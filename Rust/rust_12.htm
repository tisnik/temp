<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Práce s vektory v programovacím jazyku Rust</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Práce s vektory v programovacím jazyku Rust</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Primitivní datový typ pole (array), s&nbsp;nímž jsme se seznámili minule, neumožňuje při běhu programu přidávat či ubírat prvky. Pokud je takové chování zapotřebí, což se samozřejmě stává velmi často, lze namísto polí použít objekt typu <strong>Vec</strong> neboli vektor.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Vytvoření nového vektoru makrem <strong>vec!</strong></a></p>
<p><a href="#k02">2. Měnitelný a neměnitelný vektor</a></p>
<p><a href="#k03">3. Indexování prvků vektoru a typ <strong>usize</strong></a></p>
<p><a href="#k04">4. Získání iterátoru pro vektory a průchod všemi prvky vektoru</a></p>
<p><a href="#k05">5. Řezy (slice) vektoru</a></p>
<p><a href="#k06">6. Modifikace prvků vektoru přes slice</a></p>
<p><a href="#k07">7. Operace <strong>push</strong> a <strong>pop</strong></a></p>
<p><a href="#k08">8. Nastavení kapacity vektoru, zmenšení vektoru na základě skutečného počtu prvků</a></p>
<p><a href="#k09">9. Vytvoření nového vektoru z&nbsp;iterátoru</a></p>
<p><a href="#k10">10. Vytvoření nového vektoru z&nbsp;kolekce</a></p>
<p><a href="#k11">11. Vytvoření nového vektoru z&nbsp;objektu typu <strong>range</strong></a></p>
<p><a href="#k12">12. Vektor obsahující další vektory</a></p>
<p><a href="#k13">13. Vektor obsahující pole</a></p>
<p><a href="#k14">14. Pole obsahující vektory</a></p>
<p><a href="#k15">15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Vytvoření nového vektoru makrem <strong>vec!</strong></h2>

<p>Jak jsme se dozvěděli <a
href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/">minule</a>,
obsahuje programovací jazyk Rust podporu pro pole (<i>array</i>), která jsou
zde dokonce považována za primitivní datový typ. Připomeňme si, že pole se může
alokovat na zásobníku, překladač potřebuje znát počet prvků pole již při
překladu, z&nbsp;polí lze vytvářet řezy (<i>slices</i>), délka polí se zjišťuje
metodou <strong>len()</strong> a pro pole lze mj.&nbsp;získat i iterátor, a to
konkrétně metodou <strong>iter()</strong>.</p>

<p>V&nbsp;mnoha případech je však zapotřebí používat takové homogenní datové
struktury, u nichž je možné v&nbsp;době běhu programu měnit počet prvků,
tj.&nbsp;prvky přidávat a ubírat (navíc by všechny operace měly mít složitost
O(1)). Takovou strukturou jsou v&nbsp;programovacím jazyku Rust objekty typu
<strong>Vec</strong> nazývané vektory. Interně <strong>Vec</strong> obsahuje
několik atributů, především kapacitu vektoru, počet prvků vektoru (může být
menší než kapacita) a taktéž ukazatel na vlastní prvky, které jsou však
umístěny na haldě (dokonce <i>musí</i> být na haldě, protože překladač nezná
délku vektoru). Vektory lze vytvořit konstruktorem <strong>Vec::new()</strong>,
ovšem častěji uvidíme použití makra <strong>vec!</strong>. Podívejme se, jak
lze vytvořit vektor s&nbsp;pěti prvky, jejichž typ překladač použije pro
odvození typu vektoru. V&nbsp;příkladu je ukázáno i indexování prvků a použití
metody <strong>len()</strong> pro zjištění aktuální délky vektoru:</p>

<pre>
fn main() {
    let vector = <strong>vec![1, 2, 3, 4, 5]</strong>;
&nbsp;
    println!("vector has {} items", <strong>vector.len()</strong>);
&nbsp;
    for i in 0..vector.len() {
        println!("item #{} = {}", i+1, <strong>vector[i]</strong>);
    }
}
</pre>

<p>Výsledek běhu programu:</p>

<pre>
vector has 5 items
item #1 = 1
item #2 = 2
item #3 = 3
item #4 = 4
item #5 = 5
</pre>

<p>Alternativně je možné všechny prvky nastavit na stejnou hodnotu, a to
použitím stejné syntaxe, jakou známe z&nbsp;článku o polích &ndash;
<strong>[hodnota;počet_prvků]</strong>:</p>

<pre>
fn main() {
    let vector = <strong>vec![1; 10]</strong>;
&nbsp;
    println!("vector has {} items", <strong>vector.len()</strong>);
&nbsp;
    for i in 0..vector.len() {
        println!("item #{} = {}", i+1, <strong>vector[i]</strong>);
    }
}
</pre>

<p>Výsledek běhu programu:</p>

<pre>
vector has 10 items
item #1 = 1
item #2 = 1
item #3 = 1
item #4 = 1
item #5 = 1
item #6 = 1
item #7 = 1
item #8 = 1
item #9 = 1
item #10 = 1
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Měnitelný a neměnitelný vektor</h2>

<p>Podobně jako u polí platí, že vektory jsou implicitně neměnitelné
(<i>immutable</i>), což znamená, že ve chvíli, kdy je vektor vytvořen a
přiřazen do proměnné, už nelze měnit hodnoty jeho prvků či počet prvků.
Z&nbsp;tohoto důvodu je následující příklad nekorektní:</p>

<pre>
fn main() {
    <strong>let vector = vec![1; 10]</strong>;
&nbsp;
    println!("vector has {} items", vector.len());
&nbsp;
    print!("[");
    for i in 0..vector.len() {
        print!("{} ", vector[i]);
    }
    println!("]");
&nbsp;
    <strong>vector[5] = 100</strong>;
&nbsp;
    print!("[");
    for i in 0..vector.len() {
        print!("{} ", vector[i]);
    }
    println!("]");
}
</pre>

<p>Překlad skončí s&nbsp;chybou nalezenou na řádku, kde se pokoušíme
modifikovat prvek vektoru:</p>

<pre>
error: cannot borrow immutable local variable `vector` as mutable
  --&gt; 155_immutable_vector.rs:12:5
   |
2  |     let vector = vec![1; 10];
   |         ------ use `mut vector` here to make mutable
...
12 |     vector[5] = 100;
   |     ^^^^^^ cannot borrow mutably
&nbsp;
error: aborting due to previous error
</pre>

<p>Oprava programu je snadná &ndash; postačuje použít nám již známý modifikátor
<strong>mut</strong>, a to následovně:</p>

<pre>
fn main() {
    let <strong>mut</strong> vector = vec![1; 10];
&nbsp;
    println!("vector has {} items", vector.len());
&nbsp;
    print!("[");
    for i in 0..vector.len() {
        print!("{} ", vector[i]);
    }
    println!("]");
&nbsp;
    <strong>vector[5] = 100</strong>;
&nbsp;
    print!("[");
    for i in 0..vector.len() {
        print!("{} ", vector[i]);
    }
    println!("]");
}
</pre>

<p>Nyní je již možné příklad přeložit a spustit s&nbsp;následujícím výsledkem
(prvek byl skutečně modifikován):</p>

<pre>
vector has 10 items
[1 1 1 1 1 1 1 1 1 1 ]
[1 1 1 1 1 100 1 1 1 1 ]
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Indexování prvků vektoru a typ <strong>usize</strong></h2>

<p>Přístup k&nbsp;prvkům vektorů s&nbsp;využitím celočíselného indexu je
jednoduchý a už jsme si ho vlastně ukázali v&nbsp;předchozích příkladech. Takže
jen pro ilustraci, jak lze přistoupit ke třetímu prvku (s&nbsp;indexem rovným
dvěma):</p>

<pre>
fn main() {
    let vector = vec![1, 2, 3, 4, 5];
    let index = 2;
&nbsp;
    let item = <strong>vector[index]</strong>;
&nbsp;
    println!("vector[5] == {}", item);
}
</pre>

<p>Předchozí příklad byl přeložen v&nbsp;pořádku, ale pokud se pokusíme o
použití celočíselné konstanty některého z&nbsp;typů integer (například
<strong>i32</strong>, tedy 32bitový integer se znaménkem), dojde při překladu
k&nbsp;chybě:</p>

<pre>
fn main() {
    let vector = vec![1, 2, 3, 4, 5];
    let index = <strong>2i32</strong>;
&nbsp;
    let item = vector[index];
&nbsp;
    println!("vector[5] == {}", item);
}
</pre>

<p>Chyba při překladu:</p>

<pre>
error[E0277]: the trait bound `std::vec::Vec&lt;{integer}&gt;: std::ops::Index&lt;i32&gt;` is not satisfied
 --&gt; 158_vector_integer_index.rs:5:16
  |
5 |     let item = vector[index];
  |                ^^^^^^^^^^^^^
  |
  = note: the type `std::vec::Vec&lt;{integer}&gt;` cannot be indexed by `i32`
&nbsp;
error: aborting due to previous error
</pre>

<p>Podobně dopadneme ve chvíli, kdy specifikujeme typ proměnné obsahující
index (což je vlastně to samé):</p>

<pre>
fn main() {
    let vector = vec![1, 2, 3, 4, 5];
    let <strong>index:i32</strong> = 2;
&nbsp;
    let item = vector[index];
&nbsp;
    println!("vector[5] == {}", item);
}
</pre>

<p>Problém spočívá v&nbsp;tom, že vektory implementují trait
<strong>Index&lt;usize&gt;</strong>, aby vůbec bylo možné použít syntaxi
vektor[index_prvku]. A právě kvůli tomu je nutné pro indexaci použít hodnotu
typu <strong>usize</strong> (dokonce ani není možné použít
<strong>isize</strong>). Následující dvojice příkladů je tedy korektní:</p>

<pre>
fn main() {
    let vector = vec![1, 2, 3, 4, 5];
    let <strong>index:usize</strong> = 2;
&nbsp;
    let item = vector[index];
&nbsp;
    println!("vector[5] == {}", item);
}
</pre>

<p>Povšimněte si, že u číselných proměnných lze jejich typ přesně specifikovat
zápisem typu proměnné ihned za číselnou konstantou, která je do proměnné
přiřazována:</p>

<pre>
fn main() {
    let vector = vec![1, 2, 3, 4, 5];
    let index = <strong>2usize</strong>;
&nbsp;
    let item = vector[index];
&nbsp;
    println!("vector[5] == {}", item);
}
</pre>

<p>Poznámka: vektory ve skutečnosti implementují dva podobně pojmenované traity
<strong>Index</strong> a <strong>IndexMut</strong>. První trait se používá ve
chvíli, kdy se prvek čte, druhý se používá při zápisu (modifikaci, mutaci):</p>

<pre>
let x = vector[10];
vector[20] = x;
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Získání iterátoru pro vektory a průchod všemi prvky vektoru</h2>

<p>Podobně jako u polí lze i pro vektory získat iterátor metodou
<strong>iter()</strong>. Idiomatický zápis smyčky, v&nbsp;níž se prochází všemi
prvky vektoru, vypadá takto:</p>

<pre>
fn main() {
    let vector = vec![1, 2, 3, 4, 5];
&nbsp;
    println!("vector has {} items", vector.len());
&nbsp;
    for item in <strong>vector.iter()</strong> {
        println!("{}", item);
    }
}
</pre>

<p>Vektory mají s&nbsp;poli společnou i další vlastnost &ndash; iterátor lze
získat zápisem <strong>&amp;vektor</strong>. Přitom nedojde ke změně vlastníka
vektoru:</p>

<pre>
fn main() {
    let vector = vec![1, 2, 3, 4, 5];
&nbsp;
    println!("vector has {} items", vector.len());
&nbsp;
    for item in <strong>&amp;vector</strong> {
        println!("{}", item);
    }
}
</pre>

<p>Zatímco u polí byl předchozí zápis omezen pouze na pole s&nbsp;maximální
velikostí 32 prvků, u vektorů tomu tak není, o čemž se lze snadno
přesvědčit:</p>

<pre>
fn main() {
    let vector = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
                      1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
                      1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
                      1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
&nbsp;
    println!("vector has {} items", vector.len());
&nbsp;
    for item in <strong>&amp;vector</strong> {
        println!("{}", item);
    }
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Řezy (slice) vektoru</h2>

<p>Z&nbsp;vektorů je možné, podobně jako u polí, získat &bdquo;řezy&ldquo;
zápisem <strong>vektor[dolní_mez..horní_mez]</strong>, přičemž platí, že
v&nbsp;řezu je prvním prvkem prvek s&nbsp;indexem <strong>dolní_mez</strong> a
posledním prvkem prvek s&nbsp;indexem <strong>horní_mez-1</strong> &ndash;
teoreticky by tedy zápis řezu měl vypadat takto:
<strong>[dolní_mez..horní_mez)</strong>, to by však pravděpodobně zmátlo
textové editory, takže se tento zápis nepoužívá. Podívejme se na jednoduchý
příklad získání řezu z&nbsp;desetiprvkového vektoru:</p>

<pre>
fn main() {
    let vector = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
&nbsp;
    println!("vector has {} items", vector.len());
&nbsp;
    let slice = <strong>vector[3..7]</strong>;
&nbsp;
    println!("slice has {} items", slice.len());
&nbsp;
    for item in slice {
        println!("{}", item);
    }
}
</pre>

<p>Překlad tohoto příkladu se však nepovede:</p>

<pre>
error[E0277]: the trait bound `[{integer}]: std::marker::Sized` is not satisfied
 --&gt; 165_slice_incorrect.rs:6:9
  |
6 |     let slice = vector[3..7];
  |         ^^^^^
  |
  = note: `[{integer}]` does not have a constant size known at compile-time
  = note: all local variables must have a statically known size
</pre>

<p>Chybové hlášení je sice poněkud kryptické, ale říká nám, že překladač není
schopen odvodit velikost výsledné struktury. Pomůže nám maličkost (opět stejně
jako u polí) &ndash; použít &amp;, takže řez bude ukazovat do existujícího
vektoru:</p>

<pre>
fn main() {
    let vector = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
&nbsp;
    println!("vector has {} items", vector.len());
&nbsp;
    let slice = <strong>&amp;vector[3..7]</strong>;
&nbsp;
    println!("slice has {} items", slice.len());
&nbsp;
    for item in slice {
        println!("{}", item);
    }
}
</pre>

<p>Výsledek běhu programu:</p>

<pre>
vector has 10 items
slice has 4 items
4
5
6
7
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Modifikace prvků vektoru přes slice</h2>

<p><a
href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/nazory/906364/">V&nbsp;diskuzi</a>
u <a
href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/">předchozího
článku</a> zazněl dotaz (a správné odpovědi), jak je to s&nbsp;modifikací
původního pole přes řez. Podívejme se nyní na toto téma z&nbsp;pohledu vektorů.
Například získáme řez z&nbsp;desetiprvkového vektoru a budeme se snažit změnit
hodnotu prvku přes tento řez:</p>

<pre>
fn main() {
    let mut vector = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
&nbsp;
    println!("vector has {} items", vector.len());
&nbsp;
    let <strong>mut slice</strong> = &amp;vector[3..7];
    slice[1] = 100;
&nbsp;
    for item in &amp;vector {
        println!("{}", item);
    }
}
</pre>

<p>Proměnná <strong>slice</strong> je sice označena modifikátorem
<strong>mut</strong>, to ovšem znamená, že do proměnné lze přiřadit jiný řez a
nikoli to, že obsah samotného řezu (a tedy i vektoru) je měnitelný:</p>

<pre>
error: cannot assign to immutable indexed content `slice[..]`
 --&gt; 167_modify_via_slice_incorrect.rs:7:5
  |
7 |     slice[1] = 100;
  |     ^^^^^^^^^^^^^^
&nbsp;
error: aborting due to previous error
</pre>

<p>Následující příklad již sice správně používá <strong>&amp;mut</strong>
(tj.&nbsp;prvek vektoru lze přes řez změnit), ovšem nesmíme zapomenout na to,
že se v&nbsp;tomto případě změní i vlastník vektoru, což způsobí problém při
překladu programové smyčky:</p>

<pre>
fn main() {
    let mut vector = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
&nbsp;
    println!("vector has {} items", vector.len());
&nbsp;
    let slice = &amp;mut vector[3..7];
    slice[1] = 100;
&nbsp;
    for item in &amp;vector {
        println!("{}", item);
    }
}
</pre>

<pre>
error[E0502]: cannot borrow `vector` as immutable because it is also borrowed as mutable
  --&gt; 168_modify_via_slice_incorrect2.rs:9:18
   |
6  |     let slice = &amp;mut vector[3..7];
   |                      ------ mutable borrow occurs here
...
9  |     for item in &amp;vector {
   |                  ^^^^^^ immutable borrow occurs here
...
12 | }
   | - mutable borrow ends here
&nbsp;
error: aborting due to previous error
</pre>

<p>Jedno z&nbsp;možných řešení (či možná lépe řečeno obejití) tohoto problému
spočívá v&nbsp;omezení viditelnosti proměnné <strong>slice</strong> pomocí
programového bloku:</p>

<pre>
fn main() {
    let mut vector = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
&nbsp;
    println!("vector has {} items", vector.len());
&nbsp;
    {
        let slice = &amp;mut vector[3..7];
&nbsp;
        slice[1] = 100;
    }
&nbsp;
    for item in &amp;vector {
        println!("{}", item);
    }
}
</pre>

<p>Výsledek běhu programu:</p>

<pre>
vector has 10 items
1
2
3
4
100
6
7
8
9
10
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Operace <strong>push</strong> a <strong>pop</strong></h2>

<p>V&nbsp;úvodní kapitole jsme si řekli, že počet prvků vektoru může růst či
klesat, protože jsou podporovány dvě operace nazvané <strong>push()</strong> a
<strong>pop()</strong>, které dokážou na konec vektoru přidat nový prvek
popř.&nbsp;tento prvek odebrat. Je to umožněno díky tomu, že prvky vektoru jsou
umístěny na haldu a vektor může v&nbsp;případě potřeby růst. Pokud má vektor
dostatečnou kapacitu, mají tyto operace složitost O(1), což je samozřejmě
příjemné. Podívejme se na velmi jednoduchý příklad použití:</p>

<pre>
fn main() {
    let mut vector = vec![];
&nbsp;
    for i in 0..10 {
        <strong>vector.push(2*i)</strong>;
    }
&nbsp;
    println!("vector has {} items", vector.len());
&nbsp;
    for item in &amp;vector {
        println!("{}", item);
    }
&nbsp;
    for _ in 0..5 {
        <strong>vector.pop()</strong>;
    }
&nbsp;
    println!("-------------------------");
&nbsp;
    for item in &amp;vector {
        println!("{}", item);
    }
}
</pre>

<p>Výsledek běhu programu:</p>

<pre>
vector has 10 items
0
2
4
6
8
10
12
14
16
18
-------------------------
0
2
4
6
8
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Nastavení kapacity vektoru, zmenšení vektoru na základě skutečného počtu prvků</h2>

<p>Aby bylo přidávání prvků na konec vektoru efektivní, je zapotřebí zajistit,
aby měl vektor potřebnou kapacitu pro přidávání prvků. Pokud totiž bude
kapacita vektoru překročena, dojde k&nbsp;jejímu zvětšení, což je již
složitější operace, které se většinou budeme chtít vyhnout. V&nbsp;případě, že
je počet prvků vektoru dopředu alespoň přibližně známý, je možné vektor
vytvořit již s&nbsp;potřebnou kapacitou, a to konkrétně konstruktorem
<strong>Vec::with_capacity(počet_předalokovaných_prvků)</strong>. Pokud zadáte
příliš velkou počáteční kapacitu, bude se zbytečně alokovat paměť na haldě, na
druhou stranu se zaručí, že se vektor nebude realokovat. Kapacitu je možné
zjistit snadno metodou <strong>capacity()</strong>. Tato hodnota by měla být
větší nebo rovna hodnotě vrácené metodou <strong>len()</strong>:</p>

<pre>
fn main() {
    let mut vector = <strong>Vec::with_capacity(10)</strong>;
&nbsp;
    println!("vector has capacity for {} items", <strong>vector.capacity()</strong>);
    println!("vector has {} items", <strong>vector.len()</strong>);
&nbsp;
    for i in 0..10 {
        vector.push(2*i);
    }
&nbsp;
    println!("vector has {} items", vector.len());
&nbsp;
    for item in &amp;vector {
        println!("{}", item);
    }
&nbsp;
    for _ in 0..5 {
        vector.pop();
    }
&nbsp;
    println!("-------------------------");
&nbsp;
    for item in &amp;vector {
        println!("{}", item);
    }
}
</pre>

<p>Výsledek běhu programu:</p>

<pre>
vector has capacity for 10 items
vector has 0 items
vector has 10 items
0
2
4
6
8
10
12
14
16
18
-------------------------
0
2
4
6
8
</pre>

<p>V&nbsp;případě potřeby lze kapacitu vektoru kdykoli zmenšit na nejmenší
možnou velikost odpovídající počtu skutečně vložených prvků. Změnu velikosti
zajistí metoda <strong>shrink_to_fit()</strong>, která však provádí realokaci,
a proto ji většinou není vhodné volat příliš často:</p>

<pre>
fn main() {
    let mut vector = Vec::with_capacity(10);
&nbsp;
    println!("vector has capacity for {} items", vector.capacity());
    println!("vector has {} items", vector.len());
&nbsp;
    for i in 0..10 {
        vector.push(2*i);
    }
&nbsp;
    println!("vector has {} items", vector.len());
&nbsp;
    for item in &amp;vector {
        println!("{}", item);
    }
&nbsp;
    for _ in 0..5 {
        vector.pop();
    }
&nbsp;
    println!("-------------------------");
&nbsp;
    vector.<strong>shrink_to_fit()</strong>;
&nbsp;
    println!("vector has capacity for {} items", vector.capacity());
    println!("vector has {} items", vector.len());
&nbsp;
    for item in &amp;vector {
        println!("{}", item);
    }
}
</pre>

<p>Výsledek ukazuje, že se kapacita vektoru skutečně zmenšila na pouhých pět
prvků:</p>

<pre>
vector has capacity for 10 items
vector has 0 items
vector has 10 items
0
2
4
6
8
10
12
14
16
18
-------------------------
vector has capacity for 5 items
vector has 5 items
0
2
4
6
8
</pre>

<p>U vektorů vytvořených konstruktorem <strong>Vec::with_capacity()</strong>
dokáže překladač odvodit typ prvků z&nbsp;prvního přiřazení, což
mj.&nbsp;znamená, že následující příklad nebude přeložen, protože se do vektoru
snažíme uložit prvky nekompatibilních typů:</p>

<pre>
fn main() {
    let mut vector = Vec::with_capacity(10);
&nbsp;
    vector.push(10.0);
    vector.push(10);
&nbsp;
    println!("vector has {} items", vector.len());
}
</pre>

<p>Samozřejmě není problém zapsat typ prvků explicitně:</p>

<pre>
fn main() {
    let mut vector : Vec&lt;i8&gt; = Vec::with_capacity(10);
&nbsp;
    vector.push(10);
    vector.push(100);
    vector.push(1000);
&nbsp;
    println!("vector has {} items", vector.len());
}
</pre>

<p>Zde překladač pouze vypíše varování, že se snažíme uložit příliš velkou
hodnotu 1000 do prvku typu <strong>i8</strong>.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vytvoření nového vektoru z&nbsp;iterátoru</h2>

<p>V&nbsp;případě potřeby je možné vektor vytvořit z&nbsp;iterátoru, a to
metodou <strong>from_iter()</strong>. V&nbsp;následujícím příkladu je iterátor
tvořen sekvencí čísel od 1 do 9, v&nbsp;praxi však samozřejmě nejsme omezeni na
to, jak a čím je iterátor vytvořen (typ generovaných prvků je známý při
překladu):</p>

<pre>
use <strong>std::iter::FromIterator</strong>;
&nbsp;
fn main() {
    let vector = <strong>Vec::from_iter(1..10)</strong>;
&nbsp;
    println!("vector has {} items", vector.len());
&nbsp;
    for item in &amp;vector {
        println!("{}", item);
    }
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Vytvoření nového vektoru z&nbsp;kolekce</h2>

<p>Velmi užitečný je i další způsob převedení iterátoru či kolekce na vektor, a
to konkrétně metodou <strong>collect()</strong>. Nejprve se podívejme na převod
pole&rarr;iterátor&rarr;vektor:</p>

<pre>
fn main() {
    let array  = [1, 2, 3, 4, 5];
    let vector:Vec&lt;_&gt; = array<strong>.iter().collect()</strong>;
&nbsp;
    println!("vector has {} items", vector.len());
 &nbsp;
    for item in &amp;vector {
        println!("{}", item);
    }
}
</pre>

<p>Připomeňme si, že v&nbsp;Rustu je možné použít i funkce vyššího řádu,
například <strong>map</strong>, <strong>filter</strong>, <strong>take</strong>
či <strong>take_while</strong>, takže lze převody mezi různými kolekcemi
vyřešit funkcionálním stylem, například:</p>

<pre>
fn main() {
    let array  = [1, 2, 3, 4, 5];
    let vector:Vec&lt;_&gt; = array.iter().map(|x| x*2).collect();
&nbsp;
    println!("vector has {} items", vector.len());
&nbsp;
    for item in &amp;vector {
        println!("{}", item);
    }
}
</pre>

<p>Příklad použití kombinace <strong>take+filter+map</strong> s&nbsp;následným
převodem na vektor:</p>

<pre>
fn main() {
    let array  = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
    let vector:Vec&lt;_&gt; = array.iter()
                             .take(10)
                             .filter(|&amp;x| x % 3 ==0)
                             .map(|&amp;x| x*2)
                             .collect();
&nbsp;
    println!("vector has {} items", vector.len());
&nbsp;
    for item in &amp;vector {
        println!("{}", item);
    }
}
</pre>

<p>Samozřejmě je možné explicitně specifikovat jak typ vstupní kolekce, tak i
typ prvků vektoru:</p>

<pre>
fn main() {
    let array:[i32;15]  = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
    let vector:Vec&lt;i32&gt; = array.iter()
                             .take(10)
                             .filter(|&amp;x| x % 3 ==0)
                             .map(|&amp;x| x*2)
                             .collect();
&nbsp;
    println!("vector has {} items", vector.len());
&nbsp;
    for item in &amp;vector {
        println!("{}", item);
    }
}
</pre>

<p>Výsledkem bude:</p>

<pre>
vector has 3 items
6
12
18
</pre>

<p>Tedy prvky dělitelné třemi z&nbsp;prvních deseti prvků pole, které jsou
následně vynásobeny dvěma.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vytvoření nového vektoru z&nbsp;objektu typu <strong>range</strong></h2>

<p>Vektor je možné vytvořit i z&nbsp;objektu typu <strong>range</strong>,
zadaný rozsah však musíme uzavřít do kulatých závorek (záležitost syntaxe):</p>

<pre>
fn main() {
    let vector:Vec&lt;_&gt; = <strong>(0..10).collect()</strong>;
&nbsp;
    println!("vector has {} items", vector.len());
&nbsp;
    for item in &amp;vector {
        println!("{}", item);
    }
</pre>

<p>Povšimněte si, že jak s&nbsp;vektorem, tak i s&nbsp;poli je možné pracovat
naprosto stejným způsobem, pokud k&nbsp;nim přistupujeme přes referenci či
řez:</p>

<pre>
fn print_slice(slice :&amp;[i32]) {
    print!("[");
    for i in slice {
        print!("{} ", i);
    }
    println!("]");
}
&nbsp;
fn main() {
    let array1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    let array2 = [1; 10];
    let vector:Vec&lt;_&gt; = (0..10).collect();
&nbsp;
    print_slice(&amp;array1);
    print_slice(&amp;array2);
    print_slice(&amp;vector);
}
</pre>

<p>Výsledek běhu programu:</p>

<pre>
[0 1 2 3 4 5 6 7 8 9 ]
[1 1 1 1 1 1 1 1 1 1 ]
[0 1 2 3 4 5 6 7 8 9 ]
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vektor obsahující další vektory</h2>

<p>Poměrně často se setkáme s&nbsp;požadavkem, aby vektor obsahoval jako své
prvky další vektory. Díky typovému systému programovacího jazyka Rust je to
samozřejmě možné, protože vektory jsou plnohodnotným datovým typem. Výsledné
&bdquo;dvourozměrné vektory&ldquo; se od dvourozměrných polí odlišují jak
způsobem alokace (zásobník versus halda), tak i tím, že výsledná datová
struktura složená z&nbsp;vektorů nemusí být obdélníková, tj.&nbsp;vektory mohou
mít rozdílnou a navíc i v&nbsp;čase proměnnou délku. Podívejme se, jak se
deklaruje typ proměnné s&nbsp;vektorem obsahujícím další vektory:</p>

<pre>
let vec2:Vec&lt;Vec&lt;typ_prvků&gt;&gt;
</pre>

<p>V&nbsp;některých případech se můžeme spolehnout na typovou inferenci a typ
prvků explicitně neudávat (což použijeme v&nbsp;demonstračním příkladu):</p>

<pre>
let vec2:Vec&lt;Vec&lt;_&gt;&gt;
</pre>

<p>Při přístupu k&nbsp;prvkům lze použít běžné indexování:</p>

<pre>
println!("{}", vec2[2][1])
</pre>

<p>V&nbsp;příkladu namísto explicitního indexování použijeme iteraci přes
všechny prvky vektoru. Víme již, že prvky jsou taktéž vektory a i pro ně lze
získat iterátor, takže výpis &bdquo;vektoru vektorů&ldquo; je vlastně velmi
jednoduchý:</p>

<pre>
fn main() {
    let vec2:Vec&lt;Vec&lt;_&gt;&gt; = vec![vec![1,2,3],
                                vec![4],
                                vec![5,6,7,8,]];
&nbsp;
    println!("vector has {} items", vec2.len());
&nbsp;
    for vec1 in <strong>vec2.iter()</strong> {
        for i in <strong>vec1.iter()</strong> {
            print!("{} ", i);
        }
        println!("");
    }
&nbsp;
}
</pre>

<p>Výsledek běhu programu:</p>

<pre>
vector has 3 items
1 2 3 
4 
5 6 7 8 
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Vektor obsahující pole</h2>

<p>Možné jsou samozřejmě i další kombinace, například vektor obsahující pole.
V&nbsp;takovém případě je nutné správně zapsat datový typ prvků vektoru,
protože překladač Rustu vyžaduje znalost typů a počtu prvků polí vkládaných do
vektoru. Připomeňme si z&nbsp;předchozího článku, že typ pole se zapisuje
<strong>[typ_prvku;počet_prvků]</strong>. V&nbsp;následujícím demonstračním
příkladu je zajímavé, že samotné vnořené programové smyčky jsou vlastně totožné
s&nbsp;předchozím příkladem, protože iterátory lze použít jak u polí, tak i u
vektorů (a samozřejmě nejenom pro tyto datové struktury):</p>

<pre>
fn main() {
    let vec2:Vec&lt;<strong>[i32;3]</strong>&gt; = vec![[1,2,3],
                                 [4,5,6],
                                 [7,8,9]];
&nbsp;
    println!("vector has {} items", vec2.len());
&nbsp;
    for array in <strong>vec2.iter()</strong> {
        for i in <strong>array.iter()</strong> {
            print!("{} ", i);
        }
        println!("");
    }
}
</pre>

<p>Výsledek běhu programu:</p>

<pre>
vector has 3 items
1 2 3 
4 5 6 
7 8 9 
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Pole obsahující vektory</h2>

<p>Poslední možnou kombinací je pole obsahující vektory (první kombinaci
&ndash; pole polí &ndash; jsme si popsali již minule). Vzhledem k&nbsp;tomu, že
již víme, že typ pole se zapisuje formou
<strong>[typ_prvku;počet_prvků]</strong>, nebude pro nás žádným problémem za
<strong>typ_prvku</strong> dosadit například <strong>Vec&lt;i32&gt;</strong>
atd. Opět si povšimněte toho, že výpis obsahu takto vytvořené datové struktury
je zcela totožný, jako v&nbsp;obou předchozích příkladech:</p>

<pre>
fn main() {
    let array:<strong>[Vec&lt;i32&gt;;4]</strong> = [vec![1],
                              vec![2,3],
                              vec![4,5,6],
                              vec![7,8,9,0]];
&nbsp;
    println!("array has {} items", array.len());
&nbsp;
    for vec1 in <strong>array.iter()</strong> {
        for i in <strong>vec1.iter()</strong> {
            print!("{} ", i);
        }
        println!("");
    }
}
</pre>

<p>Takto vytvořené pole vlastně obsahuje jednoduché objekty (struktury)
s&nbsp;konstantní velikostí, které obsahují ukazatel na vlastní prvky vektoru
umístěné na haldě.</p>

<p>Výsledek běhu programu:</p>

<pre>
array has 4 items
1 
2 3 
4 5 6 
7 8 9 0 
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady byly, podobně jako ve všech
předchozích částech tohoto seriálu, uloženy do Git repositáře dostupného na
adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti
klonovat celý repositář:</p>

<table>
<tr><th>Příklad</th><th>Odkaz</th></tr>
<tr><td>153_new_vector.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/153_new_vector.rs">https://github.com/tisnik/presentations/blob/master/rust/153_new_vector.rs</a></td></tr>
<tr><td>154_new_vector_repeat_item.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/154_new_vector_repeat_item.rs">https://github.com/tisnik/presentations/blob/master/rust/154_new_vector_repeat_item.rs</a></td></tr>
<tr><td>155_immutable_vector.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/155_immutable_vector.rs">https://github.com/tisnik/presentations/blob/master/rust/155_immutable_vector.rs</a></td></tr>
<tr><td>156_mutable_vector.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/156_mutable_vector.rs">https://github.com/tisnik/presentations/blob/master/rust/156_mutable_vector.rs</a></td></tr>
<tr><td>157_vector_index.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/157_vector_index.rs">https://github.com/tisnik/presentations/blob/master/rust/157_vector_index.rs</a></td></tr>
<tr><td>158_vector_integer_index.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/158_vector_integer_index.rs">https://github.com/tisnik/presentations/blob/master/rust/158_vector_integer_index.rs</a></td></tr>
<tr><td>159_vector_integer_index2.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/159_vector_integer_index2.rs">https://github.com/tisnik/presentations/blob/master/rust/159_vector_integer_index2.rs</a></td></tr>
<tr><td>160_vector_usize_index.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/160_vector_usize_index.rs">https://github.com/tisnik/presentations/blob/master/rust/160_vector_usize_index.rs</a></td></tr>
<tr><td>161_vector_usize_index2.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/161_vector_usize_index2.rs">https://github.com/tisnik/presentations/blob/master/rust/161_vector_usize_index2.rs</a></td></tr>
<tr><td>162_foreach_vector.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/162_foreach_vector.rs">https://github.com/tisnik/presentations/blob/master/rust/162_foreach_vector.rs</a></td></tr>
<tr><td>163_foreach_ref.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/163_foreach_ref.rs">https://github.com/tisnik/presentations/blob/master/rust/163_foreach_ref.rs</a></td></tr>
<tr><td>164_foreach_large_vector.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/164_foreach_large_vector.rs">https://github.com/tisnik/presentations/blob/master/rust/164_foreach_large_vector.rs</a></td></tr>
<tr><td>165_slice_incorrect.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/165_slice_incorrect.rs">https://github.com/tisnik/presentations/blob/master/rust/165_slice_incorrect.rs</a></td></tr>
<tr><td>166_slice_correct.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/166_slice_correct.rs">https://github.com/tisnik/presentations/blob/master/rust/166_slice_correct.rs</a></td></tr>
<tr><td>167_modify_via_slice_incorrect.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/167_modify_via_slice_incorrect.rs">https://github.com/tisnik/presentations/blob/master/rust/167_modify_via_slice_incorrect.rs</a></td></tr>
<tr><td>168_modify_via_slice_incorrect2.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/168_modify_via_slice_incorrect2.rs">https://github.com/tisnik/presentations/blob/master/rust/168_modify_via_slice_incorrect2.rs</a></td></tr>
<tr><td>169_modify_via_slice_correct.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/169_modify_via_slice_correct.rs">https://github.com/tisnik/presentations/blob/master/rust/169_modify_via_slice_correct.rs</a></td></tr>
<tr><td>170_vector_push_pop.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/170_vector_push_pop.rs">https://github.com/tisnik/presentations/blob/master/rust/170_vector_push_pop.rs</a></td></tr>
<tr><td>171_vector_push_pop2.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/171_vector_push_pop2.rs">https://github.com/tisnik/presentations/blob/master/rust/171_vector_push_pop2.rs</a></td></tr>
<tr><td>172_vec_with_capacity.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/172_vec_with_capacity.rs">https://github.com/tisnik/presentations/blob/master/rust/172_vec_with_capacity.rs</a></td></tr>
<tr><td>173_vector_shrink_to_fit.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/173_vector_shrink_to_fit.rs">https://github.com/tisnik/presentations/blob/master/rust/173_vector_shrink_to_fit.rs</a></td></tr>
<tr><td>174_vector_type_incorrect.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/174_vector_type_incorrect.rs">https://github.com/tisnik/presentations/blob/master/rust/174_vector_type_incorrect.rs</a></td></tr>
<tr><td>175_vector_explicit_type.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/175_vector_explicit_type.rs">https://github.com/tisnik/presentations/blob/master/rust/175_vector_explicit_type.rs</a></td></tr>
<tr><td>176_vector_from_iter.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/176_vector_from_iter.rs">https://github.com/tisnik/presentations/blob/master/rust/176_vector_from_iter.rs</a></td></tr>
<tr><td>177_iter_collection_vector.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/177_iter_collection_vector.rs">https://github.com/tisnik/presentations/blob/master/rust/177_iter_collection_vector.rs</a></td></tr>
<tr><td>178_iter_map_collection_vector.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/178_iter_map_collection_vector.rs">https://github.com/tisnik/presentations/blob/master/rust/178_iter_map_collection_vector.rs</a></td></tr>
<tr><td>179_iter_to_vector_pipe.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/179_iter_to_vector_pipe.rs">https://github.com/tisnik/presentations/blob/master/rust/179_iter_to_vector_pipe.rs</a></td></tr>
<tr><td>180_full_type_info.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/180_full_type_info.rs">https://github.com/tisnik/presentations/blob/master/rust/180_full_type_info.rs</a></td></tr>
<tr><td>181_full_type_info.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/181_full_type_info.rs">https://github.com/tisnik/presentations/blob/master/rust/181_full_type_info.rs</a></td></tr>
<tr><td>182_vector_from_range.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/182_vector_from_range.rs">https://github.com/tisnik/presentations/blob/master/rust/182_vector_from_range.rs</a></td></tr>
<tr><td>183_vector_array_slice.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/183_vector_array_slice.rs">https://github.com/tisnik/presentations/blob/master/rust/183_vector_array_slice.rs</a></td></tr>
<tr><td>184_vector_of_vectors.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/184_vector_of_vectors.rs">https://github.com/tisnik/presentations/blob/master/rust/184_vector_of_vectors.rs</a></td></tr>
<tr><td>185_vector_of_arrays.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/185_vector_of_arrays.rs">https://github.com/tisnik/presentations/blob/master/rust/185_vector_of_arrays.rs</a></td></tr>
<tr><td>186_array_of_vectors.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/186_array_of_vectors.rs">https://github.com/tisnik/presentations/blob/master/rust/186_array_of_vectors.rs</a></td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

