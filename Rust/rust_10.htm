<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Práce s řetězci v programovacím jazyku Rust</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Práce s řetězci v programovacím jazyku Rust</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dnešním článku se budeme zabývat problematikou práce s&nbsp;řetězci. Nejedná se přitom o zcela triviální téma, protože práce s&nbsp;řetězci v&nbsp;Rustu se hned v&nbsp;několika ohledech odlišuje od ostatních céčkových programovacích jazyků.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Práce s&nbsp;řetězci v&nbsp;programovacím jazyku Rust</a></p>
<p><a href="#k02">2. Statický řetězec a jeho tisk</a></p>
<p><a href="#k03">3. Předání statického řetězce do funkce</a></p>
<p><a href="#k04">4. Úplná deklarace statického řetězce</a></p>
<p><a href="#k05">5. Modifikace proměnné typu <strong>&amp;str</strong></a></p>
<p><a href="#k06">6. Statický řetězec jako návratový typ funkce</a></p>
<p><a href="#k07">7. Typ <strong>String</strong>: řetězec umístěný na haldě</a></p>
<p><a href="#k08">8. Problematika vlastnictví proměnné typu <strong>String</strong></a></p>
<p><a href="#k09">9. Korektní řešení &ndash; dereference proměnné typu <strong>String</strong></a></p>
<p><a href="#k10">10. Spojování řetězců</a></p>
<p><a href="#k11">11. Jak spojit dva řetězce typu <strong>String</strong></a></p>
<p><a href="#k12">12. Převod řetězce na sekvenci bajtů a znaků</a></p>
<p><a href="#k13">13. Získání podřetězce &bdquo;krájením&ldquo;</a></p>
<p><a href="#k14">14. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Práce s&nbsp;řetězci v&nbsp;programovacím jazyku Rust</h2>

<p>Pozorný čtenář si možná všiml, že jsme se prozatím v&nbsp;seriálu o
programovacím jazyku Rust nezabývali způsobem práce s&nbsp;řetězci. To sice
může být poněkud překvapivé, protože se jedná o základní součást prakticky
všech programovacích jazyků, ale ve skutečnosti má v&nbsp;Rustu význam se prací
s&nbsp;řetězci začít zabývat až ve chvíli, kdy rozumíme dalším problematikám,
především použitím referencí, použitím měnitelných a neměnitelných proměnných,
vlastnictvím objektů a taktéž způsobem alokace objektů na haldě. V&nbsp;této
chvíli jsme se již všemi zmíněnými problematikami &bdquo;prokousali&ldquo;,
takže známe většinu informací nutných pro efektivní práci s&nbsp;řetězci.</p>

<p>V&nbsp;programovacím jazyku Rust jsou řetězce interně ukládány
s&nbsp;využitím kódování UTF-8, což sice může znít překvapivě, ovšem přináší to
i některé výhody. Autoři tohoto jazyka správně poukazují na to, že
v&nbsp;současnosti prakticky všechny webové služby, XML soubory, velká část
HTML stránek atd. stejně kódování UTF-8 používají, takže nemá význam neustále
provádět konverzi mezi tímto kódováním a například UCS-4 (UTF-32). Navíc je při
zpracování rozsáhlých XML souborů formát UTF-8 výhodnější z&nbsp;hlediska
spotřeby operační paměti. Největší nevýhodou použití UTF-8 je nemožnost získat
a vrátit n-tý znak v&nbsp;řetězci v&nbsp;konstantním čase. Pokud by se tato
operace prováděla velmi často, lze samozřejmě použít vhodný objekt, který
například &bdquo;obaluje&ldquo; pole čtyřbajtových širokých znaků
v&nbsp;UCS-4/UTF-32.</p>

<p>Mimochodem: řešení založené na formátu UTF-16, které <i>částečně</i> používá
například Java, je vlastně polovičaté a přináší ty horší vlastnosti z&nbsp;obou
světů &ndash; znaky jsou stále ukládány v&nbsp;proměnném počtu bajtů, ale
spotřeba paměti je u běžných řetězců (konfigurační soubory, angličtina...)
v&nbsp;porovnání s&nbsp;UTF-8 dvojnásobná.</p>

<p>V&nbsp;programovacím jazyku Rust existuje hned několik datových typů
určených pro úschovu řetězců. Obecně se tyto typy rozdělují do dvou skupin
podle toho, zda se jedná o takzvanou &bdquo;slice&ldquo; variantu (sem spadají
řetězce umístěné v&nbsp;kódovém segmentu) a o řetězce obalené vhodným
kontejnerem a typicky umístěné na haldě. V&nbsp;každé skupině nalezneme čtyři
typy: řetězce s&nbsp;kódováním UTF-8, řetězce kompatibilní s&nbsp;céčkem (nutno
použít při volání céčkových knihoven), řetězce kompatibilní s&nbsp;operačním
systémem (může se jednat o typ shodný s&nbsp;předchozím) a konečně řetězce,
které mohou uchovávat cestu k&nbsp;souborům a adresářům (opět &ndash; nemusí se
nutně jednat o zcela odlišný datový typ). V&nbsp;dalším textu nás budou zajímat
především typy <strong>str</strong> a <strong>String</strong>:</p>

<table>
<tr><th>Vlastnost</th><th>Varianta &bdquo;slice&ldquo;</th><th>Varianta &bdquo;Owned&ldquo;</th></tr>
<tr><td>UTF-8 string     </td><td>str</td><td>String</td></tr>
<tr><td>Kompatibilní s C </td><td>CStr</td><td>CString</td></tr>
<tr><td>Kompatibilní s OS</td><td>OsStr</td><td>OsString</td></tr>
<tr><td>Cesta (v&nbsp;OS)</td><td>Path</td><td>PathBuf</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Statický řetězec a jeho tisk</h2>

<p>Popis práce s&nbsp;řetězci v&nbsp;programovacím jazyku Rust začneme zcela
jednoduchým příkladem, v&nbsp;němž je deklarována proměnná nazvaná
<strong>message</strong>, do které se uloží reference na konstantní řetězec.
Obsah této proměnné je následně vypsán na standardní výstup:</p>

<pre>
fn main() {
    <strong>let message = "Hello world!"</strong>;
    println!("{}", message);
}
</pre>

<p>Překlad a spuštění prvního demonstračního příkladu:</p>

<pre>
<strong>rustc 117_str.rs</strong>
<strong>./117_str</strong>
Hello world!
</pre>

<p>V&nbsp;tomto případě se do proměnné <strong>message</strong> ve skutečnosti
uloží reference na statický řetězec, který je neměnitelný a který je součástí
výsledného spustitelného binárního souboru. Konkrétně se tento řetězec nachází
v&nbsp;sekci nazvané <strong>.rodata</strong>, která má nastavená práva Exec a
Read, nikoli však Write (ostatně i proto se jedná o neměnitelný řetězec). Jen
malý důkaz, že tomu tak skutečně je:</p>

<pre>
<strong>rustc 117_str.rs</strong>
&nbsp;
<strong>objdump  -S -j .rodata 117_str | grep Hello</strong>
&nbsp;
   468c0:       48 65 6c 6c 6f 20 77 6f 72 6c 64 21                 Hello world!
</pre>

<p>Kód se tedy podobá céčkové deklaraci:</p>

<pre>
char *str = "Hello world!";
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Předání statického řetězce do funkce</h2>

<p>Vzhledem k&nbsp;tomu, že proměnná <strong>message</strong> obsahuje
&bdquo;pouze&ldquo; referenci na řetězec, můžeme jí předat do nějaké funkce, a
to dokonce tolikrát, kolikrát potřebujeme. Jinými slovy &ndash; v&nbsp;tomto
případě díky předávání referencí nedochází ke změně vlastníka objektu, takže
překladač předání povolí. Povšimněte si, že typem parametru není
<strong>str</strong>, ale skutečně <strong>&amp;str</strong>:</p>

<pre>
fn print_str(message: <strong>&amp;str</strong>) {
    println!("{}", message);
}
&nbsp;
fn main() {
    let message = "Hello world!";
    print_str(message);
    print_str(message);
    print_str(message);
}
</pre>

<p>Překlad a spuštění druhého demonstračního příkladu:</p>

<pre>
<strong>rustc 118_str_pass_to_function.rs</strong>
<strong>./118_str_pass_to_function</strong>
Hello world!
Hello world!
Hello world!
</pre>

<p>Poznámka: toto je zdaleka nejčastější způsob předávání řetězců do funkcí a
setkáme se s&nbsp;ním v&nbsp;prakticky všech skutečných aplikacích
naprogramovaných v&nbsp;Rustu. Existují i další způsoby (použití
<strong>String</strong> atd.), ale ty již nejsou tak časté.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Úplná deklarace statického řetězce</h2>

<p>Ve skutečnosti vypadá přesná deklarace datového typu statického řetězce
(interně uloženého do sekce .rodata) následovně:</p>

<pre>
&amp;'static str
</pre>

<p>a nikoli pouze:</p>

<pre>
&amp;str
</pre>

<p>Můžeme se o tom snadno přesvědčit překladem následujícího příkladu:</p>

<pre>
fn print_str(message: <strong>&amp;'static str</strong>) {
    println!("{}", message);
}
&nbsp;
fn main() {
    let message : <strong>&amp;'static str</strong> = "Hello world!";
    print_str(message);
    print_str(message);
    print_str(message);
}
</pre>

<p>Rozdíly jsou z&nbsp;hlediska programátora minimální (ve druhém případě se
může jednat o řetězec alokovaný kdekoli jinde), ovšem jak uvidíme
v&nbsp;dalších kapitolách, někdy jsme nuceni do deklarace přidat modifikátor
<strong>'static</strong>, proto se s&nbsp;tímto modifikátorem v&nbsp;některých
zdrojových kódech potkáme.</p>

<p>Překlad a spuštění třetího demonstračního příkladu:</p>

<pre>
<strong>rustc 119_str_full_declarations.rs </strong>
<strong>./119_str_full_declarations</strong>
Hello world!
Hello world!
Hello world!
</pre>

<p>Poznámka: řetězcový literál "Hello world!" je sice vždy statickým řetězcem,
ovšem ne všechny řetězce jsou statické, tj.&nbsp;existující po celou dobu běhu
programu už do jeho začátku. Tyto &bdquo;nestatické&ldquo; řetězce vznikají
například konverzí z&nbsp;objektu <strong>String</strong> popsaného níže.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Modifikace proměnné typu <strong>&amp;str</strong></h2>

<p>Pokusme se zjistit, co se stane ve chvíli, kdy se pokusíme do proměnné
přiřadit jednu referenci na řetězec a po určité době referenci druhou. U
proměnné prozatím neuvedeme žádné modifikátory, tj.&nbsp;necháme překladač, aby
sám odvodil, jakého je proměnná typu:</p>

<pre>
fn print_str(message: &amp;str) {
    println!("{}", message);
}
&nbsp;
fn main() {
    <strong>let message = "Hello world!"</strong>;
    print_str(message);
    <strong>message = "Something else"</strong>;
    print_str(message);
    print_str(message);
}
</pre>

<p>Překlad čtvrtého demonstračního příkladu nedopadne dobře, protože překladač
ohlásí chybu ve chvíli, kdy se do stejné proměnné pokusíme přiřadit jinou
referenci:</p>

<pre>
<strong>rustc 120_str_attempt_to_modify.rs</strong>
&nbsp;
error[E0384]: re-assignment of immutable variable `message`
 --&gt; 120_str_attempt_to_modify.rs:8:5
  |
6 |     let message = "Hello world!";
  |         ------- first assignment to `message`
7 |     print_str(message);
8 |     message = "Something else";
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ re-assignment of immutable variable
&nbsp;
error: aborting due to previous error
</pre>

<p>Náprava je snadná; stačí si vzpomenout, že jsme podobnou problematiku řešili
již v&nbsp;úvodním článku:</p>

<pre>
// nekorektní
fn main() {
    let i = 0;
    while i&lt;10 {
        println!("pocitadlo: {}", i);
        i = i + 1;
    }
}
&nbsp;
// korektní
fn main() {
    let <strong>mut</strong> i = 0;
    while i&lt;10 {
        println!("pocitadlo: {}", i);
        i = i + 1;
    }
}
</pre>

<p>Pokusme se tedy použít modifikátor <strong>mut</strong>:</p>

<pre>
fn print_str(message: &amp;str) {
    println!("{}", message);
}
&nbsp;
fn main() {
    let <strong>mut</strong> message = "Hello world!";
    print_str(message);
    message = "Something else";
    print_str(message);
    print_str(message);
}
</pre>

<p>Překlad i spuštění pátého demonstračního příkladu již proběhne
v&nbsp;pořádku:</p>

<pre>
<strong>rustc 121_str_mutable.rs</strong>
<strong>./121_str_mutable </strong>
Hello world!
Something else
Something else
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Statický řetězec jako návratový typ funkce</h2>

<p>Práce s&nbsp;řetězci pravděpodobně až do této chvíle není nijak překvapivá,
pouze si stačí uvědomit, že pracujeme s&nbsp;referencemi na neměnitelné řetězce
představované typem &amp;str. Zajímavější problém nastane ve chvíli, kdy budeme
potřebovat z&nbsp;nějaké funkce vrátit řetězec. Zkusme nejdříve aplikovat až
doposud získané znalosti a vytvořit funkci vracející &amp;str:</p>

<pre>
fn print_str(message: &amp;str) {
    println!("{}", message);
}
&nbsp;
fn return_str() <strong>-&gt; &amp;str</strong> {
    "Hello world!"
}
&nbsp;
fn main() {
    let message = return_str();
&nbsp;
    print_str(message);
}
</pre>

<p>V&nbsp;tomto případě se překlad nezdaří, i když z&nbsp;první části chybového
hlášení nemusí být zcela zřejmé, proč tomu tak je. Problém spočívá v&nbsp;tom,
že řetězec vrácený z&nbsp;funkce nemá zajištěnu životnost mimo oblast platnosti
této funkce (obecně jsou totiž všechny hodnoty vytvářeny na zásobníku, i když
v&nbsp;případě řetězců je to poněkud složitější):</p>

<pre>
error[E0106]: missing lifetime specifier
 --&gt; 122_str_return_error.rs:5:20
  |
5 | fn return_str() -&gt; &amp;str {
  |                    ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
&nbsp;
error: aborting due to previous error
</pre>

<p>Druhá část chybového hlášení je již z&nbsp;uživatelského hlediska mnohem
přívětivější, protože nám přímo radí, co musíme udělat. Je nutné uvést nám již
známý modifikátor 'static označující takovou hodnotu, která sice existuje po
celou dobu běhu programu, ovšem nejedná se o globální proměnnou (ostatně stačí
si vzpomenout na statické proměnné v&nbsp;céčku s&nbsp;velmi podobným významem.
Druhá varianta příkladu bude vypadat takto:</p>

<pre>
fn print_str(message: &amp;str) {
    println!("{}", message);
}
&nbsp;
fn return_str() -&gt; <strong>&amp;'static str</strong> {
    "Hello world!"
}
&nbsp;
fn main() {
    let message = return_str();
&nbsp;
    print_str(message);
}
</pre>

<p>Nyní již překlad proběhne v&nbsp;pořádku.</p>

<p>Poznámka: jedná se o jednu z&nbsp;mála situací, kdy budete muset explicitně
použít modifikátor 'static.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Typ <strong>String</strong>: řetězec umístěný na haldě</h2>

<p>Zopakujme si, že datový typ <strong>str</strong>, s&nbsp;nímž se
v&nbsp;naprosté většině případů pracuje pouze přes referenci typu
<strong>&amp;str</strong>, představuje z&nbsp;pohledu programátora neměnitelný
(<i>immutable</i>) řetězec existující v&nbsp;původní podobě buď po celou dobu
běhu programu, nebo od svého explicitního vytvoření. V&nbsp;praxi si však
s&nbsp;takto se chovajícími řetězci mnohdy nevystačíme, protože budeme
potřebovat vytvářet nové řetězce, spojovat je, měnit jejich obsah atd.
V&nbsp;takovém případě je nutné použít odlišný typ objektu, který je
v&nbsp;v&nbsp;programovacím jazyku Rust představován typem
<strong>String</strong>. Tento typ objektu obaluje řetězec alokovaný na
haldě.</p>

<p>Takový řetězec může měnit svůj obsah, může se zvětšovat, můžeme použít
přetížený operátor + atd. Samozřejmě za tyto vlastnosti musíme zaplatit, a to
konkrétně nutností alokací popř.&nbsp;realokací řetězců. Z&nbsp;tohoto důvodu
je vždy nutné se rozmyslet, zda si v&nbsp;dané části aplikace nevystačíme
s&nbsp;neměnitelnými řetězci. V&nbsp;případě potřeby je samozřejmě možné
provést konverzi mezi <strong>&amp;str</strong> a <strong>String</strong> či
naopak, převod <strong>String&rarr;&amp;str</strong> se dokonce obejde bez
alokací paměti či přesunu znaků a proto je velmi rychlý.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Problematika vlastnictví proměnné typu <strong>String</strong></h2>

<p>Objekt typu <strong>String</strong> lze vytvořit několika způsoby. Můžeme
například použít konverzi z&nbsp;konstantního řetězce s&nbsp;využitím metody
<strong>to_string()</strong>. Výsledkem bude skutečně objekt typu
<strong>String</strong>, který lze předat do proměnné, obsah této proměnné
předat do volané funkce atd.:</p>

<pre>
fn print_str(message: String) {
    println!("{}", message);
}
&nbsp;
fn main() {
    let message = "Hello world!".to_string();
    print_str(message);
}
</pre>

<p>Objekt typu <strong>String</strong> se při předávání do proměnné či do
volané funkce chová naprosto stejným způsobem, jako jakýkoli jiný objekt
(vzpomeňme například na naše komplexní čísla <strong>Complex</strong>). To
mj.&nbsp;znamená, že se předáním mění i vlastnictví objektu (<i>ownership</i>),
takže po prvním zavolání funkce <strong>print_str()</strong> již proměnná
<strong>message</strong> daný řetězec nevlastní! Můžeme se o tom snadno
přesvědčit pokusem o překlad následujícího demonstračního příkladu:</p>

<pre>
fn print_str(message: String) {
    println!("{}", message);
}
&nbsp;
fn main() {
    let message = "Hello world!".to_string();
    print_str(message);
    print_str(message);
    print_str(message);
}
</pre>

<p>Překladač oznámí chybu u druhého a třetího volání funkce
<strong>print_str</strong>. Navíc nám naznačuje, že objekty typu
<strong>String</strong> neimplementují trait <strong>Copy</strong>, což sice
může vypadat neprakticky, ale opak je pravdou, protože většinou nepotřebujeme,
aby nám překladač automaticky klonoval potenciálně obrovské bloky paměti:</p>

<pre>
error[E0382]: use of moved value: `message`
 --&gt; 124_String_not_working.rs:8:15
  |
7 |     print_str(message);
  |               ------- value moved here
8 |     print_str(message);
  |               ^^^^^^^ value used here after move
  |
  = note: move occurs because `message` has type `std::string::String`, which does not implement the `Copy` trait
&nbsp;
error[E0382]: use of moved value: `message`
 --&gt; 124_String_not_working.rs:9:15
  |
7 |     print_str(message);
  |               ------- value moved here
8 |     print_str(message);
9 |     print_str(message);
  |               ^^^^^^^ value used here after move
  |
  = note: move occurs because `message` has type `std::string::String`, which does not implement the `Copy` trait
&nbsp;
error: aborting due to 2 previous errors
</pre>

<p>Poznámka: nejedná se o nám neznámý rys jazyka, protože jsme se s&nbsp;ním
již několikrát setkali, například zde:</p>

<pre>
struct Complex {
    real: f32,
    imag: f32,
}
&nbsp;
fn print_complex(c:Complex) {
    println!("complex number: {}+{}i", c.real, c.imag);
}
&nbsp;
fn main() {
    let c1 = Complex{real:1.0, imag:2.0};
    println!("complex number: {}+{}i", c1.real, c1.imag);
    print_complex(c1);
    println!("complex number: {}+{}i", c1.real, c1.imag);
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Korektní řešení &ndash; dereference proměnné typu <strong>String</strong></h2>

<p>Výše zmíněný problém má ve skutečnosti velmi snadné řešení,
resp.&nbsp;přesněji řečeno dokonce dvě řešení. První řešení spočívá ve
vytvoření kopie řetězce, což však většinou nechceme a ani nepotřebujeme. Druhé
řešení spočívá v&nbsp;předání <i>reference</i> na objekt typu
<strong>String</strong>, takže se vlastnictví nezmění. Referenci umíme získat
&ndash; použije se zápis &amp;proměnná. Výsledkem je nám již známý typ
<strong>&str</strong> (nejedná se přitom o žádnou magii, ale o explicitní
implementaci traitu <strong>Deref</strong>. Vzhledem k&nbsp;tomu, že konverze
<strong>String&rarr;&amp;str</strong> je velmi rychlá (prakticky zadarmo),
používá se velmi často, což je ostatně důvod platnosti výše uvedeného tvrzení,
že se prakticky v&nbsp;každé aplikaci setkáme s&nbsp;funkcemi akceptujícími
parametr/parametry typu &amp;str.</p>

<p>Upravený příklad vypadá takto:</p>

<pre>
fn print_str(message: &amp;str) {
    println!("{}", message);
}
&nbsp;
fn main() {
    let message = "Hello world!".to_string();
    print_str(&amp;message);
    print_str(&amp;message);
    print_str(&amp;message);
}
</pre>

<p>Překlad a spuštění:</p>

<pre>
<strong>rustc 125_String_to_str_coercion.rs </strong>
<strong>./125_String_to_str_coercion </strong>
Hello world!
Hello world!
Hello world!
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Spojování řetězců</h2>

<p>Vzhledem k&nbsp;tomu, že objekty typu <strong>String</strong> obsahují
měnitelné řetězce, nebude velkým překvapením, že existuje několik pomocných
metod, například <strong>insert_str()</strong>, <strong>push_str()</strong>,
<strong>trim()</strong>, <strong>trim_left()</strong> či
<strong>trim_right()</strong> určených pro modifikaci řetězců. Navíc je pro
objekty typu <strong>String</strong> přetížen operátor +, který dovoluje
připojit další řetězec (typu <strong>str</strong>
resp.&nbsp;<strong>&amp;str</strong>). Podívejme se na jednoduchý příklad:</p>

<pre>
fn print_str(message: &amp;str) {
    println!("{}", message);
}
&nbsp;
fn main() {
    let mut message = "Hello world!".to_string();
    print_str(&amp;message);
    message.push_str("\n42");
    print_str(&amp;message);
    message = message + "\n***";
    print_str(&amp;message);
}
</pre>

<p>Překlad a spuštění tohoto příkladu dopadne podle očekávání:</p>

<pre>
<strong>rustc 126_String_concatenation.rs </strong>
<strong>./126_String_concatenation </strong>
Hello world!
Hello world!
42
Hello world!
42
***
</pre>

<p>Poznámka: každá z&nbsp;výše zmíněných metod končících na
<strong>_str</strong> existuje i ve variantě bez této přípony. Ovšem
v&nbsp;tomto případě se k&nbsp;řetězci připojuje jediný znak typu
<strong>char</strong>. Příkladem mohou být metody <strong>insert()</strong> a
<strong>insert_str()</strong>, přičemž první metoda slouží k&nbsp;přidání znaku
na určenou pozici, zatímco metoda druhá slouží k&nbsp;přidání řetězce (typu
&amp;str).</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Jak spojit dva řetězce typu <strong>String</strong></h2>

<p>Z&nbsp;předchozí kapitoly již víme, že pomocí operátoru + můžeme
k&nbsp;řetězci obaleném objektem typu <strong>String</strong> přidat řetězec
typu &amp;str;. Na druhou stranu ovšem není možné + použít pro spojení dvou
<strong>String</strong>ů, o čemž se ostatně můžeme snadno přesvědčit:</p>

<pre>
fn print_str(message: &amp;str) {
    println!("{}", message);
}
&nbsp;
fn main() {
    let message1 : String = "Hello".to_string();
    let message2 : String = "world".to_string();
&nbsp;
    print_str(&amp;message1);
    print_str(&amp;message2);
&nbsp;
    let message = message1 + " " + <strong>message2</strong> + "!";
&nbsp;
    print_str(&amp;message);
</pre>

<p>Překladač ohlásí chybu při pokusu o připojení druhého
<strong>String</strong>u:</p>

<pre>
error[E0308]: mismatched types
  --&gt; 127_String_concatenation_2.rs:12:36
   |
12 |     let message = message1 + " " + message2 + "!";
   |                                    ^^^^^^^^ expected &amp;str, found struct `std::string::String`
   |
   = note: expected type `&amp;str`
   = note:    found type `std::string::String`
&nbsp;
error: aborting due to previous error
</pre>

<p>Řešení je velmi snadné &ndash; musíme použít referenci na objekt typu
<strong>String</strong> pomocí operátoru &amp;:</p>

<pre>
fn print_str(message: &amp;str) {
    println!("{}", message);
}
&nbsp;
fn main() {
    let message1 : String = "Hello".to_string();
    let message2 : String = "world".to_string();
&nbsp;
    print_str(&amp;message1);
    print_str(&amp;message2);
&nbsp;
    let message = message1 + " " + <strong>&amp;message2</strong> + "!";
&nbsp;
    print_str(&amp;message);
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Převod řetězce na sekvenci bajtů a znaků</h2>

<p>Vzhledem k&nbsp;tomu, že řetězce jsou interně ukládány v&nbsp;kódování
UTF-8, můžeme se na ně dívat dvěma pohledy. Buď se jedná o sekvenci bajtů nebo
o sekvenci znaků, přičemž obecně může být znaků méně než bajtů (všechny znaky
kromě základních znaků ASCII jsou reprezentovány větším množstvím bajtů). Opět
si to můžeme snadno vyzkoušet, protože pro objekt typu <strong>String</strong>
existují metody vracející iterátory umožňující procházet řetězcem po bajtech i
po znacích:</p>

<pre>
fn print_str(message: &amp;str) {
    println!("{}", message);
}
&nbsp;
fn main() {
    let message = "Hello world!";
&nbsp;
    for byte in message.as_bytes() {
        println!("{}", byte);
    }
&nbsp;
    for char in message.chars() {
        println!("{}", char);
    }
&nbsp;
    print_str(message);
}
</pre>

<p>Po spuštění získáme následující výstup naznačující, že počet ASCII znaků se
v&nbsp;tomto případě rovná počtu bajtů, kterými jsou znaky reprezentovány:</p>

<pre>
72
101
108
108
111
32
119
111
114
108
100
33
H
e
l
l
o
 
w
o
r
l
d
!
Hello world!
</pre>

<p>Zkusme nyní tuzemská nabodeníčka:</p>

<pre>
fn print_str(message: &amp;str) {
    println!("{}", message);
}
&nbsp;
fn main() {
    let message = "ěščř";
&nbsp;
    for byte in message.as_bytes() {
        println!("{}", byte);
    }
&nbsp;
    for char in message.chars() {
        println!("{}", char);
    }
&nbsp;
    print_str(message);
}
</pre>

<p>Zde je již patrné, že řetězec je uložen v&nbsp;osmi bajtech a přitom
představuje čtyři znaky:</p>

<pre>
196
155
197
161
196
141
197
153
ě
š
č
ř
ěščř
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Získání podřetězce &bdquo;krájením&ldquo;</h2>

<p>Vzhledem k&nbsp;výše uvedenému rozdílu při chápání řetězců jako sekvence
bajtů či znaků jazyk Rust <i>nepodporuje</i> přímé indexování znaků
v&nbsp;řetězci (typu &amp;str). Ovšem, což je poměrně zajímavé, je podporováno
získání podřetězce zápisem <strong>proměnná[from..to]</strong>, přičemž
<i>from</i> a <i>to</i> jsou indexy <strong>bajtů</strong> nikoli
<strong>znaků</strong>. To může být dosti matoucí a může dokonce docházet
k&nbsp;běhovým chybám, když se &bdquo;trefíme&ldquo; do bajtu uprostřed znaku.
Ukažme si způsob použití:</p>

<pre>
fn print_str(message: &amp;str) {
    println!("'{}'", message);
}
&nbsp;
fn main() {
    let message = "Hello world!";
&nbsp;
    let part1 = &amp;message[0..5]; // pet znaku 0,1,2,3 a 4
    let part2 = &amp;message[5..6]; // jeden znak, to je "krome"
    let part3 = &amp;message[6..12];
&nbsp;
    print_str(part1);
    print_str(part2);
    print_str(part3);
}
</pre>

<p>Po spuštění se vypíše:</p>

<pre>
'Hello'
' '
'world!'
</pre>

<p>Výsledkem &bdquo;krájení&ldquo; je opět řetězec typu str, takže lze napsat i
tento kód:</p>

<pre>
fn print_str(message: &amp;str) {
    println!("'{}'", message);
}
&nbsp;
fn main() {
    let message = "Hello world!";
&nbsp;
    let part = &amp;message[0..10][2..5];
    print_str(part);
}
</pre>

<p>S&nbsp;výsledkem &bdquo;llo&ldquo;.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady byly, podobně jako ve všech
předchozích částech tohoto seriálu, uloženy do Git repositáře dostupného na
adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti
klonovat celý repositář:</p>

<table>
<tr><th>Příklad</th><th>Odkaz</th></tr>
<tr><td>117_str.rs                   </td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/117_str.rs">https://github.com/tisnik/presentations/blob/master/rust/117_str.rs</a></td></tr>
<tr><td>118_str_pass_to_function.rs  </td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/118_str_pass_to_function.rs">https://github.com/tisnik/presentations/blob/master/rust/118_str_pass_to_function.rs</a></td></tr>
<tr><td>119_str_full_declarations.rs </td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/119_str_full_declarations.rs">https://github.com/tisnik/presentations/blob/master/rust/119_str_full_declarations.rs</a></td></tr>
<tr><td>120_str_attempt_to_modify.rs </td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/120_str_attempt_to_modify.rs">https://github.com/tisnik/presentations/blob/master/rust/120_str_attempt_to_modify.rs</a></td></tr>
<tr><td>121_str_mutable.rs           </td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/121_str_mutable.rs">https://github.com/tisnik/presentations/blob/master/rust/121_str_mutable.rs</a></td></tr>
<tr><td>122_str_return_error.rs      </td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/122_str_return_error.rs">https://github.com/tisnik/presentations/blob/master/rust/122_str_return_error.rs</a></td></tr>
<tr><td>123_str_return_working.rs    </td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/123_str_return_working.rs">https://github.com/tisnik/presentations/blob/master/rust/123_str_return_working.rs</a></td></tr>
<tr><td>124_String_not_working.rs    </td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/124_String_not_working.rs">https://github.com/tisnik/presentations/blob/master/rust/124_String_not_working.rs</a></td></tr>
<tr><td>125_String_to_str_coercion.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/125_String_to_str_coercion.rs">https://github.com/tisnik/presentations/blob/master/rust/125_String_to_str_coercion.rs</a></td></tr>
<tr><td>126_String_concatenation.rs  </td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/126_String_concatenation.rs">https://github.com/tisnik/presentations/blob/master/rust/126_String_concatenation.rs</a></td></tr>
<tr><td>127_String_concatenation_2.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/127_String_concatenation_2.rs">https://github.com/tisnik/presentations/blob/master/rust/127_String_concatenation_2.rs</a></td></tr>
<tr><td>128_String_concatenation_3.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/128_String_concatenation_3.rs">https://github.com/tisnik/presentations/blob/master/rust/128_String_concatenation_3.rs</a></td></tr>
<tr><td>129_str_indexing.rs          </td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/129_str_indexing.rs">https://github.com/tisnik/presentations/blob/master/rust/129_str_indexing.rs</a></td></tr>
<tr><td>130_str_slice.rs             </td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/130_str_slice.rs">https://github.com/tisnik/presentations/blob/master/rust/130_str_slice.rs</a></td></tr>
<tr><td>131_str_slice_from_slice.rs  </td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/131_str_slice_from_slice.rs">https://github.com/tisnik/presentations/blob/master/rust/131_str_slice_from_slice.rs</a></td></tr>
</table>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

