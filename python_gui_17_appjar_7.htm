<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Tvorba GUI v Pythonu: použití želví grafiky společně s knihovnou appJar</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Tvorba GUI v Pythonu: použití želví grafiky společně s knihovnou appJar</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V závěrečném článku o knihovně appJar sloužící ke snadné tvorbě GUI si ukážeme, jak lze propojit appJar s modulem Turtle, který v Pythonu implementuje takzvanou želví grafiku. Spojení Python+Turtle+appJar se může stát ideální kombinací pro výuku programování.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Tvorba GUI v&nbsp;Pythonu: použití želví grafiky společně s&nbsp;knihovnou appJar</a></p>
<p><a href="#k02">2. Úvodní informace o programovacím jazyku Logo</a></p>
<p><a href="#k03">3. Želví grafika</a></p>
<p><a href="#k04">4. Kombinace knihoven <i>appJar</i> a <i>turtle</i></a></p>
<p><a href="#k05">5. Vytvoření a zobrazení jednoduchého obrazce vytvořeného přes modul <i>turtle</i></a></p>
<p><a href="#k06">6. První demonstrační příklad</a></p>
<p><a href="#k07">7. Urychlení vykreslování &ndash; obnovení obsahu plátna až po 100 operacích</a></p>
<p><a href="#k08">8. Explicitní obnovení obrazovky na konci kreslení</a></p>
<p><a href="#k09">9. Želví grafika a složitější obrazec</a></p>
<p><a href="#k10">10. Použití rekurze pro vykreslení sněhové vločky Helge von Kocha</a></p>
<p><a href="#k11">11. Rekurzivní kreslení domku aneb Pythagorův strom</a></p>
<p><a href="#k12">12. Zobecněný Pythagorův strom</a></p>
<p><a href="#k13">13. Příkaz <strong>goto</strong> a jeho využití při kreslení na absolutní souřadnice plátna</a></p>
<p><a href="#k14">14. Fresnelův fraktál</a></p>
<p><a href="#k15">15. Systémy iterovaných funkcí (IFS)</a></p>
<p><a href="#k16">16. Vykreslení jednoduchého systému iterovaných funkcí krok za krokem</a></p>
<p><a href="#k17">17. Zdrojový kód příkladu pro vykreslení IFS</a></p>
<p><a href="#k18">18. Demonstrační příklad: galerie IFS, výběr a vykreslení vybraného IFS</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Tvorba GUI v&nbsp;Pythonu: použití želví grafiky společně s&nbsp;knihovnou appJar</h2>

<p>Vzhledem k&nbsp;tomu, že knihovna <i>appJar</i> byla navržena takovým
způsobem, aby ji bylo možné použít při výuce programování (včetně návrhů GUI),
se nabízí otázka, zda by nebylo možné nějakým způsobem spojit hned tři
technologie používané na školách &ndash; programovací jazyk Python, knihovnu
<i>appJar</i> a taktéž knihovnu <i>turtle</i> [<a
href="https://docs.python.org/3.5/library/turtle.html">1</a>], která
v&nbsp;Pythonu zajišťuje přístup k&nbsp;takzvané &bdquo;želví grafice&ldquo;
(<i>turtle graphics</i>), která byla nedílnou součástí programovacího jazyka
Logo.</p>

<div class="rs-tip-minor"><p>Poznámka: Python se pro potřeby výuky dnes používá
dokonce <a
href="https://mitpress.mit.edu/books/introduction-computation-and-programming-using-python">i
na MIT</a>, kde nahradil Scheme, což byla změna, která <a
href="https://www.wisdomandwonder.com/link/2110/why-mit-switched-from-scheme-to-python">byl
přijata s&nbsp;rozpaky</a>.</p></div>

<p>V&nbsp;navazující kapitole si řekneme základní informace o programovacím
jazyku Logo i o želví grafice. Pokud vás ovšem primárně zajímá způsob integrace
knihoven <i>appJar</i> a <i>turtle</i> v&nbsp;jediné aplikaci, klidně přeskočte
přímo <a href="#k04">na čtvrtou kapitolu</a>. Pokud vás naopak zaujme Logo,
můžete si přečíst poněkud starší <a
href="http://www.root.cz/serialy/letni-skola-programovaciho-jazyka-logo/">seriál</a>,
který na Rootu o tomto jazyku a jeho různých implementacích vyšel.</p>

<a href="http://i.iinfo.cz/images/402/lang-01-a-9.jpg"><img src="http://i.iinfo.cz/images/402/lang-01-a-9-prev.jpg" width="361" height="270" alt=" " /></a>
<p><i>Obrázek 1: Historický screenshot pořízený v&nbsp;jedné z&nbsp;prvních
verzí programovacího jazyka Logo.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Úvodní informace o programovacím jazyku Logo</h2>

<p>Historicky jedním z&nbsp;prvních programovacích jazyků, který byl vyvinut
s&nbsp;ohledem na snadnou a efektivní výuku programování, je jazyk <i>Logo</i>,
jehož první verze vznikla již v&nbsp;roce 1967, tj.&nbsp;o celé desetiletí
dříve, než začaly být dostupné první typy domácích osmibitových počítačů,
jejichž vliv na výuku programování je značný. Někteří lidé sice považují tento
jazyk za pouhou dětskou hračku (určitou obdobu počítačových her), ovšem ve
skutečnosti se jedná o velmi zajímavý koncept, který je neustále zdokonalován a
používán, zejména na základních ale i středních školách, kde je využíván jak
pro výuku algoritmizace, tak i jako pomůcka při názorné výuce geometrie.</p>

<img src="http://i.iinfo.cz/images/402/lang-01-a-4.png" width="272" height="540" alt="&nbsp;" />
<p><i>Obrázek 2: UCB Logo je jedním z&nbsp;představitelů tradičních
interpretrů jazyka Logo, vybavený systémem pro práci se želví grafikou. Tento
interpret je dostupný pro většinu platforem, samozřejmě včetně Linuxu.</i></p>

<p>Programovací jazyk <i>Logo</i> je postaven na takzvané <i>konstruktivní
vzdělávací filozofií</i> a je navržen k&nbsp;podpoře <i>konstruktivního
učení</i>. Konstruktivismus vysvětluje znalosti a dovednosti, jak jsou
vytvořeny žáky v&nbsp;jejich vlastních myslích, prostřednictvím vzájemné
interakce s&nbsp;jinými lidmi a okolím. Tato zajímavá teorie je spojena
především se švýcarským psychologem <a
href="https://en.wikipedia.org/wiki/Jean_Piaget">Jeanem Piagetem</a>, který
strávil mnoho času studováním a zdokumentováním procesu učení malých dětí.
S&nbsp;Piagetem spolupracoval i <a
href="https://en.wikipedia.org/wiki/Seymour_Papert">Seymour Papert</a>, který
později stál u vzniku Loga.</p>

<img src="http://i.iinfo.cz/images/402/lang-01-a-5.png" width="400" height="400" alt="&nbsp;" />
<p><i>Obrázek 3: Obrazec vzniklý pomocí želví grafiky a programu obsahujícího
dvojici vnořených programových smyček typu &bdquo;repeat&ldquo;.</i></p>

<p>Z&nbsp;programátorského hlediska je programovací jazyk <i>Logo</i> postaven
na podobných principech jako například jazyk <i>LISP</i> (ostatně není bez
zajímavosti, že první verze <i>Loga</i> byla implementována právě
v&nbsp;<i>LISPu</i>), ovšem jeho syntaxe je odlišná, což v&nbsp;případě
<i>Loga</i> vede k&nbsp;tvorbě čitelnějších programů, které se vizuálně
odlišují od Lispovského &bdquo;lesa závorek&ldquo;. Navíc se matematické a
logické výrazy v&nbsp;<i>Logu</i> zapisují v&nbsp;infixové podobě, na rozdíl od
formy prefixové používané <i>LISPem</i>. Tvorba programů v&nbsp;<i>Logu</i>
vede žáky k&nbsp;dekompozici problému na jednodušší podproblémy, ale i
k&nbsp;opačnému postupu &ndash; tvorbě nových slov (což jsou pouze jinak
pojmenované funkce), kterými se repertoár dostupných příkazů (slovník) postupně
rozšiřuje &ndash; jazyk se &bdquo;učí&ldquo; novým příkazům.</p>

<p>Příklady zápisu programu používajícího programovou smyčku
<strong>repeat</strong>, dále zmíněnou želví grafiku a definici nových slov
příkazem <strong>to</strong>:</p>

<pre>
to kruznice :krok
    repeat 360 [
        forward :krok
        left 1
    ]
end
&nbsp;
to kvet :pocet
    repeat :pocet [
        kruznice 1
        left 360/:pocet
    ]
end
&nbsp;
draw
kvet 10
</pre>

<img src="http://i.iinfo.cz/images/402/lang-01-a-6.png" width="400" height="389" alt="&nbsp;" />
<p><i>Obrázek 4: Ukázka použití želví grafiky v&nbsp;Logu.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Želví grafika</h2>

<p>Jednou z&nbsp;nejznámějších a pro výuku algoritmizace taktéž
nejužitečnějších vlastností programovacího jazyka <i>Logo</i> je takzvaná
<strong>želví grafika</strong>, anglicky <strong>turtle graphics</strong>.
Právě želví grafika velkou mírou přispěla k&nbsp;poměrně značné oblíbenosti a
také rozšíření tohoto programovacího jazyka, především v&nbsp;zahraničním
školství. V&nbsp;USA se zpočátku <i>Logo</i> šířilo spolu s&nbsp;počítačem
Apple II a později Commodore C64 i Apple Macintosh, zatímco v&nbsp;Evropě se
děti poprvé s&nbsp;<i>Logem</i> seznámily na domácích osmibitových počítačích,
především na Atari, Spectru, v&nbsp;tuzemsku na PMD, Didaktiku, IQ 151 atd.</p>
Pojďme si nyní říci základní informace o této zajímavé součásti <i>Loga</i> a
také o začlenění želví grafiky do dalších programovacích jazyků a aplikací.</p>

<img src="http://i.iinfo.cz/images/402/lang-01-a-7.jpg" width="450" height="435" alt=" " />
<p><i>Obrázek 5: Další ukázka možností želví grafiky.</i></p>

<p>Základem želví grafiky je virtuální želva (<i>turtle</i>), která se na
základě poměrně malé množiny příkazů dodávaných napsaným programem (skriptem)
či přímo pomocí interaktivního zápisu příkazů, pohybuje po obrazovce a přitom
za sebou vykresluje stopu složenou z&nbsp;úseček. Tato virtuální želva se tedy
chová podobně jako reálná želva, která se pohybuje po hladké pískové pláži a
zanechává za sebou stopu. Původní <i>Logo</i> nedisponovalo pouze virtuální
(vykreslovanou) želvou, ale skutečným malým robotem ve tvaru želvy, který byl
radiovým spojením propojen s&nbsp;řídicím počítačem a reagoval na základní
příkazy: pohyb vpřed, pohyb vzad, otočení doleva a otočení doprava. Navíc uměl
tento robot reagovat i na jeden &bdquo;multimediální&ldquo; příkaz &ndash;
zapnutí zvonku. Je zřejmé, že pro výuku malých dětí je pohybující se reálný
předmět mnohem zajímavější než pouhý obrázek, na druhou stranu však byl (prý)
pohyb robota poměrně nepřesný, zejména při otáčení (což dnes již není problém,
ostatně řiditelných a programovatelných robotů dnes existuje velké
množství).</p>

<img src="http://i.iinfo.cz/images/402/lang-01-a-8.jpg" width="450" height="435" alt=" " />
<p><i>Obrázek 6: Při tvorbě tohoto obrázku se, na rozdíl od obrázků
předchozích, již musely používat proměnné. Ovšem zajímavé je, že v&nbsp;Logu je
možné programovat poměrně dlouho bez znalosti proměnných (protože jedinou
&bdquo;stavovou proměnnou&ldquo; je pozice a orientace želvy).</i></p>

<p>Dnešní implementace programovacího jazyka <i>Logo</i> většinou (kromě
několika komerčních distribucí, například LEGO/Loga a několika amatérských
projektů) touto možností již nedisponují, takže se budeme muset spokojit
s&nbsp;virtuální želvou pohybující se na obrazovce. V&nbsp;některých
implementacích Loga je želva zobrazena poměrně reálným obrázkem želvy viděné
z&nbsp;ptačí perspektivy (jedná se například o Atari Logo, Commenius Logo,
Imagine i dnes zmíněný modul <i>turtle</i>), většinou se však na obrazovce
zobrazuje pouhý rovnoramenný trojúhelník, podobně jako ve hrách typu Xpilot
nebo Asteroids. Jednotlivé implementace se od sebe také liší tím, zda za sebou
želva stopu vykresluje &bdquo;hlavičkou&ldquo;, svým středem či
&bdquo;zadečkem&ldquo;.</p>

<img src="https://i.iinfo.cz/images/491/appjar7-1.png" class="image-310741" alt="&#160;" width="400" height="322" />
<p><i>Obrázek 7: Zobecněný Pythagorův strom, jehož konstrukci si popíšeme
v&nbsp;navazujících kapitolách.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Kombinace knihoven <i>appJar</i> a <i>turtle</i></h2>

<p>Želví grafika byla tak úspěšná a přitom implementačně jednoduchá, že se
začala používat i mimo samotné <i>Logo</i>. To je mj.&nbsp;případ
programovacího jazyka Python, který uživatelům nabízí standardní modul nazvaný
<i>turtle</i> (o němž jsme se ostatně již zmínili), jenž má příkazy shodné
s&nbsp;původním Logem. Modul <i>turtle</i> pro vykreslování používá
<i>Tkinter</i>, tj.&nbsp;stejnou knihovnu, jako <i>appJar</i>, takže nám zbývá
vyřešit problém, jak <i>turtle</i> a <i>appJar</i> použít společně v&nbsp;jedné
aplikaci. Skutečně to možné je, i když (alespoň prozatím) nikoli oficiálně.
Postup si ukážeme v&nbsp;dalších příkladech, v&nbsp;nichž vyřešíme i
problematiku pomalého vykreslování celé scény, které sice nevadí při
interaktivním ladění (tam naopak pomáhá), ale při kresbě složitějších obrazců
již může být zpomalení neúnosné.</p>

<a href="https://www.root.cz/obrazek/310742/"><img src="https://i.iinfo.cz/images/491/appjar7-2-prev.png" class="image-310742" alt="&#160;" width="270" height="270" /></a>
<p><i>Obrázek 8: Želví grafika vykreslená v&nbsp;aplikaci, jejíž GUI bylo
vytvořeno přes knihovnu appJar.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vytvoření a zobrazení jednoduchého obrazce vytvořeného přes modul <i>turtle</i></h2>

<p>Postup umožňující použití modulu <i>turtle</i> společně s&nbsp;knihovnou
<i>appJar</i> vychází z&nbsp;nám již známého postupu <a
href="https://www.root.cz/clanky/tvorba-gui-v-pythonu-widgety-pro-zobrazeni-grafickych-informaci-nabizene-knihovnou-appjar/#k13">popsaného
minule</a>, v&nbsp;němž se používalo kreslicí plátno knihovny <i>Tkinter</i>
neboli <i>canvas</i>. Nejprve tedy vytvoříme hlavní okno aplikace a následně na
okno vložíme nové kreslicí plátno:</p>

<pre>
app = gui()
&nbsp;
canvas = tkinter.Canvas(app.topLevel, width=256, height=256)
canvas.pack()
</pre>

<p>V&nbsp;dalším kroku získáme &bdquo;želvu&ldquo;, ovšem nikoli voláním
konstruktoru <strong>turtle.Turtle()</strong> (tím by se vytvořilo nové okno),
ale konstruktorem <strong>turtle.RawTurtle()</strong>, kterému předáme
referenci na objekt představující plátno. Dále je již možné
s&nbsp;&bdquo;želvou&ldquo; manipulovat běžným způsobem, tj.&nbsp;skrýt její
sprite, nastavit rychlost kreslení (0=nejvyšší rychlost :-) či barvu
vykreslované křivky:</p>

<pre>
t = turtle.RawTurtle(canvas)
&nbsp;
t.hideturtle()
t.speed(0)
t.pencolor("green")
</pre>

<p>Nakreslíme nějaký jednodušší obrazec, přitom nám postačí příkazy
<strong>forward</strong> a <strong>right</strong>:</p>

<pre>
side = 0
angle = 117
&nbsp;
for _ in range(160):
    <strong>t.forward</strong>(side)
    <strong>t.right</strong>(angle)
    side += 1
</pre>

<p>Příkazem <strong>forward</strong> posuneme želvou o zadaný počet jednotek
dopředu, tedy ve směru její hlavičky. V&nbsp;implicitním nastavení má území, na
kterém se želva pohybuje, rozměry 200&times;200 jednotek s&nbsp;počátkem
souřadnic uprostřed plátna. Příkazem <strong>right</strong> se želva otočí
doprava o zadaný počet stupňů (nikoli radiánů).</p>

<img src="https://i.iinfo.cz/images/491/appjar7-3.png" class="image-310743" alt="&#160;" width="256" height="256" />
<p><i>Obrázek 9: Obrazec vykreslený přes modul turtle.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. První demonstrační příklad</h2>

<p>Úplný kód dnešního prvního demonstračního příkladu, v&nbsp;němž se používá
želví grafika a výše uvedený postup pro získání kreslicího plátna, po kterém se
želva pohybuje, vypadá takto:</p>

<pre>
#!/usr/bin/env python
&nbsp;
from appJar import gui
import tkinter
import turtle
&nbsp;
&nbsp;
app = gui()
&nbsp;
&nbsp;
def onMenuItemSelect(menuItem):
    if menuItem == "Quit":
        app.stop()
&nbsp;
&nbsp;
app.setSticky("news")
&nbsp;
fileMenu = ["Quit"]
app.addMenuList("File", fileMenu, onMenuItemSelect)
&nbsp;
canvas = tkinter.Canvas(app.topLevel, width=256, height=256)
canvas.pack()
&nbsp;
t = turtle.RawTurtle(canvas)
&nbsp;
t.hideturtle()
t.speed(0)
t.pencolor("green")
&nbsp;
t.home()
t.pd()
&nbsp;
side = 0
angle = 117
&nbsp;
for _ in range(160):
    <strong>t.forward</strong>(side)
    <strong>t.right</strong>(angle)
    side += 1
&nbsp;
app.go()
</pre>

<img src="https://i.iinfo.cz/images/491/appjar7-4.png" class="image-310744" alt="&#160;" width="256" height="258" />
<p><i>Obrázek 10: Nepatrná změna počátečních hodnot <strong>side</strong> a
<strong>angle</strong> následovaná postprocessingem (zmenšení obrázku
s&nbsp;filtrací).</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Urychlení vykreslování &ndash; obnovení obsahu plátna až po 100 operacích</h2>

<p>Jediný vážnější problém předchozího příkladu spočívá v&nbsp;tom, že
vykreslování želví grafiky na kreslicí plátno je poměrně pomalé. Ostatně sami
si vyzkoušejte, jaká je doba mezi spuštěním předchozího programu a zobrazením
jeho okna s&nbsp;kresbou. Tento problém se při použití samostatného modulu
<i>turtle</i> řešil jednoduše &ndash; zavoláním metody <strong>tracer</strong>
objektu typu <strong>Screen</strong>, přičemž se v&nbsp;prvním parametru této
metody předalo celé číslo udávající počet změn, které musí ve scéně proběhnout,
než dojde k&nbsp;překreslení obrazovky. Druhý parametr udává rychlost želvy,
přičemž nula znamená nejvyšší rychlost (žádné zpoždění). To například znamená,
že pokud se zavolala metoda:</p>

<pre>
screen.tracer(100, 0)
</pre>

<p>znamená to, že k&nbsp;překreslení dojde až ve chvíli, kdy želva vykoná sto
příkazů.</p>

<p>Aby bylo možné metodu <strong>tracer</strong> zavolat, je nutné příklad
nepatrně změnit &ndash; musí se vytvořit instance třídy
<strong>TurtleScreen</strong> (s&nbsp;předáním již vytvořeného kreslicího
plátna) a při konstrukci želvy tuto instanci použít:</p>

<pre>
screen = turtle.TurtleScreen(canvas)
t = turtle.RawTurtle(screen)
screen.tracer(100, 0)
</pre>

<p>Upravený příklad vypadá takto:</p>

<pre>
#!/usr/bin/env python
&nbsp;
from appJar import gui
import tkinter
import turtle
&nbsp;
&nbsp;
app = gui()
&nbsp;
&nbsp;
def onMenuItemSelect(menuItem):
    if menuItem == "Quit":
        app.stop()
&nbsp;
&nbsp;
app.setSticky("news")
&nbsp;
fileMenu = ["Quit"]
app.addMenuList("File", fileMenu, onMenuItemSelect)
&nbsp;
canvas = tkinter.Canvas(app.topLevel, width=256, height=256)
canvas.pack()
&nbsp;
<strong>screen = turtle.TurtleScreen(canvas)</strong>
<strong>t = turtle.RawTurtle(screen)</strong>
<strong>screen.tracer(100, 0)</strong>
&nbsp;
t.hideturtle()
t.speed(0)
t.pencolor("green")
&nbsp;
t.home()
t.pd()
&nbsp;
side = 0
angle = 117
&nbsp;
for _ in range(160):
    t.forward(side)
    t.right(angle)
    side += 1
&nbsp;
app.go()
</pre>

<img src="https://i.iinfo.cz/images/491/appjar7-5.png" class="image-310745" alt="&#160;" width="256" height="256" />
<p><i>Obrázek 11: Obrazec vykreslený upraveným příkladem. Povšimněte si, že
kresba není dokončena.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Explicitní obnovení obrazovky na konci kreslení</h2>

<p>Příklad jsme sice s&nbsp;využitím instance třídy
<strong>TurtleScreen</strong> a metody <strong>tracer</strong> několikanásobně
urychlili, ovšem vyvstal nám další problém &ndash; obrazce nebudou dokresleny a
některé obrazce, které se skládají jen z&nbsp;několika čar nemusí být dokonce
vykresleny vůbec! Je to pochopitelně způsobeno tím, že posledních až 100
příkazů předaných želvě zůstane uloženo v&nbsp;bufferu a nedojde k&nbsp;jejich
skutečnému zobrazení v&nbsp;okně aplikace. Ovšem postačuje, když na konci
vykreslování, v&nbsp;našem případě konkrétně těsně před příkaz
<strong>app.go()</strong>, přidáme volání metody <strong>update</strong>, takže
systém donutíme, aby okno aplikace překreslil i se všemi změnami, které želva
na kreslicím plátně provedla:</p>

<pre>
screen.update()
</pre>

<p>Pro jistotu si ukažme, jak nyní vypadá zdrojový kód upraveného příkladu:</p>

<pre>
#!/usr/bin/env python
&nbsp;
from appJar import gui
import tkinter
import turtle
&nbsp;
&nbsp;
app = gui()
&nbsp;
&nbsp;
def onMenuItemSelect(menuItem):
    if menuItem == "Quit":
        app.stop()
&nbsp;
&nbsp;
app.setSticky("news")
&nbsp;
fileMenu = ["Quit"]
app.addMenuList("File", fileMenu, onMenuItemSelect)
&nbsp;
canvas = tkinter.Canvas(app.topLevel, width=256, height=256)
canvas.pack()
&nbsp;
screen = turtle.TurtleScreen(canvas)
t = turtle.RawTurtle(screen)
screen.tracer(100, 0)
&nbsp;
t.hideturtle()
t.speed(0)
t.pencolor("green")
&nbsp;
t.home()
t.pd()
&nbsp;
side = 0
angle = 117
&nbsp;
for _ in range(160):
    t.forward(side)
    t.right(angle)
    side += 1
&nbsp;
<strong>screen.update()</strong>
&nbsp;
app.go()
</pre>

<img src="https://i.iinfo.cz/images/491/appjar7-6.png" class="image-310746" alt="&#160;" width="256" height="256" />
<p><i>Obrázek 12: Obrazec vykreslený upraveným příkladem. Povšimněte si, že
kresba je již korektně dokreslena.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Želví grafika a složitější obrazec</h2>

<p>Samozřejmě se můžeme pokusit o vykreslení složitějšího obrazce, například
přepsáním následujícího programu z&nbsp;Loga:</p>

<pre>
repeat 36 [
    left 10
    repeat 10 [
        left 36
        forward 80
        repeat 3 [
            forward 30
            left 120
        ]
    ]
]
</pre>

<p>Do Pythonu je možné tento program přepsat (prakticky příkaz po příkazu)
například následujícím způsobem:</p>

<pre>
for i in range(36):
    t.left(10)
    for j in range(10):
        t.left(36)
        t.forward(80)
        for k in range(3):
            t.forward(30)
            t.left(120)
</pre>

<a href="https://www.root.cz/obrazek/310747/"><img src="https://i.iinfo.cz/images/491/appjar7-7-prev.png" class="image-310747" alt="&#160;" width="270" height="270" /></a>
<p><i>Obrázek 13: Výsledek předchozí sekvence příkazů provedených ve třech
vnořených programových smyčkách.</i></p>

<p>Výsledek zakomponujeme do aplikace, nyní již implicitně se
&bdquo;zrychleným&ldquo; vykreslováním a navíc s&nbsp;přidanou logikou pro
změnu barev vykreslování:</p>

<pre>
#!/usr/bin/env python
&nbsp;
from appJar import gui
import tkinter
import turtle
&nbsp;
&nbsp;
app = gui()
&nbsp;
&nbsp;
def setupTurtle(canvas):
    screen = turtle.TurtleScreen(canvas)
    t = turtle.RawTurtle(screen)
    screen.tracer(100, 0)
&nbsp;
    t.hideturtle()
    t.speed(0)
&nbsp;
    t.home()
    t.pd()
    return t, screen
&nbsp;
&nbsp;
def onMenuItemSelect(menuItem):
    if menuItem == "Quit":
        app.stop()
&nbsp;
&nbsp;
app.setSticky("news")
&nbsp;
fileMenu = ["Quit"]
app.addMenuList("File", fileMenu, onMenuItemSelect)
&nbsp;
canvas = tkinter.Canvas(app.topLevel, width=600, height=600)
canvas.pack()
&nbsp;
t, screen = setupTurtle(canvas)
&nbsp;
t.hideturtle()
t.speed(0)
t.pencolor("green")
&nbsp;
t.home()
t.pd()
&nbsp;
screen.colormode(255)
&nbsp;
r = 0
g = 0
b = 0
rd = 1
&nbsp;
for i in range(72):
    t.left(5)
    for j in range(10):
        t.left(36)
        t.forward(80)
        for k in range(3):
            r += rd
            if r &gt; 255 or r &lt; 0:
                b += 10
                g += 10
                rd = -rd
                r += rd
            t.pencolor((r, g, b))
            t.forward(30)
            t.left(120)
&nbsp;
screen.update()
&nbsp;
app.go()
</pre>

<a href="https://www.root.cz/obrazek/310748/"><img src="https://i.iinfo.cz/images/491/appjar7-8-prev.png" class="image-310748" alt="&#160;" width="270" height="270" /></a>
<p><i>Obrázek 14: Výsledek předchozího příkladu po úpravě barvy kreslení
příkazem <strong>t.pencolor</strong>.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Použití rekurze pro vykreslení sněhové vločky Helge von Kocha</h2>

<p>Mnohem silnější nástroj, než je pouhé opakování části kódu pomocí programové
smyčky <strong>for</strong>, představuje rekurze. Jedním z&nbsp;nejčastěji
ukazovaných a implementovaných rekurzivních algoritmů s&nbsp;grafickým výstupem
používajícím želví grafiku je algoritmus pro vykreslení křivky <i>Helge von
Kocha</i>, jejímž popisem jsme se již zabývali v&nbsp;seriálu <a
href="http://www.root.cz/serialy/fraktaly-v-pocitacove-grafice/">Fraktály
v&nbsp;počítačové grafice</a>. Vytváření křivky Helge von Kocha spočívá
v&nbsp;provedení následujících kroků (nejedná se o popis programu, ale
geometrické konstrukce této křivky):</p>

<ol>

<li>Nejprve se zkonstruuje vodorovná úsečka o zadané délce.</li>

<li>Ve druhém kroku se tato úsečka rozdělí na (stejně dlouhé) třetiny.
Prostřední třetina se vyjme a na jejím místě se sestrojí dvě ramena
rovnoramenného trojúhelníku. Vznikne tedy obrazec, který se skládá
z&nbsp;lomené úsečky (polyčáry), jejíž délka je rovna 4/3 délky původní úsečky,
tj.&nbsp;celková délka takto zkonstruované křivky se o třetinu prodlouží.</li>

<li>Na vzniklý obrazec se opakovaně aplikuje pravidlo uvedené v&nbsp;předchozím
bodě, tj.&nbsp;každá úsečka je rozdělena na třetiny, prostřední třetina se
vyjme a nahradí se dvojicí ramen rovnoramenného trojúhelníka.</li>

<li>Ze tří křivek lze pootočením o 120&deg; vytvořit sněhovou vločku.</li>

</ol>

<img src="https://i.iinfo.cz/images/491/appjar7-9.png" class="image-310749" alt="&#160;" width="256" height="256" />
<p><i>Obrázek 15: Sněhová vločka Helge von Kocha vykreslená z&nbsp;úseček
kratších než 10 jednotek délky.</i></p>

<p>V&nbsp;následují dvojici funkcí je ukázáno, jak lze rekurzi použít spolu
s&nbsp;želví grafikou pro vykreslení fraktální sněhové vločky <a
href="http://en.wikipedia.org/wiki/Helge_von_Koch">Helge von Kocha</a>. První
funkce vykreslí jednu třetinu vločky:</p>

<pre>
def koch_curve(t, length, limit):
    if length &gt; limit:
        koch_curve(t, length/3, limit)
        t.right(60)
        koch_curve(t, length/3, limit)
        t.left(120)
        koch_curve(t, length/3, limit)
        t.right(60)
        koch_curve(t, length/3, limit)
    else:
        t.forward(length)
</pre>

<p>O vykreslení třech navzájem pootočených třetin sněhové vločky se postará
druhá funkce:</p>

<pre>
def koch_snowflake(t, limit):
    t.home()
    t.goto(-70, -70)
    t.clear()
    t.pencolor("blue")
&nbsp;
    for _ in range(3):
        koch_curve(t, 150, limit)
        t.left(120)
</pre>

<img src="https://i.iinfo.cz/images/491/appjar7-10.png" class="image-310750" alt="&#160;" width="256" height="256" />
<p><i>Obrázek 16: Sněhová vločka Helge von Kocha vykreslená z&nbsp;úseček
kratších než 10 jednotek délky.</i></p>

<p>Alternativně je možné namísto testu na velikost úsečkových segmentů přímo
počítat, kolikrát již byla úsečka (rekurzivně) rozdělena:</p>

<p>Verze psaná v&nbsp;Logu:</p>

<pre>
to koch_curve :length :iter
    ifelse :iter&gt;1 [
        koch_curve :length/3 :iter-1
        left 60
        koch_curve :length/3 :iter-1
        right 120
        koch_curve :length/3 :iter-1
        left 60
        koch_curve :length/3 :iter-1
    ][  
        forward :length
    ]
end
</pre>

<p>Verze přepsaná do Pythonu:</p>

<pre>
def kochCurve(t, length, iter):
    if iter &gt; 1:
        kochCurve(t, length/3, iter-1)
        t.right(60)
        kochCurve(t, length/3, iter-1)
        t.left(120)
        kochCurve(t, length/3, iter-1)
        t.right(60)
        kochCurve(t, length/3, iter-1)
    else:
        t.forward(length)
</pre>

<p>Tato funkce je zakomponována do dalšího demonstračního příkladu, který vám
dává na výběr mezi vykreslením několika různých obrazců s&nbsp;využitím želví
grafiky:</p>

<pre>
#!/usr/bin/env python
# vim: set fileencoding=utf-8
&nbsp;
from appJar import gui
import tkinter
import turtle
from math import *
&nbsp;
&nbsp;
app = gui()
&nbsp;
&nbsp;
def setupTurtle(canvas):
    screen = turtle.TurtleScreen(canvas)
    t = turtle.RawTurtle(screen)
    screen.tracer(100, 0)
&nbsp;
    t.hideturtle()
    t.speed(0)
&nbsp;
    t.home()
    t.pd()
    return t, screen
&nbsp;
&nbsp;
def onMenuItemSelect(menuItem):
    if menuItem == "Quit":
        app.stop()
&nbsp;
&nbsp;
def kochCurve(t, length, iter):
    if iter &gt; 1:
        kochCurve(t, length/3, iter-1)
        t.right(60)
        kochCurve(t, length/3, iter-1)
        t.left(120)
        kochCurve(t, length/3, iter-1)
        t.right(60)
        kochCurve(t, length/3, iter-1)
    else:
        t.forward(length)
&nbsp;
&nbsp;
def kochSnowflake(t, iter):
    for _ in range(3):
        kochCurve(t, 200, iter)
        t.left(120)
&nbsp;
&nbsp;
def prepareTurtle(t):
    t.home()
    t.goto(-100, -60)
    t.clear()
&nbsp;
&nbsp;
def onKochSnowflakeSelect(command):
    prepareTurtle(t)
    t.pencolor("blue")
&nbsp;
    iter = int(command[0])
    kochSnowflake(t, iter)
    screen.update()
&nbsp;
&nbsp;
def onKochCombinationSelect(command):
    prepareTurtle(t)
&nbsp;
    colors = ["red", "orange", "blue", "brown"]
    for i in range(4):
        t.pencolor(colors[i])
        kochSnowflake(t, i+1)
&nbsp;
    screen.update()
&nbsp;
&nbsp;
app.setSticky("news")
&nbsp;
fileMenu = ["Quit"]
kochMenu = ["1 iterarion", "2 iterations", "3 iterations",
            "4 iterations", "5 iterations"]
specialMenu = ["Combine snowflakes"]
&nbsp;
app.addMenuList("File", fileMenu, onMenuItemSelect)
app.addMenuList("Koch Snowflake", kochMenu, onKochSnowflakeSelect)
app.addMenuItem("Special", "Combine snowflakes", onKochCombinationSelect)
&nbsp;
canvas = tkinter.Canvas(app.topLevel, width=256, height=256)
canvas.pack()
&nbsp;
t, screen = setupTurtle(canvas)
&nbsp;
app.go()
</pre>

<img src="https://i.iinfo.cz/images/491/appjar7-11.png" class="image-310751" alt="&#160;" width="256" height="256" />
<p><i>Obrázek 17: Sněhová vločka Helge von Kocha vykreslená z&nbsp;úseček
kratších než 5 jednotek délky.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Rekurzivní kreslení domku aneb Pythagorův strom</h2>

<p>Dalším zajímavým útvarem, který je možné vytvořit pomocí želví grafiky a
rekurzivně volané procedury (funkce), je takzvaný Pythagorův strom (tento
termín jsem objevil ve starším vydání časopisu Elektronika, v&nbsp;angličtině
pro něj existují i různá nepatrně odlišná pojmenování, například Pythagoras
tree nebo Pythagorean tree). Základem Pythagorova stromu je známý domek
kreslený jedním tahem. Pokud považujeme šířku domku a výšku jeho stěn za
základní délku, pak mají úhlopříčné tahy délku rovnou odmocnině dvou (&radic;2)
a délka stran střechy je naopak rovná převrácené hodnotě odmocnině dvou
(1/&radic;2):</p>

<pre>
def house(side):
    # základna
    t.forward(side)
    # úhlopříčka
    t.left(90+45)
    t.forward(side*math.sqrt(2))
    # stěna
    t.left(90+45)
    t.forward(side)
    # úhlopříčka
    t.left(90+45)
    t.forward(side*math.sqrt(2))
    # úsečka pod střechou
    t.left(90+45)
    t.forward(side)
    # první část střechy
    t.right(90)
    t.right(90-45)
    t.forward(side*math.cos(math.radians(45)))
    # druhá část střechy
    t.right(90)
    t.forward(side*math.sin(math.radians(45)))
    # zbývající stěna
    t.right(45)
    t.forward(side)
    t.left(90)
</pre>

<img src="https://i.iinfo.cz/images/491/appjar7-12.png" class="image-310752" alt="&#160;" width="256" height="256" />
<p><i>Obrázek 18: Domek jedním tahem vykreslený předchozí funkcí.</i></p>

<p>V&nbsp;proceduře nazvané <strong>house</strong> (domek) se šířka domku a
jeho výška předává v&nbsp;parametru <strong>side</strong>. O výpočet druhé
odmocniny se stará matematická funkce math.sqrt s&nbsp;parametrem 2.
V&nbsp;případě, že se vykreslení každé strany střechy nahradí rekurzivně
volanou procedurou pro kreslení celého domku, získáme charakteristický tvar
vzdáleně podobný stromu či keři:</p>

<pre>
def house(side):
    # základna
    t.forward(side)
    # úhlopříčka
    t.left(90+45)
    t.forward(side*math.sqrt(2))
    # stěna
    t.left(90+45)
    t.forward(side)
    # úhlopříčka
    t.left(90+45)
    t.forward(side*math.sqrt(2))
    # úsečka pod střechou
    t.left(90+45)
    t.forward(side)
    # první část střechy
    t.right(90)
    t.right(90-45)
    <strong>house(side*math.cos(math.radians(45)))</strong>
    # druhá část střechy
    t.right(90)
    <strong>house(side*math.sin(math.radians(45)))</strong>
    # zbývající stěna
    t.right(45)
    t.forward(side)
    t.left(90)
</pre>

<p>Samozřejmě je nutné opět zavést podmínku pro ukončení rekurze, jinak by
program skončil běhovou chybou (překročení volné kapacity paměti). Pokud je
délka strany pro vykreslení domku menší než čtyři kroky želvy, je místo domku
vykreslena pouze úsečka o této délce, čímž je zajištěno vykreslení střech domků
ležících na konci &bdquo;stromu&ldquo;. Pokud však délka strany přesahuje tuto
hodnotu (deset kroků želvy), je jedním tahem vykreslen celý domek:</p>

<pre>
def house(side):
    if side &gt; 4:
        # základna
        t.forward(side)
        # úhlopříčka
        t.left(90+45)
        t.forward(side*math.sqrt(2))
        # stěna
        t.left(90+45)
        t.forward(side)
        # úhlopříčka
        t.left(90+45)
        t.forward(side*math.sqrt(2))
        # úsečka pod střechou
        t.left(90+45)
        t.forward(side)
        # první část střechy
        t.right(90)
        t.right(90-45)
        <strong>house(side*math.cos(math.radians(45)))</strong>
        # druhá část střechy
        t.right(90)
        <strong>house(side*math.sin(math.radians(45)))</strong>
        # zbývající stěna
        t.right(45)
        t.forward(side)
        t.left(90)
    else:
        t.forward(side)
</pre>

<a href="https://www.root.cz/obrazek/310753/"><img src="https://i.iinfo.cz/images/491/appjar7-13-prev.png" class="image-310753" alt="&#160;" width="350" height="270" /></a>
<p><i>Obrázek 19: Rekurzivní kreslení domku jedním tahem aneb Pythagorův
strom.</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Zobecněný Pythagorův strom</h2>

<p>Při kresbě zobecněného Pythagorova stromu je nutné vytvořit proceduru, která
dokáže nakreslit pravoúhlý trojúhelník o zadané délce přepony (nejdelší strany)
a úhlu mezi přeponou a jednou odvěsnou. Proč ale potřebujeme vytvořit takovou
proceduru? Zobecněný Pythagorův strom se od pravidelného Pythagorova stromu,
který jsme si popsali v&nbsp;předchozí kapitole, odlišuje především v&nbsp;tom,
že je použit jiný úhel větvení, což jinými slovy znamená, že se změní tvar
střechy z&nbsp;rovnoramenného pravoúhlého trojúhelníku na jiný pravoúhlý
trojúhelník:</p>

<img src="http://i.iinfo.cz/urs/logo_08_10-118701687629026.gif" alt="Změna úhlu střechy domku" />

<p>Délka přepony v&nbsp;tomto trojúhelníku odpovídá šířce
&bdquo;domku&ldquo;, který tvoří základ celého stromu, a odvěsny představují
obě plochy střechy. Změnou úhlu odchylky první odvěsny se změní i tvar celého
trojúhelníku.</p>

<a href="https://www.root.cz/obrazek/310754/"><img src="https://i.iinfo.cz/images/491/appjar7-14-prev.png" class="image-310754" alt="&#160;" width="361" height="270" /></a>
<p><i>Obrázek 20: Zobecněný Pythagorův strom.</i></p>

<p>Úprava je jednoduchá; změněné řádky jsou zvýrazněny:</p>

<pre>
def house(side, <strong>angle</strong>):
    if side &gt; 4:
        # základna
        t.forward(side)
        # úhlopříčka
        t.left(90+45)
        t.forward(side*math.sqrt(2))
        # stěna
        t.left(90+45)
        t.forward(side)
        # úhlopříčka
        t.left(90+45)
        t.forward(side*math.sqrt(2))
        # úsečka pod střechou
        t.left(90+45)
        t.forward(side)
        # první část střechy
        t.right(90)
        <strong>t.right(90-angle)</strong>
        # původní příkaz: domek side/sqrt 2 :uhel
        <strong>house(side*math.cos(math.radians(angle)), angle)</strong>
        # druhá část střechy
        t.right(90)
        # původní příkaz: domek side/sqrt 2 :uhel
        <strong>house(side*math.sin(math.radians(angle)), angle)</strong>
        # zbývající stěna
        <strong>t.right(angle)</strong>
        t.forward(side)
        t.left(90)
    else:
        t.forward(side)
</pre>

<a href="https://www.root.cz/obrazek/310755/"><img src="https://i.iinfo.cz/images/491/appjar7-15-prev.png" class="image-310755" alt="&#160;" width="326" height="270" /></a>
<p><i>Obrázek 21: Zobecněný Pythagorův strom.</i></p>

<p>Následuje výpis zdrojového kódu příkladu, který dokáže zobrazit různé typy
zobecněného Pythagorova stromu (typ vyberete z&nbsp;hlavního menu):</p>

<pre>
#!/usr/bin/env python
# vim: set fileencoding=utf-8
&nbsp;
from appJar import gui
import math
import tkinter
import turtle
&nbsp;
&nbsp;
app = gui()
&nbsp;
&nbsp;
def setupTurtle(canvas):
    screen = turtle.TurtleScreen(canvas)
    t = turtle.RawTurtle(screen)
    screen.tracer(100, 0)
&nbsp;
    t.hideturtle()
    t.speed(0)
&nbsp;
    t.home()
    t.pd()
    return t, screen
&nbsp;
&nbsp;
def onMenuItemSelect(menuItem):
    if menuItem == "Quit":
        app.stop()
&nbsp;
&nbsp;
def onDrawMenuSelect(menuItem):
    allParams = {
        "Tree": (-50, -150, 100, 45),
        "Bush": (40, -100, 80, 35),
        "Spiral": (-200, -150, 50, 70),
        "Spiral2": (-220, -50, 40, 80),
        "Spiral3": (-300, -50, 30, 85)
    }
&nbsp;
    params = allParams[menuItem]
&nbsp;
    t.hideturtle()
    t.speed(0)
    t.pencolor("gray")
&nbsp;
    t.goto(params[0], params[1])
    t.pd()
    t.clear()
&nbsp;
    house(params[2], params[3])
    screen.update()
&nbsp;
&nbsp;
def house(side, angle):
    if side &gt; 4:
        # základna
        t.forward(side)
        # úhlopříčka
        t.left(90+45)
        t.forward(side*math.sqrt(2))
        # stěna
        t.left(90+45)
        t.forward(side)
        # úhlopříčka
        t.left(90+45)
        t.forward(side*math.sqrt(2))
        # úsečka pod střechou
        t.left(90+45)
        t.forward(side)
        # první část střechy
        t.right(90)
        t.right(90-angle)
        # původní příkaz: domek side/sqrt 2 :uhel
        house(side*math.cos(math.radians(angle)), angle)
        # druhá část střechy
        t.right(90)
        # původní příkaz: domek side/sqrt 2 :uhel
        house(side*math.sin(math.radians(angle)), angle)
        # zbývající stěna
        t.right(angle)
        t.forward(side)
        t.left(90)
    else:
        t.forward(side)
&nbsp;
&nbsp;
app.setSticky("news")
&nbsp;
fileMenu = ["Quit"]
app.addMenuList("File", fileMenu, onMenuItemSelect)
&nbsp;
drawMenu = ["Tree", "Bush", "Spiral", "Spiral2", "Spiral3"]
app.addMenuList("Draw", drawMenu, onDrawMenuSelect)
&nbsp;
canvas = tkinter.Canvas(app.topLevel, width=600, height=600)
canvas.pack()
&nbsp;
t, screen = setupTurtle(canvas)
&nbsp;
app.go()
</pre>

<a href="https://www.root.cz/obrazek/310756/"><img src="https://i.iinfo.cz/images/491/appjar7-16-prev.png" class="image-310756" alt="&#160;" width="294" height="270" /></a>
<p><i>Obrázek 22: Další zobecněný Pythagorův strom.</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Příkaz <strong>goto</strong> a jeho využití při kreslení na absolutní souřadnice plátna</h2>

<p>Příkazy <strong>forward</strong> a <strong>backward</strong>, které jsou
mnohdy zkracovány na <strong>fd</strong> a <strong>bk</strong> či
<strong>back</strong>, slouží k&nbsp;relativnímu posunu želvy o zadaný počet
kroků dopředu či dozadu, přičemž pojmy &bdquo;dopředu&ldquo; a
&bdquo;dozadu&ldquo; jsou vztaženy k&nbsp;aktuálnímu natočení želvy. Ovšem
existuje i příkaz, který donutí želvu skočit na zadané absolutní souřadnice a
v&nbsp;závislosti na zvoleném stavu pera vykreslí či naopak nevykreslí úsečku
mezi původní a novou pozicí želvy. Tento příkaz se jmenuje
<strong>goto</strong>, alternativně je ale možné použít i příkaz
<strong>setpos</strong> či <strong>setposition</strong>. Díky existenci těchto
příkazů se želví grafika přibližuje klasické vektorové grafice, což si ukážeme
na dalším demonstračním příkladu. Pro doplnění si ještě uveďme, že existují
příkazy <strong>setx</strong> a <strong>sety</strong>, které nastavují jen
x-ovou či naopak y-ovou souřadnici želvy (druhá souřadnice je ponechána na
původní hodnotě).</p>

<a href="https://www.root.cz/obrazek/310757/"><img src="https://i.iinfo.cz/images/491/appjar7-17-prev.png" class="image-310757" alt="&#160;" width="270" height="270" /></a>
<p><i>Obrázek 23: Ještě jeden zobecněný Pythagorův strom.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Fresnelův fraktál</h2>

<p>V&nbsp;článku <a
href="http://www.kerrymitchellart.com/tutorials/fresnel-integral/fresnel-integral-tutorial.html">Fresnel
Integral Coloring</a> je popsána tvorba fraktálního útvaru založeného na
Fresnelově integrálu. Tvorbu křivky (část z&nbsp;ní &ndash; klotoida &ndash; se
používá na začátku oblouků kolejnic) je možné v&nbsp;Pythonu popsat kódem,
v&nbsp;němž se nejdříve vypočítají krátké skoky ve směru daném úhlem
představovaným proměnnou <strong>f</strong>. Povšimněte si, že se hodnota
<strong>f</strong> používá ve druhé mocnině:</p>

<pre>
def drawFresnel():
    x = 0.0
    y = 0.0
    f = 0.0
&nbsp;
    for i in range(maxiter+1):
        f += fstep
        x += cos(f * f)
        y += sin(f * f)
        t.goto(scale*x, scale*y)
</pre>

<img src="https://i.iinfo.cz/images/491/appjar7-18.png" class="image-310758" alt="&#160;" width="338" height="347" />
<p><i>Obrázek 24: Fresnelův fraktál.</i></p>

<p>Na tomto příkladu se ukáže kombinace možností knihovny appJar a modulu
Turtle, neboť přímo z&nbsp;aplikace je možné měnit základní parametry
vykreslování &ndash; maximální počet iterací, hodnotu <strong>fstep</strong> i
měřítko celého obrazce. Navíc se při výpočtu postupně aktualizuje
&bdquo;teploměr&ldquo; sledující, kdy má být výpočet dokončen. Tuto možnost
jsme si již popsali v&nbsp;předchozích částech seriálu, nyní zde konečně
dostává svůj význam:</p>

<img src="https://i.iinfo.cz/images/491/appjar7-19.png" class="image-310759" alt="&#160;" width="504" height="271" />
<p><i>Obrázek 25: Ovládací prvky grafického uživatelského rozhraní
aplikace.</i></p>

<pre>
#!/usr/bin/env python
&nbsp;
from appJar import gui
import tkinter
import turtle
from math import *
&nbsp;
&nbsp;
app = gui()
&nbsp;
&nbsp;
def setupTurtle(canvas):
    screen = turtle.TurtleScreen(canvas)
    t = turtle.RawTurtle(screen)
    screen.tracer(100, 0)
&nbsp;
    t.hideturtle()
    t.speed(0)
&nbsp;
    t.home()
    t.pd()
    return t, screen
&nbsp;
&nbsp;
def onMenuItemSelect(menuItem):
    if menuItem == "Quit":
        app.stop()
&nbsp;
&nbsp;
def drawFresnel():
    global progressBarValue
&nbsp;
    x = 0.0
    y = 0.0
    f = 0.0
&nbsp;
    for i in range(maxiter+1):
        progressBarValue = 100.0 * i / maxiter
        f += fstep
        x += cos(f * f)
        y += sin(f * f)
        t.goto(scale*x, scale*y)
&nbsp;
    screen.update()
&nbsp;
&nbsp;
def updateMeter():
    app.setMeter("progressBar", progressBarValue)
&nbsp;
&nbsp;
def onFresnelDraw(command):
    t.home()
    t.clear()
    drawFresnel()
&nbsp;
&nbsp;
def onMaxiterChange(widgetName):
    global maxiter
    value = app.getScale(widgetName)
    maxiter = int(value)
&nbsp;
&nbsp;
def onScaleChange(widgetName):
    global scale
    value = app.getScale(widgetName)
    scale = float(value)
&nbsp;
&nbsp;
def onFValueChange(widgetName):
    global fstep
    value = app.getScale(widgetName)
    fstep = float(value)/100.0
&nbsp;
&nbsp;
def createGui(app):
    fileMenu = ["Quit"]
&nbsp;
    app.addMenuList("File", fileMenu, onMenuItemSelect)
&nbsp;
    app.addLabel("maxiter-label", "Maxiter", row=0, column=0)
    app.addScale("maxiter", row=0, column=1, colspan=2)
    app.showScaleIntervals("maxiter", 1000)
    app.showScaleValue("maxiter")
    app.setScaleRange("maxiter", 0, 5000, 1000)
    app.setScaleChangeFunction("maxiter", onMaxiterChange)
&nbsp;
    app.addLabel("scale-label", "Scale", row=1, column=0)
    app.addScale("scale", row=1, column=1, colspan=2)
    app.showScaleIntervals("scale", 1)
    app.showScaleValue("scale")
    app.setScaleRange("scale", 1, 10, 4)
    app.setScaleChangeFunction("scale", onScaleChange)
&nbsp;
    app.addLabel("f-value-label", "F-value", row=2, column=0)
    app.addScale("f-value", row=2, column=1, colspan=2)
    app.showScaleIntervals("f-value", 10)
    app.showScaleValue("f-value")
    app.setScaleRange("f-value", 0, 100, 20)
    app.setScaleChangeFunction("f-value", onFValueChange)
&nbsp;
    app.addMeter("progressBar", row=3, column=0, colspan=2)
    app.setMeterFill("progressBar", "green")
&nbsp;
    app.addButton("Draw", onFresnelDraw, row=3, column=2)
&nbsp;
    app.registerEvent(updateMeter)
&nbsp;
&nbsp;
progressBarValue = 0
scale = 4.0
maxiter = 1000
fstep = 0.2
&nbsp;
app.setSticky("news")
&nbsp;
createGui(app)
&nbsp;
canvas = tkinter.Canvas(app.topLevel, width=500, height=500)
canvas.pack()
t, screen = setupTurtle(canvas)
&nbsp;
app.go()
</pre>

<img src="https://i.iinfo.cz/images/491/appjar7-20.png" class="image-310760" alt="&#160;" width="436" height="449" />
<p><i>Obrázek 26: Fresnelův fraktál.</i></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Systémy iterovaných funkcí (IFS)</h2>

<p>V&nbsp;závěrečné části článku si ukážeme, jak je možné vykreslit různé
obrazce s&nbsp;využitím systémů iterovaných funkcí (<i>IFS</i>). Tato
problematika byla podrobněji popsána v&nbsp;článku <a
href="https://www.root.cz/clanky/systemy-iterovanych-funkci-a-algoritmus-nahodne-prochazky/">Systémy
iterovaných funkcí a algoritmus náhodné procházky </a>, takže si dnes pouze
řekneme, jak je možné IFS vykreslovat s&nbsp;využitím želví grafiky.</p>

<a href="http://i.iinfo.cz/urs/fractals31_2-114865051880230.png"><img alt="fractals31_2" width="400" height="300" src="http://i.iinfo.cz/urs/fractals31_2-preview-114865051880230.png" /></a>
<p><i>Obrázek 27: Model větvičky vytvořený pomocí IFS se třemi afinními
transformacemi.</i></p>

<p>Vzhledem k&nbsp;tomu, že základní algoritmus náhodné procházky vykresluje
jednotlivé body umisťované na absolutní souřadnice, použijeme pro vykreslování
dvojici funkcí <strong>goto</strong> (přesun želvy na absolutní souřadnice) a
<strong>dot</strong> (vykreslení bodu na pozici želvy). Samozřejmě je nutné,
aby želva při svém pohybu řízeném funkcí <strong>goto</strong>
<i>ne</i>kreslila úsečku, takže před začátkem vykreslování zavoláme příkaz
<strong>penup</strong> (či jen <strong>pu</strong>).</p>

<a href="http://i.iinfo.cz/urs/fractals31_3-114865053677971.png"><img alt="fractals31_3" width="400" height="300" src="http://i.iinfo.cz/urs/fractals31_3-preview-114865053677971.png" /></a>
<p><i>Obrázek 28: Fraktální drak vytvořený systémem iterovaných funkcí.</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Vykreslení jednoduchého systému iterovaných funkcí krok za krokem</h2>

<p>Každý IFS je popsán několika transformačními maticemi (ve 2D) a
pravděpodobností aplikace té které transformace. Součet pravděpodobností by měl
být roven jedné. Transformační matice by sice teoreticky měla mít velikost
3&times;3 prvky, ovšem poslední sloupec vždy obsahuje hodnotu [0, 0,
1]<sup>T</sup>, takže nám stačí uložit jen šest prvků matice. Celkem je tedy
každá transformace reprezentována sedmi hodnotami &ndash; šest pro
transformační matici, sedmá je pravděpodobnost:</p>

<pre>
ifs = (
    (+0.85000, +0.04000, -0.04000, +0.85000, +0.00000, +1.60000, +0.85000),
    (+0.20000, -0.26000, +0.23000, +0.22000, +0.00000, +1.60000, +0.07000),
    (-0.15000, +0.28000, +0.26000, +0.24000, +0.00000, +0.44000, +0.07000),
    (+0.00000, +0.00000, +0.00000, +0.16000, +0.00000, +0.00000, +0.01000))
</pre>

<p>Programová smyčka pro vykreslení IFS nejprve náhodně vybere transformaci.
Povšimněte si, že čím má transformace vyšší pravděpodobnost, tím častěji bude
vybrána (pokud se tedy můžeme spolehnout na generátor náhodných čísel):</p>

<pre>
# nahodne vybrat transformaci
pp = random()
sum = 0
k = 0
while sum &lt;= pp:
    sum += ifs[k][6]
    k += 1
k -= 1
</pre>

<p>Dále se vybraná transformace aplikuje na bod [x1, y1]:</p>

<pre>
# aplikovat transformaci
x2 = x1*ifs[k][0] + y1*ifs[k][1] + ifs[k][4]
y2 = x1*ifs[k][2] + y1*ifs[k][3] + ifs[k][5]
x1 = x2
y1 = y2
</pre>

<p>Poslední fáze &ndash; pokud byl překročen stanovený počet startovních
iterací, vykreslí se bod:</p>

<pre>
# pokud byl prekrocen pocet startovnich iteraci
if i &gt; start_iter:
    x2 = x1 * scale - dx
    y2 = y1 * scale - dy
    t.goto(x2, y2)
    t.dot(1)
</pre>

<p>Poznámka: tato podmínka nám prakticky zaručí, že bod [x1, y1] již leží
v&nbsp;atraktoru systému.</p>

<a href="http://i.iinfo.cz/urs/fractals31_5-114865057243469.png"><img alt="fractals31_5" width="400" height="300" src="http://i.iinfo.cz/urs/fractals31_5-preview-114865057243469.png" /></a>
<p><i>Obrázek 29: Variace na téma binárního stromu.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Zdrojový kód příkladu pro vykreslení IFS</h2>

<p>Funkce popsané v&nbsp;předchozí kapitole jsou součástí dnešního
předposledního demonstračního příkladu, jehož zdrojový kód najdete pod tímto
odstavcem:</p>

<pre>
#!/usr/bin/env python
&nbsp;
from appJar import gui
import tkinter
import turtle
import sys
from random import random
&nbsp;
&nbsp;
app = gui()
&nbsp;
&nbsp;
ifs = (
    (+0.85000, +0.04000, -0.04000, +0.85000, +0.00000, +1.60000, +0.85000),
    (+0.20000, -0.26000, +0.23000, +0.22000, +0.00000, +1.60000, +0.07000),
    (-0.15000, +0.28000, +0.26000, +0.24000, +0.00000, +0.44000, +0.07000),
    (+0.00000, +0.00000, +0.00000, +0.16000, +0.00000, +0.00000, +0.01000),
    (+1.00000, +0.00000, +0.00000, +1.00000, +0.00000, +0.00000, +1.00000))
&nbsp;
&nbsp;
def setupTurtle(canvas):
    screen = turtle.TurtleScreen(canvas)
    t = turtle.RawTurtle(screen)
    screen.tracer(100, 0)
&nbsp;
    t.hideturtle()
    t.speed(0)
&nbsp;
    t.home()
    t.pu()
    return t, screen
&nbsp;
&nbsp;
def onMenuItemSelect(menuItem):
    if menuItem == "Quit":
        app.stop()
&nbsp;
&nbsp;
def onIFSItemSelect(menuItem):
    global ifs
    ifs = ifs_systems[menuItem]
&nbsp;
&nbsp;
def drawIFS(ifs):
    global progressBarValue
    start_iter = 100
&nbsp;
    # generovane souradnice
    x1 = 0
    y1 = 0
&nbsp;
    dy = 220
    scale = 45
&nbsp;
    for i in range(maxiter+1):
        progressBarValue = 100.0 * i / maxiter
&nbsp;
        # nahodne vybrat transformaci
        pp = random()
        sum = 0
        k = 0
        while sum &lt;= pp:
            sum += ifs[k][6]
            k += 1
        k -= 1
&nbsp;
        # aplikovat transformaci
        x2 = x1*ifs[k][0] + y1*ifs[k][1] + ifs[k][4]
        y2 = x1*ifs[k][2] + y1*ifs[k][3] + ifs[k][5]
        x1 = x2
        y1 = y2
&nbsp;
        # pokud byl prekrocen pocet startovnich iteraci
        if i &gt; start_iter:
            x2 = x1 * scale
            y2 = y1 * scale - dy
            t.goto(x2, y2)
            t.dot(1)
&nbsp;
    screen.update()
&nbsp;
&nbsp;
def updateMeter():
    app.setMeter("progressBar", progressBarValue)
&nbsp;
&nbsp;
def onIFSDraw(command):
    t.home()
    t.clear()
    drawIFS(ifs)
&nbsp;
&nbsp;
def onMaxiterChange(widgetName):
    global maxiter
    value = app.getScale(widgetName)
    maxiter = int(value)
&nbsp;
&nbsp;
def createGui(app):
    fileMenu = ["Quit"]
&nbsp;
    app.addMenuList("File", fileMenu, onMenuItemSelect)
&nbsp;
    app.addLabel("maxiter-label", "Maxiter", row=0, column=0)
    app.addScale("maxiter", row=0, column=1, colspan=2)
    app.showScaleIntervals("maxiter", 5000)
    app.showScaleValue("maxiter")
    app.setScaleRange("maxiter", 0, 25000, 5000)
    app.setScaleChangeFunction("maxiter", onMaxiterChange)
&nbsp;
    app.addMeter("progressBar", row=3, column=0, colspan=2)
    app.setMeterFill("progressBar", "green")
&nbsp;
    app.addButton("Draw", onIFSDraw, row=3, column=2)
&nbsp;
    app.registerEvent(updateMeter)
&nbsp;
&nbsp;
progressBarValue = 0
maxiter = 5000
&nbsp;
app.setSticky("news")
&nbsp;
createGui(app)
&nbsp;
canvas = tkinter.Canvas(app.topLevel, width=500, height=500)
canvas.pack()
t, screen = setupTurtle(canvas)
&nbsp;
app.go()
</pre>

<img src="https://i.iinfo.cz/images/491/appjar7-21.png" class="image-310761" alt="&#160;" width="504" height="658" />
<p><i>Obrázek 30: Barnsleyova kapradina je typickým představitelem IFS.</i></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Demonstrační příklad: galerie IFS, výběr a vykreslení vybraného IFS</h2>

<p>Poslední demonstrační příklad je vlastně pouze rozšířením příkladu
předchozího o parametry dalších IFS. Konkrétní IFS je možné vybrat
z&nbsp;hlavního menu, které obsahuje skupinu radiových tlačítek:</p>

<img src="https://i.iinfo.cz/images/491/appjar7-22.png" class="image-310762" alt="&#160;" width="200" height="179" />
<p><i>Obrázek 31: IFS vykreslený dnešním posledním demonstračním příkladem.</i></p>

<p>Zdrojový kód příkladu je již poměrně dlouhý, nicméně podstatnou část
zabírají matice transformací, tedy &bdquo;pouhá&ldquo; data:</p>

<pre>
#!/usr/bin/env python
&nbsp;
from appJar import gui
import tkinter
import turtle
import sys
from random import random
&nbsp;
&nbsp;
app = gui()
&nbsp;
&nbsp;
ifs_systems = {
    "binary": (
        ( 0.500000, 0.000000, 0.000000, 0.500000,-2.563477,-0.000003, 0.333333),
        ( 0.500000, 0.000000, 0.000000, 0.500000, 2.436544,-0.000003, 0.333333),
        ( 0.000000,-0.500000, 0.500000, 0.000000, 4.873085, 7.563492, 0.333333)),
    "coral": (
        ( 0.307692,-0.531469,-0.461538,-0.293706, 5.401953, 8.655175, 0.400000),
        ( 0.307692,-0.076923, 0.153846,-0.447552,-1.295248, 4.152990, 0.150000),
        ( 0.000000, 0.545455, 0.692308,-0.195804,-4.893637, 7.269794, 0.450000)),
    "crystal": (
        ( 0.696970,-0.481061,-0.393939,-0.662879, 2.147003,10.310288, 0.747826),
        ( 0.090909,-0.443182, 0.515152,-0.094697, 4.286558, 2.925762, 0.252174)),
    "dragon": (
        ( 0.824074, 0.281482,-0.212346, 0.864198,-1.882290,-0.110607, 0.787473),
        ( 0.088272, 0.520988,-0.463889,-0.377778, 0.785360, 8.095795, 0.212527)),
    "dragon2": (
        ( 0.824074, 0.281481,-0.212346, 0.864197,-1.772710, 0.137795, 0.771268),
        (-0.138580, 0.283951,-0.670062,-0.279012, 2.930991, 7.338924, 0.228732)),
    "feather": (
        ( 0.870370, 0.074074,-0.115741, 0.851852,-1.278016, 0.070331, 0.798030),
        (-0.162037,-0.407407, 0.495370, 0.074074, 6.835726, 5.799174, 0.201970)),
    "fern": (
        ( 0.850000, 0.040000,-0.040000, 0.850000, 0.000000, 1.600000, 0.850000),
        ( 0.200000,-0.260000, 0.230000, 0.220000, 0.000000, 1.600000, 0.070000),
        (-0.150000, 0.280000, 0.260000, 0.240000, 0.000000, 0.440000, 0.070000),
        ( 0.000000, 0.000000, 0.000000, 0.160000, 0.000000, 0.000000, 0.010000)),
    "koch": (
        ( 0.307692, 0.000000, 0.000000, 0.294118, 4.119164, 1.604278, 0.151515),
        ( 0.192308,-0.205882, 0.653846, 0.088235,-0.688840, 5.978916, 0.253788),
        ( 0.192308, 0.205882,-0.653846, 0.088235, 0.668580, 5.962514, 0.253788),
        ( 0.307692, 0.000000, 0.000000, 0.294118,-4.136530, 1.604278, 0.151515),
        ( 0.384615, 0.000000, 0.000000,-0.294118,-0.007718, 2.941176, 1.000000)),
    "spiral": (
        ( 0.787879,-0.424242, 0.242424, 0.859848, 1.758647, 1.408065, 0.895652),
        (-0.121212, 0.257576, 0.151515, 0.053030,-6.721654, 1.377236, 0.052174),
        ( 0.181818,-0.136364, 0.090909, 0.181818, 6.086107, 1.568035, 0.052174)),
    "tree": (
        ( 0.000000, 0.000000, 0.000000, 0.500000, 0.000000, 0.000000, 0.050000),
        ( 0.420000,-0.420000, 0.420000, 0.420000, 0.000000, 0.200000, 0.400000),
        ( 0.420000, 0.420000,-0.420000, 0.420000, 0.000000, 0.200000, 0.400000),
        ( 0.100000, 0.000000, 0.000000, 0.100000, 0.000000, 0.200000, 0.150000)),
    "triangle": (
        ( 0.500000, 0.000000, 0.000000, 0.500000,-0.500000, 0.000000, 0.333333),
        ( 0.500000, 0.000000, 0.000000, 0.500000, 0.500000, 0.000000, 0.333333),
        ( 0.500000, 0.000000, 0.000000, 0.500000, 0.000000, 0.860000, 0.333334)),
}
&nbsp;
&nbsp;
def setupTurtle(canvas):
    screen = turtle.TurtleScreen(canvas)
    t = turtle.RawTurtle(screen)
    screen.tracer(100, 0)
&nbsp;
    t.hideturtle()
    t.speed(0)
&nbsp;
    t.home()
    t.pu()
    return t, screen
&nbsp;
&nbsp;
def onMenuItemSelect(menuItem):
    if menuItem == "Quit":
        app.stop()
&nbsp;
&nbsp;
def onIFSItemSelect(menuItem):
    global ifs
    ifs = ifs_systems[menuItem]
&nbsp;
&nbsp;
def drawIFS(ifs):
    global progressBarValue
    start_iter = 100
&nbsp;
    # generovane souradnice
    x1 = 0
    y1 = 0
&nbsp;
    dy = 100
&nbsp;
    for i in range(maxiter+1):
        progressBarValue = 100.0 * i / maxiter
&nbsp;
        # nahodne vybrat transformaci
        pp = random()
        sum = 0
        k = 0
        while sum &lt;= pp:
            sum += ifs[k][6]
            k += 1
        k -= 1
&nbsp;
        # aplikovat transformaci
        x2 = x1*ifs[k][0] + y1*ifs[k][1] + ifs[k][4]
        y2 = x1*ifs[k][2] + y1*ifs[k][3] + ifs[k][5]
        x1 = x2
        y1 = y2
&nbsp;
        # pokud byl prekrocen pocet startovnich iteraci
        if i &gt; start_iter:
            x2 = x1 * 30
            y2 = y1 * 30 - dy
            t.goto(x2, y2)
            t.dot(1)
&nbsp;
    screen.update()
&nbsp;
&nbsp;
def updateMeter():
    app.setMeter("progressBar", progressBarValue)
&nbsp;
&nbsp;
def onIFSDraw(command):
    t.home()
    t.clear()
    drawIFS(ifs)
&nbsp;
&nbsp;
def onMaxiterChange(widgetName):
    global maxiter
    value = app.getScale(widgetName)
    maxiter = int(value)
&nbsp;
&nbsp;
def createGui(app):
    fileMenu = ["Quit"]
&nbsp;
    app.addMenuList("File", fileMenu, onMenuItemSelect)
&nbsp;
    ifsMenu = sorted(ifs_systems.keys())
    for ifsMenuItem in ifsMenu:
        app.addMenuRadioButton("IFS", "ifs", ifsMenuItem,
                               lambda i, ifsMenuItem=ifsMenuItem: onIFSItemSelect(ifsMenuItem))
&nbsp;
    app.addLabel("maxiter-label", "Maxiter", row=0, column=0)
    app.addScale("maxiter", row=0, column=1, colspan=2)
    app.showScaleIntervals("maxiter", 5000)
    app.showScaleValue("maxiter")
    app.setScaleRange("maxiter", 0, 25000, 5000)
    app.setScaleChangeFunction("maxiter", onMaxiterChange)
&nbsp;
    app.addMeter("progressBar", row=3, column=0, colspan=2)
    app.setMeterFill("progressBar", "green")
&nbsp;
    app.addButton("Draw", onIFSDraw, row=3, column=2)
&nbsp;
    app.registerEvent(updateMeter)
&nbsp;
&nbsp;
progressBarValue = 0
maxiter = 5000
ifs = ifs_systems["binary"]
&nbsp;
app.setSticky("news")
&nbsp;
createGui(app)
&nbsp;
canvas = tkinter.Canvas(app.topLevel, width=500, height=500)
canvas.pack()
t, screen = setupTurtle(canvas)
&nbsp;
app.go()
</pre>

<img src="https://i.iinfo.cz/images/491/appjar7-23.png" class="image-310763" alt="&#160;" width="200" height="146" />
<p><i>Obrázek 32: IFS vykreslený dnešním posledním demonstračním příkladem.</i></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dvanácti dnes popsaných demonstračních příkladů byly
opět uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Pokud nechcete klonovat celý repositář, můžete namísto toho použít odkazy na
jednotlivé příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th>Příklad</th><th>Adresa</th></tr>
<tr><td>78_turtle1.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/78_turtle1.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/78_turtle1.py</a></td></tr>
<tr><td>79_turtle1_speedup.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/79_turtle1_speedup.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/79_turtle1_speedup.py</a></td></tr>
<tr><td>80_turtle1_speedup_update.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/80_turtle1_speedup_update.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/80_turtle1_speedup_update.py</a></td></tr>
<tr><td>81_turtle2.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/81_turtle2.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/81_turtle2.py</a></td></tr>
<tr><td>82_koch_snoflake.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/82_koch_snoflake.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/82_koch_snoflake.py</a></td></tr>
<tr><td>83_house.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/83_house.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/83_house.py</a></td></tr>
<tr><td>84_pythagoras_tree.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/84_pythagoras_tree.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/84_pythagoras_tree.py</a></td></tr>
<tr><td>85_pythagoras_tree_2.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/85_pythagoras_tree_2.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/85_pythagoras_tree_2.py</a></td></tr>
<tr><td>86_turtle_demo.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/86_turtle_demo.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/86_turtle_demo.py</a></td></tr>
<tr><td>87_fresnel_integral.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/87_fresnel_integral.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/87_fresnel_integral.py</a></td></tr>
<tr><td>88_ifs.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/88_ifs.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/88_ifs.py</a></td></tr>
<tr><td>89_ifs_demo.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/89_ifs_demo.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/appJar/89_ifs_demo.py</a></td></tr>
</table>

<p>Poznámka: pro úspěšné spuštění těchto příkladů musíte mít v&nbsp;aktuálním
adresáři rozbalenou knihovnu <i>appJar</i>!. Podrobnosti o instalaci jsme si
řekli <a
href="https://www.root.cz/clanky/tvorba-grafickeho-uzivatelskeho-rozhrani-v-pythonu-s-vyuzitim-knihovny-appjar/">v&nbsp;úvodním
článku</a>.</p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Seriál Letní škola programovacího jazyka Logo<br />
<a href="http://www.root.cz/serialy/letni-skola-programovaciho-jazyka-logo/">http://www.root.cz/serialy/letni-skola-programovaciho-jazyka-logo/</a>
</li>

<li>Educational programming language<br />
<a href="http://en.wikipedia.org/wiki/Educational_programming_language">http://en.wikipedia.org/wiki/Educational_programming_language</a>
</li>

<li>Logo Tree Project:<br />
<a href="http://www.elica.net/download/papers/LogoTreeProject.pdf">http://www.elica.net/download/papers/LogoTreeProject.pdf</a></li>

<li>Hra Breakout napísaná v Tkinteri<br />
<a href="https://www.root.cz/clanky/hra-breakout-napisana-v-tkinteri/">https://www.root.cz/clanky/hra-breakout-napisana-v-tkinteri/</a>
</li>

<li>Hra Snake naprogramovaná v Pythone s pomocou Tkinter<br />
<a href="https://www.root.cz/clanky/hra-snake-naprogramovana-v-pythone-s-pomocou-tkinter/">https://www.root.cz/clanky/hra-snake-naprogramovana-v-pythone-s-pomocou-tkinter/</a>
</li>

<li>24.1. turtle — Turtle graphics<br />
<a href="https://docs.python.org/3.5/library/turtle.html#module-turtle">https://docs.python.org/3.5/library/turtle.html#module-turtle</a>
</li>

<li>TkDND<br />
<a href="http://freecode.com/projects/tkdnd">http://freecode.com/projects/tkdnd</a>
</li>

<li>Python Tkinter Fonts<br />
<a href="https://www.tutorialspoint.com/python/tk_fonts.htm">https://www.tutorialspoint.com/python/tk_fonts.htm</a>
</li>

<li>The Tkinter Canvas Widget<br />
<a href="http://effbot.org/tkinterbook/canvas.htm">http://effbot.org/tkinterbook/canvas.htm</a>
</li>

<li>Ovládací prvek (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Ovl%C3%A1dac%C3%AD_prvek_%28po%C4%8D%C3%ADta%C4%8D%29">https://cs.wikipedia.org/wiki/Ovl%C3%A1dac%C3%AD_prvek_%28po%C4%8D%C3%ADta%C4%8D%29</a>
</li>

<li>Rezervovaná klíčová slova v&nbsp;Pythonu<br />
<a href="https://docs.python.org/3/reference/lexical_analysis.html#keywords">https://docs.python.org/3/reference/lexical_analysis.html#keywords</a>
</li>

<li>TkDocs: Styles and Themes<br />
<a href="http://www.tkdocs.com/tutorial/styles.html">http://www.tkdocs.com/tutorial/styles.html</a>
</li>

<li>Drawing in Tkinter<br />
<a href="http://zetcode.com/gui/tkinter/drawing/">http://zetcode.com/gui/tkinter/drawing/</a>
</li>

<li>Changing ttk widget text color (StackOverflow)<br />
<a href="https://stackoverflow.com/questions/16240477/changing-ttk-widget-text-color">https://stackoverflow.com/questions/16240477/changing-ttk-widget-text-color</a>
</li>

<li>The Hitchhiker's Guide to Pyhton: GUI Applications<br />
<a href="http://docs.python-guide.org/en/latest/scenarios/gui/">http://docs.python-guide.org/en/latest/scenarios/gui/</a>
</li>

<li>7 Top Python GUI Frameworks for 2017<br />
<a href="http://insights.dice.com/2014/11/26/5-top-python-guis-for-2015/">http://insights.dice.com/2014/11/26/5-top-python-guis-for-2015/</a>
</li>

<li>GUI Programming in Python<br />
<a href="https://wiki.python.org/moin/GuiProgramming">https://wiki.python.org/moin/GuiProgramming</a>
</li>

<li>Cameron Laird's personal notes on Python GUIs<br />
<a href="http://phaseit.net/claird/comp.lang.python/python_GUI.html">http://phaseit.net/claird/comp.lang.python/python_GUI.html</a>
</li>

<li>Python GUI development<br />
<a href="http://pythoncentral.io/introduction-python-gui-development/">http://pythoncentral.io/introduction-python-gui-development/</a>
</li>

<li>Graphic User Interface FAQ<br />
<a href="https://docs.python.org/2/faq/gui.html#graphic-user-interface-faq">https://docs.python.org/2/faq/gui.html#graphic-user-interface-faq</a>
</li>

<li>TkInter<br />
<a href="https://wiki.python.org/moin/TkInter">https://wiki.python.org/moin/TkInter</a>
</li>

<li>Tkinter 8.5 reference: a GUI for Python<br />
<a href="http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html">http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html</a>
</li>

<li>TkInter (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Tkinter">https://en.wikipedia.org/wiki/Tkinter</a>
</li>

<li>appJar<br />
<a href="http://appjar.info/">http://appjar.info/</a>
</li>

<li>appJar (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/AppJar">https://en.wikipedia.org/wiki/AppJar</a>
</li>

<li>appJar na Pythonhosted<br />
<a href="http://pythonhosted.org/appJar/">http://pythonhosted.org/appJar/</a>
</li>

<li>appJar widgets<br />
<a href="http://appjar.info/pythonWidgets/">http://appjar.info/pythonWidgets/</a>
</li>

<li>Stránky projektu PyGTK<br />
<a href="http://www.pygtk.org/">http://www.pygtk.org/</a>
</li>

<li>PyGTK (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/PyGTK">https://cs.wikipedia.org/wiki/PyGTK</a>
</li>

<li>Stránky projektu PyGObject<br />
<a href="https://wiki.gnome.org/Projects/PyGObject">https://wiki.gnome.org/Projects/PyGObject</a>
</li>

<li>Stránky projektu Kivy<br />
<a href="https://kivy.org/#home">https://kivy.org/#home</a>
</li>

<li>Stránky projektu PyQt<br />
<a href="https://riverbankcomputing.com/software/pyqt/intro">https://riverbankcomputing.com/software/pyqt/intro</a>
</li>

<li>PyQt (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/PyGTK">https://cs.wikipedia.org/wiki/PyGTK</a>
</li>

<li>Stránky projektu PySide<br />
<a href="https://wiki.qt.io/PySide">https://wiki.qt.io/PySide</a>
</li>

<li>PySide (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/PySide">https://en.wikipedia.org/wiki/PySide</a>
</li>

<li>Stránky projektu Kivy<br />
<a href="https://kivy.org/#home">https://kivy.org/#home</a>

<li>Kivy (framework, Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Kivy_(framework)">https://en.wikipedia.org/wiki/Kivy_(framework)</a>

<li>QML Applications<br />
<a href="http://doc.qt.io/qt-5/qmlapplications.html">http://doc.qt.io/qt-5/qmlapplications.html</a>
</li>

<li>KDE<br />
<a href="https://www.kde.org/">https://www.kde.org/</a>
</li>

<li>Qt<br />
<a href="https://www.qt.io/">https://www.qt.io/</a>
</li>

<li>GNOME<br />
<a href="https://en.wikipedia.org/wiki/GNOME">https://en.wikipedia.org/wiki/GNOME</a>
</li>

<li>Category:Software that uses PyGTK<br />
<a href="https://en.wikipedia.org/wiki/Category:Software_that_uses_PyGTK">https://en.wikipedia.org/wiki/Category:Software_that_uses_PyGTK</a>
</li>

<li>Category:Software that uses PyGObject<br />
<a href="https://en.wikipedia.org/wiki/Category:Software_that_uses_PyGObject">https://en.wikipedia.org/wiki/Category:Software_that_uses_PyGObject</a>
</li>

<li>Category:Software that uses wxWidgets<br />
<a href="https://en.wikipedia.org/wiki/Category:Software_that_uses_wxWidgets">https://en.wikipedia.org/wiki/Category:Software_that_uses_wxWidgets</a>
</li>

<li>GIO<br />
<a href="https://developer.gnome.org/gio/stable/">https://developer.gnome.org/gio/stable/</a>
</li>

<li>GStreamer<br />
<a href="https://gstreamer.freedesktop.org/">https://gstreamer.freedesktop.org/</a>
</li>

<li>GStreamer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GStreamer">https://en.wikipedia.org/wiki/GStreamer</a>
</li>

<li>Wax Gui Toolkit<br />
<a href="https://wiki.python.org/moin/Wax">https://wiki.python.org/moin/Wax</a>
</li>

<li>Python Imaging Library (PIL)<br />
<a href="http://infohost.nmt.edu/tcc/help/pubs/pil/">http://infohost.nmt.edu/tcc/help/pubs/pil/</a>
</li>

<li>Why Pyjamas Isn’t a Good Framework for Web Apps (blogpost z&nbsp;roku 2012)<br />
<a href="http://blog.pyjeon.com/2012/07/29/why-pyjamas-isnt-a-good-framework-for-web-apps/">http://blog.pyjeon.com/2012/07/29/why-pyjamas-isnt-a-good-framework-for-web-apps/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

