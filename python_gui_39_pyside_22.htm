<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Jazyk QML (Qt Modeling Language) a PySide 2</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Jazyk QML (Qt Modeling Language) a PySide 2</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešní části seriálu o tvorbě aplikací s grafickým uživatelským rozhraním v Pythonu s využitím frameworku PySide si ukážeme další možnosti nabízené jazykem QML. Oproti předchozí části se však zaměříme na PySide2, Qt 5 a tím pádem i na novější verzi QML.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Jazyk QML (Qt Modeling Language) a PySide 2</a></p>
<p><a href="#k02">2. Porovnání rozdílů mezi PySide a PySide2 při práci s&nbsp;QML</a></p>
<p><a href="#k03">3. Vizuální porovnání rozdílů mezi skripty psanými v&nbsp;Pythonu</a></p>
<p><a href="#k04">4. Přechod od QtQuick 1.0 ke QtQuick 2.0</a></p>
<p><a href="#k05">5. Vizuální porovnání rozdílů mezi oběma QML soubory</a></p>
<p><a href="#k06">6. Univerzální modul určený pro načtení a zobrazení QML aplikace</a></p>
<p><a href="#k07">7. Příklad použití modulu popsaného v&nbsp;předchozí kapitole</a></p>
<p><a href="#k08">8. Kotevní přímky a jejich vliv na umístění a rozměry prvků</a></p>
<p><a href="#k09">9. Použití rastrových obrázků v&nbsp;GUI</a></p>
<p><a href="#k10">10. Načtení a zobrazení vektorových výkresů v&nbsp;GUI</a></p>
<p><a href="#k11">11. Korektní rozmístění vektorových výkresů na plochu okna</a></p>
<p><a href="#k12">12. Relativní velikost výkresu: atribut <strong>fillMode</strong></a></p>
<p><a href="#k13">13. Další způsoby rozmístění prvků GUI na ploše okna</a></p>
<p><a href="#k14">14. Správce geometrie <strong>Grid</strong></a></p>
<p><a href="#k15">15. Správce geometrie <strong>Column</strong></a></p>
<p><a href="#k16">16. Správce geometrie <strong>Row</strong></a></p>
<p><a href="#k17">17. Tvorba animací v&nbsp;Pyside &ndash; použití automaticky modifikované proměnné řídicí animaci</a></p>
<p><a href="#k18">18. Další ukázky animace &ndash; plynulá změna velikosti vektorových kreseb</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Jazyk QML (Qt Modeling Language) a PySide 2</h2>

<p><a
href="https://www.root.cz/clanky/jazyk-qml-qt-modeling-language-a-pyside/">V&nbsp;předchozím
článku</a> jsme se seznámili se základními vlastnostmi jazyka QML určeného pro
tvorbu grafického uživatelského rozhraní, nad nímž je postavena technologie <a
href="http://wiki.qt.io/Qt_Quick_Tutorial">Qt Quick</a>. Ovšem prozatím jsme se
zabývali pouze tou variantou jazyka QML, která je součástí Qt Quick 1.0,
tj.&nbsp;starší verze použité v&nbsp;Qt 4.8.7. To je sice stále používaná verze
Qt (je na ní postaveno relativně mnoho podnikových aplikací), ovšem oficiálně
již není více než dva roky podporovaná, takže je poněkud problematické nad ní
stavět novější aplikace. Novější QtQuick 2.x totiž už vyžaduje Qt 5 (a to
konkrétně verze <a href="http://wiki.qt.io/Qt_5.9_Release">5.9</a>, <a
href="http://wiki.qt.io/Qt_5.10_Release">5.10</a> či <a
href="http://wiki.qt.io/Qt_5.11_Release">5.11</a>) a tím pádem i PySide 2. Mezi
oběma variantami existuje několik rozdílů a z&nbsp;tohoto důvodu si dnes
ukážeme několik příkladů postavených nad PySide 2 a Qt Quick 2.0.</p>

<a href="https://www.root.cz/obrazek/312508/"><img src="https://i.iinfo.cz/images/458/pyside1-1-prev.png" class="image-312508" alt="&#160;" height="270" width="327" /></a>
<p><i>Obrázek 1: Příkladem aplikace postavené na PyQt je integrované vývojové
prostředí Eric.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Porovnání rozdílů mezi PySide a PySide2 při práci s&nbsp;QML</h2>

<p>Nejprve se v&nbsp;krátkosti podívejme na to, jaké základní rozdíly nalezneme
mezi PySide a PySide2 u kódu (skriptu), který vlastně provádí pouze jedinou
činnost &ndash; vytvoření hlavního okna aplikace, načtení QML s&nbsp;deklarací
GUI a následného vykreslení grafického uživatelského rozhraní do tohoto okna na
základě obsahu získaného z&nbsp;QML. Při použití PySide 1 celý kód tohoto
skriptu vypadal následovně:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import sys
&nbsp;
<i># import "jádra" frameworku Qt i modulu pro GUI</i>
from PySide import QtCore
from PySide import QtGui
&nbsp;
<i># modul pro práci s QML</i>
from PySide import QtDeclarative
&nbsp;
<i># jméno QML s deklarací grafického uživatelského rozhraní</i>
QML_FILE = "173_load_qml_9.qml"
&nbsp;
&nbsp;
<i># nový widget bude odvozen od QDeclarativeView</i>
class <strong>MainWindow</strong>(QtDeclarative.QDeclarativeView):
&nbsp;
    def <strong>__init__</strong>(self, parent=None):
        super(MainWindow, self).__init__(parent)
        <i># nastavení titulku hlavního okna aplikace</i>
        self.setWindowTitle("QML Example")
        <i># načtení souboru QML</i>
        self.setSource(QtCore.QUrl.fromLocalFile(QML_FILE))
        <i># necháme QML změnit velikost okna</i>
        self.setResizeMode(QtDeclarative.QDeclarativeView.SizeRootObjectToView)
&nbsp;
&nbsp;
def <strong>main</strong>():
    <i># vytvoření Qt aplikace</i>
    app = QtGui.QApplication(sys.argv)
&nbsp;
    <i># vytvoření hlavního okna</i>
    window = MainWindow()
&nbsp;
    <i># zobrazení hlavního okna</i>
    window.show()
&nbsp;
    <i># spuštění aplikace</i>
    sys.exit(app.exec_())
&nbsp;
&nbsp;
if __name__ == '__main__':
    main()
</pre>

<p>Z&nbsp;předchozího výpisu vidíme, že třída hlavního okna je odvozena od
třídy <strong>QtDeclarative.QDeclarativeView</strong>. V&nbsp;případě, že
použijeme PySide2, je ovšem situace odlišná, neboť hlavní okno se v&nbsp;tomto
případě odvodí od odlišné třídy pojmenované
<strong>QtQuick.QQuickView</strong>. Také se bude odlišovat způsob nastavení
titulku hlavního okna, neboť se namísto metody
<strong>setWindowTitle()</strong> použije <strong>setTitle()</strong> (odlišné
jsou i další metody, s&nbsp;nimi se však prozatím nesetkáme):</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import sys
&nbsp;
<i># import "jádra" frameworku Qt i modulu pro GUI</i>
from PySide2 import QtCore
from PySide2 import QtGui
&nbsp;
<i># modul pro práci s QML</i>
from PySide2 import QtQuick
&nbsp;
<i># jméno QML s deklarací grafického uživatelského rozhraní</i>
QML_FILE = "01.qml"
&nbsp;
&nbsp;
<i># nový widget bude odvozen od QDeclarativeView</i>
class <strong>MainWindow</strong>(QtQuick.QQuickView):
&nbsp;
    def <strong>__init__</strong>(self, parent=None):
        super(MainWindow, self).__init__(parent)
        <i># nastavení titulku hlavního okna aplikace</i>
        self.setTitle("QML Example @ PySide2")
        <i># načtení souboru QML</i>
        self.setSource(QtCore.QUrl.fromLocalFile(QML_FILE))
        <i># necháme QML změnit velikost okna</i>
        self.setResizeMode(QtQuick.QQuickView.SizeRootObjectToView)
&nbsp;
&nbsp;
def <strong>main</strong>():
    <i># vytvoření Qt aplikace</i>
    app = QtGui.QGuiApplication(sys.argv)
&nbsp;
    <i># vytvoření hlavního okna</i>
    window = MainWindow()
&nbsp;
    <i># zobrazení hlavního okna</i>
    window.show()
&nbsp;
    <i># spuštění aplikace</i>
    sys.exit(app.exec_())
&nbsp;
&nbsp;
if __name__ == '__main__':
    main()
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vizuální porovnání rozdílů mezi skripty psanými v&nbsp;Pythonu</h2>

<p>Pro lepší přehled rozdílů mezi PySide 1 a PySide 2 je na screenshotu
zobrazeném pod tímto odstavcem ukázáno, jak se oba skripty uvedené <a
href="#k03">v&nbsp;předchozí kapitole</a> vizuálně odlišují. I přes snahu o to,
aby si oba zdrojové kódy byly co nejpodobnější, vidíme, že se odlišují použité
třídy a tím pádem i jejich metody, které jsou volány:</p>

<a href="https://www.root.cz/obrazek/331757/"><img src="https://i.iinfo.cz/images/494/pyside2-1-prev.png" class="image-331757" alt="&#160;" width="370" height="219" /></a>
<p><i>Obrázek 2: Vizuální porovnání rozdílu mezi skriptem napsaným pro PySide 1
a skriptem pro PySide 2.</i></p>

<p><div class="rs-tip-major">Poznámka: pro zobrazení rozdílů je použit režim
<i>diff</i> v&nbsp;textovém editoru <i>Vim</i>.</div></p>

<p>Následují odkazy na dokumentaci k&nbsp;jednotlivým třídám (a prozatím jedné
metodě), které se v&nbsp;PySide 1 a PySide 2 odlišují:</p>

<table>
<tr><th>Třída/metoda</th><th>PySide 1</th><th>PySide 2</th></tr>
<tr><td>hlavní aplikace</td><td><a href="https://pyside.github.io/docs/pyside/PySide/QtGui/QApplication.html">QtGui.QApplication</a></td><td><a href="https://doc-snapshots.qt.io/qtforpython/PySide2/QtGui/QGuiApplication.html">QtGui.QGuiApplication</a></td></tr>
<tr><td>předek okna</td><td><a href="https://pyside.github.io/docs/pyside/PySide/QtDeclarative/QDeclarativeView.html">QtDeclarative.QDeclarativeView</a></td><td><a href="https://doc-snapshots.qt.io/qtforpython/PySide2/QtQuick/QQuickView.html">QtQuick.QQuickView</a></td></tr>
<tr><td>titulek okna</td><td>setWindowTitle</td><td>setTitle</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: odlišnost mezi oběma verze PySide je
způsobena tím, že se vlastně jedná o relativně tenké rozhraní mezi
programovacím jazykem Python a nativní knihovnou Qt. Rozdíly jsou tedy
způsobeny (nekompatibilními) změnami provedenými v&nbsp;samotném Qt, které se
PySide nesnaží nijak maskovat.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Přechod od QtQuick 1.0 ke QtQuick 2.0</h2>

<p>O změnách, které musely být provedeny ve skriptech naprogramovaných
v&nbsp;Pythonu, jsme se již zmínili, takže si nyní ukažme, jaké další změny je
nutné udělat v&nbsp;samotných QML souborech s&nbsp;popisem grafického
uživatelského rozhraní. Prozatím zůstaneme u velmi jednoduchého (až
primitivního) příkladu, v&nbsp;němž jsou na plochu okna umístěny tři
různobarevné čtverce, u kterých je pro větší efekt nastavena průhlednost a
jeden čtverec je otočen:</p>

<img src="https://i.iinfo.cz/images/494/pyside2-2.png" class="image-331758" alt="&#160;" width="322" height="267" />
<p><i>Obrázek 3: Okno s&nbsp;jednoduchým GUI &ndash; na ploše okna jsou
zobrazeny tři čtverce s&nbsp;různými vizuálními a geometrickými
vlastnostmi.</i></p>

<p>První varianta QML je určena pro QtQuick 1.0 a tudíž pro PySide 1:</p>

<pre>
import QtQuick 1.0
&nbsp;
<strong>Rectangle</strong> {
    id: main
    width: 320
    height: 240
    color: "lightgray"
&nbsp;
    <strong>Rectangle</strong> {
        id: r1
        width: 160
        height: 160
        color: "red"
        opacity: 0.5
        rotation: 45
        anchors.left: parent.left
        anchors.bottom: parent.bottom
    }
&nbsp;
    <strong>Rectangle</strong> {
        id: r2
        width: 160
        height: 160
        color: "yellow"
        opacity: 0.5
        z: 1
        anchors.horizontalCenter: parent.horizontalCenter
        anchors.top: parent.top
    }
&nbsp;
    <strong>Rectangle</strong> {
        id: r3
        width: 160
        height: 160
        color: "blue"
        opacity: 0.5
        rotation: 45
        anchors.right: parent.right
        anchors.bottom: parent.bottom
    }
}
</pre>

<p>Druhá varianta je již určena pro QtQuick 2.0 a tudíž pro PySide 2:</p>

<pre>
import QtQuick 2.0
&nbsp;
<strong>Rectangle</strong> {
    id: main
    width: 320
    height: 240
    color: "lightgray"
&nbsp;
    <strong>Rectangle</strong> {
        id: r1
        width: 160
        height: 160
        color: "red"
        opacity: 0.5
        rotation: 45
        anchors.left: parent.left
        anchors.bottom: parent.bottom
    }
&nbsp;
    <strong>Rectangle</strong> {
        id: r2
        width: 160
        height: 160
        color: "yellow"
        opacity: 0.5
        z: 1
        anchors.horizontalCenter: parent.horizontalCenter
        anchors.top: parent.top
    }
&nbsp;
    <strong>Rectangle</strong> {
        id: r3
        width: 160
        height: 160
        color: "blue"
        opacity: 0.5
        rotation: 45
        anchors.right: parent.right
        anchors.bottom: parent.bottom
    }
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vizuální porovnání rozdílů mezi oběma QML soubory</h2>

<p>Zatímco mezi skripty napsanými pro knihovnu PySide 1 a PySide 2 bylo <a
href="#k03">relativně velké množství rozdílů</a> (nebyla &ndash; a to naschvál
&ndash; dodržena zpětná kompatibilita), je tomu u QML souborů jinak, alespoň
v&nbsp;našem jednoduchém příkladu grafického uživatelského rozhraní
s&nbsp;trojicí čtverců. Ostatně se můžeme podívat na následující screenshot
zobrazující všechny rozdíly. Ty nastaly na jediném řádku, ovšem je zapotřebí
poznamenat, že se skutečně jedná o primitivní příklad a v&nbsp;praxi (reálná
GUI) tomu bude jinak:</p>

<a href="https://www.root.cz/obrazek/331759/"><img src="https://i.iinfo.cz/images/494/pyside2-3-prev.png" class="image-331759" alt="&#160;" width="370" height="219" /></a>
<p><i>Obrázek 4: Vizuální porovnání rozdílu mezi QML napsaným pro QtQuick 1.0 a
QML pro QtQuick 2.0.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Univerzální modul určený pro načtení a zobrazení QML aplikace</h2>

<p>Ve všech demonstračních příkladech popsaných v&nbsp;navazujících kapitolách
budeme používat &bdquo;univerzální&ldquo; modul, který je určený pro vytvoření
hlavního okna aplikace, načtení zvoleného QML souboru a inicializaci grafického
uživatelského rozhraní. Modul neobsahuje přímo spustitelný kód
(<strong>__main__</strong>), takže ho budeme používat jako knihovnu a tím pádem
se nám zdrojové kódy příkladů zminimalizují na doslova několik řádků. Ve
skutečnosti sice není dále uvedený skript zcela univerzální, protože nedokáže
zpracovat QML soubory s&nbsp;deklarací hlavního okna, ovšem to nám pro účely
dnešního článku nebude vadit (případná vylepšení budou popsána příště). Úplný
zdrojový kód výše popsaného modulu naleznete na adrese <a
href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/QmlViewer.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/QmlViewer.py</a>:</p>

<pre>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i># univerzální prohlížeč QML souborů</i>
&nbsp;
import sys
&nbsp;
<i># import "jádra" frameworku Qt i modulu pro GUI</i>
from PySide2 import QtCore
from PySide2 import QtGui
&nbsp;
<i># modul pro práci s QML</i>
from PySide2 import QtQuick
&nbsp;
&nbsp;
<i># nový widget bude odvozen od QDeclarativeView</i>
class <strong>MainWindow</strong>(QtQuick.QQuickView):
&nbsp;
    def <strong>__init__</strong>(self, qml_file, parent=None):
        super(MainWindow, self).__init__(parent)
        <i># nastavení titulku hlavního okna aplikace</i>
        self.setTitle("QML Example @ PySide2: " + qml_file)
        <i># načtení souboru QML</i>
        self.setSource(QtCore.QUrl.fromLocalFile(qml_file))
        <i># necháme QML změnit velikost okna</i>
        self.setResizeMode(QtQuick.QQuickView.SizeRootObjectToView)
&nbsp;
&nbsp;
def <strong>main</strong>(qml_file):
    <i># vytvoření Qt aplikace</i>
    app = QtGui.QGuiApplication(sys.argv)
&nbsp;
    <i># vytvoření hlavního okna</i>
    window = MainWindow(qml_file)
&nbsp;
    <i># zobrazení hlavního okna na desktopu</i>
    window.show()
&nbsp;
    <i># spuštění aplikace</i>
    sys.exit(app.exec_())
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Příklad použití modulu popsaného v&nbsp;předchozí kapitole</h2>

<p>Podívejme se nyní, jak se <a href="#k06">výše popsaný</a> modul
<strong>QmlViewer</strong> použije. Další demonstrační příklad je skutečně
velmi krátký, protože obsahuje pouze import modulu <strong>QmlViewer</strong>,
definici QML souboru s&nbsp;popisem grafického uživatelského rozhraní a
zavolání funkce <strong>main</strong> deklarované v&nbsp;modulu (pro
rozsáhlejší aplikace je vhodnější provést <strong>import QmlViewer</strong>,
aby nedocházelo k&nbsp;&bdquo;zašpinění&ldquo; jmenného prostoru:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from QmlViewer import *
&nbsp;
QML_FILE = "02_use_qml_viewer.qml"
&nbsp;
if __name__ == '__main__':
    main(QML_FILE)
</pre>

<img src="https://i.iinfo.cz/images/494/pyside2-4.png" class="image-331760" alt="&#160;" width="322" height="267" />
<p><i>Obrázek 5: Výsledek v&nbsp;této kapitole popsaného demonstračního
příkladu.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Kotevní přímky a jejich vliv na umístění a rozměry prvků</h2>

<p>Již <a
href="https://www.root.cz/clanky/jazyk-qml-qt-modeling-language-a-pyside/">v&nbsp;předchozí
části</a> tohoto seriálu jsme se zmínili o tom, že jednou z&nbsp;možností
rozmístění ovládacích prvků grafického uživatelského rozhraní do plochy oken a
dialogů představuje použití takzvaných <i>kotevních přímek</i>, což jsou
virtuální prvky procházející jak všemi čtyřmi krajními body prvků (vlevo,
vpravo, nahoře i dole), tak i jejich středy. Změnou umístění těchto přímek se
mění i velikost (plocha) prvků. V&nbsp;dalším příkladu je ukázán způsob
rozmístění tří obdélníků v&nbsp;ploše okna.</p>

<p>První obdélník (červený) je &bdquo;přilepen&ldquo; k&nbsp;hornímu, spodnímu
a současně i k&nbsp;levému okraji okna. Jeho šířka je nastavena na 64 délkových
jednotek (zde pixelů) a vzhledem k&nbsp;tomu, že pravý okraj obdélníku není
ničím omezen, bude tato šířka zachována i při změně velikosti okna:</p>

<pre>
<strong>Rectangle</strong> {
    id: r1
    width: 64
    color: "red"
    opacity: 0.5
    anchors.left: parent.left
    anchors.top: parent.top
    anchors.bottom: parent.bottom
}
</pre>

<p>Třetí obdélník (modrý) má taktéž šířku 64 délkových jednotek a je
&bdquo;přilepen&ldquo; k&nbsp;hornímu, spodnímu a pravému okraji okna. Jeho
šířka zůstane opět zachována i ve chvíli, kdy se velikost okna z&nbsp;různých
důvodů změní:</p>

<pre>
<strong>Rectangle</strong> {
    id: r3
    width: 64
    height: 160
    color: "blue"
    opacity: 0.5
    anchors.right: parent.right
    anchors.top: parent.top
    anchors.bottom: parent.bottom
}
</pre>

<p>A konečně prostřední (žlutý) obdélník má nastavenou šířku i výšku na 160
délkových jednotek a je vycentrován:</p>

<pre>
<strong>Rectangle</strong> {
    id: r2
    width: 160
    height: 160
    color: "yellow"
    opacity: 0.5
    z: 1
    anchors.horizontalCenter: parent.horizontalCenter
    anchors.verticalCenter: parent.verticalCenter
}
</pre>

<p>Podívejme se nyní na chování všech tří prvků při změně velikosti okna:</p>

<img src="https://i.iinfo.cz/images/494/pyside2-5.png" class="image-331761" alt="&#160;" width="322" height="267" />
<p><i>Obrázek 6: Rozmístění prvků &ndash; původní velikost okna.</i></p>

<img src="https://i.iinfo.cz/images/494/pyside2-6.png" class="image-331762" alt="&#160;" width="499" height="280" />
<p><i>Obrázek 7: Rozmístění prvků v&nbsp;širším okně.</i></p>

<p>U užšího okna dojde k&nbsp;překryvu prvků a to z&nbsp;toho důvodu, že nikde
nespecifikujeme jejich <i>vzájemné</i> postavení:</p>

<img src="https://i.iinfo.cz/images/494/pyside2-7.png" class="image-331763" alt="&#160;" width="212" height="256" />
<p><i>Obrázek 8: Rozmístění prvků v&nbsp;užším okně.</i></p>

<p>Extrémní případ, kdy se překrývají všechny tři prvky:</p>

<img src="https://i.iinfo.cz/images/494/pyside2-8.png" class="image-331764" alt="&#160;" width="100" height="238" />
<p><i>Obrázek 9: Rozmístění prvků v&nbsp;ještě užším okně.</i></p>

<p>Úplný zdrojový kód tohoto příkladu vypadá následovně:</p>

<pre>
import QtQuick 2.0
&nbsp;
<strong>Rectangle</strong> {
    id: main
    width: 320
    height: 240
    color: "lightgray"
&nbsp;
    <strong>Rectangle</strong> {
        id: r1
        width: 64
        color: "red"
        opacity: 0.5
        anchors.left: parent.left
        anchors.top: parent.top
        anchors.bottom: parent.bottom
    }
&nbsp;
    <strong>Rectangle</strong> {
        id: r2
        width: 160
        height: 160
        color: "yellow"
        opacity: 0.5
        z: 1
        anchors.horizontalCenter: parent.horizontalCenter
        anchors.verticalCenter: parent.verticalCenter
    }
&nbsp;
    <strong>Rectangle</strong> {
        id: r3
        width: 64
        height: 160
        color: "blue"
        opacity: 0.5
        anchors.right: parent.right
        anchors.top: parent.top
        anchors.bottom: parent.bottom
    }
}
</pre>

<p>Zdrojový kód demonstračního příkladu využívá modul
<strong>QmlViewer</strong>:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from <strong>QmlViewer</strong> import *
&nbsp;
QML_FILE = "03_springy_widgets.qml"
&nbsp;
if __name__ == '__main__':
    main(QML_FILE)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Použití rastrových obrázků v&nbsp;GUI</h2>

<p>Při tvorbě grafického uživatelského rozhraní reálných aplikací se většinou
neobejdeme bez nutnosti použití rastrových obrázků, které například mohou
sloužit jako ikony. Pro tento účel slouží prvek nazvaný jednoduše
<strong>Image</strong>. Důležitým atributem tohoto prvku je atribut nazvaný
<strong>source</strong> se jménem souboru s&nbsp;uloženým rastrovým obrázkem
(tento atribut je typu <i>string</i> a proto by měl být zapsán
v&nbsp;uvozovkách). Podporovány jsou samozřejmě i obrázky uložené ve formátu
<a href="https://www.root.cz/clanky/png-is-not-gif/">PNG</a>:</p>

<pre>
<strong>Image</strong> {
    id: image
    source: "images/voronoi.png"
    anchors.horizontalCenter: parent.horizontalCenter
    anchors.verticalCenter: parent.verticalCenter
}
</pre>

<p><div class="rs-tip-major">Poznámka: využití rastrových obrázků může být pro
některé typy aplikací poněkud omezující, protože celé QML je navrženo takovým
způsobem, aby bylo použitelné i na smartphonech a podobných zařízeních
s&nbsp;odlišnými proporcemi displejů v&nbsp;porovnání s&nbsp;klasickými
desktopy. Ovšem záleží samozřejmě na tom, jaká aplikace se vlastně vytváří a
jak omezující mohou být například malé pidiikonky 22&times;22 pixelů, které
jsou stále v&nbsp;desktopových aplikacích poměrně masivně používány.</div></p>

<img src="https://i.iinfo.cz/images/494/pyside2-9.png" class="image-331765" alt="&#160;" width="322" height="267" />
<p><i>Obrázek 10: Umístění rastrového obrázku do plochy okna.</i></p>

<p>Podívejme se nyní na zdrojový kód demonstračního příkladu, v&nbsp;němž je
použit rastrový obrázek bez uvedení velikosti a kromě tohoto obrázku dva
obdélníky, které tvoří jeho pravý a levý okraj. Vzhledem k&nbsp;tomu, že
velikost rastrového obrázku není explicitně zadána, zjistí se z&nbsp;jeho
aktuálních rozměrů (metadat) popř.&nbsp;pouze z&nbsp;rozlišení:</p>

<pre>
import QtQuick 2.0
&nbsp;
<strong>Rectangle</strong> {
    id: main
    width: 320
    height: 240
    color: "lightgray"
&nbsp;
    <strong>Rectangle</strong> {
        id: left_rectangle
        color: "red"
        opacity: 0.5
        anchors.left: parent.left
        anchors.right: image.left
        anchors.top: parent.top
        anchors.bottom: parent.bottom
    }
&nbsp;
    <strong>Image</strong> {
        id: image
        source: "images/voronoi.png"
        anchors.horizontalCenter: parent.horizontalCenter
        anchors.verticalCenter: parent.verticalCenter
    }
&nbsp;
    <strong>Rectangle</strong> {
        id: right_rectangle
        color: "blue"
        opacity: 0.5
        anchors.left: image.right
        anchors.right: parent.right
        anchors.top: parent.top
        anchors.bottom: parent.bottom
    }
}
</pre>

<p>Zdrojový kód demonstračního příkladu opět využívá modul
<strong>QmlViewer</strong>:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from <strong>QmlViewer</strong> import *
&nbsp;
QML_FILE = "04_raster_image.qml"
&nbsp;
if __name__ == '__main__':
    main(QML_FILE)
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Načtení a zobrazení vektorových výkresů v&nbsp;GUI</h2>

<p>Kromě rastrových obrázků podporuje jazyk QML i použití vektorových výkresů
(či kreseb) uložených ve formátu <a
href="https://www.root.cz/clanky/vektorovy-graficky-format-svg/">SVG</a>.
K&nbsp;tomuto účelu se používá stejný prvek nazvaný <strong>Image</strong>, se
kterým jsme se seznámili <a href="#k09">v&nbsp;předchozí kapitole</a>. Většina
vektorových kreseb má sice zadané rozměry, ty nám však nemusí vyhovovat, takže
je možné zadat vlastní šířku a výšku. Zvětšení či zmenšení vektorové kresby se
samozřejmě obejde bez ztráty kvality výsledku:</p>

<pre>
<strong>Image</strong> {
    id: left_image
    source: "editors/vim.svg"
    width: 200
    height: 200
    anchors.horizontalCenter: parent.horizontalCenter
}
</pre>

<p>Podívejme se nyní na demonstrační příklad, v&nbsp;němž je trojice
vektorových kreseb (konkrétně ikon tří slavných textových editorů) umístěna do
okna, a to tak, že jsou všechny kresby vycentrovány. Vzhledem k&nbsp;tomu, že
kresby mají průhledné pozadí, jsou všechny tři ikony stále dobře
rozeznatelné:</p>

<img src="https://i.iinfo.cz/images/494/pyside2-10.png" class="image-331766" alt="&#160;" width="322" height="267" />
<p><i>Obrázek 11: Umístění tří vektorových kreseb do plochy okna. Všechny
kresby jsou vycentrovány a zobrazeny přes sebe.</i></p>

<p>Následuje úplný zdrojový kód tohoto příkladu:</p>

<pre>
import QtQuick 2.0
&nbsp;
<strong>Rectangle</strong> {
    id: main
    width: 320
    height: 240
    color: "lightgray"
&nbsp;
    <strong>Image</strong> {
        id: left_image
        source: "editors/vim.svg"
        width: 200
        height: 200
        anchors.horizontalCenter: parent.horizontalCenter
    }
&nbsp;
    <strong>Image</strong> {
        id: center_image
        source: "editors/emacs.svg"
        width: 200
        height: 200
        anchors.horizontalCenter: parent.horizontalCenter
    }
&nbsp;
    <strong>Image</strong> {
        id: right_image
        source: "editors/atom.svg"
        width: 200
        height: 200
        anchors.horizontalCenter: parent.horizontalCenter
    }
}
</pre>

<p>Skript určený pro načtení QML:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from <strong>QmlViewer</strong> import *
&nbsp;
QML_FILE = "05_vector_drawings_A.qml"
&nbsp;
if __name__ == '__main__':
    main(QML_FILE)
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Korektní rozmístění vektorových výkresů na plochu okna</h2>

<p>Předchozí příklad byl sice zajímavý z&nbsp;technologického hlediska, ale
v&nbsp;praktických aplikacích samozřejmě budou zákazníci vyžadovat, aby se
jednotlivé prvky grafického uživatelského rozhraní umístily vedle sebe a nikoli
na sebe. Úprava je ve skutečnosti snadná &ndash; u všech tří vektorových
výkresů zvolíme vycentrování ve vertikální ose:</p>

<pre>
anchors.verticalCenter: parent.verticalCenter
</pre>

<p>Naproti tomu na horizontální ose bude zarovnání odlišné &ndash; první výkres
bude &bdquo;přilepen&ldquo; k&nbsp;levému okraji okna, druhý výkres zůstane
vycentrován a konečně třetí výkres bude &bdquo;přilepen&ldquo; k&nbsp;okraji
pravému:</p>

<pre>
<i>// první</i>
anchors.left: parent.left
&nbsp;
<i>// druhý</i>
anchors.verticalCenter: parent.verticalCenter
&nbsp;
<i>// třetí</i>
anchors.right: parent.right
</pre>

<img src="https://i.iinfo.cz/images/494/pyside2-11.png" class="image-331767" alt="&#160;" width="322" height="267" />
<p><i>Obrázek 12: Takto má vypadat korektní rozmístění všech tří vektorových
výkresů na ploše okna.</i></p>

<p>Upravený QML kód vypadá následovně:</p>

<pre>
import QtQuick 2.0
&nbsp;
<strong>Rectangle</strong> {
    id: main
    width: 320
    height: 240
    color: "lightgray"
&nbsp;
    <strong>Image</strong> {
        id: left_image
        source: "editors/vim.svg"
        width: 100
        height: 100
        anchors.verticalCenter: parent.verticalCenter
        anchors.left: parent.left
    }
&nbsp;
    <strong>Image</strong> {
        id: center_image
        source: "editors/emacs.svg"
        width: 100
        height: 100
        anchors.horizontalCenter: parent.horizontalCenter
        anchors.verticalCenter: parent.verticalCenter
    }
&nbsp;
    <strong>Image</strong> {
        id: right_image
        source: "editors/atom.svg"
        width: 100
        height: 100
        anchors.verticalCenter: parent.verticalCenter
        anchors.right: parent.right
    }
}
</pre>

<p>Skript určený pro načtení QML vypadá prakticky totožně, jako skript
předchozí, samozřejmě až na odlišné jméno QML výkresu:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from <strong>QmlViewer</strong> import *
&nbsp;
QML_FILE = "05_vector_drawings_B.qml"
&nbsp;
if __name__ == '__main__':
    main(QML_FILE)
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Relativní velikost výkresu: atribut <strong>fillMode</strong></h2>

<p>Další zajímavou možností, která se může hodit například při programování
různých prohlížečů obrázků, CAD atd., je použití atributu pojmenovaného
<strong>fillMode</strong>. Název tohoto atributu může být matoucí, protože se
nejedná o specifikaci barvy pozadí, která má vyplnit nějakou plochu, ale o
určení, jak má widget změnit svoji velikost při změně velikosti svého předka
(<i>parent</i>). Můžeme si to vyzkoušet. U prvního obrázku (či kresby) zvolíme,
že se má obrázek zvětšovat v&nbsp;závislosti na velikosti předka, ovšem
současně musí být zachován poměr šířka:výška:</p>

<pre>
<strong>Image</strong> {
    id: left_image
    source: "editors/vim.svg"
    <strong>fillMode: Image.PreserveAspectFit</strong>
    anchors.verticalCenter: parent.verticalCenter
    anchors.left: parent.left
    anchors.right: center_image.left
}
</pre>

<p>Naproti tomu u obrázku druhého explicitně zvolíme jeho velikost:</p>

<pre>
<strong>Image</strong> {
    id: center_image
    source: "editors/emacs.svg"
    <strong>width: 100</strong>
    <strong>height: 100</strong>
    anchors.horizontalCenter: parent.horizontalCenter
    anchors.verticalCenter: parent.verticalCenter
}
</pre>

<p>Odlišné chování obou obrázků můžeme porovnat na následující dvojici
screenshotů:</p>

<img src="https://i.iinfo.cz/images/494/pyside2-12.png" class="image-331768" alt="&#160;" width="329" height="351" />
<p><i>Obrázek 13: Původní velikost widgetů v&nbsp;okně.</i></p>

<img src="https://i.iinfo.cz/images/494/pyside2-13.png" class="image-331769" alt="&#160;" width="551" height="357" />
<p><i>Obrázek 14: Velikost widgetů po zvětšení okna.</i></p>

<p>Opět si ukažme úplný zdrojový kód tohoto příkladu:</p>

<pre>
import QtQuick 2.0
&nbsp;
<strong>Rectangle</strong> {
    id: main
    width: 320
    height: 240
    color: "lightgray"
&nbsp;
    <strong>Image</strong> {
        id: left_image
        source: "editors/vim.svg"
        fillMode: Image.PreserveAspectFit
        anchors.verticalCenter: parent.verticalCenter
        anchors.left: parent.left
        anchors.right: center_image.left
    }
&nbsp;
    <strong>Image</strong> {
        id: center_image
        source: "editors/emacs.svg"
        width: 100
        height: 100
        anchors.horizontalCenter: parent.horizontalCenter
        anchors.verticalCenter: parent.verticalCenter
    }
&nbsp;
    <strong>Image</strong> {
        id: right_image
        source: "editors/atom.svg"
        fillMode: Image.PreserveAspectFit
        anchors.verticalCenter: parent.verticalCenter
        anchors.right: parent.right
        anchors.left: center_image.right
    }
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Další způsoby rozmístění prvků GUI na ploše okna</h2>

<p>Prozatím jsme si ukázali pouze jeden způsob rozmístění prvků grafického
uživatelského rozhraní na plochu okna popř.&nbsp;na plochu jakéhokoli předka.
Jednalo se o použití kotevních přímek, které jsou sice velmi flexibilní, ovšem
jejich použití může být problematické například při návrhu uživatelského
rozhraní v&nbsp;Qt Creatoru a podobných nástrojích. I z&nbsp;tohoto důvodu QML
umožňuje použít další <i>správce geometrie</i> (v&nbsp;QML se sice toto
označení většinou nepoužívá, ovšem jedná se o ustálený termín). Mezi
alternativní správce geometrie patří především běžná mřížka (<i>grid</i>), dále
pak správce pro umístění komponent do jednoho sloupce (<i>column</i>) a další
pro umístění komponent do jednoho řádku (<i>row</i>). Jednotlivé správce
geometrie je samozřejmě možné kombinovat a použít tak například <i>column</i>
pro základní rozvržení hlavního okna (menu, nástrojový pruh, hlavní plocha,
stavový řádek) a uvnitř použít správce další, například <i>row</i> pro
nástrojový pruh.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Správce geometrie <strong>Grid</strong></h2>

<p>Při použití správce geometrie, který se jmenuje příznačně <i>Grid</i>, se
jednotlivé prvky grafického uživatelského rozhraní umisťují do neviditelné
mřížky. Velikost mřížky (šířky sloupců a výšky řádků) je automaticky měněna
takovým způsobem, aby se do ní všechny vkládané widgety umístily
v&nbsp;&bdquo;rozumné&ldquo; či nastavené velikosti. Programově je však možné
měnit vzdálenost mezi jednotlivými widgety a tím také měnit velikost mřížky.
Taktéž je možné nastavit šířky mezer mezi jednotlivými buňkami a důležité je
specifikovat i počet sloupců (zatímco počet řádků se již dopočítá automaticky
podle počtu vkládaných widgetů):</p>

<pre>
<strong>Grid</strong> {
    columns: 3
    spacing: 2
    anchors.verticalCenter: parent.verticalCenter
    anchors.horizontalCenter: parent.horizontalCenter
    ...
    ...
    ...
}
</pre>

<img src="https://i.iinfo.cz/images/494/pyside2-14.png" class="image-331770" alt="&#160;" width="322" height="267" />
<p><i>Obrázek 16: Ukázka použití správce geometrie
<strong>Grid</strong>.</i></p>

<p>V&nbsp;následujícím demonstračním příkladu je do pomyslné mřížky vloženo
hned několik prvků grafického uživatelského rozhraní. Konkrétně se jedná o pět
obdélníků různých barev a velikostí a taktéž o vektorový obrázek. Povšimněte si
(i když samotná mřížka není viditelná), že se šířky sloupců a výšky řádků
upravují na základě velikosti jednotlivých komponent do mřížky vkládaných:</p>

<pre>
import QtQuick 2.0
&nbsp;
&nbsp;
<strong>Rectangle</strong> {
    id: main
    width: 320
    height: 240
    color: "lightgray"
&nbsp;
    <strong>Grid</strong> {
        columns: 3
        spacing: 2
        anchors.verticalCenter: parent.verticalCenter
        anchors.horizontalCenter: parent.horizontalCenter
&nbsp;
        <strong>Rectangle</strong> {
            color: "#ff8080"
            width: 75
            height: 75
        }
&nbsp;
        <strong>Rectangle</strong> {
            color: "yellow"
            width: 32
            height: 75
        }
&nbsp;
        <strong>Rectangle</strong> {
            color: "#8080ff"
            width: 75
            height: 32
        }
&nbsp;
        <strong>Rectangle</strong> {
            color: "#8080ff"
            width: 75
            height: 75
        }
&nbsp;
        <strong>Rectangle</strong> {
            color: "black"
            width: 10
            height: 10
        }
&nbsp;
        <strong>Image</strong> {
            id: left_image
            source: "editors/vim.svg"
            width: 100
            height: 100
        }
    }
}
</pre>

<p>Skript pro načtení a zobrazení QML souboru:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from <strong>QmlViewer</strong> import *
&nbsp;
QML_FILE = "08_grid.qml"
&nbsp;
if __name__ == '__main__':
    main(QML_FILE)
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Správce geometrie <strong>Column</strong></h2>

<p>Další správce geometrie se jmenuje <strong>Column</strong> a jeho chování
při rozmisťování prvků přesně odpovídá jeho jménu &ndash; prvky jsou jednoduše
umístěny do jediného sloupce, přičemž je ovšem samozřejmě možné nastavit jejich
velikost a zarovnání doleva a doprava. Šířka sloupce se přizpůsobuje šířce
jednotlivých prvků. Příklad použití:</p>

<pre>
<strong>Column</strong> {
    spacing: 2
    anchors.verticalCenter: parent.verticalCenter
    anchors.horizontalCenter: parent.horizontalCenter
    ...
    ...
    ...
}
</pre>

<p><div class="rs-tip-major">Poznámka: opět si povšimněte, že i prvek
<strong>Column</strong> je zapotřebí správně umístit do jeho rodičovského
prvku.</div></p>

<img src="https://i.iinfo.cz/images/494/pyside2-15.png" class="image-331771" alt="&#160;" width="242" height="427" />
<p><i>Obrázek 16: Ukázka použití správce geometrie
<strong>Column</strong>.</i></p>

<p>V&nbsp;demonstračním příkladu použijeme stejné prvky, jako v&nbsp;příkladu
předchozím &ndash; jednu vektorovou kresbu a sadu obdélníků. Ovšem budeme muset
změnit velikost okna, aby se do něj všechny prvky vešly:</p>

<pre>
import QtQuick 2.0
&nbsp;
&nbsp;
<strong>Rectangle</strong> {
    id: main
    width: 240
    height: 400
    color: "lightgray"
&nbsp;
    <strong>Column</strong> {
        spacing: 2
        anchors.verticalCenter: parent.verticalCenter
        anchors.horizontalCenter: parent.horizontalCenter
&nbsp;
        <strong>Rectangle</strong> {
            color: "#ff8080"
            width: 75
            height: 75
        }
&nbsp;
        <strong>Rectangle</strong> {
            color: "yellow"
            width: 32
            height: 75
        }
&nbsp;
        <strong>Rectangle</strong> {
            color: "#8080ff"
            width: 75
            height: 32
        }
&nbsp;
        <strong>Rectangle</strong> {
            color: "#8080ff"
            width: 75
            height: 75
        }
&nbsp;
        <strong>Rectangle</strong> {
            color: "black"
            width: 10
            height: 10
        }
&nbsp;
        <strong>Image</strong> {
            id: left_image
            source: "editors/vim.svg"
            width: 100
            height: 100
        }
    }
}
</pre>

<p>Skript pro načtení a zobrazení QML souboru:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from <strong>QmlViewer</strong> import *
&nbsp;
QML_FILE = "09_column.qml"
&nbsp;
if __name__ == '__main__':
    main(QML_FILE)
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Správce geometrie <strong>Row</strong></h2>

<p>Jak již zajisté správně tušíte, existuje vedle správce geometrie
<strong>Column</strong> i správce geometrie nazvaný <strong>Row</strong>,
s&nbsp;jehož použitím jsou jednotlivé prvky grafického uživatelského rozhraní
umisťovány do jednoho řádku:</p>

<pre>
<strong>Row</strong> {
    spacing: 2
    anchors.verticalCenter: parent.verticalCenter
    anchors.horizontalCenter: parent.horizontalCenter
    ...
    ...
    ...
}
</pre>

<img src="https://i.iinfo.cz/images/494/pyside2-16.png" class="image-331772" alt="&#160;" width="402" height="267" />
<p><i>Obrázek 17: Ukázka použití správce geometrie
<strong>Row</strong>.</i></p>

<p>Opět si ukažme příklad, v&nbsp;němž jsou jednotlivé prvky (vektorová kresba
a sada obdélníků) umístěny s&nbsp;využitím správce geometrie
<strong>Row</strong>:</p>

<pre>
import QtQuick 2.0
&nbsp;
&nbsp;
<strong>Rectangle</strong> {
    id: main
    width: 320
    height: 240
    color: "lightgray"
&nbsp;
    <strong>Row</strong> {
        spacing: 2
        anchors.verticalCenter: parent.verticalCenter
        anchors.horizontalCenter: parent.horizontalCenter
&nbsp;
        <strong>Rectangle</strong> {
            color: "#ff8080"
            width: 75
            height: 75
        }
&nbsp;
        <strong>Rectangle</strong> {
            color: "yellow"
            width: 32
            height: 75
        }
&nbsp;
        <strong>Rectangle</strong> {
            color: "#8080ff"
            width: 75
            height: 32
        }
&nbsp;
        <strong>Rectangle</strong> {
            color: "#8080ff"
            width: 75
            height: 75
        }
&nbsp;
        <strong>Rectangle</strong> {
            color: "black"
            width: 10
            height: 10
        }
&nbsp;
        <strong>Image</strong> {
            id: left_image
            source: "editors/vim.svg"
            width: 100
            height: 100
        }
    }
}
</pre>

<p>Skript pro načtení a zobrazení QML souboru je až na jméno QML totožný
s&nbsp;předchozími skripty:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from <strong>QmlViewer</strong> import *
&nbsp;
QML_FILE = "10_row.qml"
&nbsp;
if __name__ == '__main__':
    main(QML_FILE)
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Tvorba animací v&nbsp;Pyside &ndash; použití automaticky modifikované proměnné řídicí animaci</h2>

<p>Prozatím jen ve stručnosti se dnes seznámíme s&nbsp;další důležitou
vlastností QML (a nepřímo též PySide). Jedná se o podporu animací, které mohou
probíhat buď zcela automaticky nebo s&nbsp;využitím pomocných skriptů, jenž
mohou reagovat na akce prováděné uživatelem. V&nbsp;dalším příkladu je ukázána
základní animace, která využívá řídicí proměnnou nazvanou
<strong>animatedValue</strong>:</p>

<pre>
property int animatedValue: 0
</pre>

<p>Tato proměnná je automaticky periodicky měněna od 0 do 9 a potom zpět
k&nbsp;nule. Interval změny 0&rarr;9 je nastaven na jednu sekundu (1000 ms);
interval změny 9&rarr;0 je taktéž roven jedné sekundě:</p>

<pre>
<strong>SequentialAnimation</strong> on animatedValue {
    loops: Animation.Infinite
    PropertyAnimation { to: 10; duration: 1000 }
    PropertyAnimation { to: 0; duration: 1000 }
}
</pre>

<p>Úplný zdrojový kód příkladu:</p>

<pre>
import QtQuick 2.0
&nbsp;
&nbsp;
<strong>Rectangle</strong> {
    color: "lightgray"
    width: 200
    height: 200
&nbsp;
    property int animatedValue: 0
    <strong>SequentialAnimation</strong> on animatedValue {
        loops: Animation.Infinite
        PropertyAnimation { to: 10; duration: 1000 }
        PropertyAnimation { to: 0; duration: 1000 }
    }
&nbsp;
    <strong>Text</strong> {
        anchors.centerIn: parent
        text: parent.animatedValue
    }
}
</pre>

<p>Pro jistotu ještě jednou skript pro načtení QML a inicializaci GUI:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from <strong>QmlViewer</strong> import *
&nbsp;
QML_FILE = "11_animation_control_variable.qml"
&nbsp;
if __name__ == '__main__':
    main(QML_FILE)
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Další ukázky animace &ndash; plynulá změna velikosti vektorových kreseb</h2>

<p>Nic nás samozřejmě neomezuje v&nbsp;použití pouze jediné proměnné, jejíž
hodnota se automaticky mění. V&nbsp;dalším skriptu jsou použity hned tři
proměnné:</p>

<pre>
property int animatedValue1: 50
property int animatedValue2: 50
property int animatedValue3: 50
</pre>

<p>Tyto proměnné mění velikosti tří vektorových kreseb umístěných do hlavního
okna (situaci máme ulehčenou tím, že všechna tři loga textových editorů mají
shodnou šířku a výšku):</p>

<pre>
<strong>Image</strong> {
    id: left_image
    source: "editors/vim.svg"
    <strong>width: parent.animatedValue1</strong>
    <strong>height: parent.animatedValue1</strong>
    anchors.verticalCenter: parent.verticalCenter
    anchors.left: parent.left
}
</pre>

<p>Úplný zdrojový kód příkladu dnes již posledního příkladu vypadá takto:</p>

<pre>
import QtQuick 2.0
&nbsp;
<strong>Rectangle</strong> {
    id: main
    width: 320
    height: 240
    color: "lightgray"
&nbsp;
    property int animatedValue1: 50
    <strong>SequentialAnimation</strong> on animatedValue1 {
        loops: Animation.Infinite
        PropertyAnimation { to: 100; duration: 1000 }
        PropertyAnimation { to: 50; duration: 1000 }
    }
&nbsp;
    property int animatedValue2: 50
    <strong>SequentialAnimation</strong> on animatedValue2 {
        loops: Animation.Infinite
        PropertyAnimation { to: 100; duration: 2000 }
        PropertyAnimation { to: 50; duration: 2000 }
    }
&nbsp;
    property int animatedValue3: 50
    <strong>SequentialAnimation</strong> on animatedValue3 {
        loops: Animation.Infinite
        PropertyAnimation { to: 100; duration: 3000 }
        PropertyAnimation { to: 50; duration: 3000 }
    }
&nbsp;
    property int animatedValue4: 0
    <strong>SequentialAnimation</strong> on animatedValue4 {
        loops: Animation.Infinite
        PropertyAnimation { to: 320; duration: 6000 }
        PropertyAnimation { to: 0; duration: 6000 }
    }
&nbsp;
    <strong>Image</strong> {
        id: left_image
        source: "editors/vim.svg"
        width: parent.animatedValue1
        height: parent.animatedValue1
        anchors.verticalCenter: parent.verticalCenter
        anchors.left: parent.left
    }
&nbsp;
    <strong>Image</strong> {
        id: center_image
        source: "editors/emacs.svg"
        width: parent.animatedValue2
        height: parent.animatedValue2
        anchors.horizontalCenter: parent.horizontalCenter
        anchors.verticalCenter: parent.verticalCenter
    }
&nbsp;
    <strong>Image</strong> {
        id: right_image
        source: "editors/atom.svg"
        width: parent.animatedValue3
        height: parent.animatedValue3
        anchors.verticalCenter: parent.verticalCenter
        anchors.right: parent.right
    }
&nbsp;
    <strong>Rectangle</strong> {
        id: r1
        width: parent.animatedValue4
        height: 30
        color: "red"
        opacity: 0.5
        anchors.left: parent.left
        anchors.top: parent.top
    }
&nbsp;
}
</pre>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from <strong>QmlViewer</strong> import *
&nbsp;
QML_FILE = "12_animation_vector_images.qml"

if __name__ == '__main__':
    main(QML_FILE)
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů byly, podobně
jako tomu bylo i v&nbsp;předchozích článcích, uloženy do Git repositáře
dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Pokud nechcete klonovat celý repositář, můžete namísto toho použít odkazy na
jednotlivé příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Adresa</th></tr>
<tr><td> 1</td><td>01_load_qml.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/01_load_qml.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/01_load_qml.py</a></td></tr>
<tr><td> 2</td><td>QmlViewer.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/QmlViewer.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/QmlViewer.py</a></td></tr>
<tr><td> 3</td><td>02_use_qml_viewer.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/02_use_qml_viewer.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/02_use_qml_viewer.py</a></td></tr>
<tr><td> 4</td><td>03_springy_widgets.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/03_springy_widgets.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/03_springy_widgets.py</a></td></tr>
<tr><td> 5</td><td>04_raster_image.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/04_raster_image.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/04_raster_image.py</a></td></tr>
<tr><td> 6</td><td>05_vector_drawings_A.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/05_vector_drawings_A.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/05_vector_drawings_A.py</a></td></tr>
<tr><td> 7</td><td>06_vector_drawings_B.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/06_vector_drawings_B.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/06_vector_drawings_B.py</a></td></tr>
<tr><td> 8</td><td>07_vector_drawings_C.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/07_vector_drawings_C.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/07_vector_drawings_C.py</a></td></tr>
<tr><td> 9</td><td>08_grid.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/08_grid.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/08_grid.py</a></td></tr>
<tr><td>10</td><td>09_column.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/09_column.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/09_column.py</a></td></tr>
<tr><td>11</td><td>10_row.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/10_row.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/10_row.py</a></td></tr>
<tr><td>12</td><td>11_animation_control_variable.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/11_animation_control_variable.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/11_animation_control_variable.py</a></td></tr>
<tr><td>13</td><td>12_animation_vector_images.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/12_animation_vector_images.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/12_animation_vector_images.py</a></td></tr>
</table>

<p>Následuje tabulka s&nbsp;odkazy na soubory QML s&nbsp;popisem grafického
uživatelského rozhraní, které taktéž budete potřebovat:</p>

<table>
<tr><th> #</th><th>QML soubor</th><th>Adresa</th></tr>
<tr><td> 1</td><td>01.qml</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/01.qml">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/01.qml</a></td></tr>
<tr><td> 2</td><td>03_springy_widgets.qml</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/03_springy_widgets.qml">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/03_springy_widgets.qml</a></td></tr>
<tr><td> 3</td><td>04_raster_image.qml</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/04_raster_image.qml">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/04_raster_image.qml</a></td></tr>
<tr><td> 4</td><td>05_vector_drawings_A.qml</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/05_vector_drawings_A.qml">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/05_vector_drawings_A.qml</a></td></tr>
<tr><td> 5</td><td>06_vector_drawings_B.qml</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/06_vector_drawings_B.qml">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/06_vector_drawings_B.qml</a></td></tr>
<tr><td> 6</td><td>07_vector_drawings_C.qml</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/07_vector_drawings_C.qml">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/07_vector_drawings_C.qml</a></td></tr>
<tr><td> 7</td><td>08_grid.qml</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/08_grid.qml">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/08_grid.qml</a></td></tr>
<tr><td> 8</td><td>09_column.qml</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/09_column.qml">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/09_column.qml</a></td></tr>
<tr><td> 9</td><td>10_row.qml</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/10_row.qml">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/10_row.qml</a></td></tr>
<tr><td>10</td><td>11_animation_control_variable.qml</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/11_animation_control_variable.qml">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/11_animation_control_variable.qml</a></td></tr>
<tr><td>11</td><td>12_animation_vector_images.qml</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/12_animation_vector_images.qml">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide2/12_animation_vector_images.qml</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>QML Tutorial<br />
<a href="https://pyside.github.io/docs/pyside/tutorials/qmltutorial/index.html">https://pyside.github.io/docs/pyside/tutorials/qmltutorial/index.html</a>
</li>

<li>QML Advanced Tutorial<br />
<a href="https://pyside.github.io/docs/pyside/tutorials/qmladvancedtutorial/index.html">https://pyside.github.io/docs/pyside/tutorials/qmladvancedtutorial/index.html</a>
</li>

<li>User interface markup language<br />
<a href="https://en.wikipedia.org/wiki/User_interface_markup_language">https://en.wikipedia.org/wiki/User_interface_markup_language</a>
</li>

<li>UsiXML<br />
<a href="https://en.wikipedia.org/wiki/UsiXML">https://en.wikipedia.org/wiki/UsiXML</a>
</li>

<li>Anchor-based Layout in QML<br />
<a href="https://het.as.utexas.edu/HET/Software/html/qml-anchor-layout.html#anchor-layout">https://het.as.utexas.edu/HET/Software/html/qml-anchor-layout.html#anchor-layout</a>
</li>

<li>PySide.QtDeclarative<br />
<a href="https://pyside.github.io/docs/pyside/PySide/QtDeclarative/index.html">https://pyside.github.io/docs/pyside/PySide/QtDeclarative/index.html</a>
</li>

<li>PySide and Qt Quick/QML Playground<br />
<a href="https://wiki.qt.io/PySide-and-QML-Playground">https://wiki.qt.io/PySide-and-QML-Playground</a>
</li>

<li>Hand Coded GUI Versus Qt Designer GUI<br />
<a href="https://stackoverflow.com/questions/387092/hand-coded-gui-versus-qt-designer-gui">https://stackoverflow.com/questions/387092/hand-coded-gui-versus-qt-designer-gui</a>
</li>

<li>Qt Creator Manual<br />
<a href="http://doc.qt.io/qtcreator/">http://doc.qt.io/qtcreator/</a>
</li>

<li>Qt Designer Manual<br />
<a href="http://doc.qt.io/qt-5/qtdesigner-manual.html">http://doc.qt.io/qt-5/qtdesigner-manual.html</a>
</li>

<li>Qt Creator (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Qt_Creator">https://en.wikipedia.org/wiki/Qt_Creator</a>
</li>

<li>PySide 1.2.1 documentation<br />
<a href="https://pyside.github.io/docs/pyside/index.html">https://pyside.github.io/docs/pyside/index.html</a>
</li>

<li>PySide na PyPi<br />
<a href="https://pypi.org/project/PySide/">https://pypi.org/project/PySide/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

