<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Operace s framebufferem na Raspberry Pi</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Operace s framebufferem na Raspberry Pi</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Mikropočítače Raspberry Pi zajisté není nutné čtenářům Roota podrobně představovat. Jen si připomeňme, že jedním z cílů tohoto projektu bylo vytvořit počítač, jehož fungování bude snadno pochopitelné. Tento cíl se sice používáním vysokoúrovňových jazyků a knihoven poněkud vytratil, ale nikdy není pozdě se seznámit i s hardware. Začneme u framebufferu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Operace s&nbsp;framebufferem na Raspberry Pi</a></p>
<p><a href="#k02">2. Čipy s&nbsp;architekturou VideoCore</a></p>
<p><a href="#k03">3. BCM2835 a BCM2836 použité v&nbsp;projektu Raspberry Pi</a></p>
<p><a href="#k04">4. Přístup k&nbsp;framebufferu na nejnižší úrovni (mailboxy a přímý přístup do videopaměti)</a></p>
<p><a href="#k05">5. Využití Linux framebufferu</a></p>
<p><a href="#k06">6. První demonstrační příklad: přečtení základních informací o framebufferu</a></p>
<p><a href="#k07">7. Druhý demonstrační příklad: přečtení identifikace čipu, velikosti framebufferu a délky obrazového řádku</a></p>
<p><a href="#k08">8. Třetí demonstrační příklad: přístup do framebufferu s&nbsp;využitím <strong>mmap</strong></a></p>
<p><a href="#k09">9. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k10">10. Funkce použité v&nbsp;demonstračních příkladech</a></p>
<p><a href="#k11">11. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Operace s&nbsp;framebufferem na Raspberry Pi</h2>

<p>Jednodeskový mikropočítač <a href="https://www.raspberrypi.org/">Raspberry
Pi</a> se v&nbsp;současnosti používá v&nbsp;mnoha projektech, ať již se jedná o
jeho využití při výuce, implementaci různých řídicích systémů, multimediálních
center, jednoúčelových serverů či o levný desktop nebo webový kiosek. Jedním
z&nbsp;cílů, který si tvůrci tohoto projektu vytkli, bylo navržení takového
mikropočítače, jehož princip fungování bude tak jednoduchý, že i relativní
začátečníci nebudou mít problémy s&nbsp;pochopením co a proč se interně
v&nbsp;jednotlivých integrovaných obvodech, z&nbsp;nichž se Raspberry Pi
skládá, odehrává (ostatně právě i z&nbsp;tohoto důvodu se Raspberry Pi často, a
to nikoli neprávem, srovnává se slavným <a
href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/#k04">ZX
Spectrem</a>). Tento cíl byl &ndash; až na jednu výjimku zmíněnou v&nbsp;dalším
textu &ndash; splněn; Raspberry Pi například nemá ani vlastní BIOS, bootovací
proces je poměrně <a
href="http://wiki.beyondlogic.org/index.php?title=Understanding_RaspberryPi_Boot_Process">přesně
popsán</a>, stejně jako způsob ovládání jednotlivých pinů (GPIO) apod.</p>

<p>Mnoho projektů či výukových seriálů, v&nbsp;nichž se Raspberry Pi používá,
se zaměřuje hlavně na použití GPIO. Na tom samozřejmě není nic špatného, ovšem
nesmíme zapomenout na to, že ten stejný čip, který obsahuje jádro ARM,
zajišťuje bootování, poskytuje vývojářům všechny funkce dostupné přes GPIO
(SPI, PWM atd.), obsahuje i další neméně užitečnou část. Tou je video řadič
spojený s&nbsp;programovatelným grafickým akcelerátorem. V&nbsp;dnešním článku
si nejprve popíšeme, jak lze (prozatím čistě teoreticky) ovládat takzvaný <a
href="http://www.root.cz/clanky/graficke-subsystemy-pocitacu/#k05">framebuffer</a>
přímým přístupem k&nbsp;řídicím registrům tohoto video řadiče a přímým
přístupem do paměti framebufferu. Posléze se zaměříme na použití rozhraní
k&nbsp;video řadiči poskytovaného Linuxovým kernelem. Ten totiž umožňuje
aplikacím ovládat video řadič přes speciální zařízení
<strong>/dev/fb0</strong>. Díky tomu je možné na Raspberry Pi vytvářet aplikace
s&nbsp;grafickým výstupem bez nutnosti spouštění systému X Window, správců
oken, desktopových prostředí a dalších mnohdy zbytečných vrstev mezi
uživatelskou aplikací a hardwarem (aplikací s&nbsp;přímým přístupem
k&nbsp;framebufferu existuje velké množství, například prohlížeč obrázků
<i>fbi</i>, multimediální přehrávač <i>MPlayer</i>, webové prohlížeče
<i>links2</i> a <i>NetSurf</i>, mnohé hry založené na knihovně SDL atd.).</p>

<p><ins>Poznámka: pro přístup k&nbsp;framebufferu lze použít i knihovnu
<i>DirectFB</i> nebo (nepřímo) <i>SDL</i>, ale dnes se zaměříme skutečně na tu
nejjednodušší možnost, tj.&nbsp;na použití zařízení <strong>/dev/fb0</strong>
z&nbsp;céčkového programu. Mezi našimi programy a hardwarem tak bude stát jen
jediná mezivrstva.</ins></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Čipy s&nbsp;architekturou VideoCore</h2>

<p>To, že mikropočítače <i>Raspberry Pi</i> mají s&nbsp;ohledem na jejich cenu
a energetické nároky velmi dobré multimediální schopnosti, je zajištěno
použitím čipu založeného na architektuře grafických (spíše však obecně
multimediálních) procesorů pojmenovaných <i>VideoCore</i>. Tato architektura
byla vyvinuta firmou <i>Alphamosaic</i> a současně je vlastněna společností
<i>Broadcom</i>, což je ostatně jeden z&nbsp;důvodů, proč tuto architekturu
nenalezneme u dalších výrobců čipů s&nbsp;jádrem ARM (ovšem v&nbsp;této oblasti
existuje velká konkurence, takže se setkáme i s&nbsp;dalšími podobnými GPU,
například od firem TI, NVidia či Freescale). Architektura <i>VideoCore</i> je
plně programovatelná, což je poměrně důležité, protože je pro ni možné vytvářet
nové kodeky, používat kodeky, které nemusí být licencovány, využít
<i>VideoCore</i> i v&nbsp;těch aplikacích, které nepotřebují vysoký
multimediální výkon, ale například provádí mnoho operací s&nbsp;maticemi atd.
Právě poslední možnost, tj.&nbsp;použití <i>VideoCore</i> pro urychlení
&bdquo;běžných&ldquo; aplikací, otevírá nové možnosti i pro mikropočítače typu
<i>Raspberry Pi</i> (SoC použitý v&nbsp;Raspberry Pi je navržen tak, že hlavní
procesor by měl mít na starost pouze řízení GPU, což je splněno při jeho
použití v&nbsp;multimediálních centrech apod.).</p>

<p>V&nbsp;současnosti existují minimálně čtyři generace grafických procesorů
založených na <i>VideoCore</i>. Tyto procesory jsou většinou umístěny na jednom
čipu s&nbsp;hlavním procesorem a řadičem periferních zařízení, takže vzniká SoC
(System on a Chip), což je ostatně i případ mikropočítače <i>Raspberry Pi</i>.
Podívejme se na některé čipy obsahující <i>VideoCore</i> a popř.&nbsp;i hlavní
procesor a další pomocné obvody:</p>

<table>
<tr><th> #</th><th>Čip</th><th>GPU</th><th>CPU</th></tr>
<tr><td> 1</td><td>VC01          </td><td>VideoCore 1</td><td>&times;</td></tr>
<tr><td> 2</td><td>BCM2702 (VC02)</td><td>VideoCore 2</td><td>&times;</td></tr>
<tr><td> 3</td><td>BCM2705 (VC05)</td><td>VideoCore 2</td><td>&times;</td></tr>
<tr><td> 4</td><td>BCM2091       </td><td>VideoCore 4</td><td>?</td></tr>
<tr><td> 5</td><td>BCM2722       </td><td>VideoCore 2</td><td>&times;</td></tr>
<tr><td> 6</td><td>BCM2724       </td><td>VideoCore 2</td><td>&times;</td></tr>
<tr><td> 7</td><td>BCM2727       </td><td>VideoCore 3</td><td>&times;</td></tr>
<tr><td> 8</td><td>BCM11181      </td><td>VideoCore 3</td><td>&times;</td></tr>
<tr><td> 9</td><td>BCM2763       </td><td>VideoCore 4</td><td>&times;</td></tr>
<tr><td>10</td><td>BCM2820       </td><td>VideoCore 4</td><td>ARM1176</td></tr>
<tr><td>11</td><td>BCM2835       </td><td>VideoCore 4</td><td>ARM1176 (standardně 700 MHz)</td></tr>
<tr><td>12</td><td>BCM2836       </td><td>VideoCore 4</td><td>Quad-core Cortex-A7 (standardně 900 MHz)</td></tr>
<tr><td>13</td><td>BCM11182      </td><td>VideoCore 4</td><td>&times;</td></tr>
<tr><td>14</td><td>BCM11311      </td><td>VideoCore 4</td><td>Dual-core Cortex-A9</td></tr>
<tr><td>15</td><td>BCM21654      </td><td>VideoCore 4</td><td>Cortex-A9 + Cortex-R4</td></tr>
<tr><td>16</td><td>BCM21654G     </td><td>VideoCore 4</td><td>Cortex-A9 (až do 1 GHz)</td></tr>
<tr><td>17</td><td>BCM21663      </td><td>VideoCore 4</td><td>Cortex-A9 (až do 1.2 GHz)</td></tr>
<tr><td>18</td><td>BCM21664      </td><td>VideoCore 4</td><td>Cortex-A9 (až do 1 GHz)</td></tr>
<tr><td>19</td><td>BCM21664T     </td><td>VideoCore 4</td><td>Cortex-A9 (až do 1.2 GHz)</td></tr>
<tr><td>20</td><td>BCM28150      </td><td>VideoCore 4</td><td>Dual-core Cortex-A9</td></tr>
<tr><td>21</td><td>BCM21553      </td><td>VideoCore 4</td><td>ARM11</td></tr>
<tr><td>22</td><td>BCM28145/28155</td><td>VideoCore 4</td><td>Dual-core Cortex-A9 (až do 1.2 GHz)</td></tr>
<tr><td>23</td><td>BCM23550      </td><td>VideoCore 4</td><td>Quad-core Cortex-A7 (až do 1.2 GHz)</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. BCM2835 a BCM2836 použité v&nbsp;projektu Raspberry Pi</h2>

<p>Z&nbsp;tabulky vypsané <a href="#k02">v&nbsp;předchozí kapitole</a> nás nyní
budou zajímat především řádky číslo 11 a 12, protože v&nbsp;mikropočítačích
<i>Raspberry Pi</i> nalezneme buď čip <i>BMC2835</i> nebo <i>BMC2836</i>:</p>

<table>
<tr><th>Mikropočítač</th><th>SoC</th></tr>
<tr><td>Raspberry Pi 1 Model A </td><td>BCM2835</td></tr>
<tr><td>Raspberry Pi 1 Model A+</td><td>BCM2835</td></tr>
<tr><td>Raspberry Pi 1 Model B </td><td>BCM2835</td></tr>
<tr><td>Raspberry Pi 1 Model B+</td><td>BCM2835</td></tr>
<tr><td>Raspberry Pi Zero      </td><td>BCM2835</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Raspberry Pi 2 Model B </td><td>BCM2836</td></tr>
</table>

<p>Důležité je si uvědomit, že zatímco hlavní procesor je v&nbsp;čipu BCM2835
(jednojádrový ARM11) odlišný od procesoru použitého v&nbsp;čipu BCM2836
(čtyřjádrový ARM Cortex-A7), samotný grafický procesor má prakticky stejné
vlastnosti, což se týká jak maximálních podporovaných rozlišení, tak i možností
jeho naprogramování. I z&nbsp;tohoto důvodu v&nbsp;dalším textu nebudu
rozlišovat mezi jednotlivými modely Raspberry Pi.</p>

<p><ins>Poznámka: všechny příklady byly odzkoušeny na Raspberry Pi Model
B+ se systémem Raspbian.</ins></p>

<p>Programovatelnost GPU čipů BCM2835 a BCM2836 je v&nbsp;současnosti omezena
tím, že základní funkcionalita je poskytována binárním blobem (který teoreticky
může obsahovat jakýkoli kód). Až nad tímto blobem se nachází open source
driver, který poskytuje své rozhraní dalším knihovnám (EGL, OpenMax) či přímo
aplikacím.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Přístup k&nbsp;framebufferu na nejnižší úrovni (mailboxy a přímý přístup do videopaměti)</h2>

<p>GPU, který je implementován na čipech BCM2835 a BCM2836, obsahuje i
programovatelný video řadič založený na použití klasického framebufferu.
Zjednodušeně řečeno lze říci, že video řadič postupně načítá
z&nbsp;nadefinované oblasti fyzické paměti data, tato data interpretuje jako
barvy pixelů a následně tyto barvy posílá společně se synchronizačními signály
na HDMI popř.&nbsp;je slučuje do kompozitního video signálu posílaného na
konektor RCA (či na jack u některých modelů). Video řadič je tedy nejprve nutné
nakonfigurovat &ndash; předat mu informace o framebufferu a taktéž informace
potřebné pro správné časování signálů posílaných na monitor. Na nejnižší úrovni
se tyto informace předávají přes takzvané <i>mailboxy</i>, které si můžeme
představit jako malé fronty (FIFO) s&nbsp;kapacitou osmi slov o šířce 32 bitů.
Do těchto front může z&nbsp;jedné strany zapisovat procesor (ARM) a
z&nbsp;druhé strany může zprávy vybírat GPU či naopak.</p>

<p>Nastavit či přečíst lze tyto informace:</p>

<ol>

<li>Alokace a dealokace paměti pro framebuffer (čistě teoreticky lze tuto
operaci provést i za běhu systému, prakticky se provádí jednou při
bootování)</li>

<li>Nastavení fyzického rozlišení (nemusí odpovídat virtuálnímu rozlišení, GPU
může provést změnu měřítka)</li>

<li>Nastavení virtuálního rozlišení (může být menší než fyzické rozlišení,
potom lze obrazem posouvat či měnit měřítko)</li>

<li>Nastavení barevné hloubky (počtu bitů na pixel)</li>

<li>Specifikace kódování pixelů (zde lze jen volit mezi BGR a RGB)</li>

<li>Specifikace alfa kanálu (ignorován, použit, použit, ale
s&nbsp;invertovanými hodnotami)</li>

<li>Nastavení barvové palety</li>

<li>Nastavení offsetu mezi obrazovými řádky (takzvaný <i>pitch</i>)</li>

<li>Konfigurace kurzoru (autor článku ještě bude muset prozkoumat, jestli tato
volba skutečně funguje :-)</li>

</ol>



<p><a name="k05"></a></p>
<h2 id="k05">5. Využití Linux framebufferu</h2>

<p>Přístup ke GPU přes mailboxy není zcela triviální, protože je nutné
zajistit, aby se zapisované hodnoty neukládaly pouze do cache, ale skutečně se
&bdquo;propsaly&ldquo; až do fyzického řídicího registru. Taktéž je nutné
testovat, zda GPU potvrdil operaci či vrátil požadovanou hodnotu atd.
Z&nbsp;tohoto důvodu se prozatím použití mailboxů vyhneme a využijeme namísto
toho služeb poskytovaných kernelem. Kernel sám zajišťuje nízkoúrovňové ovládání
framebufferu a v&nbsp;uživatelském prostoru (kde budou spouštěny naše
demonstrační příklady) se k&nbsp;funkcím kernelu souvisejícím
s&nbsp;framebufferem dostaneme přes speciální zařízení
<strong>/dev/fb0</strong>. Přístup k&nbsp;tomuto zařízení mají všichni
uživatelé ve skupině <strong>video</strong>, takže si pro jistotu nechte
vypsat:</p>

<pre>
<strong>ls -la /dev/fb0</strong>
crw-rw---- 1 root video 29, 0 led 20 19:28 /dev/fb0
</pre>

<p>(důležité je jméno skupiny, tedy skutečně <strong>video</strong>)</p>

<p>Dále je vhodné se ujistit, že aktuální uživatel je skutečně přidán do
skupiny <strong>video</strong> (což by v&nbsp;Raspbianu mělo být splněno):</p>

<pre>
<strong>groups</strong>
pi adm cdrom sudo dip <strong>video</strong> plugdev lpadmin sambashare
</pre>

<p>Pokud aktuální uživatel není ve skupině <strong>video</strong>, stačí ho tam
přidat (a znovu se přihlásit! nebo použít <strong>newgrp</strong>),
popř.&nbsp;spouštět všechny další příkazy a příklady pod právy roota
(<strong>su/sudo</strong>, nicméně doporučuji spíše první možnost).</p>

<p>Se zařízením <strong>/dev/fb0</strong> lze provádět tři základní operace:</p>

<ol>
<li>Čtením se získají barvy jednotlivých pixelů.</li>
<li>Zápisem se mění barvy pixelů (postupně řádek po řádku).</li>
<li>Operací <strong>ioctl</strong> se získávají další údaje o framebufferu či
se naopak mění jeho konfigurace. Díky existenci této operace bylo možné
ponechat nízký počet služeb kernelu, protože většina pokročilejších operací se
provádí právě přes <strong>ioctl</strong> aplikované na nějaké speciální
zařízení.</li>
</ol>

<p>Podívejme se nyní na jednoduchý a relativně neškodný příklad &ndash; jak na
obrazovku vykreslit barevný šum a současně si vizuálně otestovat pomalost
generátoru náhodných čísel. Na konzoli (na Raspbianu ale klidně i v&nbsp;X
Window) si zkuste pustit následující příkaz:</p>

<pre>
<strong>cp /dev/urandom /dev/fb0</strong>
cp: error writing ‘/dev/fb0’: No space left on device
cp: failed to extend ‘/dev/fb0’: No space left on device
</pre>

<p>Obrazovka by se skutečně měla pomalu zaplnit barevnými pixely a nakonec by
se do tohoto zmatku měly vypsat dva řádky informující o tom, že framebuffer je
zaplněn (což vidíme) a že ho nelze (logicky) zvětšit. Překreslení obrazovky do
původního stavu zajistí příkaz <strong>clear</strong>, pro obnovení okrajů pak
přepnutí do druhé konzoly a zpět (Alt+F2, Alt+F1 atd.).</p>

<p>Pokud si chcete udělat screenshot obrazovky ve formátu &bdquo;raw&ldquo;
(což vlastně není žádný formát, jen otisk pixelů), postačuje provést:</p>

<pre>
<strong>cp /dev/fb0 framebuffer.raw</strong>
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. První demonstrační příklad: přečtení základních informací o framebufferu</h2>

<p>Čtení a zápis barev pixelů tedy dokážeme provést i přímo z&nbsp;shellu (což
by čistě teoreticky mohlo některým uživatelům dostačovat například pro
implementaci prográmku, který bude na základě stavu čidel připojených na GPIO
zobrazovat nějaké jednodušší grafy &ndash; takový dotaz již na Rootu zazněl).
Podívejme se nyní na zbývající operaci, tedy na <strong>ioctl</strong>
(Input/Output Control), kterou již budeme volat z&nbsp;céčkového programu. Jak
již víme z&nbsp;předchozího textu, lze použitím této funkce například získat
informace o framebufferu. Konkrétně je tato informace vrácena v&nbsp;datové
struktuře pojmenované <strong>fb_var_screeninfo</strong>, která má tento formát
(schválně jsem ponechal i původní komentáře):</p>

<pre>
<strong>struct</strong> fb_var_screeninfo {
        __u32 xres;                     <i>/* visible resolution           */</i>
        __u32 yres;
        __u32 xres_virtual;             <i>/* virtual resolution           */</i>
        __u32 yres_virtual;
        __u32 xoffset;                  <i>/* offset from virtual to visible */</i>
        __u32 yoffset;                  <i>/* resolution                   */</i>
&nbsp;
        __u32 bits_per_pixel;           <i>/* guess what                   */</i>
        __u32 grayscale;                <i>/* 0 = color, 1 = grayscale,    */</i>
                                        <i>/* &gt;1 = FOURCC                  */</i>
        struct fb_bitfield red;         <i>/* bitfield in fb mem if true color, */</i>
        struct fb_bitfield green;       <i>/* else only length is significant */</i>
        struct fb_bitfield blue;
        struct fb_bitfield transp;      <i>/* transparency                 */      </i>
&nbsp;
        __u32 nonstd;                   <i>/* != 0 Non standard pixel format */</i>
&nbsp;
        __u32 activate;                 <i>/* see FB_ACTIVATE_*            */</i>
&nbsp;
        __u32 height;                   <i>/* height of picture in mm    */</i>
        __u32 width;                    <i>/* width of picture in mm     */</i>
&nbsp;
        __u32 accel_flags;              <i>/* (OBSOLETE) see fb_info.flags */</i>
&nbsp;
        <i>/* Timing: All values in pixclocks, except pixclock (of course) */</i>
        __u32 pixclock;                 <i>/* pixel clock in ps (pico seconds) */</i>
        __u32 left_margin;              <i>/* time from sync to picture    */</i>
        __u32 right_margin;             <i>/* time from picture to sync    */</i>
        __u32 upper_margin;             <i>/* time from sync to picture    */</i>
        __u32 lower_margin;
        __u32 hsync_len;                <i>/* length of horizontal sync    */</i>
        __u32 vsync_len;                <i>/* length of vertical sync      */</i>
        __u32 sync;                     <i>/* see FB_SYNC_*                */</i>
        __u32 vmode;                    <i>/* see FB_VMODE_*               */</i>
        __u32 rotate;                   <i>/* angle we rotate counter clockwise */</i>
        __u32 colorspace;               <i>/* colorspace for FOURCC-based modes */</i>
        __u32 reserved[4];              <i>/* Reserved for future compatibility */</i>
};
</pre>

<p>Jak se tato struktura získá v&nbsp;céčkovém programu?</p>

<ol>

<li>Otevřeme zařízení <strong>/dev/fb0</strong> v&nbsp;režimu čtení (O_RDONLY)
funkcí <strong>open()</strong>.</li>

<li>Zavoláme funkci <strong>ioctl()</strong>, které se předají tři parametry:
handle zařízení (hodnota získaná přes <strong>open()</strong> v&nbsp;předchozím
kroku), konstanta <strong>FBIOGET_VSCREENINFO</strong> a ukazatel na strukturu
typu <strong>fb_var_screeninfo</strong>. Funkce <strong>ioctl()</strong> naplní
všechny položky této struktury a vrátí nulovou hodnotu. V&nbsp;případě nějaké
chyby vrátí nenulovou hodnotu, kterou ihned otestujeme.</li>

<li>Zavřeme zařízení <strong>/dev/fb0</strong> funkcí
<strong>close()</strong>.</li>

</ol>

<p>Podívejme se nyní, jak by mohl vypadat <a
href="https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb1.c">úplný
demonstrační příklad</a>, v&nbsp;němž navíc provádíme kontroly, zda operace
<strong>open()</strong> a <strong>ioctl()</strong> proběhly v&nbsp;pořádku.
Povšimněte si, které hlavičkové soubory je nutné použít (všechny by měly být
dostupné ve výchozí instalaci Raspbianu, pokud bude překladač hlásit chyby,
vyřešíme v&nbsp;komentářích pod článkem):</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;linux/fb.h&gt;
&nbsp;
<i>/* Datova struktura, do niz se ulozi informace o framebufferu. */</i>
<strong>typedef</strong> <strong>struct</strong> fb_var_screeninfo FramebufferInfo;
&nbsp;
<i>/* Vypis zakladnich informaci o framebufferu. */</i>
<strong>void</strong> printFramebufferInfo(<strong>int</strong> framebufferDevice)
{
    FramebufferInfo framebufferInfo;
    <i>/* Pokud operace ioctl probehne v poradku, vrati se 0 */</i>
    <strong>if</strong> (ioctl(framebufferDevice, FBIOGET_VSCREENINFO, &amp;framebufferInfo)) {
        perror("Nelze precist informace o framebufferu");
        <strong>return</strong>;
    }
    <i>/* Nyni je datova struktura FramebufferInfo naplnena. */</i>
    printf("Realne rozliseni:    %dx%d\n", framebufferInfo.xres, framebufferInfo.yres);
    printf("Virtualni rozliseni: %dx%d\n", framebufferInfo.xres_virtual, framebufferInfo.yres_virtual);
    printf("Bitu na pixel:       %d\n", framebufferInfo.bits_per_pixel);
}
&nbsp;
<strong>int</strong> main(<strong>int</strong> argc, <strong>char</strong> **argv)
{
    <strong>int</strong> framebufferDevice = 0;
&nbsp;
    <i>/* Ze zarizeni potrebujeme pouze cist.*/</i>
    framebufferDevice = open("/dev/fb0", O_RDONLY);
&nbsp;
    <i>/* Pokud otevreni probehlo uspesne, nacteme</i>
    <i> * a nasledne vypiseme informaci o framebufferu.*/</i>
    <strong>if</strong> (framebufferDevice != -1) {
        printFramebufferInfo(framebufferDevice);
        close(framebufferDevice);
        <strong>return</strong> 0;
    }
    <i>/* Otevreni se nezadarilo, vypiseme chybove hlaseni.*/</i>
    <strong>else</strong> {
        perror("Nelze otevrit ovladac /dev/fb0");
        <strong>return</strong> 1;
    }
}
</pre>

<p>Překlad se provede tím nejjednodušším možným způsobem:</p>

<pre>
gcc -o rpi_fb1 rpi_fb1.c
</pre>

<p>Spuštění:</p>

<pre>
./rpi_fb1
</pre>

<p>Na mém Raspberry Pi se konkrétně vypíše:</p>

<pre>
Realne rozliseni:    1280x1024
Virtualni rozliseni: 1280x1024
Bitu na pixel:       16
</pre>

<p>U notebooku (který má samozřejmě taktéž framebuffer) pak:</p>

<pre>
Realne rozliseni:    1440x900
Virtualni rozliseni: 1440x900
Bitu na pixel:       32
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Druhý demonstrační příklad: přečtení identifikace čipu, velikosti framebufferu a délky obrazového řádku</h2>

<p>Ve skutečnosti v&nbsp;datové struktuře <strong>fb_var_screeninfo</strong>
popsané a použité <a href="#k06">v&nbsp;předchozí kapitole</a> nezískáme
všechny informace nutné pro ovládání framebufferu. Další sada konfiguračních
parametrů je dostupná ve struktuře nazvané <strong>fb_fix_screeninfo</strong>.
Zajímavé je, že zde nalezneme i identifikaci GPU, ovšem důležitější jsou údaje
o skutečném délku obrazového řádku (v&nbsp;bajtech) a celkové velikosti
framebufferu:</p>

<pre>
<strong>struct</strong> fb_fix_screeninfo {
        char id[16];                    <i>/* identification string eg "TT Builtin" */</i>
        unsigned long smem_start;       <i>/* Start of frame buffer mem */</i>
                                        <i>/* (physical address) */</i>
        __u32 smem_len;                 <i>/* Length of frame buffer mem */</i>
        __u32 type;                     <i>/* see FB_TYPE_*                */</i>
        __u32 type_aux;                 <i>/* Interleave for interleaved Planes */</i>
        __u32 visual;                   <i>/* see FB_VISUAL_*              */ </i>
        __u16 xpanstep;                 <i>/* zero if no hardware panning  */</i>
        __u16 ypanstep;                 <i>/* zero if no hardware panning  */</i>
        __u16 ywrapstep;                <i>/* zero if no hardware ywrap    */</i>
        __u32 line_length;              <i>/* length of a line in bytes    */</i>
        unsigned long mmio_start;       <i>/* Start of Memory Mapped I/O   */</i>
                                        <i>/* (physical address) */</i>
        __u32 mmio_len;                 <i>/* Length of Memory Mapped I/O  */</i>
        __u32 accel;                    <i>/* Indicate to driver which     */</i>
                                        <i>/*  specific chip/card we have  */</i>
        __u16 capabilities;             <i>/* see FB_CAP_*                 */</i>
        __u16 reserved[2];              <i>/* Reserved for future compatibility */</i>
};
</pre>

<p>Způsob naplnění této datové struktury je ukázán v&nbsp;dnešním <a
href="https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb2.c">druhém
demonstračním příkladu</a>. Povšimněte si, že postup je naprosto shodný
s&nbsp;předchozím příkladem, ovšem druhý a třetí parametr předaný do funkce
<strong>ioctl()</strong> je odlišný. Druhým parametrem je konstanta
<strong>FBIOGET_FSCREENINFO</strong> (pozor na to, že rozdíl je jen
v&nbsp;jediném znaku!) a třetím parametrem pak ukazatel na datovou strukturu
typu <strong>fb_fix_screeninfo</strong> (nikoli
<strong>fb_var_screeninfo</strong>):</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;linux/fb.h&gt;
&nbsp;
<i>/* Datova struktura, do niz se ulozi informace o framebufferu. */</i>
<strong>typedef</strong> <strong>struct</strong> fb_var_screeninfo FramebufferInfo;
&nbsp;
<strong>typedef</strong> <strong>struct</strong> fb_fix_screeninfo ModeInfo;
&nbsp;
<strong>void</strong> printFramebufferInfo(<strong>int</strong> framebufferDevice)
{
    FramebufferInfo framebufferInfo;
    ModeInfo        modeInfo;
&nbsp;
    <i>/* Pokud operace ioctl probehne v poradku, vrati se 0 */</i>
    <strong>if</strong> (ioctl(framebufferDevice, FBIOGET_VSCREENINFO, &amp;framebufferInfo)) {
        perror("Nelze precist informace o framebufferu");
        <strong>return</strong>;
    }
    <i>/* Nyni je datova struktura FramebufferInfo naplnena. */</i>
    printf("Realne rozliseni:       %dx%d pixelu\n", framebufferInfo.xres, framebufferInfo.yres);
    printf("Virtualni rozliseni:    %dx%d pixelu\n", framebufferInfo.xres_virtual, framebufferInfo.yres_virtual);
    printf("Bitu na pixel:          %d bitu\n", framebufferInfo.bits_per_pixel);
&nbsp;
    <strong>if</strong> (ioctl(framebufferDevice, FBIOGET_FSCREENINFO, &amp;modeInfo)) {
        perror("Nelze precist informace o rezimu");
        <strong>return</strong>;
    }
    <i>/* Nyni je datova struktura ModeInfo naplnena. */</i>
    printf("Identifikace:           %s\n", modeInfo.id);
    printf("Delka obrazoveho radku: %d bajtu\n", modeInfo.line_length);
    printf("Velikost framebuffer:   %d bajtu\n", modeInfo.smem_len);
}
&nbsp;
<strong>int</strong> main(<strong>int</strong> argc, <strong>char</strong> **argv)
{
    <strong>int</strong> framebufferDevice = 0;
&nbsp;
    <i>/* Ze zarizeni potrebujeme pouze cist.*/</i>
        framebufferDevice = open("/dev/fb0", O_RDONLY);
&nbsp;
    <i>/* Pokud otevreni probehlo uspesne, nacteme</i>
    <i> * a nasledne vypiseme informaci o framebufferu.*/</i>
    <strong>if</strong> (framebufferDevice != -1) {
        printFramebufferInfo(framebufferDevice);
        close(framebufferDevice);
        <strong>return</strong> 0;
    }
    <i>/* Otevreni se nezadarilo, vypiseme chybove hlaseni.*/</i>
    <strong>else</strong> {
        perror("Nelze otevrit ovladac /dev/fb0");
        <strong>return</strong> 1;
    }
}
</pre>

<p>Překlad druhého příkladu se opět provede tím nejjednodušším možným
způsobem:</p>

<pre>
gcc -o rpi_fb2 rpi_fb2.c
</pre>

<p>Spuštění pak příkazem:</p>

<pre>
./rpi_fb2
</pre>

<p>Na mém Raspberry Pi se konkrétně vypíše (povšimněte si detekce identifikace
GPU, podle mě není zcela přesné):</p>

<pre>
Realne rozliseni:       1280x1024 pixelu
Virtualni rozliseni:    1280x1024 pixelu
Bitu na pixel:          16 bitu
Identifikace:           BCM2708 FB
Delka obrazoveho radku: 2560 bajtu
Velikost framebuffer:   2621440 bajtu
</pre>

<p>Na notebooku s&nbsp;GPU od firmy Intel se vypíše:</p>

<pre>
Realne rozliseni:       1440x900 pixelu
Virtualni rozliseni:    1440x900 pixelu
Bitu na pixel:          32 bitu
Identifikace:           inteldrmfb
Delka obrazoveho radku: 5760 bajtu
Velikost framebuffer:   5185536 bajtu
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Třetí demonstrační příklad: přístup do framebufferu s&nbsp;využitím <strong>mmap</strong></h2>

<p>Informace, které již o framebufferu umíme získat, nyní využijeme
k&nbsp;přístupu k&nbsp;jednotlivým pixelům. Zde musíme použít další systémovou
funkci, která je velmi užitečná. Jedná se o funkci nazvanou
<strong>mmap()</strong>, k&nbsp;níž existuje i protějšek
<strong>munmap()</strong>. Funkce <strong>mmap()</strong> dokáže namapovat
&bdquo;obsah&ldquo; nějakého souboru či zařízení do paměti, takže se
s&nbsp;touto pamětí může pracovat stejně jako s&nbsp;jakoukoli jinou oblastí
paměti s&nbsp;využitím ukazatelů atd. Funkce <strong>munmap()</strong> naopak
toto mapování odstraní.</p>

<p>Volání funkce <strong>mmap()</strong> bude v&nbsp;našem konkrétním případě
vypadat takto:</p>

<pre>
char *pixels = (char*)mmap(   <i>/* přetypování výsledku funkce mmap() */</i>
    0,                        <i>/* necháme na rozhodnutí jádra, aby zvolilo první adresu */</i>
    bufferSize,               <i>/* velikost namapované oblasti, zde velikost framebufferu (fb_fix_screeninfo.smem_len) */</i>
    PROT_READ | PROT_WRITE,   <i>/* budeme číst i zapisovat barvy pixelů */</i>
    MAP_SHARED,               <i>/* změna ve speciálním zařízení bude viditelná v celém systému */</i>
    framebufferDevice,        <i>/* handle vrácený funkcí open() */</i>
    0);                       <i>/* offset v rámci framebufferu, my k němu budeme přistupovat od začátku */</i>
</pre>

<p>Jakmile funkce <strong>mmap()</strong> vrátila ukazatel na paměť
s&nbsp;namapovaným speciálním zařízením, můžeme snadno změnit hodnoty všech
pixelů, a to nezávisle na jejich struktuře (uložení barev atd.):</p>

<pre>
int x;
for (x=0; x&lt;bufferSize; x++)
    pixels[x] = x;
</pre>

<p>popř.&nbsp;pokud preferujete použití ukazatelů:</p>

<pre>
int x;
char *p = pixels;
for (x=0; x&lt;bufferSize; x++)
    *p++ = x;
</pre>

<p>Na závěr je nutné funkcí <strong>munmap()</strong> zrušit mapování.
Podívejme se nyní na <a
href="https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb3.c">úplný
zdrojový kód</a> tohoto příkladu:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;linux/fb.h&gt;
&nbsp;
<i>/* Datova struktura, do niz se ulozi informace o framebufferu. */</i>
<strong>typedef</strong> <strong>struct</strong> fb_var_screeninfo FramebufferInfo;
&nbsp;
<strong>typedef</strong> <strong>struct</strong> fb_fix_screeninfo ModeInfo;
&nbsp;
<strong>long</strong> <strong>int</strong> printFramebufferInfo(<strong>int</strong> framebufferDevice)
{
    FramebufferInfo framebufferInfo;
    ModeInfo        modeInfo;
&nbsp;
    <i>/* Pokud operace ioctl probehne v poradku, vrati se 0 */</i>
    <strong>if</strong> (ioctl(framebufferDevice, FBIOGET_VSCREENINFO, &amp;framebufferInfo)) {
        perror("Nelze precist informace o framebufferu");
        <strong>return</strong> 0;
    }
    <i>/* Nyni je datova struktura FramebufferInfo naplnena. */</i>
    printf("Realne rozliseni:       %dx%d pixelu\n", framebufferInfo.xres, framebufferInfo.yres);
    printf("Virtualni rozliseni:    %dx%d pixelu\n", framebufferInfo.xres_virtual, framebufferInfo.yres_virtual);
    printf("Bitu na pixel:          %d bitu\n", framebufferInfo.bits_per_pixel);
&nbsp;
    <strong>if</strong> (ioctl(framebufferDevice, FBIOGET_FSCREENINFO, &amp;modeInfo)) {
        perror("Nelze precist informace o rezimu");
        <strong>return</strong> 0;
    }
    <i>/* Nyni je datova struktura ModeInfo naplnena. */</i>
    printf("Identifikace:           %s\n", modeInfo.id);
    printf("Delka obrazoveho radku: %d bajtu\n", modeInfo.line_length);
    printf("Velikost framebuffer:   %d bajtu\n", modeInfo.smem_len);
&nbsp;
    <strong>return</strong> modeInfo.smem_len;
}
&nbsp;
<strong>void</strong> draw(<strong>int</strong> framebufferDevice, <strong>long</strong> <strong>int</strong> bufferSize)
{
    <strong>char</strong> *pixels = (<strong>char</strong>*)mmap(0, bufferSize,
                               PROT_READ | PROT_WRITE,
                               MAP_SHARED, framebufferDevice,
                               0);
    <strong>if</strong> (pixels != MAP_FAILED) {
        <strong>int</strong> x;
        for (x=0; x&lt;bufferSize; x++) pixels[x] = x;
        getchar();
        munmap(pixels, bufferSize);
    }
    <strong>else</strong> {
        perror("Nelze pristupovat k framebufferu");
    }
}
&nbsp;
<strong>int</strong> main(<strong>int</strong> argc, <strong>char</strong> **argv)
{
    <strong>int</strong> framebufferDevice = 0;
&nbsp;
    <i>/* Ze zarizeni potrebujeme pouze cist.*/</i>
    framebufferDevice = open("/dev/fb0", O_RDWR);
&nbsp;
    <i>/* Pokud otevreni probehlo uspesne, nacteme</i>
    <i> * a nasledne vypiseme informaci o framebufferu.*/</i>
    <strong>if</strong> (framebufferDevice != -1) {
        <strong>long</strong> <strong>int</strong> bufferSize = printFramebufferInfo(framebufferDevice);
        <strong>if</strong> (bufferSize) {
            draw(framebufferDevice, bufferSize);
        }
        close(framebufferDevice);
        <strong>return</strong> 0;
    }
    <i>/* Otevreni se nezadarilo, vypiseme chybove hlaseni.*/</i>
    <strong>else</strong> {
        perror("Nelze otevrit ovladac /dev/fb0");
        <strong>return</strong> 1;
    }
}
</pre>

<p>Překlad třetího příkladu se opět provede tím nejjednodušším možným
způsobem:</p>

<pre>
gcc -o rpi_fb3 rpi_fb3.c
</pre>

<p>Spuštění pak příkazem:</p>

<pre>
./rpi_fb3
</pre>

<pre>
Realne rozliseni:       1280x1024 pixelu
Virtualni rozliseni:    1280x1024 pixelu
Bitu na pixel:          16 bitu
Identifikace:           BCM2708 FB
Delka obrazoveho radku: 2560 bajtu
Velikost framebuffer:   2621440 bajtu
</pre>

<p>Příště si ukážeme některé další triky s&nbsp;framebufferem i s&nbsp;použitím
mailboxů. Již nyní je však možné na prezentovaném příkladu stavět jednodušší
aplikace, které na Raspberry Pi využijí grafický výstup bez nutnosti používat
plnohodnotné desktopové prostředí a komplikované knihovny.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny tři demonstrační příklady, s&nbsp;nimiž jsme se v&nbsp;dnešním
článku seznámili, byly uloženy do Git repositáře umístěného na GitHubu na
adrese (<a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>):</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Zdrojový kód</th></tr>
<tr><td>1</td><td>rpi_fb1.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb1.c">https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb1.c</a></td></tr>
<tr><td>2</td><td>rpi_fb2.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb2.c">https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb2.c</a></td></tr>
<tr><td>3</td><td>rpi_fb3.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb3.c">https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb3.c</a></td></tr>
</table>

<p>Pro překlad těchto tří demonstračních příkladů je zapotřebí mít nainstalován
překladač GNU C (či Clang), linker a vývojářskou verzi libc.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Funkce použité v&nbsp;demonstračních příkladech</h2>

<p>Popis funkcí (ve skutečnosti se vlastně jedná pouze o pětici systémových
volání), které byly použity v&nbsp;dnešních demonstračních příkladech,
naleznete buď ve druhé sekci manuálových stránek (<strong>man 2
jméno_funkce</strong>), popř. pokud preferujete použití webového prohlížeče se
lze na adrese <a
href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>
podívat na ty samé manuálové stránky, ovšem zkonvertované do formátu HTML:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Popis</th></tr>
<tr><td>1</td><td>open()  </td><td><a href="http://man7.org/linux/man-pages/man2/open.2.html">man 2 open</a></td></tr>
<tr><td>2</td><td>close() </td><td><a href="http://man7.org/linux/man-pages/man2/close.2.html">man 2 close</a></td></tr>
<tr><td>3</td><td>ioctl() </td><td><a href="http://man7.org/linux/man-pages/man2/ioctl.2.html">man 2 ioctl</a></td></tr>
<tr><td>4</td><td>mmap()  </td><td><a href="http://man7.org/linux/man-pages/man2/mmap.2.html">man 2 mmap</a></td></tr>
<tr><td>5</td><td>munmap()</td><td><a href="http://man7.org/linux/man-pages/man2/munmap.2.html">man 2 unmap</a></td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na Internetu</h2>

<ol>

<li>Raspberry Pi pages<br />
<a href="https://www.raspberrypi.org/">https://www.raspberrypi.org/</a>
</li>

<li>BCM2835 registers<br />
<a href="http://elinux.org/BCM2835_registers">http://elinux.org/BCM2835_registers</a>
</li>

<li>VideoCore (archiv stránek společnosti Alphamosaic)<br />
<a href="http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/">http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/</a>
</li>

<li>VideoCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Videocore">https://en.wikipedia.org/wiki/Videocore</a>
</li>

<li>RPi lessons: Lesson 6 Screen01<br />
<a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html">http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html</a>
</li>

<li>Raspberry Pi forum: Bare metal<br />
<a href="https://www.raspberrypi.org/forums/viewforum.php?f=72">https://www.raspberrypi.org/forums/viewforum.php?f=72</a>
</li>

<li>C library for Broadcom BCM 2835 as used in Raspberry Pi<br />
<a href="http://www.airspayce.com/mikem/bcm2835/">http://www.airspayce.com/mikem/bcm2835/</a>
</li>

<li>Raspberry Pi Hardware Components<br />
<a href="http://elinux.org/RPi_Hardware#Components">http://elinux.org/RPi_Hardware#Components</a>
</li>

<li>(Linux) Framebuffer<br />
<a href="http://wiki.linuxquestions.org/wiki/Framebuffer">http://wiki.linuxquestions.org/wiki/Framebuffer</a>
</li>

<li>(Linux) Framebuffer HOWTO<br />
<a href="http://tldp.org/HOWTO/Framebuffer-HOWTO/">http://tldp.org/HOWTO/Framebuffer-HOWTO/</a>
</li>

<li>Linux framebuffer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Linux_framebuffer">https://en.wikipedia.org/wiki/Linux_framebuffer</a>
</li>

<li>RPi Framebuffer<br />
<a href="http://elinux.org/RPi_Framebuffer">http://elinux.org/RPi_Framebuffer</a>
</li>

<li>HOWTO: Boot your Raspberry Pi into a fullscreen browser kiosk<br />
<a href="http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/">http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/</a>
</li>

<li>Zdrojový kód fb.c pro RPI<br />
<a href="https://github.com/jncronin/rpi-boot/blob/master/fb.c">https://github.com/jncronin/rpi-boot/blob/master/fb.c</a>
</li>

<li>RPiconfig<br />
<a href="http://elinux.org/RPi_config.txt">http://elinux.org/RPi_config.txt</a>
</li>

<li>Mailbox framebuffer interface<br />
<a href="https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface">https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

