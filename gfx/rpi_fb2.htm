<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Operace s framebufferem na Raspberry Pi (vykreslování do framebufferu)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Operace s framebufferem na Raspberry Pi (vykreslování do framebufferu)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části článku o použití framebufferu na populárním jednodeskovém mikropočítači Raspberry Pi si ukážeme, jak na základě získaných informací o struktuře framebufferu provádět vykreslování. Začneme samozřejmě s vykreslováním jednotlivých pixelů, což není tak triviální, jak by se mohlo na první pohled zdát.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Operace s&nbsp;framebufferem na Raspberry Pi (vykreslování do framebufferu)</a></p>
<p><a href="#k02">2. Formát uložení pixelů ve framebufferu</a></p>
<p><a href="#k03">3. Přečtení informací o typu framebufferu</a></p>
<p><a href="#k04">4. Přečtení informací o grafickém režimu</a></p>
<p><a href="#k05">5. Přečtení informací o formátu uložení barev pixelů</a></p>
<p><a href="#k06">6. Úplný zdrojový kód dnešního prvního demonstračního příkladu</a></p>
<p><a href="#k07">7. Informace získané na Raspberry Pi</a></p>
<p><a href="#k08">8. Informace získané na počítači s&nbsp;framebufferem s&nbsp;32 bitovou hloubkou</a></p>
<p><a href="#k09">9. Operace <strong>putpixel</strong> pro framebuffer s&nbsp;32bitovou hloubkou</a></p>
<p><a href="#k10">10. Operace <strong>putpixel</strong> pro framebuffer se 16bitovou hloubkou</a></p>
<p><a href="#k11">11. Výběr správné funkce <strong>putpixel</strong></a></p>
<p><a href="#k12">12. Úplný zdrojový kód dnešního druhého demonstračního příkladu</a></p>
<p><a href="#k13">13. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Operace s&nbsp;framebufferem na Raspberry Pi (vykreslování do framebufferu)</h2>

<p><a
href="http://www.root.cz/clanky/operace-s-framebufferem-na-raspberry-pi/">V&nbsp;první
části</a> článku o používání framebufferu (obrazové paměti) na populárním
jednodeskovém mikropočítači <i>Raspberry Pi</i> jsme se seznámili se dvěma
základními možnostmi, jak k&nbsp;framebufferu přistupovat z&nbsp;uživatelských
aplikací. Připomeňme si jen ve stručnosti, že první možnost spočívá
v&nbsp;přímém přístupu k&nbsp;řídicím registrům GPU (grafického procesoru
BCM2835 a BCM2836) přes takzvané mailboxy a druhá možnost pak ve využití
driveru dostupného z&nbsp;uživatelského prostoru přes speciální zařízení
<strong>/dev/fb0</strong>. Toto zařízení podporuje tři základní operace:
čtení/read (čte se obsah framebufferu, tj.&nbsp;barvy jednotlivých pixelů),
zápis/write (změna barvy jednotlivých pixelů) a taktéž operaci typu IOCTL, přes
kterou lze získat další informace o framebufferu, zejména o jeho vnitřní
struktuře, formátu uložení pixelů atd. S&nbsp;využitím operace IOCTL je taktéž
možné měnit některé parametry framebufferu.</p>

<p>Taktéž jsme si ukázali jednu z&nbsp;možností, jak do framebufferu
přistupovat přímo z&nbsp;céčkového kódu. Využili jsme přitom funkci
<strong>mmap</strong>, která namapovala obsah speciálního zařízení
<strong>/dev/fb0</strong> do adresního rozsahu aplikace. Změnou jednotlivých
bajtů této paměti je možné přímo měnit barvy jednotlivých pixelů na obrazovce
(a samozřejmě si barvy zpětně přečíst atd.). Mohlo by se tedy zdát, že nám již
nic nebrání ve vytvoření funkce typu <strong>putpixel</strong>, která na určené
místo na obrazovce vykreslí bod zvolené barvy. Ve skutečnosti však i takto
primitivní operace vyžaduje od programátorů poměrně hodně práce, a to
z&nbsp;jednoduchého důvodu, který prostupuje celým oborem IT: &bdquo;pokud je
možné nějakou věc implementovat dvěma způsoby, je zaručeno, že návrháři přijdou
minimálně se třemi vzájemně nekompatibilními řešeními&ldquo;.</p>

<p>Přesně toto pravidlo můžeme aplikovat i na framebuffery &ndash;
v&nbsp;průběhu posledních čtyřiceti let vzniklo takřka nepřeberné množství
variant, jak může být framebuffer uspořádán (bitové roviny, packed-pixels,
X-mode), jak jsou uspořádány obrazové řádky (za sebou, prokládaně sudá-lichá,
po osmi řádcích, ...) a taktéž jak jsou zakódovány barvy pixelů (barvová
paleta, minimálně čtyři používané varianty hi-color, několik variant kódování
true color, dobové triky typu HAM na Amize atd.).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Formát uložení pixelů ve framebufferu</h2>

<p>Minule jsme si řekli, jakým způsobem lze přečíst základní informace o
framebufferu, zejména:</p>

<ul>
<li>Rozlišení (fyzické i virtuální).</li>
<li>Bitovou hloubku (počet bitů na jeden pixel).</li>
<li>Délku obrazového řádku (ta obecně neodpovídá horizontálnímu rozlišení!).</li>
<li>Celkovou velikost framebufferu.</li>
</ul>

<p>Tyto informace nám však ještě nestačí k&nbsp;tomu, aby bylo možné
implementovat korektní funkci typu <strong>putpixel</strong>. Potřebujeme navíc
znát minimálně tyto údaje:</p>

<ul>
<li>Zda framebuffer používá bitové roviny (Amiga, EGA, VGA) či uložení pixelů v&nbsp;jedné rovině.</li>
<li>Zda jsou řádky ve framebufferu uloženy za sebou (odshora dolů) či nějak prokládaně (interlaced).</li>
<li>Jak je zakódována barva jednotlivých pixelů.</li>
</ul>

<p>Všechny tyto údaje je možné získat již zmíněnou operací IOCTL. Navíc máme tu
výhodu, že framebuffer je v&nbsp;mikropočítači <i>Raspberry Pi</i>
implementován &bdquo;příčetně&ldquo;, takže nebudeme muset implementovat
všechny možné kombinace. Pro <i>Raspberry Pi</i> totiž platí:</p>

<ul>
<li>Oblast paměti framebufferu je kontinuální, šířka řádku odpovídá jeho délce.</li>
<li>Používá se formát packed-pixels, tj.&nbsp;všechny bity popisující jeden pixel jsou uloženy za sebou.</li>
<li>Obrazové řádky jsou taktéž uloženy lidsky za sebou bez mezer a bez prokládání.</li>
<li>Formát kódování barev je volitelný 16bpp, 24bpp a 32bpp (též 8bpp, zde je však situace složitější).</li>
</ul>

<p>Před zkoumáním vlastností framebufferu je nutné přečíst dvě datové struktury
popsané minule. To zajišťuje funkce nazvaná
<strong>readFramebufferInfo()</strong>, které se předá handle otevřeného
zařízení <strong>/dev/fb0</strong> a ukazatele na obě struktury, které se mají
naplnit:</p>

<pre>
<i>/*</i>
<i> * Precteni vsech relevantnich informaci zjistenych o framebufferu. Pro korektni</i>
<i> * funkci je zapotrebi, aby mel uzivatel pristup k zarizeni /dev/fb0</i>
<i> * (postacuje byt ve skupine 'video' ci pouziti su/sudo)</i>
<i> */</i>
<strong>int</strong> readFramebufferInfo(<strong>int</strong> framebufferDevice,
                        FramebufferInfo *framebufferInfoPtr,
                        ModeInfo *modeInfoPtr)
{
    <i>/* Pokud operace ioctl probehne v poradku, vrati se 0 */</i>
    <strong>if</strong> (ioctl(framebufferDevice, FBIOGET_VSCREENINFO, framebufferInfoPtr)) {
        perror("Nelze precist informace o framebufferu");
        <strong>return</strong> 0;
    }
&nbsp;
    <strong>if</strong> (ioctl(framebufferDevice, FBIOGET_FSCREENINFO, modeInfoPtr)) {
        perror("Nelze precist informace o rezimu");
        <strong>return</strong> 0;
    }
    <strong>return</strong> 1;
}
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Přečtení informací o typu framebufferu</h2>

<p>Dvě informace, které musíme znát, souvisí se strukturou kódování pozic
pixelů a jednotlivých bitů reprezentujících pixely. Tato informace je uložena
v&nbsp;datové položce <strong>ModeInfo.type</strong>. Jedná se o celočíselnou
položku, jejíž hodnota odpovídá jedné z&nbsp;konstant pojmenovaných
<strong>FB_TYPE_...</strong>. O převod takové konstanty na řetězec se postará
funkce <strong>getFramebufferType()</strong>:</p>

<pre>
<i>/*</i>
<i> * Ziskani informace o typu framebufferu.</i>
<i> */</i>
<strong>const</strong> <strong>char</strong>* getFramebufferType(<strong>const</strong> <strong>int</strong> type)
{
    <strong>static</strong> <strong>const</strong> <strong>char</strong>* FRAMEBUFFER_TYPES[]={
        "Packed Pixels",
        "Non interleaved planes",
        "Interleaved planes",
        "Text/attributes",
        "EGA/VGA planes"
    };
    <strong>if</strong> (type &gt;= FB_TYPE_PACKED_PIXELS &amp;&amp; type &lt;= FB_TYPE_VGA_PLANES) {
        <i>/* vypocet indexu do pole retezcu */</i>
        <strong>return</strong> FRAMEBUFFER_TYPES[type - FB_TYPE_PACKED_PIXELS];
    }
    <strong>return</strong> "unknown";
}
</pre>

<p>Funkce <strong>getFramebufferType()</strong> se volá takto:</p>

<pre>
<i>/*</i>
<i> * Vypis vsech relevantnich informaci zjistenych o framebufferu.</i>
<i> */</i>
<strong>void</strong> printFramebufferInfo(<strong>int</strong> framebufferDevice,
                          FramebufferInfo *framebufferInfoPtr,
                          ModeInfo *modeInfoPtr)
{
    ...
    ...
    ...
    printf("Organizace framebufferu: %d == %s\n", modeInfoPtr-&gt;type, getFramebufferType(modeInfoPtr-&gt;type));
    ...
    ...
    ...
}
</pre>

<p>Další zajímavou informací, kterou jádro Linuxu uživatelům zpřístupní, je
režim vykreslování. Ten je opět reprezentován celočíselnou hodnotou, která zde
však má odlišný význam: jde vlastně o bitové příznaky, z&nbsp;nichž nás
zajímají jen příznaky uložené v&nbsp;nejnižším bitu a v&nbsp;bitu
s&nbsp;indexem 1. Můžeme získat informaci o tom, zda se při zobrazování na
monitoru používá prokládaný režim a/nebo režim double scan (většinou se dnes
setkáme s&nbsp;neprokládaným režimem bez double scanu, tj.&nbsp;zopakování dvou
po sobě jdoucích řádků):</p>

<pre>
<i>/*</i>
<i> * Ziskani informace rezimu zobrazovani.</i>
<i> */</i>
<strong>const</strong> <strong>char</strong>* getVideoMode(<strong>const</strong> <strong>int</strong> mode)
{
    <strong>static</strong> <strong>const</strong> <strong>char</strong>* VIDEO_MODE_TYPES[]={
        "non interlaced",
        "interlaced",
        "non interlaced, double scan",
        "interlaced, double scan"
    };
    <strong>int</strong> index = mode &amp; 0x03;
    <strong>return</strong> VIDEO_MODE_TYPES[index];
}
</pre>

<p>Funkce <strong>getVideoMode()</strong> se volá takto:</p>

<pre>
<i>/*</i>
<i> * Vypis vsech relevantnich informaci zjistenych o framebufferu.</i>
<i> */</i>
<strong>void</strong> printFramebufferInfo(<strong>int</strong> framebufferDevice,
                          FramebufferInfo *framebufferInfoPtr,
                          ModeInfo *modeInfoPtr)
{
    ...
    ...
    ...
    printf("Rezim zobrazovani:      %d == %s\n", framebufferInfoPtr-&gt;vmode, getVideoMode(framebufferInfoPtr-&gt;vmode));
    ...
    ...
    ...
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Přečtení informací o grafickém režimu</h2>

<p>Dále nás bude zajímat informace o grafickém režimu. Naprostá většina
současných počítačů podporuje režim true color (sem spadá i hi-color, minimálně
při práci s&nbsp;Linux framebufferem) popř.&nbsp;režimy s&nbsp;barvovou paletou
(pseudo color). Grafický režim přečteme jednoduše:</p>

<pre>
<i>/*</i>
<i> * Vypis vsech relevantnich informaci zjistenych o framebufferu.</i>
<i> */</i>
<strong>void</strong> printFramebufferInfo(<strong>int</strong> framebufferDevice,
                          FramebufferInfo *framebufferInfoPtr,
                          ModeInfo *modeInfoPtr)
{
    ...
    ...
    ...
    printf("Graficky rezim:          %d == %s\n", modeInfoPtr-&gt;visual, getGraphicsMode(modeInfoPtr-&gt;visual));
    ...
    ...
    ...
}
</pre>

<p>Celočíselná hodnota, která je tímto způsobem přečtena, se rozepíše
v&nbsp;další funkci:</p>

<pre>
<i>/*</i>
<i> * Ziskani informace grafickem rezimu.</i>
<i> */</i>
<strong>const</strong> <strong>char</strong>* getGraphicsMode(<strong>const</strong> <strong>int</strong> mode)
{
    <strong>static</strong> <strong>const</strong> <strong>char</strong>* GRAPHIC_MODES[]={
        "Monochr. 1=Black 0=White",
        "Monochr. 1=White 0=Black",
        "True color",
        "Pseudo color (like Atari)",
        "Direct color",
        "Pseudo color readonly"
    };
    <strong>if</strong> (mode &gt;= FB_VISUAL_MONO01 &amp;&amp; mode &lt;= FB_VISUAL_STATIC_PSEUDOCOLOR) {
        <i>/* vypocet indexu do pole retezcu */</i>
        <strong>return</strong> GRAPHIC_MODES[mode - FB_VISUAL_MONO01];
    }
    <strong>return</strong> "unknown";
}
</pre>

<p>Všechny možnosti, které framebuffer nabízí, jsou reprezentovány konstantami
začínajícími na <strong>FB_VISUAL_</strong>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Přečtení informací o formátu uložení barev pixelů</h2>

<p>Nejdůležitější informace, která asi nejvíce ovlivní implementaci funkce typu
<strong>putpixel</strong>, je informace o způsobu kódování barev pixelů ve
framebufferu. <i>Raspberry Pi</i> je možné nakonfigurovat takovým způsobem, že
se používá osmibitová barevná hloubka (potom je ovšem nutné nastavit paletu,
jinak na obrazovce nebude nic vidět), 16bitová hloubka (výchozí a asi nejlepší
nastavení), 24bitová hloubka (s&nbsp;problémy) a konečně 32bitová hloubka,
ovšem bez alfa kanálu, což znamená, že jeden bajt z&nbsp;32bitové hodnoty
pixelu bude ignorován. Toto nastavení je možné změnit v&nbsp;souboru
<strong>/boot/config.txt</strong>. O kódování barev pixelů se dozvíme ze čtyř
datových struktur, v&nbsp;nichž se pro každou barvovou složku (red, green,
blue, alfa kanál) určuje počet bitů rezervovaných pro barvovou složku (typicky
2, 3 či 8), počet bitů, o kolik je nutné složku posunout pro složení barvy
pixelu a taktéž informaci o tom, zda je nejvyšší bit (MSB) uložen ve výsledném
slovu vpravo či vlevo). Podívejme se nyní, jak je možné tyto informace přečíst
a vypsat:</p>

<pre>
<i>/*</i>
<i> * Vypis podrobnejsich informaci o zpusobu zakodovani jedne barvove slozky</i>
<i> * pixelu ve framebufferu. Zobrazene informace maji vyznam pouze ve chvili,</i>
<i> * kdy se nepouzivaji graficke rezimy s barvovovu paletou.</i>
<i> */</i>
<strong>void</strong> printColorInfo(<strong>const</strong> <strong>char</strong> *message, <strong>const</strong> <strong>struct</strong> fb_bitfield colorInfo)
{
    puts(message);
    printf("    sirka:  %d\n", colorInfo.length);
    printf("    offset: %d\n", colorInfo.offset);
    printf("    MSB:    %s\n", colorInfo.msb_right ? "vpravo" : "vlevo");
}
</pre>

<p>Tuto funkci voláme následujícím způsobem:</p>

<pre>
<i>/*</i>
<i> * Vypis vsech relevantnich informaci zjistenych o framebufferu.</i>
<i> */</i>
<strong>void</strong> printFramebufferInfo(<strong>int</strong> framebufferDevice,
                          FramebufferInfo *framebufferInfoPtr,
                          ModeInfo *modeInfoPtr)
{
    ...
    ...
    ...
    printColorInfo("Cervena barvova slozka (RED):",  framebufferInfoPtr-&gt;red);
    printColorInfo("Zelena barvova slozka (GREEN):", framebufferInfoPtr-&gt;green);
    printColorInfo("Modra barvova slozka (BLUE):",   framebufferInfoPtr-&gt;blue);
    printColorInfo("Alfa kanal (ALPHA):",            framebufferInfoPtr-&gt;transp);
    ...
    ...
    ...
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Úplný zdrojový kód dnešního prvního demonstračního příkladu</h2>

<p>Všechny úryvky zdrojových kódů a funkcí, o nichž jsme se zmínili
v&nbsp;předchozích kapitolách, jsou součástí dnešního prvního demonstračního
příkladu, jehož zdrojový kód je zobrazen pod tímto odstavcem a který je možné
v&nbsp;případě zájmu získat na adrese <a
href="https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb5.c">https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb5.c</a>:</p>

<pre>
<i>/* Framebuffer na jednodeskovem mikropocitaci Raspberry Pi */</i>
<i>/* Autor: Pavel Tisnovsky, 2016 */</i>
&nbsp;
<i>/* Demonstracni priklad cislo 5: ziskani informaci o grafickem rezimu */</i>
<i>/*                               a o zpusobu kodovani jednotlivych pixelu */</i>
&nbsp;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;linux/fb.h&gt;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Datova struktura, do niz se ulozi informace o framebufferu.</i>
<i> * Blizsi informace o teto strukture je mozne nalezt v hlavickovem souboru</i>
<i> * dostupnem v adresari "/usr/include/linux/fb.h"</i>
<i> */</i>
<strong>typedef</strong> <strong>struct</strong> fb_var_screeninfo FramebufferInfo;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Druha datova struktura popisujici zbyvajici vlastnosti framebufferu.</i>
<i> * Blizsi informace o teto strukture je mozne nalezt v hlavickovem souboru</i>
<i> * dostupnem v adresari "/usr/include/linux/fb.h"</i>
<i> */</i>
<strong>typedef</strong> <strong>struct</strong> fb_fix_screeninfo ModeInfo;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vypis podrobnejsich informaci o zpusobu zakodovani jedne barvove slozky</i>
<i> * pixelu ve framebufferu. Zobrazene informace maji vyznam pouze ve chvili,</i>
<i> * kdy se nepouzivaji graficke rezimy s barvovovu paletou.</i>
<i> */</i>
<strong>void</strong> printColorInfo(<strong>const</strong> <strong>char</strong> *message, <strong>const</strong> <strong>struct</strong> fb_bitfield colorInfo)
{
    puts(message);
    printf("    sirka:  %d\n", colorInfo.length);
    printf("    offset: %d\n", colorInfo.offset);
    printf("    MSB:    %s\n", colorInfo.msb_right ? "vpravo" : "vlevo");
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ziskani informace o typu framebufferu.</i>
<i> */</i>
<strong>const</strong> <strong>char</strong>* getFramebufferType(<strong>const</strong> <strong>int</strong> type)
{
    <strong>static</strong> <strong>const</strong> <strong>char</strong>* FRAMEBUFFER_TYPES[]={
        "Packed Pixels",
        "Non interleaved planes",
        "Interleaved planes",
        "Text/attributes",
        "EGA/VGA planes"
    };
    <strong>if</strong> (type &gt;= FB_TYPE_PACKED_PIXELS &amp;&amp; type &lt;= FB_TYPE_VGA_PLANES) {
        <i>/* vypocet indexu do pole retezcu */</i>
        <strong>return</strong> FRAMEBUFFER_TYPES[type - FB_TYPE_PACKED_PIXELS];
    }
    <strong>return</strong> "unknown";
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ziskani informace rezimu zobrazovani.</i>
<i> */</i>
<strong>const</strong> <strong>char</strong>* getVideoMode(<strong>const</strong> <strong>int</strong> mode)
{
    <strong>static</strong> <strong>const</strong> <strong>char</strong>* VIDEO_MODE_TYPES[]={
        "non interlaced",
        "interlaced",
        "non interlaced, double scan",
        "interlaced, double scan"
    };
    <strong>int</strong> index = mode &amp; 0x03;
    <strong>return</strong> VIDEO_MODE_TYPES[index];
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ziskani informace grafickem rezimu.</i>
<i> */</i>
<strong>const</strong> <strong>char</strong>* getGraphicsMode(<strong>const</strong> <strong>int</strong> mode)
{
    <strong>static</strong> <strong>const</strong> <strong>char</strong>* GRAPHIC_MODES[]={
        "Monochr. 1=Black 0=White",
        "Monochr. 1=White 0=Black",
        "True color",
        "Pseudo color (like Atari)",
        "Direct color",
        "Pseudo color readonly"
    };
    <strong>if</strong> (mode &gt;= FB_VISUAL_MONO01 &amp;&amp; mode &lt;= FB_VISUAL_STATIC_PSEUDOCOLOR) {
        <i>/* vypocet indexu do pole retezcu */</i>
        <strong>return</strong> GRAPHIC_MODES[mode - FB_VISUAL_MONO01];
    }
    <strong>return</strong> "unknown";
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Precteni vsech relevantnich informaci zjistenych o framebufferu. Pro korektni</i>
<i> * funkci je zapotrebi, aby mel uzivatel pristup k zarizeni /dev/fb0</i>
<i> * (postacuje byt ve skupine 'video' ci pouziti su/sudo)</i>
<i> */</i>
<strong>int</strong> readFramebufferInfo(<strong>int</strong> framebufferDevice,
                        FramebufferInfo *framebufferInfoPtr,
                        ModeInfo *modeInfoPtr)
{
    <i>/* Pokud operace ioctl probehne v poradku, vrati se 0 */</i>
    <strong>if</strong> (ioctl(framebufferDevice, FBIOGET_VSCREENINFO, framebufferInfoPtr)) {
        perror("Nelze precist informace o framebufferu");
        <strong>return</strong> 0;
    }
&nbsp;
    <strong>if</strong> (ioctl(framebufferDevice, FBIOGET_FSCREENINFO, modeInfoPtr)) {
        perror("Nelze precist informace o rezimu");
        <strong>return</strong> 0;
    }
    <strong>return</strong> 1;
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vypis vsech relevantnich informaci zjistenych o framebufferu.</i>
<i> */</i>
<strong>void</strong> printFramebufferInfo(<strong>int</strong> framebufferDevice,
                          FramebufferInfo *framebufferInfoPtr,
                          ModeInfo *modeInfoPtr)
{
    <i>/* Nyni je datova struktura FramebufferInfo naplnena, lze vytisknout jeji prvky. */</i>
    printf("Realne rozliseni:       %dx%d pixelu\n", framebufferInfoPtr-&gt;xres, framebufferInfoPtr-&gt;yres);
    printf("Virtualni rozliseni:    %dx%d pixelu\n", framebufferInfoPtr-&gt;xres_virtual, framebufferInfoPtr-&gt;yres_virtual);
    printf("Odstiny sedi:           %s\n", framebufferInfoPtr-&gt;grayscale ? "ano" : "ne");
    printf("Nestandardni format:    %s\n", framebufferInfoPtr-&gt;nonstd ? "ano" : "ne");
    printf("Rezim zobrazovani:      %d == %s\n", framebufferInfoPtr-&gt;vmode, getVideoMode(framebufferInfoPtr-&gt;vmode));
&nbsp;
    printf("Bitu na pixel:          %d bitu\n", framebufferInfoPtr-&gt;bits_per_pixel);
    printColorInfo("Cervena barvova slozka (RED):",  framebufferInfoPtr-&gt;red);
    printColorInfo("Zelena barvova slozka (GREEN):", framebufferInfoPtr-&gt;green);
    printColorInfo("Modra barvova slozka (BLUE):",   framebufferInfoPtr-&gt;blue);
    printColorInfo("Alfa kanal (ALPHA):",            framebufferInfoPtr-&gt;transp);
&nbsp;
    putchar('\n');
&nbsp;
    <i>/* Nyni je datova struktura modeInfo naplnena, lze vytisknout jeji prvky. */</i>
    printf("Identifikace:            %s\n", modeInfoPtr-&gt;id);
    printf("Delka obrazoveho radku:  %d bajtu\n", modeInfoPtr-&gt;line_length);
    printf("Velikost framebufferu:   %d bajtu\n", modeInfoPtr-&gt;smem_len);
    printf("Organizace framebufferu: %d == %s\n", modeInfoPtr-&gt;type, getFramebufferType(modeInfoPtr-&gt;type));
    printf("Graficky rezim:          %d == %s\n", modeInfoPtr-&gt;visual, getGraphicsMode(modeInfoPtr-&gt;visual));
}
&nbsp;
&nbsp;
&nbsp;
<i>/* Vstupni bod do demonstraniho prikladu... :) */</i>
<strong>int</strong> main(<strong>int</strong> argc, <strong>char</strong> **argv)
{
    FramebufferInfo framebufferInfo;
    ModeInfo        modeInfo;
    <strong>int</strong> framebufferDevice = 0;
&nbsp;
    <i>/* Ze zarizeni potrebujeme pouze cist.*/</i>
    framebufferDevice = open("/dev/fb0", O_RDONLY);
&nbsp;
    <i>/* Pokud otevreni probehlo uspesne, nacteme</i>
    <i> * a nasledne vypiseme informaci o framebufferu.*/</i>
    <strong>if</strong> (framebufferDevice != -1) {
        <i>/* Precteni informaci o framebufferu a test, zda se vse podarilo */</i>
        <strong>if</strong> (readFramebufferInfo(framebufferDevice, &amp;framebufferInfo, &amp;modeInfo)) {
            printFramebufferInfo(framebufferDevice, &amp;framebufferInfo, &amp;modeInfo);
        }
        close(framebufferDevice);
        <strong>return</strong> 0;
    }
    <i>/* Otevreni se nezadarilo, vypiseme tudiz pouze chybove hlaseni.*/</i>
    <strong>else</strong> {
        perror("Nelze otevrit ovladac /dev/fb0");
        <strong>return</strong> 1;
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/* finito */</i>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Informace získané na Raspberry Pi</h2>

<p>Na stejném kusu <i>Raspberry Pi</i> s&nbsp;externím monitorem o rozlišení
1280&times;1024 jsem spustil testovací program celkem třikrát. Poprvé pro
hloubku 16bpp, posléze pro 24bpp a nakonec pro 32bpp (s&nbsp;vypnutým alfa
kanálem). Podívejme se na výsledky:</p>

<pre>
Realne rozliseni:       1280x1024 pixelu
Virtualni rozliseni:    1280x1024 pixelu
Odstiny sedi:           ne
Nestandardni format:    ne
Rezim zobrazovani:      0 == non interlaced
Bitu na pixel:          16 bitu
Cervena barvova slozka (RED):
    sirka:  5
    offset: 11
    MSB:    vlevo
Zelena barvova slozka (GREEN):
    sirka:  6
    offset: 5
    MSB:    vlevo
Modra barvova slozka (BLUE):
    sirka:  5
    offset: 0
    MSB:    vlevo
Alfa kanal (ALPHA):
    sirka:  0
    offset: 16
    MSB:    vlevo
&nbsp;
Identifikace:            BCM2708 FB
Delka obrazoveho radku:  2560 bajtu
Velikost framebufferu:   2621440 bajtu
Organizace framebufferu: 0 == Packed Pixels
Graficky rezim:          2 == True color
</pre>

<pre>
Realne rozliseni:       1280x1024 pixelu
Virtualni rozliseni:    1280x1024 pixelu
Odstiny sedi:           ne
Nestandardni format:    ne
Rezim zobrazovani:      0 == non interlaced
Bitu na pixel:          24 bitu
Cervena barvova slozka (RED):
    sirka:  8
    offset: 0
    MSB:    vlevo
Zelena barvova slozka (GREEN):
    sirka:  8
    offset: 8
    MSB:    vlevo
Modra barvova slozka (BLUE):
    sirka:  8
    offset: 16
    MSB:    vlevo
Alfa kanal (ALPHA):
    sirka:  0
    offset: 24
    MSB:    vlevo
&nbsp;
Identifikace:            BCM2708 FB
Delka obrazoveho radku:  3840 bajtu
Velikost framebufferu:   3932160 bajtu
Organizace framebufferu: 0 == Packed Pixels
Graficky rezim:          2 == True color
</pre>

<pre>
Realne rozliseni:       1280x1024 pixelu
Virtualni rozliseni:    1280x1024 pixelu
Odstiny sedi:           ne
Nestandardni format:    ne
Rezim zobrazovani:      0 == non interlaced
Bitu na pixel:          32 bitu
Cervena barvova slozka (RED):
    sirka:  8
    offset: 0
    MSB:    vlevo
Zelena barvova slozka (GREEN):
    sirka:  8
    offset: 8
    MSB:    vlevo
Modra barvova slozka (BLUE):
    sirka:  8
    offset: 16
    MSB:    vlevo
Alfa kanal (ALPHA):
    sirka:  8
    offset: 24
    MSB:    vlevo
&nbsp;
Identifikace:            BCM2708 FB
Delka obrazoveho radku:  5120 bajtu
Velikost framebufferu:   5242880 bajtu
Organizace framebufferu: 0 == Packed Pixels
Graficky rezim:          2 == True color
</pre>

<p>Vidíme, že framebuffer na <i>Raspberry Pi</i> má stále stejně jednoduchou
strukturu (packed pixels, non interlaced), mění se jen počet bitů pro
jednotlivé barvové složky a samozřejmě i bitová hloubka.</p>

<p>Ještě si pro přehlednost uveďme všechny hodnoty v&nbsp;jedné tabulce:</p>

<table>
<tr><th>Hodnota</th><th>16bpp</th><th>24bpp</th><th>32bpp</th></tr>
<tr><td>Realne rozliseni:       </td><td>1280x1024 pixelu</td><td>1280x1024 pixelu</td><td>1280x1024 pixelu</td></tr>
<tr><td>Virtualni rozliseni:    </td><td>1280x1024 pixelu</td><td>1280x1024 pixelu</td><td>1280x1024 pixelu</td></tr>
<tr><td>Odstiny sedi:           </td><td>ne</td><td>ne</td><td>ne</td></tr>
<tr><td>Nestandardni format:    </td><td>ne</td><td>ne</td><td>ne</td></tr>
<tr><td>Rezim zobrazovani:      </td><td>non interlaced</td><td>non interlaced</td><td>non interlaced</td></tr>
<tr><td>Bitu na pixel:          </td><td>16 bitu</td><td>24 bitu</td><td>32 bitu</td></tr>
<tr><td>RED:    sirka:          </td><td>5</td><td>8</td><td>8</td></tr>
<tr><td>RED:    offset:         </td><td>11</td><td>0</td><td>0</td></tr>
<tr><td>RED:    MSB:            </td><td>vlevo</td><td>vlevo</td><td>vlevo</td></tr>
<tr><td>GREEN:  sirka:          </td><td>6</td><td>8</td><td>8</td></tr>
<tr><td>GREEN:  offset:         </td><td>5</td><td>8</td><td>8</td></tr>
<tr><td>GREEN:  MSB:            </td><td>vlevo</td><td>vlevo</td><td>vlevo</td></tr>
<tr><td>BLUE:   sirka:          </td><td>5</td><td>8</td><td>8</td></tr>
<tr><td>BLUE:   offset:         </td><td>0</td><td>16</td><td>16</td></tr>
<tr><td>BLUE:   MSB:            </td><td>vlevo</td><td>vlevo</td><td>vlevo</td></tr>
<tr><td>ALPHA:  sirka:          </td><td>0</td><td>8</td><td>8</td></tr>
<tr><td>ALPHA:  offset:         </td><td>16</td><td>24</td><td>24</td></tr>
<tr><td>ALPHA:  MSB:            </td><td>vlevo</td><td>vlevo</td><td>vlevo</td></tr>
<tr><td>Identifikace:           </td><td>BCM2708 FB   </td><td>BCM2708 FB        </td><td>BCM2708 FB</td></tr>
<tr><td>Delka obrazoveho radku: </td><td>2560 bajtu   </td><td>3840 bajtu        </td><td>5120 bajtu</td></tr>
<tr><td>Velikost framebufferu:  </td><td>2621440 bajtu</td><td>3932160 bajtu     </td><td>5242880 bajtu</td></tr>
<tr><td>Organizace framebufferu:</td><td>Packed Pixels</td><td>Packed Pixels</td><td>Packed Pixels</td></tr>
<tr><td>Graficky rezim:         </td><td>True color</td><td>True color</td><td>True color</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Informace získané na počítači s&nbsp;framebufferem s&nbsp;32 bitovou hloubkou</h2>

<p>Pro porovnání se podívejme na to, jak vypadá výstup ze stejného programu,
tentokrát však spuštěný na běžném notebooku s&nbsp;displejem o rozlišení
1440&times;900 pixelů:</p>

<pre>
Realne rozliseni:       1440x900 pixelu
Virtualni rozliseni:    1440x900 pixelu
Odstiny sedi:           ne
Nestandardni format:    ne
Rezim zobrazovani:      0 == non interlaced
Bitu na pixel:          32 bitu
Cervena barvova slozka (RED):
    sirka:  8
    offset: 16
    MSB:    vlevo
Zelena barvova slozka (GREEN):
    sirka:  8
    offset: 8
    MSB:    vlevo
Modra barvova slozka (BLUE):
    sirka:  8
    offset: 0
    MSB:    vlevo
Alfa kanal (ALPHA):
    sirka:  0
    offset: 0
    MSB:    vlevo
&nbsp;
Identifikace:            inteldrmfb
Delka obrazoveho radku:  5760 bajtu
Velikost framebufferu:   5185536 bajtu
Organizace framebufferu: 0 == Packed Pixels
Graficky rezim:          2 == True color
</pre>

<p>Všimli jste si změny? Ano, jedná se stále o formát s&nbsp;32bitovou
hloubkou, ale barvové složky RGB jsou oproti framebufferu na <i>Raspberry
Pi</i> prohozeny.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Operace <strong>putpixel</strong> pro framebuffer s&nbsp;32bitovou hloubkou</h2>

<p>Podívejme se nyní na způsob implementace funkce <strong>putpixel</strong>
v&nbsp;případě, že se používá framebuffer s&nbsp;hloubkou 32bpp, což znamená,
že pro každou barvovou složku je rezervován přesně jeden bajt a zbývající bajt
je buď nevyužitý (což je případ <i>Raspberry Pi</i>) nebo obsahuje alfa kanál.
Teoreticky by s&nbsp;takto definovaným kódováním neměl být žádný větší problém,
ve skutečnosti však existuje hned několik způsobů uspořádání barvových složek
v&nbsp;32bitovém slově. Setkáme se s&nbsp;formáty RGB0 (bez alfa kanálu), RGBA,
ARGB, ABGR, 0RGB a 0BGR (možná existují i další reálně používané kombinace).
Pro jednoduchost prozatím implementujme jen jedinou verzi funkce
<strong>putpixel</strong>, v&nbsp;níž bude uspořádání barvových složek
&bdquo;zadrátováno&ldquo;. Implementace se tak značně zjednoduší, protože pouze
vypočteme adresu prvního bajtu pixelu s&nbsp;využitím znalostí o délce
obrazového řádku a následně jen zapíšeme tři bajty s&nbsp;informacemi o
barvových složkách. Celá implementace může vypadat následovně:</p>

<pre>
<i>/*</i>
<i> * Funkce putpixel platna pouze pro graficke rezimy true-color</i>
<i> * s formatem 8-8-8-8 (popr. muze byt alfa kanal ignorovan).</i>
<i> */</i>
<strong>void</strong> putpixelRGBA(<strong>const</strong> <strong>int</strong> x, <strong>const</strong> <strong>int</strong> y,
                 <strong>const</strong> <strong>char</strong> r, <strong>const</strong> <strong>char</strong> g, <strong>const</strong> <strong>char</strong> b,
                 <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length)
{
    <i>/* vypocet adresy zapisu dat */</i>
    <strong>unsigned</strong> <strong>int</strong> index = (x&lt;&lt;2) + y*line_length;
&nbsp;
    <i>/* vlastni provedeni zapisu */</i>
    *(pixels+index) = b;
    index++;
    *(pixels+index) = g;
    index++;
    *(pixels+index) = r;
}
</pre>

<p><ins>Poznámka: sami si vyzkoušejte, jak tato funkce pracuje na <i>Raspberry
Pi</i> a zda se barvy skutečně počítají správně. Tato funkce totiž byla
naschvál odladěna na počítači s&nbsp;odlišným framebufferem, takže oprava
(vcelku triviální) je ponechána na váženém čtenáři v&nbsp;rámci
procvičení.</ins></p>

<p>Překlad (s&nbsp;optimalizacemi) do assembleru procesorů ARMv6/v7 je vcelku
přímočarý:</p>

<pre>
putpixelRGBA:
        @ args = 12, pretend = 0, frame = 0
        @ frame_needed = 0, uses_anonymous_args = 0
        @ link register save eliminated.
        str     r4, [sp, #-4]!
        ldr     r4, [sp, #12]
        ldr     ip, [sp, #8]
        mul     r4, r4, r1
        ldrb    r1, [sp, #4]    @ zero_extendqisi2
        add     r4, r4, r0, asl #2
        strb    r1, [ip, r4]!
        strb    r3, [ip, #1]
        strb    r2, [ip, #2]
        ldmfd   sp!, {r4}
        bx      lr
</pre>

<p>To ovšem neznamená, že <strong>putpixel</strong> je rychlá operace! Nemá
smysl ji používat na rozsáhlejší vykreslování, protože část kódu pro výpočet
barev a adresy se neustále (zbytečně) opakuje. To platí například i pro
implementaci algoritmu pro vykreslování úseček.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Operace <strong>putpixel</strong> pro framebuffer se 16bitovou hloubkou</h2>

<p>Složitější je již funkce <strong>putpixel</strong>, která musí pracovat
v&nbsp;dalším grafickém režimu podporovaném počítačem <i>Raspberry Pi</i>.
Jedná se o výchozí režim se šestnáctibitovou hloubkou, v&nbsp;němž se pro
červenou a modrou složku používá pět bitů a pro složku zelenou pak bitů šest
(z&nbsp;toho důvodu, že lidské oko dobře rozlišuje intenzitu světla právě
v&nbsp;rozsahu zelené barvy). Kódování pixelů vypadá následovně:</p>

<pre>
  1 1 1 1 1   1
  5 4 3 2 1   0 9 8 7 6 5   4 3 2 1 0
+-----------+-------------+-----------+
| R R R R R | G G G G G G | B B B B B |
+-----------+-------------+-----------+
</pre>

<p>Jak tedy bude operace <strong>putpixel</strong> probíhat v&nbsp;tomto případě?</p>

<ol>
<li>Vstupem jsou složky Red, Green, Blue, každá o šířce osmi bitů.</li>
<li>Složku Red snížíme na pět bitů posunem doprava o 3 bity.</li>
<li>Složku Green snížíme na šest bitů posunem doprava o 2 bity.</li>
<li>Složku Blue snížíme na pět bitů posunem doprava o 3 bity.</li>
<li>Nyní složku Red posuneme doleva o 11 bitů, tj.&nbsp;na správnou pozici ve slově.</li>
<li>Dále složku Green posuneme doleva o 5 bitů, tj.&nbsp;na správnou pozici ve slově.</li>
<li>Složku Red nikam neposunujeme, je umístěna správně od bitu číslo 0.</li>
<li>Výsledné Red, Green a Blue sečteme popř.&nbsp;použijeme operaci bitového OR (což vyjde nastejno, OR je však jednodušší).</li>
<li>Výsledné 16bitové slovo rozdělíme na vyšší a nižší bajt.</i>
<li>Oba bajty posléze uložíme do framebufferu.</li>
</ol>

<pre>
<i>/*</i>
<i> * Funkce putpixel platna pouze pro graficke rezimy hi-color</i>
<i> * s formatem 5-6-5.</i>
<i> */</i>
<strong>void</strong> putpixel565(<strong>const</strong> <strong>int</strong> x, <strong>const</strong> <strong>int</strong> y,
                 <strong>const</strong> <strong>char</strong> r, <strong>const</strong> <strong>char</strong> g, <strong>const</strong> <strong>char</strong> b,
                 <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length)
{
#define RED_OFFSET     11
#define GREEN_OFFSET    5
#define BLUE_OFFSET     0
#define RED_LOST_BITS   3
#define GREEN_LOST_BITS 2
#define BLUE_LOST_BITS  3
    <i>/* vypocet barvy pixelu, v zavorce nejdrive snizime bitovou sirku</i>
    <i> * rezervovanou pro jednotlive barvove slozky a posleze bity, ktere</i>
    <i> * reprezentuji barvovou slozku posuneme do spravne pozice ve slove */</i>
    <strong>unsigned</strong> <strong>int</strong> pixel_value = (r &gt;&gt; RED_LOST_BITS)   &lt;&lt; RED_OFFSET |
                               (g &gt;&gt; GREEN_LOST_BITS) &lt;&lt; GREEN_OFFSET |
                               (b &gt;&gt; BLUE_LOST_BITS)  &lt;&lt; BLUE_OFFSET;
&nbsp;
    <i>/* prevod na dvojici bajtu */</i>
    <strong>unsigned</strong> <strong>char</strong> byte1 = pixel_value &amp; 0xff;
    <strong>unsigned</strong> <strong>char</strong> byte2 = pixel_value &gt;&gt; 8;
&nbsp;
    <i>/* vypocet adresy zapisu dat */</i>
    <strong>unsigned</strong> <strong>int</strong> index = (x&lt;&lt;1) + y*line_length;
&nbsp;
    <i>/* vlastni provedeni zapisu */</i>
    *(pixels+index) = byte1;
    index++;
    *(pixels+index) = byte2;
}
</pre>

<p>Podívejme se, jak vypadá překlad do assembleru procesorů ARMv6/v7:</p>

<pre>
putpixel565:
        @ args = 12, pretend = 0, frame = 0
        @ frame_needed = 0, uses_anonymous_args = 0
        @ link register save eliminated.
        stmfd   sp!, {r4, r5}
        mov     r3, r3, lsr #2
        ldrb    ip, [sp, #8]    @ zero_extendqisi2
        ldr     r4, [sp, #16]
        mov     r2, r2, lsr #3
        ldr     r5, [sp, #12]
        mov     ip, ip, lsr #3
        mul     r4, r4, r1
        orr     r3, ip, r3, asl #5   ; kombinace přesunu a aritmetického posunu
        orr     r2, r3, r2, asl #11  ; dtto
        add     r4, r4, r0, asl #1
        mov     r3, r2, lsr #8
        strb    r2, [r5, r4]!
        strb    r3, [r5, #1]
        ldmfd   sp!, {r4, r5}
        bx      lr
</pre>

<p>Kód je komplikovanější a taktéž pomalejší, ovšem na druhou stranu se
například při vyplňování ploch nebo při vykreslování úseček zapisuje poloviční
množství dat, což celou operaci urychluje (výpočet barev se provádí jen
jedenkrát).</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Výběr správné funkce <strong>putpixel</strong></h2>

<p>Další operací je výběr správné funkce <strong>putpixel</strong> na základě
aktuální konfigurace framebufferu. Následující kód je velmi jednoduchý, protože
rozeznává pouze dva formáty, nicméně přidání dalšího formátu je již poměrně
jednoduché, minimálně v&nbsp;případě framebufferu počítače <i>Raspberry Pi</i>
(povšimněte si způsobu použití ukazatele na funkce v&nbsp;céčku, kvůli tomu
jsem vytvořil nový datový typ, jinak by byl kód nečitelný :-):</p>

<pre>
<i>/*</i>
<i> * Novy datovy typ - ukazatel na (libovolnou) funkci putpixel.</i>
<i> */</i>
typedef <strong>void</strong> (*PutpixelFunction)(<strong>const</strong> <strong>int</strong>, <strong>const</strong> <strong>int</strong>,
                                 <strong>const</strong> <strong>char</strong>, <strong>const</strong> <strong>char</strong>, <strong>const</strong> <strong>char</strong>,
                                 <strong>char</strong>*, <strong>const</strong> <strong>int</strong>);
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce, ktera vraci korektni funkci pro operaci putpixel().</i>
<i> */</i>
PutpixelFunction getProperPutpixelFunction(<strong>int</strong> bits_per_pixel, <strong>int</strong> type, <strong>int</strong> visual)
{
    <i>/* umime rozeznat pouze format bez bitovych rovin a bez palety */</i>
    <strong>if</strong> (type == FB_TYPE_PACKED_PIXELS &amp;&amp; visual == FB_VISUAL_TRUECOLOR) {
        <strong>if</strong> (bits_per_pixel == 16) {
            <strong>return</strong> putpixel565;
        }
        <strong>if</strong> (bits_per_pixel == 32) {
            <i>/* toto neni zcela korektni, bylo by nutne rozlisit RGBA, ABGR, ARGB atd.*/</i>
            <i>/* (ukol pro vazene ctenare :) */</i>
            <strong>return</strong> putpixelRGBA;
        }
    }
    <strong>return</strong> putpixelNull;
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Úplný zdrojový kód dnešního druhého demonstračního příkladu</h2>

<p>Všechny úryvky zdrojových kódů a funkcí, o nichž jsme se zmínili
v&nbsp;předchozích třech kapitolách, jsou součástí dnešního druhého
demonstračního příkladu, jehož zdrojový kód je zobrazen pod tímto odstavcem a
který je možné v&nbsp;případě zájmu získat na adrese <a
href="https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb6.c">https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb6.c</a>:</p>

<pre>
<i>/* Framebuffer na jednodeskovem mikropocitaci Raspberry Pi */</i>
<i>/* Autor: Pavel Tisnovsky, 2016 */</i>
&nbsp;
<i>/* Demonstracni priklad cislo 6: operace putpixel */</i>
&nbsp;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;linux/fb.h&gt;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Datova struktura, do niz se ulozi informace o framebufferu.</i>
<i> * Blizsi informace o teto strukture je mozne nalezt v hlavickovem souboru</i>
<i> * dostupnem v adresari "/usr/include/linux/fb.h"</i>
<i> */</i>
<strong>typedef</strong> <strong>struct</strong> fb_var_screeninfo FramebufferInfo;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Druha datova struktura popisujici zbyvajici vlastnosti framebufferu.</i>
<i> * Blizsi informace o teto strukture je mozne nalezt v hlavickovem souboru</i>
<i> * dostupnem v adresari "/usr/include/linux/fb.h"</i>
<i> */</i>
<strong>typedef</strong> <strong>struct</strong> fb_fix_screeninfo ModeInfo;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Precteni vsech relevantnich informaci zjistenych o framebufferu. Pro korektni</i>
<i> * funkci je zapotrebi, aby mel uzivatel pristup k zarizeni /dev/fb0</i>
<i> * (postacuje byt ve skupine 'video' ci pouziti su/sudo)</i>
<i> */</i>
<strong>int</strong> readFramebufferInfo(<strong>int</strong> framebufferDevice,
                        FramebufferInfo *framebufferInfoPtr,
                        ModeInfo        *modeInfoPtr)
{
    <i>/* Pokud operace ioctl probehne v poradku, vrati se 0 */</i>
    <strong>if</strong> (ioctl(framebufferDevice, FBIOGET_VSCREENINFO, framebufferInfoPtr)) {
        perror("Nelze precist informace o framebufferu");
        <strong>return</strong> 0;
    }
&nbsp;
    <strong>if</strong> (ioctl(framebufferDevice, FBIOGET_FSCREENINFO, modeInfoPtr)) {
        perror("Nelze precist informace o rezimu");
        <strong>return</strong> 0;
    }
    <strong>return</strong> 1;
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce putpixel platna pro nezname graficke rezimy.</i>
<i> */</i>
<strong>void</strong> putpixelNull(<strong>const</strong> <strong>int</strong> x, <strong>const</strong> <strong>int</strong> y,
                 <strong>const</strong> <strong>char</strong> r, <strong>const</strong> <strong>char</strong> g, <strong>const</strong> <strong>char</strong> b,
                 <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length)
{
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce putpixel platna pouze pro graficke rezimy true-color</i>
<i> * s formatem 8-8-8-8 (popr. muze byt alfa kanal ignorovan).</i>
<i> */</i>
<strong>void</strong> putpixelRGBA(<strong>const</strong> <strong>int</strong> x, <strong>const</strong> <strong>int</strong> y,
                 <strong>const</strong> <strong>char</strong> r, <strong>const</strong> <strong>char</strong> g, <strong>const</strong> <strong>char</strong> b,
                 <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length)
{
    <i>/* vypocet adresy zapisu dat */</i>
    <strong>unsigned</strong> <strong>int</strong> index = (x&lt;&lt;2) + y*line_length;
&nbsp;
    <i>/* vlastni provedeni zapisu */</i>
    *(pixels+index) = b;
    index++;
    *(pixels+index) = g;
    index++;
    *(pixels+index) = r;
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce putpixel platna pouze pro graficke rezimy hi-color</i>
<i> * s formatem 5-6-5.</i>
<i> */</i>
<strong>void</strong> putpixel565(<strong>const</strong> <strong>int</strong> x, <strong>const</strong> <strong>int</strong> y,
                 <strong>const</strong> <strong>char</strong> r, <strong>const</strong> <strong>char</strong> g, <strong>const</strong> <strong>char</strong> b,
                 <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length)
{
#define RED_OFFSET     11
#define GREEN_OFFSET    5
#define BLUE_OFFSET     0
#define RED_LOST_BITS   3
#define GREEN_LOST_BITS 2
#define BLUE_LOST_BITS  3
    <i>/* vypocet barvy pixelu, v zavorce nejdrive snizime bitovou sirku</i>
    <i> * rezervovanou pro jednotlive barvove slozky a posleze bity, ktere</i>
    <i> * reprezentuji barvovou slozku posuneme do spravne pozice ve slove */</i>
    <strong>unsigned</strong> <strong>int</strong> pixel_value = (r &gt;&gt; RED_LOST_BITS)   &lt;&lt; RED_OFFSET |
                               (g &gt;&gt; GREEN_LOST_BITS) &lt;&lt; GREEN_OFFSET |
                               (b &gt;&gt; BLUE_LOST_BITS)  &lt;&lt; BLUE_OFFSET;
&nbsp;
    <i>/* prevod na dvojici bajtu */</i>
    <strong>unsigned</strong> <strong>char</strong> byte1 = pixel_value &amp; 0xff;
    <strong>unsigned</strong> <strong>char</strong> byte2 = pixel_value &gt;&gt; 8;
&nbsp;
    <i>/* vypocet adresy zapisu dat */</i>
    <strong>unsigned</strong> <strong>int</strong> index = (x&lt;&lt;1) + y*line_length;
&nbsp;
    <i>/* vlastni provedeni zapisu */</i>
    *(pixels+index) = byte1;
    index++;
    *(pixels+index) = byte2;
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Novy datovy typ - ukazatel na (libovolnou) funkci putpixel.</i>
<i> */</i>
typedef <strong>void</strong> (*PutpixelFunction)(<strong>const</strong> <strong>int</strong>, <strong>const</strong> <strong>int</strong>,
                                 <strong>const</strong> <strong>char</strong>, <strong>const</strong> <strong>char</strong>, <strong>const</strong> <strong>char</strong>,
                                 <strong>char</strong>*, <strong>const</strong> <strong>int</strong>);
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce, ktera vraci korektni funkci pro operaci putpixel().</i>
<i> */</i>
PutpixelFunction getProperPutpixelFunction(<strong>int</strong> bits_per_pixel, <strong>int</strong> type, <strong>int</strong> visual)
{
    <i>/* umime rozeznat pouze format bez bitovych rovin a bez palety */</i>
    <strong>if</strong> (type == FB_TYPE_PACKED_PIXELS &amp;&amp; visual == FB_VISUAL_TRUECOLOR) {
        <strong>if</strong> (bits_per_pixel == 16) {
            <strong>return</strong> putpixel565;
        }
        <strong>if</strong> (bits_per_pixel == 32) {
            <i>/* toto neni zcela korektni, bylo by nutne rozlisit RGBA, ABGR, ARGB atd.*/</i>
            <i>/* (ukol pro vazene ctenare :) */</i>
            <strong>return</strong> putpixelRGBA;
        }
    }
    <strong>return</strong> putpixelNull;
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vykresleni testovaciho obrazku s vyuzitim funkce putpixel.</i>
<i> */</i>
<strong>void</strong> drawTestImage(<strong>int</strong> framebufferDevice,
                   FramebufferInfo *framebufferInfoPtr,
                   ModeInfo        *modeInfoPtr)
{
#define OFFSET 300
    <i>/* casto pouzivane konstanty */</i>
    <strong>const</strong> <strong>int</strong> buffer_length = modeInfoPtr-&gt;smem_len;
    <strong>const</strong> <strong>int</strong> xres = framebufferInfoPtr-&gt;xres;
    <strong>const</strong> <strong>int</strong> yres = framebufferInfoPtr-&gt;yres;
&nbsp;
    <i>/* ziskame spravnou verzi funkce putpixel */</i>
    PutpixelFunction putpixel = getProperPutpixelFunction(framebufferInfoPtr-&gt;bits_per_pixel,
                                                          modeInfoPtr-&gt;type,
                                                          modeInfoPtr-&gt;visual);
&nbsp;
    <i>/* ziskat primy pristup do framebufferu */</i>
    <strong>char</strong> *pixels = (<strong>char</strong>*)mmap(0, buffer_length,
                               PROT_READ | PROT_WRITE,
                               MAP_SHARED, framebufferDevice,
                               0);
&nbsp;
    <strong>if</strong> (pixels != MAP_FAILED) {
        <strong>int</strong> x, y;
        <strong>int</strong> r, g, b;
        <i>/* nejprve vymazeme cely framebuffer */</i>
        memset(pixels, 0, buffer_length);
&nbsp;
        <i>/* vykreslime nekolik ctvercu o velikosti 256x256 pixelu */</i>
        <strong>for</strong> (y=0; y&lt;256; y++) {
            <strong>for</strong> (x=0; x&lt;256; x++) {
                <i>/* prvni rada - gradientni prechody */</i>
                <strong>if</strong> (yres &gt; 256) {
                    <i>/* cerveny gradient */</i>
                    <strong>if</strong> (xres &gt; 256) {
                        r=y; g=0; b=0;
                        putpixel(x, y, r, g, b, pixels, modeInfoPtr-&gt;line_length);
                    }
                    <i>/* zeleny gradient */</i>
                    <strong>if</strong> (xres &gt; 256 + OFFSET) {
                        r=0; g=y; b=0;
                        putpixel(OFFSET+x, y, r, g, b, pixels, modeInfoPtr-&gt;line_length);
                    }
                    <i>/* modry gradient */</i>
                    <strong>if</strong> (xres &gt; 256 + OFFSET*2) {
                        r=0; g=0; b=y;
                        putpixel(OFFSET*2+x, y, r, g, b, pixels, modeInfoPtr-&gt;line_length);
                    }
                    <i>/* grayscale gradient */</i>
                    <strong>if</strong> (xres &gt; 256 + OFFSET*3) {
                        r=y; g=y; b=y;
                        putpixel(OFFSET*3+x, y, r, g, b, pixels, modeInfoPtr-&gt;line_length);
                    }
                }
&nbsp;
                <i>/* druha rada - palety */</i>
                <strong>if</strong> (yres &gt; 256 + OFFSET) {
                    <strong>if</strong> (xres &gt; 256) {
                        r=x; g=y; b=0;
                        putpixel(x, OFFSET+y, r, g, b, pixels, modeInfoPtr-&gt;line_length);
                    }
                    <strong>if</strong> (xres &gt; 256 + OFFSET) {
                        r=x; g=y; b=255;
                        putpixel(OFFSET+x, OFFSET+y, r, g, b, pixels, modeInfoPtr-&gt;line_length);
                    }
                    <strong>if</strong> (xres &gt; 256 + OFFSET*2) {
                        r=255; g=x; b=y;
                        putpixel(OFFSET*2+x, OFFSET+y, r, g, b, pixels, modeInfoPtr-&gt;line_length);
                    }
                    <strong>if</strong> (xres &gt; 256 + OFFSET*3) {
                        r=y; g=255; b=x;
                        putpixel(OFFSET*3+x, OFFSET+y, r, g, b, pixels, modeInfoPtr-&gt;line_length);
                    }
                }
            }
        }
        getchar();
        munmap(pixels, buffer_length);
    }
    <strong>else</strong> {
        perror("Nelze pristupovat k framebufferu");
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/* Vstupni bod do demonstraniho prikladu... :) */</i>
<strong>int</strong> main(<strong>int</strong> argc, <strong>char</strong> **argv)
{
    FramebufferInfo framebufferInfo;
    ModeInfo        modeInfo;
    <strong>int</strong> framebufferDevice = 0;
&nbsp;
    <i>/* Ze zarizeni potrebujeme cist i zapisovat.*/</i>
    framebufferDevice = open("/dev/fb0", O_RDWR);
&nbsp;
    <i>/* Pokud otevreni probehlo uspesne, nacteme</i>
    <i> * a nasledne vypiseme informaci o framebufferu.*/</i>
    <strong>if</strong> (framebufferDevice != -1) {
        <i>/* Precteni informaci o framebufferu a test, zda se vse podarilo */</i>
        <strong>if</strong> (readFramebufferInfo(framebufferDevice, &amp;framebufferInfo, &amp;modeInfo)) {
            drawTestImage(framebufferDevice, &amp;framebufferInfo, &amp;modeInfo);
        }
        close(framebufferDevice);
        <strong>return</strong> 0;
    }
    <i>/* Otevreni se nezadarilo, vypiseme tudiz pouze chybove hlaseni.*/</i>
    <strong>else</strong> {
        perror("Nelze otevrit ovladac /dev/fb0");
        <strong>return</strong> 1;
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/* finito */</i>
</pre>

<p><ins>Poznámka: kód pracuje korektně pro hloubku 16bpp, zatímco pro hloubku
32bpp budou barvy prohozené. Úprava je jednoduchá, jak jsem se již ostatně
zmínil na konci <a href="#k09">deváté kapitoly</a>.</ins></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračními příklady</h2>

<p>Oba dva demonstrační příklady, s&nbsp;nimiž jsme se v&nbsp;dnešním článku
seznámili, byly uloženy do Git repositáře umístěného na GitHubu na adrese (<a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>):</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Zdrojový kód</th></tr>
<tr><td>1</td><td>rpi_fb5.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb5.c">https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb5.c</a></td></tr>
<tr><td>2</td><td>rpi_fb6.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb6.c">https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb6.c</a></td></tr>
</table>

<p>Pro překlad obou demonstračních příkladů je zapotřebí mít nainstalován
překladač GNU C (či Clang), linker a vývojářskou verzi libc.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Seriál Grafické karty a grafické akcelerátory<br />
<a href="http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/">http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>Grafické čipy v osmibitových počítačích Atari<br />
<a href="http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/">http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/</a>
</li>

<li>Osmibitové počítače Commodore a čip VIC-II<br />
<a href="http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/">http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Apple<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>Grafické karty MCGA a VGA<br />
<a href="http://www.root.cz/clanky/graficke-karty-mcga-a-vga/">http://www.root.cz/clanky/graficke-karty-mcga-a-vga/</a>
</li>

<li>Grafický subsystém počítačů Amiga<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/</a>
</li>

<li>Grafický subsystém počítačů Amiga II<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/</a>
</li>

<li>Raspberry Pi pages<br />
<a href="https://www.raspberrypi.org/">https://www.raspberrypi.org/</a>
</li>

<li>BCM2835 registers<br />
<a href="http://elinux.org/BCM2835_registers">http://elinux.org/BCM2835_registers</a>
</li>

<li>VideoCore (archiv stránek společnosti Alphamosaic)<br />
<a href="http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/">http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/</a>
</li>

<li>VideoCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Videocore">https://en.wikipedia.org/wiki/Videocore</a>
</li>

<li>RPi lessons: Lesson 6 Screen01<br />
<a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html">http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html</a>
</li>

<li>Raspberry Pi forum: Bare metal<br />
<a href="https://www.raspberrypi.org/forums/viewforum.php?f=72">https://www.raspberrypi.org/forums/viewforum.php?f=72</a>
</li>

<li>C library for Broadcom BCM 2835 as used in Raspberry Pi<br />
<a href="http://www.airspayce.com/mikem/bcm2835/">http://www.airspayce.com/mikem/bcm2835/</a>
</li>

<li>Raspberry Pi Hardware Components<br />
<a href="http://elinux.org/RPi_Hardware#Components">http://elinux.org/RPi_Hardware#Components</a>
</li>

<li>(Linux) Framebuffer<br />
<a href="http://wiki.linuxquestions.org/wiki/Framebuffer">http://wiki.linuxquestions.org/wiki/Framebuffer</a>
</li>

<li>(Linux) Framebuffer HOWTO<br />
<a href="http://tldp.org/HOWTO/Framebuffer-HOWTO/">http://tldp.org/HOWTO/Framebuffer-HOWTO/</a>
</li>

<li>Linux framebuffer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Linux_framebuffer">https://en.wikipedia.org/wiki/Linux_framebuffer</a>
</li>

<li>RPi Framebuffer<br />
<a href="http://elinux.org/RPi_Framebuffer">http://elinux.org/RPi_Framebuffer</a>
</li>

<li>HOWTO: Boot your Raspberry Pi into a fullscreen browser kiosk<br />
<a href="http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/">http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/</a>
</li>

<li>Zdrojový kód fb.c pro RPI<br />
<a href="https://github.com/jncronin/rpi-boot/blob/master/fb.c">https://github.com/jncronin/rpi-boot/blob/master/fb.c</a>
</li>

<li>RPiconfig<br />
<a href="http://elinux.org/RPi_config.txt">http://elinux.org/RPi_config.txt</a>
</li>

<li>Mailbox framebuffer interface<br />
<a href="https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface">https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface</a>
</li>

<li>Seriál Grafické formáty<br />
<a href="http://www.root.cz/serialy/graficke-formaty/">http://www.root.cz/serialy/graficke-formaty/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

