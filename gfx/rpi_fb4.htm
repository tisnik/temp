<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Operace s framebufferem na Raspberry Pi (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Operace s framebufferem na Raspberry Pi (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve čtvrté části článku o použití framebufferu na Raspberry Pi se seznámíme s vytvářením screenshotů framebufferu, s algoritmem pro vykreslování úseček s vyhlazováním hran a taktéž s jedním jednoduchým NPR algoritmem.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Operace s&nbsp;framebufferem na Raspberry Pi (dokončení)</a></p>
<p><a href="#k02">2. Vytvoření screenshotu framebufferu</a></p>
<p><a href="#k03">3. Volba vhodného formátu &ndash; rodina P[BGPA]M</a></p>
<p><a href="#k04">4. Textová varianta Portable PixelMap File Format (PPM)</a></p>
<p><a href="#k05">5. Binární varianta Portable PixelMap File Format (PPM)</a></p>
<p><a href="#k06">6. Konverze barev</a></p>
<p><a href="#k07">7. Úplný zdrojový kód prvního demonstračního příkladu</a></p>
<p><a href="#k08">8. Vykreslování úseček s&nbsp;aplikací antialiasingu</a></p>
<p><a href="#k09">9. Úplný zdrojový kód druhého demonstračního příkladu</a></p>
<p><a href="#k10">10. Třešnička na závěr: non-photorealistic rendering</a></p>
<p><a href="#k11">11. Úplný zdrojový kód třetího demonstračního příkladu</a></p>
<p><a href="#k12">12. Pokračování? GLES</a></p>
<p><a href="#k13">13. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Operace s&nbsp;framebufferem na Raspberry Pi (dokončení)</h2>

<p>Ve čtvrté a současně i poslední části miniseriálu o použití framebufferu na
oblíbených jednodeskovým mikropočítačích Raspberry Pi, navážeme na všechny tři
předchozí části [<a
href="http://www.root.cz/clanky/operace-s-framebufferem-na-raspberry-pi-vykreslovani-do-framebufferu/">1</a>][<a
href="http://www.root.cz/clanky/framebuffer-na-raspberry-pi-vykreslovani-slozitejsich-objektu/">2</a>][<a
href="http://www.root.cz/clanky/framebuffer-na-raspberry-pi-vykreslovani-slozitejsich-objektu/">3</a>],
protože si na několika demonstračních příkladech vysvětlíme, jak je možné
vytvořit screenshot framebufferu, jak lze vykreslovat úsečky s&nbsp;aplikací
antialiasingu a vyhlazování hran a na závěr si ukážeme použití jednoho (velmi
jednoduchého) algoritmu z&nbsp;oblasti NPR (<i>Non-Photorealistic
Rendering</i>), který bude využívat vykreslování úseček s&nbsp;vyhlazováním
hran. V&nbsp;navazujících částech se již budeme zabývat jiným tématem, a to
konkrétně použitím knihovny GLES (OpenGL ES), samozřejmě taktéž na Raspberry
Pi.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vytvoření screenshotu framebufferu</h2>

<p>První problém, s&nbsp;jehož řešením se dnes seznámíme, je vlastně na první
pohled zcela jednoduchý &ndash; ve chvíli, kdy je provedeno vykreslení nějakého
obrazce do framebufferu je v&nbsp;některých případech (například pro potřeby
tohoto článku) nutné udělat screenshot, tj.&nbsp;uložit barvy jednotlivých
pixelů z&nbsp;framebufferu do externího souboru. Celý problém se tedy rozděluje
na tři části:</p>

<ol>

<li>Přečtení všech pixelů z&nbsp;framebufferu. To již bezpečně umíme, a to jak
na úrovni příkazové řádky, tak i z&nbsp;céčkového programu při namapování
speciálního zařízení <strong>/dev/fb0</strong> do paměti.</li>

<li>Dekódování barev pixelů. Tuto problematiku už dobře známe z&nbsp;druhé
strany, protože již umíme převést hodnoty RGB například i do framebufferu
s&nbsp;16bitovou hloubkou (což je pro Raspberry Pi výchozí hodnota). Musíme se
tedy pouze naučit zpětný převod.</li>

<li>Uložení barev do vhodného souborového formátu. Pokud je zvolen formát
s&nbsp;&bdquo;rozumnou&ldquo; hlavičkou a bez použití komprimace, je řešení
velmi jednoduché, jak ostatně uvidíme v&nbsp;následujících kapitolách.</li>

</ol>



<p><a name="k03"></a></p>
<h2 id="k03">3. Volba vhodného formátu &ndash; rodina P[BGPA]M</h2>

<p>Pro export obsahu framebufferu do zvoleného souboru můžeme použít buď
vlastní implementaci funkce či několika spolupracujících funkcí, které zajistí
vytvoření souboru ve vhodném formátu, nebo je možné pro tento účel využít již
existující knihovny, kterým se pouze předá vhodně dekódovaný obsah
framebufferu. Druhou možnost je výhodnější použít ve chvíli, pokud se má
framebuffer ukládat například do formátů GIF, JPEG či PNG (protože asi nemá
smysl si psát vlastní komprimační rutiny, i když by to bylo z&nbsp;hlediska
sebevzdělávání zajímavé). Vzhledem k&nbsp;tomu, že se v&nbsp;tomto seriálu
zaměřujeme na ta nejsnáze použitelná řešení, nebudeme se zabývat již hotovými
knihovnami (v&nbsp;případě zájmu hledejte <i>libpng</i>, <i>libgif</i>,
<i>libjpeg</i>), ale vytvoříme si namísto toho vlastní funkci pro export
rastrových dat. Teoreticky by bylo možné využít formáty TGA (Targa) či BMP
(Bitmap), ovšem ve skutečnosti existují ještě lepší formáty, které jsou velmi
snadno implementovatelné a především konvertovatelné do formátů jiných. Jedná
se o rodinu formátů P[BGPA]M.</p>

<p>Konkrétně se pod tímto názvem skrývají čtyři příbuzné rastrové grafické
formáty PBM, PGM, PPM a PAM. Ty vznikly na původních Unixových systémech a ne
pro potřeby ukládání obrázků na počítačích řady PC (dnes jsou tyto formáty
samozřejmě používány i na dalších platformách). Unixový původ je na těchto
formátech znát, zejména jejich téměř absolutní nezávislost na použitých
hardwarových prostředcích (nenastávají například prakticky žádné problémy
s&nbsp;little vs.&nbsp;big endian, zejména u textových verzí formátů),
přítomnost magického čísla (jednoznačné identifikace formátu) na začátku
souboru, použití textových hlaviček, dostupnost dokumentace ve formě
manuálových stránek apod. Není také použita žádná metoda komprimace rastrových
dat, protože na tuto činnost jsou v&nbsp;unixových systémech (ale i jinde)
určeny dnes již téměř standardní prostředky typu <strong>gzip</strong>,
<strong>bzip</strong>, <strong>bzip2</strong> apod., běžné bývalo i použití
starodávného filtru <strong>compress</strong> (ten byl mimochodem zatížen
stejným patentem jako GIF), takže samotné grafické formáty nebylo nutné
zbytečně komplikovat &ndash; obrázek bylo možné přes rouru zkomprimovat či
naopak dekomprimovat přesně podle potřeb uživatele.</p>

<p>Popisované grafické formáty existují ve dvou variantách &ndash; textové
(označované běžně jako <i>ASCII</i> či <i>Plain</i>) a binární (označovaná jako
<i>Raw</i>). Rozdíl mezi těmito dvěma variantami (včetně předností a záporů) je
zřejmý:</p>

<ol>

<li>V&nbsp;případě textové varianty jsou vytvářeny přibližně čtyřikrát větší
soubory, takto uložené obrázky jsou však velmi snadno zpracovatelné i
programovými prostředky, které jsou primárně určeny pro zpracování textových
souborů (mezi tyto prostředky patří například sh, awk, sed, Perl a Tcl). I
vytváření textové varianty je v&nbsp;některých případech jednodušší, mnohdy
postačuje přesměrování standardního výstupu aplikace do souboru
s&nbsp;následným přidáním hlavičky. Vytvořené textové soubory jsou bez problémů
přenositelné téměř jakýmkoli protokolem (včetně sedmibitových e-mailů bez
nutnosti použití base-64 apod.). Délka řádku je stanovena na maximálně 70
znaků, což dovoluje zpracování jakýmkoli textovým editorem.</li>

<li>Binární varianta těchto grafických formátů (<i>raw</i>) přináší dvě
přednosti: menší velikost souboru v&nbsp;porovnání s&nbsp;variantou textovou a
snadné načtení rastrového obrázku (uloženého za hlavičkou) pomocí jednoho
příkazu, například funkce <strong>fread()</strong> ze standardní céčkové
knihovny. Samotný zápis obrázku je dokonce jednodušší, než zápis souboru typu
<strong>TGA</strong> (jde také o soubor s&nbsp;velmi jednoduchou strukturou), a
to zejména z&nbsp;toho důvodu, že není potřeba brát ohled na endianitu dané
architektury ani zarovnání datových struktur; oboje nám odstíní céčkovská
knihovna. Pro čtení či zápis hlavičky je možné použít funkce typu
<strong>scanf()</strong> a <strong>printf()</strong>.</li>

</ol>

<p>Na úvod mi zbývá vysvětlit, proč se jedná o čtyři formáty a ne o formát
jediný. Důvod je pochopitelný &ndash; již z&nbsp;koncovky souboru
s&nbsp;rastrovým obrázkem (v&nbsp;případě PBM, PGM a PPM) je možné poznat,
jakou bitovou hloubku a tím i maximální počet barev má daný obrázek. Také
samotná hlavička obrázku i jeho interní struktura může být mnohem jednodušší.
Poslední ze čtveřice, tj.&nbsp;formát PAM, se v&nbsp;tomto ohledu poněkud
odlišuje, protože se jedná o ideového následníka PBM, PGM a PPM, který do jedné
struktury souboru integruje mnoho různých formátů pixelů. V&nbsp;následující
tabulce jsou sepsány názvy všech dnes popisovaných formátů, včetně bitové
hloubky obrázků (<i>bpp &ndash; bits per pixel)</i>. Z&nbsp;bitové hloubky je
možné odvodit i maximální počet barev zobrazitelných v&nbsp;jednom obrázku.</p>

<table>
<tr><th>Koncovka souboru</th><th>Typ</th><th>Bpp</th><th>Počet barev</th></tr>
<tr><td>PBM</td><td>Portable Bitmap File Format</td><td>1</td><td>2 (černá a bílá)</td></tr>
<tr><td>PGM</td><td>Portable GrayMap File Format</td><td>8</td><td>256 odstínů šedi (základ)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>16 max.</td><td>65536 odstínů šedi max.</td></tr>
<tr><td>PPM</td><td>Portable PixelMap File Format</td><td>24</td><td>16777216</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>48 max.</td><td>281474976710656 max.</td></tr>
<tr><td>PAM</td><td>Portable Arbitrary Map</td><td>1&ndash;24</td><td>2&ndash;16777216<td></tr>
</table>

<p>Všechny čtyři formáty jsou v&nbsp;dokumentaci (například
k&nbsp;<strong>ImageMagicku</strong> či <strong>Netpbm</strong>) souhrnně
označované jako <strong>PNM</strong>. V&nbsp;tomto případě se však nejedná o
žádný konkrétní formát, pouze o zkrácený výpis všech zkratek. Jinými slovy, na
grafický rastrový soubor s&nbsp;koncovkou PNM bychom měli narazit pouze
v&nbsp;případě, že se interně jedná o PBM, PGM či PPM (to se jednoduše pozná
z&nbsp;hlavičky, ve které je uloženo magické číslo). Vzhledem ke zmatkům
ohledně <strong>PNM</strong> jsem si proto dovolil v&nbsp;názvu této kapitoly
použít regulární výraz.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Textová varianta Portable PixelMap File Format (PPM)</h2>

<p>Soubory typu <strong>PPM</strong> neboli <i>Portable PixelMap</i> umožňují
práci s&nbsp;obrázky v&nbsp;truecolor formátu používajících klasický barvový
model RGB (Red, Green, Blue). Zatímco většina &bdquo;truecolor&ldquo; formátů
pracuje s&nbsp;maximálním množstvím 256&times;256&times;256=16777216 barev, u
PPM je teoreticky možné použít až neuvěřitelných
65536&times;65536&times;65536=281474976710656 barevných odstínů (ovšem délka
těchto souborů je také neuvěřitelná :-). Hlavička textové varianty formátu PPM
má tvar:</p>

<pre>
P3 (případné bílé znaky)
šířka (případné bílé znaky)
výška (případné bílé znaky)
maximální hodnota barvové složky pixelu (případné bílé znaky)
rastrová data v textovém tvaru
</pre>

<p>Barvové složky pixelů jsou uloženy s&nbsp;gamma faktorem nastaveným na 2,16,
ovšem některé materiály zmiňují gamma faktor=2,2. Nekorektně napsané aplikace
předpokládají, že mezi intenzitou barvové složky a její hodnotou je lineární
vztah, takto vzniklé obrázky však postrádají kontrast v&nbsp;oblasti vyšších
intenzit a také se snižuje dynamika (to vadí zejména u obrázků, které jsou již
původně nekvalitní, například příliš tmavé či světlé). Následuje ukázka začátku
souboru s&nbsp;truecolor obrázkem Lenny:</p>

<pre>
P3
# Created by IrfanView
256 256
255
224 136 122 224 136 122 224 136 124
...
...
...
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Binární varianta Portable PixelMap File Format (PPM)</h2>

<p>Binární forma souborů typu <strong>PPM</strong> nepřináší nic převratného.
V&nbsp;hlavičce došlo ke změně magického čísla na <strong>"P6"</strong>
(textová varianta má <strong>"P3"</strong>) a pixely jsou podle nastavené
maximální hodnoty (0 až 2<sup>16</sup>) uloženy buď pomocí trojice bajtů
<i>RGB</i>, nebo jako šestice <i>RRGGBB</i>. Celková délka souboru
v&nbsp;případě trojice bytů na pixel (24&nbsp;bpp) přibližně odpovídá
nekomprimovaným souborům <strong>TGA</strong> či <strong>BMP</strong> (většinou
budou soubory BMP větší, protože u nich jsou řádky zarovnávány na hodnotu
dělitelnou čtyřmi). V&nbsp;případě plnobarevného obrázku Lenny má soubor délku
196646 bytů, což je oproti čistému rastrovému obrázku
(256&times;256&times;3=196608) pouze nepatrné zvýšení.</p>

<p>Ani při práci s&nbsp;binárním formátem nesmíme zapomenout na gamma faktor,
který má hodnotu 2,16. Pro maximální hodnotu barvových složek do 256 (maximálně
16 milionů barev) je většinou vhodnější provádět gamma korekci s&nbsp;využitím
vyhledávací tabulky (<i>look-up table</i>), pro větší maximální hodnoty však
velikost tabulky narůstá a proto se používají sice pomalejší, ale paměťově
zcela nenáročné konverzní funkce. Při požadavku na rychlé (a poněkud nepřesné)
náhledy se také používá aproximace gamma funkce (což je exponenciála a při
inverzní transformaci logaritmická funkce) dvojicí lineárních úseků.</p>

<p>Pro naše účely &ndash; uložení obsahu framebufferu &ndash; využijeme právě
tento souborový formát, takže export bude vypadat přibližně takto:</p>

<pre>
<strong>void</strong> saveFramebuffer(<strong>const</strong> <strong>char</strong> *filename, FramebufferInfo *framebufferInfoPtr, <strong>char</strong> *pixels)
{
    <strong>const</strong> <strong>int</strong> bpp = framebufferInfoPtr-&gt;bits_per_pixel;
    <strong>const</strong> <strong>int</strong> xres = framebufferInfoPtr-&gt;xres;
    <strong>const</strong> <strong>int</strong> yres = framebufferInfoPtr-&gt;yres;
&nbsp;
    FILE *fout = fopen(filename, "wb");
    <strong>int</strong> i;
    <strong>char</strong> *adr=pixels;
&nbsp;
    <strong>if</strong> (!fout) {
        perror("Unable to open output file");
        <strong>return</strong>;
    }
&nbsp;
    <i>/* hlavicka souboru s rastrovym obrazkem */</i>
    fprintf(fout, "P6\n");
    fprintf(fout, "%d\n%d\n255\n", xres, yres);
&nbsp;
    <i>/* zde bude kód, který v binární podobě zapíše hodnoty jednotlivých pixelů */</i>
    ...
    ...
    ...
    <i>/* zde bude kód, který v binární podobě zapíše hodnoty jednotlivých pixelů */</i>
&nbsp;
    fclose(fout);
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Konverze barev</h2>

<p>Číst jednotlivé pixely z&nbsp;framebufferu již umíme, souborový formát pro
uložení těchto dat je taktéž zvolený, takže nám zbývá &bdquo;pouze&ldquo;
zajistit konverzi barev. Pokud je framebuffer Raspberry Pi nakonfigurován na
použití framebufferu o hloubce 24bpp či 32bpp, je konverze barev a následný
export dat triviální. Pouze si musíme dát pozor na to, že u 32bitové hloubky se
poslední bajt každého pixelu do výsledného souboru neukládá (viz příkaz adr+=3;
a adr+=4;):</p>

<pre>
<strong>const</strong> <strong>int</strong> bpp = framebufferInfoPtr-&gt;bits_per_pixel;
<strong>const</strong> <strong>int</strong> xres = framebufferInfoPtr-&gt;xres;
<strong>const</strong> <strong>int</strong> yres = framebufferInfoPtr-&gt;yres;
&nbsp;
<strong>int</strong> i;
<strong>char</strong> *adr=pixels;
&nbsp;
<strong>switch</strong> (bpp) {
    <strong>case</strong> 24: <i>/* 24bitova barvova hloubka - lze nahradit jedinym zapisem, pokud nebudete prehazovat barvy! */</i>
        <strong>for</strong> (i=0; i&lt;xres*yres; i++) {
            fwrite(adr+2, 1, 1, fout);
            fwrite(adr+1, 1, 1, fout);
            fwrite(adr+0, 1, 1, fout);
            adr+=3; <i>/* posun na dalsi pixel ve framebufferu */</i>
        }
        <strong>break</strong>;
    <strong>case</strong> 32: <i>/* 32bitova barvova hloubka */</i>
        <strong>for</strong> (i=0; i&lt;xres*yres; i++) {
            fwrite(adr+2, 1, 1, fout);
            fwrite(adr+1, 1, 1, fout);
            fwrite(adr+0, 1, 1, fout);
            adr+=4; <i>/* posledni bajt se busi preskocit, neuklada se */</i>
        }
        <strong>break</strong>;
}
</pre>

<p>Komplikovanější (čti &bdquo;zajímavější&ldquo;) je situace v&nbsp;případě,
že je použit framebuffer se šestnáctibitovou hloubkou, což je pro Raspberry Pi
výchozí nastavení. Zde je nutné provést tři kroky &ndash; načíst dvojici
sousedních bajtů, v&nbsp;nichž je uložena barva pixelu, spojit tyto dva bajty
do jediného slova a nakonec provést opětovné rozdělení na tři barvové složky
R,G,B. Připomeňme si, že u Raspberry Pi je použit formát 565, tj.&nbsp;modrá a
červená složka pixelu je uložena v&nbsp;pěti bitech a zelená složka
v&nbsp;šesti bitech. Při bitové aritmetice budou využity tyto konstanty:</p>

<pre>
<i>/*</i>
<i> * Plati pro format 565</i>
<i> */</i>
#define RED_OFFSET     11    <i>/* posun v rámci 16bitové hodnoty pixelu */</i>
#define GREEN_OFFSET    5
#define BLUE_OFFSET     0
#define RED_LOST_BITS   3    <i>/* počet spodních bitů z 8bitového slova, které nejsou ukládány */</i>
#define GREEN_LOST_BITS 2
#define BLUE_LOST_BITS  3
#define RED_MASK        0x1f <i>/* 0001 1111 */</i>
#define GREEN_MASK      0x3f <i>/* 0011 1111 */</i>
#define BLUE_MASK       0x1f <i>/* 0001 1111 */</i>
</pre>

<p>Samotné dekódování barev může vypadat následovně:</p>

<pre>
<i>/* nejprve se prectou dva bajty z framebufferu */</i>
<strong>unsigned</strong> <strong>char</strong> b1 = *(adr+1);
<strong>unsigned</strong> <strong>char</strong> b2 = *(adr);
&nbsp;
<i>/* posleze se prevedou na 16bitove slovo */</i>
<strong>unsigned</strong> <strong>int</strong>  color = (b1 &lt;&lt; 8) + b2;
&nbsp;
<i>/* a zase ziskame zpetnym prevodem hodnoty barvovych slozek */</i>
<i>/* 1) nejprve je 16bitove slovo posunuto doprava tak, aby se ve spodnich bitech nachazela prislusna slozka */</i>
<i>/* 2) posleze se provede maskovani spodnich peti ci sesti bitu, vysledkem je 16bitove slovo s nulovymi 10 ci 9 bity */</i>
<i>/* 3) nasledne se onech 5 ci 6 bitu posune doleva, aby vznikla osmibitova hodnota barvy */</i>
<strong>unsigned</strong> <strong>char</strong> r = ((color &gt;&gt; RED_OFFSET)   &amp; RED_MASK)   &lt;&lt; RED_LOST_BITS;
<strong>unsigned</strong> <strong>char</strong> g = ((color &gt;&gt; GREEN_OFFSET) &amp; GREEN_MASK) &lt;&lt; GREEN_LOST_BITS;
<strong>unsigned</strong> <strong>char</strong> b = ((color &gt;&gt; BLUE_OFFSET)  &amp; BLUE_MASK)  &lt;&lt; BLUE_LOST_BITS;
</pre>

<p>Trojici výsledných bajtů uložíme do výstupního souboru jednoduše:</p>

<pre>
<i>/* zapis barvovych slozek */</i>
putc(r, fout);
putc(g, fout);
putc(b, fout);
adr+=2; <i>/* posun na dalsi pixel ve framebufferu */</i>
</pre>

<p>Výsledná podoba celé funkce provádějící export dat z&nbsp;framebufferu
(&bdquo;screenshot&ldquo;) může vypadat takto:</p>

<pre>
<strong>void</strong> saveFramebuffer(<strong>const</strong> <strong>char</strong> *filename, FramebufferInfo *framebufferInfoPtr, <strong>char</strong> *pixels)
{
    <strong>const</strong> <strong>int</strong> bpp = framebufferInfoPtr-&gt;bits_per_pixel;
    <strong>const</strong> <strong>int</strong> xres = framebufferInfoPtr-&gt;xres;
    <strong>const</strong> <strong>int</strong> yres = framebufferInfoPtr-&gt;yres;
&nbsp;
    FILE *fout = fopen(filename, "wb");
    <strong>int</strong> i;
    <strong>char</strong> *adr=pixels;
&nbsp;
    <strong>if</strong> (!fout) {
        perror("Unable to open output file");
        <strong>return</strong>;
    }
&nbsp;
    <i>/* hlavicka souboru s rastrovym obrazkem */</i>
    fprintf(fout, "P6\n");
    fprintf(fout, "%d\n%d\n255\n", xres, yres);
&nbsp;
    <strong>switch</strong> (bpp) {
        <strong>case</strong> 16: <i>/* 16bitova barvova hloubka, predpokladejme format 565 */</i>
            <strong>for</strong> (i=0; i&lt;xres*yres; i++) {
                <i>/* nejprve se prectou dva bajty z framebufferu */</i>
                <strong>unsigned</strong> <strong>char</strong> b1 = *(adr+1);
                <strong>unsigned</strong> <strong>char</strong> b2 = *(adr);
                <i>/* posleze se prevedou na 16bitove slovo */</i>
                <strong>unsigned</strong> <strong>int</strong>  color = (b1 &lt;&lt; 8) + b2;
                <i>/* a zase ziskame zpetnym prevodem hodnoty barvovych slozek */</i>
                <strong>unsigned</strong> <strong>char</strong> r = ((color &gt;&gt; RED_OFFSET)   &amp; RED_MASK)   &lt;&lt; RED_LOST_BITS;
                <strong>unsigned</strong> <strong>char</strong> g = ((color &gt;&gt; GREEN_OFFSET) &amp; GREEN_MASK) &lt;&lt; GREEN_LOST_BITS;
                <strong>unsigned</strong> <strong>char</strong> b = ((color &gt;&gt; BLUE_OFFSET)  &amp; BLUE_MASK)  &lt;&lt; BLUE_LOST_BITS;
                <i>/* zapis barvovych slozek */</i>
                putc(r, fout);
                putc(g, fout);
                putc(b, fout);
                adr+=2; <i>/* posun na dalsi pixel ve framebufferu */</i>
            }
            <strong>break</strong>;
        <strong>case</strong> 24: <i>/* 24bitova barvova hloubka - lze nahradit jedinym zapisem, pokud nebudete prehazovat barvy! */</i>
            <strong>for</strong> (i=0; i&lt;xres*yres; i++) {
                fwrite(adr+2, 1, 1, fout);
                fwrite(adr+1, 1, 1, fout);
                fwrite(adr+0, 1, 1, fout);
                adr+=3; <i>/* posun na dalsi pixel ve framebufferu */</i>
            }
            <strong>break</strong>;
        <strong>case</strong> 32: <i>/* 32bitova barvova hloubka */</i>
            <strong>for</strong> (i=0; i&lt;xres*yres; i++) {
                fwrite(adr+2, 1, 1, fout);
                fwrite(adr+1, 1, 1, fout);
                fwrite(adr+0, 1, 1, fout);
                adr+=4; <i>/* posledni bajt se busi preskocit, neuklada se */</i>
            }
            <strong>break</strong>;
    }
    fclose(fout);
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Úplný zdrojový kód prvního demonstračního příkladu</h2>

<p>Funkci pro export obsahu celého framebufferu do externího souboru typu PPM,
jsem přidal do příkladu, s&nbsp;nímž jsme se již seznámili minule. Jde o
příklad, který vykreslí několik úseček s&nbsp;různým sklonem a barvou. Výsledný
screenshot po konverzi do PNG vypadá následovně:</p>

<a href="http://www.root.cz/obrazek/237016/"><img src="https://i.iinfo.cz/images/572/rpi4-1-prev.png" class="image-237016" alt="&#160;" width="370" height="178" /></a>
<p><i>Obrázek 1: Screenshot vygenerovaný příkladem rpi_fb11.c.</i></p>

<p>Úplný zdrojový kód tohoto příkladu je možné získat na adrese <a
href="https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb11.c">https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb11.c</a>,
popř.&nbsp;alternativně i oblíbenou :-) metodou copy and paste:</p>

<pre>
<i>/* Framebuffer na jednodeskovem mikropocitaci Raspberry Pi */</i>
<i>/* Autor: Pavel Tisnovsky, 2016 */</i>
&nbsp;
<i>/* Demonstracni priklad cislo 11: vykreslovani usecek: rychlejsi varianta */</i>
<i>/*                                nepouzivajici funkci putpixel.          */</i>
<i>/*                                Pridani kodu pro ulozeni framebufferu   */</i>
&nbsp;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;linux/fb.h&gt;
#include &lt;linux/types.h&gt;
&nbsp;
&nbsp;
&nbsp;
#define ABS(x) ((x)&lt;0 ? -(x) : (x))
&nbsp;
<i>/*</i>
<i> * Datova struktura, do niz se ulozi informace o framebufferu.</i>
<i> * Blizsi informace o teto strukture je mozne nalezt v hlavickovem souboru</i>
<i> * dostupnem v adresari "/usr/include/linux/fb.h"</i>
<i> */</i>
<strong>typedef</strong> struct fb_var_screeninfo FramebufferInfo;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Druha datova struktura popisujici zbyvajici vlastnosti framebufferu.</i>
<i> * Blizsi informace o teto strukture je mozne nalezt v hlavickovem souboru</i>
<i> * dostupnem v adresari "/usr/include/linux/fb.h"</i>
<i> */</i>
<strong>typedef</strong> struct fb_fix_screeninfo ModeInfo;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Precteni vsech relevantnich informaci zjistenych o framebufferu. Pro korektni</i>
<i> * funkci je zapotrebi, aby mel uzivatel pristup k zarizeni /dev/fb0</i>
<i> * (postacuje byt ve skupine 'video' ci pouziti su/sudo)</i>
<i> */</i>
<strong>int</strong> readFramebufferInfo(<strong>int</strong> framebufferDevice,
                        FramebufferInfo *framebufferInfoPtr,
                        ModeInfo        *modeInfoPtr)
{
    <i>/* Pokud operace ioctl probehne v poradku, vrati se 0 */</i>
    <strong>if</strong> (ioctl(framebufferDevice, FBIOGET_VSCREENINFO, framebufferInfoPtr)) {
        perror("Nelze precist informace o framebufferu");
        <strong>return</strong> 0;
    }
&nbsp;
    <i>/* Pokud operace ioctl probehne v poradku, vrati se 0 */</i>
    <strong>if</strong> (ioctl(framebufferDevice, FBIOGET_FSCREENINFO, modeInfoPtr)) {
        perror("Nelze precist informace o rezimu");
        <strong>return</strong> 0;
    }
    <strong>return</strong> 1;
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce line() platna pro nezname graficke rezimy.</i>
<i> */</i>
<strong>void</strong> lineNull(<strong>const</strong> <strong>int</strong> x1, <strong>const</strong> <strong>int</strong> y1, <strong>const</strong> <strong>int</strong> x2, <strong>const</strong> <strong>int</strong> y2,
              <strong>const</strong> <strong>unsigned</strong> <strong>char</strong> r, <strong>const</strong> <strong>unsigned</strong> <strong>char</strong> g, <strong>const</strong> <strong>unsigned</strong> <strong>char</strong> b,
              <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length)
{
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce line platna pouze pro graficke rezimy true-color</i>
<i> * s formatem 8-8-8-8 (popr. muze byt alfa kanal ignorovan).</i>
<i> * Funkcni naproklad pro graficke karty Intel.</i>
<i> */</i>
<strong>void</strong> lineBGRA(<strong>const</strong> <strong>int</strong> x1, <strong>const</strong> <strong>int</strong> y1, <strong>const</strong> <strong>int</strong> x2, <strong>const</strong> <strong>int</strong> y2,
              <strong>const</strong> <strong>unsigned</strong> <strong>char</strong> r, <strong>const</strong> <strong>unsigned</strong> <strong>char</strong> g, <strong>const</strong> <strong>unsigned</strong> <strong>char</strong> b,
              <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length)
{
    <i>/* vypocet adresy zapisu dat */</i>
    <i>/* pocitame v 32bitovych slovech, tj. line_length je nutne podelit ctyrmi */</i>
    <strong>unsigned</strong> <strong>int</strong> index = x1 + (y1*line_length &gt;&gt; 2);
    <i>/* &gt;&gt; 2 nahrazuje deleni ctyrmi */</i>
&nbsp;
    <i>/* vlastni provedeni vykresleni usecky */</i>
    <strong>int</strong> x = x1;
    <strong>int</strong> y = y1;
    <i>/* zrcadleni algoritmu pro dalsi oktanty */</i>
    <strong>int</strong> dx = ABS(x2-x1), sx = x1&lt;x2 ? 1 : -1;
    <strong>int</strong> dy = ABS(y2-y1), sy = y1&lt;y2 ? 1 : -1;
    <strong>int</strong> err = (dx&gt;dy ? dx : -dy)/2, e2;
&nbsp;
    <i>/* uplna barva v jednom slove */</i>
    __u32 color = (r&lt;&lt;16) | (g&lt;&lt;8) | b;
    __u32 *pixels32 = (__u32*)pixels;
&nbsp;
    <i>/* pri posunu po x-ove ose se index musi zvysit ci snizit o 4 (bajty) tj. o 1 32-bitove slovo */</i>
    <strong>int</strong> offsetX = x1&lt;x2 ? 1: -1;
    <i>/* pri posunu po y-ove ose se index musi zvysit ci snizit o delku radku (ve slovech) */</i>
    <strong>int</strong> offsetY = y1&lt;y2 ? (line_length &gt;&gt; 2) : - (line_length &gt;&gt; 2);
&nbsp;
    <strong>while</strong> (1) {
        <i>/* vlastni provedeni zapisu barvy pixelu */</i>
        *(pixels32+index) = color;
&nbsp;
        <strong>if</strong> (x==x2 &amp;&amp; y==y2) {
            <strong>break</strong>;
        }
        e2 = err;
        <strong>if</strong> (e2 &gt;-dx) {
            <i>/* prepocet kumulovane chyby */</i>
            err -= dy;
            <i>/* posun na predchozi ci dalsi pixel na radku */</i>
            x += sx;
            index += offsetX;
        }
        <strong>if</strong> (e2 &lt; dy) {
            <i>/* prepocet kumulovane chyby */</i>
            err += dx;
            <i>/* posun na predchozi ci nasledujici radek */</i>
            y += sy;
            index += offsetY;
        }
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce line platna pouze pro graficke rezimy true-color</i>
<i> * s formatem 8-8-8-8 (popr. muze byt alfa kanal ignorovan).</i>
<i> * Funkcni pro Raspberry Pi s poradim bajtu R,G,B,A.</i>
<i> */</i>
<strong>void</strong> lineRGBA(<strong>const</strong> <strong>int</strong> x1, <strong>const</strong> <strong>int</strong> y1, <strong>const</strong> <strong>int</strong> x2, <strong>const</strong> <strong>int</strong> y2,
              <strong>const</strong> <strong>unsigned</strong> <strong>char</strong> r, <strong>const</strong> <strong>unsigned</strong> <strong>char</strong> g, <strong>const</strong> <strong>unsigned</strong> <strong>char</strong> b,
              <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length)
{
    lineBGRA(x1, y1, x2, y2, b, g, r, pixels, line_length);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Plati pro format 565</i>
<i> */</i>
#define RED_OFFSET     11
#define GREEN_OFFSET    5
#define BLUE_OFFSET     0
#define RED_LOST_BITS   3
#define GREEN_LOST_BITS 2
#define BLUE_LOST_BITS  3
#define RED_MASK        0x1f <i>/* 0001 1111 */</i>
#define GREEN_MASK      0x3f <i>/* 0011 1111 */</i>
#define BLUE_MASK       0x1f <i>/* 0001 1111 */</i>
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce line platna pouze pro graficke rezimy hi-color</i>
<i> * s formatem 5-6-5.</i>
<i> */</i>
<strong>void</strong> line565(<strong>const</strong> <strong>int</strong> x1, <strong>const</strong> <strong>int</strong> y1, <strong>const</strong> <strong>int</strong> x2, <strong>const</strong> <strong>int</strong> y2,
             <strong>const</strong> <strong>unsigned</strong> <strong>char</strong> r, <strong>const</strong> <strong>unsigned</strong> <strong>char</strong> g, <strong>const</strong> <strong>unsigned</strong> <strong>char</strong> b,
             <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length)
{
    <i>/* vypocet barvy pixelu, v zavorce nejdrive snizime bitovou sirku</i>
    <i> * rezervovanou pro jednotlive barvove slozky a posleze bity, ktere</i>
    <i> * reprezentuji barvovou slozku posuneme do spravne pozice ve slove */</i>
    <strong>unsigned</strong> <strong>int</strong> pixel_value = (r &gt;&gt; RED_LOST_BITS)   &lt;&lt; RED_OFFSET |
                               (g &gt;&gt; GREEN_LOST_BITS) &lt;&lt; GREEN_OFFSET |
                               (b &gt;&gt; BLUE_LOST_BITS)  &lt;&lt; BLUE_OFFSET;
&nbsp;
    <i>/* prevod na dvojici bajtu */</i>
    <strong>unsigned</strong> <strong>char</strong> byte1 = pixel_value &amp; 0xff;
    <strong>unsigned</strong> <strong>char</strong> byte2 = pixel_value &gt;&gt; 8;
&nbsp;
    <i>/* vypocet adresy zapisu dat */</i>
    <strong>unsigned</strong> <strong>int</strong> index = (x1&lt;&lt;1) + y1*line_length;
    <i>/* &lt;&lt; 1 nahrazuje nasobeni dvema */</i>
&nbsp;
    <i>/* vykresleni usecky */</i>
    <strong>int</strong> x = x1;
    <strong>int</strong> y = y1;
    <i>/* zrcadleni algoritmu pro dalsi oktanty */</i>
    <strong>int</strong> dx = ABS(x2-x1), sx = x1&lt;x2 ? 1 : -1;
    <strong>int</strong> dy = ABS(y2-y1), sy = y1&lt;y2 ? 1 : -1;
    <strong>int</strong> err = (dx&gt;dy ? dx : -dy)/2, e2;
&nbsp;
    <i>/* pri posunu po x-ove ose se index musi zvysit ci snizit o 2 (bajty) */</i>
    <strong>int</strong> offsetX = x1&lt;x2 ? 2: -2;
    <i>/* pri posunu po y-ove ose se index musi zvysit ci snizit o delku radku (v bajtech) */</i>
    <strong>int</strong> offsetY = y1&lt;y2 ? line_length : - line_length;
&nbsp;
    <strong>while</strong> (1) {
        <i>/* vlastni provedeni zapisu barvy pixelu */</i>
        *(pixels+index) = byte1;
        *(pixels+index+1) = byte2;
&nbsp;
        <strong>if</strong> (x==x2 &amp;&amp; y==y2) {
            <strong>break</strong>;
        }
        e2 = err;
        <strong>if</strong> (e2 &gt;-dx) {
            <i>/* prepocet kumulovane chyby */</i>
            err -= dy;
            <i>/* posun na predchozi ci dalsi pixel na radku */</i>
            x += sx;
            index += offsetX;
        }
        <strong>if</strong> (e2 &lt; dy) {
            <i>/* prepocet kumulovane chyby */</i>
            err += dx;
            <i>/* posun na predchozi ci nasledujici radek */</i>
            y += sy;
            index += offsetY;
        }
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Novy datovy typ - ukazatel na (libovolnou) funkci line.</i>
<i> */</i>
<strong>typedef</strong> <strong>void</strong> (*LineFunction)(<strong>const</strong> <strong>int</strong>, <strong>const</strong> <strong>int</strong>, <strong>const</strong> <strong>int</strong>, <strong>const</strong> <strong>int</strong>,
                             <strong>const</strong> <strong>unsigned</strong> <strong>char</strong>, <strong>const</strong> <strong>unsigned</strong> <strong>char</strong>, <strong>const</strong> <strong>unsigned</strong> <strong>char</strong>,
                             <strong>char</strong>*, <strong>const</strong> <strong>int</strong>);
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce, ktera vraci korektni funkci pro operaci line().</i>
<i> */</i>
LineFunction getProperLineFunction(<strong>int</strong> bits_per_pixel, <strong>int</strong> type, <strong>int</strong> visual, <strong>int</strong> redOffset)
{
    <i>/* umime rozeznat pouze format bez bitovych rovin a bez palety */</i>
    <strong>if</strong> (type == FB_TYPE_PACKED_PIXELS &amp;&amp; visual == FB_VISUAL_TRUECOLOR) {
        <strong>if</strong> (bits_per_pixel == 16) {
            <strong>return</strong> line565;
        }
        <strong>if</strong> (bits_per_pixel == 32) {
            <strong>if</strong> (redOffset == 16) {
                <strong>return</strong> lineBGRA;
            }
            <strong>else</strong> {
                <strong>return</strong> lineRGBA;
            }
        }
    }
    <strong>return</strong> lineNull;
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ulozeni obsahu framebufferu do souboru s rastrovym obrazkem.</i>
<i> */</i>
<strong>void</strong> saveFramebuffer(<strong>const</strong> <strong>char</strong> *filename, FramebufferInfo *framebufferInfoPtr, <strong>char</strong> *pixels)
{
    <strong>const</strong> <strong>int</strong> bpp = framebufferInfoPtr-&gt;bits_per_pixel;
    <strong>const</strong> <strong>int</strong> xres = framebufferInfoPtr-&gt;xres;
    <strong>const</strong> <strong>int</strong> yres = framebufferInfoPtr-&gt;yres;
&nbsp;
    FILE *fout = fopen(filename, "wb");
    <strong>int</strong> i;
    <strong>char</strong> *adr=pixels;
&nbsp;
    <strong>if</strong> (!fout) {
        perror("Unable to open output file");
        <strong>return</strong>;
    }
&nbsp;
    <i>/* hlavicka souboru s rastrovym obrazkem */</i>
    fprintf(fout, "P6\n");
    fprintf(fout, "%d\n%d\n255\n", xres, yres);
&nbsp;
    <strong>switch</strong> (bpp) {
        <strong>case</strong> 16: <i>/* 16bitova barvova hloubka, predpokladejme format 565 */</i>
            <strong>for</strong> (i=0; i&lt;xres*yres; i++) {
                <i>/* nejprve se prectou dva bajty z framebufferu */</i>
                <strong>unsigned</strong> <strong>char</strong> b1 = *(adr+1);
                <strong>unsigned</strong> <strong>char</strong> b2 = *(adr);
                <i>/* posleze se prevedou na 16bitove slovo */</i>
                <strong>unsigned</strong> <strong>int</strong>  color = (b1 &lt;&lt; 8) + b2;
                <i>/* a zase ziskame zpetnym prevodem hodnoty barvovych slozek */</i>
                <strong>unsigned</strong> <strong>char</strong> r = ((color &gt;&gt; RED_OFFSET)   &amp; RED_MASK)   &lt;&lt; RED_LOST_BITS;
                <strong>unsigned</strong> <strong>char</strong> g = ((color &gt;&gt; GREEN_OFFSET) &amp; GREEN_MASK) &lt;&lt; GREEN_LOST_BITS;
                <strong>unsigned</strong> <strong>char</strong> b = ((color &gt;&gt; BLUE_OFFSET)  &amp; BLUE_MASK)  &lt;&lt; BLUE_LOST_BITS;
                <i>/* zapis barvovych slozek */</i>
                putc(r, fout);
                putc(g, fout);
                putc(b, fout);
                adr+=2; <i>/* posun na dalsi pixel ve framebufferu */</i>
            }
            <strong>break</strong>;
        <strong>case</strong> 24: <i>/* 24bitova barvova hloubka - lze nahradit jedinym zapisem, pokud nebudete prehazovat barvy! */</i>
            <strong>for</strong> (i=0; i&lt;xres*yres; i++) {
                fwrite(adr+2, 1, 1, fout);
                fwrite(adr+1, 1, 1, fout);
                fwrite(adr+0, 1, 1, fout);
                adr+=3; <i>/* posun na dalsi pixel ve framebufferu */</i>
            }
            <strong>break</strong>;
        <strong>case</strong> 32: <i>/* 32bitova barvova hloubka */</i>
            <strong>for</strong> (i=0; i&lt;xres*yres; i++) {
                fwrite(adr+2, 1, 1, fout);
                fwrite(adr+1, 1, 1, fout);
                fwrite(adr+0, 1, 1, fout);
                adr+=4; <i>/* posledni bajt se busi preskocit, neuklada se */</i>
            }
            <strong>break</strong>;
    }
    fclose(fout);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vykresleni testovaciho obrazku s vyuzitim funkce line.</i>
<i> */</i>
<strong>void</strong> drawTestImage(<strong>int</strong> framebufferDevice,
                   FramebufferInfo *framebufferInfoPtr,
                   ModeInfo        *modeInfoPtr)
{
#define OFFSET 300
    <i>/* casto pouzivane konstanty */</i>
    <strong>const</strong> <strong>int</strong> buffer_length = modeInfoPtr-&gt;smem_len;
    <strong>const</strong> <strong>int</strong> pitch = modeInfoPtr-&gt;line_length;
&nbsp;
    <i>/* ziskame spravnou verzi funkce line */</i>
    LineFunction line = getProperLineFunction(framebufferInfoPtr-&gt;bits_per_pixel,
                                              modeInfoPtr-&gt;type,
                                              modeInfoPtr-&gt;visual,
                                              framebufferInfoPtr-&gt;red.offset);
&nbsp;
    <i>/* ziskat primy pristup do framebufferu */</i>
    <strong>char</strong> *pixels = (<strong>char</strong>*)mmap(0, buffer_length,
                               PROT_READ | PROT_WRITE,
                               MAP_SHARED, framebufferDevice,
                               0);
&nbsp;
    <strong>if</strong> (pixels != MAP_FAILED) {
        <strong>int</strong> i;
        <strong>int</strong> r, g, b;
        <i>/* nejprve vymazeme cely framebuffer */</i>
        memset(pixels, 0, buffer_length);
&nbsp;
        <i>/* vykreslime nekolik usecek s ruznym sklonem a barvou*/</i>
        <strong>for</strong> (i=0; i&lt;256; i++) {
            r = i;
            g = i;
            b = 255-i;
            line(i*3, 0, i*3, 100, r, g, b, pixels, pitch);
            r = 255;
            g = i;
            b = 255-i;
            line(i*4, 150, i*5, 250, r, g, b, pixels, pitch);
        }
        <strong>for</strong> (i=0; i&lt;=300; i+=10) {
            line(0, 300 + i, i, 300 + 300, 255, 255, 255, pixels, pitch);
&nbsp;
            line(300, 300, 600, 300 + i, 128, 128, 255, pixels, pitch);
        }
        <i>/* ulozeni framebufferu */</i>
        saveFramebuffer("rpi_fb11.ppm", framebufferInfoPtr, pixels);
        <i>/* cekani na stisk klavesy */</i>
        getchar();
        munmap(pixels, buffer_length);
    }
    <strong>else</strong> {
        perror("Nelze pristupovat k framebufferu");
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/* Vstupni bod do demonstracniho prikladu... :) */</i>
<strong>int</strong> main(<strong>int</strong> argc, <strong>char</strong> **argv)
{
    FramebufferInfo framebufferInfo;
    ModeInfo        modeInfo;
    <strong>int</strong> framebufferDevice = 0;
&nbsp;
    <i>/* Ze zarizeni potrebujeme cist i zapisovat.*/</i>
    framebufferDevice = open("/dev/fb0", O_RDWR);
&nbsp;
    <i>/* Pokud otevreni probehlo uspesne, nacteme</i>
    <i> * a nasledne vypiseme informaci o framebufferu.*/</i>
    <strong>if</strong> (framebufferDevice != -1) {
        <i>/* Precteni informaci o framebufferu a test, zda se vse podarilo */</i>
        <strong>if</strong> (readFramebufferInfo(framebufferDevice, &amp;framebufferInfo, &amp;modeInfo)) {
            drawTestImage(framebufferDevice, &amp;framebufferInfo, &amp;modeInfo);
        }
        close(framebufferDevice);
        <strong>return</strong> 0;
    }
    <i>/* Otevreni se nezadarilo, vypiseme tudiz pouze chybove hlaseni.*/</i>
    <strong>else</strong> {
        perror("Nelze otevrit ovladac /dev/fb0");
        <strong>return</strong> 1;
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/* finito */</i>
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vykreslování úseček s&nbsp;aplikací antialiasingu</h2>

<p>Minule popsaný Bresenhamův algoritmus použitý při vykreslování úseček je
velmi rychlý, pro jeho implementaci lze použít pouze celočíselnou aritmetiku a
navíc ho je možné různými způsoby optimalizovat, aby se omezil počet
podmíněných skoků. Ovšem za tuto vysokou efektivitu musíme zaplatit:
Bresenhamův algoritmus ve své základní variantě nedokáže vyhlazovat
&bdquo;schody&ldquo;, které vznikají na prakticky všech úsečkách, samozřejmě
kromě úseček přísně svislých či vodorovných. To sice nevadí ve chvíli, kdy
vykreslovací zařízení má vysoké rozlišení a navíc nedokáže pracovat
s&nbsp;různými intenzitami barev (příkladem mohou být laserové tiskárny a
osvitové jednotky). Ovšem na monitorech, které mají v&nbsp;porovnání se
zmíněnými osvitovými jednotkami řádově menší rozlišení, je někdy vhodnější
použít jiný algoritmus.</p>

<img src="https://i.iinfo.cz/images/178/rpi4-2.png" class="image-237017" alt="&#160;" width="703" height="198" />
<p><i>Obrázek 2: Krásné vodorovné úsečky &ndash; nebo ne?</i></p>

<p>Podívali jste se pozorně na předchozí obrázek? Zdánlivě jsou na něm
vykresleny vodorovné čáry, ovšem skutečnost je jiná. Jde o úsečky, jejichž
druhý vrchol je posunutý přesně o jeden pixel dolů, takže při použití
klasického Bresenhamova algoritmu dostaneme tento obrázek, kde je každý
&bdquo;schod&ldquo; uprostřed úseček jasně patrný:</p>

<img src="https://i.iinfo.cz/images/79/rpi4-3.png" class="image-237018" alt="&#160;" width="703" height="180" />
<p><i>Obrázek 3: &bdquo;Schody&ldquo; vytvořené Bresenhamovým
algoritmem.</i></p>

<p>A právě na rozdílech mezi druhým a třetím obrázkem je postaven <a
href="https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm">algoritmus</a>,
jehož autorem je Xiaolin Wu. Tento algoritmus vykresluje každou úsečku se
šířkou dvou pixelů, ovšem takovým způsobem, že součet intenzit těchto dvou
pixelů se rovná původní barvě úsečky, takže dochází k&nbsp;optickému klamu a
zdánlivému zmizení oněch schodů. Nevýhodou je složitější výpočet, použití
operací s&nbsp;plovoucí řádovou čárkou (popř.&nbsp;fixed point) a nutnost gamma
korekce (tu jsem provedl až ve fázi postprocessingu). Celý algoritmus v&nbsp;mé
úpravě vypadá následovně:</p>

<pre>
<i>/*</i>
<i> * Funkce pro vykresleni usecky s aplikaci antialiasingu.</i>
<i> */</i>
<strong>void</strong> lineAA(<strong>const</strong> <strong>int</strong> x1, <strong>const</strong> <strong>int</strong> y1, <strong>const</strong> <strong>int</strong> x2, <strong>const</strong> <strong>int</strong> y2,
          <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length, PutpixelFunction putpixel)
{
    <i>/* specialni pripad - svisla usecka */</i>
    <strong>if</strong> (x1==x2) {
        verticalLine(x1, y1, y2, pixels, line_length, putpixel);
        <strong>return</strong>;
    }
&nbsp;
    <i>/* specialni pripad - vodorovna usecka */</i>
    <strong>if</strong> (y1==y2) {
        horizontalLine(x1, x2, y1, pixels, line_length, putpixel);
        <strong>return</strong>;
    }
&nbsp;
    <i>/* mame smulu a musime pouzit plnou verzi algoritmu */</i>
&nbsp;
    <i>/* konstanty pouzite pri vykreslovani */</i>
    <strong>int</strong> dx = x2 - x1;
    <strong>int</strong> dy = y2 - y1;
    double s, p, e=255.0;
    <strong>int</strong> x, y, xdelta, ydelta, xpdelta, ypdelta, xp, yp;
    <strong>int</strong> i, imin, imax;
&nbsp;
    <i>/* pomocne promenne - pocatecni a koncove body */</i>
    <strong>int</strong> xx1 = x1 &lt; x2 ? x1 : x2;
    <strong>int</strong> xx2 = x1 &lt; x2 ? x2 : x1;
    <strong>int</strong> yy1 = x1 &lt; x2 ? y1 : y2;
    <strong>int</strong> yy2 = x1 &lt; x2 ? y2 : y1;
&nbsp;
    <i>/* nastaveni pro sklony mensi nez 45 stupnu */</i>
    <strong>if</strong> (ABS(dx) &gt; ABS(dy)) {
        s=(double)dy/(double)dx;
        imin=xx1;  imax=xx2;
        x=xx1;     y=yy1;
        xdelta=1;  ydelta=0;
        xpdelta=0;
        xp=0;
        <strong>if</strong> (yy2&gt;yy1) {
            ypdelta=1;
            yp=1;
        }
        <strong>else</strong> {
            s=-s;
            ypdelta=-1;
            yp=-1;
        }
    }
    <i>/* nastaveni pro sklony vetsi nez 45 stupnu */</i>
    <strong>else</strong> {
        s=(double)dx/(double)dy;
        xdelta=0; ydelta=1;
        ypdelta=0;
        yp=0;
        <strong>if</strong> (yy2&gt;yy1) {
            imin=yy1;    imax=yy2;
            x=xx1;       y=yy1;
            xpdelta=1;
            xp=1;
        }
        <strong>else</strong> {
            s=-s;
            imin=yy2;    imax=yy1;
            x=xx2;       y=yy2;
            xpdelta=-1;
            xp=-1;
        }
    }
    <i>/* vlastni vykreslovaci smycka (zde bez optimalizaci!) */</i>
    p=s*256.0;
    <strong>for</strong> (i=imin; i&lt;=imax; i++) {
        <strong>int</strong> c1 = (<strong>int</strong>)e;
        <strong>int</strong> c2 = 255-c1;
        putpixel(x+xp, y+yp, c2, c2, c2, pixels, line_length);
        putpixel(x, y, c1, c1, c1, pixels, line_length);
        e=e-p;
        x+=xdelta;
        y+=ydelta;
        <strong>if</strong> (e&lt;0.0) {
            e+=256.0;
            x+=xpdelta;
            y+=ypdelta;
        }
    }
}
</pre>

<img src="https://i.iinfo.cz/images/241/rpi4-4.png" class="image-237019" alt="&#160;" width="640" height="368" />
<p><i>Obrázek 4: Bližší pohled na výsledek Wuuva algoritmu. Každá úsečka má
šířku dvou pixelů s&nbsp;průběžnou změnou barvy (a průhlednosti).</i></p>


<p><a name="k09"></a></p>
<h2 id="k09">9. Úplný zdrojový kód druhého demonstračního příkladu</h2>

<p>Funkci pro vykreslení úsečky s&nbsp;aplikací antialiasingu přidáme do
demonstračního příkladu, v&nbsp;němž se vykreslí několik téměř vodorovných
úseček. V&nbsp;první polovině framebufferu je použit Bresenhamův algoritmus, ve
druhé polovině pak pomalejší, ale kvalitnější algoritmus vymyšlený Xiaolin
Wuem. Příklad je kvůli zjednodušení upraven takovým způsobem, že pixely mohou
být pouze monochromatické. Výsledek bude vypadat následovně:</p>

<a href="http://www.root.cz/obrazek/237020/"><img src="https://i.iinfo.cz/images/446/rpi4-5-prev.png" class="image-237020" alt="&#160;" width="249" height="270" /></a>
<p><i>Obrázek 5: Screenshot vygenerovaný příkladem rpi_fb12.c.</i></p>

<p>Úplný zdrojový kód příkladu, který po svém spuštění vykreslí několik úseček
bez antialiasingu a s&nbsp;aplikovaným antialiasingem, je možné získat na
adrese <a
href="https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb12.c">https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb12.c</a>.
Navíc je výpis tohoto příkladu zobrazen i pod tímto odstavcem:</p>

<pre>
<i>/* Framebuffer na jednodeskovem mikropocitaci Raspberry Pi */</i>
<i>/* Autor: Pavel Tisnovsky, 2016 */</i>
&nbsp;
<i>/* Demonstracni priklad cislo 12: vykreslovani usecek s antialiasingem. */</i>
<i>/*                                (neoptimalizovana varianta) */</i>
&nbsp;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;linux/fb.h&gt;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Datova struktura, do niz se ulozi informace o framebufferu.</i>
<i> * Blizsi informace o teto strukture je mozne nalezt v hlavickovem souboru</i>
<i> * dostupnem v adresari "/usr/include/linux/fb.h"</i>
<i> */</i>
<strong>typedef</strong> struct fb_var_screeninfo FramebufferInfo;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Druha datova struktura popisujici zbyvajici vlastnosti framebufferu.</i>
<i> * Blizsi informace o teto strukture je mozne nalezt v hlavickovem souboru</i>
<i> * dostupnem v adresari "/usr/include/linux/fb.h"</i>
<i> */</i>
<strong>typedef</strong> struct fb_fix_screeninfo ModeInfo;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Precteni vsech relevantnich informaci zjistenych o framebufferu. Pro korektni</i>
<i> * funkci je zapotrebi, aby mel uzivatel pristup k zarizeni /dev/fb0</i>
<i> * (postacuje byt ve skupine 'video' ci pouziti su/sudo)</i>
<i> */</i>
<strong>int</strong> readFramebufferInfo(<strong>int</strong> framebufferDevice,
                        FramebufferInfo *framebufferInfoPtr,
                        ModeInfo        *modeInfoPtr)
{
    <i>/* Pokud operace ioctl probehne v poradku, vrati se 0 */</i>
    <strong>if</strong> (ioctl(framebufferDevice, FBIOGET_VSCREENINFO, framebufferInfoPtr)) {
        perror("Nelze precist informace o framebufferu");
        <strong>return</strong> 0;
    }
&nbsp;
    <i>/* Pokud operace ioctl probehne v poradku, vrati se 0 */</i>
    <strong>if</strong> (ioctl(framebufferDevice, FBIOGET_FSCREENINFO, modeInfoPtr)) {
        perror("Nelze precist informace o rezimu");
        <strong>return</strong> 0;
    }
    <strong>return</strong> 1;
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce putpixel platna pro nezname graficke rezimy.</i>
<i> */</i>
<strong>void</strong> putpixelNull(<strong>const</strong> <strong>int</strong> x, <strong>const</strong> <strong>int</strong> y,
                 <strong>const</strong> <strong>char</strong> r, <strong>const</strong> <strong>char</strong> g, <strong>const</strong> <strong>char</strong> b,
                 <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length)
{
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce putpixel platna pouze pro graficke rezimy true-color</i>
<i> * s formatem 8-8-8-8 (popr. muze byt alfa kanal ignorovan).</i>
<i> * Funkcni napriklad pro graficke karty <strong>Int</strong>el.</i>
<i> */</i>
<strong>void</strong> putpixelBGRA(<strong>const</strong> <strong>int</strong> x, <strong>const</strong> <strong>int</strong> y,
                 <strong>const</strong> <strong>char</strong> r, <strong>const</strong> <strong>char</strong> g, <strong>const</strong> <strong>char</strong> b,
                 <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length)
{
    <i>/* vypocet adresy zapisu dat */</i>
    <strong>unsigned</strong> <strong>int</strong> index = (x&lt;&lt;2) + y*line_length;
    <i>/* &lt;&lt; 2 nahrazuje nasobeni ctyrmi */</i>
&nbsp;
    <i>/* vlastni provedeni zapisu */</i>
    *(pixels+index) = b;
    index++;
    *(pixels+index) = g;
    index++;
    *(pixels+index) = r;
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce putpixel platna pouze pro graficke rezimy true-color</i>
<i> * s formatem 8-8-8-8 (popr. muze byt alfa kanal ignorovan).</i>
<i> * Funkcni pro Raspberry Pi s poradim bajtu R,G,B,A.</i>
<i> */</i>
<strong>void</strong> putpixelRGBA(<strong>const</strong> <strong>int</strong> x, <strong>const</strong> <strong>int</strong> y,
                 <strong>const</strong> <strong>char</strong> r, <strong>const</strong> <strong>char</strong> g, <strong>const</strong> <strong>char</strong> b,
                 <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length)
{
    putpixelBGRA(x, y, b, g, r, pixels, line_length);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Plati pro format 565</i>
<i> */</i>
#define RED_OFFSET     11
#define GREEN_OFFSET    5
#define BLUE_OFFSET     0
#define RED_LOST_BITS   3
#define GREEN_LOST_BITS 2
#define BLUE_LOST_BITS  3
#define RED_MASK        0x1f <i>/* 0001 1111 */</i>
#define GREEN_MASK      0x3f <i>/* 0011 1111 */</i>
#define BLUE_MASK       0x1f <i>/* 0001 1111 */</i>
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce putpixel platna pouze pro graficke rezimy hi-color</i>
<i> * s formatem 5-6-5.</i>
<i> */</i>
<strong>void</strong> putpixel565(<strong>const</strong> <strong>int</strong> x, <strong>const</strong> <strong>int</strong> y,
                 <strong>const</strong> <strong>char</strong> r, <strong>const</strong> <strong>char</strong> g, <strong>const</strong> <strong>char</strong> b,
                 <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length)
{
    <i>/* vypocet barvy pixelu, v zavorce nejdrive snizime bitovou sirku</i>
    <i> * rezervovanou pro jednotlive barvove slozky a posleze bity, ktere</i>
    <i> * reprezentuji barvovou slozku posuneme do spravne pozice ve slove */</i>
    <strong>unsigned</strong> <strong>int</strong> pixel_value = (r &gt;&gt; RED_LOST_BITS)   &lt;&lt; RED_OFFSET |
                               (g &gt;&gt; GREEN_LOST_BITS) &lt;&lt; GREEN_OFFSET |
                               (b &gt;&gt; BLUE_LOST_BITS)  &lt;&lt; BLUE_OFFSET;
&nbsp;
    <i>/* prevod na dvojici bajtu */</i>
    <strong>unsigned</strong> <strong>char</strong> byte1 = pixel_value &amp; 0xff;
    <strong>unsigned</strong> <strong>char</strong> byte2 = pixel_value &gt;&gt; 8;
&nbsp;
    <i>/* vypocet adresy zapisu dat */</i>
    <strong>unsigned</strong> <strong>int</strong> index = (x&lt;&lt;1) + y*line_length;
    <i>/* &lt;&lt; 1 nahrazuje nasobeni dvema */</i>
&nbsp;
    <i>/* vlastni provedeni zapisu */</i>
    *(pixels+index) = byte1;
    index++;
    *(pixels+index) = byte2;
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Novy datovy typ - ukazatel na (libovolnou) funkci putpixel.</i>
<i> */</i>
<strong>typedef</strong> <strong>void</strong> (*PutpixelFunction)(<strong>const</strong> <strong>int</strong>, <strong>const</strong> <strong>int</strong>,
                                 <strong>const</strong> <strong>char</strong>, <strong>const</strong> <strong>char</strong>, <strong>const</strong> <strong>char</strong>,
                                 <strong>char</strong>*, <strong>const</strong> <strong>int</strong>);
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce, ktera vraci korektni funkci pro operaci putpixel().</i>
<i> */</i>
PutpixelFunction getProperPutpixelFunction(<strong>int</strong> bits_per_pixel, <strong>int</strong> type, <strong>int</strong> visual, <strong>int</strong> redOffset)
{
    <i>/* umime rozeznat pouze format bez bitovych rovin a bez palety */</i>
    <strong>if</strong> (type == FB_TYPE_PACKED_PIXELS &amp;&amp; visual == FB_VISUAL_TRUECOLOR) {
        <i>/* framebuffer s bitovou hloubkou 16bpp */</i>
        <strong>if</strong> (bits_per_pixel == 16) {
            <strong>return</strong> putpixel565;
        }
        <i>/* framebuffery s bitovou hloubkou 32bpp */</i>
        <strong>if</strong> (bits_per_pixel == 32) {
            <i>/* rozlisujeme podle pozice cervene slozky */</i>
            <strong>if</strong> (redOffset == 16) {
                <strong>return</strong> putpixelBGRA;
            }
            <strong>else</strong> {
                <strong>return</strong> putpixelRGBA;
            }
        }
    }
    <strong>return</strong> putpixelNull;
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Nekolik maker pouzitych v algoritmech pro vykreslovani usecek.</i>
<i> */</i>
#define ABS(x) ((x)&lt;0 ? -(x) : (x))
#define MAX(a,b) ((a)&gt;(b) ? (a) : (b))
#define MIN(a,b) ((a)&lt;(b) ? (a) : (b))
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Specialni pripad: vodorovna usecka.</i>
<i> */</i>
<strong>void</strong> horizontalLine(<strong>const</strong> <strong>int</strong> x1, <strong>const</strong> <strong>int</strong> x2, <strong>const</strong> <strong>int</strong> y,
                    <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length, PutpixelFunction putpixel)
{
    <strong>int</strong> x;
    <strong>int</strong> from_x = MIN(x1, x2);
    <strong>int</strong> to_x = MAX(x1, x2);
    <strong>for</strong> (x = from_x; x &lt;= to_x; x++) {
        putpixel(x, y, 0xff, 0xff, 0xff, pixels, line_length);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Specialni pripad: svisla usecka.</i>
<i> */</i>
<strong>void</strong> verticalLine(<strong>const</strong> <strong>int</strong> x, <strong>const</strong> <strong>int</strong> y1, <strong>const</strong> <strong>int</strong> y2,
                  <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length, PutpixelFunction putpixel)
{
    <strong>int</strong> y;
    <strong>int</strong> from_y = MIN(y1, y2);
    <strong>int</strong> to_y = MAX(y1, y2);
    <strong>for</strong> (y = from_y; y &lt;= to_y; y++) {
        putpixel(x, y, 0xff, 0xff, 0xff, pixels, line_length);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce pro vykresleni usecky Bresenhamovym algoritmem.</i>
<i> * (tj. bez antialiasingu)</i>
<i> */</i>
<strong>void</strong> line(<strong>const</strong> <strong>int</strong> x1, <strong>const</strong> <strong>int</strong> y1, <strong>const</strong> <strong>int</strong> x2, <strong>const</strong> <strong>int</strong> y2,
          <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length, PutpixelFunction putpixel)
{
    <i>/* specialni pripad - svisla usecka */</i>
    <strong>if</strong> (x1==x2) {
        verticalLine(x1, y1, y2, pixels, line_length, putpixel);
        <strong>return</strong>;
    }
&nbsp;
    <i>/* specialni pripad - vodorovna usecka */</i>
    <strong>if</strong> (y1==y2) {
        horizontalLine(x1, x2, y1, pixels, line_length, putpixel);
        <strong>return</strong>;
    }
&nbsp;
    <i>/* mame smulu a musime pouzit plnou verzi algoritmu */</i>
&nbsp;
    <i>/* zrcadleni algoritmu pro dalsi oktanty */</i>
    <strong>int</strong> x = x1;
    <strong>int</strong> y = y1;
&nbsp;
    <i>/* konstanty pouzite pri vykreslovani */</i>
    <strong>int</strong> dx = ABS(x2-x1), sx = x1&lt;x2 ? 1 : -1;
    <strong>int</strong> dy = ABS(y2-y1), sy = y1&lt;y2 ? 1 : -1;
    <strong>int</strong> err = (dx&gt;dy ? dx : -dy)/2, e2;
&nbsp;
    <strong>while</strong> (1) {
        putpixel(x, y, 0xff, 0xff, 0xff, pixels, line_length);
        <i>/* test, zda se jiz doslo k poslednimu bodu */</i>
        <strong>if</strong> (x==x2 &amp;&amp; y==y2) {
            <strong>break</strong>;
        }
        e2 = err;
        <strong>if</strong> (e2 &gt;-dx) {
            <i>/* prepocet kumulovane chyby */</i>
            err -= dy;
            <i>/* posun na predchozi ci dalsi pixel na radku */</i>
            x += sx;
        }
        <strong>if</strong> (e2 &lt; dy) {
            <i>/* prepocet kumulovane chyby */</i>
             err += dx;
             <i>/* posun na predchozi ci nasledujici radek */</i>
             y += sy;
        }
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce pro vykresleni usecky s aplikaci antialiasingu.</i>
<i> */</i>
<strong>void</strong> lineAA(<strong>const</strong> <strong>int</strong> x1, <strong>const</strong> <strong>int</strong> y1, <strong>const</strong> <strong>int</strong> x2, <strong>const</strong> <strong>int</strong> y2,
          <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length, PutpixelFunction putpixel)
{
    <i>/* specialni pripad - svisla usecka */</i>
    <strong>if</strong> (x1==x2) {
        verticalLine(x1, y1, y2, pixels, line_length, putpixel);
        <strong>return</strong>;
    }
&nbsp;
    <i>/* specialni pripad - vodorovna usecka */</i>
    <strong>if</strong> (y1==y2) {
        horizontalLine(x1, x2, y1, pixels, line_length, putpixel);
        <strong>return</strong>;
    }
&nbsp;
    <i>/* mame smulu a musime pouzit plnou verzi algoritmu */</i>
&nbsp;
    <i>/* konstanty pouzite pri vykreslovani */</i>
    <strong>int</strong> dx = x2 - x1;
    <strong>int</strong> dy = y2 - y1;
    double s, p, e=255.0;
    <strong>int</strong> x, y, xdelta, ydelta, xpdelta, ypdelta, xp, yp;
    <strong>int</strong> i, imin, imax;
&nbsp;
    <i>/* pomocne promenne - pocatecni a koncove body */</i>
    <strong>int</strong> xx1 = x1 &lt; x2 ? x1 : x2;
    <strong>int</strong> xx2 = x1 &lt; x2 ? x2 : x1;
    <strong>int</strong> yy1 = x1 &lt; x2 ? y1 : y2;
    <strong>int</strong> yy2 = x1 &lt; x2 ? y2 : y1;
&nbsp;
    <i>/* nastaveni pro sklony mensi nez 45 stupnu */</i>
    <strong>if</strong> (ABS(dx) &gt; ABS(dy)) {
        s=(double)dy/(double)dx;
        imin=xx1;  imax=xx2;
        x=xx1;     y=yy1;
        xdelta=1;  ydelta=0;
        xpdelta=0;
        xp=0;
        <strong>if</strong> (yy2&gt;yy1) {
            ypdelta=1;
            yp=1;
        }
        <strong>else</strong> {
            s=-s;
            ypdelta=-1;
            yp=-1;
        }
    }
    <i>/* nastaveni pro sklony vetsi nez 45 stupnu */</i>
    <strong>else</strong> {
        s=(double)dx/(double)dy;
        xdelta=0; ydelta=1;
        ypdelta=0;
        yp=0;
        <strong>if</strong> (yy2&gt;yy1) {
            imin=yy1;    imax=yy2;
            x=xx1;       y=yy1;
            xpdelta=1;
            xp=1;
        }
        <strong>else</strong> {
            s=-s;
            imin=yy2;    imax=yy1;
            x=xx2;       y=yy2;
            xpdelta=-1;
            xp=-1;
        }
    }
    <i>/* vlastni vykreslovaci smycka (zde bez optimalizaci!) */</i>
    p=s*256.0;
    <strong>for</strong> (i=imin; i&lt;=imax; i++) {
        <strong>int</strong> c1 = (<strong>int</strong>)e;
        <strong>int</strong> c2 = 255-c1;
        putpixel(x+xp, y+yp, c2, c2, c2, pixels, line_length);
        putpixel(x, y, c1, c1, c1, pixels, line_length);
        e=e-p;
        x+=xdelta;
        y+=ydelta;
        <strong>if</strong> (e&lt;0.0) {
            e+=256.0;
            x+=xpdelta;
            y+=ypdelta;
        }
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ulozeni obsahu framebufferu do souboru s rastrovym obrazkem.</i>
<i> */</i>
<strong>void</strong> saveFramebuffer(<strong>const</strong> <strong>char</strong> *filename, FramebufferInfo *framebufferInfoPtr, <strong>char</strong> *pixels)
{
    <strong>const</strong> <strong>int</strong> bpp = framebufferInfoPtr-&gt;bits_per_pixel;
    <strong>const</strong> <strong>int</strong> xres = framebufferInfoPtr-&gt;xres;
    <strong>const</strong> <strong>int</strong> yres = framebufferInfoPtr-&gt;yres;
&nbsp;
    FILE *fout = fopen(filename, "wb");
    <strong>int</strong> i;
    <strong>char</strong> *adr=pixels;
&nbsp;
    <strong>if</strong> (!fout) {
        perror("Unable to open output file");
        <strong>return</strong>;
    }
&nbsp;
    <i>/* hlavicka souboru s rastrovym obrazkem */</i>
    fpr<strong>int</strong>f(fout, "P6\n");
    fpr<strong>int</strong>f(fout, "%d\n%d\n255\n", xres, yres);
&nbsp;
    <strong>switch</strong> (bpp) {
        <strong>case</strong> 16: <i>/* 16bitova barvova hloubka, predpokladejme format 565 */</i>
            <strong>for</strong> (i=0; i&lt;xres*yres; i++) {
                <i>/* nejprve se prectou dva bajty z framebufferu */</i>
                <strong>unsigned</strong> <strong>char</strong> b1 = *(adr+1);
                <strong>unsigned</strong> <strong>char</strong> b2 = *(adr);
                <i>/* posleze se prevedou na 16bitove slovo */</i>
                <strong>unsigned</strong> <strong>int</strong>  color = (b1 &lt;&lt; 8) + b2;
                <i>/* a zase ziskame zpetnym prevodem hodnoty barvovych slozek */</i>
                <strong>unsigned</strong> <strong>char</strong> r = ((color &gt;&gt; RED_OFFSET)   &amp; RED_MASK)   &lt;&lt; RED_LOST_BITS;
                <strong>unsigned</strong> <strong>char</strong> g = ((color &gt;&gt; GREEN_OFFSET) &amp; GREEN_MASK) &lt;&lt; GREEN_LOST_BITS;
                <strong>unsigned</strong> <strong>char</strong> b = ((color &gt;&gt; BLUE_OFFSET)  &amp; BLUE_MASK)  &lt;&lt; BLUE_LOST_BITS;
                <i>/* zapis barvovych slozek */</i>
                putc(r, fout);
                putc(g, fout);
                putc(b, fout);
                adr+=2; <i>/* posun na dalsi pixel ve framebufferu */</i>
            }
            <strong>break</strong>;
        <strong>case</strong> 24: <i>/* 24bitova barvova hloubka - lze nahradit jedinym zapisem, pokud nebudete prehazovat barvy! */</i>
            <strong>for</strong> (i=0; i&lt;xres*yres; i++) {
                fwrite(adr+2, 1, 1, fout);
                fwrite(adr+1, 1, 1, fout);
                fwrite(adr+0, 1, 1, fout);
                adr+=3; <i>/* posun na dalsi pixel ve framebufferu */</i>
            }
            <strong>break</strong>;
        <strong>case</strong> 32: <i>/* 32bitova barvova hloubka */</i>
            <strong>for</strong> (i=0; i&lt;xres*yres; i++) {
                fwrite(adr+2, 1, 1, fout);
                fwrite(adr+1, 1, 1, fout);
                fwrite(adr+0, 1, 1, fout);
                adr+=4; <i>/* posledni bajt se busi preskocit, neuklada se */</i>
            }
            <strong>break</strong>;
    }
    fclose(fout);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vykresleni testovaciho obrazku s vyuzitim funkci line a putpixel.</i>
<i> */</i>
<strong>void</strong> drawTestImage(<strong>int</strong> framebufferDevice,
                   FramebufferInfo *framebufferInfoPtr,
                   ModeInfo        *modeInfoPtr)
{
#define OFFSET 300
    <i>/* casto pouzivane konstanty */</i>
    <strong>const</strong> <strong>int</strong> buffer_length = modeInfoPtr-&gt;smem_len;
    <strong>const</strong> <strong>int</strong> pitch = modeInfoPtr-&gt;line_length;
&nbsp;
    <i>/* ziskame spravnou verzi funkce putpixel */</i>
    PutpixelFunction putpixel = getProperPutpixelFunction(framebufferInfoPtr-&gt;bits_per_pixel,
                                                          modeInfoPtr-&gt;type,
                                                          modeInfoPtr-&gt;visual,
                                                          framebufferInfoPtr-&gt;red.offset);
&nbsp;
    <i>/* ziskat primy pristup do framebufferu */</i>
    <strong>char</strong> *pixels = (<strong>char</strong>*)mmap(0, buffer_length,
                               PROT_READ | PROT_WRITE,
                               MAP_SHARED, framebufferDevice,
                               0);
&nbsp;
    <strong>if</strong> (pixels != MAP_FAILED) {
        <strong>int</strong> i;
        <i>/* nejprve vymazeme cely framebuffer */</i>
        memset(pixels, 0, buffer_length);
&nbsp;
        <i>/* vykreslime nekolik usecek s ruznym sklonem (vzdy bude mit jeden "schod") */</i>
        <strong>for</strong> (i=0; i&lt;=350; i+=10) {
            <i>/* bez antialiasingu */</i>
            line(0, i, i*2, i+1, pixels, pitch, putpixel);
            <i>/* s antialiasingem */</i>
            lineAA(0, 400+i, i*2, 400+1+i, pixels, pitch, putpixel);
        }
        <i>/* ulozeni framebufferu */</i>
        saveFramebuffer("rpi_fb12.ppm", framebufferInfoPtr, pixels);
        <i>/* cekani na stisk klavesy */</i>
        getchar();
        munmap(pixels, buffer_length);
    }
    <strong>else</strong> {
        perror("Nelze pristupovat k framebufferu");
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/* Vstupni bod do demonstracniho prikladu... :) */</i>
<strong>int</strong> main(<strong>int</strong> argc, <strong>char</strong> **argv)
{
    FramebufferInfo framebufferInfo;
    ModeInfo        modeInfo;
    <strong>int</strong> framebufferDevice = 0;
&nbsp;
    <i>/* Ze zarizeni potrebujeme cist i zapisovat.*/</i>
    framebufferDevice = open("/dev/fb0", O_RDWR);
&nbsp;
    /* Pokud otevreni probehlo uspesne, nacteme
     * a nasledne vypiseme informaci o framebufferu.*/
    <strong>if</strong> (framebufferDevice != -1) {
        <i>/* Precteni informaci o framebufferu a test, zda se vse podarilo */</i>
        <strong>if</strong> (readFramebufferInfo(framebufferDevice, &amp;framebufferInfo, &amp;modeInfo)) {
            drawTestImage(framebufferDevice, &amp;framebufferInfo, &amp;modeInfo);
        }
        close(framebufferDevice);
        <strong>return</strong> 0;
    }
    <i>/* Otevreni se nezadarilo, vypiseme tudiz pouze chybove hlaseni.*/</i>
    <strong>else</strong> {
        perror("Nelze otevrit ovladac /dev/fb0");
        <strong>return</strong> 1;
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/* finito */</i>
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Třešnička na závěr: non-photorealistic rendering</h2>

<p>Ve chvíli, kdy již umíme vykreslovat úsečky s&nbsp;vyhlazenými hranami, je
možné se přesunout dále, například do oblasti takzvaných NPR
(Non-Photorealistic Rendering) algoritmů. Dnes si ukážeme pouze jediný
algoritmus, který jsem již popsal v&nbsp;článcích <a
href="http://www.root.cz/clanky/metoda-presouvani-prostredniho-bodu-a-obrazky-plasmy/">Metoda
přesouvání prostředního bodu a obrázky plasmy</a> a <a
href="http://www.root.cz/clanky/trojrozmerne-modely-terenu/">Trojrozměrné
modely terénu </a>. Jedná se tzv.&nbsp;midpoint algoritmus, který se vhodně
nastavenými parametry dokáže napodobit roztřesené čáry kreslené rukou. Použití
může být rozmanité, od pseudo architektonických 3D výkresů až po alternativněji
pojaté počítačové hry. Algoritmus je vlastně velmi jednoduchý a pracuje
rekurzivně:</p>

<ol>
<li>Vstupem jsou dva koncové body úsečky.</li>
<li>Vypočte se prostřední bod na úsečce (midpoint).</li>
<li>Vypočte se normálový vektor v&nbsp;tomto bodě.</li>
<li>Bod se posune ve směru (či proti směru) normálového vektoru o náhodnou hodnotu.</li>
<li>Rekurzivní volání pro první koncový bod o posunutý midpoint.</li>
<li>Rekurzivní volání pro druhý koncový bod o posunutý midpoint.</li>
<li>Ve chvíli, kdy je vzdálenost bodů menší, než určitá konstanta, se vykreslí úsečka.</li>
</ol>

<img src="https://i.iinfo.cz/images/484/rpi4-6.png" class="image-237021" alt="&#160;" width="551" height="608" />
<p><i>Obrázek 6: Několik úseček vygenerovaných algoritmem popsaným v&nbsp;této
kapitole.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Úplný zdrojový kód třetího demonstračního příkladu</h2>

<p>Podívejme se nyní na úplný zdrojový kód dnešního třetího demonstračního
příkladu. Pro korektní slinkování výsledného spustitelného souboru je nutné
použít volbu <strong>-lm</strong>, která zajistí přidání matematických funkcí
použitých jak pro vytváření obrazců, tak i pro normalizaci vektorů. Zdrojový
kód tohoto demonstračního příkladu je dostupný na adrese <a
href="https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb13.c">https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb13.c</a>:</p>

<pre>
<i>/* Framebuffer na jednodeskovem mikropocitaci Raspberry Pi */</i>
<i>/* Autor: Pavel Tisnovsky, 2016 */</i>
&nbsp;
<i>/* Demonstracni priklad cislo 13: non photorealistic rendering. */</i>
&nbsp;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;linux/fb.h&gt;
#include &lt;math.h&gt;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Datova struktura, do niz se ulozi informace o framebufferu.</i>
<i> * Blizsi informace o teto strukture je mozne nalezt v hlavickovem souboru</i>
<i> * dostupnem v adresari "/usr/include/linux/fb.h"</i>
<i> */</i>
<strong>typedef</strong> struct fb_var_screeninfo FramebufferInfo;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Druha datova struktura popisujici zbyvajici vlastnosti framebufferu.</i>
<i> * Blizsi informace o teto strukture je mozne nalezt v hlavickovem souboru</i>
<i> * dostupnem v adresari "/usr/include/linux/fb.h"</i>
<i> */</i>
<strong>typedef</strong> struct fb_fix_screeninfo ModeInfo;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Precteni vsech relevantnich informaci zjistenych o framebufferu. Pro korektni</i>
<i> * funkci je zapotrebi, aby mel uzivatel pristup k zarizeni /dev/fb0</i>
<i> * (postacuje byt ve skupine 'video' ci pouziti su/sudo)</i>
<i> */</i>
<strong>int</strong> readFramebufferInfo(<strong>int</strong> framebufferDevice,
                        FramebufferInfo *framebufferInfoPtr,
                        ModeInfo        *modeInfoPtr)
{
    <i>/* Pokud operace ioctl probehne v poradku, vrati se 0 */</i>
    <strong>if</strong> (ioctl(framebufferDevice, FBIOGET_VSCREENINFO, framebufferInfoPtr)) {
        perror("Nelze precist informace o framebufferu");
        <strong>return</strong> 0;
    }
&nbsp;
    <i>/* Pokud operace ioctl probehne v poradku, vrati se 0 */</i>
    <strong>if</strong> (ioctl(framebufferDevice, FBIOGET_FSCREENINFO, modeInfoPtr)) {
        perror("Nelze precist informace o rezimu");
        <strong>return</strong> 0;
    }
    <strong>return</strong> 1;
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce putpixel platna pro nezname graficke rezimy.</i>
<i> */</i>
<strong>void</strong> putpixelNull(<strong>const</strong> <strong>int</strong> x, <strong>const</strong> <strong>int</strong> y,
                 <strong>const</strong> <strong>char</strong> r, <strong>const</strong> <strong>char</strong> g, <strong>const</strong> <strong>char</strong> b,
                 <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length)
{
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce putpixel platna pouze pro graficke rezimy true-color</i>
<i> * s formatem 8-8-8-8 (popr. muze byt alfa kanal ignorovan).</i>
<i> * Funkcni napriklad pro graficke karty <strong>Int</strong>el.</i>
<i> */</i>
<strong>void</strong> putpixelBGRA(<strong>const</strong> <strong>int</strong> x, <strong>const</strong> <strong>int</strong> y,
                 <strong>const</strong> <strong>char</strong> r, <strong>const</strong> <strong>char</strong> g, <strong>const</strong> <strong>char</strong> b,
                 <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length)
{
    <i>/* vypocet adresy zapisu dat */</i>
    <strong>unsigned</strong> <strong>int</strong> index = (x&lt;&lt;2) + y*line_length;
    <i>/* &lt;&lt; 2 nahrazuje nasobeni ctyrmi */</i>
&nbsp;
    <i>/* vlastni provedeni zapisu */</i>
    *(pixels+index) = b;
    index++;
    *(pixels+index) = g;
    index++;
    *(pixels+index) = r;
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce putpixel platna pouze pro graficke rezimy true-color</i>
<i> * s formatem 8-8-8-8 (popr. muze byt alfa kanal ignorovan).</i>
<i> * Funkcni pro Raspberry Pi s poradim bajtu R,G,B,A.</i>
<i> */</i>
<strong>void</strong> putpixelRGBA(<strong>const</strong> <strong>int</strong> x, <strong>const</strong> <strong>int</strong> y,
                 <strong>const</strong> <strong>char</strong> r, <strong>const</strong> <strong>char</strong> g, <strong>const</strong> <strong>char</strong> b,
                 <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length)
{
    putpixelBGRA(x, y, b, g, r, pixels, line_length);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Plati pro format 565</i>
<i> */</i>
#define RED_OFFSET     11
#define GREEN_OFFSET    5
#define BLUE_OFFSET     0
#define RED_LOST_BITS   3
#define GREEN_LOST_BITS 2
#define BLUE_LOST_BITS  3
#define RED_MASK        0x1f <i>/* 0001 1111 */</i>
#define GREEN_MASK      0x3f <i>/* 0011 1111 */</i>
#define BLUE_MASK       0x1f <i>/* 0001 1111 */</i>
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce putpixel platna pouze pro graficke rezimy hi-color</i>
<i> * s formatem 5-6-5.</i>
<i> */</i>
<strong>void</strong> putpixel565(<strong>const</strong> <strong>int</strong> x, <strong>const</strong> <strong>int</strong> y,
                 <strong>const</strong> <strong>char</strong> r, <strong>const</strong> <strong>char</strong> g, <strong>const</strong> <strong>char</strong> b,
                 <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length)
{
    <i>/* vypocet barvy pixelu, v zavorce nejdrive snizime bitovou sirku</i>
    <i> * rezervovanou pro jednotlive barvove slozky a posleze bity, ktere</i>
    <i> * reprezentuji barvovou slozku posuneme do spravne pozice ve slove */</i>
    <strong>unsigned</strong> <strong>int</strong> pixel_value = (r &gt;&gt; RED_LOST_BITS)   &lt;&lt; RED_OFFSET |
                               (g &gt;&gt; GREEN_LOST_BITS) &lt;&lt; GREEN_OFFSET |
                               (b &gt;&gt; BLUE_LOST_BITS)  &lt;&lt; BLUE_OFFSET;
&nbsp;
    <i>/* prevod na dvojici bajtu */</i>
    <strong>unsigned</strong> <strong>char</strong> byte1 = pixel_value &amp; 0xff;
    <strong>unsigned</strong> <strong>char</strong> byte2 = pixel_value &gt;&gt; 8;
&nbsp;
    <i>/* vypocet adresy zapisu dat */</i>
    <strong>unsigned</strong> <strong>int</strong> index = (x&lt;&lt;1) + y*line_length;
    <i>/* &lt;&lt; 1 nahrazuje nasobeni dvema */</i>
&nbsp;
    <i>/* vlastni provedeni zapisu */</i>
    *(pixels+index) = byte1;
    index++;
    *(pixels+index) = byte2;
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Novy datovy typ - ukazatel na (libovolnou) funkci putpixel.</i>
<i> */</i>
<strong>typedef</strong> <strong>void</strong> (*PutpixelFunction)(<strong>const</strong> <strong>int</strong>, <strong>const</strong> <strong>int</strong>,
                                 <strong>const</strong> <strong>char</strong>, <strong>const</strong> <strong>char</strong>, <strong>const</strong> <strong>char</strong>,
                                 <strong>char</strong>*, <strong>const</strong> <strong>int</strong>);
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce, ktera vraci korektni funkci pro operaci putpixel().</i>
<i> */</i>
PutpixelFunction getProperPutpixelFunction(<strong>int</strong> bits_per_pixel, <strong>int</strong> type, <strong>int</strong> visual, <strong>int</strong> redOffset)
{
    <i>/* umime rozeznat pouze format bez bitovych rovin a bez palety */</i>
    <strong>if</strong> (type == FB_TYPE_PACKED_PIXELS &amp;&amp; visual == FB_VISUAL_TRUECOLOR) {
        <i>/* framebuffer s bitovou hloubkou 16bpp */</i>
        <strong>if</strong> (bits_per_pixel == 16) {
            <strong>return</strong> putpixel565;
        }
        <i>/* framebuffery s bitovou hloubkou 32bpp */</i>
        <strong>if</strong> (bits_per_pixel == 32) {
            <i>/* rozlisujeme podle pozice cervene slozky */</i>
            <strong>if</strong> (redOffset == 16) {
                <strong>return</strong> putpixelBGRA;
            }
            <strong>else</strong> {
                <strong>return</strong> putpixelRGBA;
            }
        }
    }
    <strong>return</strong> putpixelNull;
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Nekolik maker pouzitych v algoritmech pro vykreslovani usecek.</i>
<i> */</i>
#define ABS(x) ((x)&lt;0 ? -(x) : (x))
#define MAX(a,b) ((a)&gt;(b) ? (a) : (b))
#define MIN(a,b) ((a)&lt;(b) ? (a) : (b))
&nbsp;
&nbsp;
&nbsp;
<i>/* Definice pro ANSI C */</i>
#<strong>if</strong>ndef M_PI
#define M_PI 3.14159265358979323846
#end<strong>if</strong>
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Specialni pripad: vodorovna usecka.</i>
<i> */</i>
<strong>void</strong> horizontalLine(<strong>const</strong> <strong>int</strong> x1, <strong>const</strong> <strong>int</strong> x2, <strong>const</strong> <strong>int</strong> y,
                    <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length, PutpixelFunction putpixel)
{
    <strong>int</strong> x;
    <strong>int</strong> from_x = MIN(x1, x2);
    <strong>int</strong> to_x = MAX(x1, x2);
    for (x = from_x; x &lt;= to_x; x++) {
        putpixel(x, y, 0xff, 0xff, 0xff, pixels, line_length);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Specialni pripad: svisla usecka.</i>
<i> */</i>
<strong>void</strong> verticalLine(<strong>const</strong> <strong>int</strong> x, <strong>const</strong> <strong>int</strong> y1, <strong>const</strong> <strong>int</strong> y2,
                  <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length, PutpixelFunction putpixel)
{
    <strong>int</strong> y;
    <strong>int</strong> from_y = MIN(y1, y2);
    <strong>int</strong> to_y = MAX(y1, y2);
    for (y = from_y; y &lt;= to_y; y++) {
        putpixel(x, y, 0xff, 0xff, 0xff, pixels, line_length);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce pro vykresleni usecky s aplikaci antialiasingu.</i>
<i> */</i>
<strong>void</strong> lineAA(<strong>const</strong> <strong>int</strong> x1, <strong>const</strong> <strong>int</strong> y1, <strong>const</strong> <strong>int</strong> x2, <strong>const</strong> <strong>int</strong> y2,
          <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length, PutpixelFunction putpixel)
{
    <i>/* specialni pripad - svisla usecka */</i>
    <strong>if</strong> (x1==x2) {
        verticalLine(x1, y1, y2, pixels, line_length, putpixel);
        <strong>return</strong>;
    }
&nbsp;
    <i>/* specialni pripad - vodorovna usecka */</i>
    <strong>if</strong> (y1==y2) {
        horizontalLine(x1, x2, y1, pixels, line_length, putpixel);
        <strong>return</strong>;
    }
&nbsp;
    <i>/* mame smulu a musime pouzit plnou verzi algoritmu */</i>
&nbsp;
    <i>/* konstanty pouzite pri vykreslovani */</i>
    <strong>int</strong> dx = x2 - x1;
    <strong>int</strong> dy = y2 - y1;
    double s, p, e=255.0;
    <strong>int</strong> x, y, xdelta, ydelta, xpdelta, ypdelta, xp, yp;
    <strong>int</strong> i, imin, imax;
&nbsp;
    <i>/* pomocne promenne - pocatecni a koncove body */</i>
    <strong>int</strong> xx1 = x1 &lt; x2 ? x1 : x2;
    <strong>int</strong> xx2 = x1 &lt; x2 ? x2 : x1;
    <strong>int</strong> yy1 = x1 &lt; x2 ? y1 : y2;
    <strong>int</strong> yy2 = x1 &lt; x2 ? y2 : y1;
&nbsp;
    <i>/* nastaveni pro sklony mensi nez 45 stupnu */</i>
    <strong>if</strong> (ABS(dx) &gt; ABS(dy)) {
        s=(double)dy/(double)dx;
        imin=xx1;  imax=xx2;
        x=xx1;     y=yy1;
        xdelta=1;  ydelta=0;
        xpdelta=0;
        xp=0;
        <strong>if</strong> (yy2&gt;yy1) {
            ypdelta=1;
            yp=1;
        }
        <strong>else</strong> {
            s=-s;
            ypdelta=-1;
            yp=-1;
        }
    }
    <i>/* nastaveni pro sklony vetsi nez 45 stupnu */</i>
    <strong>else</strong> {
        s=(double)dx/(double)dy;
        xdelta=0; ydelta=1;
        ypdelta=0;
        yp=0;
        <strong>if</strong> (yy2&gt;yy1) {
            imin=yy1;    imax=yy2;
            x=xx1;       y=yy1;
            xpdelta=1;
            xp=1;
        }
        <strong>else</strong> {
            s=-s;
            imin=yy2;    imax=yy1;
            x=xx2;       y=yy2;
            xpdelta=-1;
            xp=-1;
        }
    }
    <i>/* vlastni vykreslovaci smycka (zde bez optimalizaci!) */</i>
    p=s*256.0;
    for (i=imin; i&lt;=imax; i++) {
        <strong>int</strong> c1 = (<strong>int</strong>)e;
        <strong>int</strong> c2 = 255-c1;
        putpixel(x+xp, y+yp, c2, c2, c2, pixels, line_length);
        putpixel(x, y, c1, c1, c1, pixels, line_length);
        e=e-p;
        x+=xdelta;
        y+=ydelta;
        <strong>if</strong> (e&lt;0.0) {
            e+=256.0;
            x+=xpdelta;
            y+=ypdelta;
        }
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Zvlnena usecka (rekurzivne volana funkce)</i>
<i> */</i>
<strong>void</strong> npr_line(<strong>int</strong> x1, <strong>int</strong> y1, <strong>int</strong> x2, <strong>int</strong> y2, double maxd, <strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length, PutpixelFunction putpixel)
{
    <strong>int</strong> dist = ABS(x2-x1) + ABS(y2-y1);
    <i>/* kratka vzdalenost se jiz nakresli jako normalni usecka */</i>
    <strong>if</strong> (dist &lt; 30) {
        lineAA(x1, y1, x2, y2, pixels, line_length, putpixel);
    }
    <strong>else</strong>
    {
        <strong>int</strong> midx, midy;
        double nx, ny;
        double d;
        double nd;
&nbsp;
        <i>/* vypocet presneho stredu mezi dvema body */</i>
        midx = (x1 + x2) &gt;&gt; 1;
        midy = (y1 + y2) &gt;&gt; 1;
&nbsp;
        <i>/* prvky normaloveho vektoru */</i>
        nx = (y1 - y2);
        ny = (x2 - x1);
&nbsp;
        <i>/* normalizace */</i>
        nd = sqrt(nx*nx + ny*ny);
        nx /= nd;
        ny /= nd;
&nbsp;
        <i>/* posun prostredniho bodu po normale */</i>
        d = maxd * (((float)rand()/RAND_MAX) - 0.5);
        midx += nx * d;
        midy += ny * d;
&nbsp;
        <i>/* rekurzivni vykresleni prvni a druhe casti */</i>
        npr_line(x1, y1, midx, midy, maxd/1.8, pixels, line_length, putpixel);
        npr_line(midx, midy, x2, y2, maxd/1.8, pixels, line_length, putpixel);
    }
}
&nbsp;
&nbsp;
&nbsp;
<strong>void</strong> draw_square(<strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length, PutpixelFunction putpixel)
{
    npr_line(20, 20, 200, 20, 10, pixels, line_length, putpixel);
    npr_line(200, 20, 200, 200, 10, pixels, line_length, putpixel);
    npr_line(20, 200, 200, 200, 10, pixels, line_length, putpixel);
    npr_line(20, 200, 20, 20, 10, pixels, line_length, putpixel);
}
&nbsp;
&nbsp;
&nbsp;
<strong>void</strong> draw_diamond(<strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length, PutpixelFunction putpixel)
{
#define W 80
    npr_line(100 - W, 360,     100,     360 - W, 10, pixels, line_length, putpixel);
    npr_line(100,     360 - W, 100 + W, 360,     10, pixels, line_length, putpixel);
    npr_line(100 + W, 360,     100,     360 + W, 10, pixels, line_length, putpixel);
    npr_line(100,     360 + W, 100 - W, 360,     10, pixels, line_length, putpixel);
#undef W
}
&nbsp;
&nbsp;
&nbsp;
<strong>void</strong> draw_star(<strong>char</strong> *pixels, <strong>const</strong> <strong>int</strong> line_length, PutpixelFunction putpixel)
{
#define STEP 5
    <strong>int</strong> i;
    float x1, y1, x2, y2;
    for (i=0; i&lt;360; i+=360/STEP)
    {
        x1 = 200.0*cos(i*M_PI/180.0);
        y1 = 200.0*sin(i*M_PI/180.0);
        x2 = 200.0*cos((i+3*360/STEP)*M_PI/180.0);
        y2 = 200.0*sin((i+3*360/STEP)*M_PI/180.0);
        npr_line(400+x1, 320+y1, 400+x2, 320+y2, 10, pixels, line_length, putpixel);
    }
#undef STEP
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ulozeni obsahu framebufferu do souboru s rastrovym obrazkem.</i>
<i> */</i>
<strong>void</strong> saveFramebuffer(<strong>const</strong> <strong>char</strong> *filename, FramebufferInfo *framebufferInfoPtr, <strong>char</strong> *pixels)
{
    <strong>const</strong> <strong>int</strong> bpp = framebufferInfoPtr-&gt;bits_per_pixel;
    <strong>const</strong> <strong>int</strong> xres = framebufferInfoPtr-&gt;xres;
    <strong>const</strong> <strong>int</strong> yres = framebufferInfoPtr-&gt;yres;
&nbsp;
    FILE *fout = fopen(filename, "wb");
    <strong>int</strong> i;
    <strong>char</strong> *adr=pixels;
&nbsp;
    <strong>if</strong> (!fout) {
        perror("Unable to open output file");
        <strong>return</strong>;
    }
&nbsp;
    <i>/* hlavicka souboru s rastrovym obrazkem */</i>
    fpr<strong>int</strong>f(fout, "P6\n");
    fpr<strong>int</strong>f(fout, "%d\n%d\n255\n", xres, yres);
&nbsp;
    <strong>switch</strong> (bpp) {
        <strong>case</strong> 16: <i>/* 16bitova barvova hloubka, predpokladejme format 565 */</i>
            for (i=0; i&lt;xres*yres; i++) {
                <i>/* nejprve se prectou dva bajty z framebufferu */</i>
                <strong>unsigned</strong> <strong>char</strong> b1 = *(adr+1);
                <strong>unsigned</strong> <strong>char</strong> b2 = *(adr);
                <i>/* posleze se prevedou na 16bitove slovo */</i>
                <strong>unsigned</strong> <strong>int</strong>  color = (b1 &lt;&lt; 8) + b2;
                <i>/* a zase ziskame zpetnym prevodem hodnoty barvovych slozek */</i>
                <strong>unsigned</strong> <strong>char</strong> r = ((color &gt;&gt; RED_OFFSET)   &amp; RED_MASK)   &lt;&lt; RED_LOST_BITS;
                <strong>unsigned</strong> <strong>char</strong> g = ((color &gt;&gt; GREEN_OFFSET) &amp; GREEN_MASK) &lt;&lt; GREEN_LOST_BITS;
                <strong>unsigned</strong> <strong>char</strong> b = ((color &gt;&gt; BLUE_OFFSET)  &amp; BLUE_MASK)  &lt;&lt; BLUE_LOST_BITS;
                <i>/* zapis barvovych slozek */</i>
                putc(r, fout);
                putc(g, fout);
                putc(b, fout);
                adr+=2; <i>/* posun na dalsi pixel ve framebufferu */</i>
            }
            <strong>break</strong>;
        <strong>case</strong> 24: <i>/* 24bitova barvova hloubka - lze nahradit jedinym zapisem, pokud nebudete prehazovat barvy! */</i>
            for (i=0; i&lt;xres*yres; i++) {
                fwrite(adr+2, 1, 1, fout);
                fwrite(adr+1, 1, 1, fout);
                fwrite(adr+0, 1, 1, fout);
                adr+=3; <i>/* posun na dalsi pixel ve framebufferu */</i>
            }
            <strong>break</strong>;
        <strong>case</strong> 32: <i>/* 32bitova barvova hloubka */</i>
            for (i=0; i&lt;xres*yres; i++) {
                fwrite(adr+2, 1, 1, fout);
                fwrite(adr+1, 1, 1, fout);
                fwrite(adr+0, 1, 1, fout);
                adr+=4; <i>/* posledni bajt se busi preskocit, neuklada se */</i>
            }
            <strong>break</strong>;
    }
    fclose(fout);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vykresleni testovaciho obrazku s vyuzitim funkci line a putpixel.</i>
<i> */</i>
<strong>void</strong> drawTestImage(<strong>int</strong> framebufferDevice,
                   FramebufferInfo *framebufferInfoPtr,
                   ModeInfo        *modeInfoPtr)
{
#define OFFSET 300
    <i>/* casto pouzivane konstanty */</i>
    <strong>const</strong> <strong>int</strong> buffer_length = modeInfoPtr-&gt;smem_len;
    <strong>const</strong> <strong>int</strong> pitch = modeInfoPtr-&gt;line_length;
&nbsp;
    <i>/* ziskame spravnou verzi funkce putpixel */</i>
    PutpixelFunction putpixel = getProperPutpixelFunction(framebufferInfoPtr-&gt;bits_per_pixel,
                                                          modeInfoPtr-&gt;type,
                                                          modeInfoPtr-&gt;visual,
                                                          framebufferInfoPtr-&gt;red.offset);
&nbsp;
    <i>/* ziskat primy pristup do framebufferu */</i>
    <strong>char</strong> *pixels = (<strong>char</strong>*)mmap(0, buffer_length,
                               PROT_READ | PROT_WRITE,
                               MAP_SHARED, framebufferDevice,
                               0);
&nbsp;
    <strong>if</strong> (pixels != MAP_FAILED) {
        <strong>int</strong> i;
        <i>/* nejprve vymazeme cely framebuffer */</i>
        memset(pixels, 0, buffer_length);
        <i>/* vykreslime nekolik obrazcu */</i>
        draw_square(pixels, pitch, putpixel);
        draw_diamond(pixels, pitch, putpixel);
        draw_star(pixels, pitch, putpixel);
        for (i=0; i&lt;500; i+=40) {
            npr_line(650+i, 0, 650+i, 600, i/6.0, pixels, pitch, putpixel);
        }
        <i>/* ulozeni framebufferu */</i>
        saveFramebuffer("rpi_fb13.ppm", framebufferInfoPtr, pixels);
        <i>/* cekani na stisk klavesy */</i>
        getchar();
        munmap(pixels, buffer_length);
    }
    <strong>else</strong> {
        perror("Nelze pristupovat k framebufferu");
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/* Vstupni bod do demonstracniho prikladu... :) */</i>
<strong>int</strong> main(<strong>int</strong> argc, <strong>char</strong> **argv)
{
    FramebufferInfo framebufferInfo;
    ModeInfo        modeInfo;
    <strong>int</strong> framebufferDevice = 0;
&nbsp;
    <i>/* Ze zarizeni potrebujeme cist i zapisovat.*/</i>
    framebufferDevice = open("/dev/fb0", O_RDWR);
&nbsp;
    /* Pokud otevreni probehlo uspesne, nacteme
     * a nasledne vypiseme informaci o framebufferu.*/
    <strong>if</strong> (framebufferDevice != -1) {
        <i>/* Precteni informaci o framebufferu a test, zda se vse podarilo */</i>
        <strong>if</strong> (readFramebufferInfo(framebufferDevice, &amp;framebufferInfo, &amp;modeInfo)) {
            drawTestImage(framebufferDevice, &amp;framebufferInfo, &amp;modeInfo);
        }
        close(framebufferDevice);
        <strong>return</strong> 0;
    }
    <i>/* Otevreni se nezadarilo, vypiseme tudiz pouze chybove hlaseni.*/</i>
    <strong>else</strong> {
        perror("Nelze otevrit ovladac /dev/fb0");
        <strong>return</strong> 1;
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/* finito */</i>
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Pokračování? GLES</h2>

<p>S&nbsp;využitím přímého přístupu k&nbsp;barvám pixelů uložených ve
framebufferu je možné realizovat prakticky všechny &bdquo;klasické&ldquo;
grafické efekty, které jsou známé ze starších dem, konkrétně z&nbsp;dem
vzniklých ještě před nástupem grafických akcelerátorů (nepatrně složitější je
implementace efektů s&nbsp;barvovou paletou, i to lze však realizovat). My se
však příště začneme zabývat odlišnou oblastí, která je však v&nbsp;kontextu
využití jednodeskového mikropočítače Raspberry Pi neméně důležitá
(pravděpodobně i důležitější). Jedná se o volání funkcí knihovny <i>GLES</i>
(resp.&nbsp;přesněji řečeno <i>OpenGL ES</i>) pro programování čipu Broadcom
VideoCore IV. Teprve s&nbsp;využitím <i>GLES</i> (což je nejrozšířenější
knihovna pro 3D grafiku) je možné z&nbsp;výpočetních možností nabízených
Raspberry Pi skutečně vytěžit maximum, protože VideoCore nemusí být použit
pouze pro renderování grafiky, ale i pro běžné výpočty, které mohou probíhat
mnohem rychleji, než na hlavním CPU.</p>

<img src="https://i.iinfo.cz/images/338/rpi4-7.png" class="image-237022" alt="&#160;" width="614" height="532" />
<p><i>Obrázek 7: Screenshot vygenerovaný příkladem rpi_fb13.c (obrázek byl
znegován).</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady, s&nbsp;nimiž jsme se v&nbsp;dnešním článku
seznámili, byly, podobně jako tomu bylo i v&nbsp;obou předchozích částech
tohoto seriálu, uloženy do Git repositáře umístěného na GitHubu na adrese (<a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>):</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Zdrojový kód</th></tr>
<tr><td>1</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb11.c">https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb11.c</a></td></tr>
<tr><td>2</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb12.c">https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb12.c</a></td></tr>
<tr><td>3</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb13.c">https://github.com/tisnik/presentations/blob/master/rpi_framebuffer/rpi_fb13.c</a></td></tr>
</table>

<p>Pro překlad obou demonstračních příkladů je zapotřebí mít nainstalován
překladač GNU C (či Clang), linker a vývojářskou verzi <i>libc</i>. Navíc
poslední příklad vyžaduje i slinkování s&nbsp;knihovnou <i>libm</i>,
tj.&nbsp;použití přepínače <strong>-lm</strong></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Seriál Grafické karty a grafické akcelerátory<br />
<a href="http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/">http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>Xiaolin_Wu's Line Algorithm<br />
<a href="https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm">https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm</a>
</li>

<li>Grafické čipy v osmibitových počítačích Atari<br />
<a href="http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/">http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/</a>
</li>

<li>Osmibitové počítače Commodore a čip VIC-II<br />
<a href="http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/">http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Apple<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>Grafické karty MCGA a VGA<br />
<a href="http://www.root.cz/clanky/graficke-karty-mcga-a-vga/">http://www.root.cz/clanky/graficke-karty-mcga-a-vga/</a>
</li>

<li>Grafický subsystém počítačů Amiga<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/</a>
</li>

<li>Grafický subsystém počítačů Amiga II<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/</a>
</li>

<li>Raspberry Pi pages<br />
<a href="https://www.raspberrypi.org/">https://www.raspberrypi.org/</a>
</li>

<li>BCM2835 registers<br />
<a href="http://elinux.org/BCM2835_registers">http://elinux.org/BCM2835_registers</a>
</li>

<li>VideoCore (archiv stránek společnosti Alphamosaic)<br />
<a href="http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/">http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/</a>
</li>

<li>VideoCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Videocore">https://en.wikipedia.org/wiki/Videocore</a>
</li>

<li>RPi lessons: Lesson 6 Screen01<br />
<a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html">http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html</a>
</li>

<li>Raspberry Pi forum: Bare metal<br />
<a href="https://www.raspberrypi.org/forums/viewforum.php?f=72">https://www.raspberrypi.org/forums/viewforum.php?f=72</a>
</li>

<li>C library for Broadcom BCM 2835 as used in Raspberry Pi<br />
<a href="http://www.airspayce.com/mikem/bcm2835/">http://www.airspayce.com/mikem/bcm2835/</a>
</li>

<li>Raspberry Pi Hardware Components<br />
<a href="http://elinux.org/RPi_Hardware#Components">http://elinux.org/RPi_Hardware#Components</a>
</li>

<li>(Linux) Framebuffer<br />
<a href="http://wiki.linuxquestions.org/wiki/Framebuffer">http://wiki.linuxquestions.org/wiki/Framebuffer</a>
</li>

<li>(Linux) Framebuffer HOWTO<br />
<a href="http://tldp.org/HOWTO/Framebuffer-HOWTO/">http://tldp.org/HOWTO/Framebuffer-HOWTO/</a>
</li>

<li>Linux framebuffer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Linux_framebuffer">https://en.wikipedia.org/wiki/Linux_framebuffer</a>
</li>

<li>RPi Framebuffer<br />
<a href="http://elinux.org/RPi_Framebuffer">http://elinux.org/RPi_Framebuffer</a>
</li>

<li>HOWTO: Boot your Raspberry Pi into a fullscreen browser kiosk<br />
<a href="http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/">http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/</a>
</li>

<li>Zdrojový kód fb.c pro RPI<br />
<a href="https://github.com/jncronin/rpi-boot/blob/master/fb.c">https://github.com/jncronin/rpi-boot/blob/master/fb.c</a>
</li>

<li>RPiconfig<br />
<a href="http://elinux.org/RPi_config.txt">http://elinux.org/RPi_config.txt</a>
</li>

<li>Mailbox framebuffer interface<br />
<a href="https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface">https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface</a>
</li>

<li>Seriál Grafické formáty<br />
<a href="http://www.root.cz/serialy/graficke-formaty/">http://www.root.cz/serialy/graficke-formaty/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

