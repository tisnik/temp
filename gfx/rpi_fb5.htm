<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Stručný přehled grafických knihoven pro Raspberry Pi</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Stručný přehled grafických knihoven pro Raspberry Pi</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na čtyřdílný článek o přímém přístupu do framebufferu (obrazové paměti) mikropočítače Raspberry Pi dnes navážeme přehledem některých knihoven, které je možné použít pro tvorbu 2D a 3D grafiky.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Stručný přehled grafických knihoven pro Raspberry Pi</a></p>
<p><a href="#k02">2. Kterou knihovnu si mám vybrat pro svůj projekt?</a></p>
<p><a href="#k03">3. SDL verze 1.2</a></p>
<p><a href="#k04">4. Allegro 4 a Allegro 5</a></p>
<p><a href="#k05">5. Použití GPU v&nbsp;knihovně SDL verze 2</a></p>
<p><a href="#k06">6. EGL (Native Platform Interface)</a></p>
<p><a href="#k07">7. OpenGL ES (GLES)</a></p>
<p><a href="#k08">8. OpenVG</a></p>
<p><a href="#k09">9. Vykreslovací pipeline realizovaná v&nbsp;OpenVG</a></p>
<p><a href="#k10">10. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Stručný přehled grafických knihoven pro Raspberry Pi</h2>

<p>V&nbsp;předchozí čtveřici článků o tvorbě počítačové grafiky na oblíbeném
jednodeskovém mikropočítači <i>Raspberry Pi</i> [<a
href="http://www.root.cz/clanky/operace-s-framebufferem-na-raspberry-pi/">1</a>]
[<a
href="http://www.root.cz/clanky/operace-s-framebufferem-na-raspberry-pi-vykreslovani-do-framebufferu/">2</a>]
[<a
href="http://www.root.cz/clanky/framebuffer-na-raspberry-pi-vykreslovani-slozitejsich-objektu/">3</a>]
[<a
href="http://www.root.cz/clanky/operace-s-framebufferem-na-raspberry-pi-dokonceni/">4</a>]
jsme se s&nbsp;využitím několika demonstračních příkladů seznámili se způsobem
vykreslování základních grafických entit (primitiv) přímo do framebufferu.
Připomeňme si ve stručnosti, že se v&nbsp;tomto případě pracuje se speciálním
zařízením <strong>/dev/fb0</strong>, které v&nbsp;uživatelském prostoru
zpřístupňuje jak vlastní obsah framebufferu (takzvanou Video RAM), tak i
konfiguraci framebufferu, kterou lze číst či měnit s&nbsp;využitím operace typu
<strong>ioctl</strong>. Pro dosažení co největší rychlosti vykreslování (a
samozřejmě taktéž čtení) pixelů jsme celý framebuffer zpřístupnili uživatelské
aplikaci pomocí funkce <strong>mmap</strong> (<i>memory map</i>), takže nebylo
zapotřebí používat sekvenční čtení a zápis pomocí funkcí <strong>read</strong>
a <strong>write</strong>.</p>

<p>Ovšem jednodeskový mikropočítač Raspberry Pi ve skutečnosti není vybaven
&bdquo;hloupým&ldquo; framebufferem, u něhož se pouze nastaví požadované
rozlišení, obnovovací frekvence a barevná hloubka. Ústředním čipem, na němž je
vlastně celé Raspberry Pi postaveno, je integrovaný obvod <i>BCM2835</i> popř.
<i>BCM2836</i>. První z&nbsp;těchto čipů je použit ve většině modelů Raspberry
Pi, včetně Modelu A, první verze modelu B a nejnověji i RPi Zero, zatímco druhý
čip nalezneme v&nbsp;nejvýkonnějším modelu Raspberry Pi 2 Model B. Na těchto
čipech nalezneme kromě procesorového jádra typu ARM 11 resp.&nbsp; ARM
Cortex-A7 i plně programovatelný grafický procesor neboli GPU. Není se ostatně
čemu divit, protože čipy <i>BCM2835</i> či <i>BCM2836</i> byly navrženy pro
použití v&nbsp;multimediálních zařízeních u nichž se programovatelné GPU mohou
hodit k&nbsp;mnoha různým činnostem: akceleraci 2D grafiky, akceleraci 3D
grafiky, implementaci audio i video kodeků apod. Především u prvního zmíněného
čipu, tj.&nbsp;u <i>BCM2836</i> je patrné, že procesorové jádro (dnes již
vlastně zastaralé) mělo původně sloužit pouze pro podpůrnou činnost, zatímco
nejvíce práce mělo ležet právě na programovatelném grafickém procesoru.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Kterou knihovnu si mám vybrat pro svůj projekt?</h2>

<p>Ve chvíli, kdy si uvědomíme, že právě GPU může mít největší vliv na
schopnosti Raspberry Pi, se nabízí logická otázka: jakým způsobem vlastně může
vývojář možnosti programovatelného grafického procesoru využít ve svých
aplikacích a jaká knihovna se popř.&nbsp;může použít jako náhrada za funkce,
které přímo přistupují k&nbsp;framebufferu a s&nbsp;jejichž možnostmi jsme se
již seznámili? Ve skutečnosti variant existuje hned několik. Konkrétní výběr
přitom závisí jak na tom, do jaké míry má být či musí být aplikace přenositelná
i na další zařízení (běžné PC, smartphone, tablety atd.) a zda programátor
skutečně potřebuje vytvářet vlastní algoritmy pro GPU či zda se spokojí již
s&nbsp;předpřipravenou sadou hotových a otestovaných funkcí (vykreslení úsečky,
vykreslení rastrového obrázku, tvorba křivky, vyplněného tvaru, textu,
otexturovaného trojúhelníku apod.). V&nbsp;navazujících částech tohoto seriálu
se průběžně seznámíme hned s&nbsp;několika knihovnami a technologiemi, které
jsou pro mikropočítače Raspberry Pi dostupné. Všechny příklady budou odzkoušeny
na Raspberry Pi 1 Model B, který je vybaven 512 MB RAM a čipem <i>BCM2835</i>
(ostatně i tento text vzniká na stejném zařízení).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. SDL verze 1.2</h2>

<p>Největší (i když nikoli nesložitější) výběr mají ti vývojáři, kteří se
spokojí se softwarově řízeným vykreslováním, tj.&nbsp;s&nbsp;funkcemi, které ve
výsledku budou programově zapisovat barvy jednotlivých pixelů do framebufferu.
Pravděpodobně nejjednodušší a nejpřímější cestou je v&nbsp;tomto případě
použití knihovny <i>SDL</i> verze 1.2, která je dostupná přímo v&nbsp;základní
instalaci Raspbianu. Tato knihovna programátorům nabízí jak vykreslování do
okna v&nbsp;případě použití systému X Window, tak i vykreslování do
framebufferu. Přitom se v&nbsp;případě <i>SDL 1.2</i> jedná o poměrně úzkou
vrstvu mezi framebufferem a aplikací, což mj.&nbsp;znamená, že
z&nbsp;vykreslovacích (grafických) operací jsou k&nbsp;dispozici pouze operace
určené pro vykreslení obdélníku konstantní barvou, přenosu obrázku operací
<strong>bitblt</strong> a uzamčení obrazové paměti s&nbsp;vrácením ukazatele do
framebufferu (v&nbsp;tento okamžik, tj.&nbsp;po uzamčení obrazové paměti, se
vlastně programátor nachází v&nbsp;podobném stavu, jako my při otevření
speciálního zařízení <strong>/dev/fb0</strong> a jeho namapování do adresního
prostoru aplikace). V&nbsp;případě potřeby jsou k&nbsp;dispozici i pluginy
nabízející další funkce, například práci s&nbsp;TrueType fonty apod.</p>

<p>Poznámka: v&nbsp;některých případech je určitá forma akcelerace použita i
v&nbsp;SDL 1.2, a to v&nbsp;závislosti na tom, která nižší vrstva je
z&nbsp;této knihovny volána.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Allegro 4 a Allegro 5</h2>

<p>Určitou alternativou (či možná lépe řečeno konkurencí) ke knihovně
<i>SDL</i> verze 1.2 je knihovna nazvaná <i>Allegro</i>, která
v&nbsp;současnosti existuje ve dvou variantách: &bdquo;klasická&ldquo; varianta
založená na softwarovém renderingu nese označení Allegro 4 a zcela přepracovaná
varianta, která již dokáže využívat některé možnosti nabízené grafickými
akcelerátory, se jmenuje Allegro 5 (zpětná kompatibilita zde není zachována,
podobně jako u SDL 1.2 &rarr; SDL 2.0). V&nbsp;Raspbiannu je dostupná knihovna
Allegro 4, která programátorům nabízí široké množství různých modulů.
Z&nbsp;hlediska tvorby grafiky jsou nejdůležitější funkce pro vykreslování
různých grafických primitiv (od pixelů přes úsečky až po křivky), práci
s&nbsp;rastrovými obrázky a sprity (včetně použití tzv.&nbsp;kompilovaných
spritů), ale i například podpora pro práci s&nbsp;animacemi uloženými ve
formátu FLI/FLC. Pro některé účely může být zajímavý i modul nabízející velmi
snadno použitelné GUI, které sice neobsahuje všechny dnes očekávané widgety
(chybí například strom), ale pro konfigurační dialogy s&nbsp;tlačítky,
scrollbary, vstupními textovými poli, přepínači atd. je to použitelná a přitom
výkonostně a především paměťově nenáročná alternativa
k&nbsp;&bdquo;plnohodnotným&ldquo; GUI knihovnám.</p>

<p>Poznámka: i v&nbsp;tomto případě platí, že některé operace mohou být
v&nbsp;knihovně Allegro prováděny grafickým procesorem.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Použití GPU v&nbsp;knihovně SDL verze 2</h2>

<p>Pokud programátor potřebuje či chce využít některé základní možnosti
nabízené GPU nainstalovaném na mikropočítači Raspberry Pi, může být velmi
dobrou alternativou knihovna <i>SDL 2</i>. Ta vznikla z&nbsp;již zmíněné
knihovny <i>SDL 1.2</i>, přičemž prakticky celý modul týkající se grafického
výstupu byl přepracován a není zpětně kompatibilní. Proč se vlastně tvůrci
rozšířené a současně i velmi oblíbené knihovny <i>SDL 1.2</i> (ta je použita
v&nbsp;mnoha open source i komerčních hrách) vlastně rozhodli pro změnu API,
které není zpětně kompatibilní a která tedy nutí vývojáře k&nbsp;přepisu části
svých zdrojových kódů? Odpovědí je vývoj grafických čipů a především pak
programovatelných GPU. Knihovna <i>SDL 1.2</i> vlastně (i z&nbsp;historických
důvodů) tvoří jen velmi úzkou vrstvu mezi framebufferem a aplikací, což
například znamená, většina vykreslovacích operací je prováděna softwarově
přenosem barev jednotlivých pixelů do obrazové paměti (což je přesně ten
způsob, s&nbsp;nímž jsme se již seznámili). V&nbsp;knihovně <i>SDL 2</i> je
vykreslování prováděno odlišně: nejprve se rastrové obrázky a sprity převedou
do video paměti či do texturovací paměti a teprve odsud jsou velmi rychle
vykresleny.</p>

<p>Knihovna <i>SDL 2</i> přitom může při práci s&nbsp;texturami interně volat
funkce knihoven OpenGL, OpenGL ES, Direct X atd. Pro nás je v&nbsp;tuto chvíli
zajímavá především podpora pro volání funkcí OpenGL ES, a to z&nbsp;toho
důvodu, že OpenGL ES 2.0 je na mikropočítači Raspberry Pi přímo podporována
(viz též navazující kapitoly). Návod pro překlad knihovny <i>SDL 2</i> pro
Raspberry Pi a Raspbian je popsán na stránce <a
href="https://solarianprogrammer.com/2015/01/22/raspberry-pi-raspbian-getting-started-sdl-2/">https://solarianprogrammer.com/2015/01/22/raspberry-pi-raspbian-getting-started-sdl-2/</a>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. EGL (Native Platform Interface)</h2>

<p>Konečně se dostáváme k&nbsp;technologii, která je přímo navržena pro práci
s&nbsp;grafickým procesorem. Jedná se o <i>EGL</i> neboli též <i>Native
Platform Interface</i> používané jako mezivrstva mezi grafickým procesorem
(přičemž každý grafický procesor může mít zcela odlišný způsob ovládání) na
jedné straně a knihovnou OpenVG či OpenGL ES na straně druhé (alternativně je
samozřejmě možné volat funkce poskytované EGL přímo, hlavičkové soubory
naleznete v&nbsp;adresáři <strong>/opt/vc/include/EGL</strong>). Za vývojem EGL
stojí sdružení Khronos, které kromě toho &bdquo;pečuje&ldquo; i o specifikace a
implementace OpenGL, OpenGL ES, OpenVG atd. Jedním ze základních úkolů EGL je
vytvoření a správa grafického kontextu, ploch (<i>surface</i>), do kterých je
možné přes knihovny OpenGL ES a OpenVG provádět vykreslování atd. Mimochodem
&ndash; plochy (<i>surface</i>) mohou být vytvořeny tak, aby aplikace běžela
v&nbsp;systému X Window (i v&nbsp;okně), přes framebuffer nebo lze vykreslování
provádět do zadního bufferu. Další důležitou funkcí nabízenou EGL je kopie
obsahu bitmap mezi jednotlivými plochami, tj.&nbsp;operace typu
<strong>bitblt</strong>.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. OpenGL ES (GLES)</h2>

<p>V&nbsp;článku o knihovnách určených pro tvorbu grafiky na jednodeskových
mikropočítačích Raspberry Pi samozřejmě nesmí chybět zmínka o knihovně
<i>OpenGL ES</i>, která se též někdy označuje zkratkou <i>GLES</i>. Jedná se o
variantu známé knihovny <a
href="http://www.root.cz/serialy/graficka-knihovna-opengl/">OpenGL</a>, ovšem
upravené takovým způsobem, aby se tato knihovna dala efektivně použít na
smartphonech a tabletech vybavených GPU (právě pro je v&nbsp;názvu použito
&bdquo;ES&ldquo;, což znamená &bdquo;for Embedded Systems&ldquo;). Dnes
existuje již několik specifikací OpenGL ES; nás bude nejvíce zajímat OpenGL ES
2.0, protože právě tato verze je dostupná pro Raspberry Pi (několik vývojářů se
dokonce vyjádřilo v&nbsp;tom smyslu, že na RPi je specifikace dodržována velmi
dobře a proto je RPi ideální pro ladění aplikací, které OpenGL ES 2.0
používají). Proto také všechny demonstrační příklady, s&nbsp;nimiž se později
seznámíme, budou překládány a linkovány právě proti OpenGL ES 2.0.</p>

<p>Již na začátku je nutné zdůraznit, že OpenGL ES 2.0 je v&nbsp;mnoha ohledech
odlišná od &bdquo;klasické desktopové&ldquo; knihovny OpenGL (ta vznikla pro
grafické pracovní stanice společnosti SGI, ostatně některé funkce OpenGL
nalezneme i ve starší knihovně IRIS GL). To znamená, že není možné například
převzít zdrojové kódy aplikace postavené na OpenGL a GLUTu a přeložit je beze
změny pro Raspberry Pi. Provedené úpravy v&nbsp;API GLESu však mají svůj smysl,
protože konstrukce GPU se velmi změnila &ndash; namísto pevně nastavené
vykreslovací pipeline dnes máme k&nbsp;dispozici programovatelná GPU, takže
například všechny funkce, které se v&nbsp;původní OpenGL zabývaly výpočtem
osvětlení, již není nutné mít zafixovány, protože je možné implementovat si
vlastní <i>shadery</i>. Navíc je možné vhodným naprogramováním GPU použít tento
čip i pro jiné výpočty (FFT, kodeky apod.)</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. OpenVG</h2>

<p>Pro mnoho aplikací může být zajímavé a užitečné použít relativně novou
knihovnu nazvanou <i>OpenVG</i>. Zatímco výše zmíněná knihovna <i>OpenGL ES</i>
je určena především pro tvorbu 3D grafiky, na niž se v&nbsp;posledních dvou
desetiletích soustředili i výrobci grafických akcelerátorů pro počítače řady
PC, uvědomili si tvůrci <i>OpenVG</i> jednu &bdquo;maličkost&ldquo;: při práci
s&nbsp;desktopem popř.&nbsp;i při práci na tabletu či smartphonu je velmi
důležitá i 2D grafika. Typickou 2D aplikací dneška je webový prohlížeč, od
něhož se mj.&nbsp;vyžaduje i co nejrychlejší vykreslení mnohdy velmi složitého
layoutu stránek, plynulý scrolling, kvalitně zobrazené písmo, dynamické změny
ve stránkách, podpora HTML 5 canvasu apod. Dalšími 2D aplikacemi mohou být
některé oblíbené hry, ať již se jedná o typicky dvourozměrné Angry Birds či o
hry s&nbsp;isometrickou grafikou. Na tabletech, smartphonech a některých
&bdquo;moderních&ldquo; desktopech se taktéž velmi často požaduje zmenšení
aplikace do živé ikony či použití vektorových ikon a widgetů (škálovatelné
grafické uživatelské rozhraní).</p>

<p>Právě pro tyto účely vznikla knihovna nazvaná <i>OpenVG</i>, která například
obsahuje funkce pro deklaraci a vykreslení takzvaných <i>cest (paths)</i>,
aplikaci různých filtrů na 2D scénu, práci s&nbsp;fonty apod. Funkce byly
mj.&nbsp;vybrány i s&nbsp;ohledem na předpokládané větší použití formátu SVG
(<a href="http://www.root.cz/clanky/vektorovy-graficky-format-svg/">Scalable
Vector Graphics</a>). Předpokládá se, že OpenVG může být použita ve funkci
backendu například pro Cairo a Pango apod. Zajímavé je, že existuje i čistě
softwarová implementace funkcí <i>OpenVG</i> naprogramovaná v&nbsp;ANSI C a
tedy přenositelná na prakticky jakoukoli platformu. Z&nbsp;pohledu programátora
je sympatické, že způsob pojmenování funkcí <i>OpenVG</i> je podobný se
způsobem použitým v&nbsp;knihovně OpenGL; samozřejmě až na odlišný prefix
(<strong>vgDrawImage()</strong> versus <strong>glDrawArrays()</strong> &ndash;
toto jsou mimochodem funkce s&nbsp;odlišnou sémantikou).</p>

<p>Některé možnosti <i>OpenVG</i> si ukážeme příště.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vykreslovací pipeline realizovaná v&nbsp;OpenVG</h2>

<p>Podívejme se nyní poněkud podrobněji na způsob realizace vykreslovací
pipeline v&nbsp;knihovně OpenVG, protože způsob postupné aplikace jednotlivých
operací v&nbsp;pipeline vlastně přímo určuje, jak se budou jednotlivé grafické
prvky vykreslovat. Vykreslování probíhá v&nbsp;těchto krocích (které mohou být
skutečně prováděny v&nbsp;pipeline za účelem urychlení vykreslování, při
softwarové implementaci však pravděpodobně budou prováděny sekvenčně):</p>

<ol>

<li>Na vstupu do pipeline se nachází informace o grafických objektech, které se
mají vykreslit. Jedná se o cesty (<i>path</i>), informace o lineárních
transformacích, které se mají provést (<i>transformation</i>), informace o
štětcích použitých při vykreslování (<i>stroke</i>) a konečně informace o
způsobu vykreslení výplně uzavřených křivek (<i>paint</i>).</li>

<li>Prvním krokem je aplikace štětců (<i>stroke</i>) na cesty (<i>path</i>).
Výsledkem je datová struktura popisující vrcholy, které budou následně při
vlastní rasterizaci pospojovány. Pokud se má například vykreslit široká úsečka,
vznikne aplikací štětce úzký obdélník. V&nbsp;případě čárkované úsečky pak
sekvence obdélníků.</li>

<li>Následuje transformace souřadnic vrcholů na základě vstupních informací
(transformačních matic). Transformovány jsou samozřejmě vrcholy vypočtené
v&nbsp;předchozím kroku. Pod pojmem transformace si můžeme představit především
posun, změnu měřítka či otočení (popř.&nbsp;kombinaci těchto
transformací).</li>

<li>V&nbsp;dalším kroku je prováděna takzvaná rasterizace, tj.&nbsp;převod
geometrického tvaru na pixely. My jsme se již s&nbsp;rasterizací setkali, a to
při implementaci algoritmů pro vykreslování úseček. Ovšem vzhledem
k&nbsp;podpoře složitějších tvarů v&nbsp;OpenVG jsou zde implementované
rasterizační algoritmy složitější, navíc se rasterizace nemusí provádět přímo
do framebufferu, ale například do bitmapy uložené v&nbsp;paměti GPU (to
z&nbsp;toho důvodu, aby bylo možné aplikovat další tři kroky).</li>

<li>Již během rasterizace popř.&nbsp;v&nbsp;navazujícím kroku se provádí
ořezání (<i>clipping</i>) a popř.&nbsp;maskování (<i>masking</i>), opět na
základě údajů získaných z&nbsp;uživatelské aplikace (ořezové obdélníky, bitová
maska apod.).</li>

<li>Následuje případná výplň uzavřených tvarů (<i>paint</i>). Nejjednodušší
výplní je konstantní barva, lze však použít i složitější styl výplně, včetně
textur.</li>

<li>Při některých operacích s&nbsp;rastrovými obrázky je nutné aplikovat
(bilineární) interpolaci. Jedná se zejména o zvětšení, zmenšení či otočení
obrázku před jeho vykreslením do framebufferu.</li>

<li>Poslední operací je <i>blending</i>, tj.&nbsp;aplikace nějaké funkce
(například lineární interpolace) na barvy pixelů ve zdrojovém obrázku (získaném
rasterizací a vyplněním uzavřených ploch) a v&nbsp;obrázku cílovém (což může
být například framebuffer).</li>

</ol>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odkazy na Internetu</h2>

<ol>

<li>Khronos Group<br />
<a href="https://www.khronos.org/">https://www.khronos.org/</a>
</li>

<li>Khronos Group (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Khronos_Group">https://en.wikipedia.org/wiki/Khronos_Group</a>
</li>

<li>Raspberry Pi VideoCore APIs<br />
<a href="http://elinux.org/Raspberry_Pi_VideoCore_APIs">http://elinux.org/Raspberry_Pi_VideoCore_APIs</a>
</li>

<li>Programming AudioVideo on the Raspberry Pi GPU<br />
<a href="https://jan.newmarch.name/RPi/index.html">https://jan.newmarch.name/RPi/index.html</a>
</li>

<li>The Standard for Vector Graphics Acceleration<br />
<a href="https://www.khronos.org/openvg/">https://www.khronos.org/openvg/</a>
</li>

<li>OpenVG (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenVG">https://en.wikipedia.org/wiki/OpenVG</a>
</li>

<li>OpenVG Quick Reference Card<br />
<a href="https://www.khronos.org/files/openvg-quick-reference-card.pdf">https://www.khronos.org/files/openvg-quick-reference-card.pdf</a>
</li>

<li>OpenVG on the Raspberry Pi<br />
<a href="http://mindchunk.blogspot.cz/2012/09/openvg-on-raspberry-pi.html">http://mindchunk.blogspot.cz/2012/09/openvg-on-raspberry-pi.html</a>
</li>

<li>ShivaVG: open-source ANSI C OpenVG <br />
<a href="http://ivanleben.blogspot.cz/2007/07/shivavg-open-source-ansi-c-openvg.html">http://ivanleben.blogspot.cz/2007/07/shivavg-open-source-ansi-c-openvg.html</a>
</li>

<li>Testbed for exploring OpenVG on the Raspberry Pi<br />
<a href="https://github.com/ajstarks/openvg">https://github.com/ajstarks/openvg</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: knihovna Pygame<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: knihovna Pygame prakticky<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame-prakticky/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame-prakticky/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: práce s bitmapami a TrueType fonty<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-prace-s-bitmapami-a-truetype-fonty/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-prace-s-bitmapami-a-truetype-fonty/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: sprity v knihovně Pygame<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-sprity-v-knihovne-pygame/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-sprity-v-knihovne-pygame/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: detekce kolize spritů<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-detekce-kolize-spritu/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-detekce-kolize-spritu/</a>
</li>

<li>Seriál Grafické karty a grafické akcelerátory<br />
<a href="http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/">http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>Xiaolin_Wu's Line Algorithm<br />
<a href="https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm">https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm</a>
</li>

<li>Grafické čipy v osmibitových počítačích Atari<br />
<a href="http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/">http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/</a>
</li>

<li>Osmibitové počítače Commodore a čip VIC-II<br />
<a href="http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/">http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Apple<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>Grafické karty MCGA a VGA<br />
<a href="http://www.root.cz/clanky/graficke-karty-mcga-a-vga/">http://www.root.cz/clanky/graficke-karty-mcga-a-vga/</a>
</li>

<li>Grafický subsystém počítačů Amiga<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/</a>
</li>

<li>Grafický subsystém počítačů Amiga II<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/</a>
</li>

<li>Raspberry Pi pages<br />
<a href="https://www.raspberrypi.org/">https://www.raspberrypi.org/</a>
</li>

<li>BCM2835 registers<br />
<a href="http://elinux.org/BCM2835_registers">http://elinux.org/BCM2835_registers</a>
</li>

<li>VideoCore (archiv stránek společnosti Alphamosaic)<br />
<a href="http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/">http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/</a>
</li>

<li>VideoCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Videocore">https://en.wikipedia.org/wiki/Videocore</a>
</li>

<li>RPi lessons: Lesson 6 Screen01<br />
<a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html">http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html</a>
</li>

<li>Raspberry Pi forum: Bare metal<br />
<a href="https://www.raspberrypi.org/forums/viewforum.php?f=72">https://www.raspberrypi.org/forums/viewforum.php?f=72</a>
</li>

<li>C library for Broadcom BCM 2835 as used in Raspberry Pi<br />
<a href="http://www.airspayce.com/mikem/bcm2835/">http://www.airspayce.com/mikem/bcm2835/</a>
</li>

<li>Raspberry Pi Hardware Components<br />
<a href="http://elinux.org/RPi_Hardware#Components">http://elinux.org/RPi_Hardware#Components</a>
</li>

<li>(Linux) Framebuffer<br />
<a href="http://wiki.linuxquestions.org/wiki/Framebuffer">http://wiki.linuxquestions.org/wiki/Framebuffer</a>
</li>

<li>(Linux) Framebuffer HOWTO<br />
<a href="http://tldp.org/HOWTO/Framebuffer-HOWTO/">http://tldp.org/HOWTO/Framebuffer-HOWTO/</a>
</li>

<li>Linux framebuffer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Linux_framebuffer">https://en.wikipedia.org/wiki/Linux_framebuffer</a>
</li>

<li>RPi Framebuffer<br />
<a href="http://elinux.org/RPi_Framebuffer">http://elinux.org/RPi_Framebuffer</a>
</li>

<li>HOWTO: Boot your Raspberry Pi into a fullscreen browser kiosk<br />
<a href="http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/">http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/</a>
</li>

<li>Zdrojový kód fb.c pro RPI<br />
<a href="https://github.com/jncronin/rpi-boot/blob/master/fb.c">https://github.com/jncronin/rpi-boot/blob/master/fb.c</a>
</li>

<li>RPiconfig<br />
<a href="http://elinux.org/RPi_config.txt">http://elinux.org/RPi_config.txt</a>
</li>

<li>Mailbox framebuffer interface<br />
<a href="https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface">https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface</a>
</li>

<li>Seriál Grafické formáty<br />
<a href="http://www.root.cz/serialy/graficke-formaty/">http://www.root.cz/serialy/graficke-formaty/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

