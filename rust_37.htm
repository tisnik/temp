<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Dyon - spojení předností Rustu a dynamicky typovaných programovacích jazyků</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Dyon - spojení předností Rustu a dynamicky typovaných programovacích jazyků</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešní části seriálu o programovacím jazyku Rust se výjimečně nebudeme soustředit na samotný Rust, ale řekneme si základní informace o jazyku Dyon s dynamickým typováním, který byl vytvořen speciálně pro rustovský ekosystém a slouží mj. i jako jazyk vhodný pro použití s frameworkem Piston.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Dyon &ndash; spojení předností Rustu a dynamicky typovaných programovacích jazyků</a></p>
<p><a href="#k02">2. Instalace Dyonu s&nbsp;využitím správce projektů Cargo</a></p>
<p><a href="#k03">*** 3. Základní koncepty, na nichž je programovací jazyk Dyon postaven</a></p>
<p><a href="#k04">*** 4. Proměnné</a></p>
<p><a href="#k05">*** 5. Speciální datové typy</a></p>
<p><a href="#k06">6. Funkce</a></p>
<p><a href="#k07">7. Funkce s&nbsp;parametry a &bdquo;matematická notace&ldquo;</a></p>
<p><a href="#k08">8. Změna parametrů ve volaných funkcích</a></p>
<p><a href="#k09">9. Programové bloky</a></p>
<p><a href="#k10">10. Uzávěry</a></p>
<p><a href="#k11">11. Řídicí (rozhodovací) konstrukce</a></p>
<p><a href="#k12">12. Programové smyčky</a></p>
<p><a href="#k13">*** 13. Zkrácený zápis smyčky: automatické odvození, přes kterou sekvenci se iteruje</a></p>
<p><a href="#k14">*** 14. Zkrácený zápis vnořených smyček</a></p>
<p><a href="#k15">*** 15. Zápis často používaných typů smyček &ndash; suma, hledání maxima atd.</a></p>
<p><a href="#k16">*** 16. Životnost objektů</a></p>
<p><a href="#k17">*** 17. Práce s&nbsp;chybovými hodnotami</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Dyon &ndash; spojení předností Rustu a dynamicky typovaných programovacích jazyků</h2>

<p><i>&bdquo;If you need OOP patterns, then there is only one solution: Use
another language, for example Rust. Dyon is designed for scripting, as in
solving problems fast. It is not designed for building abstractions, or proving
things through the type system.&ldquo;</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instalace Dyonu s&nbsp;využitím správce projektů Cargo</h2>

<p>Instalace programovacího jazyka Dyon je pro zkušenější rustovské
programátory triviální, protože je tento jazyk dostupný ve formě balíčku
spravovaného systémem Cargo. Postačí si tedy vytvořit nový projekt a do něj do
sekce se závislostmi přidat jedinou knihovnu.</p>

<p>Prvním krokem je samozřejmě vytvoření projektu:</p>

<pre>
$ <strong>cargo new --bin dyon-hello-world</strong>
</pre>

<p>Dále upravíme projektový soubor přidáním sekce
<strong>[dependencies]</strong>:</p>

<pre>
[package]
name = "dyon-hello-world"
version = "0.1.0"
authors = ["Pavel Tisnovsky &lt;ptisnovs@redhat.com&gt;"]
&nbsp;
<strong>[dependencies]</strong>
<strong>dyon = "0.21.0"</strong>
</pre>

<p>Pokud nyní spustíme překlad projektu, stáhnou se všechny potřebné balíčky,
na nichž <i>Dyon</i> závisí a následně se tyto balíčky přeloží:</p>

<pre>
$ <strong>cargo build</strong>
</pre>

<pre>
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading dyon v0.21.1
 Downloading piston_meta v0.29.1
 Downloading rand v0.3.16
 Downloading range v0.3.1
 Downloading read_color v0.1.0
 Downloading read_token v0.9.0
 Downloading hyper v0.9.18
 Downloading libc v0.2.29
 Downloading log v0.3.8
 Downloading rustc-serialize v0.3.24
 Downloading unicase v1.4.2
 Downloading httparse v1.2.3
 Downloading num_cpus v1.6.2
 Downloading language-tags v0.2.2
 Downloading url v1.5.1
 Downloading traitobject v0.0.1
 Downloading typeable v0.1.2
 Downloading time v0.1.38
 Downloading cookie v0.2.5
 Downloading solicit v0.4.4
 Downloading mime v0.2.6
 Downloading version_check v0.1.3
 Downloading percent-encoding v1.0.0
 Downloading idna v0.1.4
 Downloading unicode-bidi v0.3.4
 Downloading hpack v0.2.0
   Compiling matches v0.1.6
   Compiling lazy_static v0.2.8
   Compiling range v0.3.1
   Compiling libc v0.2.29
   Compiling typeable v0.1.2
   Compiling read_color v0.1.0
   Compiling unicode-normalization v0.1.5
   Compiling language-tags v0.2.2
   Compiling log v0.3.8
   Compiling httparse v1.2.3
   Compiling version_check v0.1.3
   Compiling rustc-serialize v0.3.24
   Compiling percent-encoding v1.0.0
   Compiling traitobject v0.0.1
   Compiling unicode-bidi v0.3.4
   Compiling read_token v0.9.0
   Compiling time v0.1.38
   Compiling num_cpus v1.6.2
   Compiling rand v0.3.16
   Compiling mime v0.2.6
   Compiling hpack v0.2.0
   Compiling unicase v1.4.2
   Compiling piston_meta v0.29.1
   Compiling idna v0.1.4
   Compiling solicit v0.4.4
   Compiling url v1.5.1
   Compiling cookie v0.2.5
   Compiling hyper v0.9.18
   Compiling dyon v0.21.1
   Compiling dyon-project v0.1.0 (file:///home/tester/rust/projects/dyon-project)
    Finished dev [unoptimized + debuginfo] target(s) in 64.83 secs
</pre>

<p>Do souboru <strong>main.rs</strong> přidáme kód pro spuštění nového skriptu
napsaného v&nbsp;jazyce Dyon:</p>

<pre>
extern crate dyon;
&nbsp;
use dyon::{error, run};
&nbsp;
fn main() {
    error(run("src/main.dyon"));
}
</pre>

<p>Vytvoříme zmíněný skript <strong>main.dyon</strong>, který je prozatím velmi
jednoduchý:</p>

<pre>
fn main() {
    println("Hello world!")
}
</pre>

<p>Celou aplikaci by není mělo být možné přeložit a spustit:</p>

<pre>
$ <strong>cargo run</strong>
</pre>

<pre>
   Compiling dyon-project v0.1.0 (file:///home/tester/temp/presentations/rust/projects/dyon-project)
    Finished dev [unoptimized + debuginfo] target(s) in 2.9 secs
     Running `target/debug/dyon-project`
Hello world!
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Základní koncepty, na nichž je programovací jazyk Dyon postaven</h2>



<p><a name="k04"></a></p>
<h2 id="k04">4. Proměnné</h2>

<p>Proměnné se v&nbsp;Dyonu vytváří velmi jednoduše, dokonce ještě jednodušeji
než v&nbsp;Rustu. Celá deklarace proměnné spočívá v&nbsp;uvedení jejího názvu,
znaků := pro přiřazení a hodnoty, která se má do proměnné přiřadit. Hodnota je
samozřejmě nějakého typu, ze kterého je automaticky odvozen i typ výsledné
proměnné:</p>

<pre>
x <strong>:=</strong> 42
</pre>

<p>Obsah proměnných je možné měnit, což znamená, že proměnné nejsou ve výchozím
nastavení neměnitelné (<i>immutable</i>). Pro změnu obsahu proměnné se používá
odlišný znak přiřazení <strong>=</strong>, nikoli <strong>:=</strong>. Díky
této maličkosti je možné detekovat chyby způsobené překlepem ve jménu
proměnné:</p>

<pre>
x <strong>=</strong> 0
</pre>

<p>Při přiřazování hodnot do proměnných se provádí kontroly, zda proměnná již
existuje (tj.&nbsp;zda byla deklarována) a současně zda má nová hodnota typ
shodný s&nbsp;typem proměnné. To je jeden z&nbsp;podstatných rozdílů oproti
dalším dynamicky typovaným jazykům, u nichž je většinou možné do proměnných
přiřazovat hodnoty různých typů. Příkladem může být dynamicky typovaný
Python:</p>

<pre>
x=True
x=42
x="xyzzy"
x=(1,2,3)
</pre>

<p>Mezi chybné zápisy patří:</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Speciální datové typy</h2>

<p>V&nbsp;jazyku Dyon nalezneme poměrně velké množství datových typů,
zejména:</p>

<ul>

<li>Logické hodnoty <strong>true</strong> a <strong>false</strong>
reprezentované typem <strong>bool</strong>.</li>

<li>Čísla, která interně odpovídají typu <strong>f64</strong> z&nbsp;Rustu. Při
zápisu je možné oddělovat tisíce, miliony atd. podtržítkem, což zvyšuje
čitelnost.</li>

<li>Řetězce, které odpovídají typu <strong>str</strong>, tj.&nbsp;používá se
kódování UTF-8 atd.</li>

<li>Heterogenní pole s&nbsp;prvky zapisovanými do hranatých závorek [].</li>

<li>Tzv.&nbsp;<i>links</i>, což jsou v&nbsp;podstatě homogenní pole alokovaná
po blocích o velikosti 1 kB.</li>

<li>Čtyřrozměrné vektory, kde ovšem třetí a čtvrtá složka mohou být implicitně
nulové, takže je lze použít i jako 2D a 3D vektory. Důvod použití: prakticky
všechny grafické algoritmy.</li>

<li>Objekty (<i>objects</i>), ve skutečnosti se ale jedná o slovníky.</li>

<li>Uzávěry (<i>closures</i>), o nichž se zmíníme dále.</li>

<li>Typ <strong>Option</strong> známý z&nbsp;Rustu.</li>

<li>Typ <strong>Result</strong> známý opět z&nbsp;Rustu.</li>

</ul>



<p><a name="k06"></a></p>
<h2 id="k06">6. Funkce</h2>

<p>Programovací jazyk Dyon má &ndash; ostatně podobně jako samotný Rust &ndash;
některé funkcionální rysy, takže nás pravděpodobně asi nepřekvapí, že se
v&nbsp;tomto jazyku velmi dobře a snadno pracuje s&nbsp;funkcemi, navíc je
hlídáno správné použití návratových hodnot funkcí apod. Funkce se mohou
deklarovat několika způsoby, přičemž základní způsob se v&nbsp;mnoha ohledech
podobá samotnému Rustu. Funkce bez parametrů, která nevrací žádnou hodnotu (jde
tedy vlastně o proceduru a nikoli plnohodnotnou funkci) bude vypadat takto:</p>

<pre>
fn funkce1() {
    println("funkce1")
}
</pre>

<p>Pokud chceme vytvořit funkci, která vrací hodnotu, je nutné před blok
s&nbsp;tělem zapsat -&gt; a současně je nutné ve funkci použít
<strong>return</strong>. Nelze se tedy spolehnout na to, že poslední výraz ve
funkci po svém vyhodnocení vytvoří návratovou hodnotu, která se použije
automaticky! Současně se musí návratová hodnota funkce
&bdquo;zkonzumovat&ldquo;. Podívejme se na příklad:</p>

<pre>
fn funkce2() -&gt; {
    println("funkce2")
    return 42
}
&nbsp;
fn functions() {
    print(funkce2())
}
</pre>

<p>Následující úryvky kódu jsou chybné:</p>

<pre>
fn funkce2() -&gt; {
    println("funkce2")
    42
}
</pre>

<p>Chyba vypsaná při spuštění &ndash; očekává se explicitní vrácení
hodnoty:</p>

<pre>
 --- ERROR --- 
In `src/main.dyon`:
&nbsp;
Type mismatch (#775):
Expected `any`, found `void`
5,1: fn funkce2() -&gt; {
5,1: ^
6,1:     println("funkce2")
7,1:     42
8,1: }
</pre>

<pre>
fn funkce2() {
    println("funkce2")
    return 42
}
</pre>

<p>Chyba vypsaná při spuštění &ndash; zde se naopak příkaz
<strong>return</strong> vůbec neočekává:</p>

<pre>
 --- ERROR --- 
In `src/main.dyon`:
&nbsp;
Type mismatch (#350):
Expected `void`, found `f64`
7,12:     return 42
7,12:            ^
</pre>

<pre>
fn funkce2() -&gt; {
    println("funkce2")
    return 42
}
&nbsp;
fn functions() {
    funkce2()
}
</pre>

<p>Zde se &bdquo;nezkonzumovala&ldquo; návratová hodnota funkce:</p>

<pre>
 --- ERROR --- 
In `src/main.dyon`:
&nbsp;
Type mismatch (#1100):
Unused result `any`
12,5:     funkce2()
12,5:     ^
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Funkce s&nbsp;parametry a &bdquo;matematická notace&ldquo;</h2>

<p>Funkce s&nbsp;parametry se zapisuje běžným způsobem, přičemž většinou
nepotřebujeme explicitně specifikovat typy parametrů:</p>

<pre>
fn funkce3(x,y) -&gt; {
    return x*y
}
...
...
...
println(funkce3(6,7))
</pre>

<p>Existuje ovšem i další a podle mého názoru mnohem zajímavější způsob
deklarace funkcí, který autor Dyanu nazval &bdquo;matematická notace&ldquo;.
Zde se vynechává klíčové slovo <strong>fn</strong>, explicitní zápis -&gt; i
klíčového slova <strong>return</strong> a zápis se zjednoduší na jediný
řádek:</p>

<pre>
funkce4(x,y) = x*y
</pre>

<p>Volání této funkce se již nijak neliší od volání předchozí funkce:</p>

<pre>
println(funkce4(6,7))
</pre>

<p>Konstrukci <strong>if-else</strong> lze použít i ve výrazu, takže můžeme
tvořit i složitější one-linery, například:</p>

<pre>
inv(x) = if x!=0 {1.0/x} else {0}
</pre>

<p>Příklad volání:</p>

<pre>
println(inv(0))
0
&nbsp;
println(inv(2))
0.5
</pre>

<p>Samozřejmě můžeme použít i rekurzi (v&nbsp;současnosti bez
optimalizací):</p>

<pre>
factorial(n) = if n &lt;= 1 { 1 }
               else {n * factorial(n-1)}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Změna parametrů ve volaných funkcích</h2>

<p>Funkce mohou měnit hodnoty svých argumentů, ale v&nbsp;tomto případě se
jedná o poměrně problematický rys, který musí být explicitně specifikován jak
při deklaraci funkce, tak i při jejím volání. Konkrétně to znamená, že u jména
argumentu i parametru musí být zapsáno klíčové slovo <strong>mut</strong>:</p>

<pre>
fn inc(<strong>mut</strong> x) {
    x += 1
}
&nbsp;
x := 1
println(x)
inc(mut x)
println(x)
inc(mut x)
println(x)
&nbsp;
1
2
3
</pre>

<p>Použití <strong>mut</strong> se poměrně striktně hlídá a pokud toto slovo
nepoužijeme, dostaneme následující chybové hlášení:</p>

<pre>
 --- ERROR --- 
In `src/main.dyon`:
&nbsp;
Requires `mut x`
22,5:     x += 1
22,5:     ^
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Programové bloky</h2>

<p>Základním stavebním prvkem všech aplikací naprogramovaných v&nbsp;Dyonu jsou
kromě již výše zmíněných funkcí i bloky, které se již z&nbsp;historických
důvodů (viz především programovací jazyky <a
href="https://en.wikipedia.org/wiki/B_%28programming_language%29">B</a> a <a
href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C</a>)
zapisují mezi složené závorky { a }. Ovšem bloky se v&nbsp;Dyonu, podobně jako
v&nbsp;Rustu, chovají jako výrazy, přičemž hodnota <i>posledního</i> výrazu
v&nbsp;bloku je současně i návratovou hodnotou celého bloku. Připomeňme si, že
se v&nbsp;Dyonu nemusí používat středníky, takže zde nenastává stejný problém,
jako například v&nbsp;samotném Rustu, kde je velký rozdíl mezi ukončením
posledního výrazu středníkem a uvedením stejného výrazu, ovšem bez středníku.
Podívejme se nyní na použití jednoduchých bloků (s&nbsp;jedním výrazem) i
poněkud složitějších bloků, v&nbsp;nichž je uvedeno větší množství výrazů:</p>

<pre>
fn blocks() {
    u := 42
    println(u)
&nbsp;
    v := {42}
    println(v)
&nbsp;
    w := {6*7}
    println(w)
&nbsp;
    x := {u*v}
    println(x)
&nbsp;
    y := {
        a := 6
        b := 7
        a*b
    }
    println(y)
&nbsp;
    z := {
        a := 6
        b := 7
        if a&lt;b {
            a*b
        } else {
            0
        }
    }
    println(z)
}
</pre>

<p>Výsledky:</p>

<pre>
42
42
42
1764
42
42
</pre>

<p>Musíme si však dát pozor na životnost proměnné (viz též další text, kde se
budeme touto problematikou zabývat). Následující příklad skončí s&nbsp;chybou,
protože se snažíme proměnnou použít mimo oblast její životnosti:</p>

<pre>
fn blocks_error() {
    x := {
        y := 42
        y
    }
    println(x)
}
</pre>

<p>Chyba, která nastane při překladu:</p>

<pre>
 --- ERROR --- 
In `src/main.dyon`:
&nbsp;
`y` does not live long enough
34,10:     x := {
34,10:          ^
35,1:         y := 42
36,1:         y
37,1:     }
</pre>

<p>Jedno z&nbsp;řešení spočívá v&nbsp;naklonování reference na hodnotu:</p>

<pre>
fn blocks_clone() {
    x := {
        y := 42
        clone(y)
    }
    println(x)
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Uzávěry</h2>

<p>Podobným způsobem jako funkce se zapisují i <i>uzávěry (closures)</i>, při
jejichž volání se musí použít znak \ (připomínající lambdu):</p>

<pre>
f := \(x,y) = x*y
println(\f(6,7))
</pre>

<p>Složitější uzávěr:</p>

<pre>
fac := \(n) = if n &lt;= 1 { 1 }
              else {n * factorial(n-1)}
</pre>

<p>Do uzávěru lze přidat hodnotu (nepředávanou parametrem při jeho volání)
s&nbsp;použitím <strong>grab</strong>:</p>

<pre>
delta := 6
f := \(x) = x * (grab delta)
&nbsp;
println(\f(7))
&nbsp;
42
</pre>

<p>Popravdě: práce s&nbsp;uzávěry není až tak elegantní, jak by tomu mohlo být
při použití odlišného způsobu zápisu.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Řídicí (rozhodovací) konstrukce</h2>

<p>Základní řídicí konstrukcí je v&nbsp;programovacím jazyku Dyon samozřejmě
konstrukce typu <strong>if-then</strong>
popř.&nbsp;<strong>if-then-else</strong>. Ta se zapisuje prakticky stejným
způsobem, jaký známe z&nbsp;Rustu, tj.&nbsp;okolo vyhodnocovaného výrazu se
nemusí psát kulaté závorky, ovšem všechny příkazy ve větvích
<strong>then</strong> a <strong>else</strong> naopak musí být uzavřeny do
blokových závorek { a }, a to i tehdy, pokud je celý blok tvořen jediným
příkazem. Nejjednodušší tvar řídicí konstrukce <strong>if-then</strong> je
následující:</p>

<pre>
x := 1
&nbsp;
if x &lt; 0 {
    println("zaporny")
}
</pre>

<p>Úplný tvar konstrukce <strong>if-then-else</strong> pak vypadá takto:</p>

<pre>
x := 1
&nbsp;
if x &lt; 0 {
    println("zaporny")
} else {
    println("nezaporny")
}
</pre>

<p>V&nbsp;případě potřeby je možné zřetězit větší množství podmínek za sebe.
Používaný způsob zápisu je následující:</p>

<pre>
x := 1
&nbsp;
if x &lt; 0 {
    println("zaporny")
} else if x == 0 {
    println("nulovy")
} else {
    println("kladny")
}
</pre>

<p>Vzhledem k&nbsp;tomu, že blok je považovaný za výraz, který může vracet
hodnotu, platí to stejné i pro celou rozhodovací konstrukci
<strong>if-then</strong>, kterou lze použít všude tam, kde je očekávaný
výraz:</p>

<pre>
x := 1
&nbsp;
println(if x &lt; 0 {"zaporny"} else {"nezaporny"})
</pre>

<p>Totéž samozřejmě platí i pro úplnou konstrukci
<strong>if-then-else</strong>:</p>

<pre>
x := 1
&nbsp;
println(if x &lt; 0 {"zaporny"} else if x == 0 {"nulovy"} else {"kladny"})
</pre>

<p>Poznámka: vzhledem k&nbsp;tomu, že je možné rozhodovací konstrukci použít ve
výrazu, nebylo nutné do Dyonu přidávat podporu pro poněkud méně čitelný
ternární operátor <strong>?:</strong>.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Programové smyčky</h2>

<p>Programové smyčky hrají v&nbsp;jazyku Dyon velmi významnou roli, takže jich
zde najdeme poměrně velké množství a navíc je speciálně programová smyčka
<strong>for</strong> navržena takovým způsobem, aby ji bylo možné různými
způsoby zkracovat. Nicméně začněme tou nejjednodušší smyčkou, která se jmenuje
přímočaře <strong>loop</strong>. Jedná se o nekonečnou smyčku, která neobsahuje
žádnou podmínku ani řídicí proměnnou. Jediná možnost, jak tuto smyčku ukončit,
spočívá v&nbsp;použití příkazu <strong>break</strong>, který zde má stejný
význam, jako je tomu v&nbsp;dalších programovacích jazycích odvozených od
céčka. Podívejme se na typický (školní) příklad smyčky, která na standardní
výstup vypíše hodnoty 0 až 10. Tuto smyčku lze realizovat následovně:</p>

<pre>
x := 0
loop {
    println(x)
    x += 1
    if x &gt; 10 {break}
}
</pre>

<p>Výstup:</p>

<pre>
0
1
2
3
4
5
6
7
8
9
10
</pre>

<p>V&nbsp;Dyonu nalezneme i počítanou smyčku typu <strong>for</strong>, kterou
lze použít různými způsoby. Podporována je především sémantika podobná céčku
(či Javě), kdy se vytvoří (deklaruje) řídicí proměnná smyčky, dále se
specifikuje podmínka pro ukončení smyčky a taktéž iterační příkaz provedený
vždy na konci každé iterace. Jednotlivé výrazy (deklarace, podmínka, iterační
příkaz) se od sebe oddělují středníkem a tělo smyčky je umístěno do bloku
ohraničeného závorkami { a }:</p>

<pre>
for x := 1; x &lt; 1000; x *= 2 {
    println(x)
}
</pre>

<p>Tato smyčka vypíše mocniny dvou:</p>

<pre>
1
2
4
8
16
32
64
128
256
512
</pre>

<p>V&nbsp;mnoha případech se smyčka <strong>for</strong> používá pro vytvoření
posloupnosti celých čísel. Samozřejmě je možné použít zápis:</p>

<pre>
for i := 0; i &lt; 10; i += 1 {
    println(i)
}
</pre>

<p>Ovšem to je zbytečně zdlouhavé a především se v&nbsp;množství kódu ztrácí
původní idea. Z&nbsp;tohoto důvodu se dá v&nbsp;jazyku Dyon použít zkrácený
zápis, kdy se uvede jen horní mez posloupnosti. Řídicí proměnná v&nbsp;takovém
případě nabývá hodnot 0, 1, 2 ... mez-1:</p>

<pre>
for i 10 {
    println(i)
}
</pre>

<p>Výstup:</p>

<pre>
0
1
2
3
4
5
6
7
8
9
</pre>

<p>Pokud je zapotřebí, aby posloupnost nezačínala nulou, používá se
v&nbsp;programovacích jazycích dosti neobvyklý zápis, který ale připomíná
matematický zápis intervalu. Povšimněte si, že první závorka je hranatá a druhá
kulatá (v&nbsp;matematice se při zápisu intervalu používají úhlové a kulaté
závorky):</p>

<pre>
for i [10,20) {
    println(i)
}
</pre>

<p>Výstupem bude v&nbsp;tomto případě řada celých čísel od 10 (včetně) do 20
(kromě):</p>

<pre>
10
11
12
13
14
15
16
17
18
19
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zkrácený zápis smyčky: automatické odvození, přes kterou sekvenci se iteruje</h2>

<pre>
a := [1,2,3,10]
&nbsp;
for i {
    println(a[i])
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Zkrácený zápis vnořených smyček</h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. Zápis často používaných typů smyček &ndash; suma, hledání maxima atd.</h2>

<pre>
a := [1,2,3,10]
b := sum i len(a) { a[i] }
println(b)
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Životnost objektů</h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. Práce s&nbsp;chybovými hodnotami</h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Většina ukázek z&nbsp;předchozích kapitol byla přidána do dvou
demonstračních příkladů, které byly uloženy do Git repositáře dostupného na
adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě
bez nutnosti klonovat celý repositář (ovšem u projektů je lepší mít celý
repositář, abyste nemuseli pracně stahovat všechny potřebné soubory):</p>

<table>
<tr><th>Příklad</th><th>Adresa</th></tr>
<tr><td>dyon-hello-world</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-hello-world/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-hello-world/Cargo.toml</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-hello-world/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-hello-world/src/main.rs</a></td></tr>
<tr><td>main.dyon</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-hello-world/src/main.dyon">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-hello-world/src/main.dyon</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>dyon-demo-1</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-demo-1/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-demo-1/Cargo.toml</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-demo-1/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-demo-1/src/main.rs</a></td></tr>
<tr><td>main.dyon</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-demo-1/src/main.dyon">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-demo-1/src/main.dyon</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na Internetu</h2>

<ol>

<li>Dyon: tutoriál<br />
<a href="http://www.piston.rs/dyon-tutorial/">http://www.piston.rs/dyon-tutorial/</a>
</li>

<li>Repositář s&nbsp;programovacím jazykem Dyon<br />
<a href="https://github.com/PistonDevelopers/dyon">https://github.com/PistonDevelopers/dyon</a>
</li>

<li>Dyon: A rusty dynamically typed scripting language<br />
<a href="https://rust.libhunt.com/project/dyon">https://rust.libhunt.com/project/dyon</a>
</li>

<li>Dyon snippets<br />
<a href="https://github.com/PistonDevelopers/dyon_snippets">https://github.com/PistonDevelopers/dyon_snippets</a>
</li>

<li>Scripting without garbage collector<br />
<a href="http://blog.piston.rs/2016/02/21/scripting-without-garbage-collector/">http://blog.piston.rs/2016/02/21/scripting-without-garbage-collector/</a>
</li>

<li>Podpora pro &bdquo;matematické&ldquo; smyčky<br />
<a href="https://github.com/PistonDevelopers/dyon/issues/119">https://github.com/PistonDevelopers/dyon/issues/119</a>
</li>

<li>Rust-clippy Wiki<br />
<a href="https://github.com/rust-lang-nursery/rust-clippy/wiki">https://github.com/rust-lang-nursery/rust-clippy/wiki</a>
</li>

<li>Rust-clippy<br />
<a href="https://rust.libhunt.com/project/rust-clippy">https://rust.libhunt.com/project/rust-clippy</a>
</li>

<li>ndarray - dokumentace k&nbsp;modulu<br />
<a href="https://bluss.github.io/rust-ndarray/master/ndarray/index.html">https://bluss.github.io/rust-ndarray/master/ndarray/index.html</a>
</li>

<li>ndarray - Crate<br />
<a href="https://crates.io/crates/ndarray">https://crates.io/crates/ndarray</a>
</li>

<li>rustup<br />
<a href="https://www.rustup.rs/">https://www.rustup.rs/</a>
</li>

<li>rustup: the Rust toolchain installer (Git repositář + dokumentace)<br />
<a href="https://github.com/rust-lang-nursery/rustup.rs">https://github.com/rust-lang-nursery/rustup.rs</a>
</li>

<li>The Rust FFI Omnibus<br />
<a href="http://jakegoulding.com/rust-ffi-omnibus/">http://jakegoulding.com/rust-ffi-omnibus/</a>
</li>

<li>Build Script Support<br />
<a href="http://doc.crates.io/build-script.html">http://doc.crates.io/build-script.html</a>
</li>

<li>Calling Rust From Python<br />
<a href="https://bheisler.github.io/post/calling-rust-in-python/">https://bheisler.github.io/post/calling-rust-in-python/</a>
</li>

<li>Calling Rust in Python (komentáře k předchozímu článku)<br />
<a href="https://www.reddit.com/r/rust/comments/63iy5a/calling_rust_in_python/">https://www.reddit.com/r/rust/comments/63iy5a/calling_rust_in_python/</a>
</li>

<li>CFFI Documentation<br />
<a href="https://cffi.readthedocs.io/en/latest/">https://cffi.readthedocs.io/en/latest/</a>
</li>

<li>Build Script Support<br />
<a href="http://doc.crates.io/build-script.html">http://doc.crates.io/build-script.html</a>
</li>

<li>Creating a shared and static library with the gnu compiler [gcc]<br />
<a href="http://www.adp-gmbh.ch/cpp/gcc/create_lib.html">http://www.adp-gmbh.ch/cpp/gcc/create_lib.html</a>
</li>

<li>ctypes — A foreign function library for Python<br />
<a href="https://docs.python.org/2/library/ctypes.html">https://docs.python.org/2/library/ctypes.html</a>
</li>

<li>FFI: Foreign Function Interface<br />
<a href="https://doc.rust-lang.org/book/ffi.html">https://doc.rust-lang.org/book/ffi.html</a>
</li>

<li>Primitive Type pointer<br />
<a href="https://doc.rust-lang.org/std/primitive.pointer.html">https://doc.rust-lang.org/std/primitive.pointer.html</a>
</li>

<li>Cargo: správce projektů a balíčků pro programovací jazyk Rust<br />
<a href="https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/">https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/</a>
</li>

<li>Network Communication and Serialization in Rust<br />
<a href="https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/">https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/</a>
</li>

<li>Crate bincode<br />
<a href="http://tyoverby.com/bincode/bincode/index.html">http://tyoverby.com/bincode/bincode/index.html</a>
</li>

<li>Struct std::fs::File<br />
<a href="https://doc.rust-lang.org/std/fs/struct.File.html">https://doc.rust-lang.org/std/fs/struct.File.html</a>
</li>

<li>Trait std::io::Seek<br />
<a href="https://doc.rust-lang.org/std/io/trait.Seek.html">https://doc.rust-lang.org/std/io/trait.Seek.html</a>
</li>

<li>Trait std::io::Read<br />
<a href="https://doc.rust-lang.org/std/io/trait.Read.html">https://doc.rust-lang.org/std/io/trait.Read.html</a>
</li>

<li>Trait std::io::Write<br />
<a href="https://doc.rust-lang.org/std/io/trait.Write.html">https://doc.rust-lang.org/std/io/trait.Write.html</a>
</li>

<li>Trait std::io::BufRead<br />
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html">https://doc.rust-lang.org/std/io/trait.BufRead.html</a>
</li>

<li>Module std::io::prelude<br />
<a href="https://doc.rust-lang.org/std/io/prelude/index.html">https://doc.rust-lang.org/std/io/prelude/index.html</a>
</li>

<li>std::net::IpAddr<br />
<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">https://doc.rust-lang.org/std/net/enum.IpAddr.html</a>
</li>

<li>std::net::Ipv4Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html</a>
</li>

<li>std::net::Ipv6Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html</a>
</li>

<li>TcpListener<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">https://doc.rust-lang.org/std/net/struct.TcpListener.html</a>
</li>

<li>TcpStream<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html">https://doc.rust-lang.org/std/net/struct.TcpStream.html</a>
</li>

<li>Binary heap (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Binary_heap">https://en.wikipedia.org/wiki/Binary_heap</a>
</li>

<li>Binární halda (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda">https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda</a>
</li>

<li>Halda (datová struktura)<br />
<a href="https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29">https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29</a>
</li>

<li>Struct std::collections::HashSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">https://doc.rust-lang.org/std/collections/struct.HashSet.html</a>
</li>

<li>Struct std::collections::BTreeSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">https://doc.rust-lang.org/std/collections/struct.BTreeSet.html</a>
</li>

<li>Struct std::collections::BinaryHeap<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html">https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html</a>
</li>

<li>Set (abstract data type)<br />
<a href="https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support">https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support</a>
</li>

<li>Associative array<br />
<a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a>
</li>

<li>Hash Table<br />
<a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a>
</li>

<li>B-tree<br />
<a href="https://en.wikipedia.org/wiki/B-tree">https://en.wikipedia.org/wiki/B-tree</a>
</li>

<li>Pedro Celis: Robin Hood Hashing (naskenované PDF!)<br />
<a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf</a>
</li>

<li>Robin Hood hashing<br />
<a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">http://codecapsule.com/2013/11/11/robin-hood-hashing/</a>
</li>

<li>Robin Hood hashing: backward shift deletion<br />
<a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/</a>
</li>

<li>Module std::collections<br />
<a href="https://doc.rust-lang.org/std/collections/">https://doc.rust-lang.org/std/collections/</a>
</li>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Struct std::collections::VecDeque<br />
<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">https://doc.rust-lang.org/std/collections/struct.VecDeque.html</a>
</li>

<li>Struct std::collections::LinkedList<br />
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">https://doc.rust-lang.org/std/collections/struct.LinkedList.html</a>
</li>

<li>Module std::fmt<br />
<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>
</li>

<li>Macro std::println<br />
<a href="https://doc.rust-lang.org/std/macro.println.html">https://doc.rust-lang.org/std/macro.println.html</a>
</li>

<li>Enum std::result::Result<br />
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">https://doc.rust-lang.org/std/result/enum.Result.html</a>
</li>

<li>Module std::result<br />
<a href="https://doc.rust-lang.org/std/result/">https://doc.rust-lang.org/std/result/</a>
</li>

<li>Result<br />
<a href="http://rustbyexample.com/std/result.html">http://rustbyexample.com/std/result.html</a>
</li>

<li>Rust stdlib: Option<br />
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">https://doc.rust-lang.org/std/option/enum.Option.html</a>
</li>

<li>Module std::option<br />
<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>
</li>

<li>Rust by example: option<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>Rust by example: if-let<br />
<a href="http://rustbyexample.com/flow_control/if_let.html">http://rustbyexample.com/flow_control/if_let.html</a>
</li>

<li>Rust by example: while let<br />
<a href="http://rustbyexample.com/flow_control/while_let.html">http://rustbyexample.com/flow_control/while_let.html</a>
</li>

<li>Rust by example: Option&lt;i32&gt;<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

