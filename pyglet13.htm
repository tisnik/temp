<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Režim přímého vykreslování (immediate mode) v&nbsp;knihovně OpenGL</a></p>
<p><a href="#k02">2. Nevýhody přímého režimu při použití na moderních grafických akcelerátorech</a></p>
<p><a href="#k03">3. Techniky, které dokážou vyřešit některé nevýhody přímého režimu</a></p>
<p><a href="#k04">4. Display listy</a></p>
<p><a href="#k05">*** 5. Knihovna Pyglet a podpora takzvaných vertex listů</a></p>
<p><a href="#k06">*** 6. </a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">*** 16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Režim přímého vykreslování (immediate mode) v&nbsp;knihovně OpenGL</h2>

<p>Ve všech předchozích částech seriálu o multimediální knihovně Pyglet, v&nbsp;nichž jsme vykreslovali dvourozměrné či trojrozměrné scény s&nbsp;použitím funkcí OpenGL, se využíval takzvaný <i>režim přímého</i> vykreslování neboli <i>immediate mode</i>. Tento režim je specifický tím, že se v&nbsp;něm používají &bdquo;příkazové závorky&ldquo; představované funkcemi <strong>glBegin()</strong> a <strong>glEnd()</strong>. U funkce <strong>glBegin()</strong> se při jejím volání specifikuje typ grafického primitiva (body, úsečky, polyčáry, trojúhelníky, trsy trojúhelníků atd.) a mezi <strong>glBegin()</strong> a <strong>glEnd()</strong> je možné zadávat libovolné množství souřadnic vrcholů, barev vrcholů, souřadnic v&nbsp;prostoru textur (<i>texture space</i>) atd. Přímý režim vykreslování přináší programátorům jednu podstatnou výhodu &ndash; jeho použití je jednoduché a snadno pochopitelné. To mj.&nbsp;znamená, že je k&nbsp;dispozici množství návodů, jak přímý režim použít. Dále se při použití přímého režimu nemusí předem alokovat žádná paměť na grafickém akcelerátoru, což opět zjednodušuje výsledný zdrojový kód.</p>

<p>Jen pro připomenutí si ukažme, jak vypadá část programu používající přímý režim:</p>

<pre>
def draw_walls():
    glBegin(GL_QUADS)                         # vykresleni otevrene krychle - sten domecku
    glColor3f(0.0, 0.0, 1.0)                  # modra barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0, -5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 5.0, -5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f( 5.0, -5.0, -5.0)

    glColor3f(0.0, 1.0, 0.0)                  # zelena barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f( 5.0,  5.0, -5.0)

    glColor3f(1.0, 0.0, 0.0)                  # cervena barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0, -5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f(-5.0,  5.0, -5.0)

    glColor3f(1.0, 1.0, 0.0)                  # zluta barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f( 5.0, -5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f( 5.0, -5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f( 5.0,  5.0, -5.0)
    glEnd()
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nevýhody přímého režimu při použití na moderních grafických akcelerátorech</h2>

<p>Přímý režim má však také několik nevýhod, které nakonec vedly k&nbsp;tomu, že se s&nbsp;jeho použitím v&nbsp;mnoha moderních aplikacích nesetkáme. Tyto nevýhody dokonce způsobily, že v&nbsp;novějších verzích OpenGL již není přímý režim oficiálně podporován, což je na jednu stranu škoda (začínající programátoři to mají mnohem těžší), na druhou stranu je však vývoj OpenGL pochopitelně diktován zájmy těch firem, které za rozvojem této knihovny stojí. Jaké jsou tedy největší nevýhody přímého režimu?</p>

<ul>

<li>Pro každý snímek vykreslované trojrozměrné scény je nutné přenášet (mnohdy ta stejná) data neustále znovu, což je z&nbsp;pohledu moderních grafických akcelerátorů velmi pomalá a navíc neefektivní operace, která navíc může zdržovat i další činnosti počítače (přenos dat na disk atd.).</li>

<li>Grafický akcelerátor může začít vykreslovat stěny těles až ve chvíli, kdy jsou do jeho paměti přenesena všechna potřebná data. Nicméně z&nbsp;hlediska architektury aplikace je vykreslování zdrženo, protože typicky se v&nbsp;OpenGL provádí operace v&nbsp;tomto pořadí: prohoď buffery &rarr; vymaž zadní buffer &rarr; teprve poté začni vykreslovat. To přináší zbytečné zdržení.</li>

<li>Navíc je nutné podotknout, že data zapisovaná &bdquo;přímo&ldquo; funkcemi typu <strong>glVertex*</strong>, <strong>glTexCoord*</strong> či <strong>glColor*</strong> musí být nejdříve zpracována mikroprocesorem, serializována a teprve poté přenesena do grafického akcelerátoru. Opět se jedná o mnohdy zbytečnou komplikaci.</li>

<li>Přímý režim typicky vyžaduje klasickou &bdquo;pevnou&ldquo; vykreslovací pipeline, zatímco moderní GPU jsou plně programovatelné.</li>

</ul>



<p><a name="k03"></a></p>
<h2 id="k03">3. Techniky, které dokážou vyřešit některé nevýhody přímého režimu</h2>

<p>Volání každé funkce s&nbsp;sebou nese poměrně značné množství práce pro mikroprocesor, zejména přesun dat mezi registry procesoru, pamětí a zásobníkem a také skok do funkce a návrat z&nbsp;funkce (snížení účinnosti cache paměti z&nbsp;hlediska lokálnosti odkazů a přepínání mezi ringy). Proto by bylo vhodné co nejvíce snížit množství volání funkcí nutných pro vykreslení dané scény, ideálně použít například jen jediné volání funkce pro vykreslení každého tělesa. Existuje více možností vedoucích ke snížení počtu volaných funkcí, které se liší svou složitostí, vyjadřovací schopností (tj.&nbsp;které grafické efekty lze, popř.&nbsp;naopak nelze vytvořit) a rychlostí vlastního vykreslení:</p>

<p>Historicky nejstarší možností je použití takzvaných <i>display listů</i>, kdy se příkazy nutné pro vytvoření tělesa zapíšou do display listu a ten se poté zavolá pomocí jediné funkce. Výhodou tohoto postupu je, že data uložená v&nbsp;display listu jsou v&nbsp;ideálním případě zapsána přímo do paměti grafického akcelerátoru a při každém vykreslení tedy není nutné tato data přenášet po sběrnici, což je v&nbsp;dnešní době (se současnými sběrnicemi a grafickými akcelerátory) nejvíce zpomalující operace (bottle neck) při vykreslování trojrozměrných scén.</p>

<p>Další možností je použití pole vrcholů (<i>vertex arrays</i>), kdy jsou data pro jednotlivé vrcholy uložena ve vhodně organizovaném poli a následně je umožněno poslání dat vrcholů pomocí několika málo funkčních volání. Výhodou tohoto přístupu je, že se mezi jednotlivými snímky mohou měnit data jednotlivých vrcholů (barva, poloha apod.), což v&nbsp;případě display listů nebylo možné, protože by se při jakékoliv změně musel vytvořit nový display list.</p>

<p>Z&nbsp;původních polí vrcholů se postupně vyvinuly takzvané <i>Vertex Buffer Object</i> mnohdy zkracované na <i>VBO</i>. Pole vrcholů jsou alokována v&nbsp;paměti grafického akcelerátoru, takže data v&nbsp;nich uložená jsou dostupná ještě před začátkem vykreslování celé scény, což je velmi důležité, neboť se celý proces vykreslování významným způsobem urychluje. V&nbsp;současnosti představují <i>VBO</i> prakticky nejrychlejší možnost, kterou nám klasické 3D akcelerátory nabízí. Navíc je možné data zpracovávat konfigurovatelnými shadery, což nebylo u přímého režimu možné.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Display listy</h2>

<p>Display-listy si můžeme představit jako makra, do kterých se nahraje několik příkazů OpenGL, a tato makra lze potom jedním příkazem &bdquo;spustit&ldquo;. Výhodou display-listů je na jedné straně zvýšená rychlost vykreslování, protože display-listy jsou většinou uloženy přímo v&nbsp;paměti grafického akcelerátoru, na straně druhé také zjednodušení kódu pro vykreslování komplikovaných scén. Je například možné 3D modely jednotlivých těles ukládat do samostatných display-listů a složitou scénu potom vykreslit pouze zavoláním těchto display listů s&nbsp;vhodně nastavenou transformační maticí.</p>

<p>Začátek záznamu do display-listu se povolí příkazem <strong>glNewList()</strong>, ukončení záznamu příkazem <strong>glEndList()</strong>. V&nbsp;příkazu <strong>glNewList(list, mode)</strong> zadáváme dva parametry. První celočíselný parametr list představuje identifikátor vytvořeného display-listu. Pomocí tohoto identifikátoru můžeme display-list vyvolat. Druhý parametr mode určuje, zda se má display-list pouze vytvořit (hodnota <strong>GL_COMPILE</strong>), nebo vytvořit a přímo provést (hodnota <strong>GL_COMPILE_AND_EXECUTE</strong>). Většina volání příkazů OpenGL (jsou však výjimky) je do display-listu zaznamenána, ostatní příkazy se samozřejmě provedou.</p>

<p>Provedení display-listu (tj.&nbsp;vyvolání příkazů uložených v&nbsp;display-listu) zajistíme funkcí <strong>glCallList(list)</strong>, v&nbsp;jejímž parametru list je uložen identifikátor dříve vytvořeného display-listu.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Knihovna Pyglet a podpora takzvaných vertex listů</h2>

<p>Při použití multimediální knihovny Pyglet se nemusíme zabývat tím, jak bude vykreslování provedeno na nižší úrovni (tedy na úrovni OpenGL), protože Pyglet programátorům nabízí velmi užitečnou datovou abstrakci nazvanou <i>vertex list</i>. Tento název poměrně dobře odpovídá tomu, jak jsou vertex listy konstruovány &ndash; programátor musí při jejich vytváření přesně specifikovat formát zapisovaných údajů, tj.&nbsp;které atributy jednotlivých vertexů (vrcholů) budou explicitně specifikovány a jaký budou mít formát. Mezi podporované atributy patří zejména souřadnice ve 2D či v&nbsp;3D prostoru, texturovací souřadnice, barvy vrcholů a normálové vektory vrcholů. Následně se vykreslení celého vertex listu (ten může představovat například samostatné těleso ve scéně) provede jediným příkazem. Specifikace dat pro vertex list je velmi flexibilní a poměrně jednoduché, zejména v&nbsp;porovnání s&nbsp;<i>VBO</i> vytvářenými v&nbsp;jazycích typu C či C++. Některé možnosti vertex listů si představíme v&nbsp;demonstračních příkladech.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

nearPlane = 0.1                            # blizsi orezavaci rovina
farPlane = 90.0                            # vzdalenejsi orezavaci rovina

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

keys = key.KeyStateHandler()
window.push_handlers(keys)


def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)       # barva pozadi obrazku


@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)        # viditelna oblast pres cele okno


def prepare_scene():
    # seznamu vertexu
    # parametry:
    #     v2f - format: vertex se dvema souradnicemi typu 'float'
    #     ()  - n-tice s osmi vertexy (8x2 = 16 hodnot typu 'float')
    return ('v2f', (-0.5, -0.5,
                    -0.5, +0.5,
                    +0.5, +0.5,
                    +0.5, -0.5,
                    +0.2, +0.2,
                    -0.2, -0.2,
                    -0.2, +0.2,
                    +0.2, -0.2))


def draw_scene():
    global vertex_list
    # prime vykresleni ctyr usecek, kazda je reprezentovana dvojici vertexu
    pyglet.graphics.draw(8, GL_LINES, vertex_list)


def clear_buffers():
    # vymazani vsech bitovych rovin barvoveho bufferu
    glClear(GL_COLOR_BUFFER_BIT)


def set_projection_matrix(nearPlane, farPlane):
    # zacatek modifikace projekcni matice
    glMatrixMode(GL_PROJECTION)
    # vymazani projekcni matice (=identita)
    glLoadIdentity()


def set_modelview_matrix():
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                       # nahrat jednotkovou matici


@window.event
def on_draw():
    clear_buffers()
    set_projection_matrix(nearPlane, farPlane)
    set_modelview_matrix()
    draw_scene()                    # vykresleni sceny


vertex_list = prepare_scene()
pyglet.app.run()
</pre>


<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

nearPlane = 0.1                            # blizsi orezavaci rovina
farPlane = 90.0                            # vzdalenejsi orezavaci rovina

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

keys = key.KeyStateHandler()
window.push_handlers(keys)


def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)       # barva pozadi obrazku


@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)        # viditelna oblast pres cele okno


def prepare_scene():
    # priprava seznamu vertexu
    # parametry:
    #     8   - pocet vertexu
    #     v2f - format: vertex se dvema souradnicemi typu 'float'
    #     ()  - n-tice s osmi vertexy (8x2 = 16 hodnot typu 'float')
    return pyglet.graphics.vertex_list(8, ('v2f', (-0.5, -0.5,
                                                   -0.5, +0.5,
                                                   +0.5, +0.5,
                                                   +0.5, -0.5,
                                                   +0.2, +0.2,
                                                   -0.2, -0.2,
                                                   -0.2, +0.2,
                                                   +0.2, -0.2)))


def draw_scene():
    global vertex_list
    # vykresleni ctyr usecek, data o useckach jsou ulozeny ve vertex listu
    vertex_list.draw(GL_LINES)


def clear_buffers():
    # vymazani vsech bitovych rovin barvoveho bufferu
    glClear(GL_COLOR_BUFFER_BIT)


def set_projection_matrix(nearPlane, farPlane):
    # zacatek modifikace projekcni matice
    glMatrixMode(GL_PROJECTION)
    # vymazani projekcni matice (=identita)
    glLoadIdentity()


def set_modelview_matrix():
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                       # nahrat jednotkovou matici


@window.event
def on_draw():
    clear_buffers()
    set_projection_matrix(nearPlane, farPlane)
    set_modelview_matrix()
    draw_scene()                    # vykresleni sceny


vertex_list = prepare_scene()
pyglet.app.run()
</pre>


<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

nearPlane = 0.1                            # blizsi orezavaci rovina
farPlane = 90.0                            # vzdalenejsi orezavaci rovina

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

keys = key.KeyStateHandler()
window.push_handlers(keys)


def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)       # barva pozadi obrazku


@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)        # viditelna oblast pres cele okno


def prepare_scene():
    # priprava seznamu vertexu
    # parametry:
    #     8   - pocet vertexu
    #     v2f - format: vertex se dvema souradnicemi typu 'float'
    #     ()  - n-tice s osmi vertexy (8x2 = 16 hodnot typu 'float')
    #     c3b - format: barva se tremi slozkami typu 'byte'
    #     ()  - n-tice s osmi barvami (8x3 = 24 hodnot typu 'byte')
    return pyglet.graphics.vertex_list(8, ('v2f', (-0.5, -0.5,
                                                   -0.5, +0.5,
                                                   +0.5, +0.5,
                                                   +0.5, -0.5,
                                                   +0.2, +0.2,
                                                   -0.2, -0.2,
                                                   -0.2, +0.2,
                                                   +0.2, -0.2)),
                                          ('c3B', (0xff, 0x00, 0xff,
                                                   0xff, 0xff, 0x00,
                                                   0x00, 0x00, 0xff,
                                                   0x00, 0xff, 0x00,
                                                   0x00, 0xff, 0xff,
                                                   0xff, 0x00, 0xff,
                                                   0x00, 0xff, 0xff,
                                                   0xff, 0xff, 0x00)))


def draw_scene():
    global vertex_list
    # vykresleni ctyr usecek, data o useckach jsou ulozeny ve vertex listu
    vertex_list.draw(GL_LINES)


def clear_buffers():
    # vymazani vsech bitovych rovin barvoveho bufferu
    glClear(GL_COLOR_BUFFER_BIT)


def set_projection_matrix(nearPlane, farPlane):
    # zacatek modifikace projekcni matice
    glMatrixMode(GL_PROJECTION)
    # vymazani projekcni matice (=identita)
    glLoadIdentity()


def set_modelview_matrix():
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                       # nahrat jednotkovou matici


@window.event
def on_draw():
    clear_buffers()
    set_projection_matrix(nearPlane, farPlane)
    set_modelview_matrix()
    draw_scene()                    # vykresleni sceny


vertex_list = prepare_scene()
pyglet.app.run()
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<pre>
#!/usr/bin/env python

import pyglet


def prepare_scene():
    # priprava seznamu vertexu
    # parametry:
    #     8   - pocet vertexu
    #     v2f - format: vertex se dvema souradnicemi typu 'float'
    #     ()  - n-tice s osmi vertexy (8x2 = 16 hodnot typu 'float')
    #     c3b - format: barva se tremi slozkami typu 'byte'
    #     ()  - n-tice s osmi barvami (8x3 = 24 hodnot typu 'byte')
    return pyglet.graphics.vertex_list(8, ('v2f', (-0.5, -0.5,
                                                   -0.5, +0.5,
                                                   +0.5, +0.5,
                                                   +0.5, -0.5,
                                                   +0.2, +0.2,
                                                   -0.2, -0.2,
                                                   -0.2, +0.2,
                                                   +0.2, -0.2)),
                                          ('c3B', (0xff, 0x00, 0xff,
                                                   0xff, 0xff, 0x00,
                                                   0x00, 0x00, 0xff,
                                                   0x00, 0xff, 0x00,
                                                   0x00, 0xff, 0xff,
                                                   0xff, 0x00, 0xff,
                                                   0x00, 0xff, 0xff,
                                                   0xff, 0xff, 0x00)))


def print_array(name, array):
    print(name)
    print("   type: %s" % type(array))
    print("   length: %d" % len(array))
    print("   content:")
    for element in array:
        print("        %6.1f" % element)


vertex_list = prepare_scene()

print("Vertex list size: %d" % vertex_list.get_size())
print_array("Colors:", vertex_list.colors)
print_array("Vertices:", vertex_list.vertices)
</pre>


<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Pyglet: Module Hierarchy<br />
<a href="https://pythonhosted.org/pyglet/api/module-tree.html">https://pythonhosted.org/pyglet/api/module-tree.html</a>
</li>

<li>Learning Modern OpenGL<br />
<a href="https://www.codeproject.com/articles/771225/learning-modern-opengl">https://www.codeproject.com/articles/771225/learning-modern-opengl</a>
</li>

<li>OpenGL Utility Library<br />
<a href="https://en.wikipedia.org/wiki/OpenGL_Utility_Library">https://en.wikipedia.org/wiki/OpenGL_Utility_Library</a>
</li>

<li>GLU Specification<br />
<a href="https://www.opengl.org/registry/doc/glu1.3.pdf">https://www.opengl.org/registry/doc/glu1.3.pdf</a>
</li>

<li>The Perlin noise math FAQ<br />
<a href="https://mzucker.github.io/html/perlin-noise-math-faq.html">https://mzucker.github.io/html/perlin-noise-math-faq.html</a>
</li>

<li>Perlin noise<br />
<a href="https://en.wikipedia.org/wiki/Perlin_noise">https://en.wikipedia.org/wiki/Perlin_noise</a>
</li>

<li>Perlin Noise Generator (Python recipe)<br />
<a href="http://code.activestate.com/recipes/578470-perlin-noise-generator/">http://code.activestate.com/recipes/578470-perlin-noise-generator/</a>
</li>

<li>Simplex noise demystified<br />
<a href="http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf">http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf</a>
</li>

<li>glTexEnv - příkaz OpenGL<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml</a>
</li>

<li>glGetTexEnv - příkaz OpenGL<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml</a>
</li>

<li>Pyglet Home Page<br />
<a href="https://bitbucket.org/pyglet/pyglet/wiki/Home">https://bitbucket.org/pyglet/pyglet/wiki/Home</a>
</li>

<li>Pyglet: dokumentace k verzi 1.2<br />
<a href="https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/">https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/</a>
</li>

<li>Dokumentace k verzi 1.2 ve formátu PDF<br />
<a href="https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/">https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/</a>
</li>

<li>PyOpenGL<br />
<a href="http://pyopengl.sourceforge.net/">http://pyopengl.sourceforge.net/</a>
</li>

<li>The #! magic, details about the shebang/hash-bang mechanism on various Unix flavours<br />
<a href="https://www.in-ulm.de/~mascheck/various/shebang/">https://www.in-ulm.de/~mascheck/various/shebang/</a>
</li>

<li>Shebang (Unix)<br />
<a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29">https://en.wikipedia.org/wiki/Shebang_%28Unix%29</a>
</li>

<li>Domovská stránka systému LÖVE<br />
<a href="http://love2d.org/">http://love2d.org/</a>
</li>

<li>Simple DirectMedia Layer (home page)<br />
<a href="http://www.libsdl.org/">http://www.libsdl.org/</a>
</li>

<li>Simple DirectMedia Layer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer">https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer</a>
</li>

<li>Seriál Grafická knihovna OpenGL<br />
<a href="https://www.root.cz/serialy/graficka-knihovna-opengl/">https://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Pyglet event loop<br />
<a href="http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html">http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html</a>
</li>

<li>Decorators I: Introduction to Python Decorators<br />
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a>
</li>

<li>3D Programming in Python - Part 1 <br />
<a href="https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/">https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/</a>
</li>

<li>A very basic Pyglet tutorial<br />
<a href="http://www.natan.termitnjak.net/tutorials/pyglet_basic.html">http://www.natan.termitnjak.net/tutorials/pyglet_basic.html</a>
</li>

<li>Alpha blending<br />
<a href="https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending">https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel TiĹĄnovskĂ˝</a> &nbsp; 2017</small></p>
</body>
</html>

