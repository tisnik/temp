<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Vykreslování grafů do framebufferu Raspberry Pi s použitím knihoven Pygame a Matplotlib</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>>Vykreslování grafů do framebufferu Raspberry Pi s použitím knihoven Pygame a Matplotlib</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Vzhledem k&nbsp;tomu, že je možné k&nbsp;Raspberry Pi připojit monitor popř.&nbsp;i (dotykový) displej, lze tyto oblíbené jednodeskové mikropočítače použít k&nbsp;zobrazování naměřených či vypočtených hodnot formou různých grafů. K&nbsp;dispozici je celá řada nástrojů, které je možné pro zobrazení grafů použít. My se dnes seznámíme s&nbsp;kombinací knihovny Matplotlib s&nbsp;Pygame.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. >Vykreslování grafů do framebufferu Raspberry Pi s&nbsp;použitím knihoven Pygame a Matplotlib</a></p>
<p><a href="#k02">2. Vytvoření grafu s&nbsp;jeho uložením do souboru</a></p>
<p><a href="#k03">*** 3. Vykreslení grafu knihovnou Pygame</a></p>
<p><a href="#k04">4. Výběr framebufferu</a></p>
<p><a href="#k05">5. Zdrojový kód prvního demonstračního příkladu</a></p>
<p><a href="#k06">*** 6. Úprava parametrů grafu</a></p>
<p><a href="#k07">7. Zdrojový kód druhého demonstračního příkladu</a></p>
<p><a href="#k08">*** 8. Specifikace rozlišení obrázku s&nbsp;grafem</a></p>
<p><a href="#k09">9. Zobrazení grafu ve středu obrazovky</a></p>
<p><a href="#k10">10. Zdrojový kód třetího demonstračního příkladu</a></p>
<p><a href="#k11">11. Vytvoření obrázku v&nbsp;&bdquo;nativním&ldquo; rozlišení</a></p>
<p><a href="#k12">*** 12. Zjištění aktuálně nastaveného rozlišení framebufferu</a></p>
<p><a href="#k13">*** 13. Zdrojový kód čtvrtého demonstračního příkladu</a></p>
<p><a href="#k14">14. Odlišný typ grafu &ndash; kontury</a></p>
<p><a href="#k15">15. Zdrojový kód pátého demonstračního příkladu</a></p>
<p><a href="#k16">*** 16. Články o knihovnách NumPy, Matplotlib a Pygame</a></p>
<p><a href="#k17">*** 17. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k18">18. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Vykreslování grafů do framebufferu Raspberry Pi s&nbsp;použitím knihoven Pygame a Matplotlib</h2>

<p>S&nbsp;knihovnami <i>Matplotlib</i> a <i>Pygame</i> jsme se již na tomto serveru několikrát setkali (viz též <a href="#17">sedmnáctou kapitolu s&nbsp;odkazy na dříve vydané články</a>), takže již víme, že Matplotlib je knihovna určená pro programovací jazyk Python, která slouží k&nbsp;tvorbě a částečně i k&nbsp;interaktivním úpravám různých typů grafů, například klasických grafů funkcí jedné proměnné, ovšem i mnoha grafů více či méně složitějších (grafy více funkcí, trojrozměrné grafy, polární grafy, zobrazení kontur atd.). Možnosti knihovny Matplotlib jsou skutečně značně široké a přitom je její použití poměrně jednoduché a snadno pochopitelné, pokud samozřejmě vynecháme některé pokročilejší operace. Jednou ze zajímavých možností představuje použití této knihovny v&nbsp;interaktivním prostředí IPython popř.&nbsp;IPython Notebook, zejména v&nbsp;kombinaci s&nbsp;další populární Pythonovskou knihovnou Numpy.</p>

<img class="alignnone size-medium wp-image-6844" src="https://mojefedora.cz/wp-content/uploads/2016/04/08-450x275.png" alt="08" width="450" height="275" />
<p><i>Obrázek 1: Knihovnu matplotlib je možné použít i interaktivně v&nbsp;IPythonu či v&nbsp;IPython Notebooku.</i></p>

<p>V&nbsp;mnoha projektech by bylo užitečné využít možnosti nabízené knihovnou Matplotlib i pro aplikace typické pro jednodeskové mikropočítače Raspberry Pi &ndash; měření různých veličin, ovládání dalších zařízení atd. K&nbsp;Raspberry Pi je samozřejmě možné připojit monitor přes rozhraní HDMI popř.&nbsp;lze připojit i dotykový displej, takže potřebný video výstup je zajištěn. Zbývá doprogramovat pouze &bdquo;maličkost&ldquo;  &ndash; vykreslení grafů do <i>framebufferu</i> (video paměti), abychom se obešli bez nutnosti mít spuštěný X Window System. K&nbsp;dosažení tohoto účelu zkombinujeme možnosti knihovny Matplotlib s&nbsp;další nám již známou knihovnou Pygame. Tyto knihovny nepropojíme přímo, ale využijeme meziuložení grafu na disk (či ještě lépe do ramdisku) do rastrového obrázku. Hned na úvod je nutné říci, že se sice v&nbsp;žádném případě nejedná o nejrychlejší řešení, na druhou stranu je však Matplotlib velmi flexibilní a Pygame může sloužit pro interaktivní ovládání Raspberry Pi.</p>

<img class="alignnone size-medium wp-image-6855" src="https://mojefedora.cz/wp-content/uploads/2016/04/19-450x369.png" alt="19" width="450" height="369" />
<p><i>Obrázek 2: Vykreslení průběhu funkce s&nbsp;využitím pouhých pěti příkazů (z&nbsp;toho dva příkazy slouží k&nbsp;importu knihoven).</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vytvoření grafu s&nbsp;jeho uložením do souboru</h2>

<p>Pro jednoduchost si zvolme graf funkce sinus. Pro výpočet průběhu této funkce použijeme knihovnu <i>Numpy</i>, pro vykreslení pak knihovnu <i>Matplotlib</i>. Povšimněte si velmi důležitého druhého řádku, kterým se určuje, jaký &bdquo;backend&ldquo; má <i>Matplotlib</i> použít. Zde vyžadujeme použití Agg (nativní knihovna pro C++), což nám umožní spustit aplikaci z&nbsp;konzole (bez X Window Systemu):</p>

<pre>
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import numpy as np
</pre>

<p>Následně je pomocí funkce <strong>numpy.linspace()</strong> vytvořeno pole sta prvků s&nbsp;hodnotami od 0 do 2&pi;. Na toto pole je aplikována funkce <strong>numpy.sin()</strong>, jejímž výsledkem je nové stoprvkové pole (hodnoty prvků leží v&nbsp;rozsahu od -1 do 1). Funkcí <strong>matplotlib.pyplot.plot()</strong> je vykreslen průběh funkce, ovšem graf ještě není zobrazen, takže do něj můžeme přidat popis obou os. Z&nbsp;funkce vrátíme objekt plně popisující vykreslovaný graf, jeho rozměry, osy apod:</p>

<pre>
# Vytvoreni grafu
def create_graph():
    fig = plt.figure()
    x = np.linspace(0, 2*np.pi, 100)
    y = np.sin(x)
    plt.plot(x, y)
    plt.xlabel("x")
    plt.ylabel("sin(x)")
    return fig
</pre>

<p>Další funkce uloží graf do souboru pomocí metody <strong>savefig()</strong>, které se v&nbsp;nejjednodušším případě předá pouze jméno výstupního souboru. Tato funkce pak na základě analýzy přípony souboru rozhodne o tom, který formát použije. K&nbsp;dispozici jsou mj.&nbsp;tyto formáty:</p>

<table>
<tr><th>#</th><th>Koncovka</th><th>Formát</th></tr>
<tr><td>1</td><td>png</td><td>rastrový formát <a href="http://www.root.cz/clanky/png-is-not-gif/">PNG</a></td></tr>
<tr><td>2</td><td>pdf</td><td>dokument ve formátu PDF s&nbsp;vektorovým grafem</td></tr>
<tr><td>3</td><td>eps</td><td>vektorový formát Encapsulated PostScript (varianta PostScriptu určená pro vložení do dalších dokumentů, včetně (La)TeXu)</td></tr>
<tr><td>4</td><td>ps </td><td>vektorový formát <a href="http://www.root.cz/clanky/graficky-metaformat-postscript/">PostScript</a></td></tr>
<tr><td>5</td><td>svg</td><td>vektorový formát <a href="http://www.root.cz/clanky/vektorovy-graficky-format-svg/">SVG</a></td></tr>
</table>

<p>Realizace uložení do souboru bude (prozatím) triviální:</p>

<pre>
# Ulozeni grafu do souboru
def save_graph(fig, imageFile):
    plt.savefig(imageFile)
</pre>

<img class="alignnone size-medium wp-image-7006" src="https://mojefedora.cz/wp-content/uploads/2016/04/figure_02-450x339.png" alt="figure_02" width="450" height="339" />
<p><i>Obrázek 3: Průběh funkce sin(x) vykreslený nepatrně upraveným demonstračním příkladem.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vykreslení grafu knihovnou Pygame</h2>

<p></p>

<pre>
# Inicializace knihovny Pygame, inicializace video systemu a otevreni framebufferu
def initialize_pygame(width, height, background_color):
    pygame.init()
    screen = pygame.display.set_mode([width, height])
    pygame.mouse.set_visible(0)
    screen.fill(background_color)
    return screen
</pre>

<pre>
# Zobrazeni rastroveho obrazku do framebufferu
def show_image(screen, imageFile):
    image = pygame.image.load(imageFile)
    screen.blit(image, (0,0))
    pygame.display.flip()
</pre>

<pre>
# Cekani na ukonceni aplikace libovolnou klavesou
def wait_for_key():
    clock = pygame.time.Clock()
    while True:
        for event in pygame.event.get():
            if event.type == QUIT:
                return
            if event.type == KEYDOWN:
                return
        clock.tick(20)
</pre>

<img class="alignnone size-medium wp-image-7008" src="http://mojefedora.cz/wp-content/uploads/2016/04/figure_04-450x339.png" alt="figure_04" width="450" height="339" />
<p><i>Obrázek 4: Různé styly vykreslování. Povšimněte si, že v&nbsp;grafu je v&nbsp;levém dolním rohu zobrazena i legenda.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výběr framebufferu</h2>

<p>Linuxové jádro může obsluhovat větší množství framebufferů. U počítačů Raspberry Pi je vždy k&nbsp;dispozici framebuffer realizovaný přes čip <strong>BCM270x</strong>, který má v&nbsp;operační paměti vyhrazený prostor, jenž je framebufferem využíván (velikost videopaměti je konfigurovatelná, projeví se po restartu systému). Kromě toho je však možné k&nbsp;Raspberry Pi připojit například dotykový displej, který se mnohdy též ovládá přes framebuffer v&nbsp;závislosti na konkrétním ovladači. Proto je nejdříve nutné zjistit, který framebuffer bude naše aplikace používat. Ke zjištění všech dostupných framebufferů slouží nástroj nazvaný <strong>fbset</strong>, který spustíme s&nbsp;parametry -v a -i:</p>

<pre>
fbset -v -i
</pre>

<p>Pokud je použita standardní konfigurace Raspbiannu, měly by se vypsat zhruba následující informace. Konkrétní rozlišení samozřejmě může být odlišné, protože závisí na typu připojeného monitoru:</p>

<pre>
Linux Frame Buffer Device Configuration Version 2.1 (23/06/1999)
(C) Copyright 1995-1999 by Geert Uytterhoeven

Opening frame buffer device `/dev/fb0'
Using current video mode from `/dev/fb0'

mode "1280x1024"
    geometry 1280 1024 1280 1024 16
    timings 0 0 0 0 0 0 0
    rgba 5/11,6/5,5/0,0/16
endmode

Getting further frame buffer information
Frame buffer device information:
    Name        : BCM2708 FB
    Address     : 0x1c006000
    Size        : 2621440
    Type        : PACKED PIXELS
    Visual      : TRUECOLOR
    XPanStep    : 1
    YPanStep    : 1
    YWrapStep   : 0
    LineLength  : 2560
    Accelerator : No
</pre>

<p>Vypsané jméno zařízení realizující přístup do framebufferu (<strong>/dev/fb0</strong>) použijeme v&nbsp;našem příkladu, protože před inicializací knihovny Pygame nastavíme proměnnou prostředí <strong>SDL_FBDEV</strong> a přiřadíme jí jméno zařízení s&nbsp;framebufferem. Funkce <strong>initialize_pygame()</strong> se tedy nepatrně změní:</p>

<pre>
# Inicializace knihovny Pygame, inicializace video systemu a otevreni framebufferu
def initialize_pygame(width, height, background_color, framebuffer_device):
    os.environ["SDL_FBDEV"] = framebuffer_device
    pygame.init()
    screen = pygame.display.set_mode([width, height])
    pygame.mouse.set_visible(0)
    screen.fill(background_color)
    return screen
</pre>

<p>Volání této funkce bude samozřejmě taktéž nepatrně modifikováno, protože jí kromě požadovaných rozměrů okna a barvy pozadí předáme i jméno zařízení s&nbsp;framebufferem:</p>

<pre>
# jmeno zarizeni implementujiciho rozhrani k framebufferu
FRAMEBUFFER_DEVICE = "/dev/fb0"
screen = initialize_pygame(WIDTH, HEIGHT, (0, 0, 200), FRAMEBUFFER_DEVICE)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zdrojový kód prvního demonstračního příkladu</h2>

<p>Všechny funkce popsané v&nbsp;předchozích třech kapitolách nyní použijeme v&nbsp;dnešním prvním demonstračním příkladu, který vytvoří graf, uloží ho do souboru, inicializuje knihovnu Pygame, vykreslí obrázek s&nbsp;grafem a následně čeká na stisk klávesy (poté se program ukončí):</p>

<pre>
# Hlavni funkce aplikace
def main():
    fig = create_graph()
    save_graph(fig, IMAGE_FILE)
    screen = initialize_pygame(WIDTH, HEIGHT, (0, 0, 200), FRAMEBUFFER_DEVICE)
    show_image(screen, IMAGE_FILE)
    wait_for_key()
    exit()
</pre>

<p>Úplný zdrojový kód prvního demonstračního příkladu vypadá následovně:</p>

<pre>
#!/usr/bin/python
# vim: set fileencodings=utf-8

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import numpy as np
import pygame
import os
import sys

# nutno importovat kvuli konstantam QUIT atd.
from pygame.locals import *

# velikost okna na obrazovce (framebufferu)
WIDTH = 640
HEIGHT = 480

# jmeno souboru s grafem
IMAGE_FILE = "plot1.png"

# jmeno zarizeni implementujiciho rozhrani k framebufferu
FRAMEBUFFER_DEVICE = "/dev/fb0"



# Vytvoreni grafu
def create_graph():
    fig = plt.figure()
    x = np.linspace(0, 2*np.pi, 100)
    y = np.sin(x)
    plt.plot(x, y)
    plt.xlabel("x")
    plt.ylabel("sin(x)")
    return fig



# Ulozeni grafu do souboru
def save_graph(fig, imageFile):
    plt.savefig(imageFile)



# Inicializace knihovny Pygame, inicializace video systemu a otevreni framebufferu
def initialize_pygame(width, height, background_color, framebuffer_device):
    os.environ["SDL_FBDEV"] = framebuffer_device
    pygame.init()
    screen = pygame.display.set_mode([width, height])
    pygame.mouse.set_visible(0)
    screen.fill(background_color)
    return screen



# Zobrazeni rastroveho obrazku do framebufferu
def show_image(screen, imageFile):
    image = pygame.image.load(imageFile)
    screen.blit(image, (0,0))
    pygame.display.flip()



# Cekani na ukonceni aplikace libovolnou klavesou
def wait_for_key():
    clock = pygame.time.Clock()
    while True:
        for event in pygame.event.get():
            if event.type == QUIT:
                return
            if event.type == KEYDOWN:
                return
        clock.tick(20)



# Ukonceni aplikace
def exit():
    pygame.quit()
    sys.exit()


# Hlavni funkce aplikace
def main():
    fig = create_graph()
    save_graph(fig, IMAGE_FILE)
    screen = initialize_pygame(WIDTH, HEIGHT, (0, 0, 200), FRAMEBUFFER_DEVICE)
    show_image(screen, IMAGE_FILE)
    wait_for_key()
    exit()



# Vstupni bod
if __name__ == "__main__":
    main()
</pre>

*** image ***
<p><i>Obrázek 5: Obrázek vygenerovaný prvním demonstračním příkladem.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Úprava parametrů grafu</h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zdrojový kód druhého demonstračního příkladu</h2>

<p>Druhý příklad se od příkladu prvního liší pouze úpravou funkce <strong>save_graph()</strong> a změnou názvu pracovního souboru s&nbsp;uloženým grafem:</p>

<pre>
#!/usr/bin/python
# vim: set fileencodings=utf-8

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import numpy as np
import pygame
import os
import sys

# nutno importovat kvuli konstantam QUIT atd.
from pygame.locals import *

# velikost okna na obrazovce (framebufferu)
WIDTH = 640
HEIGHT = 480

# jmeno souboru s grafem
IMAGE_FILE = "plot2.png"

# jmeno zarizeni implementujiciho rozhrani k framebufferu
FRAMEBUFFER_DEVICE = "/dev/fb0"



# Vytvoreni grafu
def create_graph():
    fig = plt.figure()
    x = np.linspace(0, 2*np.pi, 100)
    y = np.sin(x)
    plt.plot(x, y)
    plt.xlabel("x")
    plt.ylabel("sin(x)")
    return fig



# Ulozeni grafu do souboru
def save_graph(fig, imageFile):
    plt.savefig(imageFile, facecolor=fig.get_facecolor(), bbox_inches='tight', dpi=80, pad_inches=0.03)



# Inicializace knihovny Pygame, inicializace video systemu a otevreni framebufferu
def initialize_pygame(width, height, background_color, framebuffer_device):
    os.environ["SDL_FBDEV"] = framebuffer_device
    pygame.init()
    screen = pygame.display.set_mode([width, height])
    pygame.mouse.set_visible(0)
    screen.fill(background_color)
    return screen



# Zobrazeni rastroveho obrazku do framebufferu
def show_image(screen, imageFile):
    image = pygame.image.load(imageFile)
    screen.blit(image, (0,0))
    pygame.display.flip()



# Cekani na ukonceni aplikace libovolnou klavesou
def wait_for_key():
    clock = pygame.time.Clock()
    while True:
        for event in pygame.event.get():
            if event.type == QUIT:
                return
            if event.type == KEYDOWN:
                return
        clock.tick(20)



# Ukonceni aplikace
def exit():
    pygame.quit()
    sys.exit()


# Hlavni funkce aplikace
def main():
    fig = create_graph()
    save_graph(fig, IMAGE_FILE)
    screen = initialize_pygame(WIDTH, HEIGHT, (0, 0, 200), FRAMEBUFFER_DEVICE)
    show_image(screen, IMAGE_FILE)
    wait_for_key()
    exit()



# Vstupni bod
if __name__ == "__main__":
    main()
</pre>

*** image ***
<p><i>Obrázek 6: Obrázek vygenerovaný druhým demonstračním příkladem.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Specifikace rozlišení obrázku s&nbsp;grafem</h2>

<p></p>

<pre>
# Vytvoreni grafu
def create_graph(width, height, dpi):
    fig = plt.figure(figsize=(1.0*width/dpi, 1.0*height/dpi), dpi=dpi)
    x = np.linspace(0, 2*np.pi, 100)
    y = np.sin(x)
    plt.plot(x, y)
    plt.xlabel("x")
    plt.ylabel("sin(x)")
    return fig
</pre>

<p></p>

<pre>
# Ulozeni grafu do souboru
def save_graph(fig, imageFile, dpi):
    plt.savefig(imageFile, facecolor=fig.get_facecolor(), dpi=dpi)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zobrazení grafu ve středu obrazovky</h2>

<p>Pokud je rastrový obrázek obsahující graf menší než rozlišení obrazovky, bude výhodnější takový graf zobrazit doprostřed plochy monitoru. To je samozřejmě možné, protože metodě <strong>screen.blit()</strong> se kromě objektu s&nbsp;vykreslovaným obrázkem/spritem předává i levý horní roh na obrazovce. Jediný krok, který musíme udělat, je vypočítat nové souřadnice tohoto levého horního rohu, což lze realizovat snadno, když si uvědomíme, že rozměry obrazovky i obrázku jsou reprezentovány objektem typu <strong>rect</strong> s&nbsp;atributy <strong>width</strong>, <strong>height</strong> a <strong>x</strong>, <strong>y</strong> (poslední dva zmíněné atributy však nepoužijeme). Funkci pro vykreslení obrázku nepatrně upravíme takto:</p>

<pre>
# Zobrazeni rastroveho obrazku do framebufferu
def show_image(screen, imageFile):
    image = pygame.image.load(imageFile)
    image_rect = image.get_rect()
    screen_rect = screen.get_rect()
    x = (screen_rect.width - image_rect.width) / 2
    y = (screen_rect.height - image_rect.height) / 2
    screen.blit(image, (x,y))
    pygame.display.flip()
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zdrojový kód třetího demonstračního příkladu</h2>

<p>Všechny výše popsané změny opět zapracujeme do demonstračního příkladu, jehož třetí verze bude vypadat následovně:</p>

<pre>
#!/usr/bin/python
# vim: set fileencodings=utf-8

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import numpy as np
import pygame
import os
import sys

# nutno importovat kvuli konstantam QUIT atd.
from pygame.locals import *

# velikost okna na obrazovce (framebufferu)
WIDTH = 640
HEIGHT = 480

# DPI (umele zvolena hodnota)
DPI = 100

# jmeno souboru s grafem
IMAGE_FILE = "plot3.png"

# jmeno zarizeni implementujiciho rozhrani k framebufferu
FRAMEBUFFER_DEVICE = "/dev/fb0"



# Vytvoreni grafu
def create_graph(width, height, dpi):
    fig = plt.figure(figsize=(1.0*width/dpi, 1.0*height/dpi), dpi=dpi)
    x = np.linspace(0, 2*np.pi, 100)
    y = np.sin(x)
    plt.plot(x, y)
    plt.xlabel("x")
    plt.ylabel("sin(x)")
    return fig



# Ulozeni grafu do souboru
def save_graph(fig, imageFile, dpi):
    plt.savefig(imageFile, facecolor=fig.get_facecolor(), dpi=dpi)



# Inicializace knihovny Pygame, inicializace video systemu a otevreni framebufferu
def initialize_pygame(width, height, background_color, framebuffer_device):
    os.environ["SDL_FBDEV"] = framebuffer_device
    pygame.init()
    screen = pygame.display.set_mode([width, height])
    pygame.mouse.set_visible(0)
    screen.fill(background_color)
    return screen



# Zobrazeni rastroveho obrazku do framebufferu
def show_image(screen, imageFile):
    image = pygame.image.load(imageFile)
    image_rect = image.get_rect()
    screen_rect = screen.get_rect()
    x = (screen_rect.width - image_rect.width) / 2
    y = (screen_rect.height - image_rect.height) / 2
    screen.blit(image, (x,y))
    pygame.display.flip()



# Cekani na ukonceni aplikace libovolnou klavesou
def wait_for_key():
    clock = pygame.time.Clock()
    while True:
        for event in pygame.event.get():
            if event.type == QUIT:
                return
            if event.type == KEYDOWN:
                return
        clock.tick(20)



# Ukonceni aplikace
def exit():
    pygame.quit()
    sys.exit()


# Hlavni funkce aplikace
def main():
    fig = create_graph(WIDTH, HEIGHT, DPI)
    save_graph(fig, IMAGE_FILE, DPI)
    screen = initialize_pygame(WIDTH, HEIGHT, (10, 10, 40), FRAMEBUFFER_DEVICE)
    show_image(screen, IMAGE_FILE)
    wait_for_key()
    exit()



# Vstupni bod
if __name__ == "__main__":
    main()

</pre>

*** image ***
<p><i>Obrázek 7: Obrázek vygenerovaný třetím demonstračním příkladem.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vytvoření obrázku v&nbsp;&bdquo;nativním&ldquo; rozlišení</h2>

<p>Prozatím jsme v&nbsp;předchozích třech demonstračních příkladech nastavovali rozlišení monitoru na hodnotu 640&times;480 pixelů. Tato hodnota sice zaručí, že příklad bude použitelný na většině monitorů, ovšem výsledek vizuálně nebude v&nbsp;žádném případě dokonalý, protože je mnohem lepší využít nativního rozlišení monitoru nastaveného při startu operačního systému (rozlišení je ovšem možné změnit i v&nbsp;běžícím systému, i když tato možnost je omezena). Pro získání informace o tom, jaké konkrétní rozlišení je právě nastaveno, máme několik možností. Můžeme se například pokusit o přečtení globálního konfiguračního souboru <strong>/boot/config.txt</strong>, což ovšem nemusí být přesné. Přesnější je spuštění již na začátku tohoto článku zmíněné utility <strong>fbset</strong> a přečtení hodnot, které tato utilita vypíše na standardní výstup.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Zjištění aktuálně nastaveného rozlišení framebufferu</h2>

<pre>
import subprocess
import re

def get_framebuffer_resolution(framebuffer_device):
    fbset_output = subprocess.check_output(["fbset", "-s", "-fb", framebuffer_device])

    for line in fbset_output.split("\n"):
        line = line.strip()
        if line.startswith("geometry"):
            print(line)
            parsed = re.match(r"geometry (\d+) (\d+)", line)
            return (parsed.group(1), parsed.group(2))

print(get_framebuffer_resolution("/dev/fb0"))
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zdrojový kód čtvrtého demonstračního příkladu</h2>

<pre>
#!/usr/bin/python
# vim: set fileencodings=utf-8

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import numpy as np
import pygame
import os
import sys
import subprocess
import re

# nutno importovat kvuli konstantam QUIT atd.
from pygame.locals import *

# DPI (umele zvolena hodnota)
DPI = 100

# jmeno souboru s grafem
IMAGE_FILE = "plot4.png"

# jmeno zarizeni implementujiciho rozhrani k framebufferu
FRAMEBUFFER_DEVICE = "/dev/fb0"



# Vytvoreni grafu
def create_graph(width, height, dpi):
    fig = plt.figure(figsize=(1.0*width/dpi, 1.0*height/dpi), dpi=dpi)
    x = np.linspace(0, 2*np.pi, 100)
    y = np.sin(x)
    plt.plot(x, y)
    plt.xlabel("x")
    plt.ylabel("sin(x)")
    return fig



# Ulozeni grafu do souboru
def save_graph(fig, imageFile, dpi):
    plt.savefig(imageFile, facecolor=fig.get_facecolor(), dpi=dpi)



# Inicializace knihovny Pygame, inicializace video systemu a otevreni framebufferu
def initialize_pygame(width, height, background_color, framebuffer_device):
    os.environ["SDL_FBDEV"] = framebuffer_device
    pygame.init()
    screen = pygame.display.set_mode([width, height])
    pygame.mouse.set_visible(0)
    screen.fill(background_color)
    return screen



# Zobrazeni rastroveho obrazku do framebufferu
def show_image(screen, imageFile):
    image = pygame.image.load(imageFile)
    image_rect = image.get_rect()
    screen_rect = screen.get_rect()
    x = (screen_rect.width - image_rect.width) / 2
    y = (screen_rect.height - image_rect.height) / 2
    screen.blit(image, (x,y))
    pygame.display.flip()



# Cekani na ukonceni aplikace libovolnou klavesou
def wait_for_key():
    clock = pygame.time.Clock()
    while True:
        for event in pygame.event.get():
            if event.type == QUIT:
                return
            if event.type == KEYDOWN:
                return
        clock.tick(20)



# precteni aktualne nastaveneho rozliseni framebufferu
def get_framebuffer_resolution(framebuffer_device):
    fbset_output = subprocess.check_output(["fbset", "-s", "-fb", framebuffer_device])

    for line in fbset_output.split("\n"):
        line = line.strip()
        if line.startswith("geometry"):
            print(line)
            parsed = re.match(r"geometry (\d+) (\d+)", line)
            return (int(parsed.group(1)), int(parsed.group(2)))



# Ukonceni aplikace
def exit():
    pygame.quit()
    sys.exit()



# Hlavni funkce aplikace
def main():
    width, height = get_framebuffer_resolution(FRAMEBUFFER_DEVICE)
    fig = create_graph(width, height, DPI)
    save_graph(fig, IMAGE_FILE, DPI)
    screen = initialize_pygame(width, height, (10, 10, 40), FRAMEBUFFER_DEVICE)
    show_image(screen, IMAGE_FILE)
    wait_for_key()
    exit()



# Vstupni bod
if __name__ == "__main__":
    main()
</pre>

*** image ***
<p><i>Obrázek 8: Obrázek vygenerovaný čtvrtým demonstračním příkladem.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odlišný typ grafu &ndash; kontury</h2>

<p>Knihovna <i>Matplotlib</i> samozřejmě nabízí i několik možností vykreslení grafů funkcí typu z=f(x,y), tj.&nbsp;funkcí se dvěma nezávislými proměnnými. Tyto funkce je možné zobrazit různým způsobem, například ve formě kontur (&bdquo;vrstevnic&ldquo;), drátového modelu (<i>wireframe</i>) či dokonce vyplněné plochy (mapy výšek, <i>heightfield</i>). Pro zajímavost si vyzkoušíme implementaci vykreslení takzvaných kontur, které si pro zjednodušení můžeme představit jako vrstevnice na mapě &ndash; body spojené konturou/vrstevnicí mají stejnou hodnotu funkce (tj.&nbsp;stejnou hodnotu z-ové souřadnice). Při vyhodnocování a následném vykreslení funkce budeme postupovat následovně:</p>

<ol>
<li>Vytvoříme vektor <strong>x</strong> s&nbsp;hodnotami nezávislé proměnné x.</li>
<li>Vytvoříme vektor <strong>y</strong> s&nbsp;hodnotami nezávislé proměnné y.</li>
<li>S&nbsp;využitím <strong>numpy.meshgrid</strong> necháme vygenerovat dvojici matic souřadnic.</li>
<li>Necháme vypočítat body ležící na ploše funkce (z-ové souřadnice se uloží do matice Z).</li>
<li>Vlastní vykreslení kontur zajistí funkce <strong>matplotlib.pyplot.contour(X, Y, Z)</strong>.</li>
</ol>

<p>Podívejme se úpravu funkce pro vykreslení grafu, která výše uvedené kroky realizuje:</p>

<pre>
# Vytvoreni grafu
def create_graph(width, height, dpi):
    fig = plt.figure(figsize=(1.0*width/dpi, 1.0*height/dpi), dpi=dpi)
    delta = 0.1

    # prubeh nezavisle promenne x
    x = np.arange(-10.0, 10.0, delta)

    # prubeh nezavisle promenne y
    y = np.arange(-10.0, 10.0, delta)

    # vytvoreni dvou poli se souradnicemi [x,y] 
    X, Y = np.meshgrid(x, y)

    # vzdalenost od bodu [0,0]
    R1 = np.sqrt(X*X+Y*Y)

    # vzdalenost od bodu [3,3]
    R2 = np.sqrt((X-3)*(X-3)+(Y-3)*(Y-3))

    # vypocet funkce, kterou pouzijeme pri vykreslovani grafu
    Z = np.sin(R1)-np.cos(R2)

    # povoleni zobrazeni mrizky
    plt.grid(True)

    # vytvoreni grafu s konturami funkce z=f(x,y)
    plt.contour(X, Y, Z)

    # zobrazeni grafu
    plt.plot()
    return fig
</pre>

<img class="alignnone size-medium wp-image-7171" src="https://mojefedora.cz/wp-content/uploads/2016/05/04-450x339.png" alt="04" width="450" height="339" />
<p><i>Obrázek 9: Nepatrnou úpravou kódu lze dosáhnout toho, že kromě vrstevnic a jejich hodnot se napravo od grafu zobrazí i &bdquo;mapa výšek&ldquo;. Relativní velikost mapy vůči celému grafu se řídí hodnotou <strong>shrink</strong>. Zde konkrétně má celá legenda výšku jen 70% výšky celého grafu.</i></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Zdrojový kód pátého demonstračního příkladu</h2>

<p>Úplný zdrojový kód pátého a současně i dnešního posledního příkladu vypadá následovně:</p>

<pre>
#!/usr/bin/python
# vim: set fileencodings=utf-8

import matplotlib
matplotlib.use("Agg")
import matplotlib.cm as cm
import matplotlib.mlab as mlab
import matplotlib.pyplot as plt
import numpy as np
import pygame
import os
import sys
import subprocess
import re

# nutno importovat kvuli konstantam QUIT atd.
from pygame.locals import *

# DPI (umele zvolena hodnota)
DPI = 100

# jmeno souboru s grafem
IMAGE_FILE = "plot5.png"

# jmeno zarizeni implementujiciho rozhrani k framebufferu
FRAMEBUFFER_DEVICE = "/dev/fb0"



# Vytvoreni grafu
def create_graph(width, height, dpi):
    fig = plt.figure(figsize=(1.0*width/dpi, 1.0*height/dpi), dpi=dpi)
    delta = 0.1

    # prubeh nezavisle promenne x
    x = np.arange(-10.0, 10.0, delta)

    # prubeh nezavisle promenne y
    y = np.arange(-10.0, 10.0, delta)

    # vytvoreni dvou poli se souradnicemi [x,y] 
    X, Y = np.meshgrid(x, y)

    # vzdalenost od bodu [0,0]
    R1 = np.sqrt(X*X+Y*Y)

    # vzdalenost od bodu [3,3]
    R2 = np.sqrt((X-3)*(X-3)+(Y-3)*(Y-3))

    # vypocet funkce, kterou pouzijeme pri vykreslovani grafu
    Z = np.sin(R1)-np.cos(R2)

    # povoleni zobrazeni mrizky
    plt.grid(True)

    # vytvoreni grafu s konturami funkce z=f(x,y)
    plt.contour(X, Y, Z)

    # zobrazeni grafu
    plt.plot()
    return fig



# Ulozeni grafu do souboru
def save_graph(fig, imageFile, dpi):
    plt.savefig(imageFile, facecolor=fig.get_facecolor(), dpi=dpi)



# Inicializace knihovny Pygame, inicializace video systemu a otevreni framebufferu
def initialize_pygame(width, height, background_color, framebuffer_device):
    os.environ["SDL_FBDEV"] = framebuffer_device
    pygame.init()
    screen = pygame.display.set_mode([width, height])
    pygame.mouse.set_visible(0)
    screen.fill(background_color)
    return screen



# Zobrazeni rastroveho obrazku do framebufferu
def show_image(screen, imageFile):
    image = pygame.image.load(imageFile)
    image_rect = image.get_rect()
    screen_rect = screen.get_rect()
    x = (screen_rect.width - image_rect.width) / 2
    y = (screen_rect.height - image_rect.height) / 2
    screen.blit(image, (x,y))
    pygame.display.flip()



# Cekani na ukonceni aplikace libovolnou klavesou
def wait_for_key():
    clock = pygame.time.Clock()
    while True:
        for event in pygame.event.get():
            if event.type == QUIT:
                return
            if event.type == KEYDOWN:
                return
        clock.tick(20)



# precteni aktualne nastaveneho rozliseni framebufferu
def get_framebuffer_resolution(framebuffer_device):
    fbset_output = subprocess.check_output(["fbset", "-s", "-fb", framebuffer_device])

    for line in fbset_output.split("\n"):
        line = line.strip()
        if line.startswith("geometry"):
            print(line)
            parsed = re.match(r"geometry (\d+) (\d+)", line)
            return (int(parsed.group(1)), int(parsed.group(2)))



# Ukonceni aplikace
def exit():
    pygame.quit()
    sys.exit()



# Hlavni funkce aplikace
def main():
    width, height = get_framebuffer_resolution(FRAMEBUFFER_DEVICE)
    fig = create_graph(width, height, DPI)
    save_graph(fig, IMAGE_FILE, DPI)
    screen = initialize_pygame(width, height, (10, 10, 40), FRAMEBUFFER_DEVICE)
    show_image(screen, IMAGE_FILE)
    wait_for_key()
    exit()



# Vstupni bod
if __name__ == "__main__":
    main()

</pre>

*** image ***
<p><i>Obrázek 10: Obrázek vygenerovaný pátým demonstračním příkladem.</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Články o knihovnách NumPy, Matplotlib a Pygame</h2>

<p>V&nbsp;následujícím seznamu jsou vypsány články o knihovnách NumPy, Matplotlib a Pygame, které již byly na serveru <a href="https://www.mojefedora.cz">mojefedora.cz</a> v&nbsp;minulosti vydány:</p>

<ol>

<li>Integrovaná vývojová prostředí ve Fedoře: IPython a IPython Notebook<br />
<a href="http://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-ipython-a-ipython-notebook/">http://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-ipython-a-ipython-notebook/</a>
</li>

<li>Integrovaná vývojová prostředí ve Fedoře: praktické použití IPython Notebooku a knihovny Numpy<br />
<a href="http://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy/">http://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy/</a>
</li>

<li>Integrovaná vývojová prostředí ve Fedoře: praktické použití IPython Notebooku a knihovny Numpy (2.část)<br />
<a href="http://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy-2-cast/">http://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy-2-cast/</a>
</li>

<li>Integrovaná vývojová prostředí ve Fedoře: vykreslování grafů s využitím knihoven Numpy a matplotlib<br />
<a href="http://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-vykreslovani-grafu-s-vyuzitim-knihoven-numpy-a-matplotlib/">http://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-vykreslovani-grafu-s-vyuzitim-knihoven-numpy-a-matplotlib/</a>
</li>

<li>Integrovaná vývojová prostředí ve Fedoře: vykreslování grafů s využitím knihoven Numpy a matplotlib (2.část)<br />
<a href="http://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-vykreslovani-grafu-s-vyuzitim-knihoven-numpy-a-matplotlib-2-cast/">http://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-vykreslovani-grafu-s-vyuzitim-knihoven-numpy-a-matplotlib-2-cast/</a>
</li>

</ol>



<p><a name="k17"></a></p>
<h2 id="k17">17. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady, s&nbsp;nimiž jsme se v&nbsp;dnešním článku seznámili, byly uloženy do Git repositáře umístěného na GitHubu (<a href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>). Poslední verze zdrojových kódů naleznete pod odkazy uvedenými v&nbsp;tabulce pod tímto odstavcem:</p>

<table>
<tr><th>Příklad</th><th>Odkaz do repositáře</th></tr>
<tr><td>pygame_matplotlib_1.py</td><td><a href=""></a></td></tr>
<tr><td>pygame_matplotlib_2.py</td><td><a href=""></a></td></tr>
<tr><td>pygame_matplotlib_3.py</td><td><a href=""></a></td></tr>
<tr><td>pygame_matplotlib_4.py</td><td><a href=""></a></td></tr>
<tr><td>pygame_matplotlib_5.py</td><td><a href=""></a></td></tr>
<tr><td>get_framebuffer_resolution.py</td><td><a href=""></a></td></tr>
</table>

<p>Pro úspěšné spuštění těchto příkladů je nutné dodržet tato pravidla:</p>

<ol>
<li>Musí být nainstalována knihovna Matplotlib a Numpy.</li>
<li>Dále je nutné nainstalovat i knihovnu Pygame</li>
<li>Příklady by měly být spouštěny z&nbsp;terminálu Raspberry Pi <strong>bez</strong> X systému</li>
<li>Příkazem <strong>fbset -v</strong> si ověřte, že se skutečně používá zařízení <strong>/dev/fb0</strong></li>
<li>Uživatel spouštějící příklad musí mít přístup do framebufferu. Většinou to znamená laborování se skupinami či použití <strong>sudo</strong></li>
</ol>



<p><a name="k18"></a></p>
<h2 id="k18">18. Odkazy na Internetu</h2>

<ol>

<li>Pygame.org<br />
<a href="http://pygame.org/hifi.html">http://pygame.org/hifi.html</a>
</li>

<li>Pygame - instalační soubory pro různé operační systémy<br />
<a href="http://pygame.org/download.shtml">http://pygame.org/download.shtml</a>
</li>

<li>Pygame: documentation<br />
<a href="http://www.pygame.org/docs/">http://www.pygame.org/docs/</a>
</li>

<li>Pygame Wiki: Getting Started<br />
<a href="http://www.pygame.org/wiki/GettingStarted">http://www.pygame.org/wiki/GettingStarted</a>
</li>

<li>Pygame Tutorials: Tutorials Basic<br />
<a href="http://pygametutorials.wikidot.com/tutorials-basic">http://pygametutorials.wikidot.com/tutorials-basic</a>
</li>

<li>Python.org (dokumentace k&nbsp;jazyku, odkazy na instalační soubory atd.)<br />
<a href="https://www.python.org/">https://www.python.org/</a>
</li>

<li>How to Draw with Pygame on Your Raspberry Pi<br />
<a href="http://www.dummies.com/how-to/content/how-to-draw-with-pygame-on-your-raspberry-pi.html">http://www.dummies.com/how-to/content/how-to-draw-with-pygame-on-your-raspberry-pi.html</a>
</li>

<li>NumPy Home Page<br />
<a href="http://www.numpy.org/">http://www.numpy.org/</a>
</li>

<li>NumPy v1.10 Manual<br />
<a href="http://docs.scipy.org/doc/numpy/index.html">http://docs.scipy.org/doc/numpy/index.html</a>
</li>

<li>NumPy (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/NumPy">https://en.wikipedia.org/wiki/NumPy</a>
</li>

<li>Matplotlib Home Page<br />
<a href="http://matplotlib.org/">http://matplotlib.org/</a>
</li>

<li>matplotlib (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Matplotlib">https://en.wikipedia.org/wiki/Matplotlib</a>
</li>

<li>Lorenzův atraktor<br />
<a href="http://www.root.cz/clanky/fraktaly-v-pocitacove-grafice-iii/#k03">http://www.root.cz/clanky/fraktaly-v-pocitacove-grafice-iii/#k03</a>
</li>

<li>Popis barvových map modulu matplotlib.cm<br />
<a href="https://gist.github.com/endolith/2719900#id7">https://gist.github.com/endolith/2719900#id7</a>
</li>

<li>Ukázky (palety) barvových map modulu matplotlib.cm<br />
<a href="http://matplotlib.org/examples/color/colormaps_reference.html">http://matplotlib.org/examples/color/colormaps_reference.html</a>
</li>

<li>Lorenz system<br />
<a href="https://en.wikipedia.org/wiki/Lorenz_system">https://en.wikipedia.org/wiki/Lorenz_system</a>
</li>

<li>Customising contour plots in matplotlib<br />
<a href="https://philbull.wordpress.com/2012/12/27/customising-contour-plots-in-matplotlib/">https://philbull.wordpress.com/2012/12/27/customising-contour-plots-in-matplotlib/</a>
</li>

<li>Graphics with Matplotlib<br />
<a href="http://kestrel.nmt.edu/~raymond/software/python_notes/paper004.html">http://kestrel.nmt.edu/~raymond/software/python_notes/paper004.html</a>
</li>

<li>Systémy lineárních rovnic<br />
<a href="http://www.matematika.cz/systemy-linearnich-rovnic">http://www.matematika.cz/systemy-linearnich-rovnic</a>
</li>

<li>IPython homepage<br />
<a href="http://ipython.org/">http://ipython.org/</a>
</li>

<li>Dokumentace k IPythonu<br />
<a href="http://ipython.org/documentation.html#">http://ipython.org/documentation.html#</a>
</li>

<li>IPython Tutorial<br />
<a href="http://ipython.readthedocs.org/en/stable/interactive/tutorial.html">http://ipython.readthedocs.org/en/stable/interactive/tutorial.html</a>
</li>

<li>The cell magics in IPython<br />
<a href="http://nbviewer.jupyter.org/github/ipython/ipython/blob/1.x/examples/notebooks/Cell%20Magics.ipynb">http://nbviewer.jupyter.org/github/ipython/ipython/blob/1.x/examples/notebooks/Cell%20Magics.ipynb</a>
</li>

<li>0MQ Home Page<br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>Is IPython Notebook ever used as an IDE, or merely for presentations?<br />
<a href="https://www.reddit.com/r/IPython/comments/1uk7hp/is_ipython_notebook_ever_used_as_an_ide_or_merely/">https://www.reddit.com/r/IPython/comments/1uk7hp/is_ipython_notebook_ever_used_as_an_ide_or_merely/</a>
</li>

<li>The IDE as a Bad Programming Language Enabler <br />
<a href="https://dzone.com/articles/ide-bad-programming-language">https://dzone.com/articles/ide-bad-programming-language</a>
</li>

<li>Enhanced Interactive Python with IPython<br />
<a href="http://www.onlamp.com/pub/a/python/2005/01/27/ipython.html">http://www.onlamp.com/pub/a/python/2005/01/27/ipython.html</a>
</li>

<li>Direct mode<br />
<a href="https://en.wikipedia.org/wiki/Direct_mode">https://en.wikipedia.org/wiki/Direct_mode</a>
</li>

<li>Seznámení s&nbsp;Python IDE Spyder (článek vyšel zde na mojefedora.cz)<br />
<a href="http://mojefedora.cz/seznameni-s-python-ide-spyder/">http://mojefedora.cz/seznameni-s-python-ide-spyder/</a>
</li>

<li>Stránka s&nbsp;popisem různých IDE pro Python<br />
<a href="http://quintagroup.com/cms/python/ide">http://quintagroup.com/cms/python/ide</a>
</li>

<li>Eclipse (stránka o frameworku na Fedoraproject.org)<br />
<a href="https://fedoraproject.org/wiki/Eclipse">https://fedoraproject.org/wiki/Eclipse</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

