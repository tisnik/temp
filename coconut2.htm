<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Coconut aneb funkcionální nadstavba nad Pythonem (2.část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Coconut aneb funkcionální nadstavba nad Pythonem (2.část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části článku o programovacím jazyku Coconut, který je překládán do Pythonu, si popíšeme další zajímavé vlastnosti tohoto jazyka: nové operátory, použití Unicode znaků pro zápis nových i stávajících operátorů, pattern matching i optimalizaci koncové rekurze (TCO).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Coconut aneb funkcionální nadstavba nad Pythonem (2.část)</a></p>
<p><a href="#k02">2. Zřetězení většího množství generátorů</a></p>
<p><a href="#k03">3. Operátor ?? (operátor koalescence)</a></p>
<p><a href="#k04">4. Operátor ??=</a></p>
<p><a href="#k05">5. Elvis operator</a></p>
<p><a href="#k06">6. Elvis operator a přístup k&nbsp;prvkům v&nbsp;datové struktuře</a></p>
<p><a href="#k07">7. Elvis operator a přístup k&nbsp;atributům objektů</a></p>
<p><a href="#k08">8. Zápis některých operátorů s&nbsp;využitím Unicode znaků</a></p>
<p><a href="#k09">9. Příklad použití Unicode znaků</a></p>
<p><a href="#k10">10. Pattern matching: základní klauzule</a></p>
<p><a href="#k11">11. Pattern matching: složitější příklady použití</a></p>
<p><a href="#k12">12. Rekurze a koncová rekurze</a></p>
<p><a href="#k13">13. Klasická rekurze v&nbsp;Pythonu a její omezení</a></p>
<p><a href="#k14">14. Optimalizace koncové rekurze v&nbsp;Coconutu</a></p>
<p><a href="#k15">15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Coconut aneb funkcionální nadstavba nad Pythonem (2.část)</h2>

<p><a
href="https://www.root.cz/clanky/coconut-funkcionalni-jazyk-s-pattern-matchingem-kompatibilni-s-pythonem/">V&nbsp;úvodní
části</a> článku o programovacím jazyku Coconut jsme si vysvětlili, jakým
způsobem se vlastně zdrojové kódy napsané v&nbsp;Coconutu překládají
(transkompilují) do Pythonu. Taktéž jsme se seznámili s&nbsp;některými
zajímavými rysy tohoto jazyka, zejména s&nbsp;neměnitelnými (<i>immutable</i>)
datovými typy, funkcemi vyššího řádu určenými pro zpracování sekvencí,
zkráceným zápisem lambda výrazů, infixovým zápisem při volání funkcí a/nebo při
deklaraci funkcí a v&nbsp;neposlední řadě taktéž o kompozici funkcí a vytvoření
&bdquo;kolony&ldquo; funkcí, které si mezi sebou předávají vypočtené
mezivýsledky.</p>

<p>Dnes si popíšeme další zajímavé vlastnosti tohoto jazyka. Především se jedná
o nové operátory <a href="#k03">??</a>, <a href="#k04">??=</a> a <a
href="#k05">?.</a> (Elvis operator), které znají například vývojáři používající
jazyk C#. Dále si řekneme, jak lze (alternativně) zapisovat vybrané operátory
pomocí <a href="#k09">Unicode znaků</a> (což nepatrně připomíná APL), <a
href="#k10">popíšeme si</a> konstrukce používané při <a
href="https://en.wikipedia.org/wiki/Pattern_matching">pattern matchingu</a> a
taktéž se budeme zabývat problematikou <a href="#k13">optimalizace koncové
rekurze</a>, kterou jazyk Coconut taktéž podporuje, na rozdíl od standardního
Pythonu (resp.&nbsp;přesněji řečeno standardního CPythonu).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zřetězení většího množství generátorů</h2>

<p>První užitečnou vlastností programovacího jazyka Coconut, s&nbsp;níž se
v&nbsp;dnešním článku seznámíme, je možnost zřetězení většího množství
generátorů, takže se vlastně (alespoň z&nbsp;pohledu programátora-uživatele)
vytvoří generátor nový, který nejprve vrátí všechny prvky vytvořené prvním
generátorem a následně prvky vytvořené generátorem druhým. Pro tento účel se
používá nový operátor zapisovaný jako &bdquo;čtyřtečka&ldquo;. Podívejme se na
jednoduchý příklad, v&nbsp;němž jsou nejprve definovány dva generátory,
z&nbsp;nichž každý postupně vrátí maximálně čtyři prvky. Po spojení generátorů
operátorem <strong>::</strong> dostaneme posloupnost osmi prvků:</p>

<pre>
def <strong>generator1()</strong>:
    values = ["a1", "b1", "c1", "d1"]
    for value in values:
        yield value
&nbsp;
def <strong>generator2()</strong>:
    values = ["a2", "b2", "c2", "d2"]
    for value in values:
        yield value
&nbsp;
for v in <strong>generator1()::generator2()</strong>:
    print(v)
</pre>

<p>Příklad výstupu vypsaného po spuštění:</p>

<pre>
a1
b1
c1
d1
a2
b2
c2
d2
</pre>

<p>Pro zajímavost se podívejme, jak vlastně vypadá kód vygenerovaný
transpřekladačem Coconutu:</p>

<pre>
def generator1():
    values = ["a1", "b1", "c1", "d1"]
    for value in values:
        yield value
&nbsp;
def generator2():
    values = ["a2", "b2", "c2", "d2"]
    for value in values:
        yield value
&nbsp;
for v in _coconut.itertools.chain.from_iterable((f() for f in (lambda: generator1(), lambda: generator2()))):
    print(v)
</pre>

<p>Můžeme si vyzkoušet i nepatrně složitější příklad s&nbsp;konfigurovatelným
generátorem, kterému se při jeho konstrukci předává suffix vracených hodnot.
Ten stejný generátor zřetězíme celkem třikrát:</p>

<pre>
def <strong>generator3(suffix)</strong>:
    values = ["a", "b", "c", "d", "e"]
    for value in values:
        yield "{v}{s}".format(v=value, s=suffix)
&nbsp;
for v in <strong>generator3("1")::generator3("2")::generator3("3")</strong>:
    print(v)
</pre>

<p>Příklad výstupu:</p>

<pre>
a1
b1
c1
d1
e1
a2
b2
c2
d2
e2
a3
b3
c3
d3
e3
</pre>

<p>Opět se podívejme, jaký kód se vytvořil transpřekladačem:</p>

<pre>
def generator3(suffix):
    values = ["a", "b", "c", "d", "e"]
    for value in values:
        yield "{v}{s}".format(v=value, s=suffix)
&nbsp;
for v in _coconut.itertools.chain.from_iterable((f() for f in (lambda: generator3("1"), lambda: generator3("2"), lambda: generator3("3")))):
    print(v)
</pre>

<p>Použít samozřejmě můžeme i funkci <strong>range()</strong>, například pro
vygenerování série hodnot připomínajících digitalizovaný trojúhelníkový
signál:</p>

<pre>
for i in <strong>range(0, 10)::range(10, 0, -1)</strong>:
    print(i)
</pre>

<p>S&nbsp;výstupem:</p>

<pre>
0
1
2
3
4
5
6
7
8
9
10
9
8
7
6
5
4
3
2
1
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Operátor ?? (operátor koalescence)</h2>

<p>V&nbsp;některých programovacích jazycích, například v&nbsp;C#, PHP 7 či
Swiftu, se setkáme s&nbsp;takzvaným operátorem koalescence (neboli operátorem
nulového sjednocení). Jedná se o binární operátor, tj.&nbsp;o operátor, na
jehož levé straně je umístěn první operand a na pravé straně operand druhý.
Pokud má operand na levé straně hodnotu odlišnou od <strong>None</strong>,
vrátí se jeho hodnota, aniž by se zpracovával (vyhodnocoval) operand pravý.
Pokud však levý operand obsahuje <strong>None</strong> (nemá hodnotu), vrátí se
vyhodnocený pravý operand. Samotný operátor koalescence se v&nbsp;mnoha
jazycích zapisuje dvěma znaky ?? (výjimkou je Perl používající //), což je
zvyklost, která zůstala v&nbsp;Coconutu zachována.</p>

<p>Podívejme se na jednoduché (a nutno říci, že poněkud umělé) příklady:</p>

<pre>
import os
&nbsp;
v1 = None
v2 = "Some"
&nbsp;
print(v1 ?? v2)
&nbsp;
v3 = "Some"
v4 = "Something else"
&nbsp;
print(v3 ?? v4)
&nbsp;
v5 = None
v6 = None
&nbsp;
print(v5 ?? v6)
&nbsp;
print(os.getenv('EDITOR') ?? "notepad")
print(os.getenv('XXEDITOR') ?? "notepad")
</pre>

<p>Příklad výstupu:</p>

<pre>
Some
Some
None
vim
notepad
</pre>

<p>Transpřeklad do Pythonu je v&nbsp;tomto případě přímočarý &ndash; použije se
konstrukce <strong>if-else</strong> zapsaná ve výrazu:</p>

<pre>
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# __coconut_hash__ = 0x109f876f
&nbsp;
# Compiled with Coconut version 1.3.0 [Dead Parrot]
&nbsp;
# Coconut Header: -------------------------------------------------------------
&nbsp;
# Compiled Coconut: -----------------------------------------------------------
&nbsp;
import os
&nbsp;
v1 = None
v2 = "Some"
&nbsp;
print(<strong>v2 if v1 is None else v1</strong>)
&nbsp;
v3 = "Some"
v4 = "Something else"
&nbsp;
print(<strong>v4 if v3 is None else v3</strong>)
&nbsp;
v5 = None
v6 = None
&nbsp;
print(<strong>v6 if v5 is None else v5</strong>)
&nbsp;
print(<strong>(lambda _coconut_none_coalesce_item: "notepad" if _coconut_none_coalesce_item is None else _coconut_none_coalesce_item)</strong>(os.getenv('EDITOR')))
print(<strong>(lambda _coconut_none_coalesce_item: "notepad" if _coconut_none_coalesce_item is None else _coconut_none_coalesce_item)</strong>(os.getenv('XXEDITOR')))
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Operátor ??=</h2>

<p>V&nbsp;jazyce Coconut nalezneme ještě další velmi podobný operátor
zapisovaný trojicí znaků <strong>??=</strong>. Opět se jedná o binární operátor
s&nbsp;dvojicí operandů, jehož význam je následující:</p>

<ul>

<li>Pokud levý operand obsahuje <strong>None</strong>, přiřaď do něj hodnotu
operandu pravého; tato hodnota je výsledkem celého výrazu</li>

<li>V&nbsp;opačném případě je hodnota celého výrazu rovna levému operandu (aby
bylo možné používat složitější výrazy)</li>

</ul>

<p>Podívejme se na velmi jednoduchý příklad se slovníkem. Budeme měnit hodnoty
uložené pod různými klíči, ovšem díky použití operátoru <strong>??=</strong>
namísto pouhého přiřazení operátorem <strong>=</strong> se nezmění ty hodnoty,
které jsou rozdílné od <strong>None</strong>:</p>

<pre>
slovnik = {
    "prvni": 1,
    "druhy": 2,
    "treti": 3,
    "posledni": None
}
&nbsp;
print(slovnik)
&nbsp;
slovnik["prvni"] <strong>??=</strong> 1000
&nbsp;
print(slovnik)
&nbsp;
slovnik["posledni"] <strong>??=</strong> 1000
&nbsp;
print(slovnik)
&nbsp;
slovnik["neexistujici"] <strong>??=</strong> 10
&nbsp;
print(slovnik)
</pre>

<p>Nejprve se podívejme na způsob transpřekladu z&nbsp;Coconutu do Pythonu,
z&nbsp;něhož je zřejmý přesný význam operátoru <strong>??=</strong>:</p>

<pre>
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# __coconut_hash__ = 0xbe97918d
&nbsp;
# Compiled with Coconut version 1.3.0 [Dead Parrot]
&nbsp;
# Coconut Header: -------------------------------------------------------------
&nbsp;
&nbsp;
# Compiled Coconut: -----------------------------------------------------------
&nbsp;
slovnik = {"prvni": 1, "druhy": 2, "treti": 3, "posledni": None}
&nbsp;
print(slovnik)
&nbsp;
slovnik["prvni"] = 1000 if slovnik["prvni"] is None else slovnik["prvni"]
&nbsp;
print(slovnik)
&nbsp;
slovnik["posledni"] = 1000 if slovnik["posledni"] is None else slovnik["posledni"]
&nbsp;
print(slovnik)
&nbsp;
slovnik["neexistujici"] = 10 if slovnik["neexistujici"] is None else slovnik["neexistujici"]
&nbsp;
print(slovnik)
</pre>

<p>Z&nbsp;výše uvedeného kódu je možné vydedukovat, že poslední přiřazení
skončí s&nbsp;chybou, protože Python (což je velmi dobře!) rozlišuje mezi
hodnotou <strong>None</strong> uloženou pod nějakým klíčem a mezi neexistující
dvojicí klíč:hodnota:</p>

<pre>
{u'druhy': 2, u'posledni': None, u'prvni': 1, u'treti': 3}
{u'druhy': 2, u'posledni': None, u'prvni': 1, u'treti': 3}
{u'druhy': 2, u'posledni': 1000, u'prvni': 1, u'treti': 3}
Traceback (most recent call last):
  File "10_??=_operator.py", line 650, in &lt;module&gt;
    slovnik["neexistujici"] = 10 if slovnik["neexistujici"] is None else slovnik["neexistujici"]
KeyError: u'neexistujici'
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Elvis operator</h2>

<p>V&nbsp;některých programovacích jazycích se můžeme setkat
s&nbsp;neoficiálním termínem &bdquo;Elvis operator&ldquo; (podívejte se na
fotky Elvise Presleyho a zjistíte, proč je použit právě tento název). Termín
Elvis operator má hned dva významy &ndash; buď se může jednat o zkrácení
ternárního operátoru <strong>?:</strong> na operátor binární (bez druhé větve)
nebo se může jednat o takzvaný &bdquo;safe navigation operator&ldquo;, který se
většinou zapisuje dvojicí znaků <strong>?.</strong>. V&nbsp;jazyku Coconut
najdeme právě &bdquo;safe navigation operator&ldquo;, což je binární operátor,
který funguje podobně jako stávající operátor <strong>.</strong> (tečka), ovšem
pravá strana (metoda, atribut) se zpracuje pouze tehdy, pokud je objekt na levé
straně tohoto operátoru rozdílný od <strong>None</strong>. Tyto operátory lze
samozřejmě v&nbsp;případě potřeby &bdquo;zřetězit&ldquo;, tj.&nbsp;lze
například přistupovat k&nbsp;atributům atributů, a to bez nebezpečí, že by
došlo k&nbsp;vyvolání výjimky.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Elvis operator a přístup k&nbsp;prvkům v&nbsp;datové struktuře</h2>

<p>Podívejme se na jednoduchý příklad, v&nbsp;němž chceme vypsat hodnotu
posledního dosaženého skóre ze slovníku, který představuje stav hry:</p>

<pre>
game1 = {
    "player" : {
        "name": "Kvido",
        "nick": "kvido"
    },
    "results": {
        "score": {
            "last": 1000,
            "top": 2000
        },
        "lives": 0
    }
}
</pre>

<p>Následující funkce sice bude fungovat, ale jen ve chvíli, kdy má slovník
očekávanou strukturu:</p>

<pre>
def print_last_score_variant_A(game):
    score = game.get("results").get("score").get("last")
    print("Score: {s}".format(s=score))
&nbsp;
print("\nVariant A")
print_last_score_variant_A(game1)
</pre>

<p>Pro následující (částečnou) strukturu však dojde k&nbsp;výjimce:</p>

<pre>
game2 = {
    "player" : {
        "name": "Kvido",
        "nick": "kvido"
    }
}
</pre>

<p>Jedno z&nbsp;možných pythonovských řešení může vypadat tak, že metoda
<strong>get</strong> vrátí namísto <strong>None</strong> prázdný slovník, což
je sice krátký zápis, ale poněkud nepřehledný (původní význam algoritmu se
trošku ztrácí):</p>

<pre>
def print_last_score_variant_B(game):
    score = game.get("results", {}).get("score", {}).get("last")
    print("Score: {s}".format(s=score))
&nbsp;
print("\nVariant B")
print_last_score_variant_B(game1)
print_last_score_variant_B(game2)
</pre>

<p>Alternativně můžeme použít Elvis operator, který je kratší i
přehlednější:</p>

<pre>
def print_last_score_variant_C(game):
    score = game.get("results")<strong>?.</strong>get("score")<strong>?.</strong>get("last")
    print("Score: {s}".format(s=score))
&nbsp;
print("\nVariant C")
print_last_score_variant_C(game1)
print_last_score_variant_C(game2)
</pre>

<p>Pro zajímavost se podívejme, jak se vlastně Elvis operator transpřeložil do
Pythonu. Není to příliš čitelný kód, ale je poměrně přímočarý:</p>

<pre>
def print_last_score_variant_C(game):
    score = <strong>(lambda x: None if x is None else (lambda x: None if x is None else x.get("last"))</strong>(x.get("score")))(game.get("results"))
    print("Score: {s}".format(s=score))
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Elvis operator a přístup k&nbsp;atributům objektů</h2>

<p>Stejně užitečné může být použití Elvis operátoru pro přístup
k&nbsp;atributům objektů a atributům atributů (atributů...). Předchozí příklad
můžeme přepsat takovým způsobem, aby se namísto běžného slovníku používaly
objekty (schválně jsem strukturu zjednodušil):</p>

<pre>
class Player:
    def __init__(self, name, nick):
        self.name = name
        self.nick = nick
&nbsp;
class Score:
    def __init__(self,last, top):
        self.last = last
        self.top =top
&nbsp;
class Game:
    def __init__(self,player, score, lives):
        self.player = player
        self.score = score
        self.lives = lives
</pre>

<p>Funkce, která po předání objektu typu <strong>Game</strong> vypíše hodnotu
posledního skóre, můžeme napsat velmi jednoduše bez toho, že by hrozilo
vyhození výjimky:</p>

<pre>
def print_last_score_variant_D(game):
    score = <strong>game?.score?.last</strong>
    print("Score: {s}".format(s=score))
&nbsp;
</pre>

<p>Očekávané chování si můžeme jednoduše otestovat:</p>

<pre>
game1_obj = Game(Player("Kvido", "kvido"),
                 Score(1000, 2000),
                 0)
&nbsp;
game2_obj = Game(Player("Kvido", "kvido"),
                 None, 0)
&nbsp;
print("\nVariant D")
print_last_score_variant_D(game1_obj)
print_last_score_variant_D(game2_obj)
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
Variant D
Score: 1000
Score: None
</pre>

<p>Opět se podívejme na způsob transpřekladu do Pythonu:</p>

<pre>
def print_last_score_variant_D(game):
    score = (lambda x: None if x is None else (lambda x: None if x is None else x.last)(x.score))(game)
    print("Score: {s}".format(s=score))
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zápis některých operátorů s&nbsp;využitím Unicode znaků</h2>

<p>Jazyk Coconut se sice nesnaží napodobit můj oblíbený jazyk APL [<a
href="https://www.root.cz/clanky/programovaci-jazyk-apl-programovani-bez-smycek/">1</a>]
[<a href="https://www.root.cz/clanky/programovaci-jazyk-apl-dokonceni/">2</a>],
ovšem umožňuje (jako i některé další jazyky ze třetího tisíciletí :-)
alternativní zápis některých operandů s&nbsp;využitím Unicode znaků. Ostatně
podívejte se na následující tabulku:</p>

<table>
<tr><th>Znak (znaky)</th><th>Původní operátor</th></tr>
<tr><td>→     </td><td>-&gt;   </td></tr>
<tr><td>↦     </td><td>|&gt;   </td></tr>
<tr><td>*↦    </td><td>|*&gt;  </td></tr>
<tr><td>↤     </td><td>&lt;|   </td></tr>
<tr><td>↤*    </td><td>&lt;*|  </td></tr>
<tr><td>⋅     </td><td>*       </td></tr>
<tr><td>↑     </td><td>**      </td></tr>
<tr><td>÷     </td><td>/       </td></tr>
<tr><td>÷/    </td><td>//      </td></tr>
<tr><td>∘     </td><td>..      </td></tr>
<tr><td>∘&gt; </td><td>..&gt;  </td></tr>
<tr><td>&lt;∘ </td><td>&lt;..  </td></tr>
<tr><td>∘*&gt;</td><td>.*&gt;  </td></tr>
<tr><td>&lt;*∘</td><td>*..     </td></tr>
<tr><td>−     </td><td>-       </td></tr>
<tr><td>⁻     </td><td>-       </td></tr>
<tr><td>¬     </td><td>~       </td></tr>
<tr><td>≠   ¬=</td><td>!=      </td></tr>
<tr><td>≤     </td><td>&lt;=   </td></tr>
<tr><td>≥     </td><td>&gt;=   </td></tr>
<tr><td>∧   ∩ </td><td>&amp;   </td></tr>
<tr><td>∨   ∪ </td><td>|       </td></tr>
<tr><td>⊻   ⊕ </td><td>^       </td></tr>
<tr><td>«     </td><td>&lt;&lt;</td></tr>
<tr><td>»     </td><td>&gt;&gt;</td></tr>
<tr><td>…     </td><td>...     </td></tr>
<tr><td>×     </td><td>@       </td></tr>
</table>

<p>Poznámka: tyto znaky nemusíte pracně zapisovat přes pravý Alt, protože
například textový editor Vim umožňuje zápis necelých dvou tisíc Unicode znaků
pomocí &bdquo;digraphs&ldquo; (<a
href="http://vimdoc.sourceforge.net/htmldoc/digraph.html">http://vimdoc.sourceforge.net/htmldoc/digraph.html</a>),
které původně vznikly emulací psacího stroje (tisk dvou znaků přes sebe).
Postačuje napsat příkaz <strong>:dig</strong> s&nbsp;výpisem dostupných znaků a
paznaků.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Příklad použití Unicode znaků</h2>

<p>Podívejme se nyní na příklady použití Unicode znaků v&nbsp;příkladech. Nutno
říci, že (subjektivně) se zápis v&nbsp;některých případech zjednodušil,
minimálně pro čtení, ovšem samotný zápis operátorů je komplikovanější. Ostatně
posuďte sami:</p>

<pre>
result = 60⋅7÷10
print(result)
&nbsp;
if result ≥ 40 and result ≤ 50:
    print("very close")
&nbsp;
print(1 « 10)
print(1 ⊕ 255)
&nbsp;
-42 ↦ abs ↦ print
&nbsp;
"B" ↦ ord ↦ abs ↦ hex ↦ print
&nbsp;
range(11) ↦ sum ↦ print
&nbsp;
range(11) ↦ reversed ↦ sum ↦ print
&nbsp;
"B" ↦ hex ∘ abs ∘ ord ↦ print
&nbsp;
range(11) ↦ sum ∘ reversed ↦ print
</pre>

<p>Transpřeklad takto zapsaných operátorů je velmi přímočarý:</p>

<pre>
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# __coconut_hash__ = 0x3d5464d
&nbsp;
# Compiled with Coconut version 1.3.0 [Dead Parrot]
&nbsp;
# Coconut Header: -------------------------------------------------------------
&nbsp;
&nbsp;
# Compiled Coconut: -----------------------------------------------------------
&nbsp;
result = 60 * 7 / 10
print(result)
&nbsp;
if result &gt;= 40 and result &lt;= 50:
    print("very close")
&nbsp;
print(1 &lt;&lt; 10)
print(1 ^ 255)
&nbsp;
(print)((abs)(-42))
&nbsp;
(print)((hex)((abs)((ord)("B"))))
&nbsp;
(print)((sum)(range(11)))
&nbsp;
(print)((sum)((reversed)(range(11))))
&nbsp;
(print)((_coconut_forward_compose(ord, abs, hex))("B"))
&nbsp;
(print)((_coconut_forward_compose(reversed, sum))(range(11)))
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Pattern matching: základní klauzule</h2>

<p>Jazyk Coconut podporuje i <i>pattern matching</i>, jenž je ve funkcionálních
jazycích poměrně běžný. Pattern matching je realizován jazykovou konstrukcí
používající nová klíčová slova <strong>case</strong> a <strong>match</strong>.
V&nbsp;nejjednodušším případě dokážeme pomocí těchto slov nahradit poměrně
špatně čitelnou konstrukci <strong>if-elif-elif...-else</strong>:</p>

<pre>
def factorial_variant_A(n):
    <strong>case</strong> n:
        <strong>match</strong> 0:
            return 1
        <strong>match</strong> 1:
            return 1
        <strong>match</strong> x:
            return x * factorial_variant_A(x-1)
    <strong>else</strong>:
        raise TypeError("expecting integer &gt;= 0")
</pre>

<p>V&nbsp;tomto případě se bude interpret snažit najít ten vzor (pattern),
který nejlépe a jednoznačně odpovídá vstupu, tj.&nbsp;hodnotě proměnné
<strong>n</strong>. Postupně se testují vzorky 0, 1 a jakákoli jiná
hodnota.</p>

<p>Povšimněte si toho, že se na třetím řádku <strong>match x</strong> objevuje
<strong>x</strong>, což je proměnná platná jen v&nbsp;rámci dané větve a to
(samozřejmě) pouze v&nbsp;tom případě, že se tato větev bude provádět.</p>

<p>Ve skutečnosti se však mohou v&nbsp;části <strong>match</strong> použít i
další klauzule, zejména klauzule s&nbsp;podmínkou. Předchozí příklad nepracuje
korektně pro záporná čísla, takže doplníme příslušnou podmínku:</p>

<pre>
def factorial_variant_B(n):
    case n:
        match 0:
            return 1
        match 1:
            return 1
        <strong>match x if x &gt; 1</strong>:
            return x * factorial_variant_B(x-1)
    else:
        raise TypeError("expecting integer &gt;= 0")
</pre>

<p>Zde klademe na třetí vzorek další podmínku, takže mu nebude odpovídat
jakákoli hodnota proměnné <strong>n</strong>, ale pouze hodnota větší než
1.</p>

<p>Ani tato úprava však nezajistí zcela korektní chování. Ostatně si sami
vyzkoušejte, co se stane při volání s&nbsp;hodnotou 1.5. Přidáme tedy další
klauzuli na kontrolu typu s&nbsp;využitím operátoru <strong>is</strong>:</p>

<pre>
def factorial_variant_C(n):
    case n:
        match 0:
            return 1
        match 1:
            return 1
        <strong>match x is int if x &gt; 1</strong>:
            return x * factorial_variant_C(x-1)
    else:
        raise TypeError("expecting integer &gt;= 0")
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Pattern matching: složitější příklady použití</h2>

<p>Ukažme si některé poněkud složitější příklady použití pattern matchingu.
Například funkci, která rozhodne o tom, jak velký seznam je jí předán:</p>

<pre>
def type(x):
    case x:
        match [a, b]:
            return "list, 2 items"
        match [a]:
            return "list, 1 item"
        match []:
            return "empty list"
</pre>

<p>Otestování vzájemného vztahu dvou hodnot ve dvojici (seznamu, n-tici):</p>

<pre>
def pair(p):
    case p:
        match [x,x]:
            return "same values!"
        match [x,y] if x&gt;y:
            return "1st value is greater"
        match [x,y]:
            return "2nd value is greater"
    else:
        return "other"
</pre>

<p>Pokud se další funkci předá řetězec začínající na &bdquo;My name is &ldquo;,
vezme se z&nbsp;něj další text a přiřadí do proměnné <strong>name</strong>:</p>

<pre>
def say_hello(s):
    case s:
        match "My name is " + name:
            return "Hi " + name
</pre>

<p>Specifikovat je možné začátek i konec řetěze (ovšem ne regulárním
výrazem):</p>

<pre>
def get_name(s):
    case s:
        match name + "@root.cz":
            return name
&nbsp;
def say_hello2(s):
    case s:
        match "My name is " + name + ".":
            return "Hi " + name
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Rekurze a koncová rekurze</h2>

<p>Programovací jazyk Coconut podporuje i optimalizaci koncové rekurze, což je
technologie známá pod označením <i>TCO</i> neboli <i>Tail Call
Optimization</i>. Nejdříve si však popíšeme, jak je rekurze řešená
v&nbsp;samotném Pythonu (konkrétně v&nbsp;CPythonu) a jaká jsou její
omezení.</p>

<p>V&nbsp;naprosté většině algoritmů se objevují bloky kódu, které se mají
iterativně opakovat. Při programování s&nbsp;využitím funkcionálního
paradigmatu se iterace vyjadřuje formou rekurze. Ta je samozřejmě v&nbsp;jazyku
<i>Python</i> podporována (mezi jediné známější a v&nbsp;praxi používané
jazyky, které rekurzi nepodporovaly, patřil původní <i>FORTRAN</i> a
<i>BASIC</i>; psáno naschvál verzálkami). V&nbsp;některých případech je
teoreticky možné jeden typ rekurze (při níž se parametry a návratové adresy
musí ukládat na zásobník) nazvaný <i>koncová rekurze</i> optimalizovat, což
zjednodušeně řečeno znamená, že se namísto skutečného rekurzivního volání
funkce interně provede obyčejný skok (<i>koncový skok</i> či <i>koncové
volání</i>) bez nutnosti alokace místa na zásobníku pro parametry volané funkce
a návratové adresy.</p>

<p>Optimalizovaná koncová rekurze představuje při správném použití velmi silnou
programovací techniku, protože umožňuje zapisovat mnoho algoritmů v&nbsp;mnohdy
elegantní rekurzivní formě (naproti tomu autor Pythonu doporučuje používat
explicitní zápis smyčky či generátorovou notaci seznamů), ovšem skutečné
zpracování takto zapsaných algoritmů je stejně efektivní jako provádění
programové smyčky (každou koncovou rekurzi lze nahradit smyčkou a naopak).
Ovšem jen ve chvíli, kdy překladač či interpret daného programovacího jazyka
dokáže koncovou rekurzi optimalizovat, což například není případ Pythonu (i
když se objevilo několik návrhů na úpravu interpretu i několik <a
href="https://github.com/baruchel/tco">rozšiřujících modulů</a>).</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Klasická rekurze v&nbsp;Pythonu a její omezení</h2>

<p>Typickým &bdquo;školním&ldquo; příkladem ukazujícím rozdíl mezi normální
(plnou, skutečnou) rekurzí a koncovou rekurzí je výpočet faktoriálu. Ten můžeme
zapsat mnoha způsoby, například (jak je to v&nbsp;matematice obvyklé),
rekurzivně (zde bez kontrol, zda je zadáno kladné celé číslo!):</p>

<pre>
def factorial(n):
    if n &lt; 2:
        return 1
    else:
        return n*factorial(n-1)
</pre>

<p>Chování si můžeme jednoduše vyzkoušet:</p>

<pre>
for n in range(0, 11):
    print("{n}! = {f}".format(n=n, f=factorial(n)))
</pre>

<p>S&nbsp;očekávaným výsledkem:</p>

<pre>
0! = 1
1! = 1
2! = 2
3! = 6
4! = 24
5! = 120
6! = 720
7! = 5040
8! = 40320
9! = 362880
10! = 3628800
</pre>

<p>Z&nbsp;teoretického hlediska není na výše uvedené funkci nic nekorektního,
ovšem při jejím praktickém používání brzy narazíme na limit způsobený omezenou
velikostí zásobníku:</p>

<pre>
print(factorial(998))
print(factorial(999))
print(factorial(1000))
</pre>

<p>Podle verze Pythonu (2.x, 3.x) program vypočte faktoriál 998, Python 2.x
vypočítá i faktoriál 999 (Python 3.x již zde zhavaruje), ovšem posléze dojde
k&nbsp;překročení limitu zásobníku:</p>

<pre>
998
4027900501272209945382406745976015873066815457564711036474473577877262386372662
8687892313161858799279327326187206926532395562249549029885775908291258252711811
5540044131204964883707335062250983503282788739735011132006982444941985587005283
3780245208118682621495874739612984175986444702539017517287412178507405765322677
0021339872268114421977718630056298045480415170513378035696863643383049931961081
8197341194914502752560687555393768328059805942027406941465687273867068997087966
2635720033962406439251567153263633401414988030191879355452210924407527782568461
6693410323568411034647789039917938738764933248351085268065836314778365182198635
1375529220618900164975188281042287183543472177292257232652561904125692525097177
9993325186354470006164529999840307397153182191697073237996473757976873670132582
0336412948289108999137681930729225220552462634970526186400345385358987062075859
6211518646408335184218571196396412300835983314926628732700876798309217005024417
5957099044497069307963377988617539419021259649364125010072841471142609356331961
0734142386307123138516605594991443269593961122799016933824802793984359762890352
5815803809004448863145157344706452445088044626373001304259830129153477630812429
6401059379747616677850452039875082597760602858260912617450492754193936806136753
6626423271530543088921638461106913566243239104372599880588166305491309198163384
2006354699525518784828195856033032645477338126512662942408363494651203239333321
5021142528114117131488433705948011457775750356303128859897798638883207592248821
2714154436625150397491010072165067381030357707464015411283339304727602579981122
4571534249672518380758145683914398263952929391318702517417558325636082722982882
3725948165824868267286146331997262112730727751313252222401001409528425724908018
2299422406997161353460348787499685249862358438310601453383065002241105366850816
5547838962087111297947300444414551980512439088964301520461155436870989509667681
8051499779930444441384285820651427873564555286811143926809508154182080723935326
1612233943443703442428784211931605888112988747423999233655676433796853803686194
9918847009763612475872782742568849805927378373244946190707168428807837146267156
2431852137243645467011005577145204623350840821764311733469293303940714760718135
9875958881895431239423433132770022445501587177547610037161503194094509878889482
8812648426365776746774528000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000
&nbsp;
999
  File "recursive_factorial.py", line 5, in factorial
    return n*factorial(n-1)
  File "recursive_factorial.py", line 5, in factorial
    return n*factorial(n-1)
  File "recursive_factorial.py", line 5, in factorial
    return n*factorial(n-1)
  File "recursive_factorial.py", line 2, in factorial
    if n &lt; 2:
RuntimeError: maximum recursion depth exceeded in comparison
</pre>

<p>Kdo uhodne, proč Python 2.x dokáže vypočítat i faktoriál 999, zatímco u
Pythonu 3.x dojde k&nbsp;překročení limitu?</p>

<p>Mimochodem, maximální hloubku rekurze zjistíte velmi snadno:</p>

<pre>
import sys
&nbsp;
print(sys.getrecursionlimit())
</pre>

<p>Výše uvedený rekurzivní výpočet lze relativně malou úpravou převést na
výpočet který by teoreticky mohl vést na koncové volání:</p>

<pre>
def factorial(n, acc=1):
    if n &lt; 2:
        return acc
    else:
        return factorial(n-1, acc*n)
</pre>

<p>Proč tom tak je? Představte si, že <strong>n</strong> a <strong>acc</strong>
budou lokální proměnné a namísto rekurzivního volání funkce
<strong>factorial</strong> pouze modifikujeme hodnoty těchto proměnných a
provedeme skok na začátek funkce. Vzhledem k&nbsp;tomu, že si nemusíme
pamatovat mezivýsledky (jako je tomu u původního výpočtu), není nutné jejich
uložení na zásobník a kód se tedy transformuje do staré dobré programové
smyčky.</p>

<p>Chování si opět můžeme snadno otestovat:</p>

<pre>
for n in range(0, 11):
    print("{n}! = {f}".format(n=n, f=factorial(n)))
&nbsp;
print(factorial(999))
print(factorial(1000))
</pre>

<p>S&nbsp;výsledky:</p>
<pre>
0! = 1
1! = 1
2! = 2
3! = 6
4! = 24
5! = 120
6! = 720
7! = 5040
8! = 40320
9! = 362880
10! = 3628800
40238...
...
...
  File "tail_call_factorial.py", line 5, in factorial
    return factorial(n-1, acc*n)
  File "tail_call_factorial.py", line 5, in factorial
    return factorial(n-1, acc*n)
  File "tail_call_factorial.py", line 5, in factorial
    return factorial(n-1, acc*n)
  File "tail_call_factorial.py", line 5, in factorial
    return factorial(n-1, acc*n)
RuntimeError: maximum recursion depth exceeded
</pre>

<p>Ani v&nbsp;tomto případě nám tedy interpret Pythonu nepomohl a neprovedl
TCO!</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Optimalizace koncové rekurze v&nbsp;Coconutu</h2>

<p>Zkusme si napsat výpočet faktoriálu s&nbsp;koncovou rekurzí v&nbsp;Coconutu.
Je to snadné, navíc je program korektněji ochráněn před špatnými vstupy:</p>

<pre>
def factorial_tco(n, acc=1):
    case n:
        match 0:
            return acc
        match 1:
            return acc
        match _ is int if n &gt; 1:
            return factorial_tco(n-1, acc*n)
    else:
        raise TypeError("expecting integer &gt;= 0")
</pre>

<p>Po transpřekladu do Pythonu se můžeme přesvědčit o tom, že výpočet
faktoriálu 1000 a dokonce i 10000 již proběhne korektně, protože se provedla
TCO:</p>

<pre>
for n in range(11):
    print("{n}!={f}".format(n=n, f=factorial_tco(n)))
&nbsp;
print(factorial_tco(1000))
print(factorial_tco(10000))
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
0!=1
1!=1
2!=2
3!=6
4!=24
5!=120
6!=720
7!=5040
8!=40320
9!=362880
10!=3628800
402387260077093773543702433923
...
...
...
mnoho nul na konci...
</pre>

<p>Opět se podívejme na způsob transpřekladu do Pythonu:</p>

<pre>
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# __coconut_hash__ = 0x8f8983fe
&nbsp;
# Compiled with Coconut version 1.3.0 [Dead Parrot]
&nbsp;
# Coconut Header: -------------------------------------------------------------
&nbsp;
&nbsp;
# Compiled Coconut: -----------------------------------------------------------
&nbsp;
@_coconut_tco
def <strong>factorial_tco</strong>(n, acc=1):
    def <strong>_coconut_mock_func</strong>(n, acc=1): return n, acc
    while True:
        _coconut_match_to = n
        _coconut_match_check = False
        if _coconut_match_to == 0:
            _coconut_match_check = True
        if _coconut_match_check:
            return acc
        if not _coconut_match_check:
            if _coconut_match_to == 1:
                _coconut_match_check = True
            if _coconut_match_check:
                return acc
        if not _coconut_match_check:
            if _coconut.isinstance(_coconut_match_to, int):
                _coconut_match_check = True
            if _coconut_match_check and not (n &gt; 1):
                _coconut_match_check = False
            if _coconut_match_check:
                if factorial_tco is _coconut_recursive_func_0:
                    n, acc = <strong>_coconut_mock_func</strong>(n - 1, acc * n)
                    continue
                else:
                    return <strong>_coconut_tail_call</strong>(factorial_tco, n - 1, acc * n)
        if not _coconut_match_check:
            raise TypeError("expecting integer &gt;= 0")
&nbsp;
        return None
_coconut_recursive_func_0 = factorial_tco
for n in range(11):
    print("{n}!={f}".format(n=n, f=factorial_tco(n)))
&nbsp;
print(factorial_tco(1000))
print(factorial_tco(10000))
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů naleznete pod
následujícími odkazy:</p>

<table>
<tr><th>Zdrojový či transkompilovaný kód</th><th>Adresa</th></tr>
<tr><td>08-generator_chaining.coco</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/08-generator_chaining.coco">https://github.com/tisnik/presentations/blob/master/coconut/08-generator_chaining.coco</a></td></tr>
<tr><td>08-generator_chaining.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/08-generator_chaining.py">https://github.com/tisnik/presentations/blob/master/coconut/08-generator_chaining.py</a></td></tr>
<tr><td>09_??_operator.coco</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/09_%3F%3F_operator.coco">https://github.com/tisnik/presentations/blob/master/coconut/09_%3F%3F_operator.coco</a></td></tr>
<tr><td>09_??_operator.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/09_%3F%3F_operator.py">https://github.com/tisnik/presentations/blob/master/coconut/09_%3F%3F_operator.py</a></td></tr>
<tr><td>10_??=_operator.coco</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/10_%3F%3F=_operator.coco">https://github.com/tisnik/presentations/blob/master/coconut/10_%3F%3F=_operator.coco</a></td></tr>
<tr><td>10_??=_operator.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/10_%3F%3F=_operator.py">https://github.com/tisnik/presentations/blob/master/coconut/10_%3F%3F=_operator.py</a></td></tr>
<tr><td>11_elvis_operator.coco</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/11_elvis_operator.coco">https://github.com/tisnik/presentations/blob/master/coconut/11_elvis_operator.coco</a></td></tr>
<tr><td>11_elvis_operator.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/11_elvis_operator.py">https://github.com/tisnik/presentations/blob/master/coconut/11_elvis_operator.py</a></td></tr>
<tr><td>12_unicode_chars.coco</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/12_unicode_chars.coco">https://github.com/tisnik/presentations/blob/master/coconut/12_unicode_chars.coco</a></td></tr>
<tr><td>12_unicode_chars.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/12_unicode_chars.py">https://github.com/tisnik/presentations/blob/master/coconut/12_unicode_chars.py</a></td></tr>
<tr><td>13_pattern_matching.coco</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/13_pattern_matching.coco">https://github.com/tisnik/presentations/blob/master/coconut/13_pattern_matching.coco</a></td></tr>
<tr><td>13_pattern_matching.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/13_pattern_matching.py">https://github.com/tisnik/presentations/blob/master/coconut/13_pattern_matching.py</a></td></tr>
<tr><td>14_pattern_matching_2.coco</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/14_pattern_matching_2.coco">https://github.com/tisnik/presentations/blob/master/coconut/14_pattern_matching_2.coco</a></td></tr>
<tr><td>15_tail_call_optimization.coco</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/15_tail_call_optimization.coco">https://github.com/tisnik/presentations/blob/master/coconut/15_tail_call_optimization.coco</a></td></tr>
<tr><td>15_tail_call_optimization.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/15_tail_call_optimization.py">https://github.com/tisnik/presentations/blob/master/coconut/15_tail_call_optimization.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>recursion_limit.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/recursion_limit.py">https://github.com/tisnik/presentations/blob/master/coconut/recursion_limit.py</a></td></tr>
<tr><td>recursive_factorial.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/recursive_factorial.py">https://github.com/tisnik/presentations/blob/master/coconut/recursive_factorial.py</a></td></tr>
<tr><td>tail_call_factorial.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/tail_call_factorial.py">https://github.com/tisnik/presentations/blob/master/coconut/tail_call_factorial.py</a></td></tr>
</table>

<p>Poznámka: ke každému zdrojovému kódu napsanému v&nbsp;jazyku Coconut je
přiložen i vygenerovaný (transkompilovaný) kód v&nbsp;Pythonu, ovšem bez
zbytečného boilerplate.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Null coalescing operator<br />
<a href="https://en.wikipedia.org/wiki/Null_coalescing_operator">https://en.wikipedia.org/wiki/Null_coalescing_operator</a>
</li>

<li>Operátor koalescence<br />
<a href="https://cs.wikipedia.org/wiki/Oper%C3%A1tor_koalescence">https://cs.wikipedia.org/wiki/Oper%C3%A1tor_koalescence</a>
</li>

<li>Elvis operator<br />
<a href="https://en.wikipedia.org/wiki/Elvis_operator">https://en.wikipedia.org/wiki/Elvis_operator</a>
</li>

<li>Safe navigation operator<br />
<a href="https://en.wikipedia.org/wiki/Safe_navigation_operator">https://en.wikipedia.org/wiki/Safe_navigation_operator</a>
</li>

<li>Setting stacksize in a python script<br />
<a href="https://stackoverflow.com/questions/5061582/setting-stacksize-in-a-python-script">https://stackoverflow.com/questions/5061582/setting-stacksize-in-a-python-script</a>
</li>

<li>What is the maximum recursion depth in Python, and how to increase it?<br />
<a href="https://stackoverflow.com/questions/3323001/what-is-the-maximum-recursion-depth-in-python-and-how-to-increase-it?rq=1">https://stackoverflow.com/questions/3323001/what-is-the-maximum-recursion-depth-in-python-and-how-to-increase-it?rq=1</a>
</li>

<li>Does Python optimize tail recursion?<br />
<a href="https://stackoverflow.com/questions/13591970/does-python-optimize-tail-recursion">https://stackoverflow.com/questions/13591970/does-python-optimize-tail-recursion</a>
</li>

<li>Programovací jazyk APL: programování bez smyček<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-apl-programovani-bez-smycek/">https://www.root.cz/clanky/programovaci-jazyk-apl-programovani-bez-smycek/</a>
</li>

<li>Programovací jazyk APL - dokončení<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-apl-dokonceni/">https://www.root.cz/clanky/programovaci-jazyk-apl-dokonceni/</a>
</li>

<li>Tail call<br />
<a href="https://en.wikipedia.org/wiki/Tail_call">https://en.wikipedia.org/wiki/Tail_call</a>
</li>

<li>Tail Call Optimization for Python<br />
<a href="https://github.com/baruchel/tco">https://github.com/baruchel/tco</a>
</li>

<li>Tail Recursion Elimination<br />
<a href="http://neopythonic.blogspot.cz/2009/04/tail-recursion-elimination.html">http://neopythonic.blogspot.cz/2009/04/tail-recursion-elimination.html</a>
</li>

<li>Origins of Python's "Functional" Features <br />
<a href="http://python-history.blogspot.cz/2009/04/origins-of-pythons-functional-features.html">http://python-history.blogspot.cz/2009/04/origins-of-pythons-functional-features.html</a>
</li>

<li>Tail recursion decorator revisited<br />
<a href="http://fiber-space.de/wordpress/2009/04/20/tail-recursion-decorator-revisited/">http://fiber-space.de/wordpress/2009/04/20/tail-recursion-decorator-revisited/</a>
</li>

<li>Koncová rekurze<br />
<a href="https://cs.wikipedia.org/wiki/Koncov%C3%A1_rekurze">https://cs.wikipedia.org/wiki/Koncov%C3%A1_rekurze</a>
</li>

<li>Recursion (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Recursion_%28computer_science%29">https://en.wikipedia.org/wiki/Recursion_%28computer_science%29</a>
</li>

<li>Coconut: Simple, elegant, Pythonic functional programming<br />
<a href="http://coconut-lang.org/">http://coconut-lang.org/</a>
</li>

<li>coconut 1.1.0 (Python package index)<br />
<a href="https://pypi.python.org/pypi/coconut/1.1.0">https://pypi.python.org/pypi/coconut/1.1.0</a>
</li>

<li>Coconut Tutorial<br />
<a href="http://coconut.readthedocs.io/en/master/HELP.html">http://coconut.readthedocs.io/en/master/HELP.html</a>
</li>

<li>Coconut FAQ<br />
<a href="http://coconut.readthedocs.io/en/master/FAQ.html">http://coconut.readthedocs.io/en/master/FAQ.html</a>
</li>

<li>Coconut Documentation<br />
<a href="http://coconut.readthedocs.io/en/master/DOCS.html">http://coconut.readthedocs.io/en/master/DOCS.html</a>
</li>

<li>Coconut na Redditu<br />
<a href="https://www.reddit.com/r/Python/comments/4owzu7/coconut_functional_programming_in_python/">https://www.reddit.com/r/Python/comments/4owzu7/coconut_functional_programming_in_python/</a>
</li>

<li>Repositář na GitHubu<br />
<a href="https://github.com/evhub/coconut">https://github.com/evhub/coconut</a>
</li>

<li>patterns<br />
<a href="https://github.com/Suor/patterns">https://github.com/Suor/patterns</a>
</li>

<li>Source-to-source compiler<br />
<a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">https://en.wikipedia.org/wiki/Source-to-source_compiler</a>
</li>

<li>The Lua VM, on the Web<br />
<a href="https://kripken.github.io/lua.vm.js/lua.vm.js.html">https://kripken.github.io/lua.vm.js/lua.vm.js.html</a>
</li>

<li>Lua.vm.js REPL<br />
<a href="https://kripken.github.io/lua.vm.js/repl.html">https://kripken.github.io/lua.vm.js/repl.html</a>
</li>

<li>lua2js<br />
<a href="https://www.npmjs.com/package/lua2js">https://www.npmjs.com/package/lua2js</a>
</li>

<li>Wisp na GitHubu<br />
<a href="https://github.com/Gozala/wisp">https://github.com/Gozala/wisp</a>
</li>

<li>Wisp playground<br />
<a href="http://www.jeditoolkit.com/try-wisp/">http://www.jeditoolkit.com/try-wisp/</a>
</li>

<li>REPL v prohlížeči<br />
<a href="http://www.jeditoolkit.com/interactivate-wisp/">http://www.jeditoolkit.com/interactivate-wisp/</a>
</li>

<li>Minification (programming)<br />
<a href="https://en.wikipedia.org/wiki/Minification_(programming)">https://en.wikipedia.org/wiki/Minification_(programming)</a>
</li>

<li>JavaScript is Assembly Language for the Web: Sematic Markup is Dead! Clean vs. Machine-coded HTML<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx">http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx</a>
</li>

<li>JavaScript is Web Assembly Language and that's OK.<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx">http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx</a>
</li>

<li>Dart<br />
<a href="https://www.dartlang.org/">https://www.dartlang.org/</a>
</li>

<li>CoffeeScript<br />
<a href="http://coffeescript.org/">http://coffeescript.org/</a>
</li>

<li>TypeScript<br />
<a href="http://www.typescriptlang.org/">http://www.typescriptlang.org/</a>
</li>

<li>JavaScript: The Web Assembly Language?<br />
<a href="http://www.informit.com/articles/article.aspx?p=1856657">http://www.informit.com/articles/article.aspx?p=1856657</a>
</li>

<li>asm.js<br />
<a href="http://asmjs.org/">http://asmjs.org/</a>
</li>

<li>List of languages that compile to JS<br />
<a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</a>
</li>

<li>Permutation<br />
<a href="https://en.wikipedia.org/wiki/Permutation">https://en.wikipedia.org/wiki/Permutation</a>
</li>

<li>Pattern matching<br />
<a href="https://en.wikipedia.org/wiki/Pattern_matching">https://en.wikipedia.org/wiki/Pattern_matching</a>
</li>

<li>Pattern matching v&nbsp;Rustu<br />
<a href="https://www.root.cz/clanky/rust-funkce-lambda-vyrazy-a-rozhodovaci-konstrukce-match/#k13">https://www.root.cz/clanky/rust-funkce-lambda-vyrazy-a-rozhodovaci-konstrukce-match/#k13</a>
</li>

<li>SNOBOL<br />
<a href="https://en.wikipedia.org/wiki/SNOBOL">https://en.wikipedia.org/wiki/SNOBOL</a>
</li>

<li>Podpůrný plugin pro Vim<br />
<a href="https://github.com/manicmaniac/coconut.vim">https://github.com/manicmaniac/coconut.vim</a>
</li>

<li>Příkaz (programování)<br />
<a href="https://cs.wikipedia.org/wiki/P%C5%99%C3%ADkaz_%28programov%C3%A1n%C3%AD%29">https://cs.wikipedia.org/wiki/P%C5%99%C3%ADkaz_%28programov%C3%A1n%C3%AD%29</a>
</li>

<li>Threading Macros Guide<br />
<a href="https://clojure.org/guides/threading_macros">https://clojure.org/guides/threading_macros</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

