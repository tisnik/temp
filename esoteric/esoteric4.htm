<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyky z vývojářského pekla (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyky z vývojářského pekla (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve čtvrté a současně i poslední části článku o esoterických programovacích jazycích si nejdříve popíšeme jazyky založené na principu Turingova stroje, jehož páska obsahuje pouze binární symboly. Dále se seznámíme s&nbsp;uměle vytvořeným strojovým kódem a na závěr se zmíníme o jazycích, které nejsou založeny na angličtině.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyky z&nbsp;vývojářského pekla (dokončení)</a></p>
<p><a href="#k02">2. Boolfuck</a></p>
<p><a href="#k03">3. Smallfuck</a></p>
<p><a href="#k04">4. BitChanger</a></p>
<p><a href="#k05">5. URM &ndash; Universal Register Machine</a></p>
<p><a href="#k06">6. Strojový kód</a></p>
<p><a href="#k07">7. OISC &ndash; One instruction set computer</a></p>
<p><a href="#k08">8. Proč se omezovat jen na angličtinu?</a></p>
<p><a href="#k09">9. DSSP</a></p>
<p><a href="#k10">10. Lingua::Romana::Perligata</a></p>
<p><a href="#k11">11. Rapira</a></p>
<p><a href="#k12">12. Fjölnir</a></p>
<p><a href="#k13">13. Chinese BASIC a Chinese Python</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyky z&nbsp;vývojářského pekla (dokončení)</h2>

<p>V&nbsp;dnešním článku si popíšeme tři skupiny esoterických (nebo jinak
&bdquo;šílených&ldquo;) programovacích jazyků. První skupinu jazyků, se kterou
se v&nbsp;dnešním článku alespoň ve stručnosti seznámíme, tvoří jazyky, které
jsou založeny na principu Turingova stroje. S&nbsp;takovými jazyky už jsme se
několikrát seznámili, ovšem dnešní skupina esoterických jazyků se odlišuje tím,
že se namísto celočíselných symbolů na pásku Turingova stroje mohou ukládat
pouze binární symboly 0 a 1. To s&nbsp;sebou samozřejmě přináší i nutné změny
v&nbsp;množině příkazů a odlišný přístup k&nbsp;vytváření algoritmů. Mezi tyto
jazyky patří <a href="#k02">Boolfuck</a>, <a href="#k03">Smallfuck</a> a <a
href="#k04">BitChanger</a>. Ve skupině druhé pak nalezneme spíše virtuální
stroje programované buď přímo ve strojovém kódu nebo v&nbsp;jednoduchém
assembleru. Třetí skupinu pak tvoří ty programovací jazyky, které nejsou
založeny na angličtině, ale na jiných mluvených jazycích a popř.&nbsp;i
abecedách odlišných od latinky. Sem spadají například <a href="#k09">DSPP</a>,
<a href="#k10">Lingua::Romana::Perligata</a>, <a href="#k11">Rapira</a>, <a
href="#k12">Fjölnir</a> či <a href="#13">Chinese BASIC</a>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Boolfuck</h2>

<p><i>Weaker, less useful, more futile: Boolfuck.</i></p>

<p>Prvním programovacím jazykem, s&nbsp;nímž se dnes seznámíme, je jazyk
nazvaný <i>Boolfuck</i>. Jak již název tohoto jazyka napovídá, jedná se o další
z&nbsp;mnoha variant <a
href="http://www.root.cz/clanky/programovaci-jazyky-z-vyvojarskeho-pekla/#k03">Brainfucku</a>.
Zatímco však <i>Brainfuck</i> pracoval na principu simulace Turingova stroje
s&nbsp;páskou, na níž bylo možné ukládat symboly odpovídající (většinou)
celočíselným hodnotám 0 až 255, je tomu u jazyka <i>Boolfuck</i> jinak &ndash;
zde se pracuje pouze s&nbsp;binárními symboly 0 a 1, což znamená, že pásku
Turingova stroje tvoří řetězec nul a jedniček. Tyto změny vedly i ke změnám
v&nbsp;příkazech jazyka, například operace pro čtení pracuje
s&nbsp;jednotlivými bity (omezení vstupu, celý znak je zapotřebí načíst osmi
operacemi), operace pro výstup (zapisuje se středníkem namísto tečky) postupně
tvoří výstupní proud složených z&nbsp;nul a jedniček, které se skládají do
znakového výstupu. Taktéž se změnily dostupné operace, protože se namísto
přičtení a odečtení jedničky pouze mění hodnota bitu:</p>

<table>
<tr><th>#</th><th>Příkaz</th><th>Význam znaku/příkazu</th></tr>
<tr><td>1</td><td>&gt;</td><td>posun ukazatele na &bdquo;pásce&ldquo; doprava na další políčko</td></tr>
<tr><td>2</td><td>&lt;</td><td>posun ukazatele na &bdquo;pásce&ldquo; doleva na předchozí políčko</td></tr>
<tr><td>3</td><td>+   </td><td>změna bitu (negace 0&rarr;1, 1&rarr;0)</td></tr>
<tr><td>4</td><td>,   </td><td>načtení bitu a uložení jeho hodnoty do aktuálního políčka</td></tr>
<tr><td>5</td><td>;   </td><td>obsah aktuálního políčka se vloží do výstupního proudu, v&nbsp;němž jsou skládány osmibitové znaky</td></tr>
<tr><td>6</td><td>[   </td><td>v&nbsp;případě, že je hodnota v&nbsp;aktuálním políčku nulová, přesune se program za odpovídající ]</td></tr>
<tr><td>7</td><td>]   </td><td>řízení se přesune na odpovídající [</td></tr>
</table>

<p>Ukažme si demonstrační příklad naprogramovaný v&nbsp;Boolfucku. Jedná se o
klasický &bdquo;Hello, world!&ldquo;, který je nutné přepsat následujícím
způsobem (jedná se o optimalizaci, manipulace s&nbsp;binárními symboly je
mnohdy výhodnější, než se snažit získat kódy písmen operacemi + a -):</p>

<pre>
;;;+;+;;+;+;
+;+;+;+;;+;;+;
;;+;;+;+;;+;
;;+;;+;+;;+;
+;;;;+;+;;+;
;;+;;+;+;+;;
;;;;;+;+;;
+;;;+;+;;;+;
+;;;;+;+;;+;
;+;+;;+;;;+;
;;+;;+;+;;+;
;;+;+;;+;;+;
+;+;;;;+;+;;
;+;+;+;
</pre>

<p>Autor tohoto jazyka <a href="http://samuelhughes.com/boof/">uvádí</a> i
převodní tabulku mezi <i>Brainfuckem</i> a <i>Boolfuckem</i> (bez jakýchkoli
optimalizací):</p>

<table>
<tr><th>Příkaz v&nbsp;Brainfucku</th><th>Příkaz v&nbsp;Boolfucku</th></tr>
<tr><td>+   </td><td>&gt;[&gt;]+&lt;[+&lt;]&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;[+]&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</td></tr>
<tr><td>-   </td><td>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;+[&gt;+]&lt;[&lt;]&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;[+]&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</td></tr>
<tr><td>&lt;</td><td>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</td></tr>
<tr><td>&gt;</td><td>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</td></tr>
<tr><td>,   </td><td>&gt;,&gt;,&gt;,&gt;,&gt;,&gt;,&gt;,&gt;,&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</td></tr>
<tr><td>.   </td><td>&gt;;&gt;;&gt;;&gt;;&gt;;&gt;;&gt;;&gt;;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</td></tr>
<tr><td>[   </td><td>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;+[&gt;+]&lt;[&lt;]&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;[+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;[&gt;]+&lt;[+&lt;]</td></tr>
<tr><td>]   </td><td>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;+[&gt;+]&lt;[&lt;]&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;]&lt;[+&lt;]</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Smallfuck</h2>

<p>Jazyk nazvaný <i>Smallfuck</i> je v&nbsp;mnoha ohledech podobný výše
zmíněnému <i>Boolfucku</i>, takže popis budeme moci zkrátit. Ve
<i>Smallfucku</i> nenalezneme žádné příkazy pro vstup a výstup dat, a to
z&nbsp;toho důvodu, že se jedná o testovací jazyk, který měl být překládán do
dalšího esoterického jazyku nazvaného <i>SMETANA (Self-Modifying Extremely Tiny
AutomatoN Application)</i>. Další (jen malou) změnou je záměna příkazu + za
příkaz * (i když + bylo logičtější):</p>

<table>
<tr><th>#</th><th>Příkaz</th><th>Význam znaku/příkazu</th></tr>
<tr><td>1</td><td>&gt;</td><td>posun ukazatele na &bdquo;pásce&ldquo; doprava na další políčko</td></tr>
<tr><td>2</td><td>&lt;</td><td>posun ukazatele na &bdquo;pásce&ldquo; doleva na předchozí políčko</td></tr>
<tr><td>3</td><td>*   </td><td>změna bitu (negace 0&rarr;1, 1&rarr;0)</td></tr>
<tr><td>4</td><td>[   </td><td>v&nbsp;případě, že je hodnota v&nbsp;aktuálním políčku nulová, přesune se program za odpovídající ]</td></tr>
<tr><td>5</td><td>]   </td><td>řízení se přesune na odpovídající [</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. BitChanger</h2>

<p>Posledním esoterickým (a současně i dostatečně šíleným) programovacím
jazykem založeným na principu Turingova stroje s&nbsp;páskou obsahující pouze
binární symboly je jazyk nazvaný příznačně <i>BitChanger</i>. I tento jazyk
ideově vychází ze slavného Brainfucku, ovšem počet instrukcí se zde snižuje na
pouhé čtyři příkazy, které jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Příkaz</th><th>Význam znaku/příkazu</th></tr>
<tr><td>1</td><td>&lt;</td><td>posun ukazatele na &bdquo;pásce&ldquo; doleva na předchozí políčko</td></tr>
<tr><td>2</td><td>}   </td><td>kombinace příkazu &gt; a negace bitu</td></tr>
<tr><td>3</td><td>[   </td><td>v&nbsp;případě, že je hodnota v&nbsp;aktuálním políčku nulová, přesune se program za odpovídající ]</td></tr>
<tr><td>4</td><td>]   </td><td>řízení se přesune na odpovídající [</td></tr>
</table>

<p>Zdánlivě chybějící příkaz &gt; je možné nahradit sekvencí
&bdquo;}&lt;}&ldquo;, protože tato sekvence posune ukazatel doprava na další
políčko, poté provede inverzi tohoto políčka (bitu), vrátí se zpět doleva a
znovu se posune doprava s&nbsp;inverzí. Ve výsledku se tedy ukazatel pouze
přesune doprava, protože dvojí inverze stejného bitu nevede k&nbsp;žádné změně
na binární pásce.</p>

<p>Zdánlivě chybějící příkazy pro čtení a zápis (respektive pro práci se
standardním vstupem a výstupem) jsou nahrazeny tím, že prvních několik bitů na
binární pásce Turingova stroje má speciální význam. Tyto bity si můžeme
představit jako SFR (registry speciálních funkcí) v&nbsp;mikrořadičích:</p>

<table>
<tr><th>Políčko na pásce</th><th>Význam</th></tr>
<tr><td>5</td><td>pokud je nastaveno na jedničku, jsou povoleny operace vstupu a výstupu</td></tr>
<tr><td>6</td><td>po operaci vstupu (čtení dat) je zde 0 pro platný znak a 1 pro EOF</td></tr>
<tr><td>7</td><td>řízení směru toku dat: 0=vstup, 1=výstup</td></tr>
<tr><td>8-15</td><td>osm bitů pro zápis či přečtení celého ASCII znaku (+ nejvyššího bitu mimo ASCII)</td></tr>
</table>

<p>Výsledkem je tedy esoterický jazyk s&nbsp;velmi originální sadou příkazů, u
nějž je opět možné najít korespondenci (mapování) mezi příkazy Brainfucku a
BitChangeru.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. URM &ndash; Universal Register Machine</h2>

<p>O Turingově stroji jakožto teoretickém konceptu, na němž jsou některé
esoterické programovací jazyky založeny, jsme se již hned několikrát zmiňovali.
Ovšem kromě tohoto konceptu existují i koncepty takzvaných registrových strojů
(<a
href="https://en.wikipedia.org/wiki/Register_machine">https://en.wikipedia.org/wiki/Register_machine</a>).
Pokud máte nainstalovaný balíček <strong>vim-enhanced</strong>, máte interpret
jednoho takového stroje k&nbsp;dispozici ve formě Vimovských maker navázaných
na určité klávesy. Celý interpret je tvořen pouhými pěti řádky (viz
<strong>$VIMRUNIME/macror/urm/urm.vim</strong>, čitelnost pravda poněkud
utrpěla, což ovšem dobře zapadá do konceptu tohoto článku):</p>

<pre>
map * 1G/INIT^V^Mj"iT@i1G/INIT^V^MdG
map g 1G/^[(as;.]^V^Mi^V^M&gt;,^V^[mkkmw@k
map T y$
map F yl
map = 'kf,
</pre>

<p>Důležité je především první mapování (klávesa *), protože touto klávesou se
celý interpret inicializuje a druhou zkratkou g se spustí nad textem uloženým
v&nbsp;aktuálním bufferu. A jak vlastně vypadá zdrojový text zpracovávaný tímto
interpretrem? První řádky (může jich být prakticky libovolný počet) začínají
znakem &gt;. Ihned za tímto znakem je uloženo číslo. Tyto řádky obsahují stav
registrů při spuštění interpretru, tj.&nbsp;počáteční stav a současně se tyto
řádky přepisují při interpretaci, takže ihned můžete vidět výsledek nějaké
operace. První registr má index 1, ne 0 (to je však v&nbsp;podstatě jedno). Za
těmito řádky již začínají vlastní příkazy, které mohou být tvaru:</p>

<table>
<tr><th>#</th><th>Příkaz</th><th>Význam</th></tr>
<tr><td>1</td><td>a[n]</td><td>zvýšení obsahu registru n o jedničku</td></tr>
<tr><td>2</td><td>s[n]</td><td>snížení obsahu registru n o jedničku</td></tr>
<tr><td>3</td><td>x;y</td><td>spojení příkazů x a y, nejprve se provede příkaz x, potom příkaz y</td></tr>
<tr><td>4</td><td>(x)n</td><td>dokud je registr n nenulový, provádí se příkaz x (smyčka typu <strong>while</strong>)</td></tr>
<tr><td>5</td><td>. </td><td>ukončení interpretru</td></tr>
</table>

<p>Po zkušenostech s&nbsp;Brainfuckem vás asi nepřekvapí, že i tak základní
operace, jakou je kopie hodnoty z&nbsp;registru do jiného registru či součet
obsahů dvou registrů, musí být implementovány nějakou formou smyčky:</p>

<p>Vynulování registru číslo 42:</p>

<pre>
(s42)42.
</pre>

<p>Hodnota z&nbsp;registru číslo 3 se přičte k&nbsp;obsahu registru číslo 2 a
současně se registru číslo 3 vynuluje:</p>

<pre>
(a2;s3)3.
</pre>

<p>Kopie je už mnohem složitější, a to proto, že nejdříve provedeme operaci
a1=a2, a3=a2, a2=0 a poté operaci a2+=a1 (obnovení původní hodnoty).
Předpokladem je, že na začátku je a1=0 a a3=0:</p>

<pre>
(a1;a3;s2)2; (a2;s1)1.
</pre>

<p>Násobení a2=a2*a3 (registry a4 a a5 plní pomocnou funkci):</p>

<pre>
(a4;a5;s2)2; ((a2;s4)4; s3; (a1;a4;s5)5; (a5;s1)1)3.
</pre>

<p>Dělení na závěr (celý program má být na jednom řádku):</p>

<pre>
(a9;s2)2; (a2;a10;s3)3; (a3;s2)2; (a2;(s3)3)3; a3;
(s3;s2)2; (s3;a2)3; (a2)2;(a2;s9)9;(a3;s10)10;
(a9;a10;s2)2; (a11;a12;s3)3; (a2;s12)12; (a3;s9)9;
(s2;s3)3; (a3;s2)2; (a2;(s3)3)3; a3; (s3;s2)2;
(s3;a2)3; (a1;s2)2; (a2;s10)10; (a3;s11)11;
((a12;a13;s3)3; (a3;s13)13; (s2;s3)3; (a3;s12)12;
a14; (s1)1; (a9;a10;s2)2; (a11;a12;s3)3; (a2;s12)12;
(a3;s9)9; (s2;s3)3; (a3;s2)2; (a2;(s3)3)3; a3;
(s3;s2)2; (s3;a2)3; (a1;s2)2; (a2;s10)10; (a3;s11)11)1;
(s2)2; (a2;s14)14. 
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Strojový kód</h2>

<p>Existuje hned celá řada návrhů procesorů s&nbsp;&bdquo;esoterickým&ldquo;
(čti: dostatečně šíleným) strojovým kódem resp.&nbsp;přesněji řečeno se šílenou
instrukční sadou. Typicky se jedná o instrukční sady, v&nbsp;nichž je počet
instrukcí snížen na nejnutnější minimum, což je v&nbsp;přímém kontrastu
například s&nbsp;instrukční sadou procesorů řady x86. A jaký je vlastně
minimální počet instrukcí, které ještě dávají smysl? Některé mikrořadiče se
spokojí přibližně s&nbsp;35 instrukcemi (PIC s&nbsp;12bitovými instrukcemi),
ovšem to samozřejmě ještě není nejmenší číslo. Zajímavý je návrh instrukční
sady procesoru nazvaného jednoduše &bdquo;Viktor's amazing 4-bit
processor&ldquo;. Tento procesor obsahuje pouze šestnáct instrukcí, které
pravděpodobně budou srozumitelné všem čtenářům, kteří někdy pracovali
v&nbsp;assembleru (u některých typů procesorů se pouze podmíněné skoky mění na
podmíněné větvení, tedy <i>branch</i>):</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td> 1</td><td>CLF</td><td>vymazání příznaků</td></tr>
<tr><td> 2</td><td>AND</td><td>bitová operace AND, nastavení příznaku zero</td></tr>
<tr><td> 3</td><td>OR</td><td>bitová operace OR, nastavení příznaku zero</td></tr>
<tr><td> 4</td><td>ADD</td><td>součet akumulátoru s&nbsp;operandem (konstantou)</td></tr>
<tr><td> 5</td><td>SUB</td><td>součet akumulátoru s&nbsp;negací operandu (konstantou)</td></tr>
<tr><td> 6</td><td>CMP</td><td>porovnání akumulátoru s&nbsp;operandem (konstantou)</td></tr>
<tr><td> 7</td><td>ROL</td><td>rotace akumulátoru (+ carry) doleva</td></tr>
<tr><td> 8</td><td>ROR</td><td>rotace akumulátoru (+ carry) doprava</td></tr>
<tr><td> 9</td><td>LDA</td><td>načtení hodnotu z&nbsp;absolutní adresy a uložení do akumulátoru</td></tr>
<tr><td>10</td><td>STA</td><td>uložení akumulátoru na zadanou absolutní adresu</td></tr>
<tr><td>11</td><td>JMP</td><td>nepodmíněný skok na zadanou adresu</td></tr>
<tr><td>12</td><td>JNZ</td><td>podmíněný skok při zero==0</td></tr>
<tr><td>13</td><td>JNC</td><td>podmíněný skok při carry==0</td></tr>
<tr><td>14</td><td>JND</td><td>podmíněný skok na základě polohy přepínače (či tlačítka) na panelu</td></tr>
<tr><td>15</td><td>SPC</td><td>hodnota čítače instrukcí se uloží do paměti na absolutní adresu</td></tr>
<tr><td>16</td><td>HLT</td><td>ukončení programu</td></tr>
</table>

<p>Povšimněte si, že se jedná o akumulátorový CPU, v&nbsp;němž je většinou
druhým operandem pouhá konstanta. Relativní skoky či skoky do podprogramu se
musí řešit nepřímo kombinací instrukcí SPC a JMP, podobně jako pokročilejší
adresovací režimy.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. OISC &ndash; One instruction set computer</h2>

<p>Zajímavým konceptem jsou instrukční kódy s&nbsp;jedinou instrukcí, což
vlastně znamená, že vůbec není zapotřebí ukládat operační kód instrukce, ale
pouze adresu (adresy) operandu (operandů). Příkladem může být univerzální
instrukce <strong>SBNZ</strong> neboli &bdquo;Subtract and branch if not equal
to zero&ldquo;. Tato instrukce má čtyři operandy &ndash; první dva operandy
obsahují adresy dvou míst v&nbsp;paměti, které se od sebe odečtou; třetí
operand obsahuje adresu, kam se uloží výsledek a konečně operand čtvrtý
obsahuje adresu další instrukce v&nbsp;případě, že je výsledek rozdílu
nenulový. Pokud je výsledek nulový, pokračuje program v&nbsp;následující
instrukci. Dalším příkladem univerzální instrukce je <strong>SUBLEQ</strong>
neboli &bdquo;Subtract and branch if less than or equal to zero&ldquo;, která
se odlišuje tím, že má pouze tři operandy: adresu prvního čísla, adresu čísla
druhého (a současně adresu výsledku) a adresu další instrukce v&nbsp;případě,
že je podmínka splněna. Jak se dají implementovat další instrukce
s&nbsp;využitím <strong>SUBLEQ</strong> ukazují následující příklady:</p>

<pre>
<strong>JMP c</strong>
subleq Z, Z, c
&nbsp;
<strong>ADD a, b</strong>
subleq a, Z
subleq Z, b
subleq Z, Z
&nbsp;
<strong>MOV a, b </strong>
subleq b, b
subleq a, Z
subleq Z, b
subleq Z, Z
</pre>

<p>atd.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Proč se omezovat jen na angličtinu?</h2>

<p>Pravděpodobně každý vývojář si alespoň jednou položil otázku, jestli je
angličtina skutečně tím jediným a nejlepším jazykem pro zápis programů,
resp.&nbsp;přesněji řečeno pro zápis klíčových slov. Už od dob FORTRANu se
totiž v&nbsp;programování používají klíčová slova typu <strong>IF</strong>,
<strong>DO</strong>, oblíbené <strong>GOTO/GO TO</strong>,
<strong>CONTINUE</strong> atd. Samozřejmě však vzniklo mnoho jazyků
s&nbsp;národními variantami příkazů. Někteří čtenáři si možná pamatují na
českou verzi jazyka <i>Karel</i> (což i přes jméno není původní tuzemský jazyk)
s&nbsp;příkazy <strong>KROK</strong>, <strong>VLEVOVBOK</strong>,
<strong>POLOZ</strong>, <strong>ZVEDNI</strong> apod. Na Slovensku později
vznikl jazyk pojmenovaný <i>Robot Karol++</i> a později <i>Robot Emil</i>
(takový předchůdce Minecraftu :-) s&nbsp;příkazy, které naleznete na této
stránce: <a
href="http://www.emil.input.sk/info_sk.htm">http://www.emil.input.sk/info_sk.htm</a>.
Avšak zajímavější a šílenější jsou další jazyky, které si popíšeme
v&nbsp;navazujících kapitolách. Mým osobním favoritem je <a
href="#k12">Fjölnir</a></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. DSSP</h2>

<p><i>DSSP was not invented. It was found. That is why DSSP has not versions,
but only extensions. Forth is created by practice. DSSP is created by
theory.</i></p>

<p>Velmi zajímavý je průzkum programovacích jazyků používaných v&nbsp;bývalém
Sovětském Svazu. Některé z&nbsp;používaných jazyků byly částečně či úplně
převzaty ze západních zemí, ovšem v&nbsp;SSSR vzniklo i poměrně mnoho
originálních (a minimálně v&nbsp;jednom případě i elegantních) programovacích
jazyků. Z&nbsp;převzatých technologií se jedná především o <i>FORTRAN</i>
(první vyšší programovací jazyk vyvinutý firmou IBM, ale později používaný i
v&nbsp;zemích RVHP, především v&nbsp;souvislosti s&nbsp;vývojem počítačů
kompatibilních s&nbsp;mainframy firmy IBM), <i>COBOL</i> (v&nbsp;azbuce
zapisovaný &#1050;&#1086;&#1073;&#1086;&#1083;) a taktéž <i>ALGOL</i>
(&#1040;&#1083;&#1075;&#1086;&#1083;, využitý například na počítačích
<i>Elbrus</i> a <i>Odra</i>), popř.&nbsp;jeho varianta pojmenovaná
&#1040;&#1083;&#1075;&#1101;&#1082;, která byla jakýmsi hybridem mezi COBOLem a
originálním ALGOLem. Ovšem v&nbsp;Sovětském Svazu se používaly i mnohé další
programovací jazyky. Mezi ně patří i originální Sovětský programovací jazyk
nazvaný <i>DSSP</i>, který byl původně vyvinut pro tvorbu aplikací
&bdquo;trojkovém&ldquo; počítači <i>Setuň</i>
(&#1057;&#1077;&#1090;&#1091;&#1085;&#1100;), ale později se z&nbsp;různých
důvodů rozšířil i na mnohé další platformy, například i na třicetidvoubitové
osobní počítače PC.</p>

<p>Z&nbsp;instrukčního kódu počítače <i>Setuň</i> (pracujícího z&nbsp;dnešního
pohledu velmi netradičně ve vyvážené trojkové soustavě namísto dnes obvyklé
soustavy binární) byl na začátku osmdesátých let minulého století odvozen vyšší
programovací jazyk nazvaný (v&nbsp;překladu) <i>DSSP</i> neboli <i>Dialog
System for Structured Programming</i>. Některé syntaktické i sémantické
konstrukce, které můžeme v&nbsp;tomto programovacím jazyku nalézt, pochází
z&nbsp;programovacího jazyka <i>Forth</i> Chucka Moorea, ovšem tvůrci
<i>DSSP</i> se při návrhu tohoto jazyka, na rozdíl od <i>Forthu</i>, poměrně
striktně drželi hesla: &bdquo;One word of text &ndash; One word of machine
code&ldquo; (jde samozřejmě o slovní hříčku, neboť termín &bdquo;slovo&ldquo;
má v&nbsp;tomto hesle dva odlišné významy). To zjednodušeně řečeno znamená, že
téměř každé klíčové slovo či speciální znak se přímo překládá do jednoho
operačního kódu uloženého v&nbsp;operační paměti v&nbsp;jednom slově, což je
v&nbsp;případě počítače <i>Setuň</i> n-tice <i>tritů</i> (nikoli bitů).
V&nbsp;následujících odstavcích si velmi stručně popíšeme některé základní
konstrukce, ze kterých se programy vytvářené v&nbsp;programovacím jazyce
<i>DSSP</i> skládají.</p>

<p>Oba výše zmíněné programovací jazyky, tj.&nbsp;jak &bdquo;východní&ldquo;
<i>DSSP</i>, tak i &bdquo;západní&ldquo; <i>Forth</i>, jsou založeny na použití
dvou zásobníků. První z&nbsp;těchto zásobníků se nazývá <i>zásobník
operandů</i>, druhý <i>zásobník návratových adres</i>. Většina matematických
operací je prováděna buď s&nbsp;jedním operandem (uloženým na vrcholu zásobníku
operandů, což je místo označované zkratkou <i>TOS</i> neboli <i>Top Of
Stack</i>) nebo s&nbsp;dvojicí operandů (první je uložený v&nbsp;<i>TOS</i>,
druhý těsně pod prvním operandem). Funkce zásobníku návratových adres je zřejmá
&ndash; obsahuje adresy, na které se má řízení programu vrátit při opuštění
právě prováděné funkce. Ukažme si, jakým způsobem lze v&nbsp;programovacím
jazyku <i>DSSP</i> vytvářet nová slova. Nově definované slovo (funkce) vždy
začíná znakem <strong>:</strong> (tím se interpret jazyka přepne do režimu
překladu) a končí znakem <strong>;</strong>, který se překládá na instrukci
<i>RETURN</i>:</p>

<pre>
( toto slovo očekává na zásobníku operandů dvě hodnoty, které sečte a výsledek uloží do TOS )
<strong>: soucet + ;</strong>
&nbsp;
( slovo C má v DSSP stejný význam jako slovo DUP ve Forthu - zduplikuje hodnotu v TOS )
( nejprve se tedy nějaká hodnota X zkopíruje, takže zásobník obsahuje dvojici X X )
( posléze se oba shodné operandy vynásobí a výsledek je uložen zpět na vrchol zásobníku )
<strong>: mocnina C * ;</strong>
&nbsp;
( vynulování proměnné X )
( ve Forthu by se toto slovo zapsalo jako 0 X ! ovšem syntaxe DSSP je odlišná)
<strong>: clear_x !0 X ;</strong>
</pre>

<p>Programovací jazyky <i>DSSP</i> a <i>Forth</i> se i přes mnohé společné
prvky v&nbsp;několika oblastech odlišují. Týká se to především konstrukce
podmínek a programových smyček, ale i některých základních slov, z&nbsp;nichž
některé jsou v&nbsp;obou jazycích odlišné. Autoři jazyka <i>DSSP</i> evidentně
dávali přednost kratšímu zápisu základních slov, tj.&nbsp;slov (funkcí)
implementovaných přímo v&nbsp;jádru jazyka. Ovšem v&nbsp;případě potřeby
většinou není velkým problémem si vytvořit slova, jež mají stejný význam jako
slova základní. V&nbsp;jazyce <i>DSSP</i> je například možné vytvořit slovo
<strong>DUP</strong> s&nbsp;využitím základního slova <strong>C</strong>
(pravděpodobně se jedná o zkratku ze slova &bdquo;copy&ldquo;) následujícím
způsobem &ndash; <strong>: DUP C ;</strong>.  V&nbsp;tabulce zobrazené pod
tímto odstavcem jsou pro ilustraci vypsána některá slova, která jsou
v&nbsp;obou programovacích jazycích rozdílná:</p>

<table>
<tr><th>DSSP</th><th>Forth</th><th>Význam slova</th></tr>
<tr><td>D</td><td>DROP  </td><td>odstranění operandu z&nbsp;vrcholu zásobníku</td></tr>
<tr><td>C</td><td>DUP   </td><td>duplikace (kopie) operandu ležícího na vrcholu zásobníku</td></tr>
<tr><td>.</td><td>DUP . </td><td>tisk operandu ležícího na vrcholu zásobníku bez jeho odstranění</td></tr>
<tr><td>DD</td><td>2DROP</td><td>odstranění dvou operandů ze zásobníku</td></tr>
<tr><td>SP</td><td>SPACE</td><td>vložení ASCII znaku mezery na zásobník operandů</td></tr>
</table>

<p>Programovací jazyky <i>DSSP</i> a <i>Forth</i> se kromě odlišných jmen
některých základních slov (funkcí) navzájem liší i ve způsobu tvorby podmínek
(podmíněných příkazů) a programových smyček. Zatímco jazyk <i>Forth</i> je
v&nbsp;tomto ohledu jazykem na poněkud vyšší úrovni, protože jak základní
podmínkový příkaz (<strong>if-else-then</strong>), tak i všechny podporované
programové smyčky mohou ve svém těle obsahovat libovolné množství slov, včetně
dalších smyček či podmínek, v&nbsp;jazyku <i>DSSP</i> se jeho tvůrci tvrdošíjně
drželi svého hesla &bdquo;One word of text &ndash; One word of machine
code&ldquo;, což mj.&nbsp;znamená, že se například v&nbsp;každé větvi
podmíněného příkazu může vyskytovat pouze jedno slovo (tj.&nbsp;volání příkazů,
které toto slovo představuje).</p>

<p>To je sice z&nbsp;hlediska tvorby aplikací poněkud nepříjemná vlastnost (je
to podobné, jako by například v&nbsp;Céčku nebo Javě nebylo možné za příkazem
<strong>if</strong> vytvořit blok pomocí složených závorek <strong>{}</strong>,
ale bylo by povoleno uvést pouze jedno volání funkce či metody), ale je vhodné
si uvědomit, že vytváření i volání slov v&nbsp;<i>DSSP</i> či <i>Forthu</i> je
velmi jednoduché, dokonce s&nbsp;velikou pravděpodobností mnohem jednodušší,
než v&nbsp;jakémkoli jiném programovacím jazyce. Druhá výhoda tohoto přístupu
k&nbsp;tvorbě podmínek a programových smyček spočívá v&nbsp;tom, že se tyto
příkazy dají přímo převést na instrukce procesoru. Pokud by bylo možné
například v&nbsp;obou větvích podmíněného příkazu zapisovat libovolné množství
příkazů (tj.&nbsp;programový blok), musel by se plný podmíněný příkaz převést
na minimálně jeden podmíněný a jeden nepodmíněný skok.</p>

<p>Řídicí příkazy vypadají zajímavě, protože některé z&nbsp;nich obsahují
rozeskok na tři příkazy (nikoli jen na dva). To samozřejmě plyne z&nbsp;toho,
jakým způsobem je počítač Setuň implementován (třístavová logika):</p>

<table>
<tr><th>Podmíněný příkaz</th><th>Význam</th></tr>
<tr><td>IF+ A    </td><td>pokud je operátor ležící na TOS větší než 0, proveď slovo <strong>A</strong></td></tr>
<tr><td>IF- A    </td><td>pokud je operátor ležící na TOS menší než 0, proveď slovo <strong>A</strong></td></tr>
<tr><td>IF0 A    </td><td>pokud je operátor ležící na TOS nulový, proveď slovo <strong>A</strong></td></tr>
<tr><td>BR+ A B  </td><td>pokud hodnota na TOS je větší než 0, proveď slovo <strong>A</strong>, jinak slovo <strong>B</strong></td></tr>
<tr><td>BR- A B  </td><td>pokud hodnota na TOS je menší než 0, proveď slovo <strong>A</strong>, jinak slovo <strong>B</strong></td></tr>
<tr><td>BR0 A B  </td><td>pokud je hodnota na TOS nulová, proveď slovo <strong>A</strong>, jinak slovo <strong>B</strong></td></tr>
<tr><td>BRS A B C</td><td>TOS záporné: proveď <strong>A</strong>, TOS nulové: proveď <strong>B</strong>, jinak proveď <strong>C</strong></td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Lingua::Romana::Perligata</h2>

<p>Uživatelé Perlu se možná již setkali se zajímavým modulem nazvaným <a
href="http://www.csse.monash.edu.au/~damian/papers/HTML/Perligata.html/">Lingua::Romana::Perligata</a>.
V&nbsp;tomto modulu se původní &bdquo;šum na lince&ldquo;, kterým se mohou (ale
nemusí) zapisovat programy v&nbsp;Perlu mění na formu Latiny, přičemž nejde o
pouhou náhradu klíčových slov, ale i takových konstrukcí, jakou je vytvoření
pole, aritmetické operace apod. Například aritmetická operace součtu se
zapisuje v&nbsp;závislosti na kontextu slovy <strong>adde</strong>,
<strong>addentum</strong> či <strong>addementa</strong>, smyčka typu
<strong>for-each</strong> začíná slovem <strong>per</strong> apod. Zajímavá
jsou čísla &ndash; čísla do desíti je možné zapisovat buď slovy
(<strong>unum</strong>, <strong>duo</strong> ... <strong>decem</strong>) nebo
římskými číslicemi. U větších hodnot máme k&nbsp;dispozici jen druhý způsob.
Vyjádřit lze i zlomky, například 3.141 = MMMCXLI Mimum a 0.25 = 1/4 = unum
quartum, 3/10 = tres decimum. Asi nejzajímavější je indexování vícerozměrných
polí:</p>

<pre>
$unimatrix[1][3][9][7];
septimum noni tertii primi unimatrixorum
</pre>

<p>Není to krása?</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Rapira</h2>

<p>Zajímavým programovacím jazykem je <i>Rapira</i> (<i>Рапира</i>), který se
používal v&nbsp;Sovětském svazu při výuce programování, a to na různých typech
počítačů, včetně počítačů s&nbsp;klony čipů 8086 a Z80. <i>Rapira</i> je
odvozena od klasického strukturovaného jazyka ALGOL, s&nbsp;nímž má podobnou
strukturu zápisu programů, ovšem všechna klíčová slova se původně zapisovala
v&nbsp;azbuce a to v&nbsp;některých případech navíc ještě ve zkrácené formě.
Uveďme si typický příklad &ndash; &bdquo;Hello world&ldquo; v&nbsp;ruštině.
Povšimněte si klíčových slov <strong>ПРОЦ</strong> (procedura),
<strong>КНЦ</strong> (konec) a procedury <strong>ВЫВОД</strong> (výstup):</p>

<pre>
ПРОЦ СТАРТ()
    ВЫВОД: 'здравствуй, мир!!!'
КНЦ ПРОЦ 
</pre>

<p>Interpret rozeznával například následující klíčová slova:</p>

<pre>
ВОЗВРАТ   ИНАЧЕ     ПРОЦ
ВСЕ       КНЦ       ФУН
ДО        ОТ        ШАГ
ИНАЧЕ     ЕСЛИ      ПОВТОР    
</pre>

<p>Ukázka delšího programu (znalci azbuky pravděpodobně nebudou mít problém
s&nbsp;pochopením):</p>

<p><img src="https://i.iinfo.cz/images/609/rapira.png" class="image-249311" alt="&#160;" height="552" width="736" /></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Fjölnir</h2>

<p>V&nbsp;roce 1980 vytvořil profesor <i>Snorri Agnarsson</i> programovací
jazyk, který se měl používat při výuce na Islandské univerzitě. Tento jazyk se
strukturou podobá klasickým jazykům typu Algol či Pascal, ovšem nejzajímavější
je samozřejmě použití klíčových slov pocházejících z&nbsp;islandštiny. Kromě
krátkých a celkem bezproblémových slov typu <strong>fyrir</strong>
(<i>for</i>), <strong>ef</strong> (<i>if</i>) či <strong>þá</strong>
(<i>then</i>) v&nbsp;tomto jazyku najdeme perly typu
<strong>skrifastreng</strong> (<i>println/puts</i>), <strong>lykkjulok</strong>
(pravděpodobně <i>endfor</i>) a <strong>stofnlok</strong> (<i>endcase</i>) i
zápisy typu:</p>

<pre>
d:=st rstisameiginlegideilir(k 100,125)
</pre>

<p>popř.:</p>

<pre>
{
a.al -&gt;
  stef(;)
  sta.v.r handfang:=opnaskr.(;vi.fang(;1),'l')
  innflutt t.k
  stofn
    handfang e.a handfang:=0,
    HefjaLesgreiningu(;handfang),
    t.k:=LesaLes(;),
    forrit(;),
    handfang=0 e.a lokaskr.(;handfang),
  stofnlok
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Chinese BASIC</h2>

<p>Kromě SSSR vlastní varianty programovacích jazyků vyvíjeli i v&nbsp;Číně.
Příkladem může být <i>Chinese BASIC</i> pocházející z&nbsp;počátku osmdesátých
let minulého století, tj.&nbsp;z&nbsp;období, kdy byl nějaký dialekt BASICu
základním interpretrem pro většinu domácích mikropočítačů. Chinese BASIC
vychází z&nbsp;ve své době populárního <i>Applesoft BASICu</i>, což je pro
změnu varianta původního <i>Microsoft BASICu</i> upravená takovým způsobem, aby
ji bylo možné použít na počítačích Apple II (kromě Applesoft BASICu však
existoval i původní &bdquo;Integer BASIC&ldquo; nahraný přímo do ROM, jak to
ostatně bývalo zvykem). Chinese BASIC vlastně nahrazuje původní anglická
klíčová slova (<strong>GOTO</strong>, <strong>IF</strong>,
<strong>THEN</strong>, <strong>LET</strong>, <strong>FOR</strong>,
<strong>NEXT</strong> atd.) čínskými &bdquo;obrázkovými ekvivalenty.&ldquo;
Struktura původního BASICu však zůstala zachována, včetně operátorů, závorek,
čísel řádků apod. Proměnné a poznámky mohly být zapsány latinkou (ASCII) či
pomocí čínských znaků, viz též <a
href="https://en.wikipedia.org/wiki/Chinese_BASIC">https://en.wikipedia.org/wiki/Chinese_BASIC</a>.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Chinese BASIC<br />
<a href="https://en.wikipedia.org/wiki/Chinese_BASIC">https://en.wikipedia.org/wiki/Chinese_BASIC</a>
</li>

<li>Boolfuck<br />
<a href="http://samuelhughes.com/boof/">http://samuelhughes.com/boof/</a>
</li>

<li>Smallfuck<br />
<a href="http://esolangs.org/wiki/Smallfuck">http://esolangs.org/wiki/Smallfuck</a>
</li>

<li>BitChanger<br />
<a href="http://esolangs.org/wiki/BitChanger">http://esolangs.org/wiki/BitChanger</a>
</li>

<li>Programming Puzzles &amp; Code Golf - Interpret ///<br />
<a href="http://codegolf.stackexchange.com/questions/37014/interpret-pronounced-slashes">http://codegolf.stackexchange.com/questions/37014/interpret-pronounced-slashes</a>
</li>

<li>Reg Xy<br />
<a href="http://c2.com/cgi/wiki?RegXy">http://c2.com/cgi/wiki?RegXy</a>
</li>

<li>Queue (abstract data type)<br />
<a href="https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29">https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29</a>
</li>

<li>Register Machine<br />
<a href="https://en.wikipedia.org/wiki/Register_machine">https://en.wikipedia.org/wiki/Register_machine</a>
</li>

<li>Fueue<br />
<a href="http://esolangs.org/wiki/Fueue">http://esolangs.org/wiki/Fueue</a>
</li>

<li>///<br />
<a href="http://esolangs.org/wiki////">http://esolangs.org/wiki////</a>
</li>

<li>Esolang, the esoteric programming languages wiki<br />
<a href="https://esolangs.org/wiki/Main_Page">https://esolangs.org/wiki/Main_Page</a>
</li>

<li>Esoteric Topics in Computer Programming<br />
<a href="http://web.archive.org/web/20020609152409/www.catseye.mb.ca/esoteric/index.html">http://web.archive.org/web/20020609152409/www.catseye.mb.ca/esoteric/index.html</a>
</li>

<li>Programming Languages designed by Wouter von Oortmerssen<br />
<a href="http://strlen.com/programming-languages">http://strlen.com/programming-languages</a>
</li>

<li>Two-dimensional languages<br />
<a href="https://esolangs.org/wiki/Category:Two-dimensional_languages">https://esolangs.org/wiki/Category:Two-dimensional_languages</a>
</li>

<li>Piet (homepage)<br />
<a href="http://www.dangermouse.net/esoteric/piet.html">http://www.dangermouse.net/esoteric/piet.html</a>
</li>

<li>Piet (na Esolang)<br />
<a href="https://esolangs.org/wiki/Piet">https://esolangs.org/wiki/Piet</a>
</li>

<li>Piet IDE<br />
<a href="http://www.rapapaing.com/blog/?page_id=6">http://www.rapapaing.com/blog/?page_id=6</a>
</li>

<li>JSFuck (homepage)<br />
<a href="http://www.jsfuck.com/">http://www.jsfuck.com/</a>
</li>

<li>JSFuck (na Esolang)<br />
<a href="https://esolangs.org/wiki/JSFuck">https://esolangs.org/wiki/JSFuck</a>
</li>

<li>JSFuck (na Wikipedii)<br />
<a href="https://en.wikipedia.org/wiki/JSFuck">https://en.wikipedia.org/wiki/JSFuck</a>
</li>

<li>Malbolge (na Esolang)<br />
<a href="https://esolangs.org/wiki/Malbolge">https://esolangs.org/wiki/Malbolge</a>
</li>

<li>Malbolge (na Wikipedii)<br />
<a href="https://en.wikipedia.org/wiki/Malbolge">https://en.wikipedia.org/wiki/Malbolge</a>
</li>

<li>Befunge (na Esolang)<br />
<a href="https://esolangs.org/wiki/Befunge">https://esolangs.org/wiki/Befunge</a>
</li>

<li>Befunge (na Wikipedii)<br />
<a href="https://en.wikipedia.org/wiki/Befunge">https://en.wikipedia.org/wiki/Befunge</a>
</li>

<li>Minifuck<br />
<a href="https://esolangs.org/wiki/Minifuck">https://esolangs.org/wiki/Minifuck</a>
</li>

<li>XMLfuck<br />
<a href="https://esolangs.org/wiki/XMLfuck">https://esolangs.org/wiki/XMLfuck</a>
</li>

<li>The False Programming Language<br />
<a href="http://strlen.com/false-language">http://strlen.com/false-language</a>
</li>

<li>The FALSE Programming Language Manual<br />
<a href="http://strlen.com/false/false.txt">http://strlen.com/false/false.txt</a>
</li>

<li>Wouter van Oortmerssen<br />
<a href="http://esolangs.org/wiki/Wouter_van_Oortmerssen">http://esolangs.org/wiki/Wouter_van_Oortmerssen</a>
</li>

<li>dc (computer program)<br />
<a href="https://en.wikipedia.org/wiki/Dc_%28computer_program%29">https://en.wikipedia.org/wiki/Dc_%28computer_program%29</a>
</li>

<li>dc (na Esolang)<br />
<a href="http://esolangs.org/wiki/Dc">http://esolangs.org/wiki/Dc</a>
</li>

<li>Whitespace - tutorial<br />
<a href="http://compsoc.dur.ac.uk/whitespace/tutorial.html">http://compsoc.dur.ac.uk/whitespace/tutorial.html</a>
</li>

<li>Programovací jazyk Forth a zásobníkové procesory<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-forth-a-zasobnikove-procesory/">http://www.root.cz/clanky/programovaci-jazyk-forth-a-zasobnikove-procesory/</a>
</li>

<li>Seriál Programovací jazyk Forth<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-forth/">http://www.root.cz/serialy/programovaci-jazyk-forth/</a>
</li>

<li>Programovací jazyk Factor<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-factor/">http://www.root.cz/clanky/programovaci-jazyk-factor/</a>
</li>

<li>Grafický metaformát PostScript<br />
<a href="http://www.root.cz/clanky/graficky-metaformat-postscript/">http://www.root.cz/clanky/graficky-metaformat-postscript/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

