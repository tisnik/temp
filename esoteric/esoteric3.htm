<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyky z vývojářského pekla (ABEND)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyky z vývojářského pekla (ABEND)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve třetí části miniseriálu o esoterických programovacích jazycích si nejdříve popíšeme jazyky založené na substituci řetězců, dále pak jazyky využívající frontu (jako alternativu k&nbsp;zásobníku), jazyky, v&nbsp;nichž je celý program zapsán jediným číslem či dvojicí čísel a nezapomeneme ani na specialitku typu Brainfunct (neplést s&nbsp;Brainfuckem).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Esoterické programovací jazyky založené na substituci řetězců</a></p>
<p><a href="#k02">2. Jazyk /// &ndash; nejjednodušší jazyk na světě?</a></p>
<p><a href="#k03">3. Jazyk REGXY</a></p>
<p><a href="#k04">4. Esoterické programovací jazyky založené na použití fronty (queue)</a></p>
<p><a href="#k05">5. Sceql</a></p>
<p><a href="#k06">6. Fueue</a></p>
<p><a href="#k07">7. Esoterické programovací jazyky, v&nbsp;nichž je algoritmus zapsán číslem či dvěma čísly</a></p>
<p><a href="#k08">8. NULL</a></p>
<p><a href="#k09">9. Seed aneb devátá úroveň programátorského pekla</a></p>
<p><a href="#k10">10. Brainfunct</a></p>
<p><a href="#k11">11. Obsah poslední části článku</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Esoterické programovací jazyky založené na substituci řetězců</h2>

<p>Programovací jazyky, které jsme si prozatím popsali, byly založeny na
několika principech. První princip spočívá v&nbsp;implementaci jazyka
s&nbsp;příkazy, které se snaží napodobit Turingův stroj, a to buď zcela
přímočaře, nebo různými oklikami (namísto pásky se používá dvourozměrné pole
apod.). Pravděpodobně nejznámějším esoterickým jazykem patřícím do této
kategorie je slavný <a
href="http://www.root.cz/clanky/programovaci-jazyky-z-vyvojarskeho-pekla/#k03">Brainfuck</a>.
Další princip, který se používal v&nbsp;jazycích typu <a
href="http://www.root.cz/clanky/programovaci-jazyky-z-vyvojarskeho-pekla-2/#k04">dc</a>,
<a
href="http://www.root.cz/clanky/programovaci-jazyky-z-vyvojarskeho-pekla/#k02">FALSE</a>,
<a
href="http://www.root.cz/clanky/programovaci-jazyky-z-vyvojarskeho-pekla/#k07">Befunge</a>
či <a
href="http://www.root.cz/clanky/programovaci-jazyky-z-vyvojarskeho-pekla-2/#k07">Whitespace</a>,
je založen na použití zásobníku operandů, popř.&nbsp;dokonce většího množství
zásobníků. Existují však i další použitelné principy. Zajímavý a pro většinu
programátorů (a vlastně i běžných uživatelů) pochopitelný je princip založený
na substituci řetězců. Tuto operaci si dokáže představit prakticky každý, kdo
někdy použil textový editor či textový procesor, ovšem je skutečně možné
vytvořit programovací jazyk, kde se algoritmus zapisuje jen textovými
substitucemi? Odpověď nám částečně dají následující kapitoly.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Jazyk /// &ndash; nejjednodušší jazyk na světě?</h2>

<p>Prvním programovacím jazykem, s&nbsp;nímž se dnes setkáme, je jazyk nazvaný
/// (což se má číst &bdquo;slashes&ldquo;). Jedná se o jazyk, který byl
vytvořen Tannerem Swettem v&nbsp;roce 2006. <i>Slashes</i> je založen pouze na
textových substitucích, žádná další operace se při zpracování programů
neprovádí. Interpret je ve skutečnosti velmi jednoduchý a jeho činnost se dá
shrnout do několika pravidel:</p>

<ol>
<li>Zdrojový kód se zpracovává po znacích.</li>
<li>Pokud interpret nalezne znak \, vypíše následující znak na standardní výstup a oba dva znaky se z&nbsp;programu odstraní.</li>
<li>Pokud interpret nalezne znak /, získá vzorek (pattern) a náhradu (replacement) a provede substituci. Vzorek končí znakem / a i náhrada končí znakem /, což znamená, že celý příkaz vypadá takto: /pattern/replacement/.</li>
<li>Ostatní znaky se pouze vytisknou a odstraní ze zdrojového textu.</li>
<li>Substituce se provádí neustále dokola a pokud po jedné iteraci nedojde ke změně textu, substituce a tím pádem i celý program skončí.</li>
</ol>

<p>Zajímavé je, že tento jazyk je Turingovsky úplný.</p>

<p>Podívejme se na několik ukázek programů napsaných v&nbsp;jazyce ///:</p>

<p>Program typu &bdquo;Hello world!&ldquo;:</p>

<pre>
Hello, world!
</pre>

<p>Poznámka: povšimněte si, že zápis programu Hello world! již prakticky nemůže
být jednodušší. Proto je celkem zvláštní, že se jazyk /// nepoužívá na školách
při seznamování dětí s&nbsp;programováním :-)</p>

<p>Složitější varianta programu typu &bdquo;Hello world!&ldquo;:</p>

<pre>
/foo/Hello, world!//bar/foo/bar
</pre>

<p>Poznámka: jak tento program pracuje je asi zřejmé: řetězec &bdquo;bar&ldquo;
je nejprve nahrazen za &bdquo;foo&ldquo; a &bdquo;foo&ldquo; je nahrazen za
&bdquo;Hello, world!&ldquo;.</p>

<p>Konverze mezi binární a unární číselnou soustavou:</p>

<pre>
/1/0*//*0/0**//0//100010
</pre>

<p>Nekonečná smyčka (na dalších řádcích je ukázáno postupné aplikování
substituce):</p>

<pre>
/foo/foobar/foo
foobar
foobarbar
foobarbarbar
foobarbarbarbar
</pre>

<p>Generování Fibonacciho posloupnosti:</p>

<pre>
/
///!/\/.\\0\/,\\,0,\\,1\/\/.\\1\/,\\,0\/\/,\\,\/.\/\/+\\+\/=\\=.\\1-\/
\/=\\=\/+\\+\//!!!!!!!!!/.///+\+///-/\\\///0/1//1/*/++.1
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Jazyk REGXY</h2>

<p>Druhý dnes popisovaný esoterický programovací jazyk se jmenuje poměrně
příhodně <i>REGXY</i>. Tento jazyk je již poněkud složitější, než výše popsaný
jazyk ///, protože se zde vyskytují regulární výrazy a dokonce hned dva typy
příkazů &ndash; příkaz pro test a příkaz pro změnu textu. Příkaz provádějící
test vypadá následovně:</p>

<pre>
label/regex/target_label
</pre>

<p>Pokud vstupní řetězec odpovídá regulárnímu výrazu, je proveden skok na
zadané návěští.</p>

<p>Příkaz provádějící náhradu (substituci) vypadá prakticky stejně, ovšem na
jeho konec je přidáno lomítko:</p>

<pre>
label/regex/substitute/
</pre>

<p>V&nbsp;obou typech příkazů je možné používat prakticky všechny možnosti
rozšířených regulárních výrazů (minimálně jedna implementace je napsána
v&nbsp;Perlu, takže včetně různých rozšíření přidaných právě Perlem).
Povšimněte si, že každý příkaz začíná návěštím, což je libovolný řetězec (který
však nesmí obsahovat lomítko). Použití návěští bude dobře patrné na
příkladech:</p>

<p>Otočení řetězce:</p>

<pre>
a/$/_/
b/(.)(.*)_/$2_$1/
c/(.)(.*)_/b
d/_// 
</pre>

<p>Součet dvou binárních čísel (viz <a
href="http://zzo38computer.org/regxy/adbinery.txt">http://zzo38computer.org/regxy/adbinery.txt</a>):</p>

<pre>
0+0/(.*)0\+(.*)0\=/$1+$2=0/
0+1/(.*)0\+(.*)1\=/$1+$2=1/
1+0/(.*)1\+(.*)0\=/$1+$2=1/
1+1/(.*)1\+(.*)1\=/$1c+$2=0/
0c+0/(.*)0c\+(.*)0\=/$1+$2=1/
0c+1/(.*)0c\+(.*)1\=/$1c+$2=0/
1c+0/(.*)1c\+(.*)0\=/$1c+$2=0/
1c+1/(.*)1c\+(.*)1\=/$1c+$2=1/
caryblank/c\+\=/+=1/
check/.\+/check2
goto1/./fix
check2/\+[^=]/0+0
fix/(.*)\+(.*)\=/$1$2/
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Esoterické programovací jazyky založené na použití fronty (queue)</h2>

<p>Při zmínce o těch programovacích jazycích, které pro řízení běhu programu,
volání funkcí a předávání parametrů i pro vyhodnocování všech výrazů používají
zásobník (a nemusí se jednat pouze o esoterické jazyky), si možná některý
čtenář položil otázku, zda by nebylo možné namísto zásobníku, tj.&nbsp;datové
struktury typu <i>LIFO</i> (<i>Last In, First Out</i>) použít frontu, neboli
datovou strukturu typu <i>FIFO</i> (<i>First In, First Out</i>). Fronty sice
nejsou pro tento účel příliš praktické, neboť u nich nelze (alespoň ne snadno)
provádět lokální výpočty, o to &bdquo;výhodnější&ldquo; však může tato
vlastnost být při návrhu esoterického jazyka, kde mnohdy platí, že čím
složitější tvorba algoritmů, tím lépe :-) Takže vlastně není divu, že vzniklo
již několik (málo) desítek jazyků, v&nbsp;nichž se používají právě fronty.</p>

<p>Připomeňme si jen, že u čistě navržené datové struktury fronta
(<i>queue</i>) se prvky přidávají na její začátek a vybírají se z&nbsp;konce
fronty, tedy skutečně podle zkratky <i>FIFO</i>. Pokud by se prvky mohly
přidávat i číst z&nbsp;obou stran, jednalo by se o oboustrannou (obousměrnou?)
frontu, pro niž se vžila zkratka <i>deque</i> (a jak asi očekáváte &ndash;
existují esoterické jazyky založené i na této mnohem &bdquo;mocnější&ldquo;
datové struktuře, tyto jazyky však nejsou tématem dnešního článku).</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Sceql</h2>

<p>Jazyk nazvaný <i>Sceql</i>, jehož autorem je Scott Feeney, se v&nbsp;určitém
ohledu podobá nám již dobře známému jazyku <i>Brainfuck</i>, minimálně proto,
že základní operace se omezují na zvýšení či snížení hodnoty. Zatímco se však
v&nbsp;jazyku <i>Brainfuck</i> všechny zpracovávané hodnoty ukládaly do pole
představujícího (poněkud omezenou) implementaci pásky Turingova stroje, používá
se v&nbsp;případě jazyka <i>Sceql</i> fronta. Zajímavé je, že tato fronta se
nikdy nezmenšuje, protože všechny operace buď zachovávají počet prvků uložených
do fronty (změní se však jejich pořadí) nebo dokonce dokážou do fronty jeden
prvek přidat. Na začátku je fronta inicializována, protože obsahuje jediný
prvek s&nbsp;hodnotou 0. Podívejme se na dostupné příkazy. Není jich moc a
skutečně v&nbsp;nich můžeme vidět podobnost s&nbsp;<i>Brainfuckem</i>:</p>

<table>
<tr><th>#</th><th>Příkaz</th><th>Význam znaku/příkazu</th></tr>
<tr><td>1</td><td>=</td><td>prvek z&nbsp;konce fronty se odstraní a přidá znovu na její začátek</td></tr>
<tr><td>2</td><td>-</td><td>snížení hodnoty prvku na konci fronty o jedničku</td></tr>
<tr><td>3</td><td>_</td><td>zvýšení hodnoty prvku na konci fronty o jedničku</td></tr>
<tr><td>4</td><td>\</td><td>přeskočí na odpovídající párovou instrukci / pokud je prvek na konci fronty nulový</td></tr>
<tr><td>5</td><td>/</td><td>skočí (bez testu) na odpovídající párový znak \</td></tr>
<tr><td>6</td><td>!</td><td>do fronty se přidá nový prvek s&nbsp;hodnotou nula</td></tr>
<tr><td>7</td><td>&amp;</td><td>přečtení ze standardního vstupu a uložení hodnoty do fronty (na začátek)</td></tr>
<tr><td>8</td><td>*</td><td>odpovídá příkazu =, ovšem současně se vytiskne znak odpovídající ASCII kódu prvku</td></tr>
</table>

<p>Poznámka: povšimněte si, že pokud by se druhý příkaz - (minus) nahradil
například znakem @, mohly by se v&nbsp;jediném zdrojovém kódu zkombinovat hned
tři různé programy psané v&nbsp;<i>Brainfucku</i>, <i>Whitespace</i> a
<i>Sceql</i>.</p>

<p>Demonstračním příkladem samozřejmě musí být program typu &bdquo;Hello
world&ldquo;. Na tomto příkladu je patrná určitá ukecanost jazyka
<i>Sceql</i>:</p>

<pre>
________________________________________________________________________*
_____________________________*
_______*
*
___*
!=____________________________________________*
=------------*
________*
=--------*
=___*
=------*
=--------*
_*
!==__________*
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Fueue</h2>

<p>Druhým programovacím jazykem, v&nbsp;němž se používá fronta (<i>queue</i>)
je jazyk nazvaný <i>Fueue</i>. Autorem tohoto programovacího jazyka je Nathan
von Doorn. Zajímavé je, že ve <i>Fueue</i> se fronta používá jak pro uložení
zdrojového kódu programu, tak i pro reprezentaci jeho stavu. Při spuštění
interpretru tohoto jazyka je ve frontě uložen celý program (sekvence symbolů
představujících příkazy) a fronta se postupně plní i hodnotami představujícími
stav programu. Interpretace vypadá následovně:</p>

<ol>
<li>Z&nbsp;fronty se přečte jeden prvek.</li>
<li>Pokud se jedná o číslo, je převedeno na znak (ASCII hodnota) a tento znak je vytištěn.</li>
<li>Pokud se jedná o příkaz/funkci (viz tabulku níže), je funkce zavolána (argumenty jsou samozřejmě ve frontě).</li>
<li>Další symboly jsou vráceny zpět do fronty na začátek.</li>
<li>Pokud se fronta po celé rotaci (předchozí bod) nezmění, načte se znak ze standardního vstupu a jeho kód se uloží na začátek fronty.</li>
</ol>

<p>Následuje tabulka s&nbsp;podporovanými funkcemi (příkazy):</p>

<table>
<tr><th> #</th><th>Příkaz</th><th>Význam znaku/příkazu</th></tr>
<tr><td> 1</td><td>+</td><td>součet dvou čísel přečtených z&nbsp;fronty</td></tr>
<tr><td> 2</td><td>-</td><td>změna znaménka čísla přečteného z&nbsp;fronty</td></tr>
<tr><td> 3</td><td>*</td><td>součin dvou čísel přečtených z&nbsp;fronty</td></tr>
<tr><td> 4</td><td>/</td><td>celočíselný podíl dvou čísel přečtených z&nbsp;fronty</td></tr>
<tr><td> 5</td><td>%</td><td>logická negace (0 na 1, ostatní hodnoty na 0)</td></tr>
<tr><td> 6</td><td>:</td><td>duplikace prvku (přidá se na začátek fronty!)</td></tr>
<tr><td> 7</td><td>~</td><td>prohození dvou prvků (opět se přidají na začátek)</td></tr>
<tr><td> 8</td><td>!</td><td>odstranění prvku</td></tr>
<tr><td> 9</td><td>$</td><td>prvek se zduplikuje n-krát</td></tr>
<tr><td>10</td><td>(</td><td>změna hodnoty na tzv.&nbsp;blok (vlastně seznam chápaný jako prvek)</td></tr>
<tr><td>11</td><td>&lt;</td><td>přidání další hodnoty do bloku</td></tr>
<tr><td>12</td><td>)</td><td>z&nbsp;bloku se stane seznam hodnot</td></tr>
<tr><td>13</td><td>H</td><td>okamžité ukončení programu</td></tr>
</table>

<p>Demonstračním příkladem samozřejmě musí být opět program typu &bdquo;Hello
world&ldquo;. Ten je primitivní:</p>

<pre>
72 101 108 108 111 44 32 119 111 114 108 100 33 10 H
</pre>

<p>Nekonečnou smyčku lze zapsat například takto:</p>

<pre>
):[):]
</pre>

<p>Pro čtenáře se skutečně silnými nervy si ukažme interpretr
<i>Brainfucku</i>:</p>

<pre>
):[)~$)[[)[~~~~()+1])][0]$%~~1)][[)~&lt;[)$%+-~)~~~43[)[~:~~~)&lt;[)~~[)$--1[)~]&lt;~~&lt;)&lt;[)$$7--1]][~~~)%[~~)~:(+-
)(~)+-1*256]+-~)255:]~]]!]~][)~&lt;[)$%+-~)~~~45[)[~:~~~)&lt;[)~~[)$--1[)~]&lt;~~&lt;)&lt;[)$$6-%0]][~~~)*[)~(:+~~-)+1]-
--256%):]~]]!]~][)~&lt;[)$%+-~)~~~62[)[~:~~~)&lt;[)~~[)$--1[)~]&lt;~~&lt;)&lt;[)$--%0]][))(($3~)&lt;(]~]]!]~][)~&lt;[)$%+-~)~~
~60[)[~:~~~)&lt;[)~~[)$--1[)~]&lt;~~&lt;)&lt;[)$--%0]][~~)&lt;~~~(]~]]!]~][)~&lt;[)$%+-~)~~~91[)[)~~[)~&lt;[&lt;&lt;&lt;~(~~~&lt;)~][)[))$
12~[:]&lt;&lt;$4~~~&lt;[)$--1[$8~)$4&lt;[)$$6-%0[)]]&lt;]~)~:~]~[!~)~~[)[)$--1[)~~~[)$4~[~):~~[~:~)~[)$$6-%0~~[$~])~]&lt;~]
&lt;~&lt;]$3~[)$~~~%~~)]&lt;~(~~&lt;]~~&lt;&lt;~[0]]&lt;&lt;&lt;:]]]&lt;&lt;[1)]])(~~)~]~~]&lt;~[[~)~~!]):]]!]~][)~&lt;[)$%+-~)~~~93[)[[85 110
109 97 116 99 104 101 100 32 93 46H][)~[))$11~&lt;&lt;~:(~:&lt;]]~)~~~]!]~][)~&lt;[)$%+-~)~~~46[)[~:~~~)&lt;[)~~[)$--1[)
~]&lt;~~&lt;)&lt;[)$%0]][):]~]]!]~][)~&lt;[)$%+-~)~~~44[)[~:~~~)&lt;[~~~~&lt;)[)))~$([[)[~~~~()+1])][0]$%~~1)][)[)[~[0]~])]
[~!]]]~]]!]~][)~&lt;[)$%+-~)~~~33[)[[)~[)[H]]~!][85 110 109 97 116 99 104 101 100 32 91 46H]~)~~~]!]~][)~&lt;[)
$%+-~)~~~0[)[[)~[)[H]]~!][85 110 109 97 116 99 104 101 100 32 91 46H]~)~~~]!]~][)[~:)~]!]:]:]:]:]:]:]:]:]
:]:][0]~]][[0]:[[0]&lt;:[[0]&lt;:]][73 110 116 101 114 110 97 108 32 101 114 114 111 114 58 32 116 111 112 108
101 118 101 108 32 114 117 110 116 105 109 101 32 93 46H])~!][~)]
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Esoterické programovací jazyky, v&nbsp;nichž je algoritmus zapsán číslem či dvěma čísly</h2>

<p>Zajímavou a přitom poměrně malou skupinu esoterických jazyků tvoří takové
jazyky v&nbsp;nichž je algoritmus zapsán jediným číslem popř.&nbsp;dvojicí
celých čísel. Záleží pouze na tvůrci jazyka, jakým způsobem zajistí jedinečnost
mapování celé_číslo:zápis_algoritmu. Samozřejmě je prakticky vždy možné použít
defenzivní přístup, v&nbsp;němž se všechny znaky, z&nbsp;nichž se zdrojový kód
skládá, prohlásí za (například) dvě číslice v&nbsp;hexadecimálním kódu, to je
však málo &bdquo;esoterické&ldquo; resp.&nbsp;málo &bdquo;šílené&ldquo;. Proto
se můžeme setkat s&nbsp;odlišnými přístupy, v&nbsp;nichž dokonce nechybí ani
použití generátoru pseudonáhodných čísel (<i>PRNG</i>), přičemž celý zápis
programu je redukován na zadání hodnoty <i>seed</i> (semínko generátoru) a
počtu instrukcí (otázkou samozřejmě zůstává, jestli použitý generátor
pseudonáhodných čísel dokáže vygenerovat všechny smysluplné posloupnosti a jak
se vůbec hodnota <i>seed</i> nalezne).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. NULL</h2>

<p><i>NULL</i> je programovací jazyk, v&nbsp;němž se jednotlivé instrukce
(příkazy) reprezentují prvočísly. To by ještě nebylo nijak hrozné (ostatně
stejně lze jakýkoli bajtkód transformovat na prvočísla), ovšem zajímavé je, že
stav programu je v&nbsp;interpretru reprezentován dvěma celočíselnými
proměnnými <i>x</i> a <i>y</i>. Proměnná <i>x</i> na začátku obsahuje již
zmíněný zápis programu (nějaké číslo), proměnná <i>y</i> je nastavena na
jedničku. Prozatím se neděje nic šíleného že? Ovšem pokračujme: interpretace
probíhá tak, že se pro <i>x</i> zjistí jeho nejmenší prvočíselný faktor
(nejmenší prvočíselný dělitel) a následují operace:</p>

<ol>
<li>Proměnná <i>x</i> je vydělena zjištěným prvočíslem.</li>
<li>Proměnná <i>y</i> je stejným prvočíslem naopak vynásobena.</li>
<li>Provede se operace odpovídající zjištěnému prvočíslu.</li>
<li>Vše se opakuje od začátku.</li>
</ol>

<p>Následuje tabulka s&nbsp;dostupnými operacemi (povšimněte si, že se skutečně
jedná o prvočísla):</p>

<table>
<tr><th>Kód</th><th>Význam</th></tr>
<tr><td> 2</td><td>výběr další fronty (operandy jsou uloženy ve třech frontách; proč? proto)</td></tr>
<tr><td> 3</td><td>výběr předchozí fronty</td></tr>
<tr><td> 5</td><td>prvek z&nbsp;vybrané fronty je převeden na znak (ASCII) a ten je následně vypsán</td></tr>
<tr><td> 7</td><td>opak předchozího &ndash; vstup od uživatele a zápis kódu znaku do vybrané fronty</td></tr>
<tr><td>11</td><td>snížení hodnoty prvku na konci vybrané fronty o jedničku. Nikdy nedojde k&nbsp;podtečení pod hodnotu 0.</td></tr>
<tr><td>13</td><td>prvek z&nbsp;vybrané fronty je přičten k&nbsp;proměnné <i>y</i></td></tr>
<tr><td>17</td><td>zvýšení hodnoty prvku o hodnotu <i>y</i> modulo 256</td></tr>
<tr><td>19</td><td>odstranění prvku z&nbsp;vybrané fronty a jeho přidání na začátek konec další fronty</td></tr>
<tr><td>23</td><td>odstranění prvku z&nbsp;vybrané fronty a jeho přidání na začátek konec předchozí fronty</td></tr>
<tr><td>29</td><td>pouhé odstranění prvku z&nbsp;vybrané fronty</td></tr>
<tr><td>31</td><td>vložení hodnoty <i>y</i> modulo 256 do vybrané fronty</td></tr>
<tr><td>37</td><td>podmínka: pokud je fronta prázdná nebo má její prvek nulovou hodnotu, poděl <i>x</i> jeho nejmenším prvočíselným faktorem a vynásob <i>y</i> stejnou hodnotou</td></tr>
<tr><td>41</td><td>prohození hodnot v&nbsp;proměnných <i>x</i> a <i>y</i></td></tr>
<tr><td>43</td><td>ukončení běhu programu</td></tr>
</table>

<p>Program typu Hello world vypadá takto:</p>

<pre>
153609393637869503971282839335995386248921743204830348570033
550157913898858976126298703504031567456769368158187308369080
75646108694411913908753341542249057283074613678144889367
</pre>

<p>Otázkou zůstává, komu a jakým způsobem se podařilo tento program napsat
:-)</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Seed aneb devátá úroveň programátorského pekla</h2>

<p>Pravděpodobně nejšílenějším jazykem, o němž se dnes zmíníme, je jazyk
nazvaný <i>Seed</i>. Programy zapsané v&nbsp;tomto jazyku jsou tvořeny pouze
dvěma celočíselnými hodnotami. První hodnotou je &bdquo;semínko&ldquo; určené
pro inicializaci generátoru pseudonáhodných čísel. Druhou hodnotou je délka
programu. Interpretace je vlastně na první pohled triviální &ndash; nejprve je
provedena inicializace generátoru pseudonáhodných čísel (používá se <a
href="https://en.wikipedia.org/wiki/Mersenne_Twister">tento generátor</a>
s&nbsp;periodou 2<sup>19937</sup> - 1) a posléze se nechá vygenerovat <i>n</i>
bajtů (pouze ASCII hodnoty 32 až 126 + konec řádku), které jsou převedeny na
řetězec (<i>n</i> je ono druhé číslo na vstupu). Takto vytvořený řetězec je
následně předán interpretru jazyka <a
href="http://www.root.cz/clanky/programovaci-jazyky-z-vyvojarskeho-pekla/#k07">Befunge</a>.
Nic nemůže být jednoduššího že? Jediným maličkým problémem zůstává, jak napsat
nějaký smysluplný program... Ovšem kdy se tvůrce programovacího jazyka zabýval
takovými prkotinami...</p>

<p>Ve skutečnosti se programy píšou takto:</p>

<ol>

<li>Nějakým generátorem se zjistí, které instrukce v&nbsp;jazyku Befunge
odpovídají řešenému problému.</li>

<li>Následně se metodou hrubé síly pro původní Befunge program zjistí ony dvě
celočíselné hodnoty. Složitost je &bdquo;pouze&ldquo; O(96<sup>n</sup>), kde
<i>n</i> je počet znaků programu v&nbsp;Befunge (96 proto, že se prochází
všechny kombinace vygenerovaných ASCII znaků s&nbsp;hodnotami 32 až 126 + konec
řádku).</li>

</ol>

<p>Příklad &bdquo;programu&ldquo;:</p>

<pre>
780 983247832
</pre>

<p>Vygenerováním získáme program v&nbsp;jazyce Befunge:</p>

<pre>
q
Z?T7yQ
;RyHIw*#{8).'}iN*P{u&gt;z#ok&lt;w\\?!KPrVO7U;b&gt; B
f:rDj':T3'O~J(&gt;BLLxj(&gt;{5n) oM/?nwC{c(OT&gt;Fv?=)tW*`6oL8yCI:D_%4d}:ubmL"6v'(o4^5zi{E3F+vDHk"*}a&amp;nu=S*syIgT&gt;MQ9_vyi'b&amp;i^_xT"WP-"lk=#/r)8%:rG,I?'DTz&lt;)|J]0|^LDakzrx]Gjy=^.0$R&lt;y9#Sl,_K5y@\~z+jSlARiA6D#:gVlmb^&gt;[MQea
(etc)
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Brainfunct</h2>

<p>Dalším zajímavým esoterickým programovacím jazykem, s&nbsp;nímž se dnes ve
stručnosti seznámíme, je jazyk nazvaný <i>Brainfunct</i>. Podobnost názvu
tohoto jazyka se slavným (a v&nbsp;některých ohledech doposud nepřekonaným)
<i>Brainfuckem</i> samozřejmě není náhodná, protože jazyk <i>Brainfunct</i>
z&nbsp;originálního <i>Brainfucku</i> převzal šest z&nbsp;osmi původních
instrukcí a namísto toho přidal jedinou novou instrukci. Pro porovnání možností
obou jazyků si nejdříve v&nbsp;rychlosti zopakujme, kterých osm instrukcí
nalezneme v&nbsp;jazyku <i>Brianfuck</i>:</p>

<table>
<tr><th>#</th><th>Příkaz</th><th>Význam znaku/příkazu</th></tr>
<tr><td>1</td><td>&gt;</td><td>posun ukazatele na &bdquo;pásce&ldquo; doprava na další políčko</td></tr>
<tr><td>2</td><td>&lt;</td><td>posun ukazatele na &bdquo;pásce&ldquo; doleva na předchozí políčko</td></tr>
<tr><td>3</td><td>+   </td><td>zvýšení celočíselné hodnoty uložené v&nbsp;aktuálním políčku o 1</td></tr>
<tr><td>4</td><td>-   </td><td>snížení celočíselné hodnoty uložené v&nbsp;aktuálním políčku o 1</td></tr>
<tr><td>5</td><td>.   </td><td>výpis číselné hodnoty (převedené na ASCII znak) uložené v&nbsp;aktuálním políčku</td></tr>
<tr><td>6</td><td>,   </td><td>načtení bajtu (znaku) a uložení jeho číselné hodnoty do aktuálního políčka (opět se většinou předpokládá použití ASCII)</td></tr>
<tr><td>7</td><td>[   </td><td>v&nbsp;případě, že je hodnota v&nbsp;aktuálním políčku nulová, přesune se program za odpovídající ]</td></tr>
<tr><td>8</td><td>]   </td><td>v&nbsp;případě, že je hodnota v&nbsp;aktuálním políčku nenulová, přesune se program na odpovídající [</td></tr>
</table>

<p>V&nbsp;jazyku <i>Brainfunct</i> došlo k&nbsp;podstatné změně &ndash; namísto
posledních dvou instrukcí, které vlastně zajišťují možnost řízení běhu
programu, tj.&nbsp;tvorbu podmínek (rozvětvení) a programových smyček, byla
přidána instrukce <strong>@</strong> sloužící pro zavolání určité funkce.
Funkce v&nbsp;jazyku <i>Brainfunct</i> však nejsou pojmenované, ovšem současně
nejsou ani čistě anonymní, protože každé funkci je přiřazeno celé číslo. Při
volání funkce příkazem <strong>@</strong> se tedy musí přečíst hodnota
z&nbsp;aktuálního políčka na pásce (v&nbsp;poli) a provede se zavolání
instrukce, které toto číslo odpovídá. Nová struktura příkazů tedy vypadá
následovně:</p>

<table>
<tr><th>#</th><th>Příkaz</th><th>Význam znaku/příkazu</th></tr>
<tr><td>1</td><td>&gt;</td><td>posun ukazatele na &bdquo;pásce&ldquo; doprava na další políčko</td></tr>
<tr><td>2</td><td>&lt;</td><td>posun ukazatele na &bdquo;pásce&ldquo; doleva na předchozí políčko</td></tr>
<tr><td>3</td><td>+   </td><td>zvýšení celočíselné hodnoty uložené v&nbsp;aktuálním políčku o 1</td></tr>
<tr><td>4</td><td>-   </td><td>snížení celočíselné hodnoty uložené v&nbsp;aktuálním políčku o 1</td></tr>
<tr><td>5</td><td>.   </td><td>výpis číselné hodnoty (převedené na ASCII znak) uložené v&nbsp;aktuálním políčku</td></tr>
<tr><td>6</td><td>,   </td><td>načtení bajtu (znaku) a uložení jeho číselné hodnoty do aktuálního políčka (opět se většinou předpokládá použití ASCII)</td></tr>
<tr><td>7</td><td>@   </td><td>zavolání funkce, jejíž číslo se nachází na aktuálním políčku</td></tr>
</table>

<p>Jakým způsobem se však mohou v&nbsp;jazyce <i>Brainfunct</i> zapisovat
funkce? Existují dva způsoby a tím pádem je vlastně možné říci, že existují i
dvě varianty tohoto programovacího jazyka. První způsob spočívá v&nbsp;tom, že
deklarace funkcí jsou ve zdrojovém kódu (tedy ve shluku znaků &lt;, &gt;, +, -,
., , a @) odděleny znakem lomítka /. Při čtení zdrojového kódu je první funkci
(před prvním lomítkem) přiřazeno číslo 1, druhé funkci číslo 2 atd. Poslední
funkce, která se ve zdrojovém kódu nalezne, se automaticky spustí při startu
programu, tj.&nbsp;jedná se vlastně o funkci &bdquo;main&ldquo;:</p>

<pre>
funkce_číslo_1/funkce_číslo_2/funkce_číslo_3/.../main
</pre>

<p>Poznámka: těla funkcí jsou samozřejmě tvořena výše zmíněnými sedmi příkazy a
volání funkcí je ve skutečnosti skok &ndash; žádné parametry se nepředávají a
ani se neočekává návrat z&nbsp;volané funkce (tudíž ani žádná návratová
hodnota). Ve skutečnosti se tedy funkce spíše podobají pouhým návěštím
(<i>labels</i>).</p>

<p>Jak vypadá program psaný tímto způsobem? Podívejme se na implementaci
utility <strong>cat</strong> sloužící pro opisování standardního vstupu na
standardní výstup:</p>

<pre>
&gt;,.&lt;@/+@
</pre>

<p>Druhý způsob zápisu programů je nepatrně složitější, ale pro psaní
složitějších algoritmů pravděpodobně lepší. Při použití tohoto způsobu se těla
funkcí uzavírají do kulatých závorek (trošku podobně jako v&nbsp;LISPu) a
zajímavé je především to, že se funkce při čtení zdrojového kódu číslují podle
své úrovně rekurzivního vnoření. To mj.&nbsp;znamená, že existují funkce, jimž
je přiřazeno stejné číslo; to však ve skutečnosti nevadí, protože je vždy
zavolána ta funkce, která se nachází ve stejné části &bdquo;stromu&ldquo;.
Číslování může vypadat takto:</p>

<pre>
(1) (2) (((5)4)3) (4) (((8)6)(7)5) main
</pre>

<p>Povšimněte si toho, že funkce na nejvyšší úrovni jsou postupně očíslovány 1,
2, 3, 4 a 5 a navíc žádná funkce, která se nachází ve stejném podstromu, nemá
nižší číslo, než funkce nadřazená.</p>

<p>Poznámka: technicky vzato to znamená, že v&nbsp;programovacím jazyku
<i>Brainfunct</i> se používá osm či dokonce devět znaků, protože znaky /
popř.&nbsp;dvojice ( a ) je nutné využít pro zápis jednotlivých funkcí. Ovšem
příkazů je skutečně pouze sedm.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Obsah poslední části článku</h2>

<p>Čtvrtý a současně i poslední díl tohoto miniseriálku bude rozdělen na tři
části. V&nbsp;části první si popíšeme některé esoterické funkcionální jazyky
(resp.&nbsp;jazyky založené na Lambda kalkulu), z&nbsp;nichž nejdůležitějším a
nejznámějším je bezesporu jazyk nazvaný příznačně <i>Unlambda</i>. Druhá část
bude věnována jazykům simulujícím práci Turingova stroje, ovšem s&nbsp;tím
omezením, že se používají pouze binární symboly zapisované na pásku Turingova
stroje. Tím pádem se omezuje i množství možných operací prováděných se symboly,
většinou je k&nbsp;dispozici jen test na nulu a operace pro inverzi bitu. Mezi
takové jazyky patří <i>Boolfuck</i>, <i>Smallfuck</i> a <i>BitChanger</i>. Ve
třetí části článku se seznámíme s&nbsp;některými koncepty virtuálních strojů
s&nbsp;mnohdy velmi minimalisticky pojatými instrukčními sadami. Takové
virtuální stroje se samozřejmě programují v&nbsp;assembleru (nebo v&nbsp;jazyce
velmi blízkém assembleru), ovšem vzhledem k&nbsp;použití minimálního počtu
instrukcí se může programování stát poměrně složitou (ale tím pádem vlastně i
zábavnou) záležitostí.</p>

<p>Mimochodem: víte, že i v&nbsp;balíčku s&nbsp;<i>Vimem</i> se nachází
interpret esoterického jazyka? Jedná se o <i>URM</i> neboli <i>Universal
Register Machine</i>, což je struktura duální k&nbsp;Turingovu stroji. Více viz
(alespoň prozatím):</p>

<pre>
:e $VIMRUNTIME/macros/urm/examples
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Programming Puzzles &amp; Code Golf - Interpret ///<br />
<a href="http://codegolf.stackexchange.com/questions/37014/interpret-pronounced-slashes">http://codegolf.stackexchange.com/questions/37014/interpret-pronounced-slashes</a>
</li>

<li>Reg Xy<br />
<a href="http://c2.com/cgi/wiki?RegXy">http://c2.com/cgi/wiki?RegXy</a>
</li>

<li>Queue (abstract data type)<br />
<a href="https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29">https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29</a>
</li>

<li>Register Machine<br />
<a href="https://en.wikipedia.org/wiki/Register_machine">https://en.wikipedia.org/wiki/Register_machine</a>
</li>

<li>Fueue<br />
<a href="http://esolangs.org/wiki/Fueue">http://esolangs.org/wiki/Fueue</a>
</li>

<li>///<br />
<a href="http://esolangs.org/wiki////">http://esolangs.org/wiki////</a>
</li>

<li>Esolang, the esoteric programming languages wiki<br />
<a href="https://esolangs.org/wiki/Main_Page">https://esolangs.org/wiki/Main_Page</a>
</li>

<li>Esoteric Topics in Computer Programming<br />
<a href="http://web.archive.org/web/20020609152409/www.catseye.mb.ca/esoteric/index.html">http://web.archive.org/web/20020609152409/www.catseye.mb.ca/esoteric/index.html</a>
</li>

<li>Programming Languages designed by Wouter von Oortmerssen<br />
<a href="http://strlen.com/programming-languages">http://strlen.com/programming-languages</a>
</li>

<li>Two-dimensional languages<br />
<a href="https://esolangs.org/wiki/Category:Two-dimensional_languages">https://esolangs.org/wiki/Category:Two-dimensional_languages</a>
</li>

<li>Piet (homepage)<br />
<a href="http://www.dangermouse.net/esoteric/piet.html">http://www.dangermouse.net/esoteric/piet.html</a>
</li>

<li>Piet (na Esolang)<br />
<a href="https://esolangs.org/wiki/Piet">https://esolangs.org/wiki/Piet</a>
</li>

<li>Piet IDE<br />
<a href="http://www.rapapaing.com/blog/?page_id=6">http://www.rapapaing.com/blog/?page_id=6</a>
</li>

<li>JSFuck (homepage)<br />
<a href="http://www.jsfuck.com/">http://www.jsfuck.com/</a>
</li>

<li>JSFuck (na Esolang)<br />
<a href="https://esolangs.org/wiki/JSFuck">https://esolangs.org/wiki/JSFuck</a>
</li>

<li>JSFuck (na Wikipedii)<br />
<a href="https://en.wikipedia.org/wiki/JSFuck">https://en.wikipedia.org/wiki/JSFuck</a>
</li>

<li>Malbolge (na Esolang)<br />
<a href="https://esolangs.org/wiki/Malbolge">https://esolangs.org/wiki/Malbolge</a>
</li>

<li>Malbolge (na Wikipedii)<br />
<a href="https://en.wikipedia.org/wiki/Malbolge">https://en.wikipedia.org/wiki/Malbolge</a>
</li>

<li>Befunge (na Esolang)<br />
<a href="https://esolangs.org/wiki/Befunge">https://esolangs.org/wiki/Befunge</a>
</li>

<li>Befunge (na Wikipedii)<br />
<a href="https://en.wikipedia.org/wiki/Befunge">https://en.wikipedia.org/wiki/Befunge</a>
</li>

<li>Minifuck<br />
<a href="https://esolangs.org/wiki/Minifuck">https://esolangs.org/wiki/Minifuck</a>
</li>

<li>XMLfuck<br />
<a href="https://esolangs.org/wiki/XMLfuck">https://esolangs.org/wiki/XMLfuck</a>
</li>

<li>The False Programming Language<br />
<a href="http://strlen.com/false-language">http://strlen.com/false-language</a>
</li>

<li>The FALSE Programming Language Manual<br />
<a href="http://strlen.com/false/false.txt">http://strlen.com/false/false.txt</a>
</li>

<li>Wouter van Oortmerssen<br />
<a href="http://esolangs.org/wiki/Wouter_van_Oortmerssen">http://esolangs.org/wiki/Wouter_van_Oortmerssen</a>
</li>

<li>dc (computer program)<br />
<a href="https://en.wikipedia.org/wiki/Dc_%28computer_program%29">https://en.wikipedia.org/wiki/Dc_%28computer_program%29</a>
</li>

<li>dc (na Esolang)<br />
<a href="http://esolangs.org/wiki/Dc">http://esolangs.org/wiki/Dc</a>
</li>

<li>Whitespace - tutorial<br />
<a href="http://compsoc.dur.ac.uk/whitespace/tutorial.html">http://compsoc.dur.ac.uk/whitespace/tutorial.html</a>
</li>

<li>Programovací jazyk Forth a zásobníkové procesory<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-forth-a-zasobnikove-procesory/">http://www.root.cz/clanky/programovaci-jazyk-forth-a-zasobnikove-procesory/</a>
</li>

<li>Seriál Programovací jazyk Forth<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-forth/">http://www.root.cz/serialy/programovaci-jazyk-forth/</a>
</li>

<li>Programovací jazyk Factor<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-factor/">http://www.root.cz/clanky/programovaci-jazyk-factor/</a>
</li>

<li>Grafický metaformát PostScript<br />
<a href="http://www.root.cz/clanky/graficky-metaformat-postscript/">http://www.root.cz/clanky/graficky-metaformat-postscript/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

