<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Multimediální knihovna Pyglet: použití mipmappingu při texturování</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Multimediální knihovna Pyglet: použití mipmappingu při texturování</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dnešní díl seriálu o multimediální knihovně Pyglet je věnovaný technice mipmappingu, která je často používaná pro zamezení vzniku vizuálních chyb vznikajících v&nbsp;dynamicky se měnících scénách a animacích popř.&nbsp;při použití textur se složitějším vzorkem.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Multimediální knihovna Pyglet: použití mipmappingu při texturování</a></p>
<p><a href="#k02">2. Texturování bez použití mipmappingu</a></p>
<p><a href="#k03">3. Podvzorkování textury a vznik moaré</a></p>
<p><a href="#k04">4. Vytvoření rastrového obrázku s&nbsp;texturou šachovnice</a></p>
<p><a href="#k05">5. První demonstrační příklad &ndash; zobrazení šachovnice v&nbsp;3D scéně bez použití mipmappingu</a></p>
<p><a href="#k06">6. Použití mipmappingu</a></p>
<p><a href="#k07">7. Podpora mipmappingu v&nbsp;grafické knihovně OpenGL</a></p>
<p><a href="#k08">8. Automatické generování mipmap v&nbsp;nadstavbové knihovně GLU</a></p>
<p><a href="#k09">9. Automatické vygenerování mipmapy v&nbsp;knihovně Pyglet</a></p>
<p><a href="#k10">10. Nastavení filtrů při použití mipmappingu</a></p>
<p><a href="#k11">11. Druhý demonstrační příklad &ndash; použití mipmappingu v&nbsp;praxi</a></p>
<p><a href="#k12">12. Ukázka různých nastavení mipmappingu</a></p>
<p><a href="#k13">13. Úplný zdrojový kód druhého demonstračního příkladu</a></p>
<p><a href="#k14">14. Funkce knihovny OpenGL a pomocné knihovny GLU, které byly použity ve zdrojových kódech</a></p>
<p><a href="#k15">15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Multimediální knihovna Pyglet: použití mipmappingu při texturování</h2>

<p>Mipmapping představuje v&nbsp;oblasti 3D grafiky poměrně dobře známou techniku, která je v&nbsp;praxi poměrně často používaná pro odstranění či alespoň pro zmenšení některých vizuálních chyb (resp.&nbsp;přesněji řečeno nežádoucích rozdílů mezi jednotlivými snímky) vzniklých při pohybu těles s&nbsp;nanesenou texturou v&nbsp;trojrozměrné scéně nebo při pohybu celé scény (tj.&nbsp;při změně orientace nebo pozice pozorovatele/kamery). Obraz těles s&nbsp;nanesenou texturou se na obrazovce při pohybu zmenšuje, zvětšuje či jinak deformuje, čímž pochopitelně také dochází k&nbsp;nutnosti zvětšování a zmenšování textury při nanášení texelů (rastrových elementů textury) na zobrazované pixely.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Texturování bez použití mipmappingu</h2>

<p>Nejprve se podívejme na nám již známé techniky řešení tohoto problému. Již <a href="https://mojefedora.cz/multimedialni-knihovna-pyglet-konfigurace-texturovaci-jednotky-pri-nanaseni-textur-na-steny-teles/">minule</a> jsme si řekli, že při zvětšování a zmenšování textury můžeme pro zamezení některých vizuálních chyb využít filtraci. Nejrychlejšího zobrazení scény však dosáhneme vypnutím filtrace a výběrem vždy pouze jednoho nejbližšího texelu z&nbsp;textury pro každý vykreslovaný pixel:</p>

<pre>
glTexParameteri(GL_TEXTURE_2D,
                GL_TEXTURE_MAG_FILTER,
                GL_NEAREST)

glTexParameteri(GL_TEXTURE_2D,
                GL_TEXTURE_MIN_FILTER,
                GL_NEAREST)
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/05/09-3.png"><img class="alignnone size-thumbnail wp-image-8982" src="https://mojefedora.cz/wp-content/uploads/2017/05/09-3-243x254.png" alt="" width="243" height="254" /></a>
<p><i>Obrázek 1: Přiblížení textury při použití filtrů GL_NEAREST, tj.&nbsp;barva pixelů se vypočte z&nbsp;nejbližšího texelu.</i></p>

<p>Předchozí způsob je sice nejrychlejší, současně však nikterak neřeší vznik artefaktů, například takzvaného <i>moaré</i>, způsobeného podvzorkováním obrazu. V&nbsp;knihovně OpenGL a tím pádem i v&nbsp;Pygletu lze využít několika způsobů, které zamezují vznikům těchto artefaktů při zvětšování a zejména zmenšování textur. Pokud se vykresluje statická scéna, je možné použít pouze vhodné filtrace, pracující na principu výběru několika sousedních texelů a jejich bilineární interpolace při výpočtu barvy vykreslovaného pixelu:</p>

<pre>
glTexParameteri(GL_TEXTURE_2D,
                GL_TEXTURE_MAG_FILTER,
                GL_LINEAR)

glTexParameteri(GL_TEXTURE_2D,
                GL_TEXTURE_MIN_FILTER,
                GL_LINEAR);
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/05/10-3.png"><img class="alignnone size-thumbnail wp-image-8983" src="https://mojefedora.cz/wp-content/uploads/2017/05/10-3-243x254.png" alt="" width="243" height="254" /></a>
<p><i>Obrázek 2: Přiblížení textury při použití filtrů GL_LINEAR, tj.&nbsp;použitím bilineární interpolace.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Podvzorkování textury a vznik moaré</h2>

<p>Nevýhodou předchozího způsobu je určité zpomalení vykreslování, zejména díky faktu, že se musí provádět více přístupů do texturovací paměti, která v&nbsp;dnešní době stále představuje úzké hrdlo grafických akcelerátorů. V&nbsp;některých případech, zejména při požadavku na vyšší kvalitu obrázků, je možné použít antialiasing, který se v&nbsp;OpenGL provádí tak, že se scéna vykreslí ve vyšším rozlišení, než je rozlišení obrazovky, a poté se provede snížení rozlišení pomocí filtrace s&nbsp;vhodným jádrem filtru (<i>kernelem</i>). Rozdíl mezi scénou vykreslenou bez antialiasingu a s&nbsp;antialiasingem je patrný z&nbsp;dalších dvou screenshotů. Moderní grafické akcelerátory většinou umožňují provádět antialiasing celé scény. Tato technika je nazývaná <i>FSAA</i> neboli <i>Full Scene AntiAliasing</i>. Nevýhodou je samozřejmě nižší rychlost vykreslování.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/03-1.png"><img src="https://mojefedora.cz/wp-content/uploads/2017/06/03-1-254x254.png" alt="" width="254" height="254" class="alignnone size-thumbnail wp-image-9067" /></a>
<p><i>Obrázek 3: Trojrozměrná scéna vykreslená bez povoleného antialiasingu.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/04-1.png"><img src="https://mojefedora.cz/wp-content/uploads/2017/06/04-1-254x254.png" alt="" width="254" height="254" class="alignnone size-thumbnail wp-image-9068" /></a>
<p><i>Obrázek 4: Stejná scéna jako na předchozím obrázku vykreslená se zapnutým antialiasingem.</i></p>

<p>Poznámka: antialiasing implementovaný s&nbsp;použitím takzvaného supersamplingu, se velmi často používá u raytracerů.</p>

<p>Při animacích však kromě moaré vznikají i další artefakty, z&nbsp;nichž nejviditelnější je &bdquo;problikávání&ldquo; pixelů na příliš zmenšených texturách, tj.&nbsp;například texturách nanesených na vzdálených objektech. V&nbsp;těchto případech už běžná filtrace (pracující pouze pro těsné okolí nanášených texelů) není příliš prospěšná, protože s&nbsp;každým pohybem otexturovaného tělesa se může v&nbsp;rovině textury provést posun až o několik desítek texelů, čímž dochází k&nbsp;prudké změně vykreslované barvy.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vytvoření rastrového obrázku s&nbsp;texturou šachovnice</h2>

<p>V&nbsp;dnešních dvou demonstračních příkladech budeme používat texturu šachovnice. Abyste si mohli sami vyzkoušet, jak se bude zobrazení takové textury lišit pro různé velikosti políček na šachovnici, bude textura vytvořená následujícím jednoduchým skriptem. Povšimněte si, že rozměry šachovnice jsou 256&times;256 pixelů, což odpovídá &ndash; jak uvidíme dále &ndash; požadavkům na rozměry textury, z&nbsp;nichž se bude vytvářet mipmapa:</p>

<pre>
#!/usr/bin/env python

# Vytvoreni textury sachovnice

from PIL import Image

IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256

SQUARE_SIZE = 16

BLACK = (0, 0, 0)
WHITE = (255, 255, 255)

image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT))

for y in range(0, IMAGE_HEIGHT):
    for x in range(0, IMAGE_WIDTH):
        color = BLACK
        xs = x / SQUARE_SIZE
        ys = y / SQUARE_SIZE
        if (xs + ys) % 2 == 0:
            color = WHITE

        image.putpixel((x, y), color)

image.save("checker.png")
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/05-1.png"><img src="https://mojefedora.cz/wp-content/uploads/2017/06/05-1-254x254.png" alt="" width="254" height="254" class="alignnone size-thumbnail wp-image-9069" /></a>
<p><i>Obrázek 5: Textura vytvořená výše popsaným skriptem.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. První demonstrační příklad &ndash; zobrazení šachovnice v&nbsp;3D scéně bez použití mipmappingu</h2>

<p>Použití textury šachovnice vytvořené <a href="#k04">předchozím skriptem</a> je vlastně velmi snadné, protože jen postačuje nepatrně upravit příklady, s&nbsp;nimiž jsme se již seznámili v&nbsp;předchozích částech tohoto seriálu. V&nbsp;3D scéně bude zobrazeno jen jediné těleso &ndash; čtvercová plocha pokrytá šachovnicovou texturou:</p>

<pre>
def draw_floor():
    glBegin(GL_QUADS)                         # vykresleni podlahy
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-50.0, -5.0, -50.0)
    glTexCoord2f(5.0, 0.0)
    glVertex3f(-50.0, -5.0,  50.0)
    glTexCoord2f(5.0, 5.0)
    glVertex3f(50.0, -5.0,  50.0)
    glTexCoord2f(0.0, 5.0)
    glVertex3f(50.0, -5.0, -50.0)
    glEnd()
</pre>

<p>Při zobrazení bude možné si zvolit filtry použité při přiblížení či naopak vzdálení textury. Řízení texturovací jednotky provádí tento kód:</p>

<pre>
def set_filters(minFilterEnabled, magFilterEnabled):
    minFilter = GL_LINEAR if minFilterEnabled else GL_NEAREST
    magFilter = GL_LINEAR if magFilterEnabled else GL_NEAREST
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter)
</pre>

<p>Nastavení filtrů pak přibližně následující úryvek kódu, který umožňuje, aby se klávesami <strong>I</strong> a <strong>A</strong> filtry zapnuly či vypnuly (každý zvlášť):</p>

<pre>
minFilterEnabled = True                    # filtry pouzite pri texturovani
magFilterEnabled = True

if keys[key.I]:
    minFilterEnabled = not minFilterEnabled
if keys[key.A]:
    magFilterEnabled = not magFilterEnabled
</pre>

<p>Úplný zdrojový kód dnešního prvního demonstračního příkladu vypadá následovně:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

fov = 70.0                                 # hodnota zorneho uhlu - field of view
nearPlane = 0.1                            # blizsi orezavaci rovina
farPlane = 90.0                            # vzdalenejsi orezavaci rovina

r1 = 0.0
r2 = 0.0

depthBufferEnabled = False                 # povoleni ci zakaz Z-bufferu
texturesEnabled = True                     # povoleni ci zakaz textur

minFilterEnabled = True                    # filtry pouzite pri texturovani
magFilterEnabled = True


def create_window():
    return pyglet.window.Window(width=500,
                                height=500,
                                caption="Pyglet library")


window = create_window()


def load_texture(filename):
    image_stream = open(filename, 'rb')
    image = pyglet.image.load(filename, file=image_stream)
    return image.get_texture()


def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)       # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)       # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                # zadne hrany ani steny se nebudou odstranovat
    glDepthFunc(GL_LESS)                   # funkce pro testovani fragmentu

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
    glBindTexture(GL_TEXTURE_2D, texture.id)

    glEnable(GL_TEXTURE_2D)                # povoleni texturovani


@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno


def draw_floor():
    glBegin(GL_QUADS)                         # vykresleni podlahy
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-50.0, -5.0, -50.0)
    glTexCoord2f(5.0, 0.0)
    glVertex3f(-50.0, -5.0,  50.0)
    glTexCoord2f(5.0, 5.0)
    glVertex3f(50.0, -5.0,  50.0)
    glTexCoord2f(0.0, 5.0)
    glVertex3f(50.0, -5.0, -50.0)
    glEnd()


def set_depth_buffer(depthBufferEnabled):
    if depthBufferEnabled:
        glEnable(GL_DEPTH_TEST)
    else:
        glDisable(GL_DEPTH_TEST)


def clear_buffers(depthBufferEnabled):
    if depthBufferEnabled:   # vymazani i Z/W bufferu
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    else:                    # vymazani vsech bitovych rovin barvoveho bufferu
        glClear(GL_COLOR_BUFFER_BIT)


def set_filters(minFilterEnabled, magFilterEnabled):
    minFilter = GL_LINEAR if minFilterEnabled else GL_NEAREST
    magFilter = GL_LINEAR if magFilterEnabled else GL_NEAREST
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter)


def set_textures(texturesEnabled):
    if texturesEnabled:
        glEnable(GL_TEXTURE_2D)
    else:
        glDisable(GL_TEXTURE_2D)


@window.event
def on_draw():
    global depthBufferEnabled
    global texturesEnabled
    global minFilterEnabled
    global magFilterEnabled

    if keys[key.Z]:
        depthBufferEnabled = not depthBufferEnabled
    if keys[key.T]:
        texturesEnabled = not texturesEnabled
    if keys[key.I]:
        minFilterEnabled = not minFilterEnabled
    if keys[key.A]:
        magFilterEnabled = not magFilterEnabled

    clear_buffers(depthBufferEnabled)
    set_depth_buffer(depthBufferEnabled)
    set_filters(minFilterEnabled, magFilterEnabled)
    set_textures(texturesEnabled)

    # zacatek kodu modifikujiciho projekcni matici
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()                       # vymazani projekcni matice
    gluPerspective(fov, 1.0, nearPlane, farPlane)

    # zacatek kodu modifikujiciho modelview matici
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                       # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,              # bod, odkud se kamera diva
              0.0, 2.0,  0.0,              # bod, kam se kamera diva
              0.0, 1.0,  0.0)              # poloha "stropu" ve scene

    glRotatef(r1, 1.0, 0.0, 0.0)           # rotace objektu
    glRotatef(r2, 0.0, 1.0, 0.0)
    glTranslatef(0, 0, -40)                # posun objektu

    draw_floor()                           # vykresleni objektu - podlahy


texture = load_texture('checker.png')
keys = key.KeyStateHandler()
window.push_handlers(keys)

pyglet.app.run()
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/06-1.png"><img src="https://mojefedora.cz/wp-content/uploads/2017/06/06-1-243x254.png" alt="" width="243" height="254" class="alignnone size-thumbnail wp-image-9070" /></a>
<p><i>Obrázek 6: Screenshot prvního příkladu: při přiblížení textury se barva pixelu odvozuje z&nbsp;nejbližšího texelu.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/07.png"><img src="https://mojefedora.cz/wp-content/uploads/2017/06/07-243x254.png" alt="" width="243" height="254" class="alignnone size-thumbnail wp-image-9071" /></a>
<p><i>Obrázek 7: Screenshot prvního příkladu: při přiblížení textury je použita bilineární interpolace.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Použití mipmappingu</h2>

<p>Pro zamezení problikávání se používají textury uložené ve více rozlišeních (tj.&nbsp;úrovních detailu). Při vykreslování otexturovaného povrchu se nejdříve zjistí relativní velikost povrchu vůči celé textuře a poté se vybere vhodné rozlišení textury, která se posléze na vykreslovanou stěnu nanese. Tento postup má nevýhodu v&nbsp;tom, že při postupném zmenšování objektu by docházelo ke skokové změně textury (přešlo by se k&nbsp;menšímu rozlišení textury). Proto se zavádí další úroveň interpolace, kdy se vybere nejbližší větší a nejbližší menší textura a barva pixelů se vypočte interpolací mezi těmito dvěma texturami.</p>

<p>Nyní tedy zbývá pouze volba vhodného rozlišení textur. Z&nbsp;hlediska implementace interpolátoru na grafickém akcelerátoru je nejvýhodnější, aby se rozlišení textury v&nbsp;horizontálním i vertikálním směru snižovalo vždy na polovinu. Počet texelů je v&nbsp;každé následující textuře zmenšen na čtvrtinu až do dosažení textury o velikosti 1&times;1 pixel. Princip tvorby <i>mipmapy</i> je ukázán na dalším obrázku:</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/08.png"><img src="https://mojefedora.cz/wp-content/uploads/2017/06/08.png" alt="" width="450" height="250" class="alignnone size-thumbnail wp-image-9072" /></a>
<p><i>Obrázek 8: Princip tvorby mipmapy.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/09.png"><img src="https://mojefedora.cz/wp-content/uploads/2017/06/09-145x254.png" alt="" width="145" height="254" class="alignnone size-thumbnail wp-image-9073" /></a>
<p><i>Obrázek 9: Ukázka textur vhodných pro tvorbu mipmapy</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Podpora mipmappingu v&nbsp;grafické knihovně OpenGL</h2>

<p>V&nbsp;grafické knihovně OpenGL jsou mipmapy samozřejmě také podporovány, protože se jedná o velmi často používanou renderovací (vykreslovací) pomůcku. Pro každé nastavované rozlišení textury je zapotřebí zavolat již dříve popsanou funkci, jejíž céčková hlavička vypadá následovně:</p>

<pre>
void glTexImage2D(
    GLenum  target,
    GLint   level,
    GLint   components,
    GLsizei width,
    GLsizei height,
    GLint   border,
    GLenum  format,
    GLenum  type,
    const GLvoid *pixels
); 
</pre>

<p>kde se do parametru nazvaného <strong>level</strong> zadává úroveň textury v&nbsp;hierarchii. Nulou specifikujeme texturu se základním (tj.&nbsp;nejvyšším) rozlišením, jedničkou texturu s&nbsp;rozlišením polovičním atd. V&nbsp;texturovací paměti grafického akcelerátoru se vytvoří takzvaná <i>mipmapa</i>, tj.&nbsp;textura, ve které jsou uloženy všechny velikosti textur rozdělených na jednotlivé barevné složky RGB. Ukázka mipmapy je zobrazena na následujícím obrázku. Z&nbsp;tohoto obrázku je patrné, že se jedná o hierarchickou strukturu, ve které se dají jednoduše adresovat korespondující pixely v&nbsp;různých rozlišeních. Při adresaci přitom vystačíme pouze s&nbsp;aditivními operacemi a bitovými posuny, což jsou pro grafický akcelerátor ideální operace.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/10.png"><img src="https://mojefedora.cz/wp-content/uploads/2017/06/10-254x254.png" alt="" width="254" height="254" class="alignnone size-thumbnail wp-image-9074" /></a>
<p><i>Obrázek 10: Ukázka interní reprezentace mipmapy uložené v texturovací paměti grafického akcelerátoru</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Automatické generování mipmap v&nbsp;nadstavbové knihovně GLU</h2>

<p>Textury s&nbsp;více úrovněmi detailu můžeme buď vytvořit programově s&nbsp;použitím různých filtrů, nebo je možné použít funkce pro automatické generování mipmap. Tyto funkce jsou obsaženy v&nbsp;nadstavbové knihovně GLU a mají tvar:</p>

<pre>
int gluBuild1DMipmaps(
    GLenum         target,
    GLint          components,
    GLint          width,
    GLenum         format,
    GLenum         type,
    const GLvoid * data
);

int gluBuild2DMipmaps(
    GLenum         target,
    GLint          components,
    GLint          width,
    GLint          height,
    GLenum         format,
    GLenum         type,
    const GLvoid * data
);
</pre>

<p>Parametry těchto funkcí a jejich význam odpovídá parametrům funkcí <strong>glTexImage1D()</strong> a <strong>glTexImage2D()</strong>.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Automatické vygenerování mipmapy v&nbsp;knihovně Pyglet</h2>

<p>V&nbsp;knihovně Pyglet máme situaci značně usnadněnou, protože ve chvíli, kdy je k&nbsp;dispozici obrázek o rozlišení, které je mocninou čísla 2, je možné z&nbsp;takového obrázku přímo získat <i>mipmapu</i>. O všechny přepočty se postará knihovna Pyglet automaticky. Podívejme se nyní, jak se mipmapa vytvoří v&nbsp;praxi. V&nbsp;předchozím příkladu jsme používali uživatelskou funkci nazvanou <strong>load_texture()</strong>, která načetla rastrový obrázek a vytvořila z&nbsp;něho běžnou texturu:</p>

<pre>
def load_texture(filename):
    image_stream = open(filename, 'rb')
    image = pyglet.image.load(filename, file=image_stream)
    return image.get_texture()
</pre>

<p>Pokud namísto volání metody <strong>get_texture()</strong> použijeme metodu <strong>get_mipmapped_texture()</strong>, získáme skutečně mipmapu, ovšem jen ve chvíli, kdy jsou rozměry textury rovny 2<sup>n</sup>&times;2<sup>n</sup> pro nějakou celočíselnou konstantu <i>n</i>:</p>

<pre>
def load_texture(filename):
    image_stream = open(filename, 'rb')
    image = pyglet.image.load(filename, file=image_stream)
    return image.get_mipmapped_texture()
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Nastavení filtrů při použití mipmappingu</h2>

<p>Při použití mipmappingu je také možné specifikovat další typy filtrů použitých při zmenšování textur. Kromě výběru nejbližšího souseda (<strong>GL_NEAREST</strong>) a interpolace nejbližších sousedů (<strong>GL_LINEAR</strong>) jsou nově k&nbsp;dispozici i interpolace prováděné mezi dvěma texturami (vybírá se nejbližší menší a nejbližší větší textura):</p>

<ul>

<li>Při nastaveném filtru <strong>GL_NEAREST_MIPMAP_NEAREST</strong> je pro obarvení pixelu vybrán nejbližší texel z&nbsp;nejbližší větší nebo menší textury. Tento filtr poskytuje vizuálně nejhorší výsledky, vykreslování je však nejrychlejší.</li>

<li><strong>GL_NEAREST_MIP­MAP_LINEAR</strong> &ndash; vybere dva nejbližší texely z&nbsp;obou textur a provede mezi nimi lineární interpolaci. Tímto filtrem se dají jednoduše odstranit nepříjemné skokové změny v&nbsp;obraze, které nastávají v&nbsp;případě, že se zobrazované těleso příliš zvětší nebo zmenší a provede se tak výběr jiné dvojice textur z&nbsp;mipmapy.</li>

<li><strong>GL_LINEAR_MIPMAP_NEAREST</strong> &ndash; provádí bilineární interpolaci nejbližších texelů v&nbsp;jedné textuře. Při zmenšování nebo zvětšování tělesa mohou nastat skokové změny ve vykreslované textuře.</li>

<li><strong>GL_LINEAR_MIPMAP_LINEAR</strong> &ndash; nejprve se použije interpolace pro výpočet barev texelů v&nbsp;obou texturách a poté se výsledná barva spočte další interpolací mezi dvěma předešlými (ve skutečnosti se tedy provádí takzvaná <i>trilineární interpolace</i>). Tento filtr je sice nejpomalejší, ale na druhou stranu poskytuje nejlepší vizuální výsledky.</li>

</ul>



<p><a name="k11"></a></p>
<h2 id="k11">11. Druhý demonstrační příklad &ndash; použití mipmappingu v&nbsp;praxi</h2>

<p>V&nbsp;dnešním druhém demonstračním příkladu bude mipmapping použit a navíc bude i konfigurovatelný. Způsob zobrazení je řízen třemi globálními proměnnými:</p>

<pre>
minFilterEnabled = True                    # filtry pouzite pri texturovani
magFilterEnabled = True
minFilterMode = GL_NEAREST_MIPMAP_NEAREST  # rezim mipmap
</pre>

<p>Obsah těchto proměnných je možné modifikovat stiskem kláves <strong>I</strong> a <strong>A</strong> (povolení filtrů při texturování) a taktéž klávesami <strong>1</strong> až <strong>4</strong> (čtyři možnosti popsané <a href="#k10">v&nbsp;desáté kapitole</a>):</p>

<pre>
if keys[key.I]:
    minFilterEnabled = not minFilterEnabled
if keys[key.A]:
    magFilterEnabled = not magFilterEnabled
if keys[key._1]:
    minFilterMode = GL_NEAREST_MIPMAP_NEAREST
if keys[key._2]:
    minFilterMode = GL_NEAREST_MIPMAP_LINEAR
if keys[key._3]:
    minFilterMode = GL_LINEAR_MIPMAP_NEAREST
if keys[key._4]:
    minFilterMode = GL_LINEAR_MIPMAP_LINEAR
</pre>

<p>Samotná změna způsobu texturování je implementována ve funkci nazvané <strong>set_filters()</strong>:</p>

<pre>
def set_filters(minFilterEnabled, magFilterEnabled, minFilterMode):
    minFilter = GL_LINEAR if minFilterEnabled else GL_NEAREST
    magFilter = GL_LINEAR if magFilterEnabled else GL_NEAREST
    if minFilterEnabled:
        minFilter = minFilterMode
    else:
        minFilter = GL_NEAREST
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter)
</pre>

<p>Zbylé části zdrojového kódu se vlastně neliší od příkladu prvního.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Ukázka různých nastavení mipmappingu</h2>

<p>Díky tomu, že při běhu příkladu můžeme volit parametry mipmappingu, bylo získání následujících screenshotů velmi snadné:</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/11.png"><img src="https://mojefedora.cz/wp-content/uploads/2017/06/11-243x254.png" alt="" width="243" height="254" class="alignnone size-thumbnail wp-image-9075" /></a>
<p><i>Obrázek 11: Mipmapping je zakázán, v&nbsp;zadní části obrázku můžeme vidět moaré.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/12.png"><img src="https://mojefedora.cz/wp-content/uploads/2017/06/12-243x254.png" alt="" width="243" height="254" class="alignnone size-thumbnail wp-image-9076" /></a>
<p><i>Obrázek 12: Mipmapping je povolen a nastaven na <strong>GL_NEAREST_MIPMAP_NEAREST</strong>, povšimněte si chyby v&nbsp;zadní části šachovnice.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/13.png"><img src="https://mojefedora.cz/wp-content/uploads/2017/06/13-243x254.png" alt="" width="243" height="254" class="alignnone size-thumbnail wp-image-9077" /></a>
<p><i>Obrázek 13: Mipmapping je povolen a nastaven na <strong>GL_NEAREST_MIPMAP_LINEAR</strong>.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/14.png"><img src="https://mojefedora.cz/wp-content/uploads/2017/06/14-243x254.png" alt="" width="243" height="254" class="alignnone size-thumbnail wp-image-9078" /></a>
<p><i>Obrázek 14: Mipmapping je povolen a nastaven na <strong>GL_LINEAR_MIPMAP_NEAREST</strong>.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/15.png"><img src="https://mojefedora.cz/wp-content/uploads/2017/06/15-243x254.png" alt="" width="243" height="254" class="alignnone size-thumbnail wp-image-9079" /></a>
<p><i>Obrázek 15: Mipmapping je povolen a nastaven na <strong>GL_LINEAR_MIPMAP_LINEAR</strong> (nejkvalitnější výsledek).</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Úplný zdrojový kód druhého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního druhého demonstračního příkladu vypadá takto:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

fov = 70.0                                 # hodnota zorneho uhlu - field of view
nearPlane = 0.1                            # blizsi orezavaci rovina
farPlane = 90.0                            # vzdalenejsi orezavaci rovina

r1 = 0.0
r2 = 0.0

depthBufferEnabled = False                 # povoleni ci zakaz Z-bufferu
texturesEnabled = True                     # povoleni ci zakaz textur

minFilterEnabled = True                    # filtry pouzite pri texturovani
magFilterEnabled = True
minFilterMode = GL_NEAREST_MIPMAP_NEAREST  # rezim mipmap


def create_window():
    return pyglet.window.Window(width=500,
                                height=500,
                                caption="Pyglet library")


window = create_window()


def load_texture(filename):
    image_stream = open(filename, 'rb')
    image = pyglet.image.load(filename, file=image_stream)
    return image.get_mipmapped_texture()


def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)       # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)       # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                # zadne hrany ani steny se nebudou odstranovat
    glDepthFunc(GL_LESS)                   # funkce pro testovani fragmentu

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
    glBindTexture(GL_TEXTURE_2D, texture.id)

    glEnable(GL_TEXTURE_2D)                # povoleni texturovani


@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno


def draw_floor():
    glBegin(GL_QUADS)                         # vykresleni podlahy
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-50.0, -5.0, -50.0)
    glTexCoord2f(5.0, 0.0)
    glVertex3f(-50.0, -5.0,  50.0)
    glTexCoord2f(5.0, 5.0)
    glVertex3f(50.0, -5.0,  50.0)
    glTexCoord2f(0.0, 5.0)
    glVertex3f(50.0, -5.0, -50.0)
    glEnd()


def set_depth_buffer(depthBufferEnabled):
    if depthBufferEnabled:
        glEnable(GL_DEPTH_TEST)
    else:
        glDisable(GL_DEPTH_TEST)


def clear_buffers(depthBufferEnabled):
    if depthBufferEnabled:   # vymazani i Z/W bufferu
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    else:                    # vymazani vsech bitovych rovin barvoveho bufferu
        glClear(GL_COLOR_BUFFER_BIT)


def set_filters(minFilterEnabled, magFilterEnabled, minFilterMode):
    minFilter = GL_LINEAR if minFilterEnabled else GL_NEAREST
    magFilter = GL_LINEAR if magFilterEnabled else GL_NEAREST
    if minFilterEnabled:
        minFilter = minFilterMode
    else:
        minFilter = GL_NEAREST
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter)


def set_textures(texturesEnabled):
    if texturesEnabled:
        glEnable(GL_TEXTURE_2D)
    else:
        glDisable(GL_TEXTURE_2D)


@window.event
def on_draw():
    global depthBufferEnabled
    global texturesEnabled
    global minFilterEnabled
    global magFilterEnabled
    global minFilterMode

    if keys[key.Z]:
        depthBufferEnabled = not depthBufferEnabled
    if keys[key.T]:
        texturesEnabled = not texturesEnabled
    if keys[key.I]:
        minFilterEnabled = not minFilterEnabled
    if keys[key.A]:
        magFilterEnabled = not magFilterEnabled
    if keys[key._1]:
        minFilterMode = GL_NEAREST_MIPMAP_NEAREST
    if keys[key._2]:
        minFilterMode = GL_NEAREST_MIPMAP_LINEAR
    if keys[key._3]:
        minFilterMode = GL_LINEAR_MIPMAP_NEAREST
    if keys[key._4]:
        minFilterMode = GL_LINEAR_MIPMAP_LINEAR

    clear_buffers(depthBufferEnabled)
    set_depth_buffer(depthBufferEnabled)
    set_filters(minFilterEnabled, magFilterEnabled, minFilterMode)
    set_textures(texturesEnabled)

    # zacatek kodu modifikujiciho projekcni matici
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()                       # vymazani projekcni matice
    gluPerspective(fov, 1.0, nearPlane, farPlane)

    # zacatek kodu modifikujiciho modelview matici
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                       # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,              # bod, odkud se kamera diva
              0.0, 2.0,  0.0,              # bod, kam se kamera diva
              0.0, 1.0,  0.0)              # poloha "stropu" ve scene

    glRotatef(r1, 1.0, 0.0, 0.0)           # rotace objektu
    glRotatef(r2, 0.0, 1.0, 0.0)
    glTranslatef(0, 0, -40)                # posun objektu

    draw_floor()                           # vykresleni objektu - podlahy


texture = load_texture('checker.png')
keys = key.KeyStateHandler()
window.push_handlers(keys)

pyglet.app.run()
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Funkce knihovny OpenGL a pomocné knihovny GLU, které byly použity ve zdrojových kódech</h2>

<p>V&nbsp;demonstračních příkladech, které byly uvedeny v&nbsp;dnešním článku, byly použity následující funkce převzaté z&nbsp;knihoven OpenGL a GLU:</p>

<ol>

<li>glLoadIdentity<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadIdentity.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadIdentity.xml</a>
</li>

<li>glRotate<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRotate.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRotate.xml</a>
</li>

<li>glMatrixMode<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMatrixMode.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMatrixMode.xml</a>
</li>

<li>glViewport<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glViewport.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glViewport.xml</a>
</li>

<li>glColor3f<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml</a>
</li>

<li>glClearColor<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClearColor.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClearColor.xml</a>
</li>

<li>glClear<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClear.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClear.xml</a>
</li>

<li>glTexEnvi<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml</a>
</li>

<li>glTexEnvf<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml</a>
</li>

<li>glTexEnviv<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml</a>
</li>

<li>glTexEnvfv<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml</a>
</li>

<li>glBegin<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBegin.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBegin.xml</a>
</li>

<li>glEnd<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBegin.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBegin.xml</a>
</li>

<li>glBindTexture<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBindTexture.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBindTexture.xml</a>
</li>

<li>glTexParameteri<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexParameter.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexParameter.xml</a>
</li>

<li>glEnable<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnable.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnable.xml</a>
</li>

<li>glDisable<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnable.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnable.xml</a>
</li>

<li>glDepthFunc<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glDepthFunc.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glDepthFunc.xml</a>
</li>

<li>glVertex3f<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml</a>
</li>

<li>glTexCoord2f<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml</a>
</li>

<li>gluLookAt<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml</a>
</li>

<li>gluPerspective<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml</a>
</li>

</ol>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popsané demonstrační příklady byly uloženy do Git repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>. Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti klonovat celý repositář. Pro jejich spuštění je nutné mít nainstalovanou jak knihovnu Pyglet, tak i podpůrné grafické knihovny OpenGL a GLU (což se většinou provede automaticky v&nbsp;rámci instalace balíčku s&nbsp;Pygletem, viz též <a href="https://mojefedora.cz/multimedialni-knihovna-pyglet/">úvodní díl tohoto seriálu</a>):</p>

<table>
<tr><th>Příklad</th><th>Odkaz</th></tr>
<tr><td>46_make_checker.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/46_make_checker.py">https://github.com/tisnik/presentations/blob/master/pyglet/46_make_checker.py</a></td></tr>
<tr><td>47_checker.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/47_checker.py">https://github.com/tisnik/presentations/blob/master/pyglet/47_checker.py</a></td></tr>
<tr><td>48_checker_mipmap.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/48_checker_mipmap.py">https://github.com/tisnik/presentations/blob/master/pyglet/48_checker_mipmap.py</a></td></tr>
</table>

<p>Poznámka: nejprve si spusťte první skript, který vytvoří texturu použitou v&nbsp;obou dalších příkladech.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Mipmap<br />
<a href="https://en.wikipedia.org/wiki/Mipmap">https://en.wikipedia.org/wiki/Mipmap</a>
</li>

<li>Bilinear filtering<br />
<a href="https://en.wikipedia.org/wiki/Bilinear_filtering">https://en.wikipedia.org/wiki/Bilinear_filtering</a>
</li>

<li>Trilinear filtering<br />
<a href="https://en.wikipedia.org/wiki/Trilinear_filtering">https://en.wikipedia.org/wiki/Trilinear_filtering</a>
</li>

<li>glTexEnv - příkaz OpenGL<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml</a>
</li>

<li>glGetTexEnv - příkaz OpenGL<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml</a>
</li>

<li>Pyglet Home Page<br />
<a href="https://bitbucket.org/pyglet/pyglet/wiki/Home">https://bitbucket.org/pyglet/pyglet/wiki/Home</a>
</li>

<li>Dokumentace k verzi 1.2<br />
<a href="https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/">https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/</a>
</li>

<li>Dokumentace k verzi 1.2 ve formátu PDF<br />
<a href="https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/">https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/</a>
</li>

<li>PyOpenGL<br />
<a href="http://pyopengl.sourceforge.net/">http://pyopengl.sourceforge.net/</a>
</li>

<li>The #! magic, details about the shebang/hash-bang mechanism on various Unix flavours<br />
<a href="https://www.in-ulm.de/~mascheck/various/shebang/">https://www.in-ulm.de/~mascheck/various/shebang/</a>
</li>

<li>Shebang (Unix)<br />
<a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29">https://en.wikipedia.org/wiki/Shebang_%28Unix%29</a>
</li>

<li>Domovská stránka systému LÖVE<br />
<a href="http://love2d.org/">http://love2d.org/</a>
</li>

<li>Simple DirectMedia Layer (home page)<br />
<a href="http://www.libsdl.org/">http://www.libsdl.org/</a>
</li>

<li>Simple DirectMedia Layer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer">https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer</a>
</li>

<li>Seriál Grafická knihovna OpenGL<br />
<a href="https://www.root.cz/serialy/graficka-knihovna-opengl/">https://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Pyglet event loop<br />
<a href="http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html">http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html</a>
</li>

<li>Decorators I: Introduction to Python Decorators<br />
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a>
</li>

<li>3D Programming in Python - Part 1 <br />
<a href="https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/">https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/</a>
</li>

<li>A very basic Pyglet tutorial<br />
<a href="http://www.natan.termitnjak.net/tutorials/pyglet_basic.html">http://www.natan.termitnjak.net/tutorials/pyglet_basic.html</a>
</li>

<li>Alpha blending<br />
<a href="https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending">https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

