<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití Pythonu pro tvorbu testů: od jednotkových testů až po testy UI</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití Pythonu pro tvorbu testů: od jednotkových testů až po testy UI</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Již mnohokrát jsme se na stránkách Roota setkali s tematikou testů a testování aplikací na různých úrovních. Tato problematika je tak důležitá a užitečná, že si zaslouží vlastní seriál. V něm budou praktické příklady naprogramovány v Pythonu, ovšem uvedené postupy jsou univerzální.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití Pythonu pro tvorbu testů: od jednotkových testů až po testy UI</a></p>
<p><a href="#k02">2. Různé podoby testovací pyramidy</a></p>
<p><a href="#k03">3. Zmrzlinový kornout</a></p>
<p><a href="#k04">4. Jednotkové testy &ndash; základ pyramidy, špička kornoutu</a></p>
<p><a href="#k05">5. Testy komponent a integrační testy</a></p>
<p><a href="#k06">*** 6. Systémové testy, akceptační testy</a></p>
<p><a href="#k07">*** 7. Testy aplikačního (programového) rozhraní</a></p>
<p><a href="#k08">*** 8. Testy grafického uživatelského rozhraní</a></p>
<p><a href="#k09">9. Testy chování (BDD)</a></p>
<p><a href="#k10">*** 10. Test-driven development (TDD)</a></p>
<p><a href="#k11">*** 11. Acceptance test–driven development (ATDD)</a></p>
<p><a href="#k12">12. Použití knihovny unittest.mock (nejenom) při testování</a></p>
<p><a href="#k13">13. Zdrojový soubor s&nbsp;funkcí, kterou budeme nahrazovat mock objektem</a></p>
<p><a href="#k14">*** 14. Test s&nbsp;volanou i s&nbsp;mockovanou funkcí</a></p>
<p><a href="#k15">*** 15. Vytvoření handleru, který se zavolá namísto originální funkce</a></p>
<p><a href="#k16">*** 16. Kombinace handleru s&nbsp;předkonfigurovanou návratovou hodnotou?</a></p>
<p><a href="#k17">*** 17. Obsah následující části seriálu</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Předchozí články s&nbsp;tématem testování (nejenom) v&nbsp;Pythonu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití Pythonu pro tvorbu testů: od jednotkových testů až po testy UI</h2>

<p>Testování aplikací, což je téma, do kterého se počítá jak tvorba testů, tak
i nástroje a postupy pro jejich spouštění a vyhodnocování, v&nbsp;současnosti
tvoří nedílnou součást vývoje aplikací a popř. i součást jejich akceptace
zákazníkem. Jedná se o velmi rozsáhlou oblast IT, která se postupně vyvíjela a
rozdělovala do několika podoblastí společně s&nbsp;tím, jak se měnil charakter
vyvíjených aplikací i jejich celková složitost (původně dávkové úlohy, dále
čistě desktopové aplikace s&nbsp;grafickým uživatelským rozhraním, následovaly
webové aplikace a webové služby, cloud atd.). S&nbsp;problematikou testů a
testování jsme se na stránkách <a href="https://www.root.cz">Roota</a> již
několikrát setkali (viz odkazy uvedené <a href="#k19">v&nbsp;devatenácté
kapitole</a>), ale možná bude užitečné se na testování podívat i
z&nbsp;určitého odstupu &ndash; jaké typy testů se používají, proč se vlastně
používají, jaké pomocné nástroje máme v&nbsp;dané oblasti k&nbsp;dispozici a
jaké jsou případné dobré a naopak špatné praktiky.</p>

<p>Samotný &ndash; dnes již samostatný &ndash; obor testování v&nbsp;IT se
postupně vyvíjel a měnily se i jeho metodiky. U mnoha starších (z&nbsp;dnešního
pohledu prastarých) projektů bylo testování prováděno jednorázově, a to na
konci vývoje celého systému. Toto mnohdy manuální či jen poloautomatické
testování bychom dnes nazvali <i>akceptačními testy</i>. Tento přístup již pro
většinu rozsáhlejších projektů není ani praktický ani nejlevnější; dnes je
totiž testování úzce svázáno s&nbsp;celým procesem vývoje nového informačního
systému a někdy celý vývoj začíná právě vytvořením prvotní sady testů.
Důležitější je ovšem průběžné testování v&nbsp;čase vývoje a nasazování
aplikace, což nám mj.&nbsp;dává přímou zpětnou vazbu o stavu vyvíjeného systému
(pokud jsou pochopitelně testy napsány dobře). V&nbsp;dnes začínajícím
(mini)seriálu si nejprve vysvětlíme základní termíny (ty ovšem nejsou plně
ustáleny) a postupně budeme proházet &bdquo;testovací pyramidou&ldquo; (viz
druhou kapitolu) od její základny až po vrchol.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto seriálu budeme primárně
používat programovací jazyk <a href="https://www.root.cz/n/python/">Python</a>,
ovšem jednotlivé typy testů, jejich struktura atd. má svůj přímý protějšek
v&nbsp;mnoha dalších programovacích jazycích. Mezi přednosti Pythonu
v&nbsp;této oblasti patří snadná tvorba <i>mocků</i> v&nbsp;jednotkových
testech, <a href="https://github.com/vinta/awesome-python#testing">rozsáhlá
sada nástrojů</a> pro tvorbu prakticky jakýchkoli typů testů (včetně knihovny
<a href="https://robotframework.org/">Robot Framework</a>, <a
href="https://github.com/HypothesisWorks/hypothesis">Hypothesis</a>) a rozhraní
pro <a href="https://pypi.org/project/selenium/">Selenium</a>) a
v&nbsp;neposlední řadě i relativně snadná dostupnost studijních
materiálů.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Různé podoby testovací pyramidy</h2>

<p>V&nbsp;souvislosti s&nbsp;testy (resp.&nbsp;přesněji řečeno s&nbsp;různými
typy testů) se poměrně často můžeme setkat s&nbsp;termínem &bdquo;testovací
pyramida&ldquo;. O co se vlastně jedná? Jde o rozdělení jednotlivých typů testů
do vrstev, přičemž vrstvy na spodních úrovních mají blíže k&nbsp;vlastnímu
zdrojovému kódu, zatímco vrstvy na úrovních vyšších již od kódu (a mnohdy i od
architektury aplikace) do značné míry abstrahují. Má to pochopitelně svůj velmi
dobrý význam, protože jedna úroveň abstrakce nemůže v&nbsp;této oblasti
vyhovovat pro všechny oblasti použití. Zajímavé je, že se sice tento termín
skutečně používá poměrně často, ale autoři si jednotlivé vrstvy (zejména ty
prostřední) rozdělují různým způsobem. Ostatně se můžeme podívat na několik
příkladů:</p>

*** image ***
<p><i>Obrázek 1: Různé podoby testovací pyramidy.</i></p>

*** image ***
<p><i>Obrázek 2: Různé podoby testovací pyramidy.</i></p>

*** image ***
<p><i>Obrázek 3: Různé podoby testovací pyramidy.</i></p>

*** image ***
<p><i>Obrázek 4: Různé podoby testovací pyramidy.</i></p>

<p>Většina autorů se shodne na tom, že testovací pyramida (ať již jsou její
vrstvy blíže k&nbsp;vrcholku pojmenovány různě) tvoří velmi dobrý příklad toho,
jak by testy reálné aplikace měly vypadat. Základem pyramidy jsou jednotkové
testy a základna by pochopitelně měla být co nejširší. Předností jednotkových
testů je jejich rychlé spouštění (může se testovat izolovaně pouze ona jednotka
&ndash; třída, funkce atd.), stabilita a poměrně snadné a rychlé úpravy. Směrem
k&nbsp;vrcholku pyramidy se vrstvy pochopitelně zužují, což v&nbsp;překladu
znamená, že by se testům na těchto úrovních mohla (relativně!) věnovat menší
pozornost. Testy blíže k&nbsp;vrcholu pyramidy jsou &bdquo;dražší&ldquo;, a to
jak z&nbsp;hlediska investovaného pracovního času (extrémem jsou manuální
testy), tak i času strojového (je nutné sestavit celou aplikaci i se všemi
souvisejícími službami atd.).</p>

<p><div class="rs-tip-major">Poznámka: představenou testovací pyramidu není
nutné chápat jako neměnný předpis, jak by testy měly či naopak neměly vypadat;
někdy se okolo ní dokonce tvoří zbytečný <i>cargo cult</i>. Následující
blogpost je dobrým zamyšlením nad některými limity celé hierarchie <a
href="https://medium.com/@fistsOfReason/testing-is-good-pyramids-are-bad-ice-cream-cones-are-the-worst-ad94b9b2f05f">Testing
is Good. Pyramids are Bad. Ice Cream Cones are the Worst</a>.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zmrzlinový kornout</h2>

<p>V&nbsp;souvislosti s&nbsp;prioritami, které se mají věnovat jednotlivým
typům testů, se někdy setkáme i s&nbsp;termínem &bdquo;zmrzlinový
kornout&ldquo;, což je struktura připomínající otočenou pyramidu. V&nbsp;této
struktuře se málo času/energie/peněz věnuje jednotkovým testům a testům
komponent, o to více času (alespoň relativně) se pak věnuje například testům
grafického uživatelského rozhraní nebo dokonce manuálním testům. Takto
nastavené priority při tvorbě testů jsou ovšem většinou praktikujících autorů
považovány za <i>antipattern</i>, ovšem i s&nbsp;takovým postupem
(popř.&nbsp;nějakou jeho variantou) se můžeme v&nbsp;praxi setkat.</p>

*** image ***
<p><i>Obrázek 5: Podoba zmrzlinového kornoutu v&nbsp;porovnání s&nbsp;testovací
pyramidou.</i></p>

<p><div class="rs-tip-major">Poznámka: ovšem jak již bylo patrné při
představování různých variant testovací pyramidy, je nesnadné až nemožné (a
hlavně mnohdy nepraktické) pracovat na všech úrovních testů. Mnohdy si velmi
dobře vystačíme například pouze se třemi úrovněmi (jednotkové testy, integrační
testy, testy UI) &ndash; to ovšem záleží na tom, o jakou aplikaci se jedná.
Jiné požadavky budou kladeny na utilitu spouštěnou z&nbsp;příkazové řádky
v&nbsp;porovnání s&nbsp;desktopovou aplikací s&nbsp;plnohodnotným GUI
popř.&nbsp;dokonce s&nbsp;webovou aplikací založenou na využití velkého
množství <a
href="https://www.root.cz/serialy/mikrosluzby/">mikroslužeb</a>.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Jednotkové testy &ndash; základ pyramidy, špička kornoutu</h2>

<p>První fáze testování většinou probíhá na úrovni balíčků, tříd, objektů,
metod a funkcí. Jedná se o takzvané <i>jednotkové testy</i> (<i>unit
tests</i>), přičemž onou jednotkou bývá jedna funkce, metoda, celá třída nebo
(méně často) celý balíček. Tyto testy se v&nbsp;Pythonu tvoří relativně snadno
a typicky se vytváří souběžně s&nbsp;programovým kódem nebo (při TDD) dokonce
ještě před zahájením prací na programovém kódu. Výhodou jednotkových testů je
jejich specifičnost, možnost selektivního spouštění testů pouze pro zvolenou
jednotku i snadné plánovaní prací (předpokládá se, že jednotkové testy jsou
součástí zdrojových kódů). Vývoj současně s&nbsp;jednotkovými testy může pomoci
s&nbsp;vytvářením kvalitnějšího kódu (typicky při omezování stavového prostoru
aplikace, globálních proměnných atd.). Ovšem při tvorbě jednotkových testů je
nutné počítat i s&nbsp;některými riziky, zejména pak:</p>

<ol>

<li>Pokud jednotkové testy vytváří samotný autor testovaného zdrojového kódu,
je pravděpodobné, že v&nbsp;testech nemusí pokrýt všechny možné případy, které
tak nebudou ani správně odhaleny ve zdrojovém kódu.</li>

<li>Velké množství procházejících testů může vést k&nbsp;tomu, že se budou
zbývající padající testy ignorovat.</li>

<li>Testy na sobě mohou záviset, což je obecně špatná architektura (testy by
mělo být možné spouštět v&nbsp;náhodném pořadí, popř.&nbsp;je filtrovat).</li>

<li>Změna architektury aplikace může znamenat nutnost přepisu velkého množství
jednotkových testů.</li>

</ol>

<p>V&nbsp;jednotkových testech je nutné některé (zrovna netestované) bloky
nahradit za jednodušší objekty nazývané <i>test double</i>. Ty se dále
rozdělují do několika kategorií: <i>fake</i>, <i>stub</i>, <i>mock</i>,
<i>spy</i> atd. (viz též navazující kapitoly, zejména <a href="#k12">dvanáctou
kapitolu</a>).</p>

<p>Příklad primitivního jednotkového testu:</p>

<pre>
import pytest
&nbsp;
def <strong>test_the_answer</strong>():
      x = 6
      y = 7
      assert x*y == 42, "test failed"
</pre>

<p>Pro programovací jazyk Python v&nbsp;současnosti existuje téměř nepřeberné
množství knihoven, frameworků a rozšíření standardních jednotkových testů.
Jmenujme například:</p>

<table>
<tr><th> #</th><th>Knihovna/framework</th></tr>
<tr><td> 1</td><td>unittest</td></tr>
<tr><td> 2</td><td>doctest</td></tr>
<tr><td> 3</td><td>pytest</td></tr>
<tr><td> 4</td><td>nose</td></tr>
<tr><td> 5</td><td>testify</td></tr>
<tr><td> 6</td><td>Trial</td></tr>
<tr><td> 7</td><td>Twisted</td></tr>
<tr><td> 8</td><td>subunit</td></tr>
<tr><td> 9</td><td>testresources</td></tr>
<tr><td>10</td><td>reahl.tofu</td></tr>
<tr><td>11</td><td>unit testing</td></tr>
<tr><td>12</td><td>testtools</td></tr>
<tr><td>13</td><td>Sancho</td></tr>
<tr><td>14</td><td>zope.testing</td></tr>
<tr><td>15</td><td>pry</td></tr>
<tr><td>16</td><td>pythoscope</td></tr>
<tr><td>17</td><td>testlib</td></tr>
<tr><td>18</td><td>pytest</td></tr>
<tr><td>19</td><td>dutest</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: v&nbsp;dalších článcích se
s&nbsp;některými výše uvedenými balíčky a nástroji setkáme.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Testy komponent a integrační testy</h2>

<p>Jak jsme již mohli vidět <a href="#k02">ve druhé kapitole</a>, tvoří
jednotkové testy jen jedinou vrstvu (základnu) takzvané &bdquo;testovací
pyramidy&ldquo;. Nad nimi se v&nbsp;dalších vrstvách nachází testy komponent,
funkční testy, integrační testy, různé formy benchmarků, BDD testy, testy
grafického uživatelského rozhraní, manuálně prováděné testy atd. Všechny tyto
testy jsou potenciálně důležité, protože samotné jednotkové testy zdaleka
nedokáží odhalit všechny možné chyby:</p>

*** image ***
<p><i>Obrázek 6: Jednotkové testy nedokáží odhalit problémy na vyšších úrovních
abstrakce, například problematické sestavení jednotlivých modulů do vyšších
celků.</i></p>

<p>A právě z&nbsp;tohoto důvodu jsou nad samotnými jednotkovými testy postaveny
testy komponent a integrační testy. Ty se snaží zjistit, zda je možné menší (a
ideálně velmi dobře izolovaně otestované) jednotky (<i>units</i>) sestavit do
většího a přitom stále funkčního celku. V&nbsp;některých případech se rozlišuje
mezi vnitřní a vnější integrací (testy komponent patří do první kategorie).
Testuje se například komunikace mezi jednotlivými moduly, ze kterých se
výsledná aplikace skládá. Podobně jako se u jednotkových testů používají
<i>mock objekty</i> (resp.&nbsp;obecněji <i>test double</i>), lze u
integračních testů používat takzvané <i>fake moduly</i> a <i>mock moduly</i>.
Poměrně názorným příkladem takového modulu může být zjednodušená forma databáze
uložená v&nbsp;operační paměti, která pro účely testů nahrazuje reálnou
databázi (v&nbsp;paměti lze velmi snadno provozovat například SQLite).
Relativně snadno se nahrazují i například moduly pro logování apod. Taktéž se
zde setkáme s&nbsp;takzvanými špiony (<i>spies</i>), což jsou moduly
zaznamenávající všechny požadavky přicházející z&nbsp;jiných modulů.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Systémové testy, akceptační testy</h2>

<p></p>

<p>Na první úrovní můžeme nalézt <i>smoke testy</i>, které pouze velmi rychle zjišťují, zda je zajištěna alespoň minimální míra funkčnosti aplikace předtím, než se spustí složitější a časově mnohem náročnější testy.</p>

rozděleno do více podkategorií


systémové testy
O něco výše v&nbsp;hierarchii se nachází systémové testy, jejichž primárním účelem je ověření, jestli aplikace (služba) sestavená do jednoho celku pracuje korektně. Tyto testy se zaměřují jak na zjištění, zda pro určité vstupy aplikace produkuje určitý výstup (například objedná letenku), ale i to, jak reaguje na nestandardní situace, špatně zadané vstupy apod.

<p></p>

<pre>
| *** Settings ***   |                  |   |
| Library            | Test16.py        |   |
|                    |                  |   |
| *** Test Cases *** |                  |   |
| Adder #1           |                  |   |
|                    | Add              | 1 | 2
|                    | Result should be | 3 |
|                    |                  |   |
| Adder #2           |                  |   |
|                    | Add              | 0 | 0
|                    | Result should be | 0 |
|                    |                  |   |
| Adder #3           |                  |   |
|                    | Add              | 1 | -1
|                    | Result should be | 0 |
</pre>

<p>Alternativně:</p>

<pre>
| *** Settings ***   |                  |   |
| Library            | Test16.py        |   |
&nbsp;
| *** Test Cases *** |                  |   |
| Adder #1           |                  |   |
|                    | Add              | 1 | 2
|                    | Result should be | 3 |
|                    | Add              | 2 | 3
|                    | Result should be | 5 |
|                    | Add              | 4 | 5
|                    | Result should be | 9 |
&nbsp;
| Adder #2           |                  |   |
|                    | Add              | 0 | 0
|                    | Result should be | 0 |
&nbsp;
| Adder #3           |                  |   |
|                    | Add              | 1 | -1
|                    | Result should be | 0 |
</pre>

<pre>
| *** Settings ***   |                             |             |             |
| Library            | Accumulator6.py             |             |             |
| Test template      | Accumulate                  |             |             |
| Test setup         | Setup method                | 0           |             |
| Test teardown      | Teardown method             |             |             |
|                    |                             |             |             |
| *** Test Cases *** | Value                       | Expected    |             |
| Test1              | 0                           | 0           |             |
|                    | 1                           | 1           |             |
|                    | 10                          | 11          |             |
|                    | -10                         | 1           |             |
|                    | 1                           | 2           |             |
|                    | 1                           | 3           |             |
|                    |                             |             |             |
| *** Keywords ***   |                             |             |             |
| Accumulate         |                             |             |             |
|                    | [Arguments]                 | ${value}    | ${expected} |
|                    | Add value                   | ${value}    |             |
|                    | Accumulator value should be | ${expected} |             |
</pre>

<p><div class="rs-tip-major">Poznámka: pokud se s&nbsp;využitím Robot Frameworku tvoří akceptační testy, tak může být právě tabulková forma vhodná, protože se vlastně jedná o úřední dokument mnohdy zpracovávaný lidmi, kteří mají tabulky v&nbsp;oblibě :-)</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Testy aplikačního (programového) rozhraní</h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. Testy grafického uživatelského rozhraní</h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. Testy chování (BDD)</h2>

<p>Velmi důležité jsou testy chování (<i>behaviour-driven</i>), protože ty nám
mohou odhalit nelogičnosti ve zdánlivě funkčním systému (například se očekává
neintuitivní ovládání). Tyto typy testů do určité míry kombinují přístupy TDD a
ATDD (viz následující dvě kapitoly); používají se zde nástroje
<strong>Behave</strong> či <strong>Robot Framework</strong>. Zajímavé je, že se
v&nbsp;této oblasti můžeme setkat s&nbsp;určitou standardizací (procházející
dokonce přes více programovacích jazyků), kterou představuje doménově
specifický jazyk (DSL) nazvaný <i>Gherkin</i>.</p>

<p>Ve dvou článcích [<a
href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">1</a>]
[<a
href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">2</a>]
o programovacím jazyku Clojure jsme se věnovali popisu integrace výše zmíněného
doménově specifického jazyka <i>Gherkin</i> určeného pro popis testovacích
scénářů přímo v&nbsp;programovacím jazyku Clojure. Ve skutečnosti ovšem není
<i>Gherkin</i> v&nbsp;žádném případě určen pouze pro použití společně
s&nbsp;Clojure, ale jedná se o <a
href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a>
integrovatelný i do mnoha dalších programovacích jazyků. Dnes si ve stručnosti
představíme knihovnu <a href="https://pypi.python.org/pypi/behave">Behave</a>,
s&nbsp;jejíž pomocí se Gherkin integruje do jazyka Python. Ve skutečnosti se
bude jednat o téměř ideální spojení, protože Gherkin i Python používají podobný
způsob zápisu, v&nbsp;němž i odsazení jednotlivých programových řádků je
součástí syntaxe (naproti tomu se Gherkin a Clojure ze syntaktického hlediska
zcela odlišují).</p>

<p>Jazyk Gherkin je navržen takovým způsobem, aby ho uživatelé (nemusí se totiž
nutně jednat pouze o programátory) mohli začít používat prakticky okamžitě,
tj.&nbsp;bez nutnosti studia sáhodlouhých manuálů.</p> Tento doménově
specifický jazyk odstiňuje autora testů od vlastní implementace systému i od
programovacího jazyka (či jazyků), v&nbsp;nichž je systém vytvořen. Ostatně
v&nbsp;Gherkinu lze popsat očekávané chování prakticky jakéhokoli systému,
který dokonce nemusí mít nic společného s&nbsp;IT.

<a href="https://www.root.cz/obrazek/324266/"><img src="https://i.iinfo.cz/images/634/clojure-cucumber-1-prev.png" class="image-324266" alt="&#160;" width="370" height="198" /></a>
<p><i>Obrázek X: Ukázka scénářů napsaných v&nbsp;doménově specifickém jazyce
Gherkin.</i></p>

<p>Na předchozím screenshotu jsou zvýrazněna klíčová slova uvozující jednotlivé
kroky testu. Ostatní slova a číslice ve větách jsou buď pevně daná (svázaná
s&nbsp;konkrétním krokem), nebo se jedná o proměnné. Ve scénáři je zapsána i
tabulka, jejíž obsah se řádek po řádku postupně stává obsahem jednotlivých
kroků testu (obsahem tabulky se nahrazují slova umístěná do ostrých
závorek).</p>

<p><div class="rs-tip-major">Poznámka: doménově specifický jazyk Gherkin
existuje v&nbsp;různých jazykových mutacích, my se však budeme držet jeho
originální anglické varianty. Ostatně mnoho knihoven, které Gherkin podporují,
pracuje pouze s&nbsp;anglickou variantou.</div></p>

<p>Druhým důležitým souborem je vlastní testovací scénář nazvaný
<strong>adder.feature</strong>, který je (př použití knihovny
<strong>Behave</strong>) typicky uložen v&nbsp;podadresáři
<strong>features</strong>. Tento testovací scénář je naprogramován
v&nbsp;jazyku <i>Gherkin</i>, konkrétně v&nbsp;jeho výchozí anglické
&bdquo;mutaci&ldquo;. V&nbsp;následujícím výpisu jsou klíčová slova rozeznávaná
interpretrem označena tučně:</p>

<pre>
<strong>Feature</strong>: Adder test
&nbsp;
  <strong>Scenario</strong>: Check the function add()
    <strong>Given</strong> The function add is callable
    <strong>When</strong> I call function add with arguments 1 and 2
    <strong>Then</strong> I should get 3 as a result
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že jazyk Gherkin je
z&nbsp;hlediska sémantiky velmi jednoduchý jazyk. Obsahuje deklarace
jednotlivých testovacích scénářů, počáteční podmínku a potom sérii kroků ve
stylu &bdquo;když udělám X, stane se (očekávám) Y&ldquo;. Syntax je také
jednoduchá (alespoň v&nbsp;základních testovacích scénářích), protože první
slovo je klíčové a jednotlivé bloky (zde scénáře) jsou odsazeny, podobně jako
v&nbsp;samotném Pythonu či ve formátu YAML.</div></p>

<p>Tento přístup je možné napodobit i při použití Robot Frameworku, v&nbsp;němž
může zápis testu vypadat například následovně:</p>

<pre>
*** Settings ***
Library             Accumulator6.py
Test setup          Setup method  0
Test teardown       Teardown method
Test template       Accumulator operation
&nbsp;
*** Keywords ***
Accumulator operation
                    [Arguments]  ${value}  ${expected}
                    Given accumulator has been zeroed
                    When I add ${value} to accumulator
                    Then the accumulated value Should Be ${expected}
&nbsp;
*** Test Cases ***     Value  Expected
Accumulator operation  1      1
Accumulator operation  10     10
&nbsp;
&nbsp;
&nbsp;
*** Keywords ***
Accumulator has been zeroed
    log  accumulator init
&nbsp;
I add ${value} to accumulator
    Add value  ${value}
&nbsp;
Then the accumulated value should be ${expected}
    Accumulator value should be  ${expected}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Test-driven development (TDD)</h2>

<p></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Acceptance test–driven development (ATDD)</h2>

<p></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Použití knihovny unittest.mock (nejenom) při testování</h2>

<p>Při testování aplikací, zejména při psaní jednotkových testů (což je, jak
již ostatně víme, základ testovací pyramidy), se poměrně často dostaneme do
situace, kdy potřebujeme nahradit nějakou funkci, metodu nebo dokonce celou
třídu používanou v&nbsp;reálné aplikaci za &bdquo;falešnou&ldquo;
funkci/metodu/třídu vytvořenou pouze pro účely jednotkových testů.
V&nbsp;programovacím jazyku Python je možné pro tvorbu a použití takových
&bdquo;falešných&ldquo; bloků kódu použít hned několik různých knihoven, které
se od sebe odlišují jak svými možnostmi, tak i způsobem zápisu či deklarace
očekávaného chování testované aplikace. Určitým standardem v&nbsp;této oblasti
je v&nbsp;současnosti knihovna <i>unittest.mock</i>. Dnes si ukážeme některé
základní techniky, které nám tato knihovna poskytuje.</p>

<p>S&nbsp;následující situací se již setkal pravděpodobně každý vývojář
vytvářející jednotkové testy &ndash; je nutné otestovat funkcionalitu části
aplikace, v&nbsp;této části se však volá nějaká funkce nebo metoda provádějící
potenciálně destruktivní činnost (změna filesystému, vzdálené volání procedur,
programování zařízení připojeného přes USB atd.). Popř.&nbsp;se volá
funkce/metoda, která v&nbsp;závislosti na různých okolnostech vrací (minimálně
z&nbsp;pohledu testů) pseudonáhodná data. Takovou funkci/metodu by bylo vhodné
pro účely testování nahradit jednodušším kódem, jenž bude provádět předem
známou činnost, například bude za každých okolností pouze vracet určitou
hodnotu. Taková náhrada skutečných funkcí či metod za funkce/metody
&bdquo;falešné&ldquo; se (poněkud nepřesně) nazývá &bdquo;mockování&ldquo;
(<i>mocking</i>), a příslušný náhradní kód pak <i>test double</i>,
popř.&nbsp;podle funkce <i>fake</i>, <i>stub</i>, <i>spy</i> nebo <i>mock</i>.
V&nbsp;druhé části dnešního článku si ukážeme, jakým způsobem se může tato
technika použít v&nbsp;Pythonu, konkrétně v&nbsp;Pythonu řady 3.x.</p>

<p>V&nbsp;současnosti existuje relativně velké množství různých knihoven, které
mockování v&nbsp;Pythonu umožňují. Z&nbsp;nich jmenujme například velmi
zajímavý projekt <i>Flexmock</i>, který naleznete na adrese <a
href="https://pypi.python.org/pypi/flexmock">https://pypi.python.org/pypi/flexmock</a>.
Ovšem v&nbsp;Pythonu 3.x se standardem v&nbsp;této oblasti stala knihovna
nazvaná <a
href="https://docs.python.org/dev/library/unittest.mock.html">unittest.mock</a>.
V&nbsp;případě, že ještě z&nbsp;nějakého důvodu musíte používat Python 2.x,
použijte namísto knihovny <i>unittest.mock</i> knihovnu nazvanou jednoduše <a
href="https://pypi.python.org/pypi/mock">mock</a>. Tato knihovna nabízí
prakticky stejné možnosti jako <i>unittest.mock</i> (je ostatně založena na
stejném kódu, který pouze byl pro potřeby Pythonu 2.x upraven), ovšem lze ji
použít jak v&nbsp;Pythonu 2.x, tak i v&nbsp;Pythonu 3.x, a to bez toho, abyste
museli upravovat zdrojové kódy vašich testů (samozřejmě za předpokladu, že se
v&nbsp;nich nevyskytují konstrukce, které nejsou v&nbsp;Pythonu 2.x
podporovány). Další knihovny, které stojí za zmínku a které jsou potenciálně
užitečné, jsou zmíněny v&nbsp;další tabulce:</p>

<table>
<tr><th> #</th><th>Nástroj</th></tr>
<tr><td> 1</td><td>Ludibrio</td></tr>
<tr><td> 2</td><td>Python Mock</td></tr>
<tr><td> 3</td><td>PyMock</td></tr>
<tr><td> 4</td><td>mock</td></tr>
<tr><td> 5</td><td>pMock</td></tr>
<tr><td> 6</td><td>minimock</td></tr>
<tr><td> 7</td><td>svnmock</td></tr>
<tr><td> 8</td><td>Mocker</td></tr>
<tr><td> 9</td><td>Stubble</td></tr>
<tr><td>10</td><td>Mox</td></tr>
<tr><td>11</td><td>MockTest</td></tr>
<tr><td>12</td><td>Fudge</td></tr>
<tr><td>13</td><td>Mockito for Python</td></tr>
<tr><td>14</td><td>CaptureMock</td></tr>
<tr><td>15</td><td>flexmock</td></tr>
<tr><td>16</td><td>doublex</td></tr>
<tr><td>17</td><td>aspectlib</td></tr>
</table>

<p>Vraťme se však k&nbsp;základům jednotkových testů a mockování. Zmíněný
falešný blok kódu je možné podle jeho vlastností rozdělit do několika
kategorií:</p>

<ol>

<li><i>fake</i> &ndash; vrací jedinou programátorem zvolenou hodnotu. Příkladem
může být funkce nahrazující čtení z&nbsp;databáze, která vždy vrátí jediný
záznam.</li>

<li><i>stub</i> &ndash; již obsahuje jednoduchou logiku, například dokáže
reagovat na špatný vstup podobně, jako nahrazovaný blok.</li>

<li><i>spy</i> &ndash; dokáže zaznamenat předávané parametry či dokonce celý
stav (nebo podstav) aplikace.</li>

<li><i>mock</i> &ndash; mnohdy se jedná o blok s&nbsp;vlastnostmi, které se
přibližují reálnému (nahrazovanému) kódu. Vylepšená verze <i>stub</i>.</li>

</ol>

<p><div class="rs-tip-major">Poznámka: samotná knihovna <i>unittest.mock</i> je
obecná, takže mezi výše zmíněnými kategoriemi nijak nerozlišuje (a mnozí
programátoři také ne). I my budeme při popisech možností této knihovny mluvit o
&bdquo;mock objektech&ldquo;, ale až na základě jejich konkrétní implementace
se rozliší, zda se jedná o blok vracející jednu hodnotu, zda bude obsahovat
nějakou logiku, logování parametrů/stavů atd.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zdrojový soubor s&nbsp;funkcí, kterou budeme nahrazovat mock objektem</h2>

<p>Popis možností knihovny <strong>unittest.mock</strong> začneme na tom
nejjednodušším možném příkladu. Bude se jednat o aplikaci (či spíše
minimalistickou &bdquo;aplikaci&ldquo;) tvořenou pouhými dvěma zdrojovými
soubory <a
href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/application.py">application.py</a>
a <a
href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/main.py">main.py</a>.
První zmíněný soubor obsahuje jedinou funkci pojmenovanou
<strong>function1</strong>, která po svém zavolání nejprve vypíše na standardní
výstup text &bdquo;function1 called&ldquo; a následně vrátí do volajícího kódu
řetězec s&nbsp;obsahem &bdquo;tested function&ldquo;, jenž může být
v&nbsp;případě potřeby dále zpracován. Celý soubor se zdrojovým kódem má tedy
pouze několik řádků (funkce je volána ze skriptu <strong>main.py</strong>):</p>

<pre>
<i>"""Implementace logiky aplikace, kterou budeme testovat."""</i>
&nbsp;
&nbsp;
def <strong>function1</strong>():
    <i>"""Funkce, kterou v testech nahradíme mockem."""</i>
    print("function1 called")
    return "tested function"
</pre>

<p>Zavolání této aplikace je snadné a provede se, jak již víme, přes skript
<strong>main.py</strong>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
&nbsp;
<i>"""Vstupní bod do testované aplikace."""</i>
&nbsp;
from application import *
&nbsp;
&nbsp;
if __name__ == '__main__':
    <i># pouze zavoláme funkci, která se bude v testech mockovat</i>
    print(function1())
</pre>

<p>Následovně:</p>

<pre>
$ <strong>python3 main.py</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se o zcela umělý příklad, který má
jen jedinou přednost &ndash; je skutečně minimalistický, takže ukázka možností
knihovny <strong>unit.mock</strong> pravděpodobně bude poměrně názorná.
S&nbsp;reálnějšími příklady se seznámíme příště.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Test s&nbsp;volanou i s&nbsp;mockovanou funkcí</h2>

<p>Nyní se podívejme na to, jakým způsobem se může funkce <strong>function1</strong> volat v&nbsp;jednotkových testech. Pro jednoduchost prozatím nepoužijeme žádný framework určený pro psaní jednotkových testů (to bude téma pro samostatný článek), ale vytvoříme si jednoduchý pomocný soubor nazvaný <a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test1/test.py">test.py</a>, v&nbsp;němž se pokusíme zavolat jak původní funkci, tak i její tzv.&nbsp;<i>mock</i> (&bdquo;falešnou&ldquo; variantu původní funkce). Na začátku je nutné provést import modulu <strong>unittest.mock</strong> a samozřejmě taktéž import testovaného modulu <strong>application</strong>:</p>

<pre>
from unittest.mock import *
&nbsp;
import application
</pre>

<p>První pseudotest bude jednoduchý &ndash; pouze v&nbsp;něm zavoláme původní funkci a vypíšeme hodnotu, kterou tato funkce vrátí volajícímu kódu (zde se žádné mockování neprování):</p>

<pre>
def <strong>test1</strong>():
    print(application.function1())
</pre>

<p>Druhý pseudotest je již mnohem zajímavější, protože v&nbsp;něm namísto původní funkce <strong>function1</strong> z&nbsp;modulu <strong>application</strong> použijeme mock. Deklarace testovací funkce je doplněna o anotaci <strong>@patch</strong>, v&nbsp;níž specifikujeme jméno mockované funkce (ve formě řetězce, jehož obsah je kontrolován) a současně i návratovou hodnotu. To je nutné, protože se původní funkce ve skutečnosti vůbec nezavolá, ale návratovou hodnotu použijeme ve funkci <strong>print</strong>:</p>

<pre>
@patch('application.function1', return_value=42)
def <strong>test2</strong>(mocked_function_object):
    print(application.function1())
</pre>

<p>Povšimněte si, že jméno mockované funkce je zapsáno i s&nbsp;uvedením jmenného prostoru (&bdquo;application.function1&ldquo;), který ovšem musí odpovídat kontextu, v&nbsp;němž se funkce volá! Právě uvedení správného kontextu je pravděpodobně nejdůležitější část, kterou je nutné při mockování pochopit (více viz navazující kapitoly). Navíc stojí za povšimnutí, že se testovací funkci <strong>test2</strong> předává parametr <strong>mocked_function_object</strong>, který představuje objekt udržující informace o mocku. Tento objekt využijeme v&nbsp;dalších demonstračních příkladech, nyní je však nutné si uvědomit, že se tento parametr plní automaticky (při volání <strong>test2</strong> ho explicitně nebudeme uvádět).</p>

<p>Nyní již můžeme skript doplnit o kód, který všechny testy spustí. Povšimněte si, že první test naschvál spouštíme dvakrát (na začátku a na konci), aby bylo patrné, že mockovaná funkce se volá pouze v&nbsp;testu <strong>test2</strong> (mockování je v&nbsp;tomto případě přísně lokální):</p>

<pre>
if __name__ == '__main__':
    test1()
    print()
&nbsp;
    test2()
    print()
&nbsp;
    test1()
    print()
</pre>

<p>Výsledek vypsaný po provedení skriptu potvrzuje, že při každém spuštění testu <strong>test1</strong> se zavolá původní funkce, kdežto při spuštění testu <strong>test2</strong> funkce mockovaná:</p>

<pre>
$ <strong>python3 test.py</strong>
&nbsp;
function1 called
tested function
&nbsp;
42
&nbsp;
function1 called
tested function
</pre>

<p><div class="rs-tip-major">Poznámka: náš mock pouze vrací hodnotu a nesnaží se žádným způsobem napodobit logiku funkce (tedy výpis zprávy na standardní výstup). Jedná se tedy o <i>fake double</i>.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Vytvoření handleru, který se zavolá namísto originální funkce</h2>

<p>Prozatím jsme se dozvěděli, jakým způsobem je možné nahradit volání skutečné funkce vrácením nějaké předem nastavené hodnoty. Tato hodnota sice může být prakticky jakákoli (číslo, pravdivostní hodnota, řetězec, pole, n-tice, slovník, objekt, klidně i <strong>None</strong>), ovšem někdy si s&nbsp;tímto chováním nevystačíme a budeme potřebovat, aby se namísto původní funkce zavolala funkce odlišná; typicky mnohem jednodušší, s&nbsp;předvídatelnějšími výsledky atd. Příkladem může být &bdquo;falešná&ldquo; funkce nahrazující čtení záznamů z&nbsp;databáze za výběr hodnoty z&nbsp;předem známé datové struktury. S&nbsp;využitím knihovny <strong>unittest.mock</strong> je nahrazení původní funkce za její (ne)plnohodnotný mock snadné. Nejprve tuto funkci deklarujeme (měla by akceptovat stejné parametry, jako funkce původní) a následně použijeme v&nbsp;anotaci <strong>@patch</strong> nepovinný parametr <strong>side_effect</strong>, kterému předáme referenci na mock:</p>

<pre>
def side_effect_handler():
    print("side_effect function called")
    return -1


@patch('application.function1', side_effect=side_effect_handler)
def test3(mocked_function_object):
    print(application.function1())
</pre>

<p>Pokud spustíme třetí test představovaný výše vypsanou funkcí <strong>test3</strong> (a to opět BEZ parametrů):</p>

<pre>
test3()
</pre>

<p>zavolá se z&nbsp;něj ve skutečnosti funkce <strong>side_effect_handler</strong> a nikoli <strong>application.function1</strong>:</p>

<pre>
side_effect function called
-1
</pre>

<p><div class="rs-tip-major">Poznámka: takto vytvořený mock je opět použit jen lokálně v&nbsp;rámci testu představovaného funkcí <strong>test3</strong></div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Kombinace handleru s&nbsp;předkonfigurovanou návratovou hodnotou?</h2>

<p>Podívejme se ještě, co se stane ve chvíli, kdy v&nbsp;anotaci <strong>@patch</strong> současně použijeme parametr <strong>return_value</strong> i <strong>side_effect</strong>. Zápis bude vypadat následovně:</p>

<pre>
def side_effect_handler():
    print("side_effect function called")
    return -1

@patch('application.function1', return_value=42, side_effect=side_effect_handler)
def test4(mocked_function_object):
    print(application.function1())
</pre>

<p>Pokud zavoláme výše vypsanou testovací funkci <strong>test4</strong>, vypíšou se na standardní výstup následující dva řádky, z&nbsp;nichž je patrné, že se hodnota specifikovaná parametrem <strong>return_value</strong> ignorovala a namísto ní se použila návratová hodnota &bdquo;falešné&ldquo; funkce <strong>side_effect_handler</strong>:</p>

<pre>
side_effect function called
-1
</pre>

<p>Toto chování se ale změní ve chvíli, kdy mock vrátí speciální hodnotu <strong>unittest.mock.DEFAULT</strong> (přesněji řečeno <strong>sentinel.DEFAULT</strong>). V&nbsp;takovém případě se skutečně využije hodnota zapsaná v&nbsp;parametru <strong>return_value</strong> v&nbsp;anotaci <strong>@patch</strong>, o čemž se lze velmi snadno přesvědčit:</p>

<pre>
def side_effect_handler_2():
    print("side_effect function called")
    return DEFAULT


@patch('application.function1', return_value=42, side_effect=side_effect_handler_2)
def test5(mocked_function_object):
    print(application.function1())
</pre>

<p>Výsledek zavolání výše vypsané testovací funkce <strong>test5</strong>:</p>

<pre>
side_effect function called
42
</pre>

<p>Díky tomuto chování je možné použít &bdquo;falešnou&ldquo; funkci ve větším množství testů, což je téma, kterým se budeme podrobněji zabývat příště.</p>

<p>Pro přehlednost je v&nbsp;této kapitole vypsán úplný zdrojový kód dnešního <a href=""></a> rozděleného do dvou modulů.</p>

<h3>Soubor <strong>application.py</strong> s&nbsp;testovanou funkcí</h3>

<pre>
"""Implementace logiky aplikace, kterou budeme testovat."""


def function1():
    """Funkce, kterou v testech nahradíme mockem."""
    print("function1 called")
    return "tested function"
</pre>

<h3>Soubor <strong>test.py</strong> s&nbsp;testy</h3>

<pre>
"""Implementace (umělých) jednotkových testů."""

from unittest.mock import *

import application


def test1():
    """První test neprovádí prakticky žádné reálné kontroly, jen zavolá testovanou funkci."""
    print(application.function1())


@patch('application.function1', return_value=42)
def test2(mocked_function):
    """Druhý test používá fake test double - náhradu volané funkce."""
    print(application.function1())


def side_effect_handler():
    """Implementace handleru - stub funkce nahrazované mockem."""
    print("side_effect function called")
    return -1


@patch('application.function1', side_effect=side_effect_handler)
def test3(mocked_function):
    """Druhý test používá stub test double - náhradu volané funkce."""
    print(application.function1())


@patch('application.function1', return_value=42, side_effect=side_effect_handler)
def test4(mocked_function):
    """Čtvrtý test se snaží zkombinovat fake a stub."""
    print(application.function1())


def side_effect_handler_2():
    """Implementace handleru - stub funkce nahrazované mockem, který ovšem ovlivňuje chování testu."""
    print("side_effect function called")
    return DEFAULT


@patch('application.function1', return_value=42, side_effect=side_effect_handler_2)
def test5(mocked_function):
    """Čtvrtý test se opět snaží zkombinovat fake a stub."""
    print(application.function1())


if __name__ == '__main__':
    print("*** test1 ***")
    test1()
    print()

    print("*** test2 ***")
    test2()
    print()

    print("*** test3 ***")
    test3()
    print()

    print("*** test4 ***")
    test4()
    print()

    print("*** test5 ***")
    test5()
    print()

    print("*** test1 ***")
    test1()
    print()
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Obsah následující části seriálu</h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
nového Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/testing-in-python">https://github.com/tisnik/testing-in-python</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem &ndash;
alespoň prozatím &ndash; velmi malý, dnes má přibližně deseti kilobajtů),
můžete namísto toho použít odkazy na jednotlivé demonstrační příklady a jejich
části, které naleznete v&nbsp;následující tabulce:</p>

https://github.com/tisnik/testing-in-python/blob/master/

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>application.py</td><td>implementace mockované funkce</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/application.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/application.py</a></td></tr>
<tr><td> 2</td><td>main.py</td><td>vstupní bod do testované aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/main.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/main.py</a></td></tr>
<tr><td> 3</td><td>test.py</td><td>implementace jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/test.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/test.py</a></td></tr>
<tr><td> 4</td><td>run</td><td>skript pro spuštění aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/run">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/run</a></td></tr>
<tr><td> 5</td><td>test</td><td>skript pro spuštění jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/test">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/test</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>application.py</td><td>implementace mockované funkce</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/application.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/application.py</a></td></tr>
<tr><td> 7</td><td>main.py</td><td>vstupní bod do testované aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/main.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/main.py</a></td></tr>
<tr><td> 8</td><td>test.py</td><td>implementace jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/test.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/test.py</a></td></tr>
<tr><td> 9</td><td>run</td><td>skript pro spuštění aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/run">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/run</a></td></tr>
<tr><td>10</td><td>test</td><td>skript pro spuštění jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/test">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/test</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články s&nbsp;tématem testování (nejenom) v&nbsp;Pythonu</h2>

<p>Tématem testování jsme se již na stránkách Rootu několikrát zabývali. Jedná
se mj.&nbsp;o následující články:</p>

<ol>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave (druhá část)<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-druha-cast/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-druha-cast/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave (závěrečná část)<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-zaverecna-cast/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-zaverecna-cast/</a>
</li>

<li>Validace datových struktur v Pythonu pomocí knihoven Schemagic a Schema<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/</a>
</li>

<li>Validace datových struktur v Pythonu (2. část)<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-2-cast/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-2-cast/</a>
</li>

<li>Validace datových struktur v Pythonu (dokončení)<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-dokonceni/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-dokonceni/</a>
</li>

<li>Univerzální testovací nástroj Robot Framework<br />
<a href="https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework/">https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework/</a>
</li>

<li>Univerzální testovací nástroj Robot Framework a BDD testy<br />
<a href="https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework-a-bdd-testy/">https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework-a-bdd-testy/</a>
</li>

<li>Úvod do problematiky fuzzingu a fuzz testování<br />
<a href="https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani/">https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani/</a>
</li>

<li>Úvod do problematiky fuzzingu a fuzz testování – složení vlastního fuzzeru<br />
<a href="https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani-slozeni-vlastniho-fuzzeru/">https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani-slozeni-vlastniho-fuzzeru/</a>
</li>

<li>Knihovny a moduly usnadňující testování aplikací naprogramovaných v jazyce Clojure<br />
<a href="https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/">https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/</a>
</li>

<li>Validace dat s využitím knihovny spec v Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

<li>Testování aplikací naprogramovaných v jazyce Go<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/">https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/</a>
</li>

<li>Knihovny určené pro tvorbu testů v programovacím jazyce Go<br />
<a href="https://www.root.cz/clanky/knihovny-urcene-pro-tvorbu-testu-v-programovacim-jazyce-go/">https://www.root.cz/clanky/knihovny-urcene-pro-tvorbu-testu-v-programovacim-jazyce-go/</a>
</li>

<li>Testování aplikací psaných v Go s využitím knihoven Goblin a Frisby<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/">https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/</a>
</li>

<li>Testování Go aplikací s využitím knihovny GΩmega a frameworku Ginkgo<br />
<a href="https://www.root.cz/clanky/testovani-go-aplikaci-s-vyuzitim-knihovny-gomega-mega-a-frameworku-ginkgo/">https://www.root.cz/clanky/testovani-go-aplikaci-s-vyuzitim-knihovny-gomega-mega-a-frameworku-ginkgo/</a>
</li>

<li>Tvorba BDD testů s využitím jazyka Go a nástroje godog<br />
<a href="https://www.root.cz/clanky/tvorba-bdd-testu-s-vyuzitim-jazyka-go-a-nastroje-godog/">https://www.root.cz/clanky/tvorba-bdd-testu-s-vyuzitim-jazyka-go-a-nastroje-godog/</a>
</li>

<li>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem<br />
<a href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/">https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/</a>
</li>

<li>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem (dokončení)<br />
<a href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem-dokonceni/">https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem-dokonceni/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure (2)<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Awesome Python &ndash; testing<br />
<a href="https://github.com/vinta/awesome-python#testing">https://github.com/vinta/awesome-python#testing</a>
</li>

<li>Selenium (pro Python)<br />
<a href="https://pypi.org/project/selenium/">https://pypi.org/project/selenium/</a>
</li>

<li>Getting Started With Testing in Python<br />
<a href="https://realpython.com/python-testing/">https://realpython.com/python-testing/</a>
</li>

<li>unittest.mock — mock object library<br />
<a href="https://docs.python.org/3.5/library/unittest.mock.html">https://docs.python.org/3.5/library/unittest.mock.html</a>
</li>

<li>mock 2.0.0<br />
<a href="https://pypi.python.org/pypi/mock">https://pypi.python.org/pypi/mock</a>
</li>

<li>An Introduction to Mocking in Python<br />
<a href="https://www.toptal.com/python/an-introduction-to-mocking-in-python">https://www.toptal.com/python/an-introduction-to-mocking-in-python</a>
</li>

<li>Mock - Mocking and Testing Library<br />
<a href="http://mock.readthedocs.io/en/stable/">http://mock.readthedocs.io/en/stable/</a>
</li>

<li>Python Mocking 101: Fake It Before You Make It<br />
<a href="https://blog.fugue.co/2016-02-11-python-mocking-101.html">https://blog.fugue.co/2016-02-11-python-mocking-101.html</a>
</li>

<li>Nauč se Python! - Testování<br />
<a href="http://naucse.python.cz/lessons/intro/testing/">http://naucse.python.cz/lessons/intro/testing/</a>
</li>

<li>Flexmock (dokumentace)<br />
<a href="https://flexmock.readthedocs.io/en/latest/">https://flexmock.readthedocs.io/en/latest/</a>
</li>

<li>Test Fixture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test_fixture">https://en.wikipedia.org/wiki/Test_fixture</a>
</li>

<li>Mock object (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Mock_object">https://en.wikipedia.org/wiki/Mock_object</a>
</li>

<li>Extrémní programování<br />
<a href="https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD">https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD</a>
</li>

<li>Programování řízené testy<br />
<a href="https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy">https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>Tox<br />
<a href="https://tox.readthedocs.io/en/latest/">https://tox.readthedocs.io/en/latest/</a>
</li>

<li>pytest: helps you write better programs<br />
<a href="https://docs.pytest.org/en/latest/">https://docs.pytest.org/en/latest/</a>
</li>

<li>doctest — Test interactive Python examples<br />
<a href="https://docs.python.org/dev/library/doctest.html#module-doctest">https://docs.python.org/dev/library/doctest.html#module-doctest</a>
</li>

<li>unittest — Unit testing framework<br />
<a href="https://docs.python.org/dev/library/unittest.html">https://docs.python.org/dev/library/unittest.html</a>
</li>

<li>Python namespaces<br />
<a href="https://bytebaker.com/2008/07/30/python-namespaces/">https://bytebaker.com/2008/07/30/python-namespaces/</a>
</li>

<li>Namespaces and Scopes<br />
<a href="https://www.python-course.eu/namespaces.php">https://www.python-course.eu/namespaces.php</a>
</li>

<li>Stránka projektu Robot Framework<br />
<a href="https://robotframework.org/">https://robotframework.org/</a>
</li>

<li>GitHub repositář Robot Frameworku<br />
<a href="https://github.com/robotframework/robotframework">https://github.com/robotframework/robotframework</a>
</li>

<li>Robot Framework (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Robot_Framework">https://en.wikipedia.org/wiki/Robot_Framework</a>
</li>

<li>Tutoriál Robot Frameworku<br />
<a href="http://www.robotframeworktutorial.com/">http://www.robotframeworktutorial.com/</a>
</li>

<li>Robot Framework Documentation<br />
<a href="https://robotframework.org/robotframework/">https://robotframework.org/robotframework/</a>
</li>

<li>Robot Framework Introduction<br />
<a href="https://blog.testproject.io/2016/11/22/robot-framework-introduction/">https://blog.testproject.io/2016/11/22/robot-framework-introduction/</a>
</li>

<li>robotframework 3.1.2 na PyPi<br />
<a href="https://pypi.org/project/robotframework/">https://pypi.org/project/robotframework/</a>
</li>

<li>Robot Framework demo (GitHub)<br />
<a href="https://github.com/robotframework/RobotDemo">https://github.com/robotframework/RobotDemo</a>
</li>

<li>Robot Framework web testing demo using SeleniumLibrary<br />
<a href="https://github.com/robotframework/WebDemo">https://github.com/robotframework/WebDemo</a>
</li>

<li>Robot Framework for Mobile Test Automation Demo<br />
<a href="https://www.youtube.com/watch?v=06LsU08slP8">https://www.youtube.com/watch?v=06LsU08slP8</a>
</li>

<li>Gherkin<br />
<a href="https://cucumber.io/docs/gherkin/">https://cucumber.io/docs/gherkin/</a>
</li>

<li>Selenium<br />
<a href="https://selenium.dev/">https://selenium.dev/</a>
</li>

<li>SeleniumLibrary<br />
<a href="https://robotframework.org/">https://robotframework.org/</a>
</li>

<li>The Practical Test Pyramid<br />
<a href="https://martinfowler.com/articles/practical-test-pyramid.html">https://martinfowler.com/articles/practical-test-pyramid.html</a>
</li>

<li>Acceptance Tests and the Testing Pyramid<br />
<a href="http://www.blog.acceptancetestdrivendevelopment.com/acceptance-tests-and-the-testing-pyramid/">http://www.blog.acceptancetestdrivendevelopment.com/acceptance-tests-and-the-testing-pyramid/</a>
</li>

<li>Tab-separated values<br />
<a href="https://en.wikipedia.org/wiki/Tab-separated_values">https://en.wikipedia.org/wiki/Tab-separated_values</a>
</li>

<li>A quick guide about Python implementations<br />
<a href="https://blog.rmotr.com/a-quick-guide-about-python-implementations-aa224109f321">https://blog.rmotr.com/a-quick-guide-about-python-implementations-aa224109f321</a>
</li>

<li>radamsa<br />
<a href="https://gitlab.com/akihe/radamsa">https://gitlab.com/akihe/radamsa</a>
</li>

<li>Fuzzing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Fuzzing">https://en.wikipedia.org/wiki/Fuzzing</a>
</li>

<li>american fuzzy lop<br />
<a href="http://lcamtuf.coredump.cx/afl/">http://lcamtuf.coredump.cx/afl/</a>
</li>

<li>Fuzzing: the new unit testing<br />
<a href="https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide#1">https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide#1</a>
</li>

<li>Corpus for github.com/dvyukov/go-fuzz examples<br />
<a href="https://github.com/dvyukov/go-fuzz-corpus">https://github.com/dvyukov/go-fuzz-corpus</a>
</li>

<li>AFL &ndash; QuickStartGuide.txt<br />
<a href="https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt">https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt</a>
</li>

<li>Introduction to Fuzzing in Python with AFL<br />
<a href="https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/">https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/</a>
</li>

<li>Writing a Simple Fuzzer in Python<br />
<a href="https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/">https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/</a>
</li>

<li>How to Fuzz Go Code with go-fuzz (Continuously)<br />
<a href="https://fuzzit.dev/2019/10/02/how-to-fuzz-go-code-with-go-fuzz-continuously/">https://fuzzit.dev/2019/10/02/how-to-fuzz-go-code-with-go-fuzz-continuously/</a>
</li>

<li>Golang Fuzzing: A go-fuzz Tutorial and Example<br />
<a href="http://networkbit.ch/golang-fuzzing/">http://networkbit.ch/golang-fuzzing/</a>
</li>

<li>Fuzzing Python Modules<br />
<a href="https://stackoverflow.com/questions/20749026/fuzzing-python-modules">https://stackoverflow.com/questions/20749026/fuzzing-python-modules</a>
</li>

<li>0x3 Python Tutorial: Fuzzer<br />
<a href="http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/">http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/</a>
</li>

<li>fuzzing na PyPi<br />
<a href="https://pypi.org/project/fuzzing/">https://pypi.org/project/fuzzing/</a>
</li>

<li>Fuzzing 0.3.2 documentation<br />
<a href="https://fuzzing.readthedocs.io/en/latest/">https://fuzzing.readthedocs.io/en/latest/</a>
</li>

<li>Randomized testing for Go<br />
<a href="https://github.com/dvyukov/go-fuzz">https://github.com/dvyukov/go-fuzz</a>
</li>

<li>HTTP/2 fuzzer written in Golang<br />
<a href="https://github.com/c0nrad/http2fuzz">https://github.com/c0nrad/http2fuzz</a>
</li>

<li>Ffuf (Fuzz Faster U Fool) – An Open Source Fast Web Fuzzing Tool<br />
<a href="https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html">https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html</a>
</li>

<li>Continuous Fuzzing Made Simple<br />
<a href="https://fuzzit.dev/">https://fuzzit.dev/</a>
</li>

<li>Halt and Catch Fire<br />
<a href="https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86">https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86</a>
</li>

<li>Random testing<br />
<a href="https://en.wikipedia.org/wiki/Random_testing">https://en.wikipedia.org/wiki/Random_testing</a>
</li>

<li>Monkey testing<br />
<a href="https://en.wikipedia.org/wiki/Monkey_testing">https://en.wikipedia.org/wiki/Monkey_testing</a>
</li>

<li>Fuzzing for Software Security Testing and Quality Assurance, Second Edition<br />
<a href="https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false">https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false</a>
</li>

<li>libFuzzer – a library for coverage-guided fuzz testing<br />
<a href="https://llvm.org/docs/LibFuzzer.html">https://llvm.org/docs/LibFuzzer.html</a>
</li>

<li>fuzzy-swagger na PyPi<br />
<a href="https://pypi.org/project/fuzzy-swagger/">https://pypi.org/project/fuzzy-swagger/</a>
</li>

<li>fuzzy-swagger na GitHubu<br />
<a href="https://github.com/namuan/fuzzy-swagger">https://github.com/namuan/fuzzy-swagger</a>
</li>

<li>Fuzz testing tools for Python<br />
<a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy#Fuzz_Testing_Tools">https://wiki.python.org/moin/PythonTestingToolsTaxonomy#Fuzz_Testing_Tools</a>
</li>

<li>A curated list of awesome Go frameworks, libraries and software<br />
<a href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go</a>
</li>

<li>gofuzz: a library for populating go objects with random values<br />
<a href="https://github.com/google/gofuzz">https://github.com/google/gofuzz</a>
</li>

<li>tavor: A generic fuzzing and delta-debugging framework<br />
<a href="https://github.com/zimmski/tavor">https://github.com/zimmski/tavor</a>
</li>

<li>hypothesis na GitHubu<br />
<a href="https://github.com/HypothesisWorks/hypothesis">https://github.com/HypothesisWorks/hypothesis</a>
</li>

<li>Hypothesis: Test faster, fix more<br />
<a href="https://hypothesis.works/">https://hypothesis.works/</a>
</li>

<li>Hypothesis<br />
<a href="https://hypothesis.works/articles/intro/">https://hypothesis.works/articles/intro/</a>
</li>

<li>What is Hypothesis?<br />
<a href="https://hypothesis.works/articles/what-is-hypothesis/">https://hypothesis.works/articles/what-is-hypothesis/</a>
</li>

<li>Databáze CVE<br />
<a href="https://www.cvedetails.com/">https://www.cvedetails.com/</a>
</li>

<li>Fuzz test Python modules with libFuzzer<br />
<a href="https://github.com/eerimoq/pyfuzzer">https://github.com/eerimoq/pyfuzzer</a>
</li>

<li>Taof - The art of fuzzing<br />
<a href="https://sourceforge.net/projects/taof/">https://sourceforge.net/projects/taof/</a>
</li>

<li>JQF + Zest: Coverage-guided semantic fuzzing for Java<br />
<a href="https://github.com/rohanpadhye/jqf">https://github.com/rohanpadhye/jqf</a>
</li>

<li>http2fuzz<br />
<a href="https://github.com/c0nrad/http2fuzz">https://github.com/c0nrad/http2fuzz</a>
</li>

<li>Demystifying hypothesis testing with simple Python examples<br />
<a href="https://towardsdatascience.com/demystifying-hypothesis-testing-with-simple-python-examples-4997ad3c5294">https://towardsdatascience.com/demystifying-hypothesis-testing-with-simple-python-examples-4997ad3c5294</a>
</li>

<li>Testování<br />
<a href="http://voho.eu/wiki/testovani/">http://voho.eu/wiki/testovani/</a>
</li>

<li>Unit testing (Wikipedia.en)<br />
<a href="https://en.wikipedia.org/wiki/Unit_testing">https://en.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit testing (Wikipedia.cz)<br />
<a href="https://cs.wikipedia.org/wiki/Unit_testing">https://cs.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit Test vs Integration Test<br />
<a href="https://www.youtube.com/watch?v=0GypdsJulKE">https://www.youtube.com/watch?v=0GypdsJulKE</a>
</li>

<li>TestDouble<br />
<a href="https://martinfowler.com/bliki/TestDouble.html">https://martinfowler.com/bliki/TestDouble.html</a>
</li>

<li>Test Double<br />
<a href="http://xunitpatterns.com/Test%20Double.html">http://xunitpatterns.com/Test%20Double.html</a>
</li>

<li>Test-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test-driven_development">https://en.wikipedia.org/wiki/Test-driven_development</a>
</li>

<li>Acceptance test–driven development<br />
<a href="https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development">https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development</a>
</li>

<li>Gauge<br />
<a href="https://gauge.org/">https://gauge.org/</a>
</li>

<li>Gauge (software)<br />
<a href="https://en.wikipedia.org/wiki/Gauge_(software)">https://en.wikipedia.org/wiki/Gauge_(software)</a>
</li>

<li>PYPL PopularitY of Programming Language<br />
<a href="https://pypl.github.io/PYPL.html">https://pypl.github.io/PYPL.html</a>
</li>

<li>Testing is Good. Pyramids are Bad. Ice Cream Cones are the Worst<br />
<a href="https://medium.com/@fistsOfReason/testing-is-good-pyramids-are-bad-ice-cream-cones-are-the-worst-ad94b9b2f05f">https://medium.com/@fistsOfReason/testing-is-good-pyramids-are-bad-ice-cream-cones-are-the-worst-ad94b9b2f05f</a>
</li>

<li>Články a zprávičky věnující se Pythonu<br />
<a href="https://www.root.cz/n/python/">https://www.root.cz/n/python/</a>
</li>

<li>PythonTestingToolsTaxonomy<br />
<a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy">https://wiki.python.org/moin/PythonTestingToolsTaxonomy</a>
</li>

<li>Top 6 BEST Python Testing Frameworks [Updated 2020 List]<br />
<a href="https://www.softwaretestinghelp.com/python-testing-frameworks/">https://www.softwaretestinghelp.com/python-testing-frameworks/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

