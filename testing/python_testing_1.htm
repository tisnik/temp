<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Již mnohokrát jsme se na stránkách Roota setkali s tematikou testů a testování aplikací na různých úrovních. Tato problematika je tak důležitá a užitečná, že si zaslouží vlastní seriál. V něm budou praktické příklady naprogramovány v Pythonu, ovšem uvedené postupy jsou univerzální.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. Různé podoby testovací pyramidy</a></p>
<p><a href="#k03">*** 3. Zmrzlinový kornout</a></p>
<p><a href="#k04">*** 4. Jednotkové testy &ndash; základ pyramidy, špička kornoutu</a></p>
<p><a href="#k05">*** 5. Testy komponent a integrační testy</a></p>
<p><a href="#k06">*** 6. Systémové testy, akceptační testy</a></p>
<p><a href="#k07">*** 7. Testy aplikačního (programového) rozhraní</a></p>
<p><a href="#k08">*** 8. Testy grafického uživatelského rozhraní</a></p>
<p><a href="#k09">*** 9. Testy chování (BDD)</a></p>
<p><a href="#k10">*** 10. Test-driven development (TDD)</a></p>
<p><a href="#k11">*** 11. Acceptance test–driven developmena (ATDD)</a></p>
<p><a href="#k12">*** 12. Použití knihovny unittest.mock (nejenom) při testování</a></p>
<p><a href="#k13">*** 13. Zdrojový soubor s&nbsp;funkcí, kterou budeme nahrazovat mock objektem</a></p>
<p><a href="#k14">*** 14. Test s&nbsp;volanou i mockovanou funkcí</a></p>
<p><a href="#k15">*** 15. Vytvoření handleru, který se zavolá namísto originální funkce</a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">*** 19. Předchozí články s&nbsp;tématem testování (nejenom) v&nbsp;Pythonu</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<p>Testování aplikací, do kterého se počítá jak tvorba testů, tak i nástroje a postupy pro jejich spouštění, v&nbsp;současnosti tvoří nedílnou součást vývoje aplikací a popř. i součást jejich akceptace zákazníkem. Jedná se o velmi rozsáhlou oblast IT, která se postupně vyvíjela a rozdělovala do několika podoblastí společně s&nbsp;tím, jak se měnil charakter vyvíjených aplikací i jejich celková složitost (dávkové úlohy, čistě desktopové aplikace s&nbsp;grafickým uživatelským rozhraním, webové aplikace a webové služby, cloud atd.). S&nbsp;problematikou testů a testování jsme se na stránkách <a href="https://www.root.cz">Roota</a> již několikrát setkali (viz odkazy uvedené <a href="#k19">v&nbsp;devatenácté kapitole</a>), ale možná bude užitečné se na testování podívat i z&nbsp;určitého odstupu &ndash; jaké typy testů se používají, proč se vlastně používají a jaké pomocné nástroje máme v&nbsp;dané oblasti k&nbsp;dispozici.</p>

<p>Samotný &ndash; dnes již samostatný &ndash; obor testování v&nbsp;IT se postupně vyvíjel a měnily se i jeho metodiky. U mnoha starších (z&nbsp;dnešního pohledu prastarých) projektů bylo testování prováděno jednorázově, a to na konci vývoje celého systému. Toto mnohdy manuální či jen poloautomatické testování bychom dnes nazvali <i>akceptačními testy</i>. Tento přístup již pro většinu rozsáhlejších projektů není ani praktický ani nejlevnější; dnes je totiž testování úzce svázáno s&nbsp;celým procesem vývoje nového systému a někdy celý vývoj začíná právě vytvořením prvotní sady testů. Důležitější je ovšem průběžné testování v&nbsp;čase vývoje a nasazování aplikace, což nám mj.&nbsp;dává přímou zpětnou vazbu o stavu vyvíjeného systému (pokud jsou pochopitelně testy napsány dobře). V&nbsp;dnes začínajícím (mini)seriálu si nejprve vysvětlíme základní termíny (ty ovšem nejsou plně ustáleny) a postupně budeme proházet &bdquo;testovací pyramidou&ldquo; od její základny až po vrchol.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto seriálu budeme primárně používat programovací jazyk <a href="">Python</a>, ovšem jednotlivé typy testů, jejich struktura atd. má svůj protějšek v&nbsp;dalších programovacích jazycích. Mezi přednosti Pythonu v&nbsp;této oblasti patří snadná tvorba <i>mocků</i> v&nbsp;jednotkových testech, <a href="https://github.com/vinta/awesome-python#testing">rozsáhlá sada nástrojů</a> pro tvorbu prakticky jakýkoli typů testů (včetně knihovny <a href="https://robotframework.org/">Robot Framework</a>, <a href="https://github.com/HypothesisWorks/hypothesis">Hypothesis</a> a rozhraní pro <a href="https://pypi.org/project/selenium/">Selenium</a>) a v&nbsp;neposlední řadě i relativně snadná dostupnost studijních materiálů.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Různé podoby testovací pyramidy</h2>

<p>V&nbsp;souvislosti s&nbsp;testy se poměrně často můžeme setkat s&nbsp;termínem &bdquo;testovací pyramida&ldquo;. O co se vlastně jedná? Jde o rozdělení jednotlivých typů testů do vrstev, přičemž vrstvy na spodních úrovních mají blíže k&nbsp;vlastnímu zdrojovému kódu, zatímco vrstvy na úrovních vyšších již od kódu (a mnohdy i od architektury aplikace) abstrahují. Má to pochopitelně svůj význam, protože jedna úroveň abstrakce nemůže v&nbsp;této oblasti vyhovovat. Zajímavé je, že se sice tento termín skutečně používá poměrně často, ale autoři si jednotlivé vrstvy (zejména ty prostřední) rozdělují různým způsobem. Ostatně se můžeme podívat na několik příkladů:</p>

<p>Většina autorů se shodne na tom, že testovací pyramida (ať již jsou její vrstvy blíže k&nbsp;vrcholku pojmenovány různě) tvoří velmi dobrý příklad toho, jak by testy reálné aplikace měly vypadat. Základem pyramidy jsou jednotkové testy a základna by pochopitelně měla být co nejširší. Předností jednotkových testů je jejich rychlé spouštění (může se testovat izolovaně pouze ona jednotka &ndash; třída, funkce atd.), stabilita a poměrně snadné a rychlé úpravy. Směrem k&nbsp;vrcholku pyramidy se vrstvy pochopitelně zužují, což v&nbsp;překladu znamená, že by se testům na těchto úrovních mohla (relativně!) věnovat menší pozornost. Testy blíže k&nbsp;vrcholu pyramidy jsou &bdquo;dražší&ldquo;, a to jak z&nbsp;hlediska investovaného pracovního času (extrémem jsou manuální testy), tak i času strojového (je nutné sestavit celou aplikaci i se všemi souvisejícími službami atd.).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zmrzlinový kornout</h2>

<p>V&nbsp;souvislosti s&nbsp;prioritami, které se mají věnovat jednotlivým typům testů, se někdy setkáme i s&nbsp;termínem &bdquo;zmrzlinový kornout&ldquo;, což je struktura připomínající otočenou pyramidu. V&nbsp;této struktuře se málo času/energie/peněz věnuje jednotkovým testům a testům komponent, o to více času (alespoň relativně) se pak věnuje například testům grafického uživatelského rozhraní nebo dokonce manuálním testům. Takto nastavené priority při tvorbě testů jsou považovány za <i>antipattern</i>, ovšem i s&nbsp;takovým postupem (popř.&nbsp;nějakou jeho variantou) se můžeme v&nbsp;praxi setkat.</p>

<p><div class="rs-tip-major">Poznámka: ovšem jak již bylo patrné při představování různých variant testovací pyramidy, je nesnadné až nemožné (a hlavně mnohdy nepraktické) pracovat na všech úrovních testů. Mnohdy si velmi dobře vystačíme například pouze se třemi úrovněmi (jednotkové testy, integrační testy, testy UI) &ndash; to ovšem záleží na tom, o jakou aplikaci se jedná. Jiné požadavky budou na utilitu spouštěnou z&nbsp;příkazové řádky v&nbsp;porovnání s&nbsp;desktopovou aplikací s&nbsp;plnohodnotným GUI popř.&nbsp;dokonce s&nbsp;webovou aplikací založenou na využití <a href="https://www.root.cz/serialy/mikrosluzby/">mikroslužeb</a>.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Jednotkové testy &ndash; základ pyramidy, špička kornoutu</h2>

<p>první fáze, na úrovni balíčků, tříd, objektů, metod a funkcí</p>

rizika= corner case (nepokryté testem ani v kódu)
velké množství procházejících testů nemusí nic znamenat
změna architektury aplikace
fake vraci jednu hodnotu
stub logika
spy parametry, stav
mock



<p><a name="k05"></a></p>
<h2 id="k05">5. Testy komponent a integrační testy</h2>

<p><div class="rs-tip-major">Poznámka: </div></p>

<p>Ovšem jak jsme již mohli vidět <a href="#k02">ve druhé kapitole</a>, tvoří jednotkové testy jen jedinou vrstvu (základnu) takzvané &bdquo;testovací pyramidy&ldquo;. Nad nimi se v&nbsp;dalších vrstvách nachází testy komponent, funkční testy, integrační testy, různé formy benchmarků, BDD testy, testy grafického uživatelské rozhraní, manuálně prováděné testy atd.</p>
sestavení do funkčního celku

integrační testy vnitří a vnější integrace, komunikace mezi jednotlivými moduly, z&nbsp;nichž se aplikace skládá
podobně jako u jednotkových testů se používají mock objekty lze u integračních tetsů používat fake moduly. Poměrně názorným příkladem fake modulu je databáze uložená v&nbsp;paměti, která pro účely testů nahrazuje reálnou databázi (v&nbsp;paměti lze provozovat například SQLite). Kromě fake modulů se používají mock moduly, které pouze odpovídají na přesně známé vstupy známými výstupy (naproti tomu fake moduly jsou do určité míry skutečnými moduly, pouze ne zcela připravenými pro produkční použití). Taktéž se zde setkáme s&nbsp;takzvanými špiony (spies), což jsou moduly zaznamenávající všechny požadavky přicházející z&nbsp;jiných modulů.


<p><a name="k06"></a></p>
<h2 id="k06">6. Systémové testy, akceptační testy</h2>

rozděleno do více podkategorií
smoke testy


systémové testy
O něco výše v&nbsp;hierarchii se nachází systémové testy, jejichž primárním účelem je ověření, jestli aplikace (služba) sestavená do jednoho celku pracuje korektně. Tyto testy se zaměřují jak na zjištění, zda pro určité vstupy aplikace produkuje určitý výstup (například objedná letenku), ale i to, jak reaguje na nestandardní situace, špatně zadané vstupy apod.

<p></p>

<pre>
| *** Settings ***   |                  |   |
| Library            | Test16.py        |   |
|                    |                  |   |
| *** Test Cases *** |                  |   |
| Adder #1           |                  |   |
|                    | Add              | 1 | 2
|                    | Result should be | 3 |
|                    |                  |   |
| Adder #2           |                  |   |
|                    | Add              | 0 | 0
|                    | Result should be | 0 |
|                    |                  |   |
| Adder #3           |                  |   |
|                    | Add              | 1 | -1
|                    | Result should be | 0 |
</pre>

<p>Alternativně:</p>

<pre>
| *** Settings ***   |                  |   |
| Library            | Test16.py        |   |
&nbsp;
| *** Test Cases *** |                  |   |
| Adder #1           |                  |   |
|                    | Add              | 1 | 2
|                    | Result should be | 3 |
|                    | Add              | 2 | 3
|                    | Result should be | 5 |
|                    | Add              | 4 | 5
|                    | Result should be | 9 |
&nbsp;
| Adder #2           |                  |   |
|                    | Add              | 0 | 0
|                    | Result should be | 0 |
&nbsp;
| Adder #3           |                  |   |
|                    | Add              | 1 | -1
|                    | Result should be | 0 |
</pre>

<pre>
| *** Settings ***   |                             |             |             |
| Library            | Accumulator6.py             |             |             |
| Test template      | Accumulate                  |             |             |
| Test setup         | Setup method                | 0           |             |
| Test teardown      | Teardown method             |             |             |
|                    |                             |             |             |
| *** Test Cases *** | Value                       | Expected    |             |
| Test1              | 0                           | 0           |             |
|                    | 1                           | 1           |             |
|                    | 10                          | 11          |             |
|                    | -10                         | 1           |             |
|                    | 1                           | 2           |             |
|                    | 1                           | 3           |             |
|                    |                             |             |             |
| *** Keywords ***   |                             |             |             |
| Accumulate         |                             |             |             |
|                    | [Arguments]                 | ${value}    | ${expected} |
|                    | Add value                   | ${value}    |             |
|                    | Accumulator value should be | ${expected} |             |
</pre>

<p><div class="rs-tip-major">Poznámka: pokud se s&nbsp;využitím Robot Frameworku tvoří akceptační testy, tak může být právě tabulková forma vhodná, protože se vlastně jedná o úřední dokument mnohdy zpracovávaný lidmi, kteří mají tabulky v&nbsp;oblibě :-)</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Testy aplikačního (programového) rozhraní</h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. Testy grafického uživatelského rozhraní</h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. Testy chování (BDD)</h2>

kombinace TDD and from ATDD

<p>Ve dvou článcích [<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">1</a>] [<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">2</a>] o programovacím jazyku Clojure jsme se věnovali dnes poměrně populárnímu tématu: popisu integrace doménově specifického jazyka <i>Gherkin</i> určeného pro popis testovacích scénářů přímo v&nbsp;programovacím jazyku Clojure. Ve skutečnosti ovšem není <i>Gherkin</i> v&nbsp;žádném případě určen pouze pro použití společně s&nbsp;Clojure, ale jedná se o <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a> integrovatelný i do mnoha dalších programovacích jazyků. Dnes si ve stručnosti představíme knihovnu <a href="https://pypi.python.org/pypi/behave">Behave</a>, s&nbsp;jejíž pomocí se Gherkin integruje do jazyka Python. Ve skutečnosti se bude jednat o téměř ideální spojení, protože Gherkin i Python používají podobný způsob zápisu, v&nbsp;němž i odsazení jednotlivých programových řádků je součástí syntaxe (naproti tomu se Gherkin a Clojure ze syntaktického hlediska zcela odlišují).</p>

<p>Jazyk Gherkin je navržen takovým způsobem, aby ho uživatelé (nemusí se totiž nutně jednat pouze o programátory) mohli začít používat prakticky okamžitě, tj.&nbsp;bez nutnosti studia sáhodlouhých manuálů.</p> Tento doménově specifický jazyk odstiňuje autora testů od vlastní implementace systému i od programovacího jazyka (či jazyků), v&nbsp;nichž je systém vytvořen. Ostatně v&nbsp;Gherkinu lze popsat očekávané chování prakticky jakéhokoli systému, který dokonce nemusí mít nic společného s&nbsp;IT.

<a href="https://www.root.cz/obrazek/324266/"><img src="https://i.iinfo.cz/images/634/clojure-cucumber-1-prev.png" class="image-324266" alt="&#160;" width="370" height="198" /></a>
<p><i>Obrázek 1: Ukázka scénářů napsaných v&nbsp;doménově specifickém jazyce
Gherkin.</i></p>

<p>Na předchozím screenshotu jsou zvýrazněna klíčová slova uvozující jednotlivé kroky testu. Ostatní slova a číslice ve větách jsou buď pevně daná (svázaná s&nbsp;konkrétním krokem), nebo se jedná o proměnné. Ve scénáři je i tabulka, jejíž obsah se řádek po řádku postupně stává obsahem jednotlivých kroků testu (obsahem tabulky se nahrazují slova umístěná do ostrých závorek).</p>

<p><div class="rs-tip-major">Poznámka: doménově specifický jazyk Gherkin existuje v&nbsp;různých jazykových mutacích, my se však budeme držet jeho originální anglické varianty.  Ostatně mnoho knihoven, které Gherkin podporují, pracuje pouze s&nbsp;anglickou variantou.</div></p>

<p>Druhým důležitým souborem je vlastní testovací scénář nazvaný <strong>adder.feature</strong>, který je uložen v&nbsp;podadresáři <strong>features</strong>. Tento testovací scénář je naprogramován v&nbsp;jazyku <i>Gherkin</i>, konkrétně v&nbsp;jeho výchozí anglické &bdquo;mutaci&ldquo; (použitím jiných jazykových mutací se budeme zabývat příště). V&nbsp;následujícím výpisu jsou klíčová slova rozeznávaná interpretrem označena tučně:</p>

<pre>
<strong>Feature</strong>: Adder test
&nbsp;
  <strong>Scenario</strong>: Check the function add()
    <strong>Given</strong> The function add is callable
    <strong>When</strong> I call function add with arguments 1 and 2
    <strong>Then</strong> I should get 3 as a result
</pre>

<p><div class="rs-tip-major">Povšimněte si, že Gherkin je z&nbsp;hlediska sémantiky velmi jednoduchý jazyk. Obsahuje deklarace jednotlivých testovacích scénářů, počáteční podmínku a potom sérii kroků ve stylu &bdquo;když udělám X, stane se (očekávám) Y&ldquo;. Syntax je také jednoduchá (alespoň prozatím), protože první slovo je klíčové a jednotlivé bloky (zde scénáře) jsou odsazeny, podobně jako v&nbsp;samotném Pythonu či ve formátu YAML.</div></p>

<pre>
*** Settings ***
Library             Accumulator6.py
Test setup          Setup method  0
Test teardown       Teardown method
Test template       Accumulator operation
&nbsp;
*** Keywords ***
Accumulator operation
                    [Arguments]  ${value}  ${expected}
                    Given accumulator has been zeroed
                    When I add ${value} to accumulator
                    Then the accumulated value Should Be ${expected}
&nbsp;
*** Test Cases ***     Value  Expected
Accumulator operation  1      1
Accumulator operation  10     10
&nbsp;
&nbsp;
&nbsp;
*** Keywords ***
Accumulator has been zeroed
    log  accumulator init
&nbsp;
I add ${value} to accumulator
    Add value  ${value}
&nbsp;
Then the accumulated value should be ${expected}
    Accumulator value should be  ${expected}
</pre>


<p><a name="k10"></a></p>
<h2 id="k10">10. Test-driven development (TDD)</h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. Acceptance test–driven developmena (ATDD)</h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. Použití knihovny unittest.mock (nejenom) při testování</h2>

<p>Při testování aplikací, zejména při psaní jednotkových testů (což je základ testovací pyramidy), se poměrně často dostaneme do situace, kdy potřebujeme nahradit nějakou funkci, metodu nebo dokonce celou třídu používanou v&nbsp;reálné aplikaci za &bdquo;falešnou&ldquo; funkci/metodu/třídu vytvořenou pouze pro účely jednotkových testů. V&nbsp;programovacím jazyku Python je možné pro tvorbu a použití takových &bdquo;falešných&ldquo; bloků kódu použít hned několik různých knihoven, které se od sebe odlišují jak svými možnostmi, tak i způsobem zápisu či deklarace očekávaného chování testované aplikace. Určitým standardem v&nbsp;této oblasti je v&nbsp;současnosti knihovna <i>unittest.mock</i>. Dnes si ukážeme některé základní techniky, které nám tato knihovna poskytuje.</p>

<p>S&nbsp;následující situací se již setkal pravděpodobně každý vývojář vytvářející jednotkové testy &ndash; je nutné otestovat funkcionalitu části aplikace, v&nbsp;této části se však volá nějaká funkce nebo metoda provádějící potenciálně destruktivní činnost (změna filesystému, vzdálené volání procedur, programování zařízení připojeného přes USB atd.). Popř.&nbsp;se volá funkce/metoda, která v&nbsp;závislosti na různých okolnostech vrací (minimálně z&nbsp;pohledu testů) pseudonáhodná data. Takovou funkci/metodu by bylo vhodné pro účely testování nahradit jednodušším kódem, jenž bude provádět předem známou činnost, například bude za každých okolností pouze vracet určitou hodnotu. Taková náhrada skutečných funkcí či metod za funkce/metody &bdquo;falešné&ldquo; se (poněkud nepřesně) nazývá &bdquo;mockování&ldquo; (<i>mocking</i>), a příslušný náhradní kód pak <i>test double</i>, popř.&nbsp;podle funkce <i>fake</i>, <i>stub</i>, <i>spy</i> nebo <i>mock</i>. V&nbsp;druhé části dnešního článku si ukážeme, jakým způsobem se může tato technika použít v&nbsp;Pythonu, konkrétně v&nbsp;Pythonu řady 3.x:</p>

<p>V&nbsp;současnosti existuje relativně velké množství různých knihoven, které mockování v&nbsp;Pythonu umožňují. Z&nbsp;nich jmenujme například velmi zajímavý projekt <i>Flexmock</i>, který naleznete na adrese <a href="https://pypi.python.org/pypi/flexmock">https://pypi.python.org/pypi/flexmock</a>. Ovšem v&nbsp;Pythonu 3.x se standardem v&nbsp;této oblasti stala knihovna nazvaná <a href="https://docs.python.org/dev/library/unittest.mock.html">unittest.mock</a>. V&nbsp;případě, že ještě z&nbsp;nějakého důvodu musíte používat Python 2.x, použijte namísto knihovny <i>unittest.mock</i> knihovnu nazvanou jednoduše <a href="https://pypi.python.org/pypi/mock">mock</a>. Tato knihovna nabízí prakticky stejné možnosti jako <i>unittest.mock</i> (je ostatně založena na stejném kódu, který pouze byl pro potřeby Pythonu 2.x upraven), ovšem lze ji použít jak v&nbsp;Pythonu 2.x, tak i v&nbsp;Pythonu 3.x, a to bez toho, abyste museli upravovat zdrojové kódy vašich testů (samozřejmě za předpokladu, že se v&nbsp;nich nevyskytují konstrukce, které nejsou v&nbsp;Pythonu 2.x podporovány).</p>

<p>Zmíněný falešný blok kódu je možné podle jeho vlastností rozdělit do několika kategorií:</p>

<ol>

<li><i>fake</i> &ndash; vrací jedinou programátorem zvolenou hodnotu. Příkladem může být funkce nahrazující čtení z&nbsp;databáze, která vždy vrátí jediný záznam.</li>

<li><i>stub</i> &ndash; již obsahuje jednoduchou logiku, například dokáže reagovat na špatný vstup podobně, jako nahrazovaný blok.</li>

<li><i>spy</i> &ndash; dokáže zaznamenat předávané parametry či dokonce celý stav (nebo podstav) aplikace.</li>

<li><i>mock</i> &ndash; mnohdy se jedná o blok s&nbsp;vlastnostmi, které se přibližují reálnému (nahrazovanému) kódu. Vylepšená verze <i>stub</i>.</li>

</ol>

<p><div class="rs-tip-major">Poznámka: samotná knihovna <i>unittest.mock</i> je obecná, takže mezi výše zmíněnými kategoriemi nijak nerozlišuje (a mnozí programátoři také ne). I my budeme při popisech možností této knihovny mluvit o &bdquo;mock objektech&ldquo;, ale až na základě jejich konkrétní implementace se rozliší, zda se jedná o blok vracející jednu hodnotu, zda bude obsahovat nějakou logiku, logování parametrů/stavů atd.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zdrojový soubor s&nbsp;funkcí, kterou budeme nahrazovat mock objektem</h2>

<p>Popis možností knihovny <strong>unittest.mock</strong> začneme na tom nejjednodušším možném příkladu. Bude se jednat o aplikaci (či spíše minimalistickou &bdquo;aplikaci&ldquo;) tvořenou pouhými dvěma zdrojovými soubory <a href="">application.py</a> a <a href="">main.py</a>. První zmíněný soubor obsahuje jedinou funkci pojmenovanou <strong>function1</strong>, která po svém zavolání nejprve vypíše na standardní výstup text &bdquo;function1 called&ldquo; a následně vrátí do volajícího kódu řetězec s&nbsp;obsahem &bdquo;tested function&ldquo;, jenž může být v&nbsp;případě potřeby dále zpracován. Celý soubor se zdrojovým kódem má tedy pouze několik řádků (funkce je volána ze skriptu <strong>main.py</strong>):</p>

<pre>
<i>"""Implementace logiky aplikace, kterou budeme testovat."""</i>
&nbsp;
&nbsp;
def <strong>function1</strong>():
    <i>"""Funkce, kterou v testech nahradíme mockem."""</i>
    print("function1 called")
    return "tested function"
</pre>

<p>Zavolání této aplikace je snadné a provede se přes skript <strong>main.py</strong>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
&nbsp;
<i>"""Vstupní bod do testované aplikace."""</i>
&nbsp;
from application import *
&nbsp;
&nbsp;
if __name__ == '__main__':
    <i># pouze zavoláme funkci, která se bude v testech mockovat</i>
    print(function1())
</pre>

<p>Následovně:</p>

<pre>
$ <strong>python3 main.py</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se o zcela umělý příklad, který má jen jedinou přednost &ndash; je skutečně minimalistický, takže ukázka možností knihovny <strong>unit.mock</strong> pravděpodobně bude poměrně názorná.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Test s&nbsp;volanou i mockovanou funkcí</h2>

<p>Nyní se podívejme na to, jakým způsobem se může funkce <strong>function1</strong> volat v&nbsp;jednotkových testech. Pro jednoduchost prozatím nepoužijeme žádný framework určený pro psaní jednotkových testů (to bude téma pro samostatný článek), ale vytvoříme si jednoduchý pomocný soubor nazvaný <a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test1/test.py">test.py</a>, v&nbsp;němž se pokusíme zavolat jak původní funkci, tak i její tzv.&nbsp;<i>mock</i> (&bdquo;falešnou&ldquo; variantu původní funkce). Na začátku je nutné provést import modulu <strong>unittest.mock</strong> a samozřejmě taktéž import testovaného modulu <strong>application</strong>:</p>

<pre>
from unittest.mock import *
&nbsp;
import application
</pre>

<p>První pseudotest bude jednoduchý &ndash; pouze v&nbsp;něm zavoláme původní funkci a vypíšeme hodnotu, kterou tato funkce vrátí volajícímu kódu (zde se žádné mockování neprování):</p>

<pre>
def <strong>test1</strong>():
    print(application.function1())
</pre>

<p>Druhý pseudotest je již mnohem zajímavější, protože v&nbsp;něm namísto původní funkce <strong>function1</strong> z&nbsp;modulu <strong>application</strong> použijeme mock. Deklarace testovací funkce je doplněna o anotaci <strong>@patch</strong>, v&nbsp;níž specifikujeme jméno mockované funkce (ve formě řetězce, jehož obsah je kontrolován) a současně i návratovou hodnotu. To je nutné, protože se původní funkce ve skutečnosti vůbec nezavolá, ale návratovou hodnotu použijeme ve funkci <strong>print</strong>:</p>

<pre>
@patch('application.function1', return_value=42)
def <strong>test2</strong>(mocked_function_object):
    print(application.function1())
</pre>

<p>Povšimněte si, že jméno mockované funkce je zapsáno i s&nbsp;uvedením jmenného prostoru (&bdquo;application.function1&ldquo;), který ovšem musí odpovídat kontextu, v&nbsp;němž se funkce volá! Právě uvedení správného kontextu je pravděpodobně nejdůležitější část, kterou je nutné při mockování pochopit (více viz navazující kapitoly). Navíc stojí za povšimnutí, že se testovací funkci <strong>test2</strong> předává parametr <strong>mocked_function_object</strong>, který představuje objekt udržující informace o mocku. Tento objekt využijeme v&nbsp;dalších demonstračních příkladech, nyní je však nutné si uvědomit, že se tento parametr plní automaticky (při volání <strong>test2</strong> ho explicitně nebudeme uvádět).</p>

<p>Nyní již můžeme skript doplnit o kód, který všechny testy spustí. Povšimněte si, že první test naschvál spouštíme dvakrát (na začátku a na konci), aby bylo patrné, že mockovaná funkce se volá pouze v&nbsp;testu <strong>test2</strong> (mockování je v&nbsp;tomto případě přísně lokální):</p>

<pre>
if __name__ == '__main__':
    test1()
    print()
&nbsp;
    test2()
    print()
&nbsp;
    test1()
    print()
</pre>

<p>Výsledek vypsaný po provedení skriptu potvrzuje, že při každém spuštění testu <strong>test1</strong> se zavolá původní funkce, kdežto při spuštění testu <strong>test2</strong> funkce mockovaná:</p>

<pre>
$ <strong>python3 test.py</strong>
&nbsp;
function1 called
tested function
&nbsp;
42
&nbsp;
function1 called
tested function
</pre>

<p><div class="rs-tip-major">Poznámka: náš mock pouze vrací hodnotu a nesnaží se žádným způsobem napodobit logiku funkce (tedy výpis zprávy na standardní výstup). Jedná se tedy o <i>fake double</i>.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Vytvoření handleru, který se zavolá namísto originální funkce</h2>

<p>Prozatím jsme se dozvěděli, jakým způsobem je možné nahradit volání skutečné funkce vrácením nějaké předem nastavené hodnoty. Tato hodnota sice může být prakticky jakákoli (číslo, pravdivostní hodnota, řetězec, pole, n-tice, slovník, objekt, klidně i <strong>None</strong>), ovšem někdy si s&nbsp;tímto chováním nevystačíme a budeme potřebovat, aby se namísto původní funkce zavolala funkce odlišná; typicky mnohem jednodušší, s&nbsp;předvídatelnějšími výsledky atd. Příkladem může být &bdquo;falešná&ldquo; funkce nahrazující čtení záznamů z&nbsp;databáze za výběr hodnoty z&nbsp;předem známé datové struktury. S&nbsp;využitím knihovny <strong>unittest.mock</strong> je nahrazení původní funkce za její (ne)plnohodnotný mock snadné. Nejprve tuto funkci deklarujeme (měla by akceptovat stejné parametry, jako funkce původní) a následně použijeme v&nbsp;anotaci <strong>@patch</strong> nepovinný parametr <strong>side_effect</strong>, kterému předáme referenci na mock:</p>

<pre>
def side_effect_handler():
    print("side_effect function called")
    return -1


@patch('application.function1', side_effect=side_effect_handler)
def test3(mocked_function_object):
    print(application.function1())
</pre>

<p>Pokud spustíme třetí test představovaný výše vypsanou funkcí <strong>test3</strong> (a to opět BEZ parametrů):</p>

<pre>
test3()
</pre>

<p>zavolá se z&nbsp;něj ve skutečnosti funkce <strong>side_effect_handler</strong> a nikoli <strong>application.function1</strong>:</p>

<pre>
side_effect function called
-1
</pre>

<p><div class="rs-tip-major">Poznámka: takto vytvořený mock je opět použit jen lokálně v&nbsp;rámci testu představovaného funkcí <strong>test3</strong></div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Kombinace handleru s&nbsp;předkonfigurovanou návratovou hodnotou?</h2>

<p>Podívejme se ještě, co se stane ve chvíli, kdy v&nbsp;anotaci <strong>@patch</strong> současně použijeme parametr <strong>return_value</strong> i <strong>side_effect</strong>. Zápis bude vypadat následovně:</p>

<pre>
def side_effect_handler():
    print("side_effect function called")
    return -1

@patch('application.function1', return_value=42, side_effect=side_effect_handler)
def test4(mocked_function_object):
    print(application.function1())
</pre>

<p>Pokud zavoláme výše vypsanou testovací funkci <strong>test4</strong>, vypíšou se na standardní výstup následující dva řádky, z&nbsp;nichž je patrné, že se hodnota specifikovaná parametrem <strong>return_value</strong> ignorovala a namísto ní se použila návratová hodnota &bdquo;falešné&ldquo; funkce <strong>side_effect_handler</strong>:</p>

<pre>
side_effect function called
-1
</pre>

<p>Toto chování se ale změní ve chvíli, kdy mock vrátí speciální hodnotu <strong>unittest.mock.DEFAULT</strong> (přesněji řečeno <strong>sentinel.DEFAULT</strong>). V&nbsp;takovém případě se skutečně využije hodnota zapsaná v&nbsp;parametru <strong>return_value</strong> v&nbsp;anotaci <strong>@patch</strong>, o čemž se lze velmi snadno přesvědčit:</p>

<pre>
def side_effect_handler_2():
    print("side_effect function called")
    return DEFAULT


@patch('application.function1', return_value=42, side_effect=side_effect_handler_2)
def test5(mocked_function_object):
    print(application.function1())
</pre>

<p>Výsledek zavolání výše vypsané testovací funkce <strong>test5</strong>:</p>

<pre>
side_effect function called
42
</pre>

<p>Díky tomuto chování je možné použít &bdquo;falešnou&ldquo; funkci ve větším množství testů, což je téma, kterým se budeme podrobněji zabývat příště.</p>

<p>Pro přehlednost je v&nbsp;této kapitole vypsán úplný zdrojový kód dnešního <a href=""></a> rozděleného do dvou modulů.</p>

<h3>Soubor <strong>application.py</strong> s&nbsp;testovanou funkcí</h3>

<pre>
"""Implementace logiky aplikace, kterou budeme testovat."""


def function1():
    """Funkce, kterou v testech nahradíme mockem."""
    print("function1 called")
    return "tested function"
</pre>

<h3>Soubor <strong>test.py</strong> s&nbsp;testy</h3>

<pre>
"""Implementace (umělých) jednotkových testů."""

from unittest.mock import *

import application


def test1():
    """První test neprovádí prakticky žádné reálné kontroly, jen zavolá testovanou funkci."""
    print(application.function1())


@patch('application.function1', return_value=42)
def test2(mocked_function):
    """Druhý test používá fake test double - náhradu volané funkce."""
    print(application.function1())


def side_effect_handler():
    """Implementace handleru - stub funkce nahrazované mockem."""
    print("side_effect function called")
    return -1


@patch('application.function1', side_effect=side_effect_handler)
def test3(mocked_function):
    """Druhý test používá stub test double - náhradu volané funkce."""
    print(application.function1())


@patch('application.function1', return_value=42, side_effect=side_effect_handler)
def test4(mocked_function):
    """Čtvrtý test se snaží zkombinovat fake a stub."""
    print(application.function1())


def side_effect_handler_2():
    """Implementace handleru - stub funkce nahrazované mockem, který ovšem ovlivňuje chování testu."""
    print("side_effect function called")
    return DEFAULT


@patch('application.function1', return_value=42, side_effect=side_effect_handler_2)
def test5(mocked_function):
    """Čtvrtý test se opět snaží zkombinovat fake a stub."""
    print(application.function1())


if __name__ == '__main__':
    print("*** test1 ***")
    test1()
    print()

    print("*** test2 ***")
    test2()
    print()

    print("*** test3 ***")
    test3()
    print()

    print("*** test4 ***")
    test4()
    print()

    print("*** test5 ***")
    test5()
    print()

    print("*** test1 ***")
    test1()
    print()
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
nového Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/testing-in-python">https://github.com/tisnik/testing-in-python</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem &ndash;
alespoň prozatím &ndash; velmi malý, dnes má přibližně deseti kilobajtů),
můžete namísto toho použít odkazy na jednotlivé demonstrační příklady a jejich
části, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td></td><td></td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/">https://github.com/tisnik/testing-in-python/blob/master/</a></td></tr>
<tr><td> 2</td><td></td><td></td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/">https://github.com/tisnik/testing-in-python/blob/master/</a></td></tr>
<tr><td> 3</td><td></td><td></td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/">https://github.com/tisnik/testing-in-python/blob/master/</a></td></tr>
<tr><td> 4</td><td></td><td></td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/">https://github.com/tisnik/testing-in-python/blob/master/</a></td></tr>
<tr><td> 5</td><td></td><td></td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/">https://github.com/tisnik/testing-in-python/blob/master/</a></td></tr>
<tr><td> 6</td><td></td><td></td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/">https://github.com/tisnik/testing-in-python/blob/master/</a></td></tr>
<tr><td> 7</td><td></td><td></td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/">https://github.com/tisnik/testing-in-python/blob/master/</a></td></tr>
<tr><td> 8</td><td></td><td></td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/">https://github.com/tisnik/testing-in-python/blob/master/</a></td></tr>
<tr><td> 9</td><td></td><td></td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/">https://github.com/tisnik/testing-in-python/blob/master/</a></td></tr>
<tr><td>10</td><td></td><td></td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/">https://github.com/tisnik/testing-in-python/blob/master/</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články s&nbsp;tématem testování (nejenom) v&nbsp;Pythonu</h2>

<p>Tématem testování jsme se již na stránkách Rootu několikrát zabývali. Jedná se mj.&nbsp;o následující články:</p>

<ol>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave (druhá část)<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-druha-cast/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-druha-cast/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave (závěrečná část)<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-zaverecna-cast/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-zaverecna-cast/</a>
</li>

<li>Validace datových struktur v Pythonu pomocí knihoven Schemagic a Schema<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/</a>
</li>

<li>Validace datových struktur v Pythonu (2. část)<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-2-cast/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-2-cast/</a>
</li>

<li>Validace datových struktur v Pythonu (dokončení)<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-dokonceni/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-dokonceni/</a>
</li>

<li>Univerzální testovací nástroj Robot Framework<br />
<a href="https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework/">https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework/</a>
</li>

<li>Univerzální testovací nástroj Robot Framework a BDD testy<br />
<a href="https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework-a-bdd-testy/">https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework-a-bdd-testy/</a>
</li>

<li>Úvod do problematiky fuzzingu a fuzz testování<br />
<a href="https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani/">https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani/</a>
</li>

<li>Úvod do problematiky fuzzingu a fuzz testování – složení vlastního fuzzeru<br />
<a href="https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani-slozeni-vlastniho-fuzzeru/">https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani-slozeni-vlastniho-fuzzeru/</a>
</li>

<li>Knihovny a moduly usnadňující testování aplikací naprogramovaných v jazyce Clojure<br />
<a href="https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/">https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/</a>
</li>

<li>Validace dat s využitím knihovny spec v Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

<li>Testování aplikací naprogramovaných v jazyce Go<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/">https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/</a>
</li>

<li>Knihovny určené pro tvorbu testů v programovacím jazyce Go<br />
<a href="https://www.root.cz/clanky/knihovny-urcene-pro-tvorbu-testu-v-programovacim-jazyce-go/">https://www.root.cz/clanky/knihovny-urcene-pro-tvorbu-testu-v-programovacim-jazyce-go/</a>
</li>

<li>Testování aplikací psaných v Go s využitím knihoven Goblin a Frisby<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/">https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/</a>
</li>

<li>Testování Go aplikací s využitím knihovny GΩmega a frameworku Ginkgo<br />
<a href="https://www.root.cz/clanky/testovani-go-aplikaci-s-vyuzitim-knihovny-gomega-mega-a-frameworku-ginkgo/">https://www.root.cz/clanky/testovani-go-aplikaci-s-vyuzitim-knihovny-gomega-mega-a-frameworku-ginkgo/</a>
</li>

<li>Tvorba BDD testů s využitím jazyka Go a nástroje godog<br />
<a href="https://www.root.cz/clanky/tvorba-bdd-testu-s-vyuzitim-jazyka-go-a-nastroje-godog/">https://www.root.cz/clanky/tvorba-bdd-testu-s-vyuzitim-jazyka-go-a-nastroje-godog/</a>
</li>

<li>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem<br />
<a href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/">https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/</a>
</li>

<li>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem (dokončení)<br />
<a href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem-dokonceni/">https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem-dokonceni/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure (2)<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Awesome Python &ndash; testing<br />
<a href="https://github.com/vinta/awesome-python#testing">https://github.com/vinta/awesome-python#testing</a>
</li>

<li>Selenium (pro Python)<br />
<a href="https://pypi.org/project/selenium/">https://pypi.org/project/selenium/</a>
</li>

<li>Getting Started With Testing in Python<br />
<a href="https://realpython.com/python-testing/">https://realpython.com/python-testing/</a>
</li>

<li>unittest.mock — mock object library<br />
<a href="https://docs.python.org/3.5/library/unittest.mock.html">https://docs.python.org/3.5/library/unittest.mock.html</a>
</li>

<li>mock 2.0.0<br />
<a href="https://pypi.python.org/pypi/mock">https://pypi.python.org/pypi/mock</a>
</li>

<li>An Introduction to Mocking in Python<br />
<a href="https://www.toptal.com/python/an-introduction-to-mocking-in-python">https://www.toptal.com/python/an-introduction-to-mocking-in-python</a>
</li>

<li>Mock - Mocking and Testing Library<br />
<a href="http://mock.readthedocs.io/en/stable/">http://mock.readthedocs.io/en/stable/</a>
</li>

<li>Python Mocking 101: Fake It Before You Make It<br />
<a href="https://blog.fugue.co/2016-02-11-python-mocking-101.html">https://blog.fugue.co/2016-02-11-python-mocking-101.html</a>
</li>

<li>Nauč se Python! - Testování<br />
<a href="http://naucse.python.cz/lessons/intro/testing/">http://naucse.python.cz/lessons/intro/testing/</a>
</li>

<li>Flexmock (dokumentace)<br />
<a href="https://flexmock.readthedocs.io/en/latest/">https://flexmock.readthedocs.io/en/latest/</a>
</li>

<li>Test Fixture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test_fixture">https://en.wikipedia.org/wiki/Test_fixture</a>
</li>

<li>Mock object (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Mock_object">https://en.wikipedia.org/wiki/Mock_object</a>
</li>

<li>Extrémní programování<br />
<a href="https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD">https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD</a>
</li>

<li>Programování řízené testy<br />
<a href="https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy">https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>Tox<br />
<a href="https://tox.readthedocs.io/en/latest/">https://tox.readthedocs.io/en/latest/</a>
</li>

<li>pytest: helps you write better programs<br />
<a href="https://docs.pytest.org/en/latest/">https://docs.pytest.org/en/latest/</a>
</li>

<li>doctest — Test interactive Python examples<br />
<a href="https://docs.python.org/dev/library/doctest.html#module-doctest">https://docs.python.org/dev/library/doctest.html#module-doctest</a>
</li>

<li>unittest — Unit testing framework<br />
<a href="https://docs.python.org/dev/library/unittest.html">https://docs.python.org/dev/library/unittest.html</a>
</li>

<li>Python namespaces<br />
<a href="https://bytebaker.com/2008/07/30/python-namespaces/">https://bytebaker.com/2008/07/30/python-namespaces/</a>
</li>

<li>Namespaces and Scopes<br />
<a href="https://www.python-course.eu/namespaces.php">https://www.python-course.eu/namespaces.php</a>
</li>

<li>Stránka projektu Robot Framework<br />
<a href="https://robotframework.org/">https://robotframework.org/</a>
</li>

<li>GitHub repositář Robot Frameworku<br />
<a href="https://github.com/robotframework/robotframework">https://github.com/robotframework/robotframework</a>
</li>

<li>Robot Framework (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Robot_Framework">https://en.wikipedia.org/wiki/Robot_Framework</a>
</li>

<li>Tutoriál Robot Frameworku<br />
<a href="http://www.robotframeworktutorial.com/">http://www.robotframeworktutorial.com/</a>
</li>

<li>Robot Framework Documentation<br />
<a href="https://robotframework.org/robotframework/">https://robotframework.org/robotframework/</a>
</li>

<li>Robot Framework Introduction<br />
<a href="https://blog.testproject.io/2016/11/22/robot-framework-introduction/">https://blog.testproject.io/2016/11/22/robot-framework-introduction/</a>
</li>

<li>robotframework 3.1.2 na PyPi<br />
<a href="https://pypi.org/project/robotframework/">https://pypi.org/project/robotframework/</a>
</li>

<li>Robot Framework demo (GitHub)<br />
<a href="https://github.com/robotframework/RobotDemo">https://github.com/robotframework/RobotDemo</a>
</li>

<li>Robot Framework web testing demo using SeleniumLibrary<br />
<a href="https://github.com/robotframework/WebDemo">https://github.com/robotframework/WebDemo</a>
</li>

<li>Robot Framework for Mobile Test Automation Demo<br />
<a href="https://www.youtube.com/watch?v=06LsU08slP8">https://www.youtube.com/watch?v=06LsU08slP8</a>
</li>

<li>Gherkin<br />
<a href="https://cucumber.io/docs/gherkin/">https://cucumber.io/docs/gherkin/</a>
</li>

<li>Selenium<br />
<a href="https://selenium.dev/">https://selenium.dev/</a>
</li>

<li>SeleniumLibrary<br />
<a href="https://robotframework.org/">https://robotframework.org/</a>
</li>

<li>The Practical Test Pyramid<br />
<a href="https://martinfowler.com/articles/practical-test-pyramid.html">https://martinfowler.com/articles/practical-test-pyramid.html</a>
</li>

<li>Acceptance Tests and the Testing Pyramid<br />
<a href="http://www.blog.acceptancetestdrivendevelopment.com/acceptance-tests-and-the-testing-pyramid/">http://www.blog.acceptancetestdrivendevelopment.com/acceptance-tests-and-the-testing-pyramid/</a>
</li>

<li>Tab-separated values<br />
<a href="https://en.wikipedia.org/wiki/Tab-separated_values">https://en.wikipedia.org/wiki/Tab-separated_values</a>
</li>

<li>A quick guide about Python implementations<br />
<a href="https://blog.rmotr.com/a-quick-guide-about-python-implementations-aa224109f321">https://blog.rmotr.com/a-quick-guide-about-python-implementations-aa224109f321</a>
</li>

<li>radamsa<br />
<a href="https://gitlab.com/akihe/radamsa">https://gitlab.com/akihe/radamsa</a>
</li>

<li>Fuzzing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Fuzzing">https://en.wikipedia.org/wiki/Fuzzing</a>
</li>

<li>american fuzzy lop<br />
<a href="http://lcamtuf.coredump.cx/afl/">http://lcamtuf.coredump.cx/afl/</a>
</li>

<li>Fuzzing: the new unit testing<br />
<a href="https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide#1">https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide#1</a>
</li>

<li>Corpus for github.com/dvyukov/go-fuzz examples<br />
<a href="https://github.com/dvyukov/go-fuzz-corpus">https://github.com/dvyukov/go-fuzz-corpus</a>
</li>

<li>AFL &ndash; QuickStartGuide.txt<br />
<a href="https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt">https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt</a>
</li>

<li>Introduction to Fuzzing in Python with AFL<br />
<a href="https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/">https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/</a>
</li>

<li>Writing a Simple Fuzzer in Python<br />
<a href="https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/">https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/</a>
</li>

<li>How to Fuzz Go Code with go-fuzz (Continuously)<br />
<a href="https://fuzzit.dev/2019/10/02/how-to-fuzz-go-code-with-go-fuzz-continuously/">https://fuzzit.dev/2019/10/02/how-to-fuzz-go-code-with-go-fuzz-continuously/</a>
</li>

<li>Golang Fuzzing: A go-fuzz Tutorial and Example<br />
<a href="http://networkbit.ch/golang-fuzzing/">http://networkbit.ch/golang-fuzzing/</a>
</li>

<li>Fuzzing Python Modules<br />
<a href="https://stackoverflow.com/questions/20749026/fuzzing-python-modules">https://stackoverflow.com/questions/20749026/fuzzing-python-modules</a>
</li>

<li>0x3 Python Tutorial: Fuzzer<br />
<a href="http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/">http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/</a>
</li>

<li>fuzzing na PyPi<br />
<a href="https://pypi.org/project/fuzzing/">https://pypi.org/project/fuzzing/</a>
</li>

<li>Fuzzing 0.3.2 documentation<br />
<a href="https://fuzzing.readthedocs.io/en/latest/">https://fuzzing.readthedocs.io/en/latest/</a>
</li>

<li>Randomized testing for Go<br />
<a href="https://github.com/dvyukov/go-fuzz">https://github.com/dvyukov/go-fuzz</a>
</li>

<li>HTTP/2 fuzzer written in Golang<br />
<a href="https://github.com/c0nrad/http2fuzz">https://github.com/c0nrad/http2fuzz</a>
</li>

<li>Ffuf (Fuzz Faster U Fool) – An Open Source Fast Web Fuzzing Tool<br />
<a href="https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html">https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html</a>
</li>

<li>Continuous Fuzzing Made Simple<br />
<a href="https://fuzzit.dev/">https://fuzzit.dev/</a>
</li>

<li>Halt and Catch Fire<br />
<a href="https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86">https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86</a>
</li>

<li>Random testing<br />
<a href="https://en.wikipedia.org/wiki/Random_testing">https://en.wikipedia.org/wiki/Random_testing</a>
</li>

<li>Monkey testing<br />
<a href="https://en.wikipedia.org/wiki/Monkey_testing">https://en.wikipedia.org/wiki/Monkey_testing</a>
</li>

<li>Fuzzing for Software Security Testing and Quality Assurance, Second Edition<br />
<a href="https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false">https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false</a>
</li>

<li>libFuzzer – a library for coverage-guided fuzz testing<br />
<a href="https://llvm.org/docs/LibFuzzer.html">https://llvm.org/docs/LibFuzzer.html</a>
</li>

<li>fuzzy-swagger na PyPi<br />
<a href="https://pypi.org/project/fuzzy-swagger/">https://pypi.org/project/fuzzy-swagger/</a>
</li>

<li>fuzzy-swagger na GitHubu<br />
<a href="https://github.com/namuan/fuzzy-swagger">https://github.com/namuan/fuzzy-swagger</a>
</li>

<li>Fuzz testing tools for Python<br />
<a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy#Fuzz_Testing_Tools">https://wiki.python.org/moin/PythonTestingToolsTaxonomy#Fuzz_Testing_Tools</a>
</li>

<li>A curated list of awesome Go frameworks, libraries and software<br />
<a href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go</a>
</li>

<li>gofuzz: a library for populating go objects with random values<br />
<a href="https://github.com/google/gofuzz">https://github.com/google/gofuzz</a>
</li>

<li>tavor: A generic fuzzing and delta-debugging framework<br />
<a href="https://github.com/zimmski/tavor">https://github.com/zimmski/tavor</a>
</li>

<li>hypothesis na GitHubu<br />
<a href="https://github.com/HypothesisWorks/hypothesis">https://github.com/HypothesisWorks/hypothesis</a>
</li>

<li>Hypothesis: Test faster, fix more<br />
<a href="https://hypothesis.works/">https://hypothesis.works/</a>
</li>

<li>Hypothesis<br />
<a href="https://hypothesis.works/articles/intro/">https://hypothesis.works/articles/intro/</a>
</li>

<li>What is Hypothesis?<br />
<a href="https://hypothesis.works/articles/what-is-hypothesis/">https://hypothesis.works/articles/what-is-hypothesis/</a>
</li>

<li>Databáze CVE<br />
<a href="https://www.cvedetails.com/">https://www.cvedetails.com/</a>
</li>

<li>Fuzz test Python modules with libFuzzer<br />
<a href="https://github.com/eerimoq/pyfuzzer">https://github.com/eerimoq/pyfuzzer</a>
</li>

<li>Taof - The art of fuzzing<br />
<a href="https://sourceforge.net/projects/taof/">https://sourceforge.net/projects/taof/</a>
</li>

<li>JQF + Zest: Coverage-guided semantic fuzzing for Java<br />
<a href="https://github.com/rohanpadhye/jqf">https://github.com/rohanpadhye/jqf</a>
</li>

<li>http2fuzz<br />
<a href="https://github.com/c0nrad/http2fuzz">https://github.com/c0nrad/http2fuzz</a>
</li>

<li>Demystifying hypothesis testing with simple Python examples<br />
<a href="https://towardsdatascience.com/demystifying-hypothesis-testing-with-simple-python-examples-4997ad3c5294">https://towardsdatascience.com/demystifying-hypothesis-testing-with-simple-python-examples-4997ad3c5294</a>
</li>

<li>Testování<br />
<a href="http://voho.eu/wiki/testovani/">http://voho.eu/wiki/testovani/</a>
</li>

<li>Unit testing (Wikipedia.en)<br />
<a href="https://en.wikipedia.org/wiki/Unit_testing">https://en.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit testing (Wikipedia.cz)<br />
<a href="https://cs.wikipedia.org/wiki/Unit_testing">https://cs.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit Test vs Integration Test<br />
<a href="https://www.youtube.com/watch?v=0GypdsJulKE">https://www.youtube.com/watch?v=0GypdsJulKE</a>
</li>

<li>TestDouble<br />
<a href="https://martinfowler.com/bliki/TestDouble.html">https://martinfowler.com/bliki/TestDouble.html</a>
</li>

<li>Test Double<br />
<a href="http://xunitpatterns.com/Test%20Double.html">http://xunitpatterns.com/Test%20Double.html</a>
</li>

<li>Test-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test-driven_development">https://en.wikipedia.org/wiki/Test-driven_development</a>
</li>

<li>Acceptance test–driven development<br />
<a href="https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development">https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development</a>
</li>

<li>Gauge<br />
<a href="https://gauge.org/">https://gauge.org/</a>
</li>

<li>Gauge (software)<br />
<a href="https://en.wikipedia.org/wiki/Gauge_(software)">https://en.wikipedia.org/wiki/Gauge_(software)</a>
</li>

<li>PYPL PopularitY of Programming Language<br />
<a href="https://pypl.github.io/PYPL.html">https://pypl.github.io/PYPL.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

