<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití Pythonu pro tvorbu testů: od jednotkových testů až po testy UI</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití Pythonu pro tvorbu testů: od jednotkových testů až po testy UI</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Již mnohokrát jsme se na stránkách Roota setkali s tematikou testů a testování aplikací na různých úrovních. Tato problematika je tak důležitá a užitečná, že si zaslouží vlastní seriál. V něm budou praktické příklady naprogramovány v Pythonu, ovšem uvedené postupy jsou univerzální.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití Pythonu pro tvorbu testů: od jednotkových testů až po testy UI</a></p>
<p><a href="#k02">2. Různé podoby testovací pyramidy</a></p>
<p><a href="#k03">3. Zmrzlinový kornout</a></p>
<p><a href="#k04">4. Jednotkové testy &ndash; základ pyramidy, špička kornoutu</a></p>
<p><a href="#k05">5. Testy komponent a integrační testy</a></p>
<p><a href="#k06">6. Systémové testy, akceptační testy</a></p>
<p><a href="#k07">7. Testy aplikačního (programového) rozhraní</a></p>
<p><a href="#k08">8. Testy grafického uživatelského rozhraní a end-to-end testy</a></p>
<p><a href="#k09">9. Testy chování (BDD)</a></p>
<p><a href="#k10">10. Test-driven development (TDD)</a></p>
<p><a href="#k11">11. Acceptance test–driven development (ATDD)</a></p>
<p><a href="#k12">12. Použití knihovny unittest.mock (nejenom) při testování</a></p>
<p><a href="#k13">13. Zdrojový soubor s&nbsp;funkcí, kterou budeme nahrazovat mock objektem</a></p>
<p><a href="#k14">14. Test s&nbsp;volanou i s&nbsp;mockovanou funkcí</a></p>
<p><a href="#k15">15. Vytvoření handleru, který se zavolá namísto originální funkce</a></p>
<p><a href="#k16">16. Kombinace handleru s&nbsp;předkonfigurovanou návratovou hodnotou?</a></p>
<p><a href="#k17">17. Obsah následující části seriálu</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Předchozí články s&nbsp;tématem testování (nejenom) v&nbsp;Pythonu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití Pythonu pro tvorbu testů: od jednotkových testů až po testy UI</h2>

<p>Testování aplikací, což je téma, do kterého se počítá jak tvorba testů, tak
i nástroje a postupy pro jejich spouštění a vyhodnocování, v&nbsp;současnosti
tvoří nedílnou součást vývoje aplikací a popř. i součást jejich akceptace
zákazníkem. Jedná se o velmi rozsáhlou oblast IT, která se postupně vyvíjela a
rozdělovala do několika podoblastí společně s&nbsp;tím, jak se měnil charakter
vyvíjených aplikací i jejich celková složitost (původně dávkové úlohy, dále
čistě desktopové aplikace s&nbsp;grafickým uživatelským rozhraním, následovaly
webové aplikace a webové služby, cloud atd.). S&nbsp;problematikou testů a
testování jsme se na stránkách <a href="https://www.root.cz">Roota</a> již
několikrát setkali (viz odkazy uvedené <a href="#k19">v&nbsp;devatenácté
kapitole</a>), ale možná bude užitečné se na testování podívat i
z&nbsp;určitého odstupu &ndash; jaké typy testů se používají, proč se vlastně
používají, jaké pomocné nástroje máme v&nbsp;dané oblasti k&nbsp;dispozici a
jaké jsou případné dobré a naopak špatné praktiky.</p>

<p>Samotný &ndash; dnes již samostatný &ndash; obor testování v&nbsp;IT se
postupně vyvíjel a měnily se i jeho metodiky. U mnoha starších (z&nbsp;dnešního
pohledu prastarých) projektů bylo testování prováděno jednorázově, a to na
konci vývoje celého systému. Toto mnohdy manuální či jen poloautomatické
testování bychom dnes nazvali <i>akceptačními testy</i>. Tento přístup již pro
většinu rozsáhlejších projektů není ani praktický ani nejlevnější; dnes je
totiž testování úzce svázáno s&nbsp;celým procesem vývoje nového informačního
systému a někdy celý vývoj začíná právě vytvořením prvotní sady testů.
Důležitější je ovšem průběžné testování v&nbsp;čase vývoje a nasazování
aplikace, což nám mj.&nbsp;dává přímou zpětnou vazbu o stavu vyvíjeného systému
(pokud jsou pochopitelně testy napsány dobře). V&nbsp;dnes začínajícím
(mini)seriálu si nejprve vysvětlíme základní termíny (ty ovšem nejsou plně
ustáleny) a postupně budeme proházet &bdquo;testovací pyramidou&ldquo; (viz
druhou kapitolu) od její základny až po vrchol.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto seriálu budeme primárně
používat programovací jazyk <a href="https://www.root.cz/n/python/">Python</a>,
ovšem jednotlivé typy testů, jejich struktura atd. má svůj přímý protějšek
v&nbsp;mnoha dalších programovacích jazycích. Mezi přednosti Pythonu
v&nbsp;této oblasti patří snadná tvorba <i>mocků</i> v&nbsp;jednotkových
testech, <a href="https://github.com/vinta/awesome-python#testing">rozsáhlá
sada nástrojů</a> pro tvorbu prakticky jakýchkoli typů testů (včetně knihovny
<a href="https://robotframework.org/">Robot Framework</a>, <a
href="https://github.com/HypothesisWorks/hypothesis">Hypothesis</a>) a rozhraní
pro <a href="https://pypi.org/project/selenium/">Selenium</a>) a
v&nbsp;neposlední řadě i relativně snadná dostupnost studijních
materiálů.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Různé podoby testovací pyramidy</h2>

<p>V&nbsp;souvislosti s&nbsp;testy (resp.&nbsp;přesněji řečeno s&nbsp;různými
typy testů) se poměrně často můžeme setkat s&nbsp;termínem &bdquo;testovací
pyramida&ldquo;. O co se vlastně jedná? Jde o rozdělení jednotlivých typů testů
do vrstev, přičemž vrstvy na spodních úrovních mají blíže k&nbsp;vlastnímu
zdrojovému kódu, zatímco vrstvy na úrovních vyšších již od kódu (a mnohdy i od
architektury aplikace) do značné míry abstrahují. Má to pochopitelně svůj velmi
dobrý význam, protože jedna úroveň abstrakce nemůže v&nbsp;této oblasti
vyhovovat pro všechny oblasti použití. Zajímavé je, že se sice tento termín
skutečně používá poměrně často, ale autoři si jednotlivé vrstvy (zejména ty
prostřední) rozdělují různým způsobem. Ostatně se můžeme podívat na několik
příkladů:</p>

*** image ***
<p><i>Obrázek 1: Různé podoby testovací pyramidy.</i></p>

*** image ***
<p><i>Obrázek 2: Různé podoby testovací pyramidy.</i></p>

*** image ***
<p><i>Obrázek 3: Různé podoby testovací pyramidy.</i></p>

*** image ***
<p><i>Obrázek 4: Různé podoby testovací pyramidy.</i></p>

<p>Většina autorů se shodne na tom, že testovací pyramida (ať již jsou její
vrstvy blíže k&nbsp;vrcholku pojmenovány různě) tvoří velmi dobrý příklad toho,
jak by testy reálné aplikace měly vypadat. Základem pyramidy jsou jednotkové
testy a základna by pochopitelně měla být co nejširší. Předností jednotkových
testů je jejich rychlé spouštění (může se testovat izolovaně pouze ona jednotka
&ndash; třída, funkce atd.), stabilita a poměrně snadné a rychlé úpravy. Směrem
k&nbsp;vrcholku pyramidy se vrstvy pochopitelně zužují, což v&nbsp;překladu
znamená, že by se testům na těchto úrovních mohla (relativně!) věnovat menší
pozornost. Testy blíže k&nbsp;vrcholu pyramidy jsou &bdquo;dražší&ldquo;, a to
jak z&nbsp;hlediska investovaného pracovního času (extrémem jsou manuální
testy), tak i času strojového (je nutné sestavit celou aplikaci i se všemi
souvisejícími službami atd.).</p>

<p><div class="rs-tip-major">Poznámka: představenou testovací pyramidu není
nutné chápat jako neměnný předpis, jak by testy měly či naopak neměly vypadat;
někdy se okolo ní dokonce tvoří zbytečný <i>cargo cult</i>. Následující
blogpost je dobrým zamyšlením nad některými limity celé hierarchie <a
href="https://medium.com/@fistsOfReason/testing-is-good-pyramids-are-bad-ice-cream-cones-are-the-worst-ad94b9b2f05f">Testing
is Good. Pyramids are Bad. Ice Cream Cones are the Worst</a>.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zmrzlinový kornout</h2>

<p>V&nbsp;souvislosti s&nbsp;prioritami, které se mají věnovat jednotlivým
typům testů, se někdy setkáme i s&nbsp;termínem &bdquo;zmrzlinový
kornout&ldquo;, což je struktura připomínající otočenou pyramidu. V&nbsp;této
struktuře se málo času/energie/peněz věnuje jednotkovým testům a testům
komponent, o to více času (alespoň relativně) se pak věnuje například testům
grafického uživatelského rozhraní nebo dokonce manuálním testům. Takto
nastavené priority při tvorbě testů jsou ovšem většinou praktikujících autorů
považovány za <i>antipattern</i>, ovšem i s&nbsp;takovým postupem
(popř.&nbsp;nějakou jeho variantou) se můžeme v&nbsp;praxi setkat.</p>

*** image ***
<p><i>Obrázek 5: Podoba zmrzlinového kornoutu v&nbsp;porovnání s&nbsp;testovací
pyramidou.</i></p>

<p><div class="rs-tip-major">Poznámka: ovšem jak již bylo patrné při
představování různých variant testovací pyramidy, je nesnadné až nemožné (a
hlavně mnohdy nepraktické) pracovat na všech úrovních testů. Mnohdy si velmi
dobře vystačíme například pouze se třemi úrovněmi (jednotkové testy, integrační
testy, testy UI) &ndash; to ovšem záleží na tom, o jakou aplikaci se jedná.
Jiné požadavky budou kladeny na utilitu spouštěnou z&nbsp;příkazové řádky
v&nbsp;porovnání s&nbsp;desktopovou aplikací s&nbsp;plnohodnotným GUI
popř.&nbsp;dokonce s&nbsp;webovou aplikací založenou na využití velkého
množství <a
href="https://www.root.cz/serialy/mikrosluzby/">mikroslužeb</a>.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Jednotkové testy &ndash; základ pyramidy, špička kornoutu</h2>

<p>První fáze testování většinou probíhá na úrovni balíčků, tříd, objektů,
metod a funkcí. Jedná se o takzvané <i>jednotkové testy</i> (<i>unit
tests</i>), přičemž onou jednotkou bývá jedna funkce, metoda, celá třída nebo
(méně často) celý balíček. Tyto testy se v&nbsp;Pythonu tvoří relativně snadno
a typicky se vytváří souběžně s&nbsp;programovým kódem nebo (při TDD) dokonce
ještě před zahájením prací na programovém kódu. Výhodou jednotkových testů je
jejich specifičnost, možnost selektivního spouštění testů pouze pro zvolenou
jednotku i snadné plánovaní prací (předpokládá se, že jednotkové testy jsou
součástí zdrojových kódů). Vývoj současně s&nbsp;jednotkovými testy může pomoci
s&nbsp;vytvářením kvalitnějšího kódu (typicky při omezování stavového prostoru
aplikace, globálních proměnných atd.). Ovšem při tvorbě jednotkových testů je
nutné počítat i s&nbsp;některými riziky, zejména pak:</p>

<ol>

<li>Pokud jednotkové testy vytváří samotný autor testovaného zdrojového kódu,
je pravděpodobné, že v&nbsp;testech nemusí pokrýt všechny možné případy, které
tak nebudou ani správně odhaleny ve zdrojovém kódu.</li>

<li>Velké množství procházejících testů může vést k&nbsp;tomu, že se budou
zbývající padající testy ignorovat.</li>

<li>Testy na sobě mohou záviset, což je obecně špatná architektura (testy by
mělo být možné spouštět v&nbsp;náhodném pořadí, popř.&nbsp;je filtrovat).</li>

<li>Změna architektury aplikace může znamenat nutnost přepisu velkého množství
jednotkových testů.</li>

</ol>

<p>V&nbsp;jednotkových testech je nutné některé (zrovna netestované) bloky
nahradit za jednodušší objekty nazývané <i>test double</i>. Ty se dále
rozdělují do několika kategorií: <i>fake</i>, <i>stub</i>, <i>mock</i>,
<i>spy</i> atd. (viz též navazující kapitoly, zejména <a href="#k12">dvanáctou
kapitolu</a>).</p>

<p>Příklad primitivního jednotkového testu:</p>

<pre>
import pytest
&nbsp;
def <strong>test_the_answer</strong>():
      x = 6
      y = 7
      assert x*y == 42, "test failed"
</pre>

<p>Příklad testu, který zjišťuje, zda testovaná funkce vyhodila výjimku či nikoli:</p>

<pre>
import pytest
&nbsp;
def raise_expection():
    raise Exception("Diamonds are forewer")
&nbsp;
def <strong>test_exception</strong>(self):
    with pytest.raises(Exception):
        ...
        ...
        ...
&nbsp;
    self.assertTrue('This is broken' in context.exception)
</pre>

<p>Pro programovací jazyk Python v&nbsp;současnosti existuje téměř nepřeberné
množství knihoven, frameworků a rozšíření standardních jednotkových testů.
Jmenujme například:</p>

<table>
<tr><th> #</th><th>Knihovna/framework</th></tr>
<tr><td> 1</td><td>unittest</td></tr>
<tr><td> 2</td><td>doctest</td></tr>
<tr><td> 3</td><td>pytest</td></tr>
<tr><td> 4</td><td>nose</td></tr>
<tr><td> 5</td><td>testify</td></tr>
<tr><td> 6</td><td>Trial</td></tr>
<tr><td> 7</td><td>Twisted</td></tr>
<tr><td> 8</td><td>subunit</td></tr>
<tr><td> 9</td><td>testresources</td></tr>
<tr><td>10</td><td>reahl.tofu</td></tr>
<tr><td>11</td><td>unit testing</td></tr>
<tr><td>12</td><td>testtools</td></tr>
<tr><td>13</td><td>Sancho</td></tr>
<tr><td>14</td><td>zope.testing</td></tr>
<tr><td>15</td><td>pry</td></tr>
<tr><td>16</td><td>pythoscope</td></tr>
<tr><td>17</td><td>testlib</td></tr>
<tr><td>18</td><td>pytest</td></tr>
<tr><td>19</td><td>dutest</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: v&nbsp;dalších článcích se
s&nbsp;některými výše uvedenými balíčky a nástroji setkáme.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Testy komponent a integrační testy</h2>

<p>Jak jsme již mohli vidět <a href="#k02">ve druhé kapitole</a>, tvoří
jednotkové testy jen jedinou vrstvu (základnu) takzvané &bdquo;testovací
pyramidy&ldquo;. Nad nimi se v&nbsp;dalších vrstvách nachází testy komponent,
funkční testy, integrační testy, různé formy benchmarků, BDD testy, testy
grafického uživatelského rozhraní, manuálně prováděné testy atd. Všechny tyto
testy jsou potenciálně důležité, protože samotné jednotkové testy zdaleka
nedokáží odhalit všechny možné chyby:</p>

*** image ***
<p><i>Obrázek 6: Jednotkové testy nedokáží odhalit problémy na vyšších úrovních
abstrakce, například problematické sestavení jednotlivých modulů do vyšších
celků.</i></p>

<p>A právě z&nbsp;tohoto důvodu jsou nad samotnými jednotkovými testy postaveny
testy komponent a integrační testy. Ty se snaží zjistit, zda je možné menší (a
ideálně velmi dobře izolovaně otestované) jednotky (<i>units</i>) sestavit do
většího a přitom stále funkčního celku. V&nbsp;některých případech se rozlišuje
mezi vnitřní a vnější integrací (testy komponent patří do první kategorie).
Testuje se například komunikace mezi jednotlivými moduly, ze kterých se
výsledná aplikace skládá. Podobně jako se u jednotkových testů používají
<i>mock objekty</i> (resp.&nbsp;obecněji <i>test double</i>), lze u
integračních testů používat takzvané <i>fake moduly</i> a <i>mock moduly</i>.
Poměrně názorným příkladem takového modulu může být zjednodušená forma databáze
uložená v&nbsp;operační paměti, která pro účely testů nahrazuje reálnou
databázi (v&nbsp;paměti lze velmi snadno provozovat například SQLite).
Relativně snadno se nahrazují i například moduly pro logování apod. Taktéž se
zde setkáme s&nbsp;takzvanými špiony (<i>spies</i>), což jsou moduly
zaznamenávající všechny požadavky přicházející z&nbsp;jiných modulů.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Systémové testy, akceptační testy</h2>

<p>U úroveň výše v&nbsp;testovací pyramidě nacházíme celou skupinu testů,
zejména pak systémové testy a testy akceptační. Systémové testy se většinou
rozdělují do dalších podkategorií. Zejména se často používají takzvané <i>smoke
testy</i>, které pouze velmi rychle zjišťují, zda je zajištěna alespoň
minimální míra funkčnosti aplikace předtím, než se spustí složitější a časově
mnohem náročnější testy. Pokud smoke testy zhavarují, vrací se aplikace zpět
k&nbsp;vývojářům a popř.&nbsp;k&nbsp;devops týmu :-)</p>

<p><div class="rs-tip-major">Poznámka: název <i>smoke test</i> pochází
z&nbsp;jiných oborů, v&nbsp;nichž se například kontroluje těsnost potrubí ještě
před jeho reálným použitím tím, že se použije nějaký plyn, který v&nbsp;běžném
vzduchu vytvoří kouř (nebo se přímo použije kouř). Poté je již snadné pomocí
více smyslů zjistit případné netěsnosti, a to ještě předtím, než se potrubí
použije v&nbsp;reálném provozu (například s&nbsp;nějakou mnohem nebezpečnější
látkou).</div></p>

<p>Po úspěšném provedení smoke testů se mohou spouštět systémové testy, jejichž
primárním účelem je ověření, jestli aplikace (služba) sestavená do jednoho
celku pracuje korektně. Tyto testy se zaměřují jak na zjištění, zda pro určité
vstupy aplikace produkuje určitý výstup (například objedná letenku), ale i to,
jak reaguje na nestandardní situace, špatně zadané vstupy, pokusy o průnik do
aplikace apod. Tvorbou těchto testů již může být pověřen samostatný tým (na
rozdíl od testů jednotkových a popř.&nbsp;testů komponent, což je většinou
starostí vývojového týmu).</p>

<p>Testy akceptační jsou ještě zajímavější, protože se na jejich vytváření může
podílet i zákazník. Jak již název těchto testů napovídá, je jejich úspěšné
provedení (většinou) vyžadováno proto, aby byla akceptována funkčnost aplikace.
Pro akceptační testy lze v&nbsp;Pythonu použít různé knihovny a frameworky,
například dále zmíněnou knihovnu <strong>Behave</strong> nebo &ndash; a to
pravděpodobně častěji &ndash; nástroj nazvaný <strong>Robot Framework</strong>.
V&nbsp;tomto nástroji lze testy zapisovat formou tabulek, například
následujícím způsobem (nejedná se o jediný možný způsob):</p>

<pre>
| *** Settings ***   |                  |   |
| Library            | Test16.py        |   |
|                    |                  |   |
| *** Test Cases *** |                  |   |
| Adder #1           |                  |   |
|                    | Add              | 1 | 2
|                    | Result should be | 3 |
|                    |                  |   |
| Adder #2           |                  |   |
|                    | Add              | 0 | 0
|                    | Result should be | 0 |
|                    |                  |   |
| Adder #3           |                  |   |
|                    | Add              | 1 | -1
|                    | Result should be | 0 |
</pre>

<p>Ve webovém prohlížeči si můžeme prohlédnout vygenerované soubory s výsledky:</p>

<a href="https://www.root.cz/obrazek/398486/"><img src="https://i.iinfo.cz/images/555/robot-framework-01-3-prev.png" class="image-398486" alt="" width="370" height="264"></a>
<p><i>Obrázek 7: Přehled s výsledky testovacího scénáře. Zelená barva
naznačuje, že všechny testy skončily korektně.</i></p>

<p>Alternativně:</p>

<pre>
| *** Settings ***   |                  |   |
| Library            | Test16.py        |   |
&nbsp;
| *** Test Cases *** |                  |   |
| Adder #1           |                  |   |
|                    | Add              | 1 | 2
|                    | Result should be | 3 |
|                    | Add              | 2 | 3
|                    | Result should be | 5 |
|                    | Add              | 4 | 5
|                    | Result should be | 9 |
&nbsp;
| Adder #2           |                  |   |
|                    | Add              | 0 | 0
|                    | Result should be | 0 |
&nbsp;
| Adder #3           |                  |   |
|                    | Add              | 1 | -1
|                    | Result should be | 0 |
</pre>

<a href="https://www.root.cz/obrazek/398487/"><img src="https://i.iinfo.cz/images/555/robot-framework-01-4-prev.png" class="image-398487" alt="" width="370" height="97"></a>
<p><i>Obrázek 8: Podrobnější pohled na jednotlivé kroky testu.</i></p>

<p>Jiný způsob zápisu testu, opět v&nbsp;tabulkové podobě:</p>

<pre>
| *** Settings ***   |                             |             |             |
| Library            | Accumulator6.py             |             |             |
| Test template      | Accumulate                  |             |             |
| Test setup         | Setup method                | 0           |             |
| Test teardown      | Teardown method             |             |             |
|                    |                             |             |             |
| *** Test Cases *** | Value                       | Expected    |             |
| Test1              | 0                           | 0           |             |
|                    | 1                           | 1           |             |
|                    | 10                          | 11          |             |
|                    | -10                         | 1           |             |
|                    | 1                           | 2           |             |
|                    | 1                           | 3           |             |
|                    |                             |             |             |
| *** Keywords ***   |                             |             |             |
| Accumulate         |                             |             |             |
|                    | [Arguments]                 | ${value}    | ${expected} |
|                    | Add value                   | ${value}    |             |
|                    | Accumulator value should be | ${expected} |             |
</pre>

<a href="https://www.root.cz/obrazek/398488/"><img src="https://i.iinfo.cz/images/555/robot-framework-01-5-prev.png" class="image-398488" alt="" width="257" height="270"></a>
<p><i>Obrázek 9: Podrobnější pohled na jednotlivé kroky testu, informace z
logovacího souboru.</i></p>

<p><div class="rs-tip-major">Poznámka: pokud se s&nbsp;využitím Robot
Frameworku tvoří akceptační testy, tak může být právě tabulková forma vhodná,
protože se vlastně jedná o úřední dokument mnohdy zpracovávaný lidmi, kteří
mají tabulky v&nbsp;oblibě :-)</div></p>

<a href="https://www.root.cz/obrazek/398489/"><img src="https://i.iinfo.cz/images/555/robot-framework-01-6-prev.png" class="image-398489" alt="" width="370" height="264"></a>
<p><i>Obrázek 10: Přehled s výsledky testovacího scénáře. Červená barva
naznačuje pád alespoň jednoho testu.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Testy aplikačního (programového) rozhraní</h2>

<p>Dalším typem testů jsou testy aplikačního programového rozhraní, dnes
typicky (ale nejenom) REST API. Tyto testy mohou být vyvinuty a spouštěny
samostatně (například vůči jedné izolované komponentě), nebo mohou být součástí
end-to-end testů zmíněných dále. Součástí API testů bývají i kontroly
autentizace a autorizace, stejně jako kontroly, jak API reaguje na pokusy o
průnik popř.&nbsp;&bdquo;pouze&ldquo; na vadná data. Jak jsme si již řekli na
začátku tohoto odstavce, dnes se velmi často používá REST API, takže testy pro
ně lze vytvořit různými způsoby (například automaticky ze specifikace OpenAPI),
ovšem používají se i další protokoly (MQTT, SOAP, RMI, SMTP atd.). Pro některé
typy webových aplikací (resp.&nbsp;přesněji řečeno jejich REST API) mi
vyhovovala kombinace knihovny Behave se známou knihovnou <a
href="https://requests.readthedocs.io/en/master/">requests</a>, ovšem existují
i mnohé další více či méně komplexní nástroje.</p>

<p>Dnes můžeme sledovat poměrně rychlou adaptaci <i>fuzzy systémů (fuzzerů)</i>
při testování webových služeb či celých webových aplikací. Je to ostatně
logické, zejména když si uvědomíme, že právě webové služby a aplikace poskytují
svá rozhraní mnohdy všem uživatelům Internetu a tedy i mnoha potenciálním
útočníkům. Snaha o co nejlepší zabezpečení je tedy v&nbsp;této oblasti IT zcela
pochopitelná. Testovat je možné například REST API. V&nbsp;tomto případě mohou
<i>fuzzery</i> použít popis API (OpenAPI/Swagger atd.) a na základě něho začít
generovat různé potenciálně problematické vstupy se snahou o obejití vnitřních
kontrolních mechanismů aplikace či služby. Některé nástroje, například <a
href="https://github.com/dubzzz/fuzz-rest-api/">https://github.com/dubzzz/fuzz-rest-api/</a>,
se navíc snaží o různé specifické typy útoků, například do dat přidávají
řetězce s příklady SQL Injection apod. Dále lze pochopitelně posílat
pseudonáhodná data v&nbsp;tělech požadavků, měnit parametry URL i hlavičky
požadavků.</p>

<p>Příklady nástrojů určených pro Python:</p>

<table>
<tr><th>#</th><th>Nástroj</th></tr>
<tr><td>1</td><td>Hypothesis</td></tr>
<tr><td>2</td><td>Pester</td></tr>
<tr><td>3</td><td>Peach Fuzzer Framework</td></tr>
<tr><td>4</td><td>antiparser</td></tr>
<tr><td>5</td><td>Fusil (Fusil the fuzzer)</td></tr>
<tr><td>6</td><td>PyFuzzer</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: tyto nástroje lze použít i pro jiné
účely, než pro &bdquo;pouhé&ldquo; testování aplikačního rozhraní.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Testy grafického uživatelského rozhraní a end-to-end testy</h2>

<p>Následují relativně vysokoúrovňové testy, zejména testy grafického
uživatelského rozhraní, kterým bude později věnováno hned několik článků
v&nbsp;tomto seriálu. Mnohé dnešní aplikace jsou založeny na webovém prohlížeči
(ať již klasickém, či &bdquo;schovaném&ldquo; ve frameworcích typu Electron),
takže existuje hned několik nástrojů pro Python, které umožňují testování GUI
takových aplikací. Většinou se setkáme se dvěma způsoby testování:</p>

<ol>

<li>Simulace chování webového prohlížeče, typicky na úrovni protokolu HTTP a
parsování HTML, které posílá aplikace prohlížeči. Mnohdy jsou tyto testy
zredukovány na testy REST API. Sem spadají nástroje jako <i>webunit</i>,
<i>zope.testbrowser</i>, <i>webtest</i> nebo <i>FunkLoad</i>.</li>

<li>Automatizace přímo v&nbsp;rámci webového prohlížeče, kdy testy
(resp.&nbsp;framework pod nimi) přímo používá možnosti webového prohlížeče.
V&nbsp;této kategorii je pravděpodobně nejznámějším nástrojem <i>Selenium</i>,
které obsahuje podporu i pro Python. Existují však i další nástroje, například
<i>Windmill</i> či <i>Splinter</i>.</li>

</ol>

<p>Na ještě vyšší úrovni, prakticky na vrcholku pyramidy, jsou end-to-end
testy. Ty slouží k&nbsp;otestování aplikace jako celku, od začátku do konce.
Může se například provádět následující testování:</p>

<ol>
<li>Přihlášení do aplikace</li>
<li>Zahájení konkrétní operace</li>
<li>Vytvoření reportu</li>
<li>Poslání tohoto reportu na tiskárnu</li>
<li>Odhlášení z&nbsp;aplikace</li>
</ol>



<p><a name="k09"></a></p>
<h2 id="k09">9. Testy chování (BDD)</h2>

<p>Velmi důležité jsou testy chování (<i>behaviour-driven</i>), protože ty nám
mohou odhalit nelogičnosti ve zdánlivě funkčním systému (například se očekává
neintuitivní ovládání). Tyto typy testů do určité míry kombinují přístupy TDD a
ATDD (viz následující dvě kapitoly); používají se zde nástroje
<strong>Behave</strong> či <strong>Robot Framework</strong>. Zajímavé je, že se
v&nbsp;této oblasti můžeme setkat s&nbsp;určitou standardizací (procházející
dokonce přes více programovacích jazyků), kterou představuje doménově
specifický jazyk (DSL) nazvaný <i>Gherkin</i>.</p>

<p>Ve dvou článcích [<a
href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">1</a>]
[<a
href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">2</a>]
o programovacím jazyku Clojure jsme se věnovali popisu integrace výše zmíněného
doménově specifického jazyka <i>Gherkin</i> určeného pro popis testovacích
scénářů přímo v&nbsp;programovacím jazyku Clojure. Ve skutečnosti ovšem není
<i>Gherkin</i> v&nbsp;žádném případě určen pouze pro použití společně
s&nbsp;Clojure, ale jedná se o <a
href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a>
integrovatelný i do mnoha dalších programovacích jazyků. Dnes si ve stručnosti
představíme knihovnu <a href="https://pypi.python.org/pypi/behave">Behave</a>,
s&nbsp;jejíž pomocí se Gherkin integruje do jazyka Python. Ve skutečnosti se
bude jednat o téměř ideální spojení, protože Gherkin i Python používají podobný
způsob zápisu, v&nbsp;němž i odsazení jednotlivých programových řádků je
součástí syntaxe (naproti tomu se Gherkin a Clojure ze syntaktického hlediska
zcela odlišují).</p>

<p>Jazyk Gherkin je navržen takovým způsobem, aby ho uživatelé (nemusí se totiž
nutně jednat pouze o programátory) mohli začít používat prakticky okamžitě,
tj.&nbsp;bez nutnosti studia sáhodlouhých manuálů.</p> Tento doménově
specifický jazyk odstiňuje autora testů od vlastní implementace systému i od
programovacího jazyka (či jazyků), v&nbsp;nichž je systém vytvořen. Ostatně
v&nbsp;Gherkinu lze popsat očekávané chování prakticky jakéhokoli systému,
který dokonce nemusí mít nic společného s&nbsp;IT.

<a href="https://www.root.cz/obrazek/324266/"><img src="https://i.iinfo.cz/images/634/clojure-cucumber-1-prev.png" class="image-324266" alt="&#160;" width="370" height="198" /></a>
<p><i>Obrázek X: Ukázka scénářů napsaných v&nbsp;doménově specifickém jazyce
Gherkin.</i></p>

<p>Na předchozím screenshotu jsou zvýrazněna klíčová slova uvozující jednotlivé
kroky testu. Ostatní slova a číslice ve větách jsou buď pevně daná (svázaná
s&nbsp;konkrétním krokem), nebo se jedná o proměnné. Ve scénáři je zapsána i
tabulka, jejíž obsah se řádek po řádku postupně stává obsahem jednotlivých
kroků testu (obsahem tabulky se nahrazují slova umístěná do ostrých
závorek).</p>

<p><div class="rs-tip-major">Poznámka: doménově specifický jazyk Gherkin
existuje v&nbsp;různých jazykových mutacích, my se však budeme držet jeho
originální anglické varianty. Ostatně mnoho knihoven, které Gherkin podporují,
pracuje pouze s&nbsp;anglickou variantou.</div></p>

<p>Druhým důležitým souborem je vlastní testovací scénář nazvaný
<strong>adder.feature</strong>, který je (př použití knihovny
<strong>Behave</strong>) typicky uložen v&nbsp;podadresáři
<strong>features</strong>. Tento testovací scénář je naprogramován
v&nbsp;jazyku <i>Gherkin</i>, konkrétně v&nbsp;jeho výchozí anglické
&bdquo;mutaci&ldquo;. V&nbsp;následujícím výpisu jsou klíčová slova rozeznávaná
interpretrem označena tučně:</p>

<pre>
<strong>Feature</strong>: Adder test
&nbsp;
  <strong>Scenario</strong>: Check the function add()
    <strong>Given</strong> The function add is callable
    <strong>When</strong> I call function add with arguments 1 and 2
    <strong>Then</strong> I should get 3 as a result
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že jazyk Gherkin je
z&nbsp;hlediska sémantiky velmi jednoduchý jazyk. Obsahuje deklarace
jednotlivých testovacích scénářů, počáteční podmínku a potom sérii kroků ve
stylu &bdquo;když udělám X, stane se (očekávám) Y&ldquo;. Syntax je také
jednoduchá (alespoň v&nbsp;základních testovacích scénářích), protože první
slovo je klíčové a jednotlivé bloky (zde scénáře) jsou odsazeny, podobně jako
v&nbsp;samotném Pythonu či ve formátu YAML.</div></p>

<p>Tento přístup je možné napodobit i při použití Robot Frameworku, v&nbsp;němž
může zápis testu vypadat například následovně:</p>

<pre>
*** Settings ***
Library             Accumulator6.py
Test setup          Setup method  0
Test teardown       Teardown method
Test template       Accumulator operation
&nbsp;
*** Keywords ***
Accumulator operation
                    [Arguments]  ${value}  ${expected}
                    Given accumulator has been zeroed
                    When I add ${value} to accumulator
                    Then the accumulated value Should Be ${expected}
&nbsp;
*** Test Cases ***     Value  Expected
Accumulator operation  1      1
Accumulator operation  10     10
&nbsp;
&nbsp;
&nbsp;
*** Keywords ***
Accumulator has been zeroed
    log  accumulator init
&nbsp;
I add ${value} to accumulator
    Add value  ${value}
&nbsp;
Then the accumulated value should be ${expected}
    Accumulator value should be  ${expected}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Test-driven development (TDD)</h2>

<p>Zkratkou <i>TDD</i> se označuje poměrně populární metodika vývoje softwaru,
v&nbsp;němž jsou jednotlivé kroky (typicky malé operace) definovány
s&nbsp;využitím testů, a to většinou jednotkových testů, ovšem může se jednat i
o testy komponent či dokonce o testy UI (to je ovšem méně flexibilní). Nejprve
jsou napsány tyto testy, které pochopitelně musí zhavarovat, protože vyžadovaná
funkcionalita neexistuje. Posléze vývojáři postupně doplní programový kód,
který se neustále testuje &ndash; tento proces je nedílnou součástí celého
vývoje a provádí se prakticky neustále, a to pochopitelně i před a po
refaktoringu. Touto metodikou se opět budeme podrobněji zabývat
v&nbsp;samostatném článku.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Acceptance test–driven development (ATDD)</h2>

<p>Podobně znějící zkratka <i>ATDD</i> znamená <i>Acceptance test–driven
development</i>. Opět se jedná o metodiku vývoje softwaru, tentokrát ovšem
postavenou na poměrně úzké spolupráci mezi vývojáři, zákazníky a testery (což
bývá velmi problematické :-). Využívá se zde například BDD a cílem je získat
přesnější informace o požadavcích zákazníka ještě předtím, než se začne ztrácet
drahý čas vývojem &ndash; mnoho problémů by se mělo objevit již při psaní
akceptačních testů popř.&nbsp;BDD. Teoreticky by se mělo jednat o ideální
postup, který ovšem nemusí být některou z&nbsp;participujících stran dobře
pochopen.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Použití knihovny unittest.mock (nejenom) při testování</h2>

<p>Při testování aplikací, zejména při psaní jednotkových testů (což je, jak
již ostatně víme, základ testovací pyramidy), se poměrně často dostaneme do
situace, kdy potřebujeme nahradit nějakou funkci, metodu nebo dokonce celou
třídu používanou v&nbsp;reálné aplikaci za &bdquo;falešnou&ldquo;
funkci/metodu/třídu vytvořenou pouze pro účely jednotkových testů.
V&nbsp;programovacím jazyku Python je možné pro tvorbu a použití takových
&bdquo;falešných&ldquo; bloků kódu použít hned několik různých knihoven, které
se od sebe odlišují jak svými možnostmi, tak i způsobem zápisu či deklarace
očekávaného chování testované aplikace. Určitým standardem v&nbsp;této oblasti
je v&nbsp;současnosti knihovna <i>unittest.mock</i>. Dnes si ukážeme některé
základní techniky, které nám tato knihovna poskytuje.</p>

<p>S&nbsp;následující situací se již setkal pravděpodobně každý vývojář
vytvářející jednotkové testy &ndash; je nutné otestovat funkcionalitu části
aplikace, v&nbsp;této části se však volá nějaká funkce nebo metoda provádějící
potenciálně destruktivní činnost (změna filesystému, vzdálené volání procedur,
programování zařízení připojeného přes USB atd.). Popř.&nbsp;se volá
funkce/metoda, která v&nbsp;závislosti na různých okolnostech vrací (minimálně
z&nbsp;pohledu testů) pseudonáhodná data. Takovou funkci/metodu by bylo vhodné
pro účely testování nahradit jednodušším kódem, jenž bude provádět předem
známou činnost, například bude za každých okolností pouze vracet určitou
hodnotu. Taková náhrada skutečných funkcí či metod za funkce/metody
&bdquo;falešné&ldquo; se (poněkud nepřesně) nazývá &bdquo;mockování&ldquo;
(<i>mocking</i>), a příslušný náhradní kód pak <i>test double</i>,
popř.&nbsp;podle funkce <i>fake</i>, <i>stub</i>, <i>spy</i> nebo <i>mock</i>.
V&nbsp;druhé části dnešního článku si ukážeme, jakým způsobem se může tato
technika použít v&nbsp;Pythonu, konkrétně v&nbsp;Pythonu řady 3.x.</p>

<p>V&nbsp;současnosti existuje relativně velké množství různých knihoven, které
mockování v&nbsp;Pythonu umožňují. Z&nbsp;nich jmenujme například velmi
zajímavý projekt <i>Flexmock</i>, který naleznete na adrese <a
href="https://pypi.python.org/pypi/flexmock">https://pypi.python.org/pypi/flexmock</a>.
Ovšem v&nbsp;Pythonu 3.x se standardem v&nbsp;této oblasti stala knihovna
nazvaná <a
href="https://docs.python.org/dev/library/unittest.mock.html">unittest.mock</a>.
V&nbsp;případě, že ještě z&nbsp;nějakého důvodu musíte používat Python 2.x,
použijte namísto knihovny <i>unittest.mock</i> knihovnu nazvanou jednoduše <a
href="https://pypi.python.org/pypi/mock">mock</a>. Tato knihovna nabízí
prakticky stejné možnosti jako <i>unittest.mock</i> (je ostatně založena na
stejném kódu, který pouze byl pro potřeby Pythonu 2.x upraven), ovšem lze ji
použít jak v&nbsp;Pythonu 2.x, tak i v&nbsp;Pythonu 3.x, a to bez toho, abyste
museli upravovat zdrojové kódy vašich testů (samozřejmě za předpokladu, že se
v&nbsp;nich nevyskytují konstrukce, které nejsou v&nbsp;Pythonu 2.x
podporovány). Další knihovny, které stojí za zmínku a které jsou potenciálně
užitečné, jsou zmíněny v&nbsp;další tabulce:</p>

<table>
<tr><th> #</th><th>Nástroj</th></tr>
<tr><td> 1</td><td>Ludibrio</td></tr>
<tr><td> 2</td><td>Python Mock</td></tr>
<tr><td> 3</td><td>PyMock</td></tr>
<tr><td> 4</td><td>mock</td></tr>
<tr><td> 5</td><td>pMock</td></tr>
<tr><td> 6</td><td>minimock</td></tr>
<tr><td> 7</td><td>svnmock</td></tr>
<tr><td> 8</td><td>Mocker</td></tr>
<tr><td> 9</td><td>Stubble</td></tr>
<tr><td>10</td><td>Mox</td></tr>
<tr><td>11</td><td>MockTest</td></tr>
<tr><td>12</td><td>Fudge</td></tr>
<tr><td>13</td><td>Mockito for Python</td></tr>
<tr><td>14</td><td>CaptureMock</td></tr>
<tr><td>15</td><td>flexmock</td></tr>
<tr><td>16</td><td>doublex</td></tr>
<tr><td>17</td><td>aspectlib</td></tr>
</table>

<p>Vraťme se však k&nbsp;základům jednotkových testů a mockování. Zmíněný
falešný blok kódu je možné podle jeho vlastností rozdělit do několika
kategorií:</p>

<ol>

<li><i>fake</i> &ndash; vrací jedinou programátorem zvolenou hodnotu. Příkladem
může být funkce nahrazující čtení z&nbsp;databáze, která vždy vrátí jediný
záznam.</li>

<li><i>stub</i> &ndash; již obsahuje jednoduchou logiku, například dokáže
reagovat na špatný vstup podobně, jako nahrazovaný blok.</li>

<li><i>spy</i> &ndash; dokáže zaznamenat předávané parametry či dokonce celý
stav (nebo podstav) aplikace.</li>

<li><i>mock</i> &ndash; mnohdy se jedná o blok s&nbsp;vlastnostmi, které se
přibližují reálnému (nahrazovanému) kódu. Vylepšená verze <i>stub</i>.</li>

</ol>

<p><div class="rs-tip-major">Poznámka: samotná knihovna <i>unittest.mock</i> je
obecná, takže mezi výše zmíněnými kategoriemi nijak nerozlišuje (a mnozí
programátoři také ne). I my budeme při popisech možností této knihovny mluvit o
&bdquo;mock objektech&ldquo;, ale až na základě jejich konkrétní implementace
se rozliší, zda se jedná o blok vracející jednu hodnotu, zda bude obsahovat
nějakou logiku, logování parametrů/stavů atd.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zdrojový soubor s&nbsp;funkcí, kterou budeme nahrazovat mock objektem</h2>

<p>Popis možností knihovny <strong>unittest.mock</strong> začneme na tom
nejjednodušším možném příkladu. Bude se jednat o aplikaci (či spíše
minimalistickou &bdquo;aplikaci&ldquo;) tvořenou pouhými dvěma zdrojovými
soubory <a
href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/application.py">application.py</a>
a <a
href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/main.py">main.py</a>.
První zmíněný soubor obsahuje jedinou funkci pojmenovanou
<strong>function1</strong>, která po svém zavolání nejprve vypíše na standardní
výstup text &bdquo;function1 called&ldquo; a následně vrátí do volajícího kódu
řetězec s&nbsp;obsahem &bdquo;tested function&ldquo;, jenž může být
v&nbsp;případě potřeby dále zpracován. Celý soubor se zdrojovým kódem má tedy
pouze několik řádků (funkce je volána ze skriptu <strong>main.py</strong>):</p>

<pre>
<i>"""Implementace logiky aplikace, kterou budeme testovat."""</i>
&nbsp;
&nbsp;
def <strong>function1</strong>():
    <i>"""Funkce, kterou v testech nahradíme mockem."""</i>
    print("function1 called")
    return "tested function"
</pre>

<p>Zavolání této aplikace je snadné a provede se, jak již víme, přes skript
<strong>main.py</strong>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
&nbsp;
<i>"""Vstupní bod do testované aplikace."""</i>
&nbsp;
from application import *
&nbsp;
&nbsp;
if __name__ == '__main__':
    <i># pouze zavoláme funkci, která se bude v testech mockovat</i>
    print(function1())
</pre>

<p>Následovně:</p>

<pre>
$ <strong>python3 main.py</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se o zcela umělý příklad, který má
jen jedinou přednost &ndash; je skutečně minimalistický, takže ukázka možností
knihovny <strong>unit.mock</strong> pravděpodobně bude poměrně názorná.
S&nbsp;reálnějšími příklady se seznámíme příště.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Test s&nbsp;volanou i s&nbsp;mockovanou funkcí</h2>

<p>Nyní se podívejme na to, jakým způsobem se může funkce nazvaná
<strong>function1</strong> volat a testovat v&nbsp;jednotkových testech. Pro
jednoduchost prozatím nepoužijeme žádný framework určený pro psaní jednotkových
testů (to bude téma pro samostatný článek), ale vytvoříme si jednoduchý pomocný
soubor nazvaný <a
href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/test.py">test.py</a>,
v&nbsp;němž se pokusíme zavolat jak původní funkci, tak i její
tzv.&nbsp;<i>mock</i> (&bdquo;falešnou&ldquo; variantu původní funkce). Na
začátku je nutné provést import modulu <strong>unittest.mock</strong> a
samozřejmě taktéž import testovaného modulu <strong>application</strong>:</p>

<pre>
from unittest.mock import *
&nbsp;
import application
</pre>

<p>První pseudotest bude jednoduchý &ndash; pouze v&nbsp;něm zavoláme původní
funkci a vypíšeme hodnotu, kterou tato funkce vrátí volajícímu kódu (zde se
žádné mockování neprování):</p>

<pre>
def <strong>test1</strong>():
    print(application.function1())
</pre>

<p><div class="rs-tip-major">Poznámka: právě na tomto místě by měly následovat
podmínky vyhodnocující návratovou hodnotu funkce, to, zda došlo k&nbsp;vyhození
výjimky atd.</div></p>

<p>Druhý pseudotest je již mnohem zajímavější, protože v&nbsp;něm namísto
původní funkce <strong>function1</strong> z&nbsp;modulu
<strong>application</strong> použijeme mock. Deklarace testovací funkce je
doplněna o anotaci <strong>@patch</strong>, v&nbsp;níž specifikujeme jméno
mockované funkce (ve formě řetězce, jehož obsah je kontrolován) a současně i
návratovou hodnotu. To je nutné, protože se původní funkce ve skutečnosti
<i>vůbec nezavolá</i>, ale návratovou hodnotu použijeme ve funkci
<strong>print</strong>:</p>

<pre>
@patch('application.function1', return_value=42)
def <strong>test2</strong>(mocked_function_object):
    print(application.function1())
</pre>

<p>Povšimněte si, že jméno mockované funkce je zapsáno i s&nbsp;uvedením
jmenného prostoru (&bdquo;application.function1&ldquo;), který ovšem musí
odpovídat kontextu, v&nbsp;němž se funkce volá! Právě uvedení správného
kontextu je pravděpodobně nejdůležitější část, kterou je nutné při mockování
pochopit (více viz navazující část tohoto miniseriálu). Navíc stojí za
povšimnutí, že se testovací funkci <strong>test2</strong> předává parametr
<strong>mocked_function_object</strong>, který představuje objekt udržující
informace o mocku. Tento objekt využijeme v&nbsp;dalších demonstračních
příkladech, nyní je však nutné si uvědomit, že se tento parametr plní
automaticky (při volání <strong>test2</strong> ho explicitně nebudeme uvádět
&ndash; ostatně v&nbsp;reálných jednotkových testech se bude tato funkce volat
automaticky).</p>

<p>Nyní již můžeme skript doplnit o kód, který všechny testy spustí. Povšimněte
si, že první test naschvál spouštíme dvakrát (na začátku a na konci), aby bylo
patrné, že mockovaná funkce se volá pouze v&nbsp;testu <strong>test2</strong>
(mockování je v&nbsp;tomto případě přísně lokální):</p>

<pre>
if __name__ == '__main__':
    test1()
    print()
&nbsp;
    test2()
    print()
&nbsp;
    test1()
    print()
</pre>

<p>Výsledek vypsaný po provedení skriptu potvrzuje, že při každém spuštění
testu <strong>test1</strong> se zavolá původní funkce, kdežto při spuštění
testu <strong>test2</strong> funkce mockovaná:</p>

<pre>
$ <strong>python3 test.py</strong>
&nbsp;
function1 called
tested function
&nbsp;
42
&nbsp;
function1 called
tested function
</pre>

<p><div class="rs-tip-major">Poznámka: náš mock pouze vrací hodnotu a nesnaží
se žádným způsobem napodobit logiku funkce (tedy výpis zprávy na standardní
výstup). Jedná se tedy o <i>fake double</i>.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Vytvoření handleru, který se zavolá namísto originální funkce</h2>

<p>Prozatím jsme se dozvěděli, jakým způsobem je možné nahradit volání skutečné
funkce vrácením nějaké předem nastavené hodnoty. Tato hodnota sice může být
prakticky jakákoli (číslo, pravdivostní hodnota, řetězec, pole, n-tice,
slovník, objekt, klidně i <strong>None</strong>), ovšem někdy si s&nbsp;tímto
chováním nevystačíme a budeme potřebovat, aby se namísto původní funkce
zavolala funkce odlišná; typicky mnohem jednodušší, s&nbsp;předvídatelnějšími
výsledky atd. Příkladem může být &bdquo;falešná&ldquo; funkce nahrazující čtení
záznamů z&nbsp;databáze za výběr hodnoty z&nbsp;předem známé datové struktury.
S&nbsp;využitím knihovny <strong>unittest.mock</strong> je nahrazení původní
funkce za její (ne)plnohodnotný mock snadné. Nejprve tuto funkci deklarujeme
(měla by akceptovat stejné parametry, jako funkce původní) a následně použijeme
v&nbsp;anotaci <strong>@patch</strong> nepovinný parametr
<strong>side_effect</strong>, kterému předáme referenci na mock:</p>

<pre>
def <strong>side_effect_handler</strong>():
    print("side_effect function called")
    return -1
&nbsp;
&nbsp;
@patch('application.function1', side_effect=side_effect_handler)
def <strong>test3</strong>(mocked_function_object):
    print(application.function1())
</pre>

<p>Pokud spustíme třetí test představovaný výše vypsanou funkcí
<strong>test3</strong> (a to opět BEZ parametrů):</p>

<pre>
test3()
</pre>

<p>zavolá se z&nbsp;něj ve skutečnosti funkce
<strong>side_effect_handler</strong> a nikoli
<strong>application.function1</strong>:</p>

<pre>
side_effect function called
-1
</pre>

<p><div class="rs-tip-major">Poznámka: takto vytvořený mock je opět použit jen
lokálně v&nbsp;rámci testu představovaného funkcí
<strong>test3</strong>.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Kombinace handleru s&nbsp;předkonfigurovanou návratovou hodnotou?</h2>

<p>Podívejme se ještě, co se stane ve chvíli, kdy v&nbsp;anotaci
<strong>@patch</strong> současně použijeme parametr
<strong>return_value</strong> i <strong>side_effect</strong>. Zápis bude
vypadat následovně:</p>

<pre>
def <strong>side_effect_handler</strong>():
    print("side_effect function called")
    return -1
&nbsp;
@patch('application.function1', return_value=42, side_effect=side_effect_handler)
def <strong>test4</strong>(mocked_function_object):
    print(application.function1())
</pre>

<p>V&nbsp;případě, že zavoláme výše vypsanou testovací funkci
<strong>test4</strong>, vypíšou se na standardní výstup následující dva řádky,
z&nbsp;nichž je patrné, že se hodnota specifikovaná parametrem
<strong>return_value</strong> ignorovala a namísto ní se použila návratová
hodnota &bdquo;falešné&ldquo; funkce <strong>side_effect_handler</strong>:</p>

<pre>
side_effect function called
-1
</pre>

<p>Toto chování se ale změní ve chvíli, kdy mock vrátí speciální hodnotu
<strong>unittest.mock.DEFAULT</strong> (přesněji řečeno
<strong>sentinel.DEFAULT</strong>). V&nbsp;takovém případě se skutečně využije
hodnota zapsaná v&nbsp;parametru <strong>return_value</strong> v&nbsp;anotaci
<strong>@patch</strong>, o čemž se lze ostatně velmi snadno přesvědčit:</p>

<pre>
def <strong>side_effect_handler_2</strong>():
    print("side_effect function called")
    return DEFAULT
&nbsp;
&nbsp;
@patch('application.function1', return_value=42, side_effect=side_effect_handler_2)
def <strong>test5</strong>(mocked_function_object):
    print(application.function1())
</pre>

<p>Výsledek zavolání výše vypsané testovací funkce <strong>test5</strong>:</p>

<pre>
side_effect function called
42
</pre>

<p>Díky tomuto chování je možné použít &bdquo;falešnou&ldquo; funkci ve větším
množství testů, což je téma, kterým se budeme podrobněji zabývat příště.</p>

<p>Pro přehlednost je v&nbsp;této kapitole vypsán úplný zdrojový kód dnešního
<a
href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/">druhého
demonstračního příkladu</a> rozděleného do dvou modulů.</p>

<h3>Soubor <strong>application.py</strong> s&nbsp;testovanou funkcí</h3>

<pre>
<i>"""Implementace logiky aplikace, kterou budeme testovat."""</i>
&nbsp;
&nbsp;
def <strong>function1</strong>():
    <i>"""Funkce, kterou v testech nahradíme mockem."""</i>
    print("function1 called")
    return "tested function"
</pre>

<h3>Soubor <strong>test.py</strong> s&nbsp;testy</h3>

<pre>
<i>"""Implementace (umělých) jednotkových testů."""</i>
&nbsp;
from unittest.mock import *
&nbsp;
import application
&nbsp;
&nbsp;
def <strong>test1</strong>():
    <i>"""První test neprovádí prakticky žádné reálné kontroly, jen zavolá testovanou funkci."""</i>
    print(application.function1())
&nbsp;
&nbsp;
@patch('application.function1', return_value=42)
def <strong>test2</strong>(mocked_function):
    <i>"""Druhý test používá fake test double - náhradu volané funkce."""</i>
    print(application.function1())
&nbsp;
&nbsp;
def <strong>side_effect_handler</strong>():
    <i>"""Implementace handleru - stub funkce nahrazované mockem."""</i>
    print("side_effect function called")
    return -1
&nbsp;
&nbsp;
@patch('application.function1', side_effect=side_effect_handler)
def <strong>test3</strong>(mocked_function):
    <i>"""Druhý test používá stub test double - náhradu volané funkce."""</i>
    print(application.function1())
&nbsp;
&nbsp;
@patch('application.function1', return_value=42, side_effect=side_effect_handler)
def <strong>test4</strong>(mocked_function):
    <i>"""Čtvrtý test se snaží zkombinovat fake a stub."""</i>
    print(application.function1())
&nbsp;
&nbsp;
def <strong>side_effect_handler_2</strong>():
    <i>"""Implementace handleru - stub funkce nahrazované mockem, který ovšem ovlivňuje chování testu."""</i>
    print("side_effect function called")
    return DEFAULT
&nbsp;
&nbsp;
@patch('application.function1', return_value=42, side_effect=side_effect_handler_2)
def <strong>test5</strong>(mocked_function):
    <i>"""Čtvrtý test se opět snaží zkombinovat fake a stub."""</i>
    print(application.function1())
&nbsp;
&nbsp;
if __name__ == '__main__':
    print("*** test1 ***")
    test1()
    print()
&nbsp;
    print("*** test2 ***")
    test2()
    print()
&nbsp;
    print("*** test3 ***")
    test3()
    print()
&nbsp;
    print("*** test4 ***")
    test4()
    print()
&nbsp;
    print("*** test5 ***")
    test5()
    print()
&nbsp;
    print("*** test1 ***")
    test1()
    print()
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Obsah následující části seriálu</h2>

<p>V&nbsp;navazujícím článku si ukážeme některé další možnosti, které nám
Python a jeho knihovny a frameworky nabízí v&nbsp;oblasti jednotkových testů
(včetně možnosti selektivního spouštění benchmarků). Podíváme se i na způsob
spouštění jednotkových testů v&nbsp;k&nbsp;tomu určených prostředích (Jenkins,
Travis CI) apod.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
nového Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/testing-in-python">https://github.com/tisnik/testing-in-python</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem &ndash;
alespoň prozatím &ndash; velmi malý, dnes má přibližně deseti kilobajtů),
můžete namísto toho použít odkazy na jednotlivé demonstrační příklady a jejich
části, které naleznete v&nbsp;následující tabulce:</p>

https://github.com/tisnik/testing-in-python/blob/master/

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>application.py</td><td>implementace mockované funkce</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/application.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/application.py</a></td></tr>
<tr><td> 2</td><td>main.py</td><td>vstupní bod do testované aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/main.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/main.py</a></td></tr>
<tr><td> 3</td><td>test.py</td><td>implementace jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/test.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/test.py</a></td></tr>
<tr><td> 4</td><td>run</td><td>skript pro spuštění aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/run">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/run</a></td></tr>
<tr><td> 5</td><td>test</td><td>skript pro spuštění jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/test">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test1/test</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>application.py</td><td>implementace mockované funkce</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/application.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/application.py</a></td></tr>
<tr><td> 7</td><td>main.py</td><td>vstupní bod do testované aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/main.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/main.py</a></td></tr>
<tr><td> 8</td><td>test.py</td><td>implementace jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/test.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/test.py</a></td></tr>
<tr><td> 9</td><td>run</td><td>skript pro spuštění aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/run">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/run</a></td></tr>
<tr><td>10</td><td>test</td><td>skript pro spuštění jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/test">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test2/test</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články s&nbsp;tématem testování (nejenom) v&nbsp;Pythonu</h2>

<p>Tématem testování jsme se již na stránkách Rootu několikrát zabývali. Jedná
se mj.&nbsp;o následující články:</p>

<ol>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave (druhá část)<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-druha-cast/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-druha-cast/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave (závěrečná část)<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-zaverecna-cast/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-zaverecna-cast/</a>
</li>

<li>Validace datových struktur v Pythonu pomocí knihoven Schemagic a Schema<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/</a>
</li>

<li>Validace datových struktur v Pythonu (2. část)<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-2-cast/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-2-cast/</a>
</li>

<li>Validace datových struktur v Pythonu (dokončení)<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-dokonceni/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-dokonceni/</a>
</li>

<li>Univerzální testovací nástroj Robot Framework<br />
<a href="https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework/">https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework/</a>
</li>

<li>Univerzální testovací nástroj Robot Framework a BDD testy<br />
<a href="https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework-a-bdd-testy/">https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework-a-bdd-testy/</a>
</li>

<li>Úvod do problematiky fuzzingu a fuzz testování<br />
<a href="https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani/">https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani/</a>
</li>

<li>Úvod do problematiky fuzzingu a fuzz testování – složení vlastního fuzzeru<br />
<a href="https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani-slozeni-vlastniho-fuzzeru/">https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani-slozeni-vlastniho-fuzzeru/</a>
</li>

<li>Knihovny a moduly usnadňující testování aplikací naprogramovaných v jazyce Clojure<br />
<a href="https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/">https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/</a>
</li>

<li>Validace dat s využitím knihovny spec v Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

<li>Testování aplikací naprogramovaných v jazyce Go<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/">https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/</a>
</li>

<li>Knihovny určené pro tvorbu testů v programovacím jazyce Go<br />
<a href="https://www.root.cz/clanky/knihovny-urcene-pro-tvorbu-testu-v-programovacim-jazyce-go/">https://www.root.cz/clanky/knihovny-urcene-pro-tvorbu-testu-v-programovacim-jazyce-go/</a>
</li>

<li>Testování aplikací psaných v Go s využitím knihoven Goblin a Frisby<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/">https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/</a>
</li>

<li>Testování Go aplikací s využitím knihovny GΩmega a frameworku Ginkgo<br />
<a href="https://www.root.cz/clanky/testovani-go-aplikaci-s-vyuzitim-knihovny-gomega-mega-a-frameworku-ginkgo/">https://www.root.cz/clanky/testovani-go-aplikaci-s-vyuzitim-knihovny-gomega-mega-a-frameworku-ginkgo/</a>
</li>

<li>Tvorba BDD testů s využitím jazyka Go a nástroje godog<br />
<a href="https://www.root.cz/clanky/tvorba-bdd-testu-s-vyuzitim-jazyka-go-a-nastroje-godog/">https://www.root.cz/clanky/tvorba-bdd-testu-s-vyuzitim-jazyka-go-a-nastroje-godog/</a>
</li>

<li>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem<br />
<a href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/">https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/</a>
</li>

<li>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem (dokončení)<br />
<a href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem-dokonceni/">https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem-dokonceni/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure (2)<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Awesome Python &ndash; testing<br />
<a href="https://github.com/vinta/awesome-python#testing">https://github.com/vinta/awesome-python#testing</a>
</li>

<li>Selenium (pro Python)<br />
<a href="https://pypi.org/project/selenium/">https://pypi.org/project/selenium/</a>
</li>

<li>Getting Started With Testing in Python<br />
<a href="https://realpython.com/python-testing/">https://realpython.com/python-testing/</a>
</li>

<li>unittest.mock — mock object library<br />
<a href="https://docs.python.org/3.5/library/unittest.mock.html">https://docs.python.org/3.5/library/unittest.mock.html</a>
</li>

<li>mock 2.0.0<br />
<a href="https://pypi.python.org/pypi/mock">https://pypi.python.org/pypi/mock</a>
</li>

<li>An Introduction to Mocking in Python<br />
<a href="https://www.toptal.com/python/an-introduction-to-mocking-in-python">https://www.toptal.com/python/an-introduction-to-mocking-in-python</a>
</li>

<li>Mock - Mocking and Testing Library<br />
<a href="http://mock.readthedocs.io/en/stable/">http://mock.readthedocs.io/en/stable/</a>
</li>

<li>Python Mocking 101: Fake It Before You Make It<br />
<a href="https://blog.fugue.co/2016-02-11-python-mocking-101.html">https://blog.fugue.co/2016-02-11-python-mocking-101.html</a>
</li>

<li>Nauč se Python! - Testování<br />
<a href="http://naucse.python.cz/lessons/intro/testing/">http://naucse.python.cz/lessons/intro/testing/</a>
</li>

<li>Flexmock (dokumentace)<br />
<a href="https://flexmock.readthedocs.io/en/latest/">https://flexmock.readthedocs.io/en/latest/</a>
</li>

<li>Test Fixture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test_fixture">https://en.wikipedia.org/wiki/Test_fixture</a>
</li>

<li>Mock object (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Mock_object">https://en.wikipedia.org/wiki/Mock_object</a>
</li>

<li>Extrémní programování<br />
<a href="https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD">https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD</a>
</li>

<li>Programování řízené testy<br />
<a href="https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy">https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>Tox<br />
<a href="https://tox.readthedocs.io/en/latest/">https://tox.readthedocs.io/en/latest/</a>
</li>

<li>pytest: helps you write better programs<br />
<a href="https://docs.pytest.org/en/latest/">https://docs.pytest.org/en/latest/</a>
</li>

<li>doctest — Test interactive Python examples<br />
<a href="https://docs.python.org/dev/library/doctest.html#module-doctest">https://docs.python.org/dev/library/doctest.html#module-doctest</a>
</li>

<li>unittest — Unit testing framework<br />
<a href="https://docs.python.org/dev/library/unittest.html">https://docs.python.org/dev/library/unittest.html</a>
</li>

<li>Python namespaces<br />
<a href="https://bytebaker.com/2008/07/30/python-namespaces/">https://bytebaker.com/2008/07/30/python-namespaces/</a>
</li>

<li>Namespaces and Scopes<br />
<a href="https://www.python-course.eu/namespaces.php">https://www.python-course.eu/namespaces.php</a>
</li>

<li>Stránka projektu Robot Framework<br />
<a href="https://robotframework.org/">https://robotframework.org/</a>
</li>

<li>GitHub repositář Robot Frameworku<br />
<a href="https://github.com/robotframework/robotframework">https://github.com/robotframework/robotframework</a>
</li>

<li>Robot Framework (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Robot_Framework">https://en.wikipedia.org/wiki/Robot_Framework</a>
</li>

<li>Tutoriál Robot Frameworku<br />
<a href="http://www.robotframeworktutorial.com/">http://www.robotframeworktutorial.com/</a>
</li>

<li>Robot Framework Documentation<br />
<a href="https://robotframework.org/robotframework/">https://robotframework.org/robotframework/</a>
</li>

<li>Robot Framework Introduction<br />
<a href="https://blog.testproject.io/2016/11/22/robot-framework-introduction/">https://blog.testproject.io/2016/11/22/robot-framework-introduction/</a>
</li>

<li>robotframework 3.1.2 na PyPi<br />
<a href="https://pypi.org/project/robotframework/">https://pypi.org/project/robotframework/</a>
</li>

<li>Robot Framework demo (GitHub)<br />
<a href="https://github.com/robotframework/RobotDemo">https://github.com/robotframework/RobotDemo</a>
</li>

<li>Robot Framework web testing demo using SeleniumLibrary<br />
<a href="https://github.com/robotframework/WebDemo">https://github.com/robotframework/WebDemo</a>
</li>

<li>Robot Framework for Mobile Test Automation Demo<br />
<a href="https://www.youtube.com/watch?v=06LsU08slP8">https://www.youtube.com/watch?v=06LsU08slP8</a>
</li>

<li>Gherkin<br />
<a href="https://cucumber.io/docs/gherkin/">https://cucumber.io/docs/gherkin/</a>
</li>

<li>Selenium<br />
<a href="https://selenium.dev/">https://selenium.dev/</a>
</li>

<li>SeleniumLibrary<br />
<a href="https://robotframework.org/">https://robotframework.org/</a>
</li>

<li>The Practical Test Pyramid<br />
<a href="https://martinfowler.com/articles/practical-test-pyramid.html">https://martinfowler.com/articles/practical-test-pyramid.html</a>
</li>

<li>Acceptance Tests and the Testing Pyramid<br />
<a href="http://www.blog.acceptancetestdrivendevelopment.com/acceptance-tests-and-the-testing-pyramid/">http://www.blog.acceptancetestdrivendevelopment.com/acceptance-tests-and-the-testing-pyramid/</a>
</li>

<li>Tab-separated values<br />
<a href="https://en.wikipedia.org/wiki/Tab-separated_values">https://en.wikipedia.org/wiki/Tab-separated_values</a>
</li>

<li>A quick guide about Python implementations<br />
<a href="https://blog.rmotr.com/a-quick-guide-about-python-implementations-aa224109f321">https://blog.rmotr.com/a-quick-guide-about-python-implementations-aa224109f321</a>
</li>

<li>radamsa<br />
<a href="https://gitlab.com/akihe/radamsa">https://gitlab.com/akihe/radamsa</a>
</li>

<li>Fuzzing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Fuzzing">https://en.wikipedia.org/wiki/Fuzzing</a>
</li>

<li>american fuzzy lop<br />
<a href="http://lcamtuf.coredump.cx/afl/">http://lcamtuf.coredump.cx/afl/</a>
</li>

<li>Fuzzing: the new unit testing<br />
<a href="https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide#1">https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide#1</a>
</li>

<li>Corpus for github.com/dvyukov/go-fuzz examples<br />
<a href="https://github.com/dvyukov/go-fuzz-corpus">https://github.com/dvyukov/go-fuzz-corpus</a>
</li>

<li>AFL &ndash; QuickStartGuide.txt<br />
<a href="https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt">https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt</a>
</li>

<li>Introduction to Fuzzing in Python with AFL<br />
<a href="https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/">https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/</a>
</li>

<li>Writing a Simple Fuzzer in Python<br />
<a href="https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/">https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/</a>
</li>

<li>How to Fuzz Go Code with go-fuzz (Continuously)<br />
<a href="https://fuzzit.dev/2019/10/02/how-to-fuzz-go-code-with-go-fuzz-continuously/">https://fuzzit.dev/2019/10/02/how-to-fuzz-go-code-with-go-fuzz-continuously/</a>
</li>

<li>Golang Fuzzing: A go-fuzz Tutorial and Example<br />
<a href="http://networkbit.ch/golang-fuzzing/">http://networkbit.ch/golang-fuzzing/</a>
</li>

<li>Fuzzing Python Modules<br />
<a href="https://stackoverflow.com/questions/20749026/fuzzing-python-modules">https://stackoverflow.com/questions/20749026/fuzzing-python-modules</a>
</li>

<li>0x3 Python Tutorial: Fuzzer<br />
<a href="http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/">http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/</a>
</li>

<li>fuzzing na PyPi<br />
<a href="https://pypi.org/project/fuzzing/">https://pypi.org/project/fuzzing/</a>
</li>

<li>Fuzzing 0.3.2 documentation<br />
<a href="https://fuzzing.readthedocs.io/en/latest/">https://fuzzing.readthedocs.io/en/latest/</a>
</li>

<li>Randomized testing for Go<br />
<a href="https://github.com/dvyukov/go-fuzz">https://github.com/dvyukov/go-fuzz</a>
</li>

<li>HTTP/2 fuzzer written in Golang<br />
<a href="https://github.com/c0nrad/http2fuzz">https://github.com/c0nrad/http2fuzz</a>
</li>

<li>Ffuf (Fuzz Faster U Fool) – An Open Source Fast Web Fuzzing Tool<br />
<a href="https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html">https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html</a>
</li>

<li>Continuous Fuzzing Made Simple<br />
<a href="https://fuzzit.dev/">https://fuzzit.dev/</a>
</li>

<li>Halt and Catch Fire<br />
<a href="https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86">https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86</a>
</li>

<li>Random testing<br />
<a href="https://en.wikipedia.org/wiki/Random_testing">https://en.wikipedia.org/wiki/Random_testing</a>
</li>

<li>Monkey testing<br />
<a href="https://en.wikipedia.org/wiki/Monkey_testing">https://en.wikipedia.org/wiki/Monkey_testing</a>
</li>

<li>Fuzzing for Software Security Testing and Quality Assurance, Second Edition<br />
<a href="https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false">https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false</a>
</li>

<li>libFuzzer – a library for coverage-guided fuzz testing<br />
<a href="https://llvm.org/docs/LibFuzzer.html">https://llvm.org/docs/LibFuzzer.html</a>
</li>

<li>fuzzy-swagger na PyPi<br />
<a href="https://pypi.org/project/fuzzy-swagger/">https://pypi.org/project/fuzzy-swagger/</a>
</li>

<li>fuzzy-swagger na GitHubu<br />
<a href="https://github.com/namuan/fuzzy-swagger">https://github.com/namuan/fuzzy-swagger</a>
</li>

<li>Fuzz testing tools for Python<br />
<a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy#Fuzz_Testing_Tools">https://wiki.python.org/moin/PythonTestingToolsTaxonomy#Fuzz_Testing_Tools</a>
</li>

<li>A curated list of awesome Go frameworks, libraries and software<br />
<a href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go</a>
</li>

<li>gofuzz: a library for populating go objects with random values<br />
<a href="https://github.com/google/gofuzz">https://github.com/google/gofuzz</a>
</li>

<li>tavor: A generic fuzzing and delta-debugging framework<br />
<a href="https://github.com/zimmski/tavor">https://github.com/zimmski/tavor</a>
</li>

<li>hypothesis na GitHubu<br />
<a href="https://github.com/HypothesisWorks/hypothesis">https://github.com/HypothesisWorks/hypothesis</a>
</li>

<li>Hypothesis: Test faster, fix more<br />
<a href="https://hypothesis.works/">https://hypothesis.works/</a>
</li>

<li>Hypothesis<br />
<a href="https://hypothesis.works/articles/intro/">https://hypothesis.works/articles/intro/</a>
</li>

<li>What is Hypothesis?<br />
<a href="https://hypothesis.works/articles/what-is-hypothesis/">https://hypothesis.works/articles/what-is-hypothesis/</a>
</li>

<li>Databáze CVE<br />
<a href="https://www.cvedetails.com/">https://www.cvedetails.com/</a>
</li>

<li>Fuzz test Python modules with libFuzzer<br />
<a href="https://github.com/eerimoq/pyfuzzer">https://github.com/eerimoq/pyfuzzer</a>
</li>

<li>Taof - The art of fuzzing<br />
<a href="https://sourceforge.net/projects/taof/">https://sourceforge.net/projects/taof/</a>
</li>

<li>JQF + Zest: Coverage-guided semantic fuzzing for Java<br />
<a href="https://github.com/rohanpadhye/jqf">https://github.com/rohanpadhye/jqf</a>
</li>

<li>http2fuzz<br />
<a href="https://github.com/c0nrad/http2fuzz">https://github.com/c0nrad/http2fuzz</a>
</li>

<li>Demystifying hypothesis testing with simple Python examples<br />
<a href="https://towardsdatascience.com/demystifying-hypothesis-testing-with-simple-python-examples-4997ad3c5294">https://towardsdatascience.com/demystifying-hypothesis-testing-with-simple-python-examples-4997ad3c5294</a>
</li>

<li>Testování<br />
<a href="http://voho.eu/wiki/testovani/">http://voho.eu/wiki/testovani/</a>
</li>

<li>Unit testing (Wikipedia.en)<br />
<a href="https://en.wikipedia.org/wiki/Unit_testing">https://en.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit testing (Wikipedia.cz)<br />
<a href="https://cs.wikipedia.org/wiki/Unit_testing">https://cs.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit Test vs Integration Test<br />
<a href="https://www.youtube.com/watch?v=0GypdsJulKE">https://www.youtube.com/watch?v=0GypdsJulKE</a>
</li>

<li>TestDouble<br />
<a href="https://martinfowler.com/bliki/TestDouble.html">https://martinfowler.com/bliki/TestDouble.html</a>
</li>

<li>Test Double<br />
<a href="http://xunitpatterns.com/Test%20Double.html">http://xunitpatterns.com/Test%20Double.html</a>
</li>

<li>Test-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test-driven_development">https://en.wikipedia.org/wiki/Test-driven_development</a>
</li>

<li>Acceptance test–driven development<br />
<a href="https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development">https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development</a>
</li>

<li>Gauge<br />
<a href="https://gauge.org/">https://gauge.org/</a>
</li>

<li>Gauge (software)<br />
<a href="https://en.wikipedia.org/wiki/Gauge_(software)">https://en.wikipedia.org/wiki/Gauge_(software)</a>
</li>

<li>PYPL PopularitY of Programming Language<br />
<a href="https://pypl.github.io/PYPL.html">https://pypl.github.io/PYPL.html</a>
</li>

<li>Testing is Good. Pyramids are Bad. Ice Cream Cones are the Worst<br />
<a href="https://medium.com/@fistsOfReason/testing-is-good-pyramids-are-bad-ice-cream-cones-are-the-worst-ad94b9b2f05f">https://medium.com/@fistsOfReason/testing-is-good-pyramids-are-bad-ice-cream-cones-are-the-worst-ad94b9b2f05f</a>
</li>

<li>Články a zprávičky věnující se Pythonu<br />
<a href="https://www.root.cz/n/python/">https://www.root.cz/n/python/</a>
</li>

<li>PythonTestingToolsTaxonomy<br />
<a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy">https://wiki.python.org/moin/PythonTestingToolsTaxonomy</a>
</li>

<li>Top 6 BEST Python Testing Frameworks [Updated 2020 List]<br />
<a href="https://www.softwaretestinghelp.com/python-testing-frameworks/">https://www.softwaretestinghelp.com/python-testing-frameworks/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

