<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Testování webových aplikací s REST API z Pythonu (3)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Testování webových aplikací s REST API z Pythonu (3)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve třetím článku o testování webových aplikací s REST API z Pythonu konečně dojde ke spojení dvou technologií, které již známe: frameworku Pytest a knihovny Requests. Uvidíme, že psaní testů s využitím těchto dvou technologií je snadné a poměrně rychlé.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Testování webových aplikací s&nbsp;REST API z&nbsp;Pythonu (3)</a></p>
<p><a href="#k02">2. Poslání požadavku s&nbsp;využitím HTTP metody GET</a></p>
<p><a href="#k03">3. Otestování, zda byla odpověď poslána s&nbsp;očekávaným HTTP kódem</a></p>
<p><a href="#k04">4. Příprava funkcí pro knihovnu určenou pro testování REST API</a></p>
<p><a href="#k05">5. Kontrola hlavičky nebo hlaviček vrácených serverem v&nbsp;odpovědi</a></p>
<p><a href="#k06">6. Samostatná funkce pro otestování typu odpovědi</a></p>
<p><a href="#k07">7. Test, zda server poslal rastrové obrázky či podobná data</a></p>
<p><a href="#k08">8. Otestování těla odpovědi</a></p>
<p><a href="#k09">9. Zpracování a otestování odpovědi serveru ve formátu JSON</a></p>
<p><a href="#k10">10. Výběr atributů s&nbsp;využitím DSL</a></p>
<p><a href="#k11">11. Otestování REST API endpointu dostupného přes HTTP metodu POST</a></p>
<p><a href="#k12">12. Zaslání dat na server s&nbsp;využitím metody POST</a></p>
<p><a href="#k13">13. Předání dat serveru v&nbsp;těle HTTP požadavku typu POST</a></p>
<p><a href="#k14">14. Předání cookies v&nbsp;požadavku a test dat vrácených v&nbsp;odpovědi serveru</a></p>
<p><a href="#k15">15. Správa sezení s&nbsp;využitím cookies</a></p>
<p><a href="#k16">16. Kontrola složitějších datových struktur vracených serverem</a></p>
<p><a href="#k17">17. Zpracování XML a HTML v&nbsp;Pythonu s&nbsp;využitím knihovny lxml</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Předchozí články s&nbsp;tématem testování (nejenom) v&nbsp;Pythonu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Testování webových aplikací s&nbsp;REST API z&nbsp;Pythonu (3)</h2>

<p>Na předchozí dva články [<a
href="https://www.root.cz/clanky/testovani-webovych-aplikaci-s-rest-api-z-pythonu/">1</a>]
[<a
href="https://www.root.cz/clanky/testovani-webovych-aplikaci-s-rest-api-z-pythonu-2/">2</a>]
dnes navážeme, protože si ukážeme, jakým způsobem je možné využít knihovnu
<i>Requests</i> společně s&nbsp;frameworkem <i>Pytest</i>, jehož základní
možnosti jsme si již taktéž popsali v&nbsp;[<a
href="https://www.root.cz/clanky/pouziti-nastroje-pytest-pro-tvorbu-jednotkovych-testu-a-benchmarku/">3</a>]
[<a
href="https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-fixtures-vyjimky-parametrizace-testu/">4</a>]
a [<a
href="https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-zivotni-cyklus-testu-uzitecne-tipy-a-triky/">5</a>].
Sice by se mohlo zdát, že <i>Pytest</i> je určen pouze pro psaní jednotkových
testů (což je skutečně jeho primárním účelem), ovšem ve skutečnosti nám nikdo
nebrání v&nbsp;tom použít tento velmi užitečný nástroj i pro testy integrační
popř.&nbsp;konkrétně pro vytváření testů REST API.</p>

<p><div class="rs-tip-major">Poznámka: na druhou stranu některé pluginy pro
Pytest, například plugin pro zjištění pokrytí kódu jednotkovými testy,
přestanou mít význam.</div></p>

<p>Teoreticky si v&nbsp;mnoha případech nasazení REST API testů skutečně
vystačíme pouze s&nbsp;dvojicí <i>Requests+Pytest</i>, ovšem dále uvidíme, že
může být velmi výhodné začít používat i další nástroje, které například
umožňují automatické či poloautomatické vytváření testů na základě specifikace
<i>OpenAPI</i> resp.&nbsp;<i>Swaggeru</i>. Toto téma je velmi zajímavé
především u těch služeb, které mají rozsáhlé REST API, tj.&nbsp;obsahují mnoho
koncových bodů, každý s&nbsp;několika HTTP metodami, mnoha parametry atd.</p>

<p><div class="rs-tip-major">Poznámka: samozřejmě je dobré si položit otázku,
jestli je takové &bdquo;barokní&ldquo; REST API vůbec korektní či alespoň
vhodné používat ve světě mikroslužeb; na druhou stranu mnohdy nemá tester
možnost zasahovat do architektury již vytvořené aplikace</div></p>.</p>

<p>V&nbsp;závěru článku se ve stručnosti zmíníme o tom, jak je možné testovat
složitější datové struktury vracené v&nbsp;REST API odpovědích popř.&nbsp;jak
lze testovat XML popř.&nbsp;přímo HTML stránky (či jejich fragmenty), které
jsou serverem vraceny v&nbsp;HTTP odpovědích.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Poslání požadavku s&nbsp;využitím HTTP metody GET</h2>

<p>Začněme velmi jednoduchým demonstračním příkladem, v&nbsp;němž pouze pošleme
HTTP požadavek (<i>request</i>) na server s&nbsp;REST API rozhraním a
zkontrolujeme a poté provedeme &bdquo;dummy&ldquo; test na existenci objektu
typu <strong>response</strong> (ten se ve skutečnosti vrátí za všech okolností,
protože v&nbsp;opačném případě by nastala výjimka, která by byla vyhozena a
následně zachycena samotným <i>Pytestem</i> ještě předtím, než by se došlo
k&nbsp;příkazu <strong>assert</strong>). V&nbsp;tomto demonstračním příkladu se
tedy neprovádí žádné reálné testy, pouze si ukazujeme, jak vypadá typická
funkce (nebo i metoda) s&nbsp;implementací REST API testů:</p>

<ol>

<li>Její jméno začíná prefixem &bdquo;test_&ldquo;</li>

<li>Uvnitř funkce/metody se typicky nachází sekvence příkazů (řídicích
konstrukcí) <strong>assert</strong>.</li>

<li>Alternativně je možné namísto příkazu <strong>assert</strong> využít
pomocné metody z&nbsp;testovacího frameworku <a
href="https://docs.python.org/3/library/unittest.html">unittest</a>, které jsou
vypsány <a
href="https://kapeli.com/cheat_sheets/Python_unittest_Assertions.docset/Contents/Resources/Documents/index">zde</a>.</li>

</ol>

<p>Úplný zdrojový kód tohoto demonstračního příkladu naleznete na adrese <a
href="https://github.com/tisnik/testing-in-python/blob/master/requests/tests/01_basic_usage_test.py">https://github.com/tisnik/testing-in-python/blob/master/requests/tests/01_basic_usage_test.py</a>
a vypadá následovně:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import requests
&nbsp;
&nbsp;
def <strong>test_get_method_for_existing_endpoint</strong>():
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/get"
&nbsp;
    <i># poslani HTTP dotazu typu GET</i>
    response = requests.get(URL)
&nbsp;
    <u>assert</u> response is not None
&nbsp;
&nbsp;
def <strong>test_get_method_for_missing_endpoint</strong>():
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/neexistuje"
&nbsp;
    <i># poslani HTTP dotazu typu GET</i>
    response = requests.get(URL)
&nbsp;
    <u>assert</u> response is not None
</pre>

<p>Vzhledem k&nbsp;tomu, že se jedná o korektně napsané testovací funkce
spustitelné nástrojem <i>Pytest</i>, můžeme si chování snadno otestovat:</p>

<pre>
$ <strong>pytest -v 01_basic_usage_test.py</strong>
&nbsp;
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/requests/tests
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 2 items
&nbsp;
01_basic_usage_test.py::test_get_method_for_existing_endpoint PASSED     [ 50%]
01_basic_usage_test.py::test_get_method_for_missing_endpoint PASSED      [100%]
&nbsp;
============================== 2 passed in 0.71s ===============================
</pre>

<p><div class="rs-tip-major">Poznámka: vzhledem k&nbsp;tomu, že je příkaz
<strong>assert</strong> nejdůležitější částí testů (ostatní příkazy jsou
z&nbsp;tohoto pohledu jen pomocné), je ve všech zdrojových kódech zvýrazněn
<u>podtrženým písmem</u>.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Otestování, zda byla odpověď poslána s&nbsp;očekávaným HTTP kódem</h2>

<p>Z&nbsp;předchozích článků již víme, že stavový kód odpovědi serveru je
reprezentován celým číslem, přičemž z&nbsp;první číslice (stovky) lze odvodit
základní vlastnost stavu (úspěch, chyba, přesměrování...):</p>

<table>
<tr><th>Skupina stavových kódů</th><th>Význam</th></tr>
<tr><td>1xx</td><td>informační, potvrzení atd. (ovšem požadavek se prozatím nevykonal)</td></tr>
<tr><td>2xx</td><td>úspěšné vyřízení požadavku popř.&nbsp;jeho akceptace serverem (202)</td></tr>
<tr><td>3xx</td><td>přesměrování požadavku, informace o tom, že se objekt nezměnil atd.</td></tr>
<tr><td>4xx</td><td>různé typy chyb typicky zaviněných klientem (bohužel nejrozsáhlejší skupina)</td></tr>
<tr><td>5xx</td><td>různé chyby na serveru</td></tr>
</table>

<p>Pokud budeme dotaz posílat s&nbsp;využitím knihovny <i>Requests</i>, je
možné ke stavovému kódu přistupovat přes objekt typu <strong>Response</strong>,
představujícího odpověď serveru. Číselný kód stavu uložen v&nbsp;atributu
pojmenovaném <strong>status_code</strong>. Kromě toho existuje ještě atribut
nazvaný <strong>ok</strong>, který obsahuje pravdivostní hodnotu
<strong>True</strong> v&nbsp;případě, že je číselný kód stavu menší než 400 a
hodnotu <strong>False</strong> v&nbsp;opačném případě. Obě tyto hodnoty
pochopitelně můžeme snadno otestovat:</p>

<pre>
<u>assert</u> response.ok
<u>assert</u> response.status_code == 200
</pre>

<p>Tento typ testů je ukázán ve druhém demonstračním příkladu, který zjistí,
zda je možný přístup na existující URL i na neexistující koncový bod. Úplný
zdrojový kód tohoto demonstračního příkladu lze nalézt na adrese <a
href="https://github.com/tisnik/testing-in-python/blob/master/requests/tests/02_check_status_test.py">https://github.com/tisnik/testing-in-python/blob/master/requests/tests/02_check_status_test.py</a>
a vypadá následovně:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import requests
&nbsp;
&nbsp;
def <strong>test_get_method_for_existing_endpoint</strong>():
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/get"
&nbsp;
    <i># poslani HTTP dotazu typu GET</i>
    response = requests.get(URL)
&nbsp;
    <u>assert</u> response is not None
    <u>assert</u> response.ok
    <u>assert</u> response.status_code == 200
&nbsp;
&nbsp;
def <strong>test_get_method_for_missing_endpoint</strong>():
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/neexistuje"
&nbsp;
    <i># poslani HTTP dotazu typu GET</i>
    response = requests.get(URL)
&nbsp;
    <u>assert</u> response is not None
    <u>assert</u> response.ok
    <u>assert</u> response.status_code == 200
</pre>

<p>Po spuštění těchto testů by mělo dojít k&nbsp;detekci chyby, a to konkrétně
u druhého testu, který se snaží přistoupit na neexistující koncový bod REST API
serveru:</p>

<pre>
$ <strong>pytest -v 02_check_status_test.py</strong>
&nbsp;
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/requests/tests
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 2 items
&nbsp;
02_check_status_test.py::test_get_method_for_existing_endpoint PASSED    [ 50%]
02_check_status_test.py::test_get_method_for_missing_endpoint FAILED     [100%]
&nbsp;
=================================== FAILURES ===================================
_____________________ test_get_method_for_missing_endpoint _____________________
&nbsp;
    def test_get_method_for_missing_endpoint():
        # adresa s testovaci REST API sluzbou
        URL = "http://httpbin.org/neexistuje"
    &nbsp;
        # poslani HTTP dotazu typu GET
        response = requests.get(URL)
    &nbsp;
        assert response is not None
&gt;       assert response.ok
E       assert False
E        +  where False = &lt;Response [404]&gt;.ok
&nbsp;
02_check_status_test.py:27: AssertionError
=========================== short test summary info ============================
FAILED 02_check_status_test.py::test_get_method_for_missing_endpoint - assert...
========================= 1 failed, 1 passed in 0.88s ==========================
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Příprava funkcí pro knihovnu určenou pro testování REST API</h2>

<p>V&nbsp;předchozích testech už bylo patrné, že se některé operace &ndash;
zejména podmínky &ndash; opakují. Z&nbsp;tohoto důvodu nemusí být špatným
nápadem provést malý refaktoring a připravit si tak malou knihovnu určenou pro
zjednodušení psaní REST API testů. Inspirací přitom je knihovna <i>Frisby</i>
určená pro programovací jazyk Go, s&nbsp;níž jsme se seznámili v&nbsp;článku <a
href="https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/">Testování
aplikací psaných v Go s využitím knihoven Goblin a Frisby</a>. Tato knihovna
používá zřetězení funkcí, ovšem prozatím si vystačíme pouze s&nbsp;pomocnými
funkcemi; například s&nbsp;funkcí, která pouze otestuje, zda server vrátil HTTP
kód 200 OK či nikoli:</p>

<pre>
def <strong>expect_ok_response</strong>(response):
    <u>assert</u> response is not None
    <u>assert</u> response.ok
    <u>assert</u> response.status_code == 200
</pre>

<p>Zařazení takové funkce do testů je snadné, což je ostatně ukázáno i na
dnešním třetím demonstračním příkladu:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import requests
&nbsp;
&nbsp;
def <strong>expect_ok_response</strong>(response):
    <u>assert</u> response is not None
    <u>assert</u> response.ok
    <u>assert</u> response.status_code == 200
&nbsp;
&nbsp;
def <strong>test_get_method_for_existing_endpoint</strong>():
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/get"
&nbsp;
    <i># poslani HTTP dotazu typu GET</i>
    response = requests.get(URL)
&nbsp;
    <i># zakladni test odpovedi</i>
    expect_ok_response(response)
&nbsp;
&nbsp;
def <strong>test_get_method_for_missing_endpoint</strong>():
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/neexistuje"
&nbsp;
    <i># poslani HTTP dotazu typu GET</i>
    response = requests.get(URL)
&nbsp;
    <i># zakladni test odpovedi</i>
    expect_ok_response(response)
</pre>

<p>Nyní by měl nástroj <i>Pytest</i> vypsat informaci o tom, že první test byl
dokončen úspěšně, ale druhý skončil s&nbsp;chybou:</p>

<pre>
$ <strong>pytest -v 03_refactor_check_status_test.py</strong>
&nbsp;
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/requests/tests
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 2 items
&nbsp;
03_refactor_check_status_test.py::test_get_method_for_existing_endpoint PASSED [ 50%]
03_refactor_check_status_test.py::test_get_method_for_missing_endpoint FAILED [100%]
&nbsp;
=================================== FAILURES ===================================
_____________________ test_get_method_for_missing_endpoint _____________________
&nbsp;
    def test_get_method_for_missing_endpoint():
        # adresa s testovaci REST API sluzbou
        URL = "http://httpbin.org/neexistuje"
&nbsp;
        # poslani HTTP dotazu typu GET
        response = requests.get(URL)
&nbsp;
        # zakladni test odpovedi
&gt;       expect_ok_response(response)

03_refactor_check_status_test.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
&nbsp;
response = &lt;Response [404]&gt;
&nbsp;
    def expect_ok_response(response):
        assert response is not None
&gt;       assert response.ok
E       assert False
E        +  where False = &lt;Response [404]&gt;.ok
&nbsp;
03_refactor_check_status_test.py:9: AssertionError
=========================== short test summary info ============================
FAILED 03_refactor_check_status_test.py::test_get_method_for_missing_endpoint
========================= 1 failed, 1 passed in 0.88s ==========================
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Kontrola hlavičky nebo hlaviček vrácených serverem v&nbsp;odpovědi</h2>

<p>Samotné odpovědi serveru neobsahují pouze požadovaná data (<i>payload</i>),
ale i metainformace o těchto datech. Tyto metainformace se ukládají do hlaviček
odpovědi, ke kterým samozřejmě máme při použití knihovny <i>Requests</i>
přístup a můžeme je tedy zkontrolovat i v&nbsp;testech REST API, například
následujícím způsobem:</p>

<pre>
<i># test existence hlavicky</i>
<u>assert</u> "content-type" in headers
&nbsp;
<i># kontrola obsahu hlavicky</i>
<u>assert</u> headers["content-type"] == "application/json"
</pre>

<p><div class="rs-tip-major">Poznámka: z&nbsp;tohoto úryvku kódu je patrné, že
se jedná o běžný slovník.</div></p>

<p>V&nbsp;dnešním <a
href="https://github.com/tisnik/testing-in-python/blob/master/requests/tests/04_check_content_type.py">čtvrtém
demonstračním příkladu</a> je výše uvedený úryvek programového kódu použit pro
ověření, že server vrací odpověď se správným typem, tedy konkrétně data
odpovídající MIME typu &bdquo;application/json&ldquo;:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import requests
&nbsp;
&nbsp;
def <strong>test_get_method_for_existing_endpoint</strong>():
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/get"
&nbsp;
    <i># poslani HTTP dotazu typu GET</i>
    response = requests.get(URL)
&nbsp;
    <i># precteni hlavicek</i>
    headers = response.headers
&nbsp;
    <u>assert</u> response is not None
    <u>assert</u> response.ok
    <u>assert</u> response.status_code == 200
&nbsp;
    <i># test existence hlavicky</i>
    <u>assert</u> "content-type" in headers
&nbsp;
    <i># kontrola obsahu hlavicky</i>
    <u>assert</u> headers["content-type"] == "application/json"
</pre>

<p>Výsledek získaný po spuštění testů:</p>

<pre>
$ <strong>pytest -v 04_check_content_type.py</strong>
&nbsp;
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/requests/tests
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 1 item
&nbsp;
04_check_content_type.py::test_get_method_for_existing_endpoint PASSED   [100%]
&nbsp;
============================== 1 passed in 0.53s ===============================
</pre>

<p>Samozřejmě nám nic nebrání si vyzkoušet chování v&nbsp;případě, že se vrací
neočekávaný typ dat:</p>

<pre>
$ <strong>pytest -v 04_check_content_type_B.py</strong>
&nbsp;
================================================= test session starts =================================================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/requests/tests
plugins: print-0.1.3, voluptuous-1.0.2
collected 1 item                                                                                                                                              
&nbsp;
04_check_content_type_B.py::test_get_method_for_existing_endpoint FAILED                                        [100%]
&nbsp;
====================================================== FAILURES =======================================================
________________________________________ test_get_method_for_existing_endpoint ________________________________________
&nbsp;
    def test_get_method_for_existing_endpoint():
        # adresa s testovaci REST API sluzbou
        URL = "http://httpbin.org/get"
&nbsp;
        # poslani HTTP dotazu typu GET
        response = requests.get(URL)
&nbsp;
        # precteni hlavicek
        headers = response.headers
&nbsp;
        assert response is not None
        assert response.ok
        assert response.status_code == 200
&nbsp;
        # test existence hlavicky
        assert "content-type" in headers
&nbsp;
        # kontrola obsahu hlavicky
&gt;       assert headers["content-type"] == "text/plain"
E       AssertionError: assert 'application/json' == 'text/plain'
E         - text/plain
E         + application/json
&nbsp;
04_check_content_type_B.py:25: AssertionError
========================================================= short test summary info ==================================================
FAILED 04_check_content_type_B.py::test_get_method_for_existing_endpoint - AssertionError: assert 'application/json' == 'text/plain'
============================================================ 1 failed in 0.66s =====================================================
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Samostatná funkce pro otestování typu odpovědi</h2>

<p>Kontrola typu odpovědi (resp.&nbsp;přesněji MIME typu) je v&nbsp;praxi tak
častá, že si pro ni můžeme vytvořit novou pomocnou funkci volanou
z&nbsp;jednotlivých testů:</p>

<pre>
def <strong>expect_content_type</strong>(response, content_type):
    <i># precteni hlavicek</i>
    headers = response.headers
&nbsp;
    <i># test existence hlavicky</i>
    <u>assert</u> "content-type" in headers
&nbsp;
    <i># kontrola obsahu hlavicky</i>
    <u>assert</u> headers["content-type"] == content_type
</pre>

<p>Upravený kód tohoto demonstračního příkladu s&nbsp;dvojicí testů vypadá
následovně:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import requests
&nbsp;
&nbsp;
def <strong>expect_ok_response</strong>(response):
    <u>assert</u> response is not None
    <u>assert</u> response.ok
    <u>assert</u> response.status_code == 200
&nbsp;
&nbsp;
def <strong>expect_content_type</strong>(response, content_type):
    <i># precteni hlavicek</i>
    headers = response.headers
&nbsp;
    <i># test existence hlavicky</i>
    <u>assert</u> "content-type" in headers
&nbsp;
    <i># kontrola obsahu hlavicky</i>
    <u>assert</u> headers["content-type"] == content_type
&nbsp;
&nbsp;
def <strong>test_get_method_for_existing_endpoint</strong>():
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/get"
&nbsp;
    <i># poslani HTTP dotazu typu GET</i>
    response = requests.get(URL)
&nbsp;
    <i># zakladni test odpovedi</i>
    expect_ok_response(response)
    expect_content_type(response, "application/json")
</pre>

<p>Chování takto upraveného příkladu po spuštění:</p>

<pre>
$ <strong>pytest -v 05_refactor_check_content_type.py</strong>
&nbsp;
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/requests/tests
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 1 item
&nbsp;
05_refactor_check_content_type.py::test_get_method_for_existing_endpoint PASSED [100%]
&nbsp;
============================== 1 passed in 0.47s ===============================
</pre>

<p>Opět je samozřejmě možné otestovat i negativní příklad (s&nbsp;chybami):</p>

<pre>
$ <strong>pytest -v 05_refactor_check_content_type_B.py</strong>
&nbsp;
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/requests/tests
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 1 item
&nbsp;
05_refactor_check_content_type_B.py::test_get_method_for_existing_endpoint FAILED [100%]
&nbsp;
=================================== FAILURES ===================================
____________________ test_get_method_for_existing_endpoint _____________________
&nbsp;
    def test_get_method_for_existing_endpoint():
        # adresa s testovaci REST API sluzbou
        URL = "http://httpbin.org/get"
    &nbsp;
        # poslani HTTP dotazu typu GET
        response = requests.get(URL)
    &nbsp;
        # zakladni test odpovedi
        expect_ok_response(response)
&gt;       expect_content_type(response, "text/plain")
&nbsp;
05_refactor_check_content_type_B.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
&nbsp;
response = &lt;Response [200]&gt;, content_type = 'text/plain'
&nbsp;
    def expect_content_type(response, content_type):
        # precteni hlavicek
        headers = response.headers
&nbsp;
        # test existence hlavicky
        assert "content-type" in headers
&nbsp;
        # kontrola obsahu hlavicky
&gt;       assert headers["content-type"] == content_type
E       AssertionError: assert 'application/json' == 'text/plain'
E         - text/plain
E         + application/json
&nbsp;
05_refactor_check_content_type_B.py:21: AssertionError
=========================== short test summary info ============================
FAILED 05_refactor_check_content_type_B.py::test_get_method_for_existing_endpoint
============================== 1 failed in 0.57s ===============================
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Test, zda server poslal rastrové obrázky či podobná data</h2>

<p>Mnoho serverů nevrací požadované informace pouze ve formátu JSON. Příkladem
mohou být mapové servery vracející buď vektorové kresby ve formátu SVG nebo
rastrové obrázky ve formátu PNG, GIF popř.&nbsp;JPEG. I tyto typy informací
mají přiřazen příslušný MIME typ, takže si náš test můžeme rozšířit o další
typy dat, zde konkrétně o otestování, zda server vrátil rastrové obrázky ve
formátech PNG a JPEG (pochopitelně při přístupu na příslušné koncové body):</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import requests
&nbsp;
&nbsp;
def <strong>expect_ok_response</strong>(response):
    assert response is not None
    assert response.ok
    assert response.status_code == 200
&nbsp;
&nbsp;
def <strong>expect_content_type</strong>(response, content_type):
    <i># precteni hlavicek</i>
    headers = response.headers
&nbsp;
    <i># test existence hlavicky</i>
    assert "content-type" in headers
&nbsp;
    <i># kontrola obsahu hlavicky</i>
    assert headers["content-type"] == content_type
&nbsp;
&nbsp;
def <strong>test_get_method_for_existing_endpoint</strong>():
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/get"
&nbsp;
    <i># poslani HTTP dotazu typu GET</i>
    response = requests.get(URL)
&nbsp;
    <i># zakladni test odpovedi</i>
    expect_ok_response(response)
    expect_content_type(response, "application/json")
&nbsp;
&nbsp;
def <strong>test_get_method_for_png_image</strong>():
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/image/png"
&nbsp;
    <i># poslani HTTP dotazu typu GET</i>
    response = requests.get(URL)
&nbsp;
    <i># zakladni test odpovedi</i>
    expect_ok_response(response)
    expect_content_type(response, "image/png")
&nbsp;
&nbsp;
def <strong>test_get_method_for_jpeg_image</strong>():
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/image/jpeg"
&nbsp;
    <i># poslani HTTP dotazu typu GET</i>
    response = requests.get(URL)
&nbsp;
    <i># zakladni test odpovedi</i>
    expect_ok_response(response)
    expect_content_type(response, "image/jpeg")
</pre>

<p></p>

<pre>
$ <strong>pytest -v 06_more_content_types.py</strong>
&nbsp;
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/requests/tests
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 3 items

06_more_content_types.py::test_get_method_for_existing_endpoint PASSED   [ 33%]
06_more_content_types.py::test_get_method_for_png_image PASSED           [ 66%]
06_more_content_types.py::test_get_method_for_jpeg_image PASSED          [100%]

============================== 3 passed in 1.49s ===============================
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>

<p>Testy REST API pochopitelně musí zjišťovat i to, jestli server skutečně
vrátil požadovanou informaci či informace. Musíme tedy nejenom testovat obsah
HTTP hlaviček odpovědi (což jsou metainformace), ale i obsah těla odpovědi.
Pokud je odpověď čistě textová (nebo čistě binární), tj.&nbsp;bez složitější
struktury, můžeme s&nbsp;tělem odpovědi pracovat přímo, a to přes tento
atribut:</p>

<pre>
response.text
</pre>

<p>Nejjednodušší test může zjišťovat, jestli se v&nbsp;těle odpovědi nachází
očekávaný řetězec. Samozřejmě můžeme použít regulární výrazy atd., ovšem test
na přítomnost očekávaného (pod)řetězce lze v&nbsp;Pythonu napsat ještě
stručněji:</p>

<pre>
def <strong>expect_text_in_payload</strong>(response, expected):
    <u>assert</u> expected in response.text
</pre>

<p>V&nbsp;dalším demonstračním příkladu se zjišťuje, jestli se v&nbsp;těle
odpovědi nachází text &bdquo;42&ldquo;:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import requests
&nbsp;
&nbsp;
def <strong>expect_ok_response</strong>(response):
    assert response is not None
    assert response.ok
    assert response.status_code == 200
&nbsp;
&nbsp;
def <strong>expect_content_type</strong>(response, content_type):
    <i># precteni hlavicek</i>
    headers = response.headers
&nbsp;
    <i># test existence hlavicky</i>
    assert "content-type" in headers
&nbsp;
    <i># kontrola obsahu hlavicky</i>
    assert headers["content-type"] == content_type
&nbsp;
&nbsp;
def <strong>expect_text_in_payload</strong>(response, expected):
    assert expected in response.text
&nbsp;
&nbsp;
def <strong>test_get_method_for_existing_endpoint</strong>():
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/get?x=6&y=7&answer=42"
&nbsp;
    <i># poslani HTTP dotazu typu GET</i>
    response = requests.get(URL)
&nbsp;
    <i># zakladni test odpovedi</i>
    expect_ok_response(response)
    expect_content_type(response, "application/json")
&nbsp;
    expect_text_in_payload(response, "42")
</pre>

<p></p>

<pre>
$ <strong>pytest -v 07_check_payload.py</strong>
&nbsp;
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/requests/tests
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 1 item

07_check_payload.py::test_get_method_for_existing_endpoint PASSED        [100%]

============================== 1 passed in 0.47s ===============================
</pre>

<p>Předchozí test skutečně prošel, a to z&nbsp;toho důvodu, že odpověď serveru
obsahuje následující data:</p>

<pre>
{
  "args": {
    "answer": "42", 
    "x": "6", 
    "y": "7"
  }, 
  "headers": {
    "Host": "a0207c42-pmhttpbin-pmhttpb-c018-592832243.us-east-1.elb.amazonaws.com", 
    "X-Amzn-Trace-Id": "Root=1-5f022b53-28ef633486278da51c263ebf"
  }, 
  "origin": "37.48.51.80", 
  "url": "http://a0207c42-pmhttpbin-pmhttpb-c018-592832243.us-east-1.elb.amazonaws.com/get?x=6&amp;y=7&amp;answer=42"
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>

<p>Velmi často se setkáme s&nbsp;tím, že je nutné zpracovat nebo alespoň
zkontrolovat odpověď serveru ve formátu JSON. Příkladem může být odpověď ve
formátu, který byl ukázán na konci předchozí kapitoly. Jak tedy například
zjistíme, že se správně vrátila hodnota atributu <strong>answer</strong> (tedy
řetězec &bdquo;42&ldquo;), který je uložen v&nbsp;atributu
<strong>args</strong>:</p>

<pre>
{
  "args": {
    <strong>"answer": "42", </strong>
    ...
    ...
    ...
</pre>

<p>Jedno z&nbsp;možných řešení spočívá v&nbsp;otrockém přístupu k&nbsp;hodnotě
atributu:</p>

<pre>
<i># pruchod datovou strukturou odeslanou serverem</i>
encoded = response.json()
&nbsp;
<u>assert</u> "args" in encoded
args = encoded["args"]
&nbsp;
<u>assert</u> "answer" in args
answer = args["answer"]
&nbsp;
<u>assert</u> answer == "42"
</pre>

<p>Popř.&nbsp;použít jednořádkovou variantu:</p>

<pre>
<i># pruchod datovou strukturou odeslanou serverem</i>
encoded = response.json()
&nbsp;
<u>assert</u> encoded["args"]["answer"] == "42"
</pre>

<p>Toto jednoduché otestování jednoho atributu odpovědi je ukázáno v&nbsp;další
verzi demonstračního příkladu:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import requests
&nbsp;
&nbsp;
def <strong>expect_ok_response</strong>(response):
    assert response is not None
    assert response.ok
    assert response.status_code == 200
&nbsp;
&nbsp;
def <strong>expect_content_type</strong>(response, content_type):
    <i># precteni hlavicek</i>
    headers = response.headers
&nbsp;
    <i># test existence hlavicky</i>
    assert "content-type" in headers
&nbsp;
    <i># kontrola obsahu hlavicky</i>
    assert headers["content-type"] == content_type
&nbsp;
&nbsp;
def <strong>test_get_method_for_existing_endpoint</strong>():
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/get?x=6&y=7&answer=42"
&nbsp;
    <i># poslani HTTP dotazu typu GET</i>
    response = requests.get(URL)
&nbsp;
    <i># zakladni test odpovedi</i>
    expect_ok_response(response)
    expect_content_type(response, "application/json")
&nbsp;
    <i># pruchod datovou strukturou odeslanou serverem</i>
    encoded = response.json()
&nbsp;
    assert "args" in encoded
    args = encoded["args"]
&nbsp;
    assert "answer" in args
    answer = args["answer"]
&nbsp;
    assert answer == "42"
</pre>

<p></p>

<pre>
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/requests/tests
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 1 item

08_check_json_content.py::test_get_method_for_existing_endpoint PASSED   [100%]

============================== 1 passed in 0.46s ===============================
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

<p></p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import requests
&nbsp;
&nbsp;
def <strong>expect_ok_response</strong>(response):
    assert response is not None
    assert response.ok
    assert response.status_code == 200
&nbsp;
&nbsp;
def <strong>expect_content_type</strong>(response, content_type):
    <i># precteni hlavicek</i>
    headers = response.headers
&nbsp;
    <i># test existence hlavicky</i>
    assert "content-type" in headers
&nbsp;
    <i># kontrola obsahu hlavicky</i>
    assert headers["content-type"] == content_type
&nbsp;
&nbsp;
def <strong>get_value_using_path</strong>(obj, path):
    """Get the attribute value using the XMLpath-like path specification.
    Return any attribute stored in the nested object and list hierarchy using
    the 'path' where path consists of:
        keys (selectors)
        indexes (in case of arrays)
    separated by slash, ie. "key1/0/key_x".
    Usage:
    get_value_using_path({"x" : {"y" : "z"}}, "x"))   -> {"y" : "z"}
    get_value_using_path({"x" : {"y" : "z"}}, "x/y")) -> "z"
    get_value_using_path(["x", "y", "z"], "0"))       -> "x"
    get_value_using_path(["x", "y", "z"], "1"))       -> "y"
    get_value_using_path({"key1" : ["x", "y", "z"],
                          "key2" : ["a", "b", "c", "d"]}, "key1/1")) -> "y"
    get_value_using_path({"key1" : ["x", "y", "z"],
                          "key2" : ["a", "b", "c", "d"]}, "key2/1")) -> "b"
    """
    keys = path.split("/")
    for key in keys:
        if key.isdigit():
            obj = obj[int(key)]
        else:
            obj = obj[key]
    return obj
&nbsp;
&nbsp;
def <strong>test_get_method_for_existing_endpoint</strong>():
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/get?x=6&y=7&answer=42"
&nbsp;
    <i># poslani HTTP dotazu typu GET</i>
    response = requests.get(URL)
&nbsp;
    <i># zakladni test odpovedi</i>
    expect_ok_response(response)
    expect_content_type(response, "application/json")
&nbsp;
    <i># ziskani konkretniho prvku z vracene datove struktury</i>
    encoded = response.json()
&nbsp;
    answer = get_value_using_path(encoded, "args/answer")
    assert answer == "42"
</pre>

<p></p>

<pre>
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/requests/tests
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 1 item

09_xpath_like_query.py::test_get_method_for_existing_endpoint PASSED     [100%]

============================== 1 passed in 0.44s ===============================
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<p></p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import requests
&nbsp;
&nbsp;
def <strong>expect_ok_response</strong>(response):
    assert response is not None
    assert response.ok
    assert response.status_code == 200
&nbsp;
&nbsp;
def <strong>expect_content_type</strong>(response, content_type):
    <i># precteni hlavicek</i>
    headers = response.headers
&nbsp;
    <i># test existence hlavicky</i>
    assert "content-type" in headers
&nbsp;
    <i># kontrola obsahu hlavicky</i>
    assert headers["content-type"] == content_type
&nbsp;
&nbsp;
def <strong>test_post_method_for_existing_endpoint</strong>():
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/post"
&nbsp;
    <i># poslani HTTP dotazu typu POST</i>
    response = requests.post(URL)
&nbsp;
    <i># zakladni test odpovedi</i>
    expect_ok_response(response)
    expect_content_type(response, "application/json")
</pre>

<p></p>

<pre>
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/requests/tests
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 1 item

10_post_method_test.py::test_post_method_for_existing_endpoint PASSED    [100%]

============================== 1 passed in 0.44s ===============================
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<p></p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import requests
&nbsp;
&nbsp;
def <strong>expect_ok_response</strong>(response):
    assert response is not None
    assert response.ok
    assert response.status_code == 200
&nbsp;
&nbsp;
def <strong>expect_content_type</strong>(response, content_type):
    <i># precteni hlavicek</i>
    headers = response.headers
&nbsp;
    <i># test existence hlavicky</i>
    assert "content-type" in headers
&nbsp;
    <i># kontrola obsahu hlavicky</i>
    assert headers["content-type"] == content_type
&nbsp;
&nbsp;
def <strong>test_post_method_for_existing_endpoint</strong>():
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/post"
&nbsp;
    <i># data posilana serveru</i>
    payload = {
        "klic": "hodnota",
        "answer": 42,
        "question": None,
        "correct": True}
&nbsp;
    <i># poslani HTTP dotazu typu POST s telem</i>
    response = requests.post(URL, data=payload)
&nbsp;
    <i># zakladni test odpovedi</i>
    expect_ok_response(response)
    expect_content_type(response, "application/json")
</pre>

<p></p>

<pre>
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/requests/tests
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 1 item

11_post_method_with_payload_test.py::test_post_method_for_existing_endpoint PASSED [100%]

============================== 1 passed in 0.55s ===============================
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<p></p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import requests
&nbsp;
&nbsp;
def <strong>expect_ok_response</strong>(response):
    assert response is not None
    assert response.ok
    assert response.status_code == 200
&nbsp;
&nbsp;
def <strong>expect_content_type</strong>(response, content_type):
    <i># precteni hlavicek</i>
    headers = response.headers
&nbsp;
    <i># test existence hlavicky</i>
    assert "content-type" in headers
&nbsp;
    <i># kontrola obsahu hlavicky</i>
    assert headers["content-type"] == content_type
&nbsp;
&nbsp;
def <strong>test_post_method_for_existing_endpoint</strong>():
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/post"
&nbsp;
    <i># data posilana serveru</i>
    payload = {
        "klic": "hodnota",
        "answer": 42,
        "question": None,
        "correct": True}
&nbsp;
    <i># poslani HTTP dotazu typu POST s telem</i>
    response = requests.post(URL, json=payload)
&nbsp;
    <i># zakladni test odpovedi</i>
    expect_ok_response(response)
    expect_content_type(response, "application/json")
</pre>

<p></p>

<pre>
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/requests/tests
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 1 item

12_post_method_with_payload_test.py::test_post_method_for_existing_endpoint PASSED [100%]

============================== 1 passed in 0.46s ===============================
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<p></p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import requests
import json
&nbsp;
&nbsp;
def <strong>expect_ok_response</strong>(response):
    assert response is not None
    assert response.ok
    assert response.status_code == 200
&nbsp;
&nbsp;
def <strong>expect_content_type</strong>(response, content_type):
    <i># precteni hlavicek</i>
    headers = response.headers
&nbsp;
    <i># test existence hlavicky</i>
    assert "content-type" in headers
&nbsp;
    <i># kontrola obsahu hlavicky</i>
    assert headers["content-type"] == content_type
&nbsp;
&nbsp;
def <strong>get_value_using_path</strong>(obj, path):
    """Get the attribute value using the XMLpath-like path specification.
    Return any attribute stored in the nested object and list hierarchy using
    the 'path' where path consists of:
        keys (selectors)
        indexes (in case of arrays)
    separated by slash, ie. "key1/0/key_x".
    Usage:
    get_value_using_path({"x" : {"y" : "z"}}, "x"))   -> {"y" : "z"}
    get_value_using_path({"x" : {"y" : "z"}}, "x/y")) -> "z"
    get_value_using_path(["x", "y", "z"], "0"))       -> "x"
    get_value_using_path(["x", "y", "z"], "1"))       -> "y"
    get_value_using_path({"key1" : ["x", "y", "z"],
                          "key2" : ["a", "b", "c", "d"]}, "key1/1")) -> "y"
    get_value_using_path({"key1" : ["x", "y", "z"],
                          "key2" : ["a", "b", "c", "d"]}, "key2/1")) -> "b"
    """
    keys = path.split("/")
    for key in keys:
        if key.isdigit():
            obj = obj[int(key)]
        else:
            obj = obj[key]
    return obj
&nbsp;
&nbsp;
def <strong>test_cookies</strong>():
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/cookies"
&nbsp;
    <i># hlavicka posilana v dotazu</i>
    headers = {'accept': 'application/json'}
&nbsp;
    <i># priprava cookies</i>
    cookies = {'key1': 'value1',
               'key2': 'value2',
               'key3': 'value3'}
&nbsp;
    <i># poslani HTTP dotazu typu GET</i>
    response = requests.get(URL, headers=headers, cookies=cookies)
&nbsp;
    <i># zakladni test odpovedi</i>
    expect_ok_response(response)
    expect_content_type(response, "application/json")
&nbsp;
    <i># precteni hlavicek</i>
    headers = response.headers
&nbsp;
    <i># pruchod datovou strukturou odeslanou serverem</i>
    encoded = response.json()
    cookies = get_value_using_path(encoded, "cookies")
&nbsp;
    <i># test existence klicu</i>
    assert "key1" in cookies
    assert "key2" in cookies
    assert "key3" in cookies
&nbsp;
    <i># test hodnot, ktere server detekoval v poslanych cookies</i>
    assert get_value_using_path(encoded, "cookies/key1") == "value1"
    assert get_value_using_path(encoded, "cookies/key2") == "value2"
    assert get_value_using_path(encoded, "cookies/key3") == "value3"
&nbsp;
    <i># nyni ziskame cookies z odpovedi a zkontrolujeme jejich obsah</i>
    cookies = response.cookies.get_dict()
&nbsp;
    <i># melo by se jednat o prazdny slovnik</i>
    assert not cookies
</pre>

<p></p>

<pre>
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/requests/tests
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 1 item

13_cookies_tests.py::test_cookies PASSED                                 [100%]

============================== 1 passed in 0.49s ===============================
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<p></p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import requests
import json
&nbsp;
session = None
&nbsp;
&nbsp;
def <strong>expect_ok_response</strong>(response):
    assert response is not None
    assert response.ok
    assert response.status_code == 200
&nbsp;
&nbsp;
def <strong>expect_content_type</strong>(response, content_type):
    <i># precteni hlavicek</i>
    headers = response.headers
&nbsp;
    <i># test existence hlavicky</i>
    assert "content-type" in headers
&nbsp;
    <i># kontrola obsahu hlavicky</i>
    assert headers["content-type"] == content_type
&nbsp;
&nbsp;
def <strong>expect_cookie</strong>(response, name, value):
    cookies = session.cookies
    assert name in cookies
    assert cookies[name] == value
&nbsp;
&nbsp;
def <strong>expect_cookies</strong>(response, how_many):
    cookies = session.cookies
    assert len(cookies) == how_many
&nbsp;
&nbsp;
def <strong>get_value_using_path</strong>(obj, path):
    <i>"""Get the attribute value using the XMLpath-like path specification.</i>
    <i>Return any attribute stored in the nested object and list hierarchy using</i>
    <i>the 'path' where path consists of:</i>
        <i>keys (selectors)</i>
        <i>indexes (in case of arrays)</i>
    <i>separated by slash, ie. "key1/0/key_x".</i>
    <i>Usage:</i>
    <i>get_value_using_path({"x" : {"y" : "z"}}, "x"))   -&gt; {"y" : "z"}</i>
    <i>get_value_using_path({"x" : {"y" : "z"}}, "x/y")) -&gt; "z"</i>
    <i>get_value_using_path(["x", "y", "z"], "0"))       -&gt; "x"</i>
    <i>get_value_using_path(["x", "y", "z"], "1"))       -&gt; "y"</i>
    <i>get_value_using_path({"key1" : ["x", "y", "z"],</i>
                          <i>"key2" : ["a", "b", "c", "d"]}, "key1/1")) -&gt; "y"</i>
    <i>get_value_using_path({"key1" : ["x", "y", "z"],</i>
                          <i>"key2" : ["a", "b", "c", "d"]}, "key2/1")) -&gt; "b"</i>
    <i>"""</i>
    keys = path.split("/")
    for key in keys:
        if key.isdigit():
            obj = obj[int(key)]
        else:
            obj = obj[key]
    return obj
&nbsp;
&nbsp;
def <strong>set_cookie</strong>(session, name, value):
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/cookies/set/{name}/{value}".format(name=name, value=value)
&nbsp;
    <i># hlavicka posilana v dotazu</i>
    headers = {'accept': 'application/json'}
&nbsp;
    <i># poslani HTTP dotazu typu GET</i>
    return session.get(URL, headers=headers)
&nbsp;
&nbsp;
def <strong>delete_cookie</strong>(session, name):
    <i># adresa s testovaci REST API sluzbou</i>
    URL = "http://httpbin.org/cookies/delete?{name}=".format(name=name)
&nbsp;
    <i># hlavicka posilana v dotazu</i>
    headers = {'accept': 'application/json'}
&nbsp;
    <i># poslani HTTP dotazu typu GET</i>
    return session.get(URL, headers=headers)
&nbsp;
&nbsp;
def <strong>setup_module</strong>(module):
    global session
    session = requests.Session()
&nbsp;
&nbsp;
def <strong>test_set_cookie_</strong>1():
    response = set_cookie(session, "foo", "6")
&nbsp;
    <i># zakladni test odpovedi</i>
    expect_ok_response(response)
    expect_content_type(response, "application/json")
&nbsp;
    <i># test cookies</i>
    expect_cookies(response, 1)
    expect_cookie(response, "foo", "6")
&nbsp;
&nbsp;
def <strong>test_set_cookie_</strong>2():
    response = set_cookie(session, "bar", "7")
&nbsp;
    <i># zakladni test odpovedi</i>
    expect_ok_response(response)
    expect_content_type(response, "application/json")
&nbsp;
    <i># test cookies</i>
    expect_cookies(response, 2)
    expect_cookie(response, "foo", "6")
    expect_cookie(response, "bar", "7")
&nbsp;
&nbsp;
def <strong>test_set_cookie_</strong>3():
    response = set_cookie(session, "foo", "42")
&nbsp;
    <i># zakladni test odpovedi</i>
    expect_ok_response(response)
    expect_content_type(response, "application/json")
&nbsp;
    <i># test cookies</i>
    expect_cookies(response, 2)
    expect_cookie(response, "foo", "42")
    expect_cookie(response, "bar", "7")
&nbsp;
&nbsp;
def <strong>test_delete_cookie_</strong>1():
    response = delete_cookie(session, "foo")
&nbsp;
    <i># zakladni test odpovedi</i>
    expect_ok_response(response)
    expect_content_type(response, "application/json")
&nbsp;
    <i># test cookies</i>
    expect_cookies(response, 1)
    expect_cookie(response, "bar", "7")
&nbsp;
&nbsp;
def <strong>test_delete_cookie_</strong>2():
    response = delete_cookie(session, "baz")
&nbsp;
    <i># zakladni test odpovedi</i>
    expect_ok_response(response)
    expect_content_type(response, "application/json")
&nbsp;
    <i># test cookies</i>
    expect_cookies(response, 1)
    expect_cookie(response, "bar", "7")
&nbsp;
&nbsp;
def <strong>test_delete_cookie_</strong>3():
    response = delete_cookie(session, "bar")
&nbsp;
    <i># zakladni test odpovedi</i>
    expect_ok_response(response)
    expect_content_type(response, "application/json")
&nbsp;
    <i># test cookies</i>
    expect_cookies(response, 0)
</pre>

<p></p>

<pre>
$ <strong>pytest -v 14_session_cookies_tests.py</strong>
&nbsp;
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/requests/tests
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 6 items

14_session_cookies_tests.py::test_set_cookie_1 PASSED                    [ 16%]
14_session_cookies_tests.py::test_set_cookie_2 PASSED                    [ 33%]
14_session_cookies_tests.py::test_set_cookie_3 PASSED                    [ 50%]
14_session_cookies_tests.py::test_delete_cookie_1 PASSED                 [ 66%]
14_session_cookies_tests.py::test_delete_cookie_2 PASSED                 [ 83%]
14_session_cookies_tests.py::test_delete_cookie_3 PASSED                 [100%]

============================== 6 passed in 3.03s ===============================
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je mnohem lepším řešením
použít:</div></p>

<pre>
def <strong>setup_module</strong>(module):
    module.session = requests.Session()
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Kontrola složitějších datových struktur vracených serverem</h2>

<p>Mnoho testů REST API navíc vyžaduje provedení minimálně tří popř.&nbsp;čtyř
typů operací:</p>

<ol>

<li>Kontrola popř.&nbsp;použití JWT tokenů či podobné technologie. Tímto
důležitým tématem se budeme zabývat později.</li>

<li>Validace prakticky libovolně komplikovaných datových struktur vrácených
serverem, a to na základě programátorem definovaného schématu.</li>

<li>Načítání (parsování) obsahu reprezentovaného pomocí XML, přístup
k&nbsp;jednotlivým prvkům výsledného stromu.</li>

<li>Dtto, ovšem pro obsah (typicky dokument) reprezentovaný v&nbsp;HTML.</li>

</ol>

<p>Nejdříve se alespoň ve stručnosti zmiňme o validaci datových struktur,
tj.&nbsp;většinou struktur reprezentovaných v&nbsp;JSONu, popř.&nbsp;(méně
často) v&nbsp;jiném serializačním formátu. Pro programovací jazyk Python
existuje několik knihoven, které většinou zajišťují dvě úlohy:</p>

<ol>
<li>provedení samotné validace (musíme vědět, jak mají data vypadat)</li>
<li>současně strukturu dat dokumentuje, a to rigidním způsobem</li>
</ol>

<p>Pro Python jsou poskytovány mj.&nbsp;i tyto knihovny:</p>

<ol>
<li>Schemagic</li>
<li>Schema</li>
<li>Voluptuous</li>
</ol>

<p>Některé příklady použití těchto knihoven si ukážeme příště společně
s&nbsp;jednoduchým REST API serverem, který bude poskytovat data
v&nbsp;příslušném formátu.</p>

<p><div class="rs-tip-major">Poznámka: tyto knihovny jsou dostupné i ve formě
pluginu pro nástroj <i>Pytest</i>, což je ostatně patrné i na mé
konfiguraci:</div></p>

<pre>
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/requests/tests
plugins: print-0.1.3, <strong>voluptuous-1.0.2</strong>
collecting ... collected 2 items
&nbsp;
01_basic_usage_test.py::test_get_method_for_existing_endpoint PASSED     [ 50%]
01_basic_usage_test.py::test_get_method_for_missing_endpoint PASSED      [100%]
&nbsp;
============================== 2 passed in 0.71s ===============================
</pre>


<p><a name="k17"></a></p>
<h2 id="k17">17. Zpracování XML a HTML v&nbsp;Pythonu s&nbsp;využitím knihovny lxml</h2>

<p>Knihovna <strong>lxml</strong>, o níž se dnes pro úplnost jen krátce zmíníme, slouží k&nbsp;načítání (parsování) XML souborů, přístupu k&nbsp;jednotlivým prvkům výsledného stromu, tvorbě a zapisování nových XML a v&nbsp;případě potřeby lze tuto knihovnu použít i pro zpracování HTML stránek.  Zajímavé je, že se tato knihovna poměrně dobře hodí i pro práci s&nbsp;nevalidními XML, XML bez schématu atd. &ndash; tj.&nbsp;se soubory, které může být obtížné zpracovat v&nbsp;jiných nástrojích. Vývojářům jsou v&nbsp;případě potřeby k&nbsp;dispozici i další zajímavé technologie, zejména XPath (zjednodušeně: přístup k&nbsp;elementům a jejich atributům přes doménově specifický jazyk) a SAX, tj.&nbsp;možnost zpracovávat XML jako sekvenci elementů, což je přístup mnohem méně náročný na paměť. Navíc se většinou jedná o rychlejší způsob práce s&nbsp;XML.</p>

<p>Knihovnu <strong>lxml</strong> je možné v&nbsp;případě potřeby použít i pro zpracování HTML stránek. Při zpracovávání HTML stránek se nevyžaduje (a popravdě řečeno ani neočekává) validita stránky, takže se specializovaný parser nazvaný <strong>HTMLParser</strong> snaží z&nbsp;dodaného zdrojového kódu stránky získat korektní stromovou strukturu, a to i v&nbsp;případě, že autor například neuzavírá značky, nevkládá uzavírací značky ve správném pořadí atd.  Podívejme se nyní na jednoduchý příklad zpracovatelné HTML stránky, konkrétně na stránku dostupnou na adrese <a href="http://www.zyvra.org/html/simple.htm">http://www.zyvra.org/html/simple.htm</a>.  Zdrojový kód této stránky vypadá následovně (stylem zápisu trošku připomíná minulé tisíciletí :-):</p>

<pre>
&lt;html&gt;&lt;head&gt;&lt;title&gt;
Very simple HTML page.
&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&nbsp;
&lt;p&gt;You can look at the source of this page by: Right clicking anywhere
out in space on this page then selecting "View" in the menu.&lt;/p&gt;
&lt;p&gt;This works on any page, but sometimes
what you see may be very complex
and seem confusing.&lt;/p&gt;
&nbsp;
&lt;p&gt;
&lt;b&gt;Please,&lt;/b&gt; look at the source and what you see with the browser.
You should understand and see the effect of every tag. Use the little
Icons up in the right of your browser screen to change the size of the
window and see the effect, and how the browser displays this page.&lt;/p&gt;
&lt;p align="right"&gt;
Yes, this is a &lt;b&gt;Very Plain&lt;/b&gt; page. &lt;i&gt;But it works!&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;&lt;b&gt;Remember. We are just getting started,&lt;/b&gt; and I haven't used
anything more than I have talked about in a couple pages!&lt;/i&gt;
Yes. You will want to be more fancy.
Just be patient, we'll get there.
&nbsp;
&lt;p align="center"&gt;Now create a page like
this of your own. &lt;b&gt;Have fun!&lt;/b&gt;&lt;/p
&nbsp;
&lt;/body&gt;&lt;/html&gt;
</pre>

<p>Povšimněte si například toho, že se ve stránce objevují neuzavřené značky
&lt;p&gt;, chybí informace o verzi HTML, o kódování atd. I přesto je možné
takovou stránku zpracovat.</p>

<p>Realizace příkladu pro zpracování HTML stránky je poměrně přímočará. Nejprve
(přesněji řečeno po importu <strong>lxml.etree</strong>) vytvoříme instanci
parseru HTML stránek:</p>

<pre>
import lxml.etree as ET
&nbsp;
parser = ET.HTMLParser()
</pre>

<p>Dále se pokusíme stránku načíst a ihned poté zparsovat. Povšimněte si, že
funkce <strong>lxml.etree.parse</strong> rozpozná URL a stránku v&nbsp;případě
potřeby stáhne (pokud ovšem není dostupná na serveru s&nbsp;HTTPS!):</p>

<pre>
url = "http://www.zyvra.org/html/simple.htm"
&nbsp;
tree = ET.parse(url, parser)
&nbsp;
root = tree.getroot()
</pre>

<p>Nyní, když máme k&nbsp;dispozici celý strom i kořenový prvek, se můžeme
pokusit zpětně zrekonstruovat řetězec se zdrojovým kódem stránky:</p>

<pre>
print("\n\n\nContent:")
result = ET.tostring(tree.getroot(), pretty_print=True, method="html")
print(result)
</pre>

<p>Podrobnosti, včetně testů určených pro reálný server, si ukážeme příště.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
nového Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/testing-in-python">https://github.com/tisnik/testing-in-python</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem &ndash;
alespoň prozatím &ndash; velmi malý, dnes má přibližně několik desítek
kilobajtů), můžete namísto toho použít odkazy na jednotlivé demonstrační
příklady a jejich části, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_basic_usage_test.py</td><td>poslání (HTTP) požadavku s&nbsp;využitím HTTP metody GET (umělý test)</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/tests/01_basic_usage_test.py">https://github.com/tisnik/testing-in-python/tree/master/tests/01_basic_usage_test.py</a></td></tr>
<tr><td> 2</td><td>02_check_status_test.py</td><td>otestování, zda byla odpověď poslána s&nbsp;očekávaným HTTP kódem</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/tests/02_check_status_test.py">https://github.com/tisnik/testing-in-python/tree/master/tests/02_check_status_test.py</a></td></tr>
<tr><td> 3</td><td>03_refactor_check_status_test.py</td><td>příprava funkcí pro knihovnu určenou pro testování REST API</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/tests/03_refactor_check_status_test.py">https://github.com/tisnik/testing-in-python/tree/master/tests/03_refactor_check_status_test.py</a></td></tr>
<tr><td> 4</td><td>04_check_content_type.py</td><td>kontrola hlavičky nebo hlaviček vrácených serverem v&nbsp;odpovědi</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/tests/04_check_content_type.py">https://github.com/tisnik/testing-in-python/tree/master/tests/04_check_content_type.py</a></td></tr>
<tr><td> 5</td><td>05_refactor_check_content_type.py</td><td>samostatná funkce pro otestování typu odpovědi</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/tests/05_refactor_check_content_type.py">https://github.com/tisnik/testing-in-python/tree/master/tests/05_refactor_check_content_type.py</a></td></tr>
<tr><td> 6</td><td>06_more_content_types.py</td><td>test, zda server poslal rastrové obrázky či podobná data</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/tests/06_more_content_types.py">https://github.com/tisnik/testing-in-python/tree/master/tests/06_more_content_types.py</a></td></tr>
<tr><td> 7</td><td>07_check_payload.py</td><td>otestování těla odpovědi</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/tests/07_check_payload.py">https://github.com/tisnik/testing-in-python/tree/master/tests/07_check_payload.py</a></td></tr>
<tr><td> 8</td><td>08_check_json_content.py</td><td>zpracování a otestování odpovědi serveru ve formátu JSON</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/tests/08_check_json_content.py">https://github.com/tisnik/testing-in-python/tree/master/tests/08_check_json_content.py</a></td></tr>
<tr><td> 9</td><td>09_xpath_like_query.py</td><td>výběr atributů z&nbsp;JSONu s&nbsp;využitím jednoduchého DSL</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/tests/09_xpath_like_query.py">https://github.com/tisnik/testing-in-python/tree/master/tests/09_xpath_like_query.py</a></td></tr>
<tr><td>10</td><td>10_post_method_test.py</td><td>otestování REST API endpointu dostupného přes HTTP metodu POST</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/tests/10_post_method_test.py">https://github.com/tisnik/testing-in-python/tree/master/tests/10_post_method_test.py</a></td></tr>
<tr><td>11</td><td>11_post_method_with_payload_test.py</td><td>zaslání dat na server s&nbsp;využitím metody POST</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/tests/11_post_method_with_payload_test.py">https://github.com/tisnik/testing-in-python/tree/master/tests/11_post_method_with_payload_test.py</a></td></tr>
<tr><td>12</td><td>12_post_method_with_payload_test.py</td><td>předání dat serveru v&nbsp;těle HTTP požadavku typu POST</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/tests/12_post_method_with_payload_test.py">https://github.com/tisnik/testing-in-python/tree/master/tests/12_post_method_with_payload_test.py</a></td></tr>
<tr><td>13</td><td>13_cookies_tests.py</td><td>předání cookies v&nbsp;požadavku a test dat vrácených v&nbsp;odpovědi serveru</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/tests/13_cookies_tests.py">https://github.com/tisnik/testing-in-python/tree/master/tests/13_cookies_tests.py</a></td></tr>
<tr><td>14</td><td>14_session_cookies_tests.py</td><td>správa sezení s&nbsp;využitím cookies</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/tests/14_session_cookies_tests.py">https://github.com/tisnik/testing-in-python/tree/master/tests/14_session_cookies_tests.py</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články s&nbsp;tématem testování (nejenom) v&nbsp;Pythonu</h2>

<p>Tématem testování jsme se již na stránkách Rootu několikrát zabývali. Jedná
se mj.&nbsp;o následující články:</p>

<ol>

<li>Použití Pythonu pro tvorbu testů: od jednotkových testů až po testy UI<br />
<a href="https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-od-jednotkovych-testu-az-po-testy-ui/">https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-od-jednotkovych-testu-az-po-testy-ui/</a>
</li>

<li>Použití Pythonu pro tvorbu testů: použití třídy Mock z knihovny unittest.mock<br />
<a href="https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-pouziti-tridy-mock-z-knihovny-unittest-mock/">https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-pouziti-tridy-mock-z-knihovny-unittest-mock/</a>
</li>

<li>Použití nástroje pytest pro tvorbu jednotkových testů a benchmarků<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-pytest-pro-tvorbu-jednotkovych-testu-a-benchmarku/">https://www.root.cz/clanky/pouziti-nastroje-pytest-pro-tvorbu-jednotkovych-testu-a-benchmarku/</a>
</li>

<li>Nástroj pytest a jednotkové testy: fixtures, výjimky, parametrizace testů<br />
<a href="https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-fixtures-vyjimky-parametrizace-testu/">https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-fixtures-vyjimky-parametrizace-testu/</a>
</li>

<li>Nástroj pytest a jednotkové testy: životní cyklus testů, užitečné tipy a triky<br />
<a href="https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-zivotni-cyklus-testu-uzitecne-tipy-a-triky/">https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-zivotni-cyklus-testu-uzitecne-tipy-a-triky/</a>
</li>

<li>Struktura projektů s jednotkovými testy, využití Travis CI<br />
<a href="https://www.root.cz/clanky/struktura-projektu-s-jednotkovymi-testy-vyuziti-travis-ci/">https://www.root.cz/clanky/struktura-projektu-s-jednotkovymi-testy-vyuziti-travis-ci/</a>
</li>

<li>Omezení stavového prostoru testovaných funkcí a metod<br />
<a href="https://www.root.cz/clanky/omezeni-stavoveho-prostoru-testovanych-funkci-a-metod/">https://www.root.cz/clanky/omezeni-stavoveho-prostoru-testovanych-funkci-a-metod/</a>
</li>

<li>Testování aplikací s využitím nástroje Hypothesis<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-s-vyuzitim-nastroje-hypothesis/">https://www.root.cz/clanky/testovani-aplikaci-s-vyuzitim-nastroje-hypothesis/</a>
</li>

<li>Testování aplikací s využitím nástroje Hypothesis (dokončení)<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-s-vyuzitim-nastroje-hypothesis-dokonceni/">https://www.root.cz/clanky/testovani-aplikaci-s-vyuzitim-nastroje-hypothesis-dokonceni/</a>
</li>

<li>Testování webových aplikací s REST API z Pythonu<br />
<a href="https://www.root.cz/clanky/testovani-webovych-aplikaci-s-rest-api-z-pythonu/">https://www.root.cz/clanky/testovani-webovych-aplikaci-s-rest-api-z-pythonu/</a>
</li>

<li>Testování webových aplikací s REST API z Pythonu (2)<br />
<a href="https://www.root.cz/clanky/testovani-webovych-aplikaci-s-rest-api-z-pythonu-2/">https://www.root.cz/clanky/testovani-webovych-aplikaci-s-rest-api-z-pythonu-2/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave (druhá část)<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-druha-cast/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-druha-cast/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave (závěrečná část)<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-zaverecna-cast/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-zaverecna-cast/</a>
</li>

<li>Validace datových struktur v Pythonu pomocí knihoven Schemagic a Schema<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/</a>
</li>

<li>Validace datových struktur v Pythonu (2. část)<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-2-cast/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-2-cast/</a>
</li>

<li>Validace datových struktur v Pythonu (dokončení)<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-dokonceni/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-dokonceni/</a>
</li>

<li>Univerzální testovací nástroj Robot Framework<br />
<a href="https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework/">https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework/</a>
</li>

<li>Univerzální testovací nástroj Robot Framework a BDD testy<br />
<a href="https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework-a-bdd-testy/">https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework-a-bdd-testy/</a>
</li>

<li>Úvod do problematiky fuzzingu a fuzz testování<br />
<a href="https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani/">https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani/</a>
</li>

<li>Úvod do problematiky fuzzingu a fuzz testování – složení vlastního fuzzeru<br />
<a href="https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani-slozeni-vlastniho-fuzzeru/">https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani-slozeni-vlastniho-fuzzeru/</a>
</li>

<li>Knihovny a moduly usnadňující testování aplikací naprogramovaných v jazyce Clojure<br />
<a href="https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/">https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/</a>
</li>

<li>Validace dat s využitím knihovny spec v Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

<li>Testování aplikací naprogramovaných v jazyce Go<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/">https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/</a>
</li>

<li>Knihovny určené pro tvorbu testů v programovacím jazyce Go<br />
<a href="https://www.root.cz/clanky/knihovny-urcene-pro-tvorbu-testu-v-programovacim-jazyce-go/">https://www.root.cz/clanky/knihovny-urcene-pro-tvorbu-testu-v-programovacim-jazyce-go/</a>
</li>

<li>Testování aplikací psaných v Go s využitím knihoven Goblin a Frisby<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/">https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/</a>
</li>

<li>Testování Go aplikací s využitím knihovny GΩmega a frameworku Ginkgo<br />
<a href="https://www.root.cz/clanky/testovani-go-aplikaci-s-vyuzitim-knihovny-gomega-mega-a-frameworku-ginkgo/">https://www.root.cz/clanky/testovani-go-aplikaci-s-vyuzitim-knihovny-gomega-mega-a-frameworku-ginkgo/</a>
</li>

<li>Tvorba BDD testů s využitím jazyka Go a nástroje godog<br />
<a href="https://www.root.cz/clanky/tvorba-bdd-testu-s-vyuzitim-jazyka-go-a-nastroje-godog/">https://www.root.cz/clanky/tvorba-bdd-testu-s-vyuzitim-jazyka-go-a-nastroje-godog/</a>
</li>

<li>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem<br />
<a href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/">https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/</a>
</li>

<li>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem (dokončení)<br />
<a href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem-dokonceni/">https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem-dokonceni/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure (2)<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Requests: HTTP for Humans (dokumentace)<br />
<a href="http://docs.python-requests.org/en/master/">http://docs.python-requests.org/en/master/</a>
</li>

<li>Requests: Introduction<br />
<a href="http://docs.python-requests.org/en/latest/user/intro/">http://docs.python-requests.org/en/latest/user/intro/</a>
</li>

<li>Requests na GitHubu<br />
<a href="https://github.com/requests/requests">https://github.com/requests/requests</a>
</li>

<li>Requests (software) na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Requests_%28software%29">https://en.wikipedia.org/wiki/Requests_%28software%29</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>20 Python libraries you can’t live without<br />
<a href="https://pythontips.com/2013/07/30/20-python-libraries-you-cant-live-without/">https://pythontips.com/2013/07/30/20-python-libraries-you-cant-live-without/</a>
</li>

<li>What are the top 10 most useful and influential Python libraries and frameworks?<br />
<a href="https://www.quora.com/What-are-the-top-10-most-useful-and-influential-Python-libraries-and-frameworks">https://www.quora.com/What-are-the-top-10-most-useful-and-influential-Python-libraries-and-frameworks</a>
</li>

<li>Python: useful modules<br />
<a href="https://wiki.python.org/moin/UsefulModules">https://wiki.python.org/moin/UsefulModules</a>
</li>

<li>Top 15 most popular Python libraries<br />
<a href="https://keyua.org/blog/most-popular-python-libraries/">https://keyua.org/blog/most-popular-python-libraries/</a>
</li>

<li>Hypertext Transfer Protocol<br />
<a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a>
</li>

<li>List of HTTP header fields<br />
<a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">https://en.wikipedia.org/wiki/List_of_HTTP_header_fields</a>
</li>

<li>List of HTTP status codes<br />
<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">https://en.wikipedia.org/wiki/List_of_HTTP_status_codes</a>
</li>

<li>Python requests deep dive<br />
<a href="https://medium.com/@anthonypjshaw/python-requests-deep-dive-a0a5c5c1e093">https://medium.com/@anthonypjshaw/python-requests-deep-dive-a0a5c5c1e093</a>
</li>

<li>The awesome requests module<br />
<a href="https://www.pythonforbeginners.com/requests/the-awesome-requests-module">https://www.pythonforbeginners.com/requests/the-awesome-requests-module</a>
</li>

<li>Send HTTP Requests in Python<br />
<a href="https://code-maven.com/http-requests-in-python">https://code-maven.com/http-requests-in-python</a>
</li>

<li>Introducing JSON<br />
<a href="http://json.org/">http://json.org/</a>
</li>

<li>Writing tests for RESTful APIs in Python using requests – part 1: basic tests<br />
<a href="https://www.ontestautomation.com/writing-tests-for-restful-apis-in-python-using-requests-part-1-basic-tests/">https://www.ontestautomation.com/writing-tests-for-restful-apis-in-python-using-requests-part-1-basic-tests/</a>
</li>

<li>Step by Step Rest API Testing using Python + Pytest + Allure<br />
<a href="https://www.udemy.com/course/api-testing-python/">https://www.udemy.com/course/api-testing-python/</a>
</li>

<li>Prime formulas and polynomial functions<br />
<a href="https://en.wikipedia.org/wiki/Formula_for_primes#Prime_formulas_and_polynomial_functions">https://en.wikipedia.org/wiki/Formula_for_primes#Prime_formulas_and_polynomial_functions</a>
</li>

<li>Prime-Generating Polynomial<br />
<a href="https://mathworld.wolfram.com/Prime-GeneratingPolynomial.html">https://mathworld.wolfram.com/Prime-GeneratingPolynomial.html</a>
</li>

<li>Hoare logic<br />
<a href="https://en.wikipedia.org/wiki/Hoare_logic">https://en.wikipedia.org/wiki/Hoare_logic</a>
</li>

<li>Goto Fail, Heartbleed, and Unit Testing Culture<br />
<a href="https://martinfowler.com/articles/testing-culture.html">https://martinfowler.com/articles/testing-culture.html</a>
</li>

<li>PEP-484<br />
<a href="https://www.python.org/dev/peps/pep-0484/">https://www.python.org/dev/peps/pep-0484/</a>
</li>

<li>In-depth: Functional programming in C++<br />
<a href="https://www.gamasutra.com/view/news/169296/Indepth_Functional_programming_in_C.php">https://www.gamasutra.com/view/news/169296/Indepth_Functional_programming_in_C.php</a>
</li>

<li>mypy<br />
<a href="http://www.mypy-lang.org/">http://www.mypy-lang.org/</a>
</li>

<li>Welcome to Mypy documentation!<br />
<a href="https://mypy.readthedocs.io/en/latest/index.html">https://mypy.readthedocs.io/en/latest/index.html</a>
</li>

<li>mypy na GitHubu<br />
<a href="https://github.com/python/mypy">https://github.com/python/mypy</a>
</li>

<li>mypy 0.770 na PyPi<br />
<a href="https://pypi.org/project/mypy/">https://pypi.org/project/mypy/</a>
</li>

<li>Extensions for mypy (separated out from mypy/extensions)<br />
<a href="https://github.com/python/mypy_extensions">https://github.com/python/mypy_extensions</a>
</li>

<li>The Mypy Blog<br />
<a href="https://mypy-lang.blogspot.com/2020/03/mypy-0770-released.html">https://mypy-lang.blogspot.com/2020/03/mypy-0770-released.html</a>
</li>

<li>Our journey to type checking 4 million lines of Python<br />
<a href="https://dropbox.tech/application/our-journey-to-type-checking-4-million-lines-of-python">https://dropbox.tech/application/our-journey-to-type-checking-4-million-lines-of-python</a>
</li>

<li>Type-Checking Python Programs With Type Hints and mypy<br />
<a href="https://www.youtube.com/watch?v=2xWhaALHTvU">https://www.youtube.com/watch?v=2xWhaALHTvU</a>
</li>

<li>Refactoring to Immutability - Kevlin Henney<br />
<a href="https://www.youtube.com/watch?v=APUCMSPiNh4">https://www.youtube.com/watch?v=APUCMSPiNh4</a>
</li>

<li>Bernat Gabor - Type hinting (and mypy) - PyCon 2019<br />
<a href="https://www.youtube.com/watch?v=hTrjTAPnA_k">https://www.youtube.com/watch?v=hTrjTAPnA_k</a>
</li>

<li>Stanford Seminar - Optional Static Typing for Python<br />
<a href="https://www.youtube.com/watch?v=GiZKuyLKvAA">https://www.youtube.com/watch?v=GiZKuyLKvAA</a>
</li>

<li>mypy Getting to Four Million Lines of Typed Python - Michael Sullivan<br />
<a href="https://www.youtube.com/watch?v=FT_WHV4-QcU">https://www.youtube.com/watch?v=FT_WHV4-QcU</a>
</li>

<li>Shebang<br />
<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">https://en.wikipedia.org/wiki/Shebang_(Unix)</a>
</li>

<li>pytest 5.4.2 na PyPi<br />
<a href="https://pypi.org/project/pytest/">https://pypi.org/project/pytest/</a>
</li>

<li>Hillel Wayne - Beyond Unit Tests: Taking Your Testing to the Next Level - PyCon 2018<br />
<a href="https://www.youtube.com/watch?v=MYucYon2-lk">https://www.youtube.com/watch?v=MYucYon2-lk</a>
</li>

<li>Awesome Python &ndash; testing<br />
<a href="https://github.com/vinta/awesome-python#testing">https://github.com/vinta/awesome-python#testing</a>
</li>

<li>pytest Plugins Compatibility<br />
<a href="http://plugincompat.herokuapp.com/">http://plugincompat.herokuapp.com/</a>
</li>

<li>Selenium (pro Python)<br />
<a href="https://pypi.org/project/selenium/">https://pypi.org/project/selenium/</a>
</li>

<li>Getting Started With Testing in Python<br />
<a href="https://realpython.com/python-testing/">https://realpython.com/python-testing/</a>
</li>

<li>unittest.mock — mock object library<br />
<a href="https://docs.python.org/3.5/library/unittest.mock.html">https://docs.python.org/3.5/library/unittest.mock.html</a>
</li>

<li>mock 2.0.0<br />
<a href="https://pypi.python.org/pypi/mock">https://pypi.python.org/pypi/mock</a>
</li>

<li>An Introduction to Mocking in Python<br />
<a href="https://www.toptal.com/python/an-introduction-to-mocking-in-python">https://www.toptal.com/python/an-introduction-to-mocking-in-python</a>
</li>

<li>Mock - Mocking and Testing Library<br />
<a href="http://mock.readthedocs.io/en/stable/">http://mock.readthedocs.io/en/stable/</a>
</li>

<li>Python Mocking 101: Fake It Before You Make It<br />
<a href="https://blog.fugue.co/2016-02-11-python-mocking-101.html">https://blog.fugue.co/2016-02-11-python-mocking-101.html</a>
</li>

<li>Nauč se Python! - Testování<br />
<a href="http://naucse.python.cz/lessons/intro/testing/">http://naucse.python.cz/lessons/intro/testing/</a>
</li>

<li>Flexmock (dokumentace)<br />
<a href="https://flexmock.readthedocs.io/en/latest/">https://flexmock.readthedocs.io/en/latest/</a>
</li>

<li>Test Fixture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test_fixture">https://en.wikipedia.org/wiki/Test_fixture</a>
</li>

<li>Mock object (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Mock_object">https://en.wikipedia.org/wiki/Mock_object</a>
</li>

<li>Extrémní programování<br />
<a href="https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD">https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD</a>
</li>

<li>Programování řízené testy<br />
<a href="https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy">https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>Tox<br />
<a href="https://tox.readthedocs.io/en/latest/">https://tox.readthedocs.io/en/latest/</a>
</li>

<li>pytest: helps you write better programs<br />
<a href="https://docs.pytest.org/en/latest/">https://docs.pytest.org/en/latest/</a>
</li>

<li>doctest — Test interactive Python examples<br />
<a href="https://docs.python.org/dev/library/doctest.html#module-doctest">https://docs.python.org/dev/library/doctest.html#module-doctest</a>
</li>

<li>unittest — Unit testing framework<br />
<a href="https://docs.python.org/dev/library/unittest.html">https://docs.python.org/dev/library/unittest.html</a>
</li>

<li>Python namespaces<br />
<a href="https://bytebaker.com/2008/07/30/python-namespaces/">https://bytebaker.com/2008/07/30/python-namespaces/</a>
</li>

<li>Namespaces and Scopes<br />
<a href="https://www.python-course.eu/namespaces.php">https://www.python-course.eu/namespaces.php</a>
</li>

<li>Stránka projektu Robot Framework<br />
<a href="https://robotframework.org/">https://robotframework.org/</a>
</li>

<li>GitHub repositář Robot Frameworku<br />
<a href="https://github.com/robotframework/robotframework">https://github.com/robotframework/robotframework</a>
</li>

<li>Robot Framework (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Robot_Framework">https://en.wikipedia.org/wiki/Robot_Framework</a>
</li>

<li>Tutoriál Robot Frameworku<br />
<a href="http://www.robotframeworktutorial.com/">http://www.robotframeworktutorial.com/</a>
</li>

<li>Robot Framework Documentation<br />
<a href="https://robotframework.org/robotframework/">https://robotframework.org/robotframework/</a>
</li>

<li>Robot Framework Introduction<br />
<a href="https://blog.testproject.io/2016/11/22/robot-framework-introduction/">https://blog.testproject.io/2016/11/22/robot-framework-introduction/</a>
</li>

<li>robotframework 3.1.2 na PyPi<br />
<a href="https://pypi.org/project/robotframework/">https://pypi.org/project/robotframework/</a>
</li>

<li>Robot Framework demo (GitHub)<br />
<a href="https://github.com/robotframework/RobotDemo">https://github.com/robotframework/RobotDemo</a>
</li>

<li>Robot Framework web testing demo using SeleniumLibrary<br />
<a href="https://github.com/robotframework/WebDemo">https://github.com/robotframework/WebDemo</a>
</li>

<li>Robot Framework for Mobile Test Automation Demo<br />
<a href="https://www.youtube.com/watch?v=06LsU08slP8">https://www.youtube.com/watch?v=06LsU08slP8</a>
</li>

<li>Gherkin<br />
<a href="https://cucumber.io/docs/gherkin/">https://cucumber.io/docs/gherkin/</a>
</li>

<li>Selenium<br />
<a href="https://selenium.dev/">https://selenium.dev/</a>
</li>

<li>SeleniumLibrary<br />
<a href="https://robotframework.org/">https://robotframework.org/</a>
</li>

<li>The Practical Test Pyramid<br />
<a href="https://martinfowler.com/articles/practical-test-pyramid.html">https://martinfowler.com/articles/practical-test-pyramid.html</a>
</li>

<li>Acceptance Tests and the Testing Pyramid<br />
<a href="http://www.blog.acceptancetestdrivendevelopment.com/acceptance-tests-and-the-testing-pyramid/">http://www.blog.acceptancetestdrivendevelopment.com/acceptance-tests-and-the-testing-pyramid/</a>
</li>

<li>Tab-separated values<br />
<a href="https://en.wikipedia.org/wiki/Tab-separated_values">https://en.wikipedia.org/wiki/Tab-separated_values</a>
</li>

<li>A quick guide about Python implementations<br />
<a href="https://blog.rmotr.com/a-quick-guide-about-python-implementations-aa224109f321">https://blog.rmotr.com/a-quick-guide-about-python-implementations-aa224109f321</a>
</li>

<li>radamsa<br />
<a href="https://gitlab.com/akihe/radamsa">https://gitlab.com/akihe/radamsa</a>
</li>

<li>Fuzzing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Fuzzing">https://en.wikipedia.org/wiki/Fuzzing</a>
</li>

<li>american fuzzy lop<br />
<a href="http://lcamtuf.coredump.cx/afl/">http://lcamtuf.coredump.cx/afl/</a>
</li>

<li>Fuzzing: the new unit testing<br />
<a href="https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide#1">https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide#1</a>
</li>

<li>Corpus for github.com/dvyukov/go-fuzz examples<br />
<a href="https://github.com/dvyukov/go-fuzz-corpus">https://github.com/dvyukov/go-fuzz-corpus</a>
</li>

<li>AFL &ndash; QuickStartGuide.txt<br />
<a href="https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt">https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt</a>
</li>

<li>Introduction to Fuzzing in Python with AFL<br />
<a href="https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/">https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/</a>
</li>

<li>Writing a Simple Fuzzer in Python<br />
<a href="https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/">https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/</a>
</li>

<li>How to Fuzz Go Code with go-fuzz (Continuously)<br />
<a href="https://fuzzit.dev/2019/10/02/how-to-fuzz-go-code-with-go-fuzz-continuously/">https://fuzzit.dev/2019/10/02/how-to-fuzz-go-code-with-go-fuzz-continuously/</a>
</li>

<li>Golang Fuzzing: A go-fuzz Tutorial and Example<br />
<a href="http://networkbit.ch/golang-fuzzing/">http://networkbit.ch/golang-fuzzing/</a>
</li>

<li>Fuzzing Python Modules<br />
<a href="https://stackoverflow.com/questions/20749026/fuzzing-python-modules">https://stackoverflow.com/questions/20749026/fuzzing-python-modules</a>
</li>

<li>0x3 Python Tutorial: Fuzzer<br />
<a href="http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/">http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/</a>
</li>

<li>fuzzing na PyPi<br />
<a href="https://pypi.org/project/fuzzing/">https://pypi.org/project/fuzzing/</a>
</li>

<li>Fuzzing 0.3.2 documentation<br />
<a href="https://fuzzing.readthedocs.io/en/latest/">https://fuzzing.readthedocs.io/en/latest/</a>
</li>

<li>Randomized testing for Go<br />
<a href="https://github.com/dvyukov/go-fuzz">https://github.com/dvyukov/go-fuzz</a>
</li>

<li>HTTP/2 fuzzer written in Golang<br />
<a href="https://github.com/c0nrad/http2fuzz">https://github.com/c0nrad/http2fuzz</a>
</li>

<li>Ffuf (Fuzz Faster U Fool) – An Open Source Fast Web Fuzzing Tool<br />
<a href="https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html">https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html</a>
</li>

<li>Continuous Fuzzing Made Simple<br />
<a href="https://fuzzit.dev/">https://fuzzit.dev/</a>
</li>

<li>Halt and Catch Fire<br />
<a href="https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86">https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86</a>
</li>

<li>Random testing<br />
<a href="https://en.wikipedia.org/wiki/Random_testing">https://en.wikipedia.org/wiki/Random_testing</a>
</li>

<li>Monkey testing<br />
<a href="https://en.wikipedia.org/wiki/Monkey_testing">https://en.wikipedia.org/wiki/Monkey_testing</a>
</li>

<li>Fuzzing for Software Security Testing and Quality Assurance, Second Edition<br />
<a href="https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false">https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false</a>
</li>

<li>libFuzzer – a library for coverage-guided fuzz testing<br />
<a href="https://llvm.org/docs/LibFuzzer.html">https://llvm.org/docs/LibFuzzer.html</a>
</li>

<li>fuzzy-swagger na PyPi<br />
<a href="https://pypi.org/project/fuzzy-swagger/">https://pypi.org/project/fuzzy-swagger/</a>
</li>

<li>fuzzy-swagger na GitHubu<br />
<a href="https://github.com/namuan/fuzzy-swagger">https://github.com/namuan/fuzzy-swagger</a>
</li>

<li>Fuzz testing tools for Python<br />
<a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy#Fuzz_Testing_Tools">https://wiki.python.org/moin/PythonTestingToolsTaxonomy#Fuzz_Testing_Tools</a>
</li>

<li>A curated list of awesome Go frameworks, libraries and software<br />
<a href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go</a>
</li>

<li>gofuzz: a library for populating go objects with random values<br />
<a href="https://github.com/google/gofuzz">https://github.com/google/gofuzz</a>
</li>

<li>tavor: A generic fuzzing and delta-debugging framework<br />
<a href="https://github.com/zimmski/tavor">https://github.com/zimmski/tavor</a>
</li>

<li>hypothesis na GitHubu<br />
<a href="https://github.com/HypothesisWorks/hypothesis">https://github.com/HypothesisWorks/hypothesis</a>
</li>

<li>Hypothesis: Test faster, fix more<br />
<a href="https://hypothesis.works/">https://hypothesis.works/</a>
</li>

<li>Hypothesis<br />
<a href="https://hypothesis.works/articles/intro/">https://hypothesis.works/articles/intro/</a>
</li>

<li>What is Hypothesis?<br />
<a href="https://hypothesis.works/articles/what-is-hypothesis/">https://hypothesis.works/articles/what-is-hypothesis/</a>
</li>

<li>What is Property Based Testing?<br />
<a href="https://hypothesis.works/articles/what-is-property-based-testing/">https://hypothesis.works/articles/what-is-property-based-testing/</a>
</li>

<li>Databáze CVE<br />
<a href="https://www.cvedetails.com/">https://www.cvedetails.com/</a>
</li>

<li>Fuzz test Python modules with libFuzzer<br />
<a href="https://github.com/eerimoq/pyfuzzer">https://github.com/eerimoq/pyfuzzer</a>
</li>

<li>Taof - The art of fuzzing<br />
<a href="https://sourceforge.net/projects/taof/">https://sourceforge.net/projects/taof/</a>
</li>

<li>JQF + Zest: Coverage-guided semantic fuzzing for Java<br />
<a href="https://github.com/rohanpadhye/jqf">https://github.com/rohanpadhye/jqf</a>
</li>

<li>http2fuzz<br />
<a href="https://github.com/c0nrad/http2fuzz">https://github.com/c0nrad/http2fuzz</a>
</li>

<li>Demystifying hypothesis testing with simple Python examples<br />
<a href="https://towardsdatascience.com/demystifying-hypothesis-testing-with-simple-python-examples-4997ad3c5294">https://towardsdatascience.com/demystifying-hypothesis-testing-with-simple-python-examples-4997ad3c5294</a>
</li>

<li>Testování<br />
<a href="http://voho.eu/wiki/testovani/">http://voho.eu/wiki/testovani/</a>
</li>

<li>Unit testing (Wikipedia.en)<br />
<a href="https://en.wikipedia.org/wiki/Unit_testing">https://en.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit testing (Wikipedia.cz)<br />
<a href="https://cs.wikipedia.org/wiki/Unit_testing">https://cs.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit Test vs Integration Test<br />
<a href="https://www.youtube.com/watch?v=0GypdsJulKE">https://www.youtube.com/watch?v=0GypdsJulKE</a>
</li>

<li>TestDouble<br />
<a href="https://martinfowler.com/bliki/TestDouble.html">https://martinfowler.com/bliki/TestDouble.html</a>
</li>

<li>Test Double<br />
<a href="http://xunitpatterns.com/Test%20Double.html">http://xunitpatterns.com/Test%20Double.html</a>
</li>

<li>Test-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test-driven_development">https://en.wikipedia.org/wiki/Test-driven_development</a>
</li>

<li>Acceptance test–driven development<br />
<a href="https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development">https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development</a>
</li>

<li>Gauge<br />
<a href="https://gauge.org/">https://gauge.org/</a>
</li>

<li>Gauge (software)<br />
<a href="https://en.wikipedia.org/wiki/Gauge_(software)">https://en.wikipedia.org/wiki/Gauge_(software)</a>
</li>

<li>PYPL PopularitY of Programming Language<br />
<a href="https://pypl.github.io/PYPL.html">https://pypl.github.io/PYPL.html</a>
</li>

<li>Testing is Good. Pyramids are Bad. Ice Cream Cones are the Worst<br />
<a href="https://medium.com/@fistsOfReason/testing-is-good-pyramids-are-bad-ice-cream-cones-are-the-worst-ad94b9b2f05f">https://medium.com/@fistsOfReason/testing-is-good-pyramids-are-bad-ice-cream-cones-are-the-worst-ad94b9b2f05f</a>
</li>

<li>Články a zprávičky věnující se Pythonu<br />
<a href="https://www.root.cz/n/python/">https://www.root.cz/n/python/</a>
</li>

<li>PythonTestingToolsTaxonomy<br />
<a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy">https://wiki.python.org/moin/PythonTestingToolsTaxonomy</a>
</li>

<li>Top 6 BEST Python Testing Frameworks [Updated 2020 List]<br />
<a href="https://www.softwaretestinghelp.com/python-testing-frameworks/">https://www.softwaretestinghelp.com/python-testing-frameworks/</a>
</li>

<li>pytest-print 0.1.3<br />
<a href="https://pypi.org/project/pytest-print/">https://pypi.org/project/pytest-print/</a>
</li>

<li>pytest fixtures: explicit, modular, scalable<br />
<a href="https://docs.pytest.org/en/latest/fixture.html">https://docs.pytest.org/en/latest/fixture.html</a>
</li>

<li>PyTest Tutorial: What is, Install, Fixture, Assertions<br />
<a href="https://www.guru99.com/pytest-tutorial.html">https://www.guru99.com/pytest-tutorial.html</a>
</li>

<li>Pytest - Fixtures<br />
<a href="https://www.tutorialspoint.com/pytest/pytest_fixtures.htm">https://www.tutorialspoint.com/pytest/pytest_fixtures.htm</a>
</li>

<li>Marking test functions with attributes<br />
<a href="https://docs.pytest.org/en/latest/mark.html">https://docs.pytest.org/en/latest/mark.html</a>
</li>

<li>pytest-print<br />
<a href="https://pytest-print.readthedocs.io/en/latest/">https://pytest-print.readthedocs.io/en/latest/</a>
</li>

<li>Continuous integration<br />
<a href="https://en.wikipedia.org/wiki/Continuous_integration">https://en.wikipedia.org/wiki/Continuous_integration</a>
</li>

<li>Travis CI<br />
<a href="https://travis-ci.org/">https://travis-ci.org/</a>
</li>

<li>Mutation testing<br />
<a href="https://en.wikipedia.org/wiki/Mutation_testing">https://en.wikipedia.org/wiki/Mutation_testing</a>
</li>

<li>Články o Hypothesis<br />
<a href="https://news.ycombinator.com/from?site=hypothesis.works">https://news.ycombinator.com/from?site=hypothesis.works</a>
</li>

<li>Testovací případ<br />
<a href="https://cs.wikipedia.org/wiki/Testovac%C3%AD_p%C5%99%C3%ADpad">https://cs.wikipedia.org/wiki/Testovac%C3%AD_p%C5%99%C3%ADpad</a>
</li>

<li>Most testing is ineffective<br />
<a href="https://hypothesis.works/">https://hypothesis.works/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

