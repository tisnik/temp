<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Při psaní jednotkových testů (a vlastně nejenom jich) se většinou snažíme s co nejmenším úsilím otestovat co největší množství kombinací z celého možného stavového prostoru. K tomu slouží jak nástroje typu Hypothesis, tak i omezení velikosti tohoto prostoru, například s využitím Mypy.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Omezení stavového prostoru testovaných funkcí a metod</a></p>
<p><a href="#k02">2. Příklad polymorfní funkce v&nbsp;Pythonu</a></p>
<p><a href="#k03">3. Nástroj <i>mypy</i> aneb nepovinná deklarace datových typů</a></p>
<p><a href="#k04">4. Funkce akceptující parametry vybraných typů</a></p>
<p><a href="#k05">5. Generické funkce</a></p>
<p><a href="#k06">6. Návratová hodnota generické funkce</a></p>
<p><a href="#k07">7. Postupná úprava projektu s&nbsp;funkcí pro výpočet faktoriálu</a></p>
<p><a href="#k08">8. Rozšíření jednotkových testů pro pokrytí všech větví kódu</a></p>
<p><a href="#k09">9. Chyby kvůli chybějícím typovým kontrolám</a></p>
<p><a href="#k10">10. Explicitní typové kontroly prováděné v&nbsp;čase běhu aplikace</a></p>
<p><a href="#k11">11. Použití typové deklarace a kontrola s&nbsp;využitím <i>mypy</i></a></p>
<p><a href="#k12">12. Pokus o použití typové deklarace používající <strong>Union</strong></a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">16. Jak pracné je přidat informace o typech do složitějších funkcí?</a></p>
<p><a href="#k17">17. Specifikace typů kontejnerů</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Předchozí články s&nbsp;tématem testování (nejenom) v&nbsp;Pythonu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Omezení stavového prostoru testovaných funkcí a metod</h2>

<p><i>&bdquo;A large fraction of the flaws in software development are due to
programmers not fully understanding all the possible states their code may
execute in.&ldquo;<br />
John Carmack</i></p>

<p>V&nbsp;sedmém článku o tvorbě testů s&nbsp;využitím programovacího jazyka <a
href="https://www.root.cz/n/python/">Python</a> se budeme zabývat tématem,
které sice může být považováno za okrajové, ovšem ve skutečnosti je pro psaní
dobrých testů poměrně důležité. Jedná se o to, jakým způsobem vůbec může autor
jednotkových testů (popř.&nbsp;později testů integračních) vůbec s&nbsp;rozumně
velkým úsilím obsáhnout celý <i>stavový prostor</i> testovaných modulů, ať již
se jedná o funkce, metody, třídy či o celé balíčky. Nejjednodušší (ovšem jen
relativně) je z&nbsp;pohledu testování stavový prostor čistých funkcí,
tj.&nbsp;funkcí, které produkují výstup čistě na základě svých parametrů;
nemají tedy vnitřní paměť. Složitější je situace u uzávěrů či generátorů, které
vnitřní paměť mají a ještě rozsáhlejší stavový prostor najedeme u (netřídních,
nestatických) metod či při testování celých tříd, zejména těch, které umožňují
měnit stav objektů (a to vůbec nemluvíme o kódu, který mění globální
proměnné).</p>

<p>V&nbsp;případě jednotkových testů je celá situace vlastně velmi spravedlivá
&ndash; autorem jednotkových testů i vlastního kódu bývá stejný vývojář, jenž
se buď může snažit o refaktoring kódu do takového stavu, že bude snadno
testovatelný, či naopak bude věnovat více času psaní jednotkových testů
(samozřejmě za předpokladu, že je jeho cílem mít stabilní a relativně bezchybný
produkt). Refaktoring může směřovat k&nbsp;vytváření čistých funkcí, neměnných
hodnot (<i>immutable</i>), k&nbsp;omezení globálního stavu aplikace apod.
(ostatně i z&nbsp;tohoto důvodu je podle mého názoru vhodné alespoň nějaký čas
věnovat studiu funkcionálních jazyků). V&nbsp;případě jazyka Python lze stavový
prostor omezit &ndash; a to mnohdy dosti podstatným způsobem &ndash; zavedením
nepovinných typových deklarací, což je nosné téma dnešního článku. Vedle snahy
o tvorbu programů takovým způsobem, aby byl jejich stavový prostor co nejvíce
omezen, existují i nástroje, které se po dodání vhodných informací snaží o
otestování všech z&nbsp;nějakého pohledu zajímavých či extrémních stavů.
Takovým nástrojem je <a href="https://hypothesis.works/">Hypothesis</a>, kterým
se budeme zabývat příště.</p>

<p><i>&bdquo;Many programming languages support programming in both functional
and imperative style but the syntax and facilities of a language are typically
optimised for only one of these styles, and social factors like coding
conventions and libraries often force the programmer towards one of the styles.
Therefore, programming languages may be categorized into functional and
imperative ones.&ldquo;</i></p>

<p>Jak jsme si již řekli v&nbsp;předchozím odstavci, dnes se budeme zabývat
především způsobem, jak do kódu v&nbsp;Pythonu zavést statické typové
informace, což je pochopitelně <i>velmi</i> kontroverzní téma, protože jeden
z&nbsp;důvodů velké obliby Pythonu je právě možnost elegantního zápisu programů
bez toho, aby se musel vývojář soustředit na (v&nbsp;daném kontextu)
nepodstatné detaily. Navíc může být díky dynamickému typovému systému mnoho
funkcí polymorfních, což opět vede ke zjednodušení tvorby programů. Příkladem
může být standardní polymorfní funkce <strong>len</strong>, která pracuje
korektně pro všechny datové typy, kde má slovo &bdquo;délka&ldquo; význam:
řetězce, n-tice, seznamy, množiny, objekt <strong>range</strong> atd.
Programátor si tedy nemusí pamatovat (jako v&nbsp;některých jiných jazycích),
že například délku kolekce získá metodou <strong>.size()</strong>, délku
řetězce naopak metodou <strong>.length()</strong> a velikost pole pro změnu
přečte z&nbsp;atributu <strong>length</strong>. Ovšem polymorfní funkce/metody
mají pochopitelně i některé nepříjemné vlastnosti a ty se týkají testování.</p>

<p><div class="rs-tip-major">Poznámka: termín <i>polymorfismus</i> má ve světě
programovacích jazyků (a ještě více v&nbsp;teorii programovacích jazyků) hned
několik významů. Polymorfní mohou být operátory (v&nbsp;mnoha jazycích, včetně
klasického céčka), funkce, metody i celé třídy. V&nbsp;dnešním článku si
vystačíme s&nbsp;polymorfními funkcemi a interně s&nbsp;polymorfními
operátory.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Příklad polymorfní funkce v&nbsp;Pythonu</h2>

<p><i>&bdquo;Write unit tests.&ldquo;<br />
&bdquo;Write unit tests.&ldquo;<br />
&bdquo;Write unit tests.&ldquo;<br />
<a href="https://youtu.be/MYucYon2-lk?t=167">https://youtu.be/MYucYon2-lk?t=167</a></i></p>

<p>Podívejme se nyní na příklad běžné funkce, která však má v&nbsp;Pythonu
polymorfní chování, konkrétně se chová různě pro různé typy hodnot předaných
této funkci. Funkce je to vlastně velmi primitivní &ndash; porovná hodnoty
svých dvou argumentů a vrátí hodnotu <strong>True</strong> pouze
v&nbsp;případě, že je hodnota prvního argumentu &bdquo;menší&ldquo;, než
hodnota argumentu druhého. Ovšem slovo &bdquo;menší&ldquo; je nutné chápat
v&nbsp;kontextu daného datového typu:</p>

<pre>
def <strong>compare</strong>(x, y):
    return x &lt; y
</pre>

<p><div class="rs-tip-major">Poznámka: viz též <a
href="https://github.com/tisnik/testing-in-python/tree/master/mypy/comparator1.py">https://github.com/tisnik/testing-in-python/tree/master/mypy/comparator1.py</a>.</div></p>

<p>Pro takovou funkci je možné napsat jednotkový test a přitom zcela ignorovat
fakt, že porovnávat lze i jiné hodnoty, než celá čísla:</p>

<pre>
<i>"""Jednotkové testy pro funkci compare."""</i>
&nbsp;
from comparator1 import compare
&nbsp;
&nbsp;
def <strong>test_comparator</strong>():
    <i>"""Jednotkový test pro porovnání dvou prvků."""</i>
    assert compare(1, 2)
    assert not compare(2, 1)
</pre>

<p>Tento jednotkový test proběhne v&nbsp;pořádku:</p>

<pre>
$ <strong>pytest -v test_comparator.py</strong>
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/mypy
plugins: print-0.1.3, voluptuous-1.0.2, cov-2.5.1
collecting ... collected 1 item
&nbsp;
comparator_test.py::test_comparator PASSED                               [100%]
&nbsp;
============================== 1 passed in 0.01s ===============================
</pre>

<p>Podobně dopadneme i při zjišťování pokrytí kódu jednotkovými testy:</p>

<pre>
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1
rootdir: /home/ptisnovs/src/python/testing-in-python/mypy
plugins: print-0.1.3, voluptuous-1.0.2, cov-2.5.1
collected 1 item
&nbsp;
comparator_test.py .                                                     [100%]
&nbsp;
============================== 1 passed in 0.02s ===============================
</pre>

<p>Stoprocentní pokrytí by mohlo vzbuzovat dojem, že se nám podařilo otestovat
celé a úplné chování funkce &ndash; celý stavový prostor tvořený hodnotami
jejich argumentů. Ten je v&nbsp;Pythonu skutečně obrovský, jak je naznačeno na
následujícím diagramu:</p>

<pre>
  ┌──────────────────────────────────────────────────────────────────────........┐
  │┌─────────────────────────┐┌────────────┐         ┌────────┐┌────────┐        │
  ││         float           ││   integer  │         │ string ││ bytes  │ tuple  │
  ││                         ││            │         │        ││        │        │
  ││                         ││       ┌────┤┌──────┐ │        ││        │ list   │
  ││                         ││       │bool││ None │ │        ││        │        │
  │└─────────────────────────┘└───────┴────┘└──────┘ │        ││        │ dict   │
  │┌───────────────────────────────────────────┐     │        ││        │        │
  ││                  complex                  │     │        ││        │ ...    │
  ││                                           │     │        ││        │ ...    │
  ││                                           │     │        ││        │ ...    │
  ││                                           │     │        ││        │        │
  │└───────────────────────────────────────────┘     └────────┘└────────┘        │
  └──────────────────────────────────────────────────────────────────────........┘
</pre>

<p>Ve skutečnosti je však stavový prostor mnohem větší, protože Python
umožňuje, aby se do funkce <strong>compare</strong> předaly i instance
libovolné třídy:</p>

<pre>
┌───────────────────────────────────────────────────────────────────────────────────┐
│                                                                                   │
│ ┌──────────────────────────────────────────────────────────────────────........┐  │
│ │┌─────────────────────────┐┌────────────┐         ┌────────┐┌────────┐        │  │
│ ││         float           ││   integer  │         │ string ││ bytes  │ tuple  │  │
│ ││                         ││            │         │        ││        │        │  │
│ ││                         ││       ┌────┤┌──────┐ │        ││        │ list   │  │
│ ││                         ││       │bool││ None │ │        ││        │        │  │
│ │└─────────────────────────┘└───────┴────┘└──────┘ │        ││        │ dict   │  │
│ │┌───────────────────────────────────────────┐     │        ││        │        │  │
│ ││                  complex                  │     │        ││        │ ...    │  │
│ ││                                           │     │        ││        │ ...    │  │
│ ││                                           │     │        ││        │ ...    │  │
│ ││                                           │     │        ││        │        │  │
│ │└───────────────────────────────────────────┘     └────────┘└────────┘        │  │
│ └──────────────────────────────────────────────────────────────────────........┘  │
│                                                                                   │
│                                                                                   │
│                                 všechny ostatní třídy                             │
│                                                                                   │
│                                                                                   │
└───────────────────────────────────────────────────────────────────────────────────┘
</pre>

<p>Můžeme se tedy pokusit napsat poněkud složitější jednotkový test:</p>

<pre>
<i>"""Jednotkové testy pro funkci compare."""</i>
&nbsp;
from comparator1 import compare
&nbsp;
&nbsp;
def <strong>test_comparator</strong>():
    <i>"""Jednotkový test pro porovnání dvou prvků."""</i>
    assert compare(1, 2)
    assert compare(1.2, 3.4)
    assert not compare("foo", "bar")
    assert compare([1, 2], [3, 4])
    assert not compare(True, False)
</pre>

<p>I tak jsme ovšem s&nbsp;celého stavového prostoru otestovali nepatrný zlomek
všech možných kombinací:</p>

<pre>
┌──────────────────────────────────────────────────────────────────────────────────────────┐
│                                                                                          │
│ ┌────────────────────────────────────────────────────────────────────────.............┐  │
│ │┌─────────────────────────┐┌─────────────┐         ┌─────────┐┌────────┐             │  │
│ ││         float           ││   integer   │         │ string  ││ bytes  │ tuple       │  │
│ ││                         ││<strong>[1,2]</strong>        │         │         ││        │             │  │
│ ││       <strong>[1.2, 3.4]</strong>        ││       ┌─────┤┌──────┐ │         ││        │ list        │  │
│ ││                         ││       │<strong>[T,F]</strong>││ None │ │         ││        │ <strong>[[1,2][3,4]]</strong>│  │
│ │└─────────────────────────┘└───────┴─────┘└──────┘ │         ││        │             │  │
│ │┌────────────────────────────────────────────┐     │         ││        │ dict        │  │
│ ││                  complex                   │     │<strong>[foo,bar]</strong>││        │             │  │
│ ││                                            │     │         ││        │ ...         │  │
│ ││                                            │     │         ││        │ ...         │  │
│ ││                                            │     │         ││        │ ...         │  │
│ │└────────────────────────────────────────────┘     └─────────┘└────────┘             │  │
│ └────────────────────────────────────────────────────────────────────────.............┘  │
│                                                                                          │
│                                                                                          │
│                                 všechny ostatní třídy                                    │
│                                                                                          │
│                                                                                          │
└──────────────────────────────────────────────────────────────────────────────────────────┘
</pre>

<p>To mj.&nbsp;znamená, že ani stoprocentní pokrytí kódu testy nemusí vůbec nic
znamenat a naše funkce nejenom že není řádně otestovaná, ale pro mnohé vstupy
ani nepracuje korektně (resp.&nbsp;její chování není komutativní, což je od
porovnání většinou očekáváno). Ostatně si to můžete ověřit:</p>

<pre>
<i>"""Jednotkové testy pro funkci compare."""</i>
&nbsp;
from comparator1 import compare
from math import nan
&nbsp;
&nbsp;
def <strong>test_comparator</strong>():
    <i>"""Jednotkový test komutativity."""</i>
    assert compare(1, 2) is not compare(2, 1)
    assert compare("foo", "bar") is not compare("bar", "foo")
    assert compare(nan, nan) is not compare(nan, nan)
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/mypy
plugins: print-0.1.3, voluptuous-1.0.2, cov-2.5.1
collecting ... collected 1 item
&nbsp;
comparator_test2.py::test_comparator FAILED                              [100%]
&nbsp;
=================================== FAILURES ===================================
_______________________________ test_comparator ________________________________
&nbsp;
    def test_comparator():
        """Jednotkový test komutativity."""
        assert compare(1, 2) is not compare(2, 1)
        assert compare("foo", "bar") is not compare("bar", "foo")
&gt;       assert compare(nan, nan) is not compare(nan, nan)
E       assert False is not False
E        +  where False = compare(nan, nan)
E        +  and   False = compare(nan, nan)
&nbsp;
comparator_test2.py:11: AssertionError
=========================== short test summary info ============================
FAILED comparator_test2.py::test_comparator - assert False is not False
============================== 1 failed in 0.03s ===============================
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Nástroj <i>mypy</i> aneb nepovinná deklarace datových typů</h2>

<p><i>&bdquo;<del>Types will save us!</del>&ldquo;</i></p>

<p>Již od doby vzniku prvních programovacích jazyků s&nbsp;dynamickým typovým
systémem (LISP 1) existuje tenze mezi zastánci silného typového systému a
dynamických typových systémů. Obě paradigmata mají své nesporné výhody, ale i
zápory, což v&nbsp;důsledcích vedlo k&nbsp;řešení, které vidíme i dnes &ndash;
samotný operační systém a jeho další součástí v&nbsp;user space jsou psány
v&nbsp;jazycích se statickým (schválně nepíšu silným) typovým systémem, zatímco
skripty jsou vytvářeny v&nbsp;dynamicky typovaných programovacích jazycích.
Existují samozřejmě snahy o propojení obou světů a jedním z&nbsp;příkladů této
snahy je i nástroj <i>mypy</i>, jehož některé vlastnosti si ukážeme
v&nbsp;následujících kapitolách.</p>

<p>Mypy lze nainstalovat stejným způsobem, jako jakýkoli jiný balíček pro
Python, tj.&nbsp;například s&nbsp;využitím nástroje
<strong>pip/pip3</strong>:</p>

<pre>
$ <strong>pip3 install --user mypy</strong>
</pre>

<p>Ovšem vzhledem k&nbsp;poměrně rychlému vývoji tohoto nástroje může být lepší
používat verzi získanou a nainstalovanou přímo z&nbsp;repositáře:</p>

<pre>
$ <strong>git clone --recurse-submodules https://github.com/python/mypy.git</strong>
$ <strong>cd mypy</strong>
$ <strong>sudo python3 -m pip install --upgrade .</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: poslední příkaz může být spuštěn i bez
<strong>sudo</strong> a s&nbsp;přepínačem <strong>--user</strong>, což zajistí
instalaci pouze pro aktuálně přihlášeného uživatele.</div></p>

<p>Takto nainstalovaná verze <i>mypy</i> by se měla ohlásit následujícím
způsobem:</p>

<pre>
$ <strong>mypy --version</strong>
&nbsp;
mypy 0.770+dev.1d7a6ae9fa313a93293a48585dcfc4e9dc482467
</pre>

<p>Existuje velké množství přepínačů a konfiguračních voleb. Prakticky žádnou
z&nbsp;nich prozatím nebudeme potřebovat, ale pochopitelně je možné si je
nechat vypsat ve formě nápovědy:</p>

<pre>
$ <strong>mypy --help</strong>
&nbsp;
usage: mypy [-h] [-v] [-V] [more options; see below]
            [-m MODULE] [-p PACKAGE] [-c PROGRAM_TEXT] [files ...]
&nbsp;
Mypy is a program that will type check your Python code.
&nbsp;
Pass in any files or folders you want to type check. Mypy will
recursively traverse any provided folders to find .py files:
&nbsp;
    $ mypy my_program.py my_src_folder
&nbsp;
For more information on getting started, see:
    ...
    ...
    ...
</pre>

<p>Podívejme se nyní na příklad použití tohoto nástroje. Nejprve si necháme
zanalyzovat zdrojový kód s&nbsp;funkcí, která žádné informace o typech
neobsahuje:</p>

<pre>
def <strong>compare</strong>(x, y):
    return x &lt; y
&nbsp;
&nbsp;
if __name__ == '__main__':
    <i># pouze se ujistíme, že lze spustit funkci compare</i>
    print(compare(1, 2))
    print(compare(1.2, 3.4))
    print(compare("foo", "bar"))
    print(compare([1, 2], [3, 4]))
    print(compare(True, False))
</pre>

<p>Analýza proběhne bez chyby, a to z&nbsp;toho důvodu, že <i>mypy</i> nedokáže
otestovat funkce a metody bez uvedení typových deklarací:</p>

<pre>
$ <strong>mypy comparator1.py</strong>
&nbsp;
Success: no issues found in 1 source file
</pre>

<p><div class="rs-tip-major">Poznámka: toto je velmi dobrá vlastnost, protože
si lze představit situaci, kdy se tento nástroj spustí na zdrojových kódech
rozsáhlých projektů. Pokud by se vypsaly (doslova) miliony chyb, asi by nikdo
z&nbsp;vývojářů vůbec neměl sílu začít tyto problémy řešit. S&nbsp;<i>mypy</i>
se postupuje opačně &ndash; typové deklarace se přidávají jen tam, kde jsou
z&nbsp;nějakého důvodu zapotřebí a ty lze následně otestovat.</div></p>

<p>Nyní do kódu přidáme informace o typech, které byly do Pythonu zavedeny
v&nbsp;souvislosti s&nbsp;<a
href="https://www.python.org/dev/peps/pep-0484/">PEP-484</a>. Specifikujeme, že
parametry funkce by měly být typu celé číslo a výsledek pak pravdivostní
hodnota:</p>

<pre>
def <strong>compare</strong>(x: int, y: int) -&gt; bool:
    return x &lt; y
&nbsp;
&nbsp;
print(compare(1, 2))
print(compare(1.2, 3.4))
print(compare("foo", "bar"))
print(compare([1, 2], [3, 4]))
print(compare(True, False))
&nbsp;
print("string" + compare(True, False))
</pre>

<p>Nyní již <i>mypy</i> dokáže detekovat problémy při volání funkce (a
popř.&nbsp;při zpracování její návratové hodnoty):</p>

<pre>
$ <strong>mypy comparator2.py</strong>
&nbsp;
comparator2.py:6: error: Argument 1 to "compare" has incompatible type "float"; expected "int"
comparator2.py:6: error: Argument 2 to "compare" has incompatible type "float"; expected "int"
comparator2.py:7: error: Argument 1 to "compare" has incompatible type "str"; expected "int"
comparator2.py:7: error: Argument 2 to "compare" has incompatible type "str"; expected "int"
comparator2.py:8: error: Argument 1 to "compare" has incompatible type "List[int]"; expected "int"
comparator2.py:8: error: Argument 2 to "compare" has incompatible type "List[int]"; expected "int"
comparator2.py:11: error: Unsupported operand types for + ("str" and "bool")
Found 7 errors in 1 file (checked 1 source file)
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Funkce akceptující parametry vybraných typů</h2>

<p>V&nbsp;některých situacích budeme potřebovat zajistit, aby nějaká funkce
akceptovala parametry nejenom jednoho datového typu, ale vybraných typů.
Poněkud umělým příkladem může být naše testovací funkce
<strong>compare</strong>, jejíž typovou definici lze upravit takovým způsobem,
aby akceptovala buď celá čísla, nebo i řetězce. K&nbsp;tomuto účelu se používá
tato typová deklarace:</p>

<pre>
Union[typ1, typ2, ...]
</pre>

<p>Zápis je tedy možné upravit následujícím způsobem:</p>

<pre>
from typing import Union
&nbsp;
&nbsp;
def <strong>compare</strong>(x: Union[int, str], y: Union[int, str]) -&gt; bool:
    return x &lt; y
&nbsp;
&nbsp;
print(compare(1, 2))
print(compare(1.2, 3.4))
print(compare("foo", "bar"))
print(compare([1, 2], [3, 4]))
print(compare(True, False))
&nbsp;
<i># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</i>
print(compare(1, "bar"))
print(compare("foo", 2))
</pre>

<p>Ve skutečnosti se ovšem problém s&nbsp;datovými typy nevyřešil uspokojivě, a
to z&nbsp;toho důvodu, že jeden z&nbsp;operandů nyní může být typu
<strong>int</strong> a druhý typu <strong>str</strong> či naopak (nikde není
řečeno, že oba operandy musí být stejného datového typu). Na tuto skutečnost
nás <i>mypy</i> upozorní, a to na jediném; konkrétně v&nbsp;samotném těle
funkce, kde z&nbsp;možných čtyř kombinací jsou pouze dvě korektní:</p>

<pre>
comparator3.py:5: error: Unsupported operand types for &lt; ("int" and "str")
comparator3.py:5: error: Unsupported operand types for &lt; ("str" and "int")
</pre>

<p>Naproti tomu samotné volání funkce, a to včetně dvou volání oddělených
vykřičníky, je již z&nbsp;pohledu <i>mypy</i> korektní, protože typy přesně
odpovídají typům deklarovaným:</p>

<pre>
$ <strong>mypy comparator3.py</strong>
&nbsp;
comparator3.py:5: note: Both left and right operands are unions
comparator3.py:9: error: Argument 1 to "compare" has incompatible type "float"; expected "Union[int, str]"
comparator3.py:9: error: Argument 2 to "compare" has incompatible type "float"; expected "Union[int, str]"
comparator3.py:11: error: Argument 1 to "compare" has incompatible type "List[int]"; expected "Union[int, str]"
comparator3.py:11: error: Argument 2 to "compare" has incompatible type "List[int]"; expected "Union[int, str]"
Found 6 errors in 1 file (checked 1 source file)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Generické funkce</h2>

<p>Nástroj <i>mypy</i> podporuje i deklaraci generických funkcí,
resp.&nbsp;přesněji řečeno umožňuje zápis, který se do značné míry generickým
funkcím podobá. Nejprve je nutné deklarovat nový datový typ, v&nbsp;našem
případě odpovídající buď celým číslům nebo řetězcům:</p>

<pre>
IntOrString = TypeVar("IntOrString", str, int)
</pre>

<p>Tento typ, který se &bdquo;naplní&ldquo; až u deklarace konkrétní funkce či
jiného datového typu, se používá následujícím způsobem:</p>

<pre>
def <strong>compare</strong>(x: IntOrString, y: IntOrString) -&gt; bool:
    ...
    ...
    ...
</pre>

<p>V&nbsp;této chvíli již můžeme náš demonstrační příklad s&nbsp;deklarací
funkce <strong>compare</strong> dokončit:</p>

<pre>
from typing import Union
from typing import TypeVar
&nbsp;
IntOrString = TypeVar("IntOrString", str, int)
&nbsp;
&nbsp;
def <strong>compare</strong>(x: IntOrString, y: IntOrString) -&gt; bool:
    return x &lt; y
&nbsp;
&nbsp;
print(compare(1, 2))
print(compare(1.2, 3.4))
print(compare("foo", "bar"))
print(compare([1, 2], [3, 4]))
print(compare(True, False))
</pre>

<p>A následně si nechat otestovat, zda a kdy je funkce použita správně:</p>

<pre>
$ <strong>mypy comparator4.py</strong>
&nbsp;
comparator4.py:12: error: Value of type variable "IntOrString" of "compare" cannot be "float"
comparator4.py:14: error: Value of type variable "IntOrString" of "compare" cannot be "List[int]"
Found 2 errors in 1 file (checked 1 source file)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že <i>mypy</i>
v&nbsp;této chvíli již nevypisuje chybu typu &bdquo;Unsupported operand types
for &lt; ("int" and "str")&ldquo;, která byla předtím detekována u operandů
operátoru &lt;.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Návratová hodnota generické funkce</h2>

<p>Ukažme si ještě jeden příklad generické funkce. Tentokrát se bude jednat o
funkci nazvanou <strong>add</strong>, která je určena buď pro součet dvou
celých čísel nebo pro spojení dvou řetězců (pochopitelně se opět jedná o umělý
&bdquo;školní&ldquo; příklad). U této funkce určíme jak typ obou parametrů, tak
i typ výsledné hodnoty &ndash; ve všech případech se musí jednat o shodný typ
(buď číslo nebo řetězec):</p>

<pre>
from typing import TypeVar
&nbsp;
IntOrString = TypeVar("IntOrString", str, int)
&nbsp;
&nbsp;
def <strong>add</strong>(x: IntOrString, y: IntOrString) -&gt; IntOrString:
    return x + y
&nbsp;
&nbsp;
print(add(1, 2))
print(add("foo", "bar"))
&nbsp;
print(add("foo", 2))
print(add(1, "bar"))
&nbsp;
print(42 + add(1,2))
print(42 + add("foo", "bar"))
&nbsp;
print("result: " + add("foo", "bar"))
print("result: " + add(1, 2))
</pre>

<p>S&nbsp;chybami, které byly nalezeny nástrojem <i>mypy</i>:</p>

<pre>
adder.py:13: error: Value of type variable "IntOrString" of "add" cannot be "object"
adder.py:14: error: Value of type variable "IntOrString" of "add" cannot be "object"
adder.py:17: error: Unsupported operand types for + ("int" and "str")
adder.py:20: error: Unsupported operand types for + ("str" and "int")
Found 4 errors in 1 file (checked 1 source file)
</pre>

<p><div class="rs-tip-major">Poznámka: opět můžeme vidět, že jsou nalezeny jak
nesprávné typy parametrů, tak i použití výsledků ve špatném kontextu (snaha o
spojení řetězce a celého čísla atd.)</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Postupná úprava projektu s&nbsp;funkcí pro výpočet faktoriálu</h2>

<p>V&nbsp;následujících kapitolách si ukážeme postupnou úpravu jednoduchého
projektu s&nbsp;jedinou funkcí určenou pro rekurzivní výpočet faktoriálu. Opět
se jedná o typický školní příklad, protože v&nbsp;praxi lze výpočet realizovat
i efektivnější formou:</p>

<pre>
<i>"""Výpočet faktoriálu."""</i>
&nbsp;
&nbsp;
def <strong>factorial</strong>(n):
    <i>"""Rekurzivní výpočet faktoriálu."""</i>
    if n &lt; 0:
        return None
    if n == 0:
        return 1
    return n * factorial(n-1)
</pre>

<p>V&nbsp;jednotkových testech zjistíme, jak výpočet probíhá jak pro počáteční
dvě vstupní hodnoty 0 a 1, tak i pro hodnotu, u níž muselo dojít
k&nbsp;několika rekurzivním zanořením:</p>

<pre>
<i>"""Jednotkové testy pro výpočet faktoriálu."""</i>
&nbsp;
from factorial import factorial
&nbsp;
&nbsp;
def <strong>test_factorial</strong>():
    <i>"""Jednotkový test pro výpočet faktoriálu."""</i>
    assert factorial(0) == 1
    assert factorial(1) == 1
    assert factorial(3) == 6
</pre>

<p>Výsledek běhu jednotkových testů ukazuje, že by mělo být vše v&nbsp;pořádku
(což ovšem samozřejmě není pravda):</p>

<pre>
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/mypy/factorial1
plugins: print-0.1.3, voluptuous-1.0.2, cov-2.5.1
collecting ... collected 1 item
&nbsp;
factorial_test.py::test_factorial PASSED                                 [100%]
&nbsp;
============================== 1 passed in 0.01s ===============================
</pre>

<p>Detekce pokrytí kódu jednotkovými testy naznačuje, že jedna větev
v&nbsp;podmínce vůbec není otestovaná, takže se nedosáhlo 100%:</p>

<pre>
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1
rootdir: /home/ptisnovs/src/python/testing-in-python/mypy/factorial1
plugins: print-0.1.3, voluptuous-1.0.2, cov-2.5.1
collected 1 item
&nbsp;
factorial_test.py .                                                      [100%]
&nbsp;
----------- coverage: platform linux, python 3.6.6-final-0 -----------
Name           Stmts   Miss  Cover
----------------------------------
factorial.py       6      1    83%
&nbsp;
&nbsp;
============================== 1 passed in 0.03s ===============================
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Rozšíření jednotkových testů pro pokrytí všech větví kódu</h2>

<p>Samozřejmě nám nic nebrání se podívat na to, které řádky nejsou jednotkovými
testy pokryty. Jedná se o první větev, která testuje, zda nejsou ve výpočtu
použity záporné hodnoty:</p>

<pre>
<i>"""Výpočet faktoriálu."""</i>
&nbsp;
&nbsp;
def <strong>factorial</strong>(n):
    <i>"""Rekurzivní výpočet faktoriálu."""</i>
    <i>if n &lt; 0</i>:
        <i>return None</i>
    if n == 0:
        return 1
    return n * factorial(n-1)
</pre>

<p>Jednotkové testy lze rozšířit i o tyto hodnoty s&nbsp;otestováním, jaký
výsledek dostaneme (faktoriál pro záporná čísla definován není, takže lze buď
vyhodit výjimku či vrátit nějakou speciální hodnotu, což je i náš případ):</p>

<pre>
<i>"""Jednotkové testy pro výpočet faktoriálu."""</i>
&nbsp;
from factorial import factorial
&nbsp;
&nbsp;
def <strong>test_factorial</strong>():
    <i>"""Jednotkový test pro výpočet faktoriálu."""</i>
    assert factorial(0) == 1
    assert factorial(1) == 1
    assert factorial(3) == 6
&nbsp;
&nbsp;
def <strong>test_factorial_negative_values</strong>():
    <i>"""Jednotkový test pro výpočet faktoriálu."""</i>
    assert factorial(-1) is None
    assert factorial(-1000) is None
</pre>

<p>Nyní je již pokrytí kódu jednotkovými testy stoprocentní:</p>

<pre>
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1
rootdir: /home/ptisnovs/src/python/testing-in-python/mypy/factorial2
plugins: print-0.1.3, voluptuous-1.0.2, cov-2.5.1
collected 2 items
&nbsp;
factorial_test.py ..                                                     [100%]
&nbsp;
----------- coverage: platform linux, python 3.6.6-final-0 -----------
Name           Stmts   Miss  Cover
----------------------------------
factorial.py       6      0   100%
&nbsp;
&nbsp;
============================== 2 passed in 0.03s ===============================
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Chyby kvůli chybějícím typovým kontrolám</h2>

<p>I přesto, že je pokrytí jednotkovými testy stoprocentní, není výpočet
faktoriálu naprogramován bezchybně. Ostatně si to můžeme sami ověřit, například
pokusem o předání parametru 2.1 (nebo jakékoli kladné hodnoty s&nbsp;nenulovou
částí za desetinnou čárkou):</p>

<pre>
print(factorial(2.1))
</pre>

<p>V&nbsp;tomto případě dojde při rekurzi k&nbsp;tomu, že se výpočet rekurzivně
zavolá se zápornou hodnotou (-0.9), z&nbsp;té se vypočte výsledek
<strong>None</strong> a při fázi rozvinování dojde k&nbsp;vynásobení
<strong>None</strong> a hodnoty 0.1:</p>

<pre>
Traceback (most recent call last):
  File "./failure1.py", line 8, in &lt;module;&gt;
    print(factorial(2.1))
  File "/home/ptisnovs/src/python/testing-in-python/mypy/factorial2/factorial.py", line 10, in factorial
    return n * factorial(n-1)
  File "/home/ptisnovs/src/python/testing-in-python/mypy/factorial2/factorial.py", line 10, in factorial
    return n * factorial(n-1)
  File "/home/ptisnovs/src/python/testing-in-python/mypy/factorial2/factorial.py", line 10, in factorial
    return n * factorial(n-1)
TypeError: unsupported operand type(s) for *: 'float' and 'NoneType'
</pre>

<p>Podobně není ošetřeno zadání zcela nesmyslné hodnoty na vstup, například
řetězce:</p>

<pre>
print(factorial("foo"))
</pre>

<pre>
Traceback (most recent call last):
  File "./failure2.py", line 8, in &lt;module;&gt;
    print(factorial("foo"))
  File "/home/ptisnovs/src/python/testing-in-python/mypy/factorial2/factorial.py", line 6, in factorial
    if n &lt; 0:
TypeError: '&lt;' not supported between instances of 'str' and 'int'
</pre>

<p>Naproti tomu pravdivostní hodnoty <strong>True</strong> a
<strong>False</strong> jsou v&nbsp;typovém systému Pythonu převedeny na
celočíselné hodnoty 1 a 0, takže s&nbsp;nimi výpočet provést lze, i když to
vypadá nesmyslně:</p>

<pre>
print(factorial(True))
print(factorial(False))
</pre>

<p>Faktoriál True je roven jedné, stejně jako faktoriál False :-)</p>

<pre>
1
1
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Explicitní typové kontroly prováděné v&nbsp;čase běhu aplikace</h2>

<p>Pochopitelně nám nic nebrání v&nbsp;tom provádět typové kontroly explicitně
v&nbsp;čase běhu aplikace. Využít je možné například příkaz
<strong>assert</strong> nebo podmínku zkombinovanou s&nbsp;programovou
konstrukcí <strong>raise</strong>:</p>

<pre>
<i>"""Výpočet faktoriálu."""</i>
&nbsp;
&nbsp;
def <strong>factorial</strong>(n):
    <i>"""Rekurzivní výpočet faktoriálu."""</i>
    assert isinstance(n, int), "Integer expected"
&nbsp;
    if n &lt; 0:
        return None
    if n == 0:
        return 1
    result = n * factorial(n-1)
&nbsp;
    assert isinstance(result, int), "Internal error in factorial computation"
    return result
</pre>

<p>Nyní se chyby detekují již na začátku každého výpočtu (v&nbsp;jeho dalším
průběhu sice taktéž probíhají, ale podmínka nemůže být splněna):</p>

<pre>
<strong>print(factorial(2.1))</strong>
&nbsp;
Traceback (most recent call last):
  File "./failure1.py", line 8, in &lt;module;&gt;
    print(factorial(2.1))
  File "/home/ptisnovs/src/python/testing-in-python/mypy/factorial3/factorial.py", line 6, in factorial
    assert isinstance(n, int), "Integer expected"
AssertionError: Integer expected
</pre>

<p>Další pokus:</p>

<pre>
<strong>print(factorial("foo"))</strong>
&nbsp;
Traceback (most recent call last):
  File "./failure2.py", line 8, in &lt;module;&gt;
    print(factorial("foo"))
  File "/home/ptisnovs/src/python/testing-in-python/mypy/factorial3/factorial.py", line 6, in factorial
    assert isinstance(n, int), "Integer expected"
AssertionError: Integer expected
</pre>

<p>Některé hodnoty, typicky pravdivostní, jsou však typovým systémem Pythonu
stále považovány za kladná čísla:</p>

<pre>
<strong>print(factorial(True))</strong>
<strong>print(factorial(False))</strong>
&nbsp;
1
1
</pre>

<p><div class="rs-tip-major">Poznámka: tento přístup není v&nbsp;žádném případě
dokonalý a navíc kontroly prováděné za běhu celou aplikaci mohou dosti
podstatným způsobem zpomalovat. Proto v&nbsp;dalším textu namísto tohoto
přístupu použijeme nástroj <i>mypy</i> a statické kontroly (bez spuštění
kódu).</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Použití typové deklarace a kontrola s&nbsp;využitím <i>mypy</i></h2>

<p>Můžeme se samozřejmě pokusit o přidání typových deklarací, a to způsobem,
který jsme viděli v&nbsp;úvodních kapitolách. První varianta vychází
z&nbsp;toho, že výpočet faktoriálu má cenu provádět pouze pro celočíselné
vstupní hodnoty a výsledkem je taktéž celé číslo (až na případy záporných
čísel, pro které není faktoriál definován). První varianta typové deklarace by
tedy mohla vypadat následovně:</p>

<pre>
<i>"""Výpočet faktoriálu."""</i>
&nbsp;
&nbsp;
def <strong>factorial</strong>(n: int) -&gt; int:
    <i>"""Rekurzivní výpočet faktoriálu."""</i>
    if n &lt; 0:
        return None
    if n == 0:
        return 1
    return n * factorial(n-1)
</pre>

<p>Ovšem nástroj <i>mypy</i> v&nbsp;tomto případě zjistí &ndash; a to zcela
korektně &ndash;, že není správně ošetřen případ, kdy funkce vrací nikoli
celočíselnou hodnotu, ale hodnotu <strong>None</strong>:</p>

<pre>
factorial.py:7: error: Incompatible return value type (got "None", expected "int")
Found 1 error in 1 file (checked 1 source file)
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Pokus o použití typové deklarace používající <strong>Union</strong></h2>

<p>Vzhledem k&nbsp;tomu, že funkce pro výpočet faktoriálu vrací pro záporné
vstupy hodnotu <strong>None</strong> (s&nbsp;významem
&bdquo;nedefinováno&ldquo;), mohlo by se zdát, že řešení předchozí chyby je
velmi snadné &ndash; postačuje použít typovou deklaraci <strong>Union[int,
None]</strong> pro návratovou hodnotu funkce <strong>factorial</strong>. Další
varianta by tedy mohla vypadat následovně:</p>

<pre>
<i>"""Výpočet faktoriálu."""</i>
&nbsp;
from typing import Union
&nbsp;
&nbsp;
def <strong>factorial</strong>(n: int) -&gt; Union[int, None]:
    <i>"""Rekurzivní výpočet faktoriálu."""</i>
    if n &lt; 0:
        return None
    if n == 0:
        return 1
    return n * factorial(n-1)
</pre>

<p>Ovšem ani toto řešení není korektní, protože nyní nástroj <i>mypy</i>
zjistí, že v&nbsp;rekurzívním výpočtu by mohlo dojít k&nbsp;vynásobení celého
čísla s&nbsp;hodnotou typu <strong>None</strong>:</p>

<pre>
factorial.py:12: error: Unsupported operand types for * ("int" and "None")
factorial.py:12: note: Right operand is of type "Optional[int]"
Found 1 error in 1 file (checked 1 source file)
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti k&nbsp;této situaci
nemůže dojít, ovšem <i>mypy</i> pouze sleduje použití datových typů a nikoli
všechny podmínky a toky řízení v&nbsp;zapsaném algoritmu.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<p></p>

<pre>
<i>"""Výpočet faktoriálu."""</i>
&nbsp;
from typing import Optional
&nbsp;
&nbsp;
def <strong>factorial</strong>(n: Optional[int]) -&gt; Optional[int]:
    <i>"""Rekurzivní výpočet faktoriálu."""</i>
    if n is None:
        return None
    if n &lt; 0:
        return None
    if n == 0:
        return 1
    return n * factorial(n-1)
</pre>

<pre>
factorial.py:14: error: Unsupported operand types for * ("int" and "None")
factorial.py:14: note: Right operand is of type "Optional[int]"
Found 1 error in 1 file (checked 1 source file)
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<p></p>

<pre>
<i>"""Výpočet faktoriálu."""</i>
&nbsp;
from typing import Optional
&nbsp;
&nbsp;
def <strong>factorial</strong>(n: Optional[int]) -&gt; Optional[int]:
    <i>"""Rekurzivní výpočet faktoriálu."""</i>
    if n is None:
        return None
    if n &lt; 0:
        return None
    if n == 0:
        return 1
&nbsp;
    r = factorial(n-1)
&nbsp;
    if r is None:
        return None
    return n * r
</pre>

<pre>
Success: no issues found in 1 source file
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<pre>
"""Výpočet faktoriálu."""
&nbsp;
from typing import overload
from typing import Optional
&nbsp;
&nbsp;
@overload
def <strong>factorial</strong>(n: None) -&gt; None:
    pass
&nbsp;
&nbsp;
@overload
def <strong>factorial</strong>(n: int) -&gt; int:
    pass
&nbsp;
&nbsp;
def <strong>factorial</strong>(n: Optional[int]) -&gt; Optional[int]:
    """Rekurzivní výpočet faktoriálu."""
    if n is None:
        return None
    if n &lt; 0:
        return None
    if n == 0:
        return 1
&nbsp;
    return n * factorial(n-1)
</pre>

<pre>
Success: no issues found in 1 source file
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Jak pracné je přidat informace o typech do složitějších funkcí?</h2>

<p>Podívejme se nyní na funkci, s&nbsp;nímž jsme se již v&nbsp;tomto seriálu
setkali. Jedná se o funkci nazvanou <strong>primes</strong>, která dokáže
rychlým algoritmem vypočítat prvočísla od 2 do zadaného limitu. Přitom jde o
poměrně dlouhý algoritmus (přes dvacet řádků), takže by se mohlo zdát, že
přidání typových deklarací bude taktéž komplikované. Ovšem ukazuje se, že tomu
tak není, protože je pouze nutné zadat typ vstupního parametru (celočíselný
limit) a typ výsledků, což je seznam prvočísel. V&nbsp;Pythonu nemáme koncept
čísel bez znaménka, takže se spokojíme s&nbsp;typem <strong>int</strong> a
<strong>List[int]</strong>:</p>

<pre>
<i>"""Výpočet seznamu prvočísel až do zadaného limitu."""</i>
&nbsp;
from typing import List
&nbsp;
&nbsp;
<i># originální kód lze nalézt na adrese:</i>
<i># http://www.rosettacode.org/wiki/Sieve_of_Eratosthenes#Odds-only_version_of_the_array_sieve_above</i>
def <strong>primes</strong>(limit: int) -&gt; List[int]:
    <i>"""Výpočet seznamu prvočísel až do zadaného limitu."""</i>
    <i># okrajový případ</i>
    if limit &lt; 2:
        return []
&nbsp;
    <i># druhý případ - 2 je speciálním prvočíslem</i>
    if limit &lt; 3:
        return [2]
&nbsp;
    lmtbf = (limit - 3) // 2
&nbsp;
    <i># naplnění tabulky, která se bude prosívat</i>
    buf = [True] * (lmtbf + 1)
&nbsp;
    <i># vlastní prosívání</i>
    for i in range((int(limit ** 0.5) - 3) // 2 + 1):
        if buf[i]:
            p = i + i + 3
            s = p * (i + 1) + i
            buf[s::p] = [False] * ((lmtbf - s) // p + 1)
&nbsp;
    <i># vytvoření seznamu prvočísel</i>
    return [2] + [i + i + 3 for i, v in enumerate(buf) if v]
&nbsp;
&nbsp;
print(primes(100))
</pre>

<p>Kontrola by neměla zjistit žádné nekorektní použití typů:</p>

<pre>
$ <strong>mypy primes.py </strong>
&nbsp;
Success: no issues found in 1 source file
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Specifikace typů kontejnerů</h2>

<p>Prakticky v&nbsp;každé aplikaci vyvinuté v&nbsp;Pythonu se setkáme
s&nbsp;některými kontejnery, typicky s&nbsp;kontejnery, které jsou součástí
samotného programovacího jazyka Python. Jedná se o n-tice (<i>tuple</i>),
seznamy <i>list</i>, množiny (<i>set</i>) a slovníky (<i>dict</i>). Typickým
znakem Pythonu, resp.&nbsp;přesněji řečeno jeho typového systému, je fakt, že
tyto kontejnery mohou obsahovat prvky libovolného typu. To je sice na jednu
stranu velmi užitečná vlastnost, ovšem na stranu druhou se v&nbsp;reálných
aplikacích vyskytují funkce a metody, které pracují pouze s&nbsp;kontejnery
obsahujícími prvky jedinečného typu.</p>

<p>Typickým příkladem může být nějaká funkce, které se předá seznam uživatelů,
tedy seznam objektů typu <strong>User</strong>. Jakým způsobem je však možné
specifikovat tento datový typ, tj.&nbsp;jak odlišit seznam prvků libovolného
typu od seznamu prvků určitého typu (nebo unie několika typů)? Samozřejmě to
možné je a používá se následující způsob zápisu (který jsme již viděli
v&nbsp;předchozí kapitole &ndash; ovšem tam bez dalšího vysvětlení):</p>

<pre>
List[int]
Dict[int, int]
List[User]
Dict[int, User]
</pre>

<p>Podívejme se nyní na poměrně typický příklad použití. Budeme chtít vytvořit
funkci vyššího řádu nazvanou <strong>apply</strong>, která bude aplikovat
nějakou funkci typu <strong>int -&gt; int</strong> na seznam typu
<strong>List[int]</strong>. Aplikovaná funkce je (v&nbsp;tom nejjednodušším
případě) typu <strong>Callable</strong>, takže je možné psát:</p>

<pre>
def <strong>apply</strong>(function, list):
    return [function(e) for e in list]
</pre>

<p>Po přidání informace o typech pak rozšíříme definici funkce následovně:</p>

<pre>
def <strong>apply</strong>(function: Callable, list: List[int]) -&gt; List[int]:
    return [function(e) for e in list]
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;předchozím kódu se používá
generátorová notace seznamu neboli <i>list comprehension</i>.</div></p>

<p>Příklad použití takto navržené funkce. Nejprve bez typových deklarací:</p>

<pre>
from typing import overload
from typing import Optional
&nbsp;
&nbsp;
@overload
def <strong>factorial</strong>(n: None) -&gt; None:
    pass
&nbsp;
&nbsp;
@overload
def <strong>factorial</strong>(n: int) -&gt; int:
    pass
&nbsp;
&nbsp;
def <strong>factorial</strong>(n: Optional[int]) -&gt; Optional[int]:
    <i>"""Rekurzivní výpočet faktoriálu."""</i>
    if n is None:
        return None
    if n &lt; 0:
        return None
    if n == 0:
        return 1
&nbsp;
    return n * factorial(n-1)
&nbsp;
&nbsp;
def <strong>apply</strong>(function, list):
    return [function(e) for e in list]
&nbsp;
&nbsp;
print(apply(factorial, [1, 2, 3, 4]))
print(apply(factorial, [1, 2.2, "foo", 4]))
</pre>

<p>A následně s&nbsp;typovými deklaracemi:</p>

<pre>
from typing import overload
from typing import Optional
from typing import Callable, List
&nbsp;
&nbsp;
@overload
def <strong>factorial</strong>(n: None) -&gt; None:
    pass
&nbsp;
&nbsp;
@overload
def <strong>factorial</strong>(n: int) -&gt; int:
    pass
&nbsp;
&nbsp;
def <strong>factorial</strong>(n: Optional[int]) -&gt; Optional[int]:
    <i>"""Rekurzivní výpočet faktoriálu."""</i>
    if n is None:
        return None
    if n &lt; 0:
        return None
    if n == 0:
        return 1
&nbsp;
    return n * factorial(n-1)
&nbsp;
&nbsp;
def <strong>apply</strong>(function: Callable, list: List[int]) -&gt; List[int]:
    return [function(e) for e in list]
&nbsp;
&nbsp;
print(apply(factorial, [1, 2, 3, 4]))
print(apply(factorial, [1, 2.2, "foo", 4]))
</pre>

<p>Kontrola odhalí dvě chyby, kterých jsme se dopustili při volání funkce
<strong>apply</strong> &ndash; ta by totiž do funkce <strong>factorial</strong>
předala hodnoty nekorektních typů:</p>

<pre>
$ <strong>mypy apply2.py </strong>
&nbsp;
apply2.py:33: error: List item 1 has incompatible type "float"; expected "int"
apply2.py:33: error: List item 2 has incompatible type "str"; expected "int"
Found 2 errors in 1 file (checked 1 source file)
</pre>

<p>Další varianta, tentokrát vytvářející slovník s&nbsp;hodnotou a faktoriálem
této hodnoty pomocí nové funkce pojmenované <strong>asDict</strong>:</p>

<pre>
from typing import overload
from typing import Optional
from typing import Callable, List
from typing import Dict, Any
&nbsp;
&nbsp;
@overload
def <strong>factorial</strong>(n: None) -&gt; None:
    pass
&nbsp;
&nbsp;
@overload
def <strong>factorial</strong>(n: int) -&gt; int:
    pass
&nbsp;
&nbsp;
def <strong>factorial</strong>(n: Optional[int]) -&gt; Optional[int]:
    <i>"""Rekurzivní výpočet faktoriálu."""</i>
    if n is None:
        return None
    if n &lt; 0:
        return None
    if n == 0:
        return 1
&nbsp;
    return n * factorial(n-1)
&nbsp;
&nbsp;
def <strong>asDict</strong>(function: Callable, list: List[int]) -&gt; Dict[int, int]:
    return {value: function(value) for value in list}
&nbsp;
&nbsp;
print(asDict(factorial, [1, 2, 3, 4]))
print(asDict(factorial, [1, 2.2, "foo", 4]))
</pre>

<p>Výsledek typové kontroly:</p>

<pre>
$ <strong>mypy apply3.py </strong>
&nbsp;
apply3.py:34: error: List item 1 has incompatible type "float"; expected "int"
apply3.py:34: error: List item 2 has incompatible type "str"; expected "int"
Found 2 errors in 1 file (checked 1 source file)
</pre>

<p><div class="rs-tip-major">Poznámka: můžeme vidět, že typové kontroly
prováděné nástrojem <i>mypy</i> mohou být užitečné, ovšem pochopitelně nejsou
v&nbsp;žádném případě dokonalé (to by vyžadovalo zcela zásadní změny
v&nbsp;typovém systému). Ovšem pro některé projekty se může jednat o užitečný
pokus o zlepšení celkové kvality produktu. Viz například popis změn provedených
ve skutečně obrovském projektu pro zlepšení celkové kvality: <a
href="https://dropbox.tech/application/our-journey-to-type-checking-4-million-lines-of-python">Our
journey to type checking 4 million lines of Python</a></div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
nového Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/testing-in-python">https://github.com/tisnik/testing-in-python</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem &ndash;
alespoň prozatím &ndash; velmi malý, dnes má přibližně několik desítek
kilobajtů), můžete namísto toho použít odkazy na jednotlivé demonstrační
příklady a jejich části, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>comparator1.py</td><td>implementace funkce <strong>compare</strong> bez deklarace typů</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/mypy/comparator1.py">https://github.com/tisnik/testing-in-python/tree/master/mypy/comparator1.py</a></td></tr>
<tr><td> 2</td><td>comparator2.py</td><td>funkce <strong>compare</strong> akceptující pouze celá čísla</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/mypy/comparator2.py">https://github.com/tisnik/testing-in-python/tree/master/mypy/comparator2.py</a></td></tr>
<tr><td> 3</td><td>comparator3.py</td><td>funkce <strong>compare</strong> akceptující kombinaci čísel a řetězců</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/mypy/comparator3.py">https://github.com/tisnik/testing-in-python/tree/master/mypy/comparator3.py</a></td></tr>
<tr><td> 4</td><td>comparator3.py</td><td>funkce <strong>compare</strong> akceptující celá čísla nebo řetězce</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/mypy/comparator3.py">https://github.com/tisnik/testing-in-python/tree/master/mypy/comparator3.py</a></td></tr>
<tr><td> 5</td><td>comparator_test.py</td><td>jednotkové testy pro <strong>comparator1.py</strong></td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/mypy/comparator_test.py">https://github.com/tisnik/testing-in-python/tree/master/mypy/comparator_test.py</a></td></tr>
<tr><td> 6</td><td>comparator_test2.py</td><td>hodnoty <i>nan</i> a <strong>comparator1.py</strong></td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/mypy/comparator_test2.py">https://github.com/tisnik/testing-in-python/tree/master/mypy/comparator_test2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>primes.py</td><td>algoritmus pro výpočet prvočísel, tentokrát s&nbsp;typovými definicemi</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/mypy/primes.py">https://github.com/tisnik/testing-in-python/tree/master/mypy/primes.py</a></td></tr>
<tr><td> 8</td><td>adder.py</td><td>generická funkce pro součet dvou hodnot</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/mypy/adder.py">https://github.com/tisnik/testing-in-python/tree/master/mypy/adder.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>apply1.py</td><td>beztypová funkce vyššího řádu typu <strong>apply</strong></td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/mypy/apply1.py">https://github.com/tisnik/testing-in-python/tree/master/mypy/apply1.py</a></td></tr>
<tr><td>10</td><td>apply2.py</td><td>funkce vyššího řádu <strong>apply</strong> s&nbsp;typovým omezením</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/mypy/apply2.py">https://github.com/tisnik/testing-in-python/tree/master/mypy/apply2.py</a></td></tr>
<tr><td>11</td><td>apply3.py</td><td>alternativa k&nbsp;funkci <strong>apply</strong>, která vytváří slovníky</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/mypy/apply3.py">https://github.com/tisnik/testing-in-python/tree/master/mypy/apply3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>factorial1</td><td>původní algoritmus pro výpočet faktoriálu bez informací o typech</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/mypy/factorial1">https://github.com/tisnik/testing-in-python/tree/master/mypy/factorial1</a></td></tr>
<tr><td>13</td><td>factorial2</td><td>rozšíření jednotkových testů pro dosažení stoprocentního pokrytí</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/mypy/factorial2">https://github.com/tisnik/testing-in-python/tree/master/mypy/factorial2</a></td></tr>
<tr><td>14</td><td>factorial3</td><td>explicitní kontrola typů v&nbsp;čase běhu aplikace (runtime)</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/mypy/factorial3">https://github.com/tisnik/testing-in-python/tree/master/mypy/factorial3</a></td></tr>
<tr><td>15</td><td>factorial4</td><td>první varianta algoritmu s&nbsp;typovými deklaracemi</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/mypy/factorial4">https://github.com/tisnik/testing-in-python/tree/master/mypy/factorial4</a></td></tr>
<tr><td>16</td><td>factorial5</td><td>druhá varianta povolující hodnoty <strong>None</strong></td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/mypy/factorial5">https://github.com/tisnik/testing-in-python/tree/master/mypy/factorial5</a></td></tr>
<tr><td>17</td><td>factorial6</td><td>třetí varianta využívající <strong>Optional</strong></td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/mypy/factorial6">https://github.com/tisnik/testing-in-python/tree/master/mypy/factorial6</a></td></tr>
<tr><td>18</td><td>factorial7</td><td>oprava předchozího příkladu</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/mypy/factorial7">https://github.com/tisnik/testing-in-python/tree/master/mypy/factorial7</a></td></tr>
<tr><td>19</td><td>factorial8</td><td>přetížení funkce pro zajištění typové bezchybnosti</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/mypy/factorial8">https://github.com/tisnik/testing-in-python/tree/master/mypy/factorial8</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články s&nbsp;tématem testování (nejenom) v&nbsp;Pythonu</h2>

<p>Tématem testování jsme se již na stránkách Rootu několikrát zabývali. Jedná
se mj.&nbsp;o následující články:</p>

<ol>

<li>Použití Pythonu pro tvorbu testů: od jednotkových testů až po testy UI<br />
<a href="https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-od-jednotkovych-testu-az-po-testy-ui/">https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-od-jednotkovych-testu-az-po-testy-ui/</a>
</li>

<li>Použití Pythonu pro tvorbu testů: použití třídy Mock z knihovny unittest.mock<br />
<a href="https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-pouziti-tridy-mock-z-knihovny-unittest-mock/">https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-pouziti-tridy-mock-z-knihovny-unittest-mock/</a>
</li>

<li>Použití nástroje pytest pro tvorbu jednotkových testů a benchmarků<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-pytest-pro-tvorbu-jednotkovych-testu-a-benchmarku/">https://www.root.cz/clanky/pouziti-nastroje-pytest-pro-tvorbu-jednotkovych-testu-a-benchmarku/</a>
</li>

<li>Nástroj pytest a jednotkové testy: fixtures, výjimky, parametrizace testů<br />
<a href="https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-fixtures-vyjimky-parametrizace-testu/">https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-fixtures-vyjimky-parametrizace-testu/</a>
</li>

<li>Nástroj pytest a jednotkové testy: životní cyklus testů, užitečné tipy a triky<br />
<a href="https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-zivotni-cyklus-testu-uzitecne-tipy-a-triky/">https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-zivotni-cyklus-testu-uzitecne-tipy-a-triky/</a>
</li>

<li>Struktura projektů s jednotkovými testy, využití Travis CI<br />
<a href="https://www.root.cz/clanky/struktura-projektu-s-jednotkovymi-testy-vyuziti-travis-ci/">https://www.root.cz/clanky/struktura-projektu-s-jednotkovymi-testy-vyuziti-travis-ci/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave (druhá část)<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-druha-cast/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-druha-cast/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave (závěrečná část)<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-zaverecna-cast/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-zaverecna-cast/</a>
</li>

<li>Validace datových struktur v Pythonu pomocí knihoven Schemagic a Schema<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/</a>
</li>

<li>Validace datových struktur v Pythonu (2. část)<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-2-cast/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-2-cast/</a>
</li>

<li>Validace datových struktur v Pythonu (dokončení)<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-dokonceni/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-dokonceni/</a>
</li>

<li>Univerzální testovací nástroj Robot Framework<br />
<a href="https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework/">https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework/</a>
</li>

<li>Univerzální testovací nástroj Robot Framework a BDD testy<br />
<a href="https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework-a-bdd-testy/">https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework-a-bdd-testy/</a>
</li>

<li>Úvod do problematiky fuzzingu a fuzz testování<br />
<a href="https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani/">https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani/</a>
</li>

<li>Úvod do problematiky fuzzingu a fuzz testování – složení vlastního fuzzeru<br />
<a href="https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani-slozeni-vlastniho-fuzzeru/">https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani-slozeni-vlastniho-fuzzeru/</a>
</li>

<li>Knihovny a moduly usnadňující testování aplikací naprogramovaných v jazyce Clojure<br />
<a href="https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/">https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/</a>
</li>

<li>Validace dat s využitím knihovny spec v Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

<li>Testování aplikací naprogramovaných v jazyce Go<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/">https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/</a>
</li>

<li>Knihovny určené pro tvorbu testů v programovacím jazyce Go<br />
<a href="https://www.root.cz/clanky/knihovny-urcene-pro-tvorbu-testu-v-programovacim-jazyce-go/">https://www.root.cz/clanky/knihovny-urcene-pro-tvorbu-testu-v-programovacim-jazyce-go/</a>
</li>

<li>Testování aplikací psaných v Go s využitím knihoven Goblin a Frisby<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/">https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/</a>
</li>

<li>Testování Go aplikací s využitím knihovny GΩmega a frameworku Ginkgo<br />
<a href="https://www.root.cz/clanky/testovani-go-aplikaci-s-vyuzitim-knihovny-gomega-mega-a-frameworku-ginkgo/">https://www.root.cz/clanky/testovani-go-aplikaci-s-vyuzitim-knihovny-gomega-mega-a-frameworku-ginkgo/</a>
</li>

<li>Tvorba BDD testů s využitím jazyka Go a nástroje godog<br />
<a href="https://www.root.cz/clanky/tvorba-bdd-testu-s-vyuzitim-jazyka-go-a-nastroje-godog/">https://www.root.cz/clanky/tvorba-bdd-testu-s-vyuzitim-jazyka-go-a-nastroje-godog/</a>
</li>

<li>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem<br />
<a href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/">https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/</a>
</li>

<li>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem (dokončení)<br />
<a href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem-dokonceni/">https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem-dokonceni/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure (2)<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>PEP-484<br />
<a href="https://www.python.org/dev/peps/pep-0484/">https://www.python.org/dev/peps/pep-0484/</a>
</li>

<li>In-depth: Functional programming in C++<br />
<a href="https://www.gamasutra.com/view/news/169296/Indepth_Functional_programming_in_C.php">https://www.gamasutra.com/view/news/169296/Indepth_Functional_programming_in_C.php</a>
</li>

<li>mypy<br />
<a href="http://www.mypy-lang.org/">http://www.mypy-lang.org/</a>
</li>

<li>Welcome to Mypy documentation!<br />
<a href="https://mypy.readthedocs.io/en/latest/index.html">https://mypy.readthedocs.io/en/latest/index.html</a>
</li>

<li>mypy na GitHubu<br />
<a href="https://github.com/python/mypy">https://github.com/python/mypy</a>
</li>

<li>mypy 0.770 na PyPi<br />
<a href="https://pypi.org/project/mypy/">https://pypi.org/project/mypy/</a>
</li>

<li>Extensions for mypy (separated out from mypy/extensions)<br />
<a href="https://github.com/python/mypy_extensions">https://github.com/python/mypy_extensions</a>
</li>

<li>The Mypy Blog<br />
<a href="https://mypy-lang.blogspot.com/2020/03/mypy-0770-released.html">https://mypy-lang.blogspot.com/2020/03/mypy-0770-released.html</a>
</li>

<li>Our journey to type checking 4 million lines of Python<br />
<a href="https://dropbox.tech/application/our-journey-to-type-checking-4-million-lines-of-python">https://dropbox.tech/application/our-journey-to-type-checking-4-million-lines-of-python</a>
</li>

<li>Type-Checking Python Programs With Type Hints and mypy<br />
<a href="https://www.youtube.com/watch?v=2xWhaALHTvU">https://www.youtube.com/watch?v=2xWhaALHTvU</a>
</li>

<li>Refactoring to Immutability - Kevlin Henney<br />
<a href="https://www.youtube.com/watch?v=APUCMSPiNh4">https://www.youtube.com/watch?v=APUCMSPiNh4</a>
</li>

<li>Bernat Gabor - Type hinting (and mypy) - PyCon 2019<br />
<a href="https://www.youtube.com/watch?v=hTrjTAPnA_k">https://www.youtube.com/watch?v=hTrjTAPnA_k</a>
</li>

<li>Stanford Seminar - Optional Static Typing for Python<br />
<a href="https://www.youtube.com/watch?v=GiZKuyLKvAA">https://www.youtube.com/watch?v=GiZKuyLKvAA</a>
</li>

<li>mypy Getting to Four Million Lines of Typed Python - Michael Sullivan<br />
<a href="https://www.youtube.com/watch?v=FT_WHV4-QcU">https://www.youtube.com/watch?v=FT_WHV4-QcU</a>
</li>

<li>Shebang<br />
<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">https://en.wikipedia.org/wiki/Shebang_(Unix)</a>
</li>

<li>pytest 5.4.2 na PyPi<br />
<a href="https://pypi.org/project/pytest/">https://pypi.org/project/pytest/</a>
</li>

<li>Hillel Wayne - Beyond Unit Tests: Taking Your Testing to the Next Level - PyCon 2018<br />
<a href="https://www.youtube.com/watch?v=MYucYon2-lk">https://www.youtube.com/watch?v=MYucYon2-lk</a>
</li>

<li>Awesome Python &ndash; testing<br />
<a href="https://github.com/vinta/awesome-python#testing">https://github.com/vinta/awesome-python#testing</a>
</li>

<li>pytest Plugins Compatibility<br />
<a href="http://plugincompat.herokuapp.com/">http://plugincompat.herokuapp.com/</a>
</li>

<li>Selenium (pro Python)<br />
<a href="https://pypi.org/project/selenium/">https://pypi.org/project/selenium/</a>
</li>

<li>Getting Started With Testing in Python<br />
<a href="https://realpython.com/python-testing/">https://realpython.com/python-testing/</a>
</li>

<li>unittest.mock — mock object library<br />
<a href="https://docs.python.org/3.5/library/unittest.mock.html">https://docs.python.org/3.5/library/unittest.mock.html</a>
</li>

<li>mock 2.0.0<br />
<a href="https://pypi.python.org/pypi/mock">https://pypi.python.org/pypi/mock</a>
</li>

<li>An Introduction to Mocking in Python<br />
<a href="https://www.toptal.com/python/an-introduction-to-mocking-in-python">https://www.toptal.com/python/an-introduction-to-mocking-in-python</a>
</li>

<li>Mock - Mocking and Testing Library<br />
<a href="http://mock.readthedocs.io/en/stable/">http://mock.readthedocs.io/en/stable/</a>
</li>

<li>Python Mocking 101: Fake It Before You Make It<br />
<a href="https://blog.fugue.co/2016-02-11-python-mocking-101.html">https://blog.fugue.co/2016-02-11-python-mocking-101.html</a>
</li>

<li>Nauč se Python! - Testování<br />
<a href="http://naucse.python.cz/lessons/intro/testing/">http://naucse.python.cz/lessons/intro/testing/</a>
</li>

<li>Flexmock (dokumentace)<br />
<a href="https://flexmock.readthedocs.io/en/latest/">https://flexmock.readthedocs.io/en/latest/</a>
</li>

<li>Test Fixture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test_fixture">https://en.wikipedia.org/wiki/Test_fixture</a>
</li>

<li>Mock object (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Mock_object">https://en.wikipedia.org/wiki/Mock_object</a>
</li>

<li>Extrémní programování<br />
<a href="https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD">https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD</a>
</li>

<li>Programování řízené testy<br />
<a href="https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy">https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>Tox<br />
<a href="https://tox.readthedocs.io/en/latest/">https://tox.readthedocs.io/en/latest/</a>
</li>

<li>pytest: helps you write better programs<br />
<a href="https://docs.pytest.org/en/latest/">https://docs.pytest.org/en/latest/</a>
</li>

<li>doctest — Test interactive Python examples<br />
<a href="https://docs.python.org/dev/library/doctest.html#module-doctest">https://docs.python.org/dev/library/doctest.html#module-doctest</a>
</li>

<li>unittest — Unit testing framework<br />
<a href="https://docs.python.org/dev/library/unittest.html">https://docs.python.org/dev/library/unittest.html</a>
</li>

<li>Python namespaces<br />
<a href="https://bytebaker.com/2008/07/30/python-namespaces/">https://bytebaker.com/2008/07/30/python-namespaces/</a>
</li>

<li>Namespaces and Scopes<br />
<a href="https://www.python-course.eu/namespaces.php">https://www.python-course.eu/namespaces.php</a>
</li>

<li>Stránka projektu Robot Framework<br />
<a href="https://robotframework.org/">https://robotframework.org/</a>
</li>

<li>GitHub repositář Robot Frameworku<br />
<a href="https://github.com/robotframework/robotframework">https://github.com/robotframework/robotframework</a>
</li>

<li>Robot Framework (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Robot_Framework">https://en.wikipedia.org/wiki/Robot_Framework</a>
</li>

<li>Tutoriál Robot Frameworku<br />
<a href="http://www.robotframeworktutorial.com/">http://www.robotframeworktutorial.com/</a>
</li>

<li>Robot Framework Documentation<br />
<a href="https://robotframework.org/robotframework/">https://robotframework.org/robotframework/</a>
</li>

<li>Robot Framework Introduction<br />
<a href="https://blog.testproject.io/2016/11/22/robot-framework-introduction/">https://blog.testproject.io/2016/11/22/robot-framework-introduction/</a>
</li>

<li>robotframework 3.1.2 na PyPi<br />
<a href="https://pypi.org/project/robotframework/">https://pypi.org/project/robotframework/</a>
</li>

<li>Robot Framework demo (GitHub)<br />
<a href="https://github.com/robotframework/RobotDemo">https://github.com/robotframework/RobotDemo</a>
</li>

<li>Robot Framework web testing demo using SeleniumLibrary<br />
<a href="https://github.com/robotframework/WebDemo">https://github.com/robotframework/WebDemo</a>
</li>

<li>Robot Framework for Mobile Test Automation Demo<br />
<a href="https://www.youtube.com/watch?v=06LsU08slP8">https://www.youtube.com/watch?v=06LsU08slP8</a>
</li>

<li>Gherkin<br />
<a href="https://cucumber.io/docs/gherkin/">https://cucumber.io/docs/gherkin/</a>
</li>

<li>Selenium<br />
<a href="https://selenium.dev/">https://selenium.dev/</a>
</li>

<li>SeleniumLibrary<br />
<a href="https://robotframework.org/">https://robotframework.org/</a>
</li>

<li>The Practical Test Pyramid<br />
<a href="https://martinfowler.com/articles/practical-test-pyramid.html">https://martinfowler.com/articles/practical-test-pyramid.html</a>
</li>

<li>Acceptance Tests and the Testing Pyramid<br />
<a href="http://www.blog.acceptancetestdrivendevelopment.com/acceptance-tests-and-the-testing-pyramid/">http://www.blog.acceptancetestdrivendevelopment.com/acceptance-tests-and-the-testing-pyramid/</a>
</li>

<li>Tab-separated values<br />
<a href="https://en.wikipedia.org/wiki/Tab-separated_values">https://en.wikipedia.org/wiki/Tab-separated_values</a>
</li>

<li>A quick guide about Python implementations<br />
<a href="https://blog.rmotr.com/a-quick-guide-about-python-implementations-aa224109f321">https://blog.rmotr.com/a-quick-guide-about-python-implementations-aa224109f321</a>
</li>

<li>radamsa<br />
<a href="https://gitlab.com/akihe/radamsa">https://gitlab.com/akihe/radamsa</a>
</li>

<li>Fuzzing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Fuzzing">https://en.wikipedia.org/wiki/Fuzzing</a>
</li>

<li>american fuzzy lop<br />
<a href="http://lcamtuf.coredump.cx/afl/">http://lcamtuf.coredump.cx/afl/</a>
</li>

<li>Fuzzing: the new unit testing<br />
<a href="https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide#1">https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide#1</a>
</li>

<li>Corpus for github.com/dvyukov/go-fuzz examples<br />
<a href="https://github.com/dvyukov/go-fuzz-corpus">https://github.com/dvyukov/go-fuzz-corpus</a>
</li>

<li>AFL &ndash; QuickStartGuide.txt<br />
<a href="https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt">https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt</a>
</li>

<li>Introduction to Fuzzing in Python with AFL<br />
<a href="https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/">https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/</a>
</li>

<li>Writing a Simple Fuzzer in Python<br />
<a href="https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/">https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/</a>
</li>

<li>How to Fuzz Go Code with go-fuzz (Continuously)<br />
<a href="https://fuzzit.dev/2019/10/02/how-to-fuzz-go-code-with-go-fuzz-continuously/">https://fuzzit.dev/2019/10/02/how-to-fuzz-go-code-with-go-fuzz-continuously/</a>
</li>

<li>Golang Fuzzing: A go-fuzz Tutorial and Example<br />
<a href="http://networkbit.ch/golang-fuzzing/">http://networkbit.ch/golang-fuzzing/</a>
</li>

<li>Fuzzing Python Modules<br />
<a href="https://stackoverflow.com/questions/20749026/fuzzing-python-modules">https://stackoverflow.com/questions/20749026/fuzzing-python-modules</a>
</li>

<li>0x3 Python Tutorial: Fuzzer<br />
<a href="http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/">http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/</a>
</li>

<li>fuzzing na PyPi<br />
<a href="https://pypi.org/project/fuzzing/">https://pypi.org/project/fuzzing/</a>
</li>

<li>Fuzzing 0.3.2 documentation<br />
<a href="https://fuzzing.readthedocs.io/en/latest/">https://fuzzing.readthedocs.io/en/latest/</a>
</li>

<li>Randomized testing for Go<br />
<a href="https://github.com/dvyukov/go-fuzz">https://github.com/dvyukov/go-fuzz</a>
</li>

<li>HTTP/2 fuzzer written in Golang<br />
<a href="https://github.com/c0nrad/http2fuzz">https://github.com/c0nrad/http2fuzz</a>
</li>

<li>Ffuf (Fuzz Faster U Fool) – An Open Source Fast Web Fuzzing Tool<br />
<a href="https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html">https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html</a>
</li>

<li>Continuous Fuzzing Made Simple<br />
<a href="https://fuzzit.dev/">https://fuzzit.dev/</a>
</li>

<li>Halt and Catch Fire<br />
<a href="https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86">https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86</a>
</li>

<li>Random testing<br />
<a href="https://en.wikipedia.org/wiki/Random_testing">https://en.wikipedia.org/wiki/Random_testing</a>
</li>

<li>Monkey testing<br />
<a href="https://en.wikipedia.org/wiki/Monkey_testing">https://en.wikipedia.org/wiki/Monkey_testing</a>
</li>

<li>Fuzzing for Software Security Testing and Quality Assurance, Second Edition<br />
<a href="https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false">https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false</a>
</li>

<li>libFuzzer – a library for coverage-guided fuzz testing<br />
<a href="https://llvm.org/docs/LibFuzzer.html">https://llvm.org/docs/LibFuzzer.html</a>
</li>

<li>fuzzy-swagger na PyPi<br />
<a href="https://pypi.org/project/fuzzy-swagger/">https://pypi.org/project/fuzzy-swagger/</a>
</li>

<li>fuzzy-swagger na GitHubu<br />
<a href="https://github.com/namuan/fuzzy-swagger">https://github.com/namuan/fuzzy-swagger</a>
</li>

<li>Fuzz testing tools for Python<br />
<a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy#Fuzz_Testing_Tools">https://wiki.python.org/moin/PythonTestingToolsTaxonomy#Fuzz_Testing_Tools</a>
</li>

<li>A curated list of awesome Go frameworks, libraries and software<br />
<a href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go</a>
</li>

<li>gofuzz: a library for populating go objects with random values<br />
<a href="https://github.com/google/gofuzz">https://github.com/google/gofuzz</a>
</li>

<li>tavor: A generic fuzzing and delta-debugging framework<br />
<a href="https://github.com/zimmski/tavor">https://github.com/zimmski/tavor</a>
</li>

<li>hypothesis na GitHubu<br />
<a href="https://github.com/HypothesisWorks/hypothesis">https://github.com/HypothesisWorks/hypothesis</a>
</li>

<li>Hypothesis: Test faster, fix more<br />
<a href="https://hypothesis.works/">https://hypothesis.works/</a>
</li>

<li>Hypothesis<br />
<a href="https://hypothesis.works/articles/intro/">https://hypothesis.works/articles/intro/</a>
</li>

<li>What is Hypothesis?<br />
<a href="https://hypothesis.works/articles/what-is-hypothesis/">https://hypothesis.works/articles/what-is-hypothesis/</a>
</li>

<li>Databáze CVE<br />
<a href="https://www.cvedetails.com/">https://www.cvedetails.com/</a>
</li>

<li>Fuzz test Python modules with libFuzzer<br />
<a href="https://github.com/eerimoq/pyfuzzer">https://github.com/eerimoq/pyfuzzer</a>
</li>

<li>Taof - The art of fuzzing<br />
<a href="https://sourceforge.net/projects/taof/">https://sourceforge.net/projects/taof/</a>
</li>

<li>JQF + Zest: Coverage-guided semantic fuzzing for Java<br />
<a href="https://github.com/rohanpadhye/jqf">https://github.com/rohanpadhye/jqf</a>
</li>

<li>http2fuzz<br />
<a href="https://github.com/c0nrad/http2fuzz">https://github.com/c0nrad/http2fuzz</a>
</li>

<li>Demystifying hypothesis testing with simple Python examples<br />
<a href="https://towardsdatascience.com/demystifying-hypothesis-testing-with-simple-python-examples-4997ad3c5294">https://towardsdatascience.com/demystifying-hypothesis-testing-with-simple-python-examples-4997ad3c5294</a>
</li>

<li>Testování<br />
<a href="http://voho.eu/wiki/testovani/">http://voho.eu/wiki/testovani/</a>
</li>

<li>Unit testing (Wikipedia.en)<br />
<a href="https://en.wikipedia.org/wiki/Unit_testing">https://en.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit testing (Wikipedia.cz)<br />
<a href="https://cs.wikipedia.org/wiki/Unit_testing">https://cs.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit Test vs Integration Test<br />
<a href="https://www.youtube.com/watch?v=0GypdsJulKE">https://www.youtube.com/watch?v=0GypdsJulKE</a>
</li>

<li>TestDouble<br />
<a href="https://martinfowler.com/bliki/TestDouble.html">https://martinfowler.com/bliki/TestDouble.html</a>
</li>

<li>Test Double<br />
<a href="http://xunitpatterns.com/Test%20Double.html">http://xunitpatterns.com/Test%20Double.html</a>
</li>

<li>Test-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test-driven_development">https://en.wikipedia.org/wiki/Test-driven_development</a>
</li>

<li>Acceptance test–driven development<br />
<a href="https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development">https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development</a>
</li>

<li>Gauge<br />
<a href="https://gauge.org/">https://gauge.org/</a>
</li>

<li>Gauge (software)<br />
<a href="https://en.wikipedia.org/wiki/Gauge_(software)">https://en.wikipedia.org/wiki/Gauge_(software)</a>
</li>

<li>PYPL PopularitY of Programming Language<br />
<a href="https://pypl.github.io/PYPL.html">https://pypl.github.io/PYPL.html</a>
</li>

<li>Testing is Good. Pyramids are Bad. Ice Cream Cones are the Worst<br />
<a href="https://medium.com/@fistsOfReason/testing-is-good-pyramids-are-bad-ice-cream-cones-are-the-worst-ad94b9b2f05f">https://medium.com/@fistsOfReason/testing-is-good-pyramids-are-bad-ice-cream-cones-are-the-worst-ad94b9b2f05f</a>
</li>

<li>Články a zprávičky věnující se Pythonu<br />
<a href="https://www.root.cz/n/python/">https://www.root.cz/n/python/</a>
</li>

<li>PythonTestingToolsTaxonomy<br />
<a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy">https://wiki.python.org/moin/PythonTestingToolsTaxonomy</a>
</li>

<li>Top 6 BEST Python Testing Frameworks [Updated 2020 List]<br />
<a href="https://www.softwaretestinghelp.com/python-testing-frameworks/">https://www.softwaretestinghelp.com/python-testing-frameworks/</a>
</li>

<li>pytest-print 0.1.3<br />
<a href="https://pypi.org/project/pytest-print/">https://pypi.org/project/pytest-print/</a>
</li>

<li>pytest fixtures: explicit, modular, scalable<br />
<a href="https://docs.pytest.org/en/latest/fixture.html">https://docs.pytest.org/en/latest/fixture.html</a>
</li>

<li>PyTest Tutorial: What is, Install, Fixture, Assertions<br />
<a href="https://www.guru99.com/pytest-tutorial.html">https://www.guru99.com/pytest-tutorial.html</a>
</li>

<li>Pytest - Fixtures<br />
<a href="https://www.tutorialspoint.com/pytest/pytest_fixtures.htm">https://www.tutorialspoint.com/pytest/pytest_fixtures.htm</a>
</li>

<li>Marking test functions with attributes<br />
<a href="https://docs.pytest.org/en/latest/mark.html">https://docs.pytest.org/en/latest/mark.html</a>
</li>

<li>pytest-print<br />
<a href="https://pytest-print.readthedocs.io/en/latest/">https://pytest-print.readthedocs.io/en/latest/</a>
</li>

<li>Continuous integration<br />
<a href="https://en.wikipedia.org/wiki/Continuous_integration">https://en.wikipedia.org/wiki/Continuous_integration</a>
</li>

<li>Travis CI<br />
<a href="https://travis-ci.org/">https://travis-ci.org/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

