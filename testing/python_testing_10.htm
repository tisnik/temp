<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Testování webových aplikací s REST API z Pythonu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Testování webových aplikací s REST API z Pythonu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Důležitým typem testů jsou testy aplikačního programového rozhraní, dnes typicky (ale nejenom) REST API. Tyto testy mohou být spouštěny samostatně (vůči jedné izolované komponentě), nebo mohou být součástí end-to-end testů. Dnes se zaměříme na popis knihovny Request tvořící základ REST API testů.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Testování webových aplikací s&nbsp;REST API z&nbsp;Pythonu</a></p>
<p><a href="#k02">2. Instalace knihovny Requests pro aktuálně přihlášeného uživatele</a></p>
<p><a href="#k03">3. Kontrola instalace knihovny Requests</a></p>
<p><a href="#k04">4. Základ protokolu HTTP: metody a stavové kódy</a></p>
<p><a href="#k05">5. Nejjednodušší příklad &ndash; poslání požadavku GET na zvolenou adresu</a></p>
<p><a href="#k06">6. Základní atributy objektu typu <strong>Response</strong>: stavový kód a indikátor korektní odpovědi</a></p>
<p><a href="#k07">7. Přečtení vybrané hlavičky z&nbsp;odpovědi HTTP serveru</a></p>
<p><a href="#k08">8. Předání informací (parametrů) serveru přímo v&nbsp;URL</a></p>
<p><a href="#k09">9. Přečtení těla odpovědi serveru v&nbsp;původní textové podobě</a></p>
<p><a href="#k10">10. Získání metainformací o poslaných datech (typ a délka)</a></p>
<p><a href="#k11">11. Zpracování odpovědi, která byla vrácena ve formátu JSON</a></p>
<p><a href="#k12">12. Použití HTTP metody POST</a></p>
<p><a href="#k13">13. Předání dat serveru ve &bdquo;formuláři&ldquo;</a></p>
<p><a href="#k14">14. Předání dat serveru v&nbsp;těle požadavku</a></p>
<p><a href="#k15">15. Vlastní jednoduchý testovací HTTP server</a></p>
<p><a href="#k16">16. Implementace HTTP serveru</a></p>
<p><a href="#k17">17. Požadavek poslaný na lokálně běžící HTTP server</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Předchozí články s&nbsp;tématem testování (nejenom) v&nbsp;Pythonu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Testování webových aplikací s&nbsp;REST API z&nbsp;Pythonu</h2>

<p><a
href="https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-od-jednotkovych-testu-az-po-testy-ui/">V&nbsp;úvodní
části seriálu</a> o testování aplikací s&nbsp;využitím Pythonu jsme si řekli,
že v&nbsp;takzvané <i>testovací pyramidě</i> nalezneme velké množství typů
testů:</p>

<ol>
<li>Jednotkové testy</li>
<li>Testy komponent a integrační testy</li>
<li>Systémové testy, akceptační testy</li>
<li>Testy aplikačního (programového) rozhraní</li>
<li>Testy grafického uživatelského rozhraní a end-to-end testy</li>
<li>Testy chování (BDD)</li>
</ol>

<p>Důležitým typem testů jsou <i>testy aplikačního programového rozhraní</i>,
dnes typicky (ale nejenom) REST API. Tyto testy mohou být vyvinuty a spouštěny
samostatně (například vůči jedné izolované komponentě), nebo mohou být součástí
end-to-end testů zmíněných dále. Součástí API testů bývají i kontroly
autentizace a autorizace, stejně jako kontroly, jak API reaguje na pokusy o
průnik popř.&nbsp;&bdquo;pouze&ldquo; na vadná data. Jak jsme si již řekli na
začátku tohoto odstavce, dnes se velmi často používá REST API, takže testy pro
ně lze vytvořit různými způsoby (například automaticky ze specifikace OpenAPI),
ovšem používají se i další protokoly (MQTT, SOAP, RMI, SMTP atd.). Pro některé
typy webových aplikací (resp.&nbsp;přesněji řečeno jejich REST API) mi
vyhovovala kombinace knihovny Behave se známou knihovnou <a
href="https://requests.readthedocs.io/en/master/">requests</a>, ovšem existují
i mnohé další více či méně komplexní nástroje.</p>

<p>Poměrně snadno se vytváří testy REST API založené na kombinaci již zmíněné
knihovny <i>Requests</i> s&nbsp;frameworkem <i>Pytest</i> &ndash; typicky se
jedná o testy typu &bdquo;pošlu HTTP požadavek a očekávám tuto odpověď&ldquo;.
To, do jaké míry bude možné zjistit stav serveru, do značné míry záleží na
konkrétním REST API rozhraní, ovšem pro mikroslužby komunikující přes REST API
(kde se očekává jen limitovaný stavový prostor) může být kombinace
<i>Requests+Pytest</i> dostatečná. Ovšem v&nbsp;dalších pokračováních tohoto
seriálu se zaměříme i na další možnosti, poloautomatické vytváření testů na
základě <i>OpenAPI</i> apod.</p>

<p>Dnes si popíšeme základní vlastnosti protokolu HTTP z&nbsp;hlediska
uživatele. Demonstrační příklady budou vždy naprogramovány v&nbsp;Pythonu
s&nbsp;využitím funkcí a metod z&nbsp;knihovny <i>Requests</i>, ovšem tam, kde
to má smysl, bude ukázáno i alternativní použití velmi užitečného nástroje
<strong>curl</strong> a v&nbsp;několika případech použijeme i nástroj
<strong>telnet</strong>, v&nbsp;němž hlavičku a popř.&nbsp;i tělo požadavku
vytvoříme ručně (což není příliš praktické, ovšem lépe se tak ukáže funkce HTTP
na nižší úrovni, kterou před námi <i>Requests</i> i <strong>curl</strong> do
jisté míry skrývá).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instalace knihovny Requests pro aktuálně přihlášeného uživatele</h2>

<p>Instalace knihovny <strong>Requests</strong> je velmi jednoduchá a použijeme
pro ni nástroj <strong>pip</strong> resp.&nbsp;(podle aktuální konfigurace
systému) <strong>pip3</strong>, tj.&nbsp;<i>pip installer</i> určený pro
ekosystém programovacího jazyka Python 3. Instalaci provedeme s&nbsp;volbou
<strong>--user</strong>, čímž zajistíme, že se všechny soubory nainstalují do
adresáře <strong>~/.local</strong> a pro instalaci tak nebude zapotřebí mít
práva superuživatele:</p>

<pre>
$ <strong>pip3 install --user requests</strong>
</pre>

<p>Průběh instalace může vypadat následovně (jedná se o čistě nainstalovanou
Fedoru 27 Server, proto se v&nbsp;ukázce instaluje poněkud postarší verze
knihovny):</p>

<pre>
Collecting requests
  Downloading https://files.pythonhosted.org/packages/65/47/7e02164a2a3db50ed6d8a6ab1d6d60b69c4c3fdf57a284257925dfc12bda/requests-2.19.1-py2.py3-none-any.whl (91kB)
    100% |████████████████████████████████| 92kB 296kB/s 
Collecting chardet&lt;3.1.0,&gt;=3.0.2 (from requests)
  Downloading https://files.pythonhosted.org/packages/bc/a9/01ffebfb562e4274b6487b4bb1ddec7ca55ec7510b22e4c51f14098443b8/chardet-3.0.4-py2.py3-none-any.whl (133kB)
    100% |████████████████████████████████| 143kB 898kB/s 
Collecting idna&lt;2.8,&gt;=2.5 (from requests)
  Downloading https://files.pythonhosted.org/packages/4b/2a/0276479a4b3caeb8a8c1af2f8e4355746a97fab05a372e4a2c6a6b876165/idna-2.7-py2.py3-none-any.whl (58kB)
    100% |████████████████████████████████| 61kB 1.8MB/s 
Collecting urllib3&lt;1.24,&gt;=1.21.1 (from requests)
  Downloading https://files.pythonhosted.org/packages/bd/c9/6fdd990019071a4a32a5e7cb78a1d92c53851ef4f56f62a3486e6a7d8ffb/urllib3-1.23-py2.py3-none-any.whl (133kB)
    100% |████████████████████████████████| 143kB 1.8MB/s 
Collecting certifi&gt;=2017.4.17 (from requests)
  Downloading https://files.pythonhosted.org/packages/7c/e6/92ad559b7192d846975fc916b65f667c7b8c3a32bea7372340bfe9a15fa5/certifi-2018.4.16-py2.py3-none-any.whl (150kB)
    100% |████████████████████████████████| 153kB 976kB/s 
Installing collected packages: chardet, idna, urllib3, certifi, requests
Successfully installed certifi-2018.4.16 chardet-3.0.4 idna-2.7 requests-2.19.1 urllib3-1.23
</pre>

<p>Pokud je již knihovna <strong>Requests</strong> nainstalována, bude celý
proces mnohem kratší:</p>

<pre>
$ <strong>pip3 install --user requests</strong>
&nbsp;
Requirement already satisfied (use --upgrade to upgrade): requests in /usr/lib/python3/dist-packages
Cleaning up...
</pre>

<p>Alternativně je samozřejmě možné knihovnu nainstalovat do systémových
adresářů, takže bude dostupná pro všechny uživatele:</p>

<pre>
$ <strong>sudo pip3 install requests</strong>
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Kontrola instalace knihovny Requests</h2>

<p>Po instalaci si můžeme ověřit, zda je knihovna <strong>Requests</strong>
skutečně korektně nainstalována a zda k&nbsp;ní má interpret Pythonu přístup.
Nejprve běžným způsobem spustíme interpret Pythonu:</p>

<pre>
$ <strong>python3</strong>
Python 3.6.6 (default, Jul 19 2018, 16:29:00) 
[GCC 7.3.1 20180303 (Red Hat 7.3.1-5)] on linux
Type "help", "copyright", "credits" or "license" for more information.
</pre>

<p>Následně se pokusíme naimportovat knihovnu <strong>Requests</strong> a pro
jistotu zobrazit i její dokumentaci:</p>

<pre>
&gt;&gt;&gt; import requests
&gt;&gt;&gt; help("requests")
</pre>

<p>V&nbsp;případě, že instalace proběhla v&nbsp;pořádku, měl by výstup vypadat
přibližně následovně:</p>

<pre>
Help on package requests:
&nbsp;
NAME
    requests
&nbsp;
DESCRIPTION
    Requests HTTP Library
    ~~~~~~~~~~~~~~~~~~~~~
&nbsp;
    Requests is an HTTP library, written in Python, for human beings. Basic GET
    usage:
&nbsp;
       &gt;&gt;&gt; import requests
       &gt;&gt;&gt; r = requests.get('https://www.python.org')
       &gt;&gt;&gt; r.status_code
       200
       &gt;&gt;&gt; 'Python is a programming language' in r.content
       True
&nbsp;
    ... or POST:
&nbsp;
       &gt;&gt;&gt; payload = dict(key1='value1', key2='value2')
       &gt;&gt;&gt; r = requests.post('http://httpbin.org/post', data=payload)
       &gt;&gt;&gt; print(r.text)
       {
         ...
         "form": {
           "key2": "value2",
           "key1": "value1"
         },
         ...
       }
&nbsp;
    The other HTTP methods are supported - see `requests.api`. Full documentation
    is at &lt;http://python-requests.org&gt;.
&nbsp;
    :copyright: (c) 2017 by Kenneth Reitz.
    :license: Apache 2.0, see LICENSE for more details.
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Základ protokolu HTTP: metody a stavové kódy</h2>

<p>Protokol HTTP neboli <i>Hypertext Transfer Protocol</i> byl původně navržen
pro přenos hypertextových dokumentů napsaných ve formátu/jazyku HTML. Dnes se
ovšem používá i pro mnohé další účely; například ho využívají REST API služby
atd. Protokol HTTP pracuje způsobem dotaz-odpověď neboli
<i>request-response</i> (ostatně právě zde můžeme vysledovat původ názvu
knihovny <strong>Requests</strong>).</p>

*** image ***
<p><i>Obrázek 1: Nejjednodušší použití protokolu HTTP &ndash; bezstavové
poslání dotazu a obdržení odpovědi.</i></p>

<p>Jak dotaz, tak i odpověď, jsou reprezentovány formátovaným textem, kde
jednotlivé řádky mají předem známý význam (bližší informace o formátu budou
uvedeny níže). Požadavek většinou vyžaduje nějaký zdroj (<i>resource</i>),
který je identifikován s&nbsp;využitím URL (<i>Uniform Resource Locator</i>).
Celý URL se skládá z&nbsp;několika částí, z&nbsp;nichž mnohé mohou být
vynechány:</p>

<pre>
            userinfo          host        port
        ┌───────┴───────┐ ┌────┴────────┐ ┌┴┐
 http://john.doe:password@www.example.com:123/forum/questions/?tag=networking&amp;order=newest#top
 └─┬─┘ └───────────┬────────────────────────┘└─┬─────────────┘└────────┬──────────────────┘└┬─┘
 scheme         authority                      path                  query             fragment
&nbsp;
(Zdroj: Wikipedia)
</pre>

<p>Protokolem HTTP je samozřejmě možné přenášet i data; ostatně pro tento účel
slouží pojmenované metody s&nbsp;předem specifikovaným významem (viz tabulku
pod tímto odstavcem). Specifikace protokolu HTTP rovněž obsahuje popis
takzvaných stavových kódů, kterými server předává klientovi výsledek zpracování
dotazu.</p>

<p>V&nbsp;následující tabulce je uveden přehled všech <i>metod</i> HTTP
protokolu, přičemž nejpoužívanější jsou první dvě metody <strong>GET</strong> a
<strong>POST</strong>, s&nbsp;jejichž použitím se seznámíme
v&nbsp;demonstračních příkladech popsaných v&nbsp;navazujících kapitolách:</p>

<table>
<tr><th>Metoda</th><th>Příklad použití</th></tr>
<tr><td>GET</td><td>Základní metoda sloužící k&nbsp;získání dat ze serveru. Může se například jednat o HTML stránku, statický obrázek, ale i výsledek volání REST API služby.</td></tr>
<tr><td>POST</td><td>Metoda používaná pro odesílání dat na server. Teoreticky je sice možné použít i metodu GET, ovšem sémanticky je vhodnější použít tuto metodu (a REST API služby sémantiku operace většinou dodržují).</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>PUT</td><td>Tato metoda slouží k&nbsp;nahrání dat na server. S&nbsp;touto metodou se setkáme u některých REST API služeb.</td></tr>
<tr><td>DELETE</td><td>Slouží ke smazání dat ze serveru. Opět platí &ndash; s&nbsp;touto metodou se setkáme méně často u některých REST API služeb.</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>HEAD</td><td>Tato metoda se částečně podobá metodě GET, ovšem server nevrátí požadovaná data, ale pouze metadata (čas změny, velikost dat, typ/formát dat apod.). Obecně je možné říci, že se tento dotaz zpracuje rychleji než GET.</td></tr>
<tr><td>CONNECT</td><td>Používá se při použití TCP/IP tunelování.</td></tr>
<tr><td>OPTIONS</td><td>Poslání dotazu na server, které metody podporuje. Využití najde například při použití CORS apod.</td></tr>
<tr><td>TRACE</td><td>Server by měl klientovi odeslat požadavek zpět, čehož se používá pro zjištění, které údaje se mění na přenosové cestě.</td></tr>
<tr><td>PATCH</td><td>Umožňuje změnu dat na serveru, má tady jinou sémantiku než DELETE+PUT.</td></tr>
</table>

<p>Stavový kód odpovědi serveru je reprezentován celým číslem, přičemž
z&nbsp;první číslice (stovky) lze odvodit základní vlastnost stavu (úspěch,
chyba, přesměrování...):</p>

<table>
<tr><th>Skupina stavových kódů</th><th>Význam</th></tr>
<tr><td>1xx</td><td>informační, potvrzení atd. (ovšem požadavek se prozatím nevykonal)</td></tr>
<tr><td>2xx</td><td>úspěšné vyřízení požadavku popř.&nbsp;jeho akceptace serverem (202)</td></tr>
<tr><td>3xx</td><td>přesměrování požadavku, informace o tom, že se objekt nezměnil atd.</td></tr>
<tr><td>4xx</td><td>různé typy chyb typicky zaviněných klientem (bohužel nejrozsáhlejší skupina)</td></tr>
<tr><td>5xx</td><td>různé chyby na serveru</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Nejjednodušší příklad &ndash; poslání požadavku GET na zvolenou adresu</h2>

<p>V&nbsp;dnešním <a
href="https://github.com/tisnik/testing-in-python/tree/master/requests/01_basic_usage.py">prvním
demonstračním příkladu</a> si ukážeme, jakým způsobem je možné použít základní
HTTP metodu GET pro poslání požadavku na server. Použijeme přitom server
dostupný na adrese <a href="http://httpbin.org/">http://httpbin.org/</a>,
který je možné využít pro otestování základních HTTP metod i jednoduchých REST
API služeb. Konkrétně pošleme požadavek na adresu <a
href="http://httpbin.org/get">http://httpbin.org/get</a>; v&nbsp;samotném
požadavku nebudou předány žádné parametry. Dále se pokusíme stejný požadavek
odeslat na neexistující URL <a
href="http://httpbin.org/neexistuje">http://httpbin.org/neexistuje</a>.</p>

<p>Z&nbsp;příkazové řádky můžeme dotazy poslat pomocí univerzálního nástroje
<strong>curl</strong>:</p>

<pre>
$ <strong>curl -v http://httpbin.org/get</strong>
&nbsp;
% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0*   Trying 3.220.112.94...
* TCP_NODELAY set
* Connected to httpbin.org (3.220.112.94) port 80 (#0)
&gt; GET /get HTTP/1.1
&gt; Host: httpbin.org
&gt; User-Agent: curl/7.55.1
&gt; Accept: */*
&gt; 
&lt; HTTP/1.1 200 OK
&lt; Date: Sun, 05 Jul 2020 18:46:02 GMT
&lt; Content-Type: application/json
&lt; Content-Length: 252
&lt; Connection: keep-alive
&lt; Server: gunicorn/19.9.0
&lt; Access-Control-Allow-Origin: *
&lt; Access-Control-Allow-Credentials: true
&lt; 
{ [252 bytes data]
100   252  100   252    0     0    252      0  0:00:01 --:--:--  0:00:01   672
* Connection #0 to host httpbin.org left intact
{
  "args": {}, 
  "headers": {
    "Accept": "*/*", 
    "Host": "httpbin.org", 
    "User-Agent": "curl/7.55.1", 
    "X-Amzn-Trace-Id": "Root=1-5f021fea-fb5e443098df529029b36f40"
  }, 
  "origin": "37.48.51.80", 
  "url": "http://httpbin.org/get"
}
</pre>

<p><div class="rs-tip-major">Poznámka: znakem &gt; jsou uvozeny data požadavku
(<i>request</i>), znakem &lt; pak hlavička odpovědi serveru (<i>response</i>).
Samotný text odpovědi není nijak uvozen a obsahuje data ve formátu
JSON.</div></p>

<p>Dotaz na neexistující zdroj mnoho serverů zpracuje takovým způsobem, že
kromě HTTP kódu 404 navíc pošle i data, která jsou zobrazitelná ve webovém
prohlížeči:</p>

<pre>
*   Trying 3.220.112.94...
* TCP_NODELAY set
* Connected to httpbin.org (3.220.112.94) port 80 (#0)
&gt; GET /neexistuje HTTP/1.1
&gt; Host: httpbin.org
&gt; User-Agent: curl/7.55.1
&gt; Accept: */*
&gt; 
&lt; HTTP/1.1 404 NOT FOUND
&lt; Date: Sun, 05 Jul 2020 18:53:50 GMT
&lt; Content-Type: text/html
&lt; Content-Length: 233
&lt; Connection: keep-alive
&lt; Server: gunicorn/19.9.0
&lt; Access-Control-Allow-Origin: *
&lt; Access-Control-Allow-Credentials: true
&lt; 
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;
&lt;title&gt;404 Not Found&lt;/title&gt;
&lt;h1&gt;Not Found&lt;/h1&gt;
&lt;p&gt;The requested URL was not found on the server.  If you entered the URL manually please check your spelling and try again.&lt;/p&gt;
* Connection #0 to host httpbin.org left intact
</pre>

<p><strong>curl</strong> je sice velmi užitečným nástrojem, ovšem některé
operace před programátory skrývá. Můžeme však jít ještě níže a komunikovat
s&nbsp;HTTP serverem s&nbsp;využitím starého dobrého <strong>telnetu</strong>.
Nejprve se připojíme k&nbsp;HTTP serveru na port 80:</p>

<pre>
$ <strong>telnet httpbin.org 80</strong>
Trying 3.220.112.94...
Connected to httpbin.org.
Escape character is '^]'.
</pre>

<p>HTTP metoda GET se zadává řádkem GET, za nímž následuje cesta a popř.&nbsp;i
parametry:</p>

<pre>
<strong>GET /get</strong>
{
  "args": {}, 
  "headers": {
    "Host": "a0207c42-pmhttpbin-pmhttpb-c018-592832243.us-east-1.elb.amazonaws.com", 
    "X-Amzn-Trace-Id": "Root=1-5f0222d9-575a6990dba9ef7041fa18d8"
  }, 
  "origin": "37.48.51.80", 
  "url": "http://a0207c42-pmhttpbin-pmhttpb-c018-592832243.us-east-1.elb.amazonaws.com/get"
}
Connection closed by foreign host.
</pre>

<p><div class="rs-tip-major">Poznámka: můžeme vidět, že server poslal odpověď a
následně se odpojil (poslední řádek není součástí odpovědi, ale hlášení
telnetu).</div></p>

<p>Nyní se již můžeme pokusit o použití knihovny <i>Request</i> a přepis
předchozích dotazů do Pythonu. Je to velmi snadné, což je ostatně patrné i ze
zdrojového kódu dnešního prvního demonstračního příkladu:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import <strong>requests</strong>
&nbsp;
<i># adresa s testovaci REST API sluzbou</i>
URL = "http://httpbin.org/get"
&nbsp;
<i># poslani HTTP dotazu typu GET</i>
response = <strong>requests.get(URL)</strong>
&nbsp;
<i># vypis objektu, ktery se vrati</i>
print(response)
&nbsp;
&nbsp;
&nbsp;
<i># nyni vyzkousime neexistujici endpoint:</i>
&nbsp;
<i># adresa s testovaci REST API sluzbou</i>
URL = "http://httpbin.org/neexistuje"
&nbsp;
<i># poslani HTTP dotazu typu GET</i>
response = <strong>requests.get(URL)</strong>
&nbsp;
<i># vypis objektu, ktery se vrati</i>
print(response)
</pre>

<p>Po spuštění tohoto příkladu by se na standardním výstupu (tj.&nbsp;na
konzoli či na emulátoru terminálu) měly objevit pouhé dva řádky. První
z&nbsp;nich by měl obsahovat textovou podobu prvního objektu typu
<strong>Response</strong>, který představuje úspěšnou odpověď serveru
s&nbsp;HTTP kódem 200. Druhý řádek by měl obsahovat textovou podobu objektu
typu <strong>Response</strong> s&nbsp;HTTP kódem 404, což je ovšem
pochopitelné, protože jsme se snažili přistoupit k&nbsp;neexistující URL:</p>

<pre>
&lt;Response [200]&gt;
&nbsp;
&lt;Response [404]&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že je možné bez problémů
použít i protokol HTTPS namísto pouhého HTTP. Od této skutečnosti je
programátor využívající knihovnu <strong>Requests</strong> většinou
odstíněn. Varianta s&nbsp;HTTPS:</div></p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import <strong>requests</strong>
&nbsp;
<i># adresa s testovaci REST API sluzbou</i>
URL = "<strong>https</strong>://httpbin.org/get"
&nbsp;
<i># poslani HTTP dotazu typu GET</i>
response = <strong>requests.get(URL)</strong>
&nbsp;
<i># vypis objektu, ktery se vrati</i>
print(response)
&nbsp;
&nbsp;
&nbsp;
<i># nyni vyzkousime neexistujici endpoint:</i>
&nbsp;
<i># adresa s testovaci REST API sluzbou</i>
URL = "<strong>https://httpbin.org/neexistuje</strong>"
&nbsp;
<i># poslani HTTP dotazu typu GET</i>
response = <strong>requests.get(URL)</strong>
&nbsp;
<i># vypis objektu, ktery se vrati</i>
print(response)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Základní atributy objektu typu <strong>Response</strong>: stavový kód a indikátor korektní odpovědi</h2>

<p>Ve <a
href="https://github.com/tisnik/testing-in-python/tree/master/requests/02_check_status.py">druhém
demonstračním příkladu</a>, který bude opět velmi jednoduchý, si ukážeme, jakým
způsobem je možné zjistit stav (<i>HTTP status</i>) předaný v&nbsp;odpovědi.
Z&nbsp;předchozích kapitol, ale i z&nbsp;běžných zkušeností s&nbsp;browserem,
víme, že stavový kód HTTP je představován celým číslem doplněným o textový
popisek stavu. V&nbsp;objektu typu <strong>Response</strong> představujícího
odpověď serveru je číselný kód stavu uložen v&nbsp;atributu pojmenovaném
<strong>status_code</strong>. Kromě toho existuje ještě atribut nazvaný
<strong>ok</strong>, který obsahuje pravdivostní hodnotu <strong>True</strong>
v&nbsp;případě, že je číselný kód stavu menší než 400 a hodnotu
<strong>False</strong> v&nbsp;opačném případě. Použití tohoto atributu tedy
může být poněkud problematické, protože například některé stavy 3xx je možné
v&nbsp;kontextu vyvíjené aplikace považovat za chybové stavy:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import <strong>requests</strong>
&nbsp;
<i># adresa s testovaci REST API sluzbou</i>
URL = "http://httpbin.org/get"
&nbsp;
<i># poslani HTTP dotazu typu GET</i>
response = <strong>requests.get(URL)</strong>
&nbsp;
<i># vypis stavu odpovedi</i>
print(response.status_code)
print(response.ok)
&nbsp;
&nbsp;
&nbsp;
<i># nyni vyzkousime neexistujici endpoint:</i>
&nbsp;
<i># adresa s testovaci REST API sluzbou</i>
URL = "http://httpbin.org/neexistuje"
&nbsp;
<i># poslani HTTP dotazu typu GET</i>
response = <strong>requests.get(URL)</strong>
&nbsp;
<i># vypis stavu odpovedi</i>
print(response.status_code)
print(response.ok)
</pre>

<p>Podívejme se, jaké hodnoty se vypíšou pro korektní URL <a
href="https://httpbin.org/get">https://httpbin.org/get</a> a jaké hodnoty pro
nekorektní URL <a
href="https://httpbin.org/neexistuje">https://httpbin.org/neexistuje</a>. Pro
korektní URL získáme podle očekávání stavový kód 200 a atribut
<strong>ok</strong> bude mít hodnotu <strong>True</strong>:</p>

<pre>
200
True
</pre>

<p>Pro nekorektní URL je stavový kód HTTP roven 404 a tím pádem je i atribut
<strong>ok</strong> nastaven na hodnotu <strong>False</strong>:</p>

<pre>
404
False
</pre>

<p>Můžeme použít i adresu, která vrací HTTP kód 500 značící interní chybu
serveru:</p>

<pre>
$ <strong>curl -v http://httpbin.org/status/500</strong>
&nbsp;
*   Trying 3.220.112.94...
* TCP_NODELAY set
* Connected to httpbin.org (3.220.112.94) port 80 (#0)
&gt; GET /status/500 HTTP/1.1
&gt; Host: httpbin.org
&gt; User-Agent: curl/7.55.1
&gt; Accept: */*
&gt; 
&lt; HTTP/1.1 500 INTERNAL SERVER ERROR
&lt; Date: Sun, 05 Jul 2020 19:16:31 GMT
&lt; Content-Type: text/html; charset=utf-8
&lt; Content-Length: 0
&lt; Connection: keep-alive
&lt; Server: gunicorn/19.9.0
&lt; Access-Control-Allow-Origin: *
&lt; Access-Control-Allow-Credentials: true
&lt; 
* Connection #0 to host httpbin.org left intact
</pre>

<p><a
href="https://github.com/tisnik/testing-in-python/tree/master/requests/02_any_status.py">Totéž
v&nbsp;Pythonu</a>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import <strong>requests</strong>
&nbsp;
<i># adresa s testovaci REST API sluzbou</i>
URL = "http://httpbin.org/status/500"
&nbsp;
<i># poslani HTTP dotazu typu GET</i>
response = <strong>requests.get(URL)</strong>
&nbsp;
<i># vypis stavu odpovedi</i>
print(response.status_code)
print(response.ok)
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je možné adresu
<strong>http://httpbin.org/status/XYZ</strong> zavolat s&nbsp;libovolným
stavovým kódem, který má být vrácený v&nbsp;odpovědi, a to včetně kódů
neznámých:</div></p>

<pre>
$ <strong>curl -v http://httpbin.org/status/999</strong>
&nbsp;
*   Trying 54.236.246.173...
* TCP_NODELAY set
* Connected to httpbin.org (54.236.246.173) port 80 (#0)
&gt; GET /status/999 HTTP/1.1
&gt; Host: httpbin.org
&gt; User-Agent: curl/7.55.1
&gt; Accept: */*
&gt; 
&lt; HTTP/1.1 999 UNKNOWN
&lt; Date: Sun, 05 Jul 2020 19:19:01 GMT
&lt; Content-Type: text/html; charset=utf-8
&lt; Content-Length: 0
&lt; Connection: keep-alive
&lt; Server: gunicorn/19.9.0
&lt; Access-Control-Allow-Origin: *
&lt; Access-Control-Allow-Credentials: true
&lt; 
* Connection #0 to host httpbin.org left intact
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Přečtení vybrané hlavičky z&nbsp;odpovědi HTTP serveru</h2>

<p>Odpověď serveru ve formě pouhého HTTP stavu (číselného kódu) samozřejmě
většinou není příliš přínosná (kromě dotazů na to, zda se nějaký zdroj
nezměnil), protože serveru posíláme dotaz za účelem získání nějakých dat (nebo
změny stavu, ovšem v&nbsp;tomto případě se nepoužije metoda GET). Protokol HTTP
je navržen takovým způsobem, že dokáže přenášet data v&nbsp;různých formátech,
přičemž formát se rozpozná na základě hodnoty uložené do hlavičky pojmenované
<strong>content-type</strong> (opět viz předchozí kapitoly s&nbsp;popisem této
hlavičky). Údaje ze všech hlaviček získaných z&nbsp;odpovědi serveru je
samozřejmě možné získat, protože objekt typu <strong>Response</strong> obsahuje
mj.&nbsp;i atribut <strong>headers</strong>, ve kterém jsou všechny hlavičky
uloženy ve formě slovníku (jméno hlavičky:hodnota). V&nbsp;dnešním <a
href="https://github.com/tisnik/testing-in-python/tree/master/requests/03_content_type.py">třetím
demonstračním příkladu</a> je ukázáno, jakým způsobem se přistupuje právě
k&nbsp;hlavičce <strong>content-type</strong> obsahující typ/formát dat, které
server odeslal (nebo by měl odeslat) klientovi:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import <strong>requests</strong>
&nbsp;
<i># adresa s testovaci REST API sluzbou</i>
URL = "http://httpbin.org/get"
&nbsp;
<i># poslani HTTP dotazu typu GET</i>
response = <strong>requests.get(URL)</strong>
&nbsp;
<i># precteni hlavicek</i>
headers = response.headers
&nbsp;
<i># vypis typu internetoveho media</i>
print(headers.get("content-type"))
</pre>

<p>Webová služba dostupná na adrese <a
href="http://httpbin.org/get">http://httpbin.org/get</a> nebo i <a
href="https://httpbin.org/get">https://httpbin.org/get</a> vrací hodnoty
uložené v&nbsp;těle odpovědi, přičemž tyto hodnoty jsou reprezentovány ve
známém a velmi často využívaném <a href="http://json.org/">formátu JSON</a>.
Služba je tedy správně nakonfigurována takovým způsobem, že vrací typ dat:</p>

<pre>
application/json
</pre>

<p>Naproti tomu jiné koncové body vrací data v&nbsp;odlišném formátu, což si
opět můžeme velmi snadno otestovat:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import <strong>requests</strong>
&nbsp;
<i># adresa s testovaci REST API sluzbou</i>
URL = "http://httpbin.org/status/500"
&nbsp;
<i># poslani HTTP dotazu typu GET</i>
response = <strong>requests.get(URL)</strong>
&nbsp;
<i># precteni hlavicek</i>
headers = response.headers
&nbsp;
<i># vypis typu internetoveho media</i>
print(headers.get("content-type"))
&nbsp;
<i># tento koncový bod vrací obrázek</i>
URL = "http://httpbin.org/image/png"
&nbsp;
<i># poslani HTTP dotazu typu GET</i>
response = <strong>requests.get(URL)</strong>
&nbsp;
<i># precteni hlavicek</i>
headers = response.headers
&nbsp;
<i># vypis typu internetoveho media</i>
print(headers.get("content-type"))
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
text/html; charset=utf-8
image/png
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Předání informací (parametrů) serveru přímo v&nbsp;URL</h2>

<p>Serveru, jehož služby potřebujeme přes knihovnu <strong>Requests</strong>
využívat, je samozřejmě možné předat nějaká data. Protokol HTTP podporuje dva
základní způsoby předání dat. Pokud se jedná o několik parametrů
s&nbsp;relativně malým (krátkým) obsahem, je možné takové parametry předat
přímo v&nbsp;URL (v&nbsp;prohlížeči přes adresní řádek). Zápis URL by
v&nbsp;takovém případě měl vypadat následovně:</p>

<pre>
protokol://adresa.serveru/endpoint?parametr1=hodnota1&amp;parametr2=hodnota2&amp;parametr2=hodnota2
</pre>

<p>Konkrétně v&nbsp;našem konkrétním případě, kdy používáme testovací server <a
href="http://httpbin.org/">http://httpbin.org/</a>:</p>

<pre>
http://httpbin.org/get?x=6&amp;y=7&amp;answer=42
</pre>

<p>Příklad používající <strong>telnet</strong> ukáže, že se poslaná data
objevují i v&nbsp;odpovědi serveru:</p>

<pre>
$ <strong>telnet httpbin.org 80</strong>
&nbsp;
Trying 54.236.246.173...
Connected to httpbin.org.
Escape character is '^]'.
GET /get?x=6&amp;y=7&amp;answer=42
{
  "args": {
    "answer": "42", 
    "x": "6", 
    "y": "7"
  }, 
  "headers": {
    "Host": "a0207c42-pmhttpbin-pmhttpb-c018-592832243.us-east-1.elb.amazonaws.com", 
    "X-Amzn-Trace-Id": "Root=1-5f022b53-28ef633486278da51c263ebf"
  }, 
  "origin": "37.48.51.80", 
  "url": "http://a0207c42-pmhttpbin-pmhttpb-c018-592832243.us-east-1.elb.amazonaws.com/get?x=6&amp;y=7&amp;answer=42"
}
Connection closed by foreign host.
</pre>

<p>Tento způsob přináší některá omezení. Zejména je nutné zajistit, aby se ve
jménech a hodnotách parametrů nevyskytovaly některé znaky, které slouží jako
oddělovače ve vlastní URL. Touto problematikou, kterou lze opět řešit
automaticky, se budeme zabývat příště. Také je nutné zajistit (a zjistit), zda
server neomezuje délku URL, například na 1024 znaků atd. (ovšem délku URL
mnohdy omezují i prohlížeče).</p>

<p>Příklad, který serveru předá parametry přes URL, se prakticky žádným
způsobem neodlišuje od <a
href="https://github.com/tisnik/testing-in-python/tree/master/requests/01_basic_usage.py">prvního
demonstračního příkladu</a>, takže jen ve stručnosti:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import requests
&nbsp;
<i># adresa s testovaci REST API sluzbou</i>
URL = "http://httpbin.org/get?x=6&amp;y=7&amp;answer=42"
&nbsp;
<i># poslani HTTP dotazu typu GET</i>
response = requests.get(URL)
&nbsp;
<i># vypis objektu, ktery se vrati</i>
print(response)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Přečtení těla odpovědi serveru v&nbsp;původní textové podobě</h2>

<p>Ve chvíli, kdy serveru předáme nějaká data (či parametry), server typicky
odpoví tak, že klientovi pošle zpět vyžadované údaje. V&nbsp;tomto případě není
možné tyto údaje předat v&nbsp;URL (ta je jen součástí dotazu, nikoli
odpovědi), takže všechna vyžadovaná data server pošle v&nbsp;těle odpovědi a
popř.&nbsp;do hlaviček doplní potřebná metadata (například již zmíněný
<i>content-type</i> apod.). V&nbsp;odpovědi, která je v&nbsp;knihovně
<strong>Requests</strong> reprezentována objektem typu
<strong>Response</strong>, lze k&nbsp;nezpracovaným datům přistupovat přes
atribut pojmenovaný <strong>text</strong>:</p>

<pre>
response = requests.get(URL)
data = response.text
</pre>

<p>Opět se podívejme na <a
href="https://github.com/tisnik/testing-in-python/tree/master/requests/04_response_content.py">jednoduchý
demonstrační příklad</a>, který testovacímu serveru pošle tři parametry
<strong>x=6</strong>, <strong>y=7</strong> a <strong>answer=42</strong> a
následně zobrazí odpověď serveru:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import <strong>requests</strong>
&nbsp;
<i># adresa s testovaci REST API sluzbou</i>
URL = "http://httpbin.org/get?x=6&amp;y=7&amp;answer=42"
&nbsp;
<i># poslani HTTP dotazu typu GET</i>
response = <strong>requests.get(URL)</strong>
&nbsp;
<i># vypis tela odpovedi</i>
print("Plain text:")
print("-" * 60)        # horizontalni oddelovac
print(response.text)
print("-" * 60)        # horizontalni oddelovac
</pre>

<p>Příklad odpovědi vrácené serverem:</p>

<pre>
Plain text:
------------------------------------------------------------
{
  "args": {
    "answer": "42", 
    "x": "6", 
    "y": "7"
  }, 
  "headers": {
    "Accept": "*/*", 
    "Accept-Encoding": "gzip, deflate", 
    "Connection": "close", 
    "Host": "httpbin.org", 
    "User-Agent": "python-requests/2.13.0"
  }, 
  "origin": "213.175.37.10", 
  "url": "https://httpbin.org/get?x=6&amp;y=7&amp;answer=42"
}

------------------------------------------------------------
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že testovací server nám
vlastně pouze vrací údaje, které od nás získal, což je dobře, protože ho
skutečně budeme moci použít pro další pokusy.</div></p>

<p>Zajímavá situace nastane ve chvíli, kdy server odešle komprimovaná data,
konkrétně s&nbsp;využitím algoritmu <strong>gzip</strong>. Knihovna
<i>Request</i> v&nbsp;tomto případě provede konverze za nás:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import requests
&nbsp;
<i># adresa s testovaci REST API sluzbou</i>
URL = "http://httpbin.org/gzip"
&nbsp;
<i># poslani HTTP dotazu typu GET</i>
response = requests.get(URL)
&nbsp;
<i># vypis tela odpovedi</i>
print("Plain text:")
print("-" * 60)
print(response.text)
print("-" * 60)
</pre>

<p>Původní obsah (zkomprimovaný) získáme například opět nástrojem
<strong>curl</strong>:</p>

<pre>
$ <strong>curl -v http://httpbin.org/gzip --output response.gzip</strong>
</pre>

<p>Obsah:</p>

<pre>
$ <strong>od -tx1 response.gzip</strong>
&nbsp;
0000000 1f 8b 08 00 f8 ed 02 5f 02 ff 3d 8e 3d 0b 83 30
0000020 14 45 77 7f 85 64 94 26 7e d4 54 2d 74 70 28 6d
0000040 d7 62 a1 6b 8c cf 18 a8 46 62 5c 14 ff 7b a3 82
0000060 e3 3d ef bc cb 9d 1d d7 45 62 92 7d 0f 15 ba ba
0000100 46 8f 70 72 57 d6 00 ab 40 0f 96 cd 36 5a 90 73
0000120 0e bd b1 19 79 be 87 36 c9 d2 a7 1a 36 d6 18 d3
0000140 97 b2 23 4a 8b e3 f6 19 40 e3 5c 40 b7 19 7c d4
0000160 3f 3f 21 94 92 f0 30 be 38 6f a7 0e 17 9a 71 c0
0000200 af 75 00 7a 2b 65 6e 21 a6 75 10 41 55 a7 38 e6
0000220 94 65 94 56 9c b1 28 8c c2 a0 cc 4a 4a eb 4b 82
0000240 6c c3 b2 4f 6d c1 34 6a 7b 7e dc 8b bd 1b 29 2d
0000260 85 ec 56 76 4e 48 9c 92 8c 44 f1 05 39 8b f3 07
0000300 73 e7 44 fb f1 00 00 00
0000310
</pre>

<p>Po dekomprimaci:</p>

<pre>
$ <strong>zcat response.gzip</strong>
&nbsp;
{
  "gzipped": true, 
  "headers": {
    "Accept": "*/*", 
    "Host": "httpbin.org", 
    "User-Agent": "curl/7.55.1", 
    "X-Amzn-Trace-Id": "Root=1-5f02edf8-4c5a955dcaa21210b9b55f67"
  }, 
  "method": "GET", 
  "origin": "37.48.9.246"
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Získání metainformací o poslaných datech (typ a délka)</h2>

<p>Zajímavé a v&nbsp;některých případech i užitečné bude zjištění základních
metainformací o údajích, které nám server zaslal ve své odpovědi. Tyto
metainformace se předávají formou hlaviček, a to zejména hlavičky
<strong>content-type</strong> (typ/formát dat, již známe),
<strong>content-length</strong> (délka dat) a popř.&nbsp;i
<strong>date</strong> (datum vygenerování dat). Údaje z&nbsp;těchto hlaviček
získáme velmi jednoduše, což je ostatně ukázáno i <a
href="https://github.com/tisnik/testing-in-python/tree/master/requests/05_response_content_and_headers.py">v&nbsp;pořadí
již pátém demonstračním příkladu</a>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import <strong>requests</strong>
&nbsp;
<i># adresa s testovaci REST API sluzbou</i>
URL = "http://httpbin.org/get?x=6&amp;y=7&amp;answer=42"
&nbsp;
<i># poslani HTTP dotazu typu GET</i>
response = <strong>requests.get(URL)</strong>
&nbsp;
<i># precteni hlavicek</i>
headers = response.headers
&nbsp;
print("Metadata:")
print("-" * 60)
&nbsp;
<i># vypis typu internetoveho media</i>
print("Typ dat:", headers.get("content-type"))
&nbsp;
<i># vypis delky dat predanych v tele</i>
print("Delka dat:", headers.get("content-length"))
&nbsp;
<i># vypis delky dat predanych v tele</i>
print("Datum:", headers.get("date"))
&nbsp;
print("-" * 60)
&nbsp;
<i># vypis tela odpovedi</i>
print("Plain text:")
print("-" * 60)
print(response.text)
print("-" * 60)
</pre>

<p>Po spuštění tohoto demonstračního příkladu získáme přibližně následující
výstup (ve vašem konkrétním případě bude odlišné datum a popř.&nbsp;i hlavička
<strong>User-Agent</strong>):</p>

<pre>
Metadata:
------------------------------------------------------------
Typ dat: application/json
Delka dat: 385
Datum: Sat, 04 Aug 2018 07:26:26 GMT
------------------------------------------------------------
Plain text:
------------------------------------------------------------
{
  "args": {
    "answer": "42", 
    "x": "6", 
    "y": "7"
  }, 
  "headers": {
    "Accept": "*/*", 
    "Accept-Encoding": "gzip, deflate, compress", 
    "Connection": "close", 
    "Host": "httpbin.org", 
    "User-Agent": "python-requests/2.2.1 CPython/3.4.3 Linux/3.13.0-139-lowlatency"
  }, 
  "origin": "37.48.1.40", 
  "url": "https://httpbin.org/get?x=6&amp;y=7&amp;answer=42"
}
&nbsp;
------------------------------------------------------------
</pre>

<p><div class="rs-tip-major">Poznámka: hlavička <strong>content_length</strong>
nemusí být (a neměla by být) nastavena ve chvíli, kdy je tělo odpovědi prázdné,
viz například <a
href="https://tools.ietf.org/html/rfc7230">https://tools.ietf.org/html/rfc7230</a>.
Některé servery či služby navíc v&nbsp;této hlavičce neposílají správné údaje
&ndash; někdy to vlastně ani není možné, protože odpověď serveru je tvořena
&bdquo;on-the-fly&ldquo;, tj.&nbsp;průběžně.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Zpracování odpovědi, která byla vrácena ve formátu JSON</h2>

<p>Mnoho webových služeb, především těch, které jsou postaveny na architektuře
<i>REST</i> (<i>REpresentational State Transfer</i>), vrací údaje ve formátu
JSON. Přesněji řečeno &ndash; odpovědi serveru obsahují stavovou informaci,
všechny potřebné hlavičky s&nbsp;metainformacemi a taktéž tělo představující
data serializovaná právě do formátu JSON. Ve skutečnosti je zpracování těchto
dat s&nbsp;využitím knihovny <i>Requests</i> velmi jednoduché, protože lze
využít metodu <strong>json()</strong> objektu typu <strong>Response</strong>.
V&nbsp;případě, že server skutečně odeslal data ve formátu JSON, jsou tato data
deserializována a vrácena programu ve formě seznamu či (častěji) slovníku,
jehož prvky mohou být opět seznamy, slovníky, primitivní hodnoty atd. Následně
je možné tato data zpracovat. V&nbsp;případě, že data nejsou ve formátu JSON,
vyvolá se výjimka typu <strong>ValueError</strong>
popř.&nbsp;<strong>json.decoder.JSONDecodeError</strong>:</p>

<pre>
<i># zpracovani odpovedi, ktera prisla ve formatu JSON</i>
data = response.json()
&nbsp;
<i># celý desrializovaný obsah JSONu</i>
print(data)
&nbsp;
<i># vybraná část</i>
args = data["args"]
print(args)
&nbsp;
print("x =", args["x"])
print("y =", args["y"])
print("answer =", args["answer"])
</pre>

<p>Zpracování údajů vrácených testovacím serverem <a
href="https://httpbin.org/">https://httpbin.org/</a> je ukázáno <a
href="https://github.com/tisnik/testing-in-python/tree/master/requests/06_response_json.py">v&nbsp;dnešním
šestém demonstračním příkladu</a>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import <strong>requests</strong>
&nbsp;
<i># adresa s testovaci REST API sluzbou</i>
URL = "http://httpbin.org/get?x=6&amp;y=7&amp;answer=42"
&nbsp;
<i># poslani HTTP dotazu typu GET</i>
response = <strong>requests.get(URL)</strong>
&nbsp;
<i># zpracovani odpovedi, ktera prisla ve formatu JSON</i>
data = response.json()
&nbsp;
print(data)
&nbsp;
args = data["args"]
print(args)
&nbsp;
print("x =", args["x"])
print("y =", args["y"])
print("answer =", args["answer"])
</pre>

<p>Po spuštění tohoto příkladu by se nejprve měl vypsat obsah celého těla
odpovědi (deserializovaný z&nbsp;JSONu):</p>

<pre>
{'args': {'answer': '42', 'x': '6', 'y': '7'}, 'headers': {'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate', 'Connection': 'close', 'Host': 'httpbin.org', 'User-Agent': 'python-requests/2.13.0'}, 'origin': '213.175.37.10', 'url': 'https://httpbin.org/get?x=6&amp;y=7&amp;answer=42'}
</pre>

<p>Následně by se měly vypsat jen vybrané údaje:</p>

<pre>
{'answer': '42', 'x': '6', 'y': '7'}
x = 6
y = 7
answer = 42
</pre>

<p>Chyba, která vznikne při pokusu o zpracování odpovědi, která neobsahuje data
ve formátu JSON:</p>

<pre>
  File "06_response_json_error.py", line 13, in <module>
    data = response.json()
  File "/usr/lib/python3.6/site-packages/requests/models.py", line 897, in json
    return complexjson.loads(self.text, **kwargs)
  File "/usr/lib64/python3.6/json/__init__.py", line 354, in loads
    return _default_decoder.decode(s)
  File "/usr/lib64/python3.6/json/decoder.py", line 339, in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
  File "/usr/lib64/python3.6/json/decoder.py", line 357, in raw_decode
    raise JSONDecodeError("Expecting value", s, err.value) from None
json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)
</pre>

<p><div class="rs-tip-major">Poznámka: předchozí chyba vznikla při zpracování
odpovědi z&nbsp;adresy <a
href="http://httpbin.org/bytes/100">http://httpbin.org/bytes/100</a>.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Použití HTTP metody POST</h2>

<p>Kromě metody <strong>GET</strong> protokolu HTTP je samozřejmě možné
v&nbsp;knihovně <i>Requests</i> použít i metodu <strong>POST</strong>. Tato
metoda se typicky používá ve chvíli, kdy je zapotřebí předat serveru větší
množství parametrů a/nebo rozsáhlejších dat (a její sémantika je navíc od
<strong>GET</strong> odlišná, protože <strong>POST</strong> mění stav).
Existuje několik způsobů, jak tato data předávat, ovšem <a
href="https://github.com/tisnik/testing-in-python/tree/master/requests/07_post_method.py">v&nbsp;prvním
příkladu</a>, v&nbsp;němž metodu <strong>POST</strong> použijeme, se žádná data
prozatím předávat nebudou. Úplný zdrojový kód tohoto příkladu vypadá
následovně:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import <strong>requests</strong>
&nbsp;
<i># adresa s testovaci REST API sluzbou</i>
URL = "http://httpbin.org/post"
&nbsp;
<i># poslani HTTP dotazu typu POST</i>
response = requests.post(URL)
&nbsp;
<i># vypis odpovedi v plain textu</i>
print(response.text)
</pre>

<p>Zajímavá je odpověď serveru. Povšimněte si především toho, že nám server
vrátil klíč <strong>form</strong> a <strong>json</strong>. K&nbsp;těmto klíčům
se dostaneme později:</p>

<pre>
{
  "args": {}, 
  "data": "", 
  "files": {}, 
  "form": {}, 
  "headers": {
    "Accept": "*/*", 
    "Accept-Encoding": "gzip, deflate", 
    "Connection": "close", 
    "Content-Length": "0", 
    "Host": "httpbin.org", 
    "User-Agent": "python-requests/2.13.0"
  }, 
  "json": null, 
  "origin": "213.175.37.10", 
  "url": "http://httpbin.org/post"
}
</pre>

<p>Zdroj <a href="http://httpbin.org/post">http://httpbin.org/post</a>
nepodporuje metodu <strong>GET</strong>, což si ostatně můžeme velmi snadno
ověřit:</p>

<pre>
$ <strong>curl -v http://httpbin.org/post</strong>
&nbsp;
*   Trying 3.220.112.94...
* TCP_NODELAY set
* Connected to httpbin.org (3.220.112.94) port 80 (#0)
&gt; GET /post HTTP/1.1
&gt; Host: httpbin.org
&gt; User-Agent: curl/7.55.1
&gt; Accept: */*
&gt; 
&lt; HTTP/1.1 405 METHOD NOT ALLOWED
&lt; Date: Sun, 05 Jul 2020 19:38:12 GMT
&lt; Content-Type: text/html
&lt; Content-Length: 178
&lt; Connection: keep-alive
&lt; Server: gunicorn/19.9.0
&lt; Allow: OPTIONS, POST
&lt; Access-Control-Allow-Origin: *
&lt; Access-Control-Allow-Credentials: true
&lt; 
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;
&lt;title&gt;405 Method Not Allowed&lt;/title&gt;
&lt;h1&gt;Method Not Allowed&lt;/h1&gt;
&lt;p&gt;The method is not allowed for the requested URL.&lt;/p&gt;
* Connection #0 to host httpbin.org left intact
</pre>

<p>Zvolená HTTP metoda se v&nbsp;nástroji <strong>curl</strong> specifikuje
parametrem <strong>-X</strong>:</p>

<pre>
$ <strong>curl -X POST -v http://httpbin.org/post</strong>
&nbsp;
*   Trying 54.236.246.173...
* TCP_NODELAY set
* Connected to httpbin.org (54.236.246.173) port 80 (#0)
&gt; POST /post HTTP/1.1
&gt; Host: httpbin.org
&gt; User-Agent: curl/7.55.1
&gt; Accept: */*
&gt; 
&lt; HTTP/1.1 200 OK
&lt; Date: Mon, 06 Jul 2020 09:47:33 GMT
&lt; Content-Type: application/json
&lt; Content-Length: 316
&lt; Connection: keep-alive
&lt; Server: gunicorn/19.9.0
&lt; Access-Control-Allow-Origin: *
&lt; Access-Control-Allow-Credentials: true
&lt; 
{
  "args": {}, 
  "data": "", 
  "files": {}, 
  "form": {}, 
  "headers": {
    "Accept": "*/*", 
    "Host": "httpbin.org", 
    "User-Agent": "curl/7.55.1", 
    "X-Amzn-Trace-Id": "Root=1-5f02f335-41e814ac916d8e9484c52160"
  }, 
  "json": null, 
  "origin": "37.48.9.246", 
  "url": "http://httpbin.org/post"
}
* Connection #0 to host httpbin.org left intact
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Předání dat serveru ve &bdquo;formuláři&ldquo;</h2>

<p>První metoda poslání parametrů od klienta na server používá takzvané
&bdquo;formulářové položky&ldquo;. Tento poněkud nepřesný název je odvozen od
toho, že se podobným způsobem posílají data z&nbsp;HTML formuláře (bez použití
JavaScriptu, pouze čistě HTML prostředky). Pokud budeme chtít simulovat
posílání dat tímto způsobem, můžeme použít nepovinný parametr nazvaný
<strong>data</strong> předaný funkci <strong>requests.post()</strong>:</p>

<pre>
payload = {
    "klic": "hodnota",
    "answer": 42,
    "question": None,
    "correct": True}
&nbsp;
<i># poslani HTTP dotazu typu POST se specifikaci hodnot formulare</i>
response = <strong>requests.post(URL, data=payload)</strong>
</pre>

<p>Tento způsob je použit i v&nbsp;dnešním <a
href="https://github.com/tisnik/testing-in-python/tree/master/requests/08_post_method_with_payload.py">osmém
demonstračním příkladu</a>, jehož úplný zdrojový kód vypadá následovně:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import <strong>requests</strong>
&nbsp;
<i># adresa s testovaci REST API sluzbou</i>
URL = "http://httpbin.org/post"
&nbsp;
payload = {
    "klic": "hodnota",
    "answer": 42,
    "question": None,
    "correct": True}
&nbsp;
<i># poslani HTTP dotazu typu POST se specifikaci hodnot formulare</i>
response = <strong>requests.post(URL, data=payload)</strong>
&nbsp;
<i># vypis tela odpovedi v plain textu</i>
print(response.text)
</pre>

<p>Odpověď serveru opět obsahuje položku <strong>form</strong>. Povšimněte si,
že server získal a následně vrátil pouze tři hodnoty &ndash; chybí zde ovšem
hodnota <strong>question=None</strong>, která se ve skutečnosti ve
formulářových datech nepředala (neexistuje zde totiž ekvivalent pro speciální
hodnoty <strong>None</strong>, <strong>nil</strong> či
<strong>null</strong>):</p>

<pre>
{
  "args": {}, 
  "data": "", 
  "files": {}, 
  "form": {
    "answer": "42", 
    "correct": "True", 
    "klic": "hodnota"
  }, 
  "headers": {
    "Accept": "*/*", 
    "Accept-Encoding": "gzip, deflate", 
    "Connection": "close", 
    "Content-Length": "35", 
    "Content-Type": "application/x-www-form-urlencoded", 
    "Host": "httpbin.org", 
    "User-Agent": "python-requests/2.13.0"
  }, 
  "json": null, 
  "origin": "213.175.37.10", 
  "url": "https://httpbin.org/post"
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Předání dat serveru v&nbsp;těle požadavku</h2>

<p>Pokud budeme chtít serveru předat větší množství strukturovaných dat, a to
potenciálně včetně speciálních hodnot, je lepší takové údaje předat přímo
v&nbsp;těle požadavku. Pro tento účel se ve funkci
<strong>requests.post()</strong> použije nepovinný parametr nazvaný
<strong>json</strong> a nikoli parametr pojmenovaný <strong>data</strong> (jako
tomu bylo v&nbsp;příkladu předchozím). Opět se podívejme <a
href="https://github.com/tisnik/testing-in-python/tree/master/requests/09_post_method_with_payload.py">na
jednoduchý demonstrační příklad</a>, který se od příkladu předchozího odlišuje
pouze v&nbsp;jediném detailu &ndash; nepovinném parametru funkce
<strong>requests.post()</strong>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import <strong>requests</strong>
&nbsp;
<i># adresa s testovaci REST API sluzbou</i>
URL = "http://httpbin.org/post"
&nbsp;
payload = {
    "klic": "hodnota",
    "answer": 42,
    "question": None,
    "correct": True}
&nbsp;
<i># poslani HTTP dotazu typu POST s telem</i>
response = requests.post(URL, json=payload)
&nbsp;
<i># vypis tela odpovedi v plain textu</i>
print(response.text)
</pre>

<p>Odpověď serveru nyní vypadá odlišně, protože nám testovací server
v&nbsp;odpovědi říká, jak parametry získal (resp.&nbsp;jak mu byly předány).
Povšimněte si, že nyní je pod klíčem <strong>form</strong> uložen prázdný
slovník, ovšem naše parametry jsou nyní předány pod klíčem
<strong>data</strong> a současně i ve zpracované podobě pod klíčem
<strong>json</strong>:</p>

<pre>
{
  "args": {}, 
  "data": "{\"klic\": \"hodnota\", \"answer\": 42, \"question\": null, \"correct\": true}", 
  "files": {}, 
  "form": {}, 
  "headers": {
    "Accept": "*/*", 
    "Accept-Encoding": "gzip, deflate", 
    "Connection": "close", 
    "Content-Length": "68", 
    "Content-Type": "application/json", 
    "Host": "httpbin.org", 
    "User-Agent": "python-requests/2.13.0"
  }, 
  "json": {
    "answer": 42, 
    "correct": true, 
    "klic": "hodnota", 
    "question": null
  }, 
  "origin": "213.175.37.10", 
  "url": "https://httpbin.org/post"
}
</pre>

<p><div class="rs-tip-major">Poznámka: hodnota atributu
<strong>question</strong> je nyní vrácena a je rovna <strong>null</strong>, což
je opět potenciálně velmi důležité.</div></p>

<p>Podobným způsobem lze použít i nástroj <strong>curl</strong>, samotná data
jsou v&nbsp;tomto případě uložena v&nbsp;souboru
<strong>data.json</strong>:</p>

<pre>
{
    "klic": "hodnota",
    "answer": 42,
    "question": null,
    "correct": true
}
</pre>

<p>Poslání dat společně se zobrazením odpovědi:</p>

<pre>
$ <strong>curl -X POST -v http://httpbin.org/post -d @data.json -H "Content-Type: application/json"</strong>
&nbsp;
*   Trying 3.220.112.94...
* TCP_NODELAY set
* Connected to httpbin.org (3.220.112.94) port 80 (#0)
&gt; POST /post HTTP/1.1
&gt; Host: httpbin.org
&gt; User-Agent: curl/7.55.1
&gt; Accept: */*
&gt; Content-Type: application/json
&gt; Content-Length: 81
&gt; 
* upload completely sent off: 81 out of 81 bytes
&lt; HTTP/1.1 200 OK
&lt; Date: Mon, 06 Jul 2020 09:56:07 GMT
&lt; Content-Type: application/json
&lt; Content-Length: 564
&lt; Connection: keep-alive
&lt; Server: gunicorn/19.9.0
&lt; Access-Control-Allow-Origin: *
&lt; Access-Control-Allow-Credentials: true
&lt; 
{
  "args": {}, 
  "data": "{    \"klic\": \"hodnota\",    \"answer\": 42,    \"question\": null,    \"correct\": true}", 
  "files": {}, 
  "form": {}, 
  "headers": {
    "Accept": "*/*", 
    "Content-Length": "81", 
    "Content-Type": "application/json", 
    "Host": "httpbin.org", 
    "User-Agent": "curl/7.55.1", 
    "X-Amzn-Trace-Id": "Root=1-5f02f537-4a20ddc8bee8dabcacb6787a"
  }, 
  "json": {
    "answer": 42, 
    "correct": true, 
    "klic": "hodnota", 
    "question": null
  }, 
  "origin": "37.48.9.246", 
  "url": "http://httpbin.org/post"
}
* Connection #0 to host httpbin.org left intact
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Vlastní jednoduchý testovací HTTP server</h2>

<p>Aby bylo možné zjistit, jak přesně vlastně vypadá požadavek posílaný
z&nbsp;klienta na server pomocí metody <strong>GET</strong> nebo
<strong>POST</strong>, vytvoříme si vlastní velmi jednoduchou implementaci HTTP
serveru založenou na existující (velmi užitečné) třídě
<strong>BaseHTTPRequestHandler</strong>. Ta samozřejmě nebude v&nbsp;žádném
případě určena pro produkční nasazení, protože například nijak neřeší HTTPS,
souběžné zpracování většího množství požadavků, zabezpečení, autorizaci,
kontrolu korektnosti požadavků atd. Server pouze velmi jednoduše zpracuje
všechny HTTP požadavky typu <strong>GET</strong> a <strong>POST</strong>;
klientovi přitom vrátí odpověď se stavem <strong>200 OK</strong> a
jednořádkovou (plain textovou) zprávou, která klienta pouze informuje o tom,
jakou HTTP metodu při volání serveru použil. Zcela základní implementace
serveru by tedy mohla vypadat následovně (bez importů, spuštění atd.):</p>

<pre>
class <strong>SimpleServer</strong>(BaseHTTPRequestHandler):
&nbsp;
    def <strong>do_GET</strong>(self):
        <i># priprava hlavicky odpovedi</i>
        self.send_response(200)
        self.send_header('Content-type', 'text/plain')
        self.end_headers()
&nbsp;
        <i># odpoved serveru klientovi</i>
        self.wfile.write("*** get ***".encode("utf-8"))
&nbsp;
    def <strong>do_POST</strong>(self):
        <i># priprava hlavicky odpovedi</i>
        self.send_response(200)
        self.send_header('Content-type', 'text/plain')
        self.end_headers()
&nbsp;
        <i># odpoved serveru klientovi</i>
        self.wfile.write("*** post ***".encode("utf-8"))
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Implementace HTTP serveru</h2>

<p>Ve skutečnosti bude implementace našeho testovacího serveru nepatrně
komplikovanější, protože budeme potřebovat, aby se u metody
<strong>POST</strong> získalo i tělo požadavku, které může obsahovat data
poslaná klientem. To se dá provést relativně jednoduše &ndash; nejprve zjistíme
délku obsahu (v&nbsp;bajtech) a posléze tento obsah načteme metodou
<strong>rfile.read()</strong>, které se předá délka těla požadavku:</p>

<pre>
content_length = int(self.headers['Content-Length'])
print("content length: {len}".format(len=content_length))
&nbsp;
content = self.rfile.read(content_length)
</pre>

<p>Následně může server tato data zobrazit ve svém terminálu či do logovacího
souboru, což je přesně to, co potřebujeme &ndash; získat nezpracovaný formát
požadavku vytvořený knihovnou <strong>Requests</strong>.</p>

<p>Úplná implementace <a
href="https://github.com/tisnik/testing-in-python/tree/master/requests/simple_server.py">našeho
HTTP serveru</a> je založena na zdrojovém kódu, který byl poslán na <a
href="https://gist.github.com/bradmontgomery/2219997">https://gist.github.com/bradmontgomery/2219997</a>,
ovšem provedl jsem v&nbsp;něm několik úprav a oprav. Výsledek je použitelný
s&nbsp;Pythonem 3.x:</p>

<pre>
<i>#!/usr/bin/python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i># Original (slightly buggy) code:</i>
<i># see https://gist.github.com/bradmontgomery/2219997</i>
&nbsp;
&nbsp;
import socket
from http.server import <strong>BaseHTTPRequestHandler</strong>, <strong>HTTPServer</strong>
&nbsp;
hostName = ""
hostPort = 8000
&nbsp;
&nbsp;
class <strong>SimpleServer</strong>(<strong>BaseHTTPRequestHandler</strong>):
&nbsp;
    def <strong>do_GET</strong>(self):
        <i># priprava hlavicky odpovedi</i>
        self.send_response(200)
        self.send_header('Content-type', 'text/plain')
        self.end_headers()
&nbsp;
        <i># odpoved serveru klientovi</i>
        self.wfile.write("*** get ***".encode("utf-8"))
&nbsp;
    def <strong>do_POST</strong>(self):
        print("URI: {uri}".format(uri=self.path))
&nbsp;
        <i># precteni tela HTTP pozadavku</i>
        content_length = int(self.headers['Content-Length'])
        print("content length: {len}".format(len=content_length))
&nbsp;
        content = self.rfile.read(content_length)
        print("content value:  {content}".format(content=content))
&nbsp;
        <i># priprava hlavicky odpovedi</i>
        self.send_response(200)
        self.send_header('Content-type', 'text/plain')
        self.end_headers()
&nbsp;
        <i># odpoved serveru klientovi</i>
        self.wfile.write("*** post ***".encode("utf-8"))
&nbsp;
&nbsp;
simpleServer = HTTPServer((hostName, hostPort), SimpleServer)
&nbsp;
try:
    simpleServer.serve_forever()
except KeyboardInterrupt:
    pass
&nbsp;
simpleServer.server_close()
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Požadavek poslaný na lokálně běžící HTTP server</h2>

<p>Výše popsaný HTTP server zavoláme celkem třikrát &ndash; jednou se použije
metoda <strong>GET</strong>, podruhé metoda <strong>POST</strong>
s&nbsp;předáním &bdquo;formulářových dat&ldquo; a nakonec se opět použije
metoda <strong>POST</strong>, ovšem tentokrát se data předají v&nbsp;těle
požadavku s&nbsp;využitím formátu JSON:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import <strong>requests</strong>
&nbsp;
<i># adresa lokalne beziciho serveru</i>
URL = "http://localhost:8000"
&nbsp;
<i># poslani HTTP dotazu typu GET</i>
response = <strong>requests.get(URL)</strong>
&nbsp;
<i># vypis zakladnich informaci ziskanych z odpovedi</i>
print(response)
print(response.status_code)
print(response.ok)
print(response.text)
&nbsp;
payload = {
    "klic": "hodnota",
    "answer": 42,
    "question": None,
    "correct": True}
&nbsp;
<i># poslani dat jako hodnot formulare</i>
response = <strong>requests.post(URL, data=payload)</strong>
&nbsp;
print(response.text)
&nbsp;
<i># poslani dat v tele dotazu</i>
response = <strong>requests.post(URL, json=payload)</strong>
&nbsp;
print(response.text)
</pre>

<p>Na konzoli, ze které spouštíme testovací skript, se vypíšou tyto údaje.
První čtyři řádky platí pro první volání <strong>GET</strong>, další dva pro
volání <strong>POST</strong>:</p>

<pre>
&lt;Response [200]&gt;
200
True
*** get ***
*** post ***
*** post ***
</pre>

<p>Na konzoli serveru (ovšem nikoli na konzoli, kde spouštíme testovací
skript!) by se měly vypsat následující řádky, z&nbsp;nichž je patrný jak formát
požadavku typu <strong>GET</strong>, tak i formát požadavku typu
<strong>POST</strong> při předávání údajů přes formulářová data a nakonec
formát požadavku předaného v&nbsp;těle (JSON):</p>

<pre>
127.0.0.1 - - [03/Aug/2018 13:57:57] "GET / HTTP/1.1" 200 -
URI: /
content length: 35
content value:  b'klic=hodnota&amp;answer=42&amp;correct=True'
127.0.0.1 - - [03/Aug/2018 13:57:57] "POST / HTTP/1.1" 200 -
URI: /
content length: 68
content value:  b'{"klic": "hodnota", "answer": 42, "question": null, "correct": true}'
127.0.0.1 - - [03/Aug/2018 13:57:57] "POST / HTTP/1.1" 200 -
</pre>

<p><div class="rs-tip-major">Poznámka: nic nám pochopitelně nebrání komunikovat
s&nbsp;naším serverem s&nbsp;využitím nástrojů <strong>curl</strong>,
<strong>telnet</strong> atd.:</div></p>

<pre>
$ <strong>curl -v localhost:8000</strong>
&nbsp;
* Rebuilt URL to: localhost:8000/
*   Trying ::1...
* TCP_NODELAY set
* connect to ::1 port 8000 failed: Connection refused
*   Trying 127.0.0.1...
* TCP_NODELAY set
* Connected to localhost (127.0.0.1) port 8000 (#0)
&gt; GET / HTTP/1.1
&gt; Host: localhost:8000
&gt; User-Agent: curl/7.55.1
&gt; Accept: */*
&gt; 
* HTTP 1.0, assume close after body
&lt; HTTP/1.0 200 OK
&lt; Server: BaseHTTP/0.6 Python/3.6.6
&lt; Date: Mon, 06 Jul 2020 10:05:25 GMT
&lt; Content-type: text/plain
&lt; 
* Closing connection 0
</pre>

<pre>
$ <strong>telnet localhost 8000</strong>
&nbsp;
Trying ::1...
telnet: connect to address ::1: Connection refused
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
GET /
&nbsp;
*** get ***
Connection closed by foreign host.
</pre>

<p><div class="rs-tip-major">Poznámka: při použití <strong>telnetu</strong> je
nutné za příkaz GET vložit jeden prázdný řádek (dvojí stlačení klávesy
Enter).</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
nového Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/testing-in-python">https://github.com/tisnik/testing-in-python</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem &ndash;
alespoň prozatím &ndash; velmi malý, dnes má přibližně několik desítek
kilobajtů), můžete namísto toho použít odkazy na jednotlivé demonstrační
příklady a jejich části, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_basic_usage.py</td><td>použití metody GET pro komunikaci s&nbsp;HTTP serverem</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/01_basic_usage.py">https://github.com/tisnik/testing-in-python/tree/master/requests/01_basic_usage.py</a></td></tr>
<tr><td> 2</td><td>02_check_status.py</td><td>kontrola stavového kódu odpovědi HTTP serveru</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/02_check_status.py">https://github.com/tisnik/testing-in-python/tree/master/requests/02_check_status.py</a></td></tr>
<tr><td> 3</td><td>02_any_status.py</td><td>kontrola stavového kódu odpovědi HTTP serveru</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/02_any_status.py">https://github.com/tisnik/testing-in-python/tree/master/requests/02_any_status.py</a></td></tr>
<tr><td> 4</td><td>03_content_type.py</td><td>získání typu/formátu odpovědi serveru</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/03_content_type.py">https://github.com/tisnik/testing-in-python/tree/master/requests/03_content_type.py</a></td></tr>
<tr><td> 5</td><td>03_other_content_types.py</td><td>získání typu/formátu odpovědi serveru</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/03_other_content_types.py">https://github.com/tisnik/testing-in-python/tree/master/requests/03_other_content_types.py</a></td></tr>
<tr><td> 6</td><td>04_response_content.py</td><td>získání obsahu odpovědi serveru</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/04_response_content.py">https://github.com/tisnik/testing-in-python/tree/master/requests/04_response_content.py</a></td></tr>
<tr><td> 7</td><td>05_response_content_and_headers.py</td><td>získání obsahu odpovědi serveru včetně hlaviček HTTP protokolu</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/05_response_content_and_headers.py">https://github.com/tisnik/testing-in-python/tree/master/requests/05_response_content_and_headers.py</a></td></tr>
<tr><td> 8</td><td>06_response_json.py</td><td>práce s&nbsp;odpovědí ve formátu JSON</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/06_response_json.py">https://github.com/tisnik/testing-in-python/tree/master/requests/06_response_json.py</a></td></tr>
<tr><td> 9</td><td>07_post_method.py</td><td>použití metody POST pro komunikaci se serverem</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/07_post_method.py">https://github.com/tisnik/testing-in-python/tree/master/requests/07_post_method.py</a></td></tr>
<tr><td>10</td><td>08_post_method_with_payload.py</td><td>metoda POST a data poslaná ve formuláři</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/08_post_method_with_payload.py">https://github.com/tisnik/testing-in-python/tree/master/requests/08_post_method_with_payload.py</a></td></tr>
<tr><td>11</td><td>09_post_method_with_payload.py</td><td>metoda POST a data poslaná v&nbsp;těle zprávy</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/09_post_method_with_payload.py">https://github.com/tisnik/testing-in-python/tree/master/requests/09_post_method_with_payload.py</a></td></tr>
<tr><td>12</td><td>10_against_test_local_server.py</td><td>test metod GET a POST vůči lokálnímu serveru</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/10_against_test_local_server.py">https://github.com/tisnik/testing-in-python/tree/master/requests/10_against_test_local_server.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>simple_server.py</td><td>velmi jednoduchý lokální HTTP server</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/simple_server.py">https://github.com/tisnik/testing-in-python/tree/master/requests/simple_server.py</a></td></tr>
<tr><td>14</td><td>simple_server_2.py</td><td>druhá varianta HTTP serveru</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/requests/simple_server_2.py">https://github.com/tisnik/testing-in-python/tree/master/requests/simple_server_2.py</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články s&nbsp;tématem testování (nejenom) v&nbsp;Pythonu</h2>

<p>Tématem testování jsme se již na stránkách Rootu několikrát zabývali. Jedná
se mj.&nbsp;o následující články:</p>

<ol>

<li>Requests: HTTP for Humans (dokumentace)<br />
<a href="http://docs.python-requests.org/en/master/">http://docs.python-requests.org/en/master/</a>
</li>

<li>Requests: Introduction<br />
<a href="http://docs.python-requests.org/en/latest/user/intro/">http://docs.python-requests.org/en/latest/user/intro/</a>
</li>

<li>Requests na GitHubu<br />
<a href="https://github.com/requests/requests">https://github.com/requests/requests</a>
</li>

<li>Requests (software) na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Requests_%28software%29">https://en.wikipedia.org/wiki/Requests_%28software%29</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>20 Python libraries you can’t live without<br />
<a href="https://pythontips.com/2013/07/30/20-python-libraries-you-cant-live-without/">https://pythontips.com/2013/07/30/20-python-libraries-you-cant-live-without/</a>
</li>

<li>What are the top 10 most useful and influential Python libraries and frameworks?<br />
<a href="https://www.quora.com/What-are-the-top-10-most-useful-and-influential-Python-libraries-and-frameworks">https://www.quora.com/What-are-the-top-10-most-useful-and-influential-Python-libraries-and-frameworks</a>
</li>

<li>Python: useful modules<br />
<a href="https://wiki.python.org/moin/UsefulModules">https://wiki.python.org/moin/UsefulModules</a>
</li>

<li>Top 15 most popular Python libraries<br />
<a href="https://keyua.org/blog/most-popular-python-libraries/">https://keyua.org/blog/most-popular-python-libraries/</a>
</li>

<li>Hypertext Transfer Protocol<br />
<a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a>
</li>

<li>List of HTTP header fields<br />
<a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">https://en.wikipedia.org/wiki/List_of_HTTP_header_fields</a>
</li>

<li>List of HTTP status codes<br />
<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">https://en.wikipedia.org/wiki/List_of_HTTP_status_codes</a>
</li>

<li>Python requests deep dive<br />
<a href="https://medium.com/@anthonypjshaw/python-requests-deep-dive-a0a5c5c1e093">https://medium.com/@anthonypjshaw/python-requests-deep-dive-a0a5c5c1e093</a>
</li>

<li>The awesome requests module<br />
<a href="https://www.pythonforbeginners.com/requests/the-awesome-requests-module">https://www.pythonforbeginners.com/requests/the-awesome-requests-module</a>
</li>

<li>Send HTTP Requests in Python<br />
<a href="https://code-maven.com/http-requests-in-python">https://code-maven.com/http-requests-in-python</a>
</li>

<li>Introducing JSON<br />
<a href="http://json.org/">http://json.org/</a>
</li>

<li>Použití Pythonu pro tvorbu testů: od jednotkových testů až po testy UI<br />
<a href="https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-od-jednotkovych-testu-az-po-testy-ui/">https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-od-jednotkovych-testu-az-po-testy-ui/</a>
</li>

<li>Použití Pythonu pro tvorbu testů: použití třídy Mock z knihovny unittest.mock<br />
<a href="https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-pouziti-tridy-mock-z-knihovny-unittest-mock/">https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-pouziti-tridy-mock-z-knihovny-unittest-mock/</a>
</li>

<li>Použití nástroje pytest pro tvorbu jednotkových testů a benchmarků<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-pytest-pro-tvorbu-jednotkovych-testu-a-benchmarku/">https://www.root.cz/clanky/pouziti-nastroje-pytest-pro-tvorbu-jednotkovych-testu-a-benchmarku/</a>
</li>

<li>Nástroj pytest a jednotkové testy: fixtures, výjimky, parametrizace testů<br />
<a href="https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-fixtures-vyjimky-parametrizace-testu/">https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-fixtures-vyjimky-parametrizace-testu/</a>
</li>

<li>Nástroj pytest a jednotkové testy: životní cyklus testů, užitečné tipy a triky<br />
<a href="https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-zivotni-cyklus-testu-uzitecne-tipy-a-triky/">https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-zivotni-cyklus-testu-uzitecne-tipy-a-triky/</a>
</li>

<li>Struktura projektů s jednotkovými testy, využití Travis CI<br />
<a href="https://www.root.cz/clanky/struktura-projektu-s-jednotkovymi-testy-vyuziti-travis-ci/">https://www.root.cz/clanky/struktura-projektu-s-jednotkovymi-testy-vyuziti-travis-ci/</a>
</li>

<li>Omezení stavového prostoru testovaných funkcí a metod<br />
<a href="https://www.root.cz/clanky/omezeni-stavoveho-prostoru-testovanych-funkci-a-metod/">https://www.root.cz/clanky/omezeni-stavoveho-prostoru-testovanych-funkci-a-metod/</a>
</li>

<li>Testování aplikací s využitím nástroje Hypothesis<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-s-vyuzitim-nastroje-hypothesis/">https://www.root.cz/clanky/testovani-aplikaci-s-vyuzitim-nastroje-hypothesis/</a>
</li>

<li>Testování aplikací s využitím nástroje Hypothesis (dokončení)<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-s-vyuzitim-nastroje-hypothesis-dokonceni/">https://www.root.cz/clanky/testovani-aplikaci-s-vyuzitim-nastroje-hypothesis-dokonceni/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave (druhá část)<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-druha-cast/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-druha-cast/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave (závěrečná část)<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-zaverecna-cast/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-zaverecna-cast/</a>
</li>

<li>Validace datových struktur v Pythonu pomocí knihoven Schemagic a Schema<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/</a>
</li>

<li>Validace datových struktur v Pythonu (2. část)<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-2-cast/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-2-cast/</a>
</li>

<li>Validace datových struktur v Pythonu (dokončení)<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-dokonceni/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-dokonceni/</a>
</li>

<li>Univerzální testovací nástroj Robot Framework<br />
<a href="https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework/">https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework/</a>
</li>

<li>Univerzální testovací nástroj Robot Framework a BDD testy<br />
<a href="https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework-a-bdd-testy/">https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework-a-bdd-testy/</a>
</li>

<li>Úvod do problematiky fuzzingu a fuzz testování<br />
<a href="https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani/">https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani/</a>
</li>

<li>Úvod do problematiky fuzzingu a fuzz testování – složení vlastního fuzzeru<br />
<a href="https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani-slozeni-vlastniho-fuzzeru/">https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani-slozeni-vlastniho-fuzzeru/</a>
</li>

<li>Knihovny a moduly usnadňující testování aplikací naprogramovaných v jazyce Clojure<br />
<a href="https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/">https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/</a>
</li>

<li>Validace dat s využitím knihovny spec v Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

<li>Testování aplikací naprogramovaných v jazyce Go<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/">https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/</a>
</li>

<li>Knihovny určené pro tvorbu testů v programovacím jazyce Go<br />
<a href="https://www.root.cz/clanky/knihovny-urcene-pro-tvorbu-testu-v-programovacim-jazyce-go/">https://www.root.cz/clanky/knihovny-urcene-pro-tvorbu-testu-v-programovacim-jazyce-go/</a>
</li>

<li>Testování aplikací psaných v Go s využitím knihoven Goblin a Frisby<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/">https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/</a>
</li>

<li>Testování Go aplikací s využitím knihovny GΩmega a frameworku Ginkgo<br />
<a href="https://www.root.cz/clanky/testovani-go-aplikaci-s-vyuzitim-knihovny-gomega-mega-a-frameworku-ginkgo/">https://www.root.cz/clanky/testovani-go-aplikaci-s-vyuzitim-knihovny-gomega-mega-a-frameworku-ginkgo/</a>
</li>

<li>Tvorba BDD testů s využitím jazyka Go a nástroje godog<br />
<a href="https://www.root.cz/clanky/tvorba-bdd-testu-s-vyuzitim-jazyka-go-a-nastroje-godog/">https://www.root.cz/clanky/tvorba-bdd-testu-s-vyuzitim-jazyka-go-a-nastroje-godog/</a>
</li>

<li>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem<br />
<a href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/">https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/</a>
</li>

<li>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem (dokončení)<br />
<a href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem-dokonceni/">https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem-dokonceni/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure (2)<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Writing tests for RESTful APIs in Python using requests – part 1: basic tests<br />
<a href="https://www.ontestautomation.com/writing-tests-for-restful-apis-in-python-using-requests-part-1-basic-tests/">https://www.ontestautomation.com/writing-tests-for-restful-apis-in-python-using-requests-part-1-basic-tests/</a>
</li>

<li>Step by Step Rest API Testing using Python + Pytest + Allure<br />
<a href="https://www.udemy.com/course/api-testing-python/">https://www.udemy.com/course/api-testing-python/</a>
</li>

<li>Prime formulas and polynomial functions<br />
<a href="https://en.wikipedia.org/wiki/Formula_for_primes#Prime_formulas_and_polynomial_functions">https://en.wikipedia.org/wiki/Formula_for_primes#Prime_formulas_and_polynomial_functions</a>
</li>

<li>Prime-Generating Polynomial<br />
<a href="https://mathworld.wolfram.com/Prime-GeneratingPolynomial.html">https://mathworld.wolfram.com/Prime-GeneratingPolynomial.html</a>
</li>

<li>Hoare logic<br />
<a href="https://en.wikipedia.org/wiki/Hoare_logic">https://en.wikipedia.org/wiki/Hoare_logic</a>
</li>

<li>Goto Fail, Heartbleed, and Unit Testing Culture<br />
<a href="https://martinfowler.com/articles/testing-culture.html">https://martinfowler.com/articles/testing-culture.html</a>
</li>

<li>PEP-484<br />
<a href="https://www.python.org/dev/peps/pep-0484/">https://www.python.org/dev/peps/pep-0484/</a>
</li>

<li>In-depth: Functional programming in C++<br />
<a href="https://www.gamasutra.com/view/news/169296/Indepth_Functional_programming_in_C.php">https://www.gamasutra.com/view/news/169296/Indepth_Functional_programming_in_C.php</a>
</li>

<li>mypy<br />
<a href="http://www.mypy-lang.org/">http://www.mypy-lang.org/</a>
</li>

<li>Welcome to Mypy documentation!<br />
<a href="https://mypy.readthedocs.io/en/latest/index.html">https://mypy.readthedocs.io/en/latest/index.html</a>
</li>

<li>mypy na GitHubu<br />
<a href="https://github.com/python/mypy">https://github.com/python/mypy</a>
</li>

<li>mypy 0.770 na PyPi<br />
<a href="https://pypi.org/project/mypy/">https://pypi.org/project/mypy/</a>
</li>

<li>Extensions for mypy (separated out from mypy/extensions)<br />
<a href="https://github.com/python/mypy_extensions">https://github.com/python/mypy_extensions</a>
</li>

<li>The Mypy Blog<br />
<a href="https://mypy-lang.blogspot.com/2020/03/mypy-0770-released.html">https://mypy-lang.blogspot.com/2020/03/mypy-0770-released.html</a>
</li>

<li>Our journey to type checking 4 million lines of Python<br />
<a href="https://dropbox.tech/application/our-journey-to-type-checking-4-million-lines-of-python">https://dropbox.tech/application/our-journey-to-type-checking-4-million-lines-of-python</a>
</li>

<li>Type-Checking Python Programs With Type Hints and mypy<br />
<a href="https://www.youtube.com/watch?v=2xWhaALHTvU">https://www.youtube.com/watch?v=2xWhaALHTvU</a>
</li>

<li>Refactoring to Immutability - Kevlin Henney<br />
<a href="https://www.youtube.com/watch?v=APUCMSPiNh4">https://www.youtube.com/watch?v=APUCMSPiNh4</a>
</li>

<li>Bernat Gabor - Type hinting (and mypy) - PyCon 2019<br />
<a href="https://www.youtube.com/watch?v=hTrjTAPnA_k">https://www.youtube.com/watch?v=hTrjTAPnA_k</a>
</li>

<li>Stanford Seminar - Optional Static Typing for Python<br />
<a href="https://www.youtube.com/watch?v=GiZKuyLKvAA">https://www.youtube.com/watch?v=GiZKuyLKvAA</a>
</li>

<li>mypy Getting to Four Million Lines of Typed Python - Michael Sullivan<br />
<a href="https://www.youtube.com/watch?v=FT_WHV4-QcU">https://www.youtube.com/watch?v=FT_WHV4-QcU</a>
</li>

<li>Shebang<br />
<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">https://en.wikipedia.org/wiki/Shebang_(Unix)</a>
</li>

<li>pytest 5.4.2 na PyPi<br />
<a href="https://pypi.org/project/pytest/">https://pypi.org/project/pytest/</a>
</li>

<li>Hillel Wayne - Beyond Unit Tests: Taking Your Testing to the Next Level - PyCon 2018<br />
<a href="https://www.youtube.com/watch?v=MYucYon2-lk">https://www.youtube.com/watch?v=MYucYon2-lk</a>
</li>

<li>Awesome Python &ndash; testing<br />
<a href="https://github.com/vinta/awesome-python#testing">https://github.com/vinta/awesome-python#testing</a>
</li>

<li>pytest Plugins Compatibility<br />
<a href="http://plugincompat.herokuapp.com/">http://plugincompat.herokuapp.com/</a>
</li>

<li>Selenium (pro Python)<br />
<a href="https://pypi.org/project/selenium/">https://pypi.org/project/selenium/</a>
</li>

<li>Getting Started With Testing in Python<br />
<a href="https://realpython.com/python-testing/">https://realpython.com/python-testing/</a>
</li>

<li>unittest.mock — mock object library<br />
<a href="https://docs.python.org/3.5/library/unittest.mock.html">https://docs.python.org/3.5/library/unittest.mock.html</a>
</li>

<li>mock 2.0.0<br />
<a href="https://pypi.python.org/pypi/mock">https://pypi.python.org/pypi/mock</a>
</li>

<li>An Introduction to Mocking in Python<br />
<a href="https://www.toptal.com/python/an-introduction-to-mocking-in-python">https://www.toptal.com/python/an-introduction-to-mocking-in-python</a>
</li>

<li>Mock - Mocking and Testing Library<br />
<a href="http://mock.readthedocs.io/en/stable/">http://mock.readthedocs.io/en/stable/</a>
</li>

<li>Python Mocking 101: Fake It Before You Make It<br />
<a href="https://blog.fugue.co/2016-02-11-python-mocking-101.html">https://blog.fugue.co/2016-02-11-python-mocking-101.html</a>
</li>

<li>Nauč se Python! - Testování<br />
<a href="http://naucse.python.cz/lessons/intro/testing/">http://naucse.python.cz/lessons/intro/testing/</a>
</li>

<li>Flexmock (dokumentace)<br />
<a href="https://flexmock.readthedocs.io/en/latest/">https://flexmock.readthedocs.io/en/latest/</a>
</li>

<li>Test Fixture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test_fixture">https://en.wikipedia.org/wiki/Test_fixture</a>
</li>

<li>Mock object (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Mock_object">https://en.wikipedia.org/wiki/Mock_object</a>
</li>

<li>Extrémní programování<br />
<a href="https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD">https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD</a>
</li>

<li>Programování řízené testy<br />
<a href="https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy">https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>Tox<br />
<a href="https://tox.readthedocs.io/en/latest/">https://tox.readthedocs.io/en/latest/</a>
</li>

<li>pytest: helps you write better programs<br />
<a href="https://docs.pytest.org/en/latest/">https://docs.pytest.org/en/latest/</a>
</li>

<li>doctest — Test interactive Python examples<br />
<a href="https://docs.python.org/dev/library/doctest.html#module-doctest">https://docs.python.org/dev/library/doctest.html#module-doctest</a>
</li>

<li>unittest — Unit testing framework<br />
<a href="https://docs.python.org/dev/library/unittest.html">https://docs.python.org/dev/library/unittest.html</a>
</li>

<li>Python namespaces<br />
<a href="https://bytebaker.com/2008/07/30/python-namespaces/">https://bytebaker.com/2008/07/30/python-namespaces/</a>
</li>

<li>Namespaces and Scopes<br />
<a href="https://www.python-course.eu/namespaces.php">https://www.python-course.eu/namespaces.php</a>
</li>

<li>Stránka projektu Robot Framework<br />
<a href="https://robotframework.org/">https://robotframework.org/</a>
</li>

<li>GitHub repositář Robot Frameworku<br />
<a href="https://github.com/robotframework/robotframework">https://github.com/robotframework/robotframework</a>
</li>

<li>Robot Framework (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Robot_Framework">https://en.wikipedia.org/wiki/Robot_Framework</a>
</li>

<li>Tutoriál Robot Frameworku<br />
<a href="http://www.robotframeworktutorial.com/">http://www.robotframeworktutorial.com/</a>
</li>

<li>Robot Framework Documentation<br />
<a href="https://robotframework.org/robotframework/">https://robotframework.org/robotframework/</a>
</li>

<li>Robot Framework Introduction<br />
<a href="https://blog.testproject.io/2016/11/22/robot-framework-introduction/">https://blog.testproject.io/2016/11/22/robot-framework-introduction/</a>
</li>

<li>robotframework 3.1.2 na PyPi<br />
<a href="https://pypi.org/project/robotframework/">https://pypi.org/project/robotframework/</a>
</li>

<li>Robot Framework demo (GitHub)<br />
<a href="https://github.com/robotframework/RobotDemo">https://github.com/robotframework/RobotDemo</a>
</li>

<li>Robot Framework web testing demo using SeleniumLibrary<br />
<a href="https://github.com/robotframework/WebDemo">https://github.com/robotframework/WebDemo</a>
</li>

<li>Robot Framework for Mobile Test Automation Demo<br />
<a href="https://www.youtube.com/watch?v=06LsU08slP8">https://www.youtube.com/watch?v=06LsU08slP8</a>
</li>

<li>Gherkin<br />
<a href="https://cucumber.io/docs/gherkin/">https://cucumber.io/docs/gherkin/</a>
</li>

<li>Selenium<br />
<a href="https://selenium.dev/">https://selenium.dev/</a>
</li>

<li>SeleniumLibrary<br />
<a href="https://robotframework.org/">https://robotframework.org/</a>
</li>

<li>The Practical Test Pyramid<br />
<a href="https://martinfowler.com/articles/practical-test-pyramid.html">https://martinfowler.com/articles/practical-test-pyramid.html</a>
</li>

<li>Acceptance Tests and the Testing Pyramid<br />
<a href="http://www.blog.acceptancetestdrivendevelopment.com/acceptance-tests-and-the-testing-pyramid/">http://www.blog.acceptancetestdrivendevelopment.com/acceptance-tests-and-the-testing-pyramid/</a>
</li>

<li>Tab-separated values<br />
<a href="https://en.wikipedia.org/wiki/Tab-separated_values">https://en.wikipedia.org/wiki/Tab-separated_values</a>
</li>

<li>A quick guide about Python implementations<br />
<a href="https://blog.rmotr.com/a-quick-guide-about-python-implementations-aa224109f321">https://blog.rmotr.com/a-quick-guide-about-python-implementations-aa224109f321</a>
</li>

<li>radamsa<br />
<a href="https://gitlab.com/akihe/radamsa">https://gitlab.com/akihe/radamsa</a>
</li>

<li>Fuzzing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Fuzzing">https://en.wikipedia.org/wiki/Fuzzing</a>
</li>

<li>american fuzzy lop<br />
<a href="http://lcamtuf.coredump.cx/afl/">http://lcamtuf.coredump.cx/afl/</a>
</li>

<li>Fuzzing: the new unit testing<br />
<a href="https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide#1">https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide#1</a>
</li>

<li>Corpus for github.com/dvyukov/go-fuzz examples<br />
<a href="https://github.com/dvyukov/go-fuzz-corpus">https://github.com/dvyukov/go-fuzz-corpus</a>
</li>

<li>AFL &ndash; QuickStartGuide.txt<br />
<a href="https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt">https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt</a>
</li>

<li>Introduction to Fuzzing in Python with AFL<br />
<a href="https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/">https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/</a>
</li>

<li>Writing a Simple Fuzzer in Python<br />
<a href="https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/">https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/</a>
</li>

<li>How to Fuzz Go Code with go-fuzz (Continuously)<br />
<a href="https://fuzzit.dev/2019/10/02/how-to-fuzz-go-code-with-go-fuzz-continuously/">https://fuzzit.dev/2019/10/02/how-to-fuzz-go-code-with-go-fuzz-continuously/</a>
</li>

<li>Golang Fuzzing: A go-fuzz Tutorial and Example<br />
<a href="http://networkbit.ch/golang-fuzzing/">http://networkbit.ch/golang-fuzzing/</a>
</li>

<li>Fuzzing Python Modules<br />
<a href="https://stackoverflow.com/questions/20749026/fuzzing-python-modules">https://stackoverflow.com/questions/20749026/fuzzing-python-modules</a>
</li>

<li>0x3 Python Tutorial: Fuzzer<br />
<a href="http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/">http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/</a>
</li>

<li>fuzzing na PyPi<br />
<a href="https://pypi.org/project/fuzzing/">https://pypi.org/project/fuzzing/</a>
</li>

<li>Fuzzing 0.3.2 documentation<br />
<a href="https://fuzzing.readthedocs.io/en/latest/">https://fuzzing.readthedocs.io/en/latest/</a>
</li>

<li>Randomized testing for Go<br />
<a href="https://github.com/dvyukov/go-fuzz">https://github.com/dvyukov/go-fuzz</a>
</li>

<li>HTTP/2 fuzzer written in Golang<br />
<a href="https://github.com/c0nrad/http2fuzz">https://github.com/c0nrad/http2fuzz</a>
</li>

<li>Ffuf (Fuzz Faster U Fool) – An Open Source Fast Web Fuzzing Tool<br />
<a href="https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html">https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html</a>
</li>

<li>Continuous Fuzzing Made Simple<br />
<a href="https://fuzzit.dev/">https://fuzzit.dev/</a>
</li>

<li>Halt and Catch Fire<br />
<a href="https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86">https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86</a>
</li>

<li>Random testing<br />
<a href="https://en.wikipedia.org/wiki/Random_testing">https://en.wikipedia.org/wiki/Random_testing</a>
</li>

<li>Monkey testing<br />
<a href="https://en.wikipedia.org/wiki/Monkey_testing">https://en.wikipedia.org/wiki/Monkey_testing</a>
</li>

<li>Fuzzing for Software Security Testing and Quality Assurance, Second Edition<br />
<a href="https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false">https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false</a>
</li>

<li>libFuzzer – a library for coverage-guided fuzz testing<br />
<a href="https://llvm.org/docs/LibFuzzer.html">https://llvm.org/docs/LibFuzzer.html</a>
</li>

<li>fuzzy-swagger na PyPi<br />
<a href="https://pypi.org/project/fuzzy-swagger/">https://pypi.org/project/fuzzy-swagger/</a>
</li>

<li>fuzzy-swagger na GitHubu<br />
<a href="https://github.com/namuan/fuzzy-swagger">https://github.com/namuan/fuzzy-swagger</a>
</li>

<li>Fuzz testing tools for Python<br />
<a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy#Fuzz_Testing_Tools">https://wiki.python.org/moin/PythonTestingToolsTaxonomy#Fuzz_Testing_Tools</a>
</li>

<li>A curated list of awesome Go frameworks, libraries and software<br />
<a href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go</a>
</li>

<li>gofuzz: a library for populating go objects with random values<br />
<a href="https://github.com/google/gofuzz">https://github.com/google/gofuzz</a>
</li>

<li>tavor: A generic fuzzing and delta-debugging framework<br />
<a href="https://github.com/zimmski/tavor">https://github.com/zimmski/tavor</a>
</li>

<li>hypothesis na GitHubu<br />
<a href="https://github.com/HypothesisWorks/hypothesis">https://github.com/HypothesisWorks/hypothesis</a>
</li>

<li>Hypothesis: Test faster, fix more<br />
<a href="https://hypothesis.works/">https://hypothesis.works/</a>
</li>

<li>Hypothesis<br />
<a href="https://hypothesis.works/articles/intro/">https://hypothesis.works/articles/intro/</a>
</li>

<li>What is Hypothesis?<br />
<a href="https://hypothesis.works/articles/what-is-hypothesis/">https://hypothesis.works/articles/what-is-hypothesis/</a>
</li>

<li>What is Property Based Testing?<br />
<a href="https://hypothesis.works/articles/what-is-property-based-testing/">https://hypothesis.works/articles/what-is-property-based-testing/</a>
</li>

<li>Databáze CVE<br />
<a href="https://www.cvedetails.com/">https://www.cvedetails.com/</a>
</li>

<li>Fuzz test Python modules with libFuzzer<br />
<a href="https://github.com/eerimoq/pyfuzzer">https://github.com/eerimoq/pyfuzzer</a>
</li>

<li>Taof - The art of fuzzing<br />
<a href="https://sourceforge.net/projects/taof/">https://sourceforge.net/projects/taof/</a>
</li>

<li>JQF + Zest: Coverage-guided semantic fuzzing for Java<br />
<a href="https://github.com/rohanpadhye/jqf">https://github.com/rohanpadhye/jqf</a>
</li>

<li>http2fuzz<br />
<a href="https://github.com/c0nrad/http2fuzz">https://github.com/c0nrad/http2fuzz</a>
</li>

<li>Demystifying hypothesis testing with simple Python examples<br />
<a href="https://towardsdatascience.com/demystifying-hypothesis-testing-with-simple-python-examples-4997ad3c5294">https://towardsdatascience.com/demystifying-hypothesis-testing-with-simple-python-examples-4997ad3c5294</a>
</li>

<li>Testování<br />
<a href="http://voho.eu/wiki/testovani/">http://voho.eu/wiki/testovani/</a>
</li>

<li>Unit testing (Wikipedia.en)<br />
<a href="https://en.wikipedia.org/wiki/Unit_testing">https://en.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit testing (Wikipedia.cz)<br />
<a href="https://cs.wikipedia.org/wiki/Unit_testing">https://cs.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit Test vs Integration Test<br />
<a href="https://www.youtube.com/watch?v=0GypdsJulKE">https://www.youtube.com/watch?v=0GypdsJulKE</a>
</li>

<li>TestDouble<br />
<a href="https://martinfowler.com/bliki/TestDouble.html">https://martinfowler.com/bliki/TestDouble.html</a>
</li>

<li>Test Double<br />
<a href="http://xunitpatterns.com/Test%20Double.html">http://xunitpatterns.com/Test%20Double.html</a>
</li>

<li>Test-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test-driven_development">https://en.wikipedia.org/wiki/Test-driven_development</a>
</li>

<li>Acceptance test–driven development<br />
<a href="https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development">https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development</a>
</li>

<li>Gauge<br />
<a href="https://gauge.org/">https://gauge.org/</a>
</li>

<li>Gauge (software)<br />
<a href="https://en.wikipedia.org/wiki/Gauge_(software)">https://en.wikipedia.org/wiki/Gauge_(software)</a>
</li>

<li>PYPL PopularitY of Programming Language<br />
<a href="https://pypl.github.io/PYPL.html">https://pypl.github.io/PYPL.html</a>
</li>

<li>Testing is Good. Pyramids are Bad. Ice Cream Cones are the Worst<br />
<a href="https://medium.com/@fistsOfReason/testing-is-good-pyramids-are-bad-ice-cream-cones-are-the-worst-ad94b9b2f05f">https://medium.com/@fistsOfReason/testing-is-good-pyramids-are-bad-ice-cream-cones-are-the-worst-ad94b9b2f05f</a>
</li>

<li>Články a zprávičky věnující se Pythonu<br />
<a href="https://www.root.cz/n/python/">https://www.root.cz/n/python/</a>
</li>

<li>PythonTestingToolsTaxonomy<br />
<a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy">https://wiki.python.org/moin/PythonTestingToolsTaxonomy</a>
</li>

<li>Top 6 BEST Python Testing Frameworks [Updated 2020 List]<br />
<a href="https://www.softwaretestinghelp.com/python-testing-frameworks/">https://www.softwaretestinghelp.com/python-testing-frameworks/</a>
</li>

<li>pytest-print 0.1.3<br />
<a href="https://pypi.org/project/pytest-print/">https://pypi.org/project/pytest-print/</a>
</li>

<li>pytest fixtures: explicit, modular, scalable<br />
<a href="https://docs.pytest.org/en/latest/fixture.html">https://docs.pytest.org/en/latest/fixture.html</a>
</li>

<li>PyTest Tutorial: What is, Install, Fixture, Assertions<br />
<a href="https://www.guru99.com/pytest-tutorial.html">https://www.guru99.com/pytest-tutorial.html</a>
</li>

<li>Pytest - Fixtures<br />
<a href="https://www.tutorialspoint.com/pytest/pytest_fixtures.htm">https://www.tutorialspoint.com/pytest/pytest_fixtures.htm</a>
</li>

<li>Marking test functions with attributes<br />
<a href="https://docs.pytest.org/en/latest/mark.html">https://docs.pytest.org/en/latest/mark.html</a>
</li>

<li>pytest-print<br />
<a href="https://pytest-print.readthedocs.io/en/latest/">https://pytest-print.readthedocs.io/en/latest/</a>
</li>

<li>Continuous integration<br />
<a href="https://en.wikipedia.org/wiki/Continuous_integration">https://en.wikipedia.org/wiki/Continuous_integration</a>
</li>

<li>Travis CI<br />
<a href="https://travis-ci.org/">https://travis-ci.org/</a>
</li>

<li>Mutation testing<br />
<a href="https://en.wikipedia.org/wiki/Mutation_testing">https://en.wikipedia.org/wiki/Mutation_testing</a>
</li>

<li>Články o Hypothesis<br />
<a href="https://news.ycombinator.com/from?site=hypothesis.works">https://news.ycombinator.com/from?site=hypothesis.works</a>
</li>

<li>Testovací případ<br />
<a href="https://cs.wikipedia.org/wiki/Testovac%C3%AD_p%C5%99%C3%ADpad">https://cs.wikipedia.org/wiki/Testovac%C3%AD_p%C5%99%C3%ADpad</a>
</li>

<li>Most testing is ineffective<br />
<a href="https://hypothesis.works/">https://hypothesis.works/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

