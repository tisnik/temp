<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Testování nativních funkcí s využitím programovacího jazyka Python</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Testování nativních funkcí s využitím programovacího jazyka Python</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešní části seriálu o testování aplikací s využitím programovacího jazyka Python se budeme zabývat možná poněkud méně známým tématem. Bude se jednat o testování nativních funkcí (či celých nativních knihoven nebo dokonce aplikací) s využitím Pythonu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Testování nativních funkcí s&nbsp;využitím programovacího jazyka Python</a></p>
<p><a href="#k02">2. Zdrojový kód funkce, která se má přeložit do dynamické knihovny</a></p>
<p><a href="#k03">3. Zdrojový kód Pythonovského skriptu, který má dynamickou knihovnu využít</a></p>
<p><a href="#k04">4. Překlad projektu a pokus o zavolání nativní funkce z&nbsp;dynamické knihovny</a></p>
<p><a href="#k05">5. Malá úprava demonstračního příkladu &ndash; obalení nativní funkce Pythonovským kódem</a></p>
<p><a href="#k06">6. Jednotkové testy naprogramované v&nbsp;Pythonu, které volají a testují nativní funkci</a></p>
<p><a href="#k07">7. Spuštění jednotkových testů</a></p>
<p><a href="#k08">8. Rozdíly mezi datovými typy jazyka C a Pythonu</a></p>
<p><a href="#k09">9. Přetečení při operacích s&nbsp;celými čísly v&nbsp;C</a></p>
<p><a href="#k10">10. Jednoduchý test volající funkce ze standardní knihovny jazyka C</a></p>
<p><a href="#k11">11. Volání céčkových funkcí akceptujících odlišné typy argumentů</a></p>
<p><a href="#k12">12. Práce s&nbsp;datovými strukturami</a></p>
<p><a href="#k13">13. Porovnání komplexních čísel</a></p>
<p><a href="#k14">14. Rozšíření knihovny pro práci s&nbsp;komplexními čísly</a></p>
<p><a href="#k15">15. Nativní knihovny a behavior-driven testing založený na použití knihovny Behave</a></p>
<p><a href="#k16">16. Projekt, v&nbsp;němž budeme testovat vlastnosti nativní funkce</a></p>
<p><a href="#k17">17. Modifikace testovacího scénáře &ndash; určení typů parametrů předávaných nativní funkci</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Předchozí články s&nbsp;tématem testování (nejenom) v&nbsp;Pythonu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Testování nativních funkcí s&nbsp;využitím programovacího jazyka Python</h2>

<p>V&nbsp;dnešní části seriálu o testování aplikací s&nbsp;využitím <a
href="https://www.root.cz/n/python/">programovacího jazyka Python</a> se budeme
zabývat možná poněkud méně známým tématem. Bude se jednat o testování nativních
funkcí (či celých nativních knihoven nebo dokonce aplikací) s&nbsp;využitím
Pythonu. Dnes použité demonstrační příklady, resp.&nbsp;přesněji řečeno jejich
část, která má být překládána do nativního (strojového) kódu, budou psány
v&nbsp;programovacím jazyku C. Propojíme tak céčko (což je stále
nejpopulárnější nízkoúrovňový jazyk) s&nbsp;dnes pravděpodobně nejpopulárnějším
vysokoúrovňovým programovacím jazykem současnosti. Ovšem stejně dobře lze
použít i další překládané jazyky, zejména <i>Rust</i> a <i>C++</i> &ndash;
ovšem u obou těchto jazyků je nutné zakázat <i>name mangling</i>, tedy
&bdquo;dekorování&ldquo; jmen symbolů ve vytvářených objektových souborech i
staticky či dynamicky linkovaných knihovnách.</p>

<p>Na straně Pythonu lze pro volání nativních funkcí použít například
standardní modul <a
href="https://docs.python.org/3.3/library/ctypes.html">ctypes</a> nebo sice
méně známý, ale o to povedenější modul pojmenovaný <a
href="https://cffi.readthedocs.io/en/latest/">CFFI</a>. Dnes použité příklady
budou pro jednoduchost používat modul <i>ctypes</i>, který ve svém systému již
pravděpodobně máte nainstalovaný. Modulem <strong>CFFI</strong> se budeme
podrobněji zabývat v&nbsp;navazujícím článku.</p>

<p>Prezentovány budou dva typy testů. První typ je založen na nástroji
<strong>pytest</strong>, což znamená, že samotné testy svoji strukturou
připomínají jednotkové testy, stejné je jejich vyhodnocení apod. Pochopitelně
&ndash; pokud tedy nepoužijeme ještě další nástroje &ndash; ovšem nezjistíme
pokrytí nativního kódu těmito testy. V&nbsp;závěrečné části článku si ovšem
ukážeme i behaviorální testy (BDD), které budou založeny na použití frameworku
<i>Behave</i> a doménově specifického jazyka <i>Gherkin</i>. Obě zmíněné
technologie již na Rootu byly představeny, takže závěrečná část článku je spíše
shrnutím již známých věcí.</p>

<p><div class="rs-tip-major">Poznámka: pravděpodobně si nyní pokládáte otázku,
jestli je vůbec dobrým nápadem testovat nativní aplikace s&nbsp;využitím testů
naprogramovaných v&nbsp;Pythonu. Co se týká Rustu (popř.&nbsp;Go či D), tak je
s&nbsp;velkou pravděpodobností výhodnější použít přímo tooling určený pro daný
ekosystém, ale v&nbsp;případě jazyka C může být (a velmi často bývá) použití
Pythonu poměrně efektivním řešením, které je flexibilnější, než snaha psát
jednotkové testy přímo v&nbsp;céčku.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zdrojový kód funkce, která se má přeložit do dynamické knihovny</h2>

<p>Základem několika dále použitých demonstračních příkladů bude zdrojový kód
vyvinutý v&nbsp;programovacím jazyku C, který je uložený do souboru
pojmenovaného <strong>adder.c</strong>. Tento zdrojový kód bude obsahovat pouze
jedinou funkci se jménem <strong>add</strong> a triviálním kódem:</p>

<pre>
<strong>extern</strong> int add(int x, int y)
{
    <strong>return</strong> x+y;
}
</pre>

<p>Jak je ze zdrojového kódu patrné, akceptuje tato funkce dva parametry typu
<strong>int</strong> a vrací hodnotu, která je taktéž typu
<strong>int</strong>. To může být poněkud problematické, protože standard
programovacího jazyka C sice poměrně přesně a striktně určuje vlastnosti
datového typu <strong>int</strong>, ale již neříká, jaká je konkrétní bitová
délka (což je ostatně ve většině případů dobře a v&nbsp;případě potřeby lze
datový typ specifikovat přesněji, minimálně <a
href="https://en.wikipedia.org/wiki/C_data_types#Fixed-width_integer_types">ve
standardu C99</a>). Podle použité architektury se může jednat o šestnáctibitová
čísla, většinou půjde o čísla 32bitová, ovšem na specializovaných
architekturách nalezneme například i 24bitové hodnoty (typické je použití
24bitových akumulátorů u některých digitálně-signálových procesorů neboli DSP,
příkladem může být <a
href="https://www.root.cz/clanky/digitalni-signalove-procesory-rady-tms320/">slavná
řada TMS320</a>).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zdrojový kód Pythonovského skriptu, který má dynamickou knihovnu využít</h2>

<p>Nyní je nutné vytvořit druhou část projektu naprogramovanou pro změnu ve
vysokoúrovňovém Pythonu. Tato část bude prozatím velmi jednoduchá, protože
sestává z&nbsp;jediného souboru pojmenovaného
<strong>call_from_python.py</strong> uloženého v&nbsp;adresáři s&nbsp;projektem
(což je opět řešení zvolené pouze pro jeho jednoduchost, v&nbsp;reálném světě
bude situace poněkud odlišná):</p>

<pre>
<i>"""Základní použití balíčku ctypes."""</i>
&nbsp;
import ctypes
&nbsp;
&nbsp;
def <strong>load_library</strong>(library_name):
    <i>"""Načtení nativní knihovny."""</i>
    return ctypes.CDLL(library_name)
&nbsp;
&nbsp;
def <strong>main</strong>():
    <i>"""Otestování, jestli je možné zavolat nativní funkci."""</i>
    library = load_library("libadder.so")
    print(library)
    result = library.add(1, 2)
    print(f"1+2=", result, sep="")
&nbsp;
&nbsp;
if __name__ == '__main__':
    <i># pouze se ujistíme, že lze zavolat nativní funkci</i>
    main()
</pre>

<p>Povšimněte si, že se nejdříve ve funkci <strong>load_library</strong>
pokusíme otevřít dynamickou knihovnu, k&nbsp;níž je uvedena plná cesta. To není
obvyklý způsob, neboť v&nbsp;praxi je lepší se spolehnout na proměnnou
prostředí <strong>LD_LIBRARY_PATH</strong>, což si ukážeme v&nbsp;dalších
demonstračních projektech. Dále zavoláme nativní funkci <strong>add</strong>
načtenou z&nbsp;této knihovny, získáme její výsledek a ten vypíšeme na
standardní výstup.</p>

<p>Pokud se nyní pokusíme skript <strong>call_from_python.py</strong> spustit
v&nbsp;interpretru Pythonu, dojde k&nbsp;chybě, protože načítaná knihovna
nebude nalezena (existuje prozatím pouze ve zdrojové podobě, ale nebyla
přeložena):</p>

<pre>
$ <strong>python3 call_from_python.py</strong>
&nbsp;
Traceback (most recent call last):
  File "call_from_python.py", line 21, in <module>
    main()
  File "call_from_python.py", line 13, in main
    library = load_library("libadder.so")
  File "call_from_python.py", line 8, in load_library
    return ctypes.CDLL(library_name)
  File "/usr/lib64/python3.6/ctypes/__init__.py", line 343, in __init__
    self._handle = _dlopen(self._name, mode)
OSError: libadder.so: cannot open shared object file: No such file or directory
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Překlad projektu a pokus o zavolání nativní funkce z&nbsp;dynamické knihovny</h2>

<p>Soubor <strong>adder.c</strong> nyní přeložíme do objektového souboru, který
bude pojmenován <strong>adder.o</strong>. Povšimněte si použití volby
<strong>PIC</strong>, kterou se zapíná takzvaný <i>Position Independent
Code</i> (tedy instrukcí nepoužívajících absolutní skoky) a která se používá
při vytváření sdílených knihoven na některých architekturách (na x86_64 však
v&nbsp;našem jednoduchém příkladu dostaneme stejný výsledek i bez použití této
volby):</p>

<pre>
$ <strong>gcc -Wall -ansi -c -fPIC adder.c -o adder.o</strong>
</pre>

<p>Následně z&nbsp;tohoto objektového souboru vytvoříme sdílenou knihovnu
(<i>shared library</i>) pojmenovanou <strong>libadder.so</strong> (přípona
<i>.so</i> značí &bdquo;shared object&ldquo;):</p>

<pre>
$ <strong>gcc -shared -Wl,-soname,libadder.so -o libadder.so adder.o</strong>
</pre>

<p>Přesvědčíme se, že soubor <strong>libadder.so</strong> skutečně vznikl:</p>

<pre>
$ <strong>file libadder.so </strong>
&nbsp;
libadder.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=85fe85114c2f6582a8764ca22ba578df35381fec, not stripped
</pre>

<p>Popř.&nbsp;se můžeme podívat i na symboly, které jsou v&nbsp;tomto souboru
definovány. Použijeme k&nbsp;tomu nástroj <strong>nm</strong>:</p>

<pre>
00000000000005ca T add
0000000000201018 B __bss_start
0000000000201018 b completed.6984
                 w __cxa_finalize@@GLIBC_2.2.5
00000000000004f0 t deregister_tm_clones
0000000000000580 t __do_global_dtors_aux
0000000000200e30 t __do_global_dtors_aux_fini_array_entry
0000000000200e38 d __dso_handle
0000000000200e40 d _DYNAMIC
0000000000201018 D _edata
0000000000201020 B _end
00000000000005e0 T _fini
00000000000005c0 t frame_dummy
0000000000200e28 t __frame_dummy_init_array_entry
0000000000000688 r __FRAME_END__
0000000000201000 d _GLOBAL_OFFSET_TABLE_
                 w __gmon_start__
00000000000005ec r __GNU_EH_FRAME_HDR
00000000000004b8 T _init
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
0000000000000530 t register_tm_clones
0000000000201018 d __TMC_END__
</pre>

<p>Můžeme se dokonce podívat, jakým způsobem se funkce <strong>add</strong>
přeložila do strojového kódu. K&nbsp;tomuto účelu použijeme nástroj
<strong>objdump</strong> a pro získání disassemblovaného textu zvolené funkce
použijeme trik s&nbsp;<strong>awk</strong>, který z&nbsp;výpisu
&bdquo;vykousne&ldquo; pouze požadovanou funkci:</p>

<pre>
$ <strong>objdump -d -M intel libadder.so | awk -F"\n" -v RS="\n\n" '$1 ~ /add/'</strong>
&nbsp;
00000000000005ca &lt;add&gt;:
 5ca:   55                      push   rbp
 5cb:   48 89 e5                mov    rbp,rsp
 5ce:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi
 5d1:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi
 5d4:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]
 5d7:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
 5da:   01 d0                   add    eax,edx
 5dc:   5d                      pop    rbp
 5dd:   c3
</pre>

<p><div class="rs-tip-major">Poznámka: aby bylo možné sdílenou knihovnu nalézt,
je nutné nastavit proměnnou prostředí <strong>LD_LIBRARY_PATH</strong> (jinak
by se knihovna hledala v&nbsp;/usr/lib popř.&nbsp;/usr/lib64 atd. ale nikoli
v&nbsp;aktuálním adresáři.). V&nbsp;našem konkrétním případě to znamená, že se
interpret Pythonu zavolá takto:</div></p>

<pre>
$ <strong>LD_LIBRARY_PATH=. python3 call_from_python.py</strong>
</pre>

<p>Tento řádek je uložen ve skriptu <strong>run.sh</strong>, který je možné
přímo použít:</p>

<pre>
$ <strong>./run.sh</strong>
&nbsp;
&lt;CDLL 'libadder.so', handle 55ac5f4a1bf0 at 0x7fde59f99080&gt;
1+2=3
</pre>

<p><div class="rs-tip-major">Poznámka: všechny zdrojové soubory a skripty
potřebné pro překlad a spuštění dnešního prvního demonstračního příkladu jsou
dostupné na adrese <a
href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project1">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project1</a>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Malá úprava demonstračního příkladu &ndash; obalení nativní funkce Pythonovským kódem</h2>

<p>Předchozí demonstrační příklad upravíme, a to takovým způsobem, že se
nativní funkce <strong>add</strong> obalí Pythonovskou funkcí taktéž nazvanou
<strong>add</strong>. Navíc do nového modulu <strong>adder.py</strong> přidáme
kód pro načtení a inicializaci dynamicky sdílené knihovny:</p>

<pre>
<i>"""Základní použití balíčku ctypes, modul pro import."""</i>
&nbsp;
import ctypes
&nbsp;
&nbsp;
library = None
&nbsp;
&nbsp;
def <strong>load_library</strong>(library_name):
    <i>"""Načtení nativní knihovny."""</i>
    return ctypes.CDLL(library_name)
&nbsp;
&nbsp;
def <strong>add</strong>(x, y):
    <i>"""Zavolání externí funkce."""</i>
    return library.add(x, y)
&nbsp;
&nbsp;
def <strong>init</strong>():
    global library
    library = load_library("libadder.so")
&nbsp;
&nbsp;
def <strong>main</strong>():
    <i>"""Otestování, jestli je možné zavolat nativní funkci."""</i>
    init()
    print(library)
    result = add(1, 2)
    print(f"1+2=", result, sep="")
&nbsp;
&nbsp;
if __name__ == '__main__':
    <i># pouze se ujistíme, že lze zavolat nativní funkci</i>
    main()
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti ovšem nic nezabrání
ostatnímu kódu, aby se funkce <strong>add</strong> zavolala s&nbsp;rozdílnými
parametry, například s&nbsp;dvojicí řetězců.</div></p>

<p>Nový modul <strong>adder</strong> se použije relativně snadno &ndash; pouze
musíme zavolat inicializační funkci a následně je již možné používat funkci
<strong>add</strong>:</p>

<pre>
<i>"""Základní použití balíčku ctypes."""</i>
&nbsp;
from adder import init, add
&nbsp;
&nbsp;
def <strong>main</strong>():
    <i>"""Otestování, jestli je možné zavolat nativní funkci."""</i>
    init()
    result = add(1, 2)
    print(f"1+2=", result, sep="")
&nbsp;
&nbsp;
if __name__ == '__main__':
    <i># pouze se ujistíme, že lze zavolat nativní funkci</i>
    main()
</pre>

<p>Překlad céčkového kódu do nativní sdílené knihovny opět zajišťuje příslušný
skript:</p>

<pre>
$ <strong>./make_library.sh</strong>
</pre>

<p>Pokud k&nbsp;překladu a vytvoření knihovny došlo, dopadne spuštění příkladu
podle očekávání &ndash; vypíše se výsledek součtu:</p>

<pre>
$ <strong>./run.sh</strong>
&nbsp;
1+2=3
</pre>

<p>V&nbsp;předchozím textu bylo uvedeno, že funkce <strong>add</strong> nijak
nekontroluje typ parametrů &ndash; pouze je předá do nativního kódu. To
například umožňuje, aby se tato funkce zavolala s&nbsp;dvojicí řetězců, přičemž
výsledkem pochopitelně bude nesmysl (sečtou se hodnoty dvou ukazatelů nebo
jejich částí):</p>

<pre>
def <strong>main</strong>():
    <i>"""Otestování, jestli je možné zavolat nativní funkci."""</i>
    init()
    result = add("foo", "bar")
    print(f"'foo'+'bar'=", result, sep="")
</pre>

<p>Špatné chování si můžeme snadno otestovat:</p>

<pre>
$ <strong>./run_bad.sh</strong>
&nbsp;
'foo'+'bar'=155795872
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto konkrétním případě by
nemělo dojít k&nbsp;pádu, protože nativní funkce pouze sčítá dvojici celých
čísel. Pokud by se ovšem očekávaly ukazatele (na pole atd.), mohlo by
k&nbsp;pádu celé aplikace snadno dojít.</div></p>

<p>Druhý demonstrační příklad naleznete na adrese <a
href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project2">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project2</a>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Jednotkové testy naprogramované v&nbsp;Pythonu, které volají a testují nativní funkci</h2>

<p>Naši nativní céčkovou funkci pojmenovanou <strong>add</strong>:</p>

<pre>
extern int <strong>add</strong>(int x, int y)
{
    return x+y;
}
</pre>

<p>která je obalena vlastním Pythonovským balíčkem:</p>

<pre>
<i>"""Základní použití balíčku ctypes, modul pro import."""</i>
&nbsp;
import ctypes
&nbsp;
&nbsp;
library = None
&nbsp;
&nbsp;
def <strong>load_library</strong>(library_name):
    <i>"""Načtení nativní knihovny."""</i>
    return ctypes.CDLL(library_name)
&nbsp;
&nbsp;
def <strong>add</strong>(x, y):
    <i>"""Zavolání externí funkce."""</i>
    return library.add(x, y)
&nbsp;
&nbsp;
def <strong>init</strong>():
    global library
    library = load_library("libadder.so")
&nbsp;
&nbsp;
def <strong>main</strong>():
    <i>"""Otestování, jestli je možné zavolat nativní funkci."""</i>
    init()
    print(library)
    result = add(1, 2)
    print(f"1+2=", result, sep="")
&nbsp;
&nbsp;
if __name__ == '__main__':
    <i># pouze se ujistíme, že lze zavolat nativní funkci</i>
    main()
</pre>

<p>pochopitelně můžeme relativně snadno otestovat přímo z&nbsp;Pythonu, a to
pomocí nám již známého nástroje <strong>pytest</strong>. Kostra jednotkového
testu může vypadat následovně:</p>

<pre>
<i>"""Implementace jednotkových testů."""</i>
&nbsp;
import pytest
&nbsp;
from adder import init, add
&nbsp;
&nbsp;
def <strong>test_add_basic</strong>():
    <i>"""Otestování výpočtu součtu dvou celých čísel."""</i>
    init()
    result = add(1, 2)
    expected = 3
    assert result == expected, "Očekávaná hodnota {}, vráceno {}".format(expected, result)
</pre>

<p><div class="rs-tip-major">Poznámka: všechny soubory třetího demonstračního
příkladu jsou dostupné na adrese <a
href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project3">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project3</a>.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Spuštění jednotkových testů</h2>

<p>Jednotkové testy (resp.&nbsp;přesněji řečeno jediný jednotkový test, který
jsme prozatím vytvořili) lze spustit příkazem <strong>pytest</strong>. Nesmíme
ovšem zapomenout na nastavení proměnné prostředí
<strong>LD_LIBRARY_PATH</strong>. Pokud by tato proměnná prostředí nebyla
nastavena (popř.&nbsp;byla nastavena nesprávně), nebylo by možné načíst nativní
knihovnu a testy by ihned na začátku zhavarovaly. Spuštění jednotkových testů
by tedy mohlo vypadat takto:</p>

<pre>
$ <strong>LD_LIBRARY_PATH=.;pytest -v</strong>
</pre>

<p>V&nbsp;případě, že nativní knihovna byla nalezena, měly by testy projít bez
pádu:</p>

<pre>
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/native_libs/project3
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 1 item
&nbsp;
test_add.py::test_add_basic PASSED                                       [100%]
&nbsp;
============================== 1 passed in 0.01s ===============================
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Rozdíly mezi datovými typy jazyka C a Pythonu</h2>

<p>Mezi programovacími jazyky C a Pythonem existuje velké množství rozdílů. Ty
se týkají mj.&nbsp;i datových typů obou jazyků. A právě při volání nativních
funkcí se někdy musí provádět konverze mezi různými datovými typy. Výjimek je
jen několik a týkají se celých čísel (<strong>int</strong>) v&nbsp;32bitovém či
64bitovém rozsahu popř.&nbsp;polí bajtů, které jsou přenášeny jako řetězce
(Unicode řetězce jako ukazatele na <strong>wchar_t</strong>). Při použití
ostatních typů je nutné provádět konverze. K&nbsp;tomu slouží speciální datové
typy knihovny <strong>ctypes</strong>, každý se svým konstruktorem:</p>

<table>
<tr><th> #</th><th>Typ v&nbsp;knihovně <strong>ctypes</strong></th><th>Typ v&nbsp;céčku</th><th>Typ v&nbsp;Pythonu</th></tr>
<tr><td> 1</td><td>c_bool</td><td>_Bool</td><td>bool</td></tr>
<tr><td> 2</td><td>c_char</td><td>char</td><td>1-character bytes object</td></tr>
<tr><td> 3</td><td>c_wchar</td><td>wchar_t</td><td>1-character string</td></tr>
<tr><td> 4</td><td>c_byte</td><td>char</td><td>int</td></tr>
<tr><td> 5</td><td>c_ubyte</td><td>unsigned char</td><td>int</td></tr>
<tr><td> 6</td><td>c_short</td><td>short</td><td>int</td></tr>
<tr><td> 7</td><td>c_ushort</td><td>unsigned short</td><td>int</td></tr>
<tr><td> 8</td><td>c_int</td><td>int</td><td>int</td></tr>
<tr><td> 9</td><td>c_uint</td><td>unsigned int</td><td>int</td></tr>
<tr><td>10</td><td>c_long</td><td>long</td><td>int</td></tr>
<tr><td>11</td><td>c_ulong</td><td>unsigned long</td><td>int</td></tr>
<tr><td>12</td><td>c_longlong</td><td>__int64 nebo long long</td><td>int</td></tr>
<tr><td>13</td><td>c_ulonglong</td><td>unsigned __int64 nebo unsigned long long</td><td>int</td></tr>
<tr><td>14</td><td>c_size_t</td><td>size_t</td><td>int</td></tr>
<tr><td>15</td><td>c_ssize_t</td><td>ssize_t nebo Py_ssize_t</td><td>int</td></tr>
<tr><td>16</td><td>c_float</td><td>float</td><td>float</td></tr>
<tr><td>17</td><td>c_double</td><td>double</td><td>float</td></tr>
<tr><td>18</td><td>c_longdouble</td><td>long double</td><td>float</td></tr>
<tr><td>19</td><td>c_char_p</td><td>char * (NUL terminated)</td><td>bytes object nebo None</td></tr>
<tr><td>20</td><td>c_wchar_p</td><td>wchar_t * (NUL terminated)</td><td>string nebo None</td></tr>
<tr><td>21</td><td>c_void_p</td><td>void *</td><td>int nebo None</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka 1: typem <strong>int</strong> je
v&nbsp;Pythonu myšlen datový typ s&nbsp;rozsahem omezeným jen kapacitou
poskytované operační paměti a výpočetního výkonu. Jedná se tedy o datový typ
zcela odlišný od céčka.</div></p>

<p><div class="rs-tip-major">Poznámka 2: jméno typu z&nbsp;knihovny
<strong>ctypes</strong> je současně i konstruktorem daného typu. Stačí tedy
napsat například následující kód pro získání hodnoty kompatibilní
s&nbsp;céčkovým typem <strong>float</strong>:</div></p>

<pre>
$ <strong>python3</strong>
Python 3.6.6 (default, Jul 19 2018, 16:29:00) 
[GCC 7.3.1 20180303 (Red Hat 7.3.1-5)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&nbsp;
&gt;&gt;&gt; <strong>import ctypes</strong>
&gt;&gt;&gt; <strong>ctypes.c_float(1/2)</strong>
c_float(0.5)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Přetečení při operacích s&nbsp;celými čísly v&nbsp;C</h2>

<p><a href="#k08">V&nbsp;předchozí kapitole</a> jsme si řekli, že typ
<strong>int</strong> v&nbsp;Pythonu má prakticky neomezený rozsah. To však
v&nbsp;žádném případě neplatí pro stejně pojmenovaný datový typ
<strong>int</strong> z&nbsp;céčka, který může mít šířku typicky šestnáct bitů,
32bitů, 64bitů ale i 24 bitů (dříve podle použité platformy, dnes někdy i na
základě tradice). Proto se nativní funkce <strong>add</strong> bude chovat
rozdílně oproti operátoru + přímo v&nbsp;Pythonu. To si ostatně můžeme velmi
snadno ověřit rozšířením jednotkových testů o sčítání hodnot, které se blíží
32bitovému limitu:</p>

<pre>
<i>"""Implementace jednotkových testů."""</i>
&nbsp;
import pytest
&nbsp;
from adder import init, add
&nbsp;
&nbsp;
def <strong>test_add_basic</strong>():
    <i>"""Otestování výpočtu součtu dvou celých čísel."""</i>
    init()
    result = add(1, 2)
    expected = 3
    assert result == expected, "Očekávaná hodnota {}, vráceno {}".format(expected, result)
&nbsp;
&nbsp;
def <strong>test_add_large_ints</strong>():
    <i>"""Otestování výpočtu součtu dvou větších celých čísel."""</i>
    init()
    result = add(2**31-2, 1)
    expected = 2**31-1
    assert result == expected, "Očekávaná hodnota {}, vráceno {}".format(expected, result)
&nbsp;
&nbsp;
def <strong>test_add_even_larger_ints</strong>():
    <i>"""Otestování výpočtu součtu dvou velkých celých čísel."""</i>
    init()
    result = add(2**31-1, 1)
    expected = 2**31
    assert result == expected, "Očekávaná hodnota {}, vráceno {}".format(expected, result)
</pre>

<p>Při spuštění těchto jednotkových testů se může stát, že třetí test havaruje,
a to právě kvůli přetečení výsledku v&nbsp;nativní funkci:</p>

<pre>
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/native_libs/project4
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 3 items
&nbsp;
test_add.py::test_add_basic PASSED                                       [ 33%]
test_add.py::test_add_large_ints PASSED                                  [ 66%]
test_add.py::test_add_even_larger_ints FAILED                            [100%]
&nbsp;
=================================== FAILURES ===================================
__________________________ test_add_even_larger_ints ___________________________
&nbsp;
    def test_add_even_larger_ints():
        """Otestování výpočtu součtu dvou velkých celých čísel."""
        init()
        result = add(2**31-1, 1)
        expected = 2**31
&gt;       assert result == expected, "Očekávaná hodnota {}, vráceno {}".format(expected, result)
E       AssertionError: <strong>Očekávaná hodnota 2147483648, vráceno -2147483648</strong>
E       assert -2147483648 == 2147483648
E         +-2147483648
E         -2147483648
&nbsp;
test_add.py:29: AssertionError
=========================== short test summary info ============================
FAILED test_add.py::test_add_even_larger_ints - AssertionError: Očekávaná hod...
========================= 1 failed, 2 passed in 0.03s ==========================
</pre>

<p><div class="rs-tip-major">Poznámka: bitovou šířku typu <strong>int</strong>
lze zjistit snadno:</div></p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int <strong>main</strong>(void) {
    printf("Bit size of int: %lu\n", 8*sizeof(int));
    return 0;
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Jednoduchý test volající funkce ze standardní knihovny jazyka C</h2>

<p>Kromě vlastních nativních knihoven pochopitelně můžeme z&nbsp;Pythonu volat
i funkce ze standardní knihovny programovacího jazyka C. Na Linuxu jsou
standardní funkce dostupné v&nbsp;knihovně <strong>libc.so.6</strong> typicky
umístěné v&nbsp;<strong>/usr/lib64/</strong> nebo <strong>/usr/lib/</strong>.
Všechny externí (volatelné) symboly (tedy především funkce) si ostatně můžeme
zobrazit:</p>

<pre>
$ <strong>nm -g /usr/lib64/libc.so.6</strong>
&nbsp;
0000000000042390 T a64l
0000000000035be0 T abort
00000000003b1d00 B __abort_msg
0000000000037880 T abs
00000000000f6070 T accept
00000000000f6a40 T accept4
00000000000e69f0 W access
00000000000ece00 T acct
...
...
...
0000000000127710 T xdr_vector
0000000000127880 T xdr_void
0000000000128240 T xdr_wrapstring
0000000000127380 T xencrypt
00000000000e6190 T __xmknod
00000000000e61f0 T __xmknodat
0000000000043c60 T __xpg_basename
0000000000034e50 W __xpg_sigpause
000000000008cb30 T __xpg_strerror_r
00000000001254c0 T xprt_register
00000000001255f0 T xprt_unregister
00000000000e60a0 T __xstat
00000000000e60a0 T __xstat64
</pre>

<p>Je tedy možné zavolat a otestovat základní funkcionalitu standardních funkcí
<strong>time()</strong> a <strong>abs()</strong>. U první funkce ověříme, že
vrácený čas (počet sekund od začátku Unixové éry) platí pro rok 2020 a další
roky (vlastní výpočet je ovšem značně nepřesný &ndash; nepočítá například
přestupné roky). U druhé funkce ověříme, jestli se skutečně počítá a vrací
absolutní hodnota:</p>

<pre>
<i>"""Implementace jednotkových testů."""</i>
&nbsp;
import pytest
import ctypes
&nbsp;
libc = None
&nbsp;
&nbsp;
def <strong>setup_module</strong>(module):
    <i>"""Zavoláno při inicializaci modulu s testem."""</i>
    global libc
    libc = ctypes.CDLL("libc.so.6")
&nbsp;
&nbsp;
def <strong>test_time</strong>():
    <i>"""Otestování nativní funkce time()."""</i>
    t = libc.time(None)
    <i># velmi nepřesný odhad počtu sekund pro 2000-01-01</i>
    t2020 = (2020-1970)*365*24*60*60
    assert t &gt; t2020, "Neočekávaná hodnota {}".format(t)
&nbsp;
&nbsp;
def <strong>test_abs</strong>():
    <i>"""Otestování nativní funkce abs()."""</i>
    x = libc.abs(-1)
    assert x == 1, "Neočekávaná hodnota {}".format(x)
&nbsp;
    x = libc.abs(1)
    assert x == 1, "Neočekávaná hodnota {}".format(x)
</pre>

<p>Jednotkové testy nyní můžeme spustit bez nutnosti nastavování proměnné
prostředí <strong>LD_LIBRARY_PATH</strong>:</p>

<pre>
$ <strong>pytest -v</strong>
&nbsp;
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/native_libs/project5
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 2 items
&nbsp;
test_stdlib.py::test_time PASSED                                         [ 50%]
test_stdlib.py::test_abs PASSED                                          [100%]
&nbsp;
============================== 2 passed in 0.01s ===============================
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Volání céčkových funkcí akceptujících odlišné typy argumentů</h2>

<p>Pokusme se nyní zavolat standardní funkci <strong>strlen()</strong> a předat
jí řetězec v&nbsp;Pythonu:</p>

<pre>
def <strong>test_strlen</strong>():
    <i>"""Otestování nativní funkce strlen()."""</i>
    x = libc.strlen("Hello")
    assert x == 5, "Neočekávaná hodnota {}".format(x)
</pre>

<p>Tento jednotkový test zařadíme do demonstračního příkladu k&nbsp;předchozím
dvěma testům:</p>

<pre>
<i>"""Implementace jednotkových testů."""</i>
&nbsp;
import pytest
import ctypes
&nbsp;
libc = None
&nbsp;
&nbsp;
def <strong>setup_module</strong>(module):
    <i>"""Zavoláno při inicializaci modulu s testem."""</i>
    global libc
    libc = ctypes.CDLL("libc.so.6")
&nbsp;
&nbsp;
def <strong>test_time</strong>():
    <i>"""Otestování nativní funkce time()."""</i>
    t = libc.time(None)
    <i># velmi nepřesný odhad počtu sekund pro 2000-01-01</i>
    t2020 = (2020-1970)*365*24*60*60
    assert t &gt; t2020, "Neočekávaná hodnota {}".format(t)
&nbsp;
&nbsp;
def <strong>test_abs</strong>():
    <i>"""Otestování nativní funkce abs()."""</i>
    x = libc.abs(-1)
    assert x == 1, "Neočekávaná hodnota {}".format(x)
&nbsp;
    x = libc.abs(1)
    assert x == 1, "Neočekávaná hodnota {}".format(x)
&nbsp;
&nbsp;
def <strong>test_strlen</strong>():
    <i>"""Otestování nativní funkce strlen()."""</i>
    x = libc.strlen("Hello")
    assert x == 5, "Neočekávaná hodnota {}".format(x)
</pre>

<p>Vidíme, že test kontroluje, jestli je délka řetězce &bdquo;Hello&ldquo;
skutečně rovna pěti znakům. Ovšem při pokusu o spuštění testů dojde
k&nbsp;chybě:</p>

<pre>
$ <strong>pytest -v</strong>
&nbsp;
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/native_libs/project6
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 3 items
&nbsp;
test_stdlib.py::test_time PASSED                                         [ 33%]
test_stdlib.py::test_abs PASSED                                          [ 66%]
test_stdlib.py::test_strlen FAILED                                       [100%]
&nbsp;
=================================== FAILURES ===================================
_________________________________ test_strlen __________________________________
&nbsp;
    def test_strlen():
        """Otestování nativní funkce strlen()."""
        x = libc.strlen("Hello")
&gt;       assert x == 5, "Neočekávaná hodnota {}".format(x)
E       AssertionError: Neočekávaná hodnota 1
E       assert 1 == 5
E         +1
E         -5
&nbsp;
test_stdlib.py:35: AssertionError
=========================== short test summary info ============================
FAILED test_stdlib.py::test_strlen - AssertionError: Neočekávaná hodnota 1
========================= 1 failed, 2 passed in 0.03s ==========================
</pre>

<p>Proč tomu tak je? V&nbsp;Pythonu 3 se používají Unicode řetězce, které jsou
do céčkových funkcí přenášeny přes ukazatel na <strong>wchar_t</strong>. My
však pracujeme s&nbsp;klasickými ASCIIZ řetězci céčka, musíme tedy použít pole
bajtů (opět &ndash; platí pro Python 3):</p>

<pre>
<i>"""Implementace jednotkových testů."""</i>
&nbsp;
import pytest
import ctypes
&nbsp;
libc = None
&nbsp;
&nbsp;
def <strong>setup_module</strong>(module):
    <i>"""Zavoláno při inicializaci modulu s testem."""</i>
    global libc
    libc = ctypes.CDLL("libc.so.6")
&nbsp;
&nbsp;
def <strong>test_time</strong>():
    <i>"""Otestování nativní funkce time()."""</i>
    t = libc.time(None)
    # velmi nepřesný odhad počtu sekund pro 2000-01-01
    t2020 = (2020-1970)*365*24*60*60
    assert t &gt; t2020, "Neočekávaná hodnota {}".format(t)
&nbsp;
&nbsp;
def <strong>test_abs</strong>():
    <i>"""Otestování nativní funkce abs()."""</i>
    x = libc.abs(-1)
    assert x == 1, "Neočekávaná hodnota {}".format(x)
&nbsp;
    x = libc.abs(1)
    assert x == 1, "Neočekávaná hodnota {}".format(x)
&nbsp;
&nbsp;
def <strong>test_strlen</strong>():
    <i>"""Otestování nativní funkce strlen()."""</i>
    x = libc.strlen(b"Hello")
    assert x == 5, "Neočekávaná hodnota {}".format(x)
</pre>

<p>Nyní již jednotkové testy projdou bez problémů:</p>

<pre>
$ <strong>pytest -v</strong>
&nbsp;
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/native_libs/project7
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 3 items
&nbsp;
test_stdlib.py::test_time PASSED                                         [ 33%]
test_stdlib.py::test_abs PASSED                                          [ 66%]
test_stdlib.py::test_strlen PASSED                                       [100%]
&nbsp;
============================== 3 passed in 0.01s ===============================
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se o velmi častou chybu, na kterou
se mnohdy přijde až dosti pozdě.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Práce s&nbsp;datovými strukturami</h2>

<p>Ve druhé části dnešního článku si ukážeme způsob předávání datových struktur
mezi jazykem C a Pythonem. Připomeňme si, že v&nbsp;C představují struktury
základní (a do značné míry jedinou) technologii určenou pro tvorbu uživatelsky
definovaných heterogenních datových struktur (naproti tomu pole jsou struktury
homogenní). Oproti primitivním datovým typům je předávání datových struktur
poněkud složitější, a to zejména na straně Pythonu, protože je nutné explicitně
specifikovat typy prvků a samozřejmě i jejich pořadí. Další problém, který je
někdy nutné řešit, představuje předávání struktur odkazem,
tj.&nbsp;s&nbsp;využitím ukazatelů. I s&nbsp;touto problematikou se postupně
seznámíme, ovšem až v&nbsp;navazujícím článku.</p>

<p>Ukažme si nyní velmi jednoduchou aplikaci, v&nbsp;níž bude používána datová
struktura reprezentující komplexní číslo a v&nbsp;C bude navíc implementována
funkce pro součet dvou komplexních čísel.</p>

<p>Část aplikace psaná v&nbsp;programovacím jazyku C bude nejprve obsahovat
deklaraci struktury nazvané <strong>Complex</strong>:</p>

<pre>
typedef struct {
    float real;
    float imag;
} <strong>Complex</strong>;
</pre>

<p>Ve stejném zdrojovém kódu je taktéž uvedena funkce určená pro součet dvou
komplexních čísel. Jedná se o skutečnou funkci, která nijak nemění své
parametry, ale vytváří nové komplexní číslo (to ovšem nemusí být příliš
efektivní, například při práci s&nbsp;vektory či maticemi komplexních
čísel):</p>

<pre>
extern Complex <strong>add</strong>(Complex x, Complex y)
{
    Complex result;
    result.real = x.real + y.real;
    result.imag = x.imag + y.imag;
    return result;
}
</pre>

<p>Skript naprogramovaný v&nbsp;Pythonu, který bude volat céčkovou funkci pro
součet komplexních čísel, je již poměrně složitý. Nejdříve si uveďme je úplnou
podobu a potom se zaměříme na popis jednotlivých částí:</p>

<pre>
<i>"""Základní použití balíčku ctypes, modul pro import."""</i>
&nbsp;
import ctypes
&nbsp;
&nbsp;
library = None
&nbsp;
&nbsp;
def <strong>load_library</strong>(library_name):
    <i>"""Načtení nativní knihovny."""</i>
    return ctypes.CDLL(library_name)
&nbsp;
&nbsp;
def <strong>add</strong>(x, y):
    <i>"""Zavolání externí funkce."""</i>
    return library.add(x, y)
&nbsp;
&nbsp;
def <strong>init</strong>():
    global library
    library = load_library("libadder.so")
&nbsp;
    library.add.argtypes = (Complex, Complex)
    library.add.restype = Complex
&nbsp;
&nbsp;
class <strong>Complex</strong>(ctypes.Structure):
    _fields_ = [("real", ctypes.c_float), ("imag", ctypes.c_float)]
&nbsp;
    def <strong>__str__</strong>(self):
        return "Complex: %f + i%f" % (self.real, self.imag)
&nbsp;
&nbsp;
def <strong>main</strong>():
    <i>"""Otestování, jestli je možné zavolat nativní funkci."""</i>
    init()
    print(library)
&nbsp;
    c1 = Complex(1.0, 2.0)
    c2 = Complex(3.0, 4.0)
&nbsp;
    c3 = add(c1, c2)
&nbsp;
    print(c1)
    print(c2)
    print(c3)
&nbsp;
&nbsp;
if __name__ == '__main__':
    <i># pouze se ujistíme, že lze zavolat nativní funkci</i>
    main()
</pre>

<p>Na začátku pouze naimportujeme funkce a typy z&nbsp;modulu
<i>ctypes</i>:</p>

<pre>
import ctypes
</pre>

<p>Následně se pokusíme načíst novou dynamickou knihovnu s&nbsp;deklarací
struktury <strong>Complex</strong> i s&nbsp;funkcí <strong>add()</strong>.
Samozřejmě zde můžete odstranit cestu ke knihovně a použít přístup
s&nbsp;proměnnou prostředí <strong>LD_LIBRARY_PATH</strong>:</p>

<pre>
library = load_library("libadder.so")
</pre>

<p>Další část je poměrně záludná, ale důležitá, a to konkrétní určení typů
parametrů funkce <strong>add()</strong> a taktéž přesného návratového typu této
funkce::</p>

<pre>
library.add.argtypes = (Complex, Complex)
library.add.restype = Complex
</pre>

<p>Následuje poměrně složitá část skriptu, v&nbsp;níž (znovu) deklarujeme
datovou strukturu <strong>Complex</strong>, tentokrát ovšem takovým způsobem,
aby pořadí a typy atributů (<i>fields</i>) přesně odpovídaly rustovské
deklaraci. Všimněte si, jak se atributy popisují &ndash; uvádí se jejich jméno
a datový typ (což je důležité, aby interpret Pythonu mohl strukturu vytvořit
tak, aby byla binárním obrazem céčkovské či céčkové struktury). Navíc si
&ndash; zcela nezávisle na původní struktuře &ndash; můžeme přidat metody,
například metodu <strong>__str__</strong>, která nám umožní nechat si vypsat
obsah komplexního číslo (tedy reálné a imaginární složky).</p>

<pre>
class <strong>Complex</strong>(ctypes.Structure):
    _fields_ = [("real", ctypes.c_float), ("imag", ctypes.c_float)]
&nbsp;
    def <strong>__str__</strong>(self):
        return "Complex: %f + i%f" % (self.real, self.imag)
</pre>

<p>Nyní se již můžeme začít chovat ke třídě <strong>Complex</strong> i
k&nbsp;funkci <strong>add()</strong> běžným způsobem &ndash; následující kód
již neobsahuje žádné speciality a při pohledu na něj ani nelze říct, že by
třída <strong>Complex</strong> či funkce <strong>add_complex()</strong> byla
něčím výjimečná:</p>

<pre>
c1 = Complex(1.0, 2.0)
c2 = Complex(3.0, 4.0)
&nbsp;
c3 = library.add(c1, c2)
&nbsp;
print(c1)
print(c2)
print(c3)
</pre>

<pre>
Complex: 1.000000 + i2.000000
Complex: 3.000000 + i4.000000
Complex: 4.000000 + i6.000000
</pre>

<p>Korektní chování si ověříme i jednotkovými testy:</p>

<pre>
<i>"""Implementace jednotkových testů."""</i>
&nbsp;
import pytest
&nbsp;
from adder import Complex, init, add
&nbsp;
&nbsp;
def <strong>test_add_basic</strong>():
    <i>"""Otestování výpočtu součtu dvou komplexních čísel."""</i>
    init()
&nbsp;
    c1 = Complex(1.0, 2.0)
    c2 = Complex(3.0, 4.0)
&nbsp;
    result = add(c1, c2)
    expected = Complex(4.0, 6.0)
    assert result.real == expected.real and result.imag == expected.imag, \
        "Očekávaná hodnota {}, vráceno {}".format(expected, result)
</pre>

<p>S&nbsp;výsledkem &ndash; ok:</p>

<pre>
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/native_libs/project8
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 1 item
&nbsp;
test_add.py::test_add_basic PASSED                                       [100%]
&nbsp;
============================== 1 passed in 0.01s ===============================
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Porovnání komplexních čísel</h2>

<p>Nyní zdrojový kód pro nativní knihovnu rozšíříme o funkci sloužící
k&nbsp;porovnání dvou komplexních čísel. Připomeňme si, že v&nbsp;céčku jsou
pravdivostní hodnoty představovány typem <strong>int</strong>:</p>

<pre>
typedef struct {
    float real;
    float imag;
} <strong>Complex</strong>;
&nbsp;
extern Complex <strong>add</strong>(Complex x, Complex y)
{
    Complex result;
    result.real = x.real + y.real;
    result.imag = x.imag + y.imag;
    return result;
}
&nbsp;
extern int <strong>equal</strong>(Complex x, Complex y)
{
    return x.real == y.real &amp;&amp; x.imag == y.imag;
}
</pre>

<p>Příslušnou funkci &bdquo;obalíme&ldquo; stejně pojmenovanou funkcí
v&nbsp;Pythonu &ndash; opět se bude jmenovat <strong>equal</strong>:</p>

<pre>
<i>"""Základní použití balíčku ctypes, modul pro import."""</i>
&nbsp;
import ctypes
&nbsp;
&nbsp;
library = None
&nbsp;
&nbsp;
def <strong>load_library</strong>(library_name):
    <i>"""Načtení nativní knihovny."""</i>
    return ctypes.CDLL(library_name)
&nbsp;
&nbsp;
def <strong>add</strong>(x, y):
    <i>"""Zavolání externí funkce."""</i>
    return library.add(x, y)
&nbsp;
&nbsp;
def <strong>equal</strong>(x, y):
    <i>"""Zavolání externí funkce."""</i>
    return library.equal(x, y)
&nbsp;
&nbsp;
def <strong>init</strong>():
    global library
    library = load_library("libadder.so")
&nbsp;
    library.add.argtypes = (Complex, Complex)
    library.add.restype = Complex
&nbsp;
    library.equal.argtypes = (Complex, Complex)
    library.equal.restype = bool
&nbsp;
&nbsp;
class <strong>Complex</strong>(ctypes.Structure):
    _fields_ = [("real", ctypes.c_float), ("imag", ctypes.c_float)]
&nbsp;
    def <strong>__str__</strong>(self):
        return "Complex: %f + i%f" % (self.real, self.imag)
&nbsp;
&nbsp;
def <strong>main</strong>():
    <i>"""Otestování, jestli je možné zavolat nativní funkci."""</i>
    init()
    print(library)
&nbsp;
    c1 = Complex(1.0, 2.0)
    c2 = Complex(3.0, 4.0)
&nbsp;
    c3 = add(c1, c2)
&nbsp;
    print(c1)
    print(c2)
    print(c3)
&nbsp;
    print("c1==c2?", equal(c1, c2))
    print("c2==c2?", equal(c2, c2))
&nbsp;
&nbsp;
if __name__ == '__main__':
    <i># pouze se ujistíme, že lze zavolat nativní funkci</i>
    main()
</pre>

<p>Jednotkové testy se příslušným způsobem zjednoduší &ndash; budeme moci
zavolat funkci <strong>equal</strong> a předat jí dvojici komplexních čísel.
Využívá se zde faktu, že i v&nbsp;Pythonu lze pro reprezentaci nepravdy použít
nulu a pravdy libovolnou jinou celočíselnou hodnotu:</p>

<pre>
<i>"""Implementace jednotkových testů."""</i>
&nbsp;
import pytest
&nbsp;
from adder import Complex, init, add, equal
&nbsp;
&nbsp;
def <strong>test_add_basic</strong>():
    <i>"""Otestování výpočtu součtu dvou komplexních čísel."""</i>
    init()
&nbsp;
    c1 = Complex(1.0, 2.0)
    c2 = Complex(3.0, 4.0)
&nbsp;
    result = add(c1, c2)
    expected = Complex(4.0, 6.0)
    assert equal(result, expected), \
        "Očekávaná hodnota {}, vráceno {}".format(expected, result)
</pre>

<p>S&nbsp;výsledkem &ndash; znovu ok:</p>

<pre>
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/native_libs/project8
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 1 item
&nbsp;
test_add.py::test_add_basic PASSED                                       [100%]
&nbsp;
============================== 1 passed in 0.01s ===============================
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Rozšíření knihovny pro práci s&nbsp;komplexními čísly</h2>

<p>Vzhledem k&nbsp;tomu, že v&nbsp;Pythonu je struktura reprezentující
komplexní číslo implementována třídou, nic nám nebrání vytvořit si (tedy
přetížit) vlastní verzi operátoru porovnávání (==):</p>

<pre>
class <strong>Complex</strong>(ctypes.Structure):
    _fields_ = [("real", ctypes.c_float), ("imag", ctypes.c_float)]
&nbsp;
    def <strong>__str__</strong>(self):
        return "Complex: %f + i%f" % (self.real, self.imag)
&nbsp;
    def <strong>__eq__</strong>(self, other):
        return equal(self, other)
</pre>

<p>Výsledná podoba skriptu:</p>

<pre>
<i>"""Základní použití balíčku ctypes, modul pro import."""</i>
&nbsp;
import ctypes
&nbsp;
&nbsp;
library = None
&nbsp;
&nbsp;
def <strong>load_library</strong>(library_name):
    <i>"""Načtení nativní knihovny."""</i>
    return ctypes.CDLL(library_name)
&nbsp;
&nbsp;
def <strong>add</strong>(x, y):
    <i>"""Zavolání externí funkce."""</i>
    return library.add(x, y)
&nbsp;
&nbsp;
def <strong>equal</strong>(x, y):
    <i>"""Zavolání externí funkce."""</i>
    return library.equal(x, y)
&nbsp;
&nbsp;
def <strong>init</strong>():
    global library
    library = load_library("libadder.so")
&nbsp;
    library.add.argtypes = (Complex, Complex)
    library.add.restype = Complex
&nbsp;
    library.equal.argtypes = (Complex, Complex)
    library.equal.restype = bool
&nbsp;
&nbsp;
class <strong>Complex</strong>(ctypes.Structure):
    _fields_ = [("real", ctypes.c_float), ("imag", ctypes.c_float)]
&nbsp;
    def <strong>__str__</strong>(self):
        return "Complex: %f + i%f" % (self.real, self.imag)
&nbsp;
    def <strong>__eq__</strong>(self, other):
        return equal(self, other)
&nbsp;
&nbsp;
def <strong>main</strong>():
    <i>"""Otestování, jestli je možné zavolat nativní funkci."""</i>
    init()
    print(library)
&nbsp;
    c1 = Complex(1.0, 2.0)
    c2 = Complex(3.0, 4.0)
&nbsp;
    c3 = add(c1, c2)
&nbsp;
    print(c1)
    print(c2)
    print(c3)
&nbsp;
    print("c1==c2?", equal(c1, c2))
    print("c2==c2?", equal(c2, c2))
&nbsp;
&nbsp;
if __name__ == '__main__':
    <i># pouze se ujistíme, že lze zavolat nativní funkci</i>
    main()
</pre>

<p>Jeho spušení ověří základní chování přetíženého operátoru:</p>

<pre>
&lt;CDLL 'libadder.so', handle 55fb1a6a4760 at 0x7fe480018390&gt;
Complex: 1.000000 + i2.000000
Complex: 3.000000 + i4.000000
Complex: 4.000000 + i6.000000
c1==c2? False
c2==c2? True
</pre>

<p>Dosti zásadním způsobem se zjednoduší jednotkové testy, v&nbsp;nichž bude
v&nbsp;konstrukci <strong>assert</strong> možné porovnat dvě komplexní čísla
pomocí operátoru ==. Toto je finální podoba jednotkových testů:</p>

<pre>
<i>"""Implementace jednotkových testů."""</i>
&nbsp;
import pytest
&nbsp;
from adder import Complex, init, add, equal
&nbsp;
&nbsp;
def <strong>test_add_basic</strong>():
    <i>"""Otestování výpočtu součtu dvou komplexních čísel."""</i>
    init()
&nbsp;
    c1 = Complex(1.0, 2.0)
    c2 = Complex(3.0, 4.0)
&nbsp;
    result = add(c1, c2)
    expected = Complex(4.0, 6.0)
    assert result == expected, \
        "Očekávaná hodnota {}, vráceno {}".format(expected, result)
&nbsp;
&nbsp;
def <strong>test_add_failure</strong>():
    <i>"""Otestování výpočtu součtu dvou komplexních čísel."""</i>
    init()
&nbsp;
    c1 = Complex(1.0, 2.0)
    c2 = Complex(0.0, 0.0)
&nbsp;
    result = add(c1, c2)
    expected = Complex(4.0, 6.0)
    assert result == expected, \
        "Očekávaná hodnota {}, vráceno {}".format(expected, result)
</pre>

<p>Do skriptu byl naschvál vložen test, který po svém spuštění detekuje chybu,
aby bylo patrné, že i konstrukce <strong>asssert</strong> dokáže díky existenci
metod <strong>__eq__</strong> a <strong>__str__</strong> produkovat velmi
čitelné výsledky:</p>

<pre>
============================= test session starts ==============================
platform linux -- Python 3.6.6, pytest-5.4.2, py-1.5.2, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/ptisnovs/src/python/testing-in-python/native_libs/projectA
plugins: print-0.1.3, voluptuous-1.0.2
collecting ... collected 2 items
&nbsp;
test_add.py::test_add_basic PASSED                                       [ 50%]
test_add.py::test_add_failure FAILED                                     [100%]
&nbsp;
=================================== FAILURES ===================================
_______________________________ test_add_failure _______________________________
&nbsp;
    def test_add_failure():
        """Otestování výpočtu součtu dvou komplexních čísel."""
        init()
&nbsp;
        c1 = Complex(1.0, 2.0)
        c2 = Complex(0.0, 0.0)
&nbsp;
        result = add(c1, c2)
        expected = Complex(4.0, 6.0)
&gt;       assert result == expected, \
            "Očekávaná hodnota {}, vráceno {}".format(expected, result)
E       AssertionError: Očekávaná hodnota Complex: 4.000000 + i6.000000, vráceno Complex: 1.000000 + i2.000000
E       assert &lt;adder.Comple...x7f05abf32c80&gt; == &lt;adder.Comple...x7f05abf32bf8&gt;
E         +&lt;adder.Complex object at 0x7f05abf32c80&gt;
E         -&lt;adder.Complex object at 0x7f05abf32bf8&gt;
&nbsp;
test_add.py:30: AssertionError
=========================== short test summary info ============================
FAILED test_add.py::test_add_failure - AssertionError: Očekávaná hodnota Comp...
========================= 1 failed, 1 passed in 0.04s ==========================
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Nativní knihovny a behavior-driven testing založený na použití knihovny Behave</h2>

<p>S&nbsp;BDD testy jsme se již ve stručnosti seznámili <a
href="https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-od-jednotkovych-testu-az-po-testy-ui/">v&nbsp;úvodním
článku</a> seriálu o testování s&nbsp;využitím Pythonu. Připomeňme si, že i
když je BDD poměrně široký pojem, mnohdy si pod ním představujeme využití <a
href="https://en.wikipedia.org/wiki/Domain-specific_language">doménově
specifického jazyka</a> nazvaného <i>Gherkin</i>. Tento jazyk je díky existenci
mnoha rozhraní integrovatelný do většiny mainstreamových programovacích jazyků,
pochopitelně včetně Pythonu. Dnes si ve stručnosti (znovu) představíme knihovnu
<a href="https://pypi.python.org/pypi/behave">Behave</a>, s&nbsp;jejíž pomocí
se Gherkin integruje právě do jazyka Python. Ve skutečnosti se bude jednat o
téměř ideální spojení, protože Gherkin i Python používají podobný způsob
zápisu, v&nbsp;němž i odsazení jednotlivých programových řádků je součástí
syntaxe (podobně je řešen i jazyk YAML). A protože se zabýváme nativními
knihovnami a jejich testováním, budou (dva) projekty, které si představíme,
testovat právě nativní céčkovou knihovnu (obsahující funkci pro součet dvou
čísel).</p>

<p><div class="rs-tip-major">Poznámka: s&nbsp;kombinací Python+Behave jsme se
již na stránkách Rootu dříve setkali, takže tuto kapitolu i obě kapitoly
následující je vhodné chápat spíše jako doplňující materiál.</div></p>

<a href="https://www.root.cz/obrazek/324266/"><img src="https://i.iinfo.cz/images/634/clojure-cucumber-1-prev.png" class="image-324266" alt="&#160;" width="370" height="198" /></a>
<p><i>Obrázek 1: Ukázka scénářů napsaných v&nbsp;doménově specifickém jazyce Gherkin.</i></p>

<p>Jazyk Gherkin je navržen takovým způsobem, aby ho uživatelé (nemusí se totiž
nutně jednat pouze o programátory) mohli začít používat prakticky okamžitě,
tj.&nbsp;bez nutnosti studia sáhodlouhých manuálů. I z&nbsp;toho důvodu si
možnosti tohoto doménově specifického jazyka postupně ukážeme na několika
demonstračních příkladech. První příklad bude (prozatím) velmi jednoduchý,
protože bude obsahovat jediný modul (naprogramovaný v&nbsp;Pythonu), který
budeme chtít otestovat. I přesto se však bude jednat o plnohodnotný projekt,
jehož struktura odpovídá struktuře projektů složitějších a sofistikovanějších.
Adresář s&nbsp;projektem i s&nbsp;testovacím scénářem by měl vypadat
následovně:</p>

<pre>
├── feature_list.txt
├── features
│   ├── smoketest.feature
│   ├── basic.feature
│   ├── advanced.feature
│   ├── ...
│   ├── ...
│   ├── ...
│   ├── environment.py
│   └── steps
│       ├── common.py
│       ├── ...
│       ├── ...
│       └── ...
├── requirements.in
├── requirements.txt
├── run_tests.sh
└── src
    └── application.py
&nbsp;
3 directories, 7 files
</pre>

<p>V&nbsp;projektu můžeme vidět několik typů souborů:</p>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th></tr>
<tr><td>1</td><td>src/application.py</td><td>vlastní modul, který budeme chtít otestovat</td></tr>
<tr><td>2</td><td>requirements.in/requirements.txt</td><td>soubory pro <strong>pip</strong> (instalátor balíčků jazyka Python)</td></tr>
<tr><td>3</td><td>feature_list.txt</td><td>seznam testovacích scénářů, které se mají spustit</td></tr>
<tr><td>4</td><td>features/*</td><td>adresář obsahující testovací scénáře i implementaci jednotlivých kroků testů</td></tr>
<tr><td>5</td><td>features/*.feature</td><td>jednotlivé testovací scénáře</td></tr>
<tr><td>6</td><td>features/environment.py</td><td>projekt s&nbsp;definicí funkcí vyvolaných před spuštěním testů, před jednotlivými kroky atd.</td></tr>
<tr><td>7</td><td>features/steps/</td><td>implementace jednotlivých testovacích kroků</td></tr>
<tr><td>8</td><td>run_tests.sh</td><td>pomocný skript pro spuštění testovacích scénářů</td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Projekt, v&nbsp;němž budeme testovat vlastnosti nativní funkce</h2>

<p>Nyní se podívejme na strukturu projektu, v&nbsp;němž budeme testovat
základní vlastnosti vybrané nativní funkce na základě testovacího scénáře. Celá
struktura projektu bude založena běžných projektech založených na frameworku
<i>Behave</i>, ovšem s&nbsp;tím rozdílem, že se v&nbsp;projektu nově objevil
adresář <strong>lib</strong> obsahující zdrojový kód napsaný v&nbsp;jazyku C a
skript určený pro vytvoření nativní knihovny:</p>

<pre>
.
├── feature_list.txt
├── features
│   ├── environment.py
│   ├── smoketest.feature
│   └── steps
│       └── common.py
├── lib
│   ├── adder.c
│   ├── clean.sh
│   └── make_library.sh
├── requirements.in
├── requirements.txt
└── run_tests.sh
&nbsp;
3 directories, 10 files
</pre>

<p>Následně je nutné připravit testovací scénář, konkrétně soubor
<strong>smoketest.feature</strong>. Scénář připravíme takovým způsobem, že
budeme očekávat přetečení výsledků za předpokladu, že velikost datového typu
<strong>int</strong> je 32 bitů (a jak jsme mohli vidět v&nbsp;první části
článku, tato situace běžně nastane). V&nbsp;případě, že tato podmínka nebude
splněna, testy selžou:</p>

<pre>
<strong>Feature</strong>: Smoke test
&nbsp;
  <strong>Scenario</strong>: Check the function int add(int, int)
    <strong>Given</strong> The library libadder.so is loaded
    <strong>When</strong> I call native function add with arguments 1 and 2
    <strong>Then</strong> I should get 3 as a result
&nbsp;
  <strong>Scenario Outline</strong>: Thorough checking function int add(int, int)
    <strong>Given</strong> The library libadder.so is loaded
    <strong>When</strong> I call native function add with arguments &lt;x&gt; and &lt;y&gt;
    <strong>Then</strong> I should get &lt;result&gt; as a result
&nbsp;
     <strong>Examples</strong>: result
     |      x    | y| result    |
     # basic arithmetic
     |          0| 0|          0|
     |          1| 2|          3|
     |          1|-2|         -1|
     # no overflows at 16 bit limits
     |      32767| 1|      32768|
     |      65535| 1|      65536|
     # integer overflow
     | 2147483648| 1|-2147483647|
     |-2147483647|-1|-2147483648|
     |-2147483648|-1| 2147483647|
</pre>

<p>Samozřejmě budeme muset připravit i implementaci testovacích kroků. Ovšem
ještě předtím vytvoříme nový soubor nazvaný <strong>environment.py</strong>,
který bude uložen do adresáře <strong>features</strong>, tj.&nbsp;do stejného
adresáře, v&nbsp;němž se nachází i všechny soubory <strong>.feature</strong>.
V&nbsp;tomto modulu budou deklarovány pomocné funkce volané automaticky
interpretrem jazyka Gherkin. Nejdříve provedeme import potřebných modulů
(<strong>ctypes</strong> pro načtení nativní knihovny, druhý modul pro
logování, což prozatím nevyužijeme):</p>

<pre>
from behave.log_capture import capture
import ctypes
</pre>

<p>V&nbsp;tomto modulu si dále vytvoříme pomocnou funkci určenou pro načtení
nativní knihovny a uložení reference na ni do kontextu:</p>

<pre>
def <strong>_load_library</strong>(context, library_name):
    <i>"""Načtení a inicializace nativní knihovny."""</i>
    if context.tested_library is None:
        context.tested_library = ctypes.CDLL(library_name)
</pre>

<p>Důležitá je funkce pojmenovaná <strong>before_all</strong>. Tato funkce je
zavolána <i>automaticky</i> před vlastním testovacím scénářem a typicky se
v&nbsp;ní nastavuje počáteční stav kontextu (což je jediný parametr předaný
funkci při jejím volání):</p>

<pre>
def <strong>before_all</strong>(context):
    <i>"""Perform setup before the first event."""</i>
    context.tested_library = None
    context.load_library = _load_library
</pre>

<p>Implementace kroků testu se nachází v&nbsp;souboru nazvaném
<strong>common.py</strong> (ovšem může být pojmenovaný i jinak &ndash; import
všech souborů v&nbsp;daném adresáři se provádí automaticky). Povšimněte si
provedených změn, především toho, že v&nbsp;klauzuli <strong>given</strong> se
pokusíme načíst nativní knihovnu zadaného jména. Pokud se načtení nativní
knihovny podaří, bude v&nbsp;dalších krocích dostupná v&nbsp;atributu
<strong>context.tested_library</strong>:</p>

<pre>
from behave import given, then, when
&nbsp;
&nbsp;
@<strong>given</strong>('The library {library_name} is loaded')
def <strong>initial_state</strong>(context, library_name):
    context.load_library(context, library_name)
&nbsp;
&nbsp;
@<strong>when</strong>('I call native function add with arguments {x:d} and {y:d}')
def <strong>call_add</strong>(context, x, y):
    context.result = context.tested_library.add(x, y)
&nbsp;
&nbsp;
@<strong>then</strong>('I should get {result:d} as a result')
def <strong>check_integer_result</strong>(context, result):
    assert context.result == result, "Expected result: {e}, returned value: {r}".format(e=result, r=context.result)
</pre>

<p>V&nbsp;případě, že nativní funkce byla korektně přeložena, měly by se po
spuštění skriptu <strong>run_tests.sh</strong> na standardním výstupu objevit
následující řádky produkované knihovnou Behave:</p>

<pre>
Feature: Smoke test # features/smoketest.feature:1
&nbsp;
  @smoketest
  Scenario: Check the function int add(int, int)           # features/smoketest.feature:4
    Given The library libadder.so is loaded                # features/steps/common.py:4
    When I call native function add with arguments 1 and 2 # features/steps/common.py:9
    Then I should get 3 as a result                        # features/steps/common.py:14
&nbsp;
  Scenario Outline: Thorough checking function int add(int, int) -- @1.1 result  # features/smoketest.feature:17
    Given The library libadder.so is loaded                                      # features/steps/common.py:4
    When I call native function add with arguments 0 and 0                       # features/steps/common.py:9
    Then I should get 0 as a result                                              # features/steps/common.py:14
&nbsp;
  Scenario Outline: Thorough checking function int add(int, int) -- @1.2 result  # features/smoketest.feature:18
    Given The library libadder.so is loaded                                      # features/steps/common.py:4
    When I call native function add with arguments 1 and 2                       # features/steps/common.py:9
    Then I should get 3 as a result                                              # features/steps/common.py:14
&nbsp;
  Scenario Outline: Thorough checking function int add(int, int) -- @1.3 result  # features/smoketest.feature:19
    Given The library libadder.so is loaded                                      # features/steps/common.py:4
    When I call native function add with arguments 1 and -2                      # features/steps/common.py:9
    Then I should get -1 as a result                                             # features/steps/common.py:14
&nbsp;
  Scenario Outline: Thorough checking function int add(int, int) -- @1.4 result  # features/smoketest.feature:21
    Given The library libadder.so is loaded                                      # features/steps/common.py:4
    When I call native function add with arguments 32767 and 1                   # features/steps/common.py:9
    Then I should get 32768 as a result                                          # features/steps/common.py:14
&nbsp;
  Scenario Outline: Thorough checking function int add(int, int) -- @1.5 result  # features/smoketest.feature:22
    Given The library libadder.so is loaded                                      # features/steps/common.py:4
    When I call native function add with arguments 65535 and 1                   # features/steps/common.py:9
    Then I should get 65536 as a result                                          # features/steps/common.py:14
&nbsp;
  Scenario Outline: Thorough checking function int add(int, int) -- @1.6 result  # features/smoketest.feature:24
    Given The library libadder.so is loaded                                      # features/steps/common.py:4
    When I call native function add with arguments 2147483648 and 1              # features/steps/common.py:9
    Then I should get -2147483647 as a result                                    # features/steps/common.py:14
&nbsp;
  Scenario Outline: Thorough checking function int add(int, int) -- @1.7 result  # features/smoketest.feature:25
    Given The library libadder.so is loaded                                      # features/steps/common.py:4
    When I call native function add with arguments -2147483647 and -1            # features/steps/common.py:9
    Then I should get -2147483648 as a result                                    # features/steps/common.py:14
&nbsp;
  Scenario Outline: Thorough checking function int add(int, int) -- @1.8 result  # features/smoketest.feature:26
    Given The library libadder.so is loaded                                      # features/steps/common.py:4
    When I call native function add with arguments -2147483648 and -1            # features/steps/common.py:9
    Then I should get 2147483647 as a result                                     # features/steps/common.py:14
&nbsp;
1 feature passed, 0 failed, 0 skipped
9 scenarios passed, 0 failed, 0 skipped
27 steps passed, 0 failed, 0 skipped, 0 undefined
Took 0m0.003s
</pre>

<a href="https://www.root.cz/obrazek/324948/"><img src="https://i.iinfo.cz/images/549/behave1-3-prev.png" class="image-324948" alt="&#160;" width="370" height="266" /></a>
<p><i>Obrázek 2: Výsledek běhu testovacích scénářů ve chvíli, kdy se nativní
funkce chová podle očekávání.</i></p>

<p>V&nbsp;případě, že jsme vynechali krok překladu nativní funkce popř.&nbsp;se
nepodařilo nativní knihovnu vůbec načíst (nebo najít), bude výsledek testů
mnohem delší a pesimističtější:</p>

<pre>
Feature: Smoke test # features/smoketest.feature:1
&nbsp;
  @smoketest
  Scenario: Check the function int add(int, int)           # features/smoketest.feature:4
    Given The library libadder.so is loaded                # features/steps/common.py:4
      Traceback (most recent call last):
        File "/usr/local/lib/python3.4/dist-packages/behave/model.py", line 1456, in run
          match.run(runner.context)
        File "/usr/local/lib/python3.4/dist-packages/behave/model.py", line 1903, in run
          self.func(context, *args, **kwargs)
        File "features/steps/common.py", line 6, in initial_state
          context.load_library(context, library_name)
        File "features/environment.py", line 7, in _load_library
          context.tested_library = ctypes.CDLL(library_name)
        File "/usr/lib/python3.4/ctypes/__init__.py", line 351, in __init__
          self._handle = _dlopen(self._name, mode)
      OSError: libadder.so: cannot open shared object file: No such file or directory
&nbsp;
    When I call native function add with arguments 1 and 2 # None
    Then I should get 3 as a result                        # None
</pre>

<p>...následují informace o pádu všech dalších testů...</p>

<pre>
Failing scenarios:
  features/smoketest.feature:4  Check the function int add(int, int)
  features/smoketest.feature:17  Thorough checking function int add(int, int) -- @1.1 result
  features/smoketest.feature:18  Thorough checking function int add(int, int) -- @1.2 result
  features/smoketest.feature:19  Thorough checking function int add(int, int) -- @1.3 result
  features/smoketest.feature:21  Thorough checking function int add(int, int) -- @1.4 result
  features/smoketest.feature:22  Thorough checking function int add(int, int) -- @1.5 result
  features/smoketest.feature:24  Thorough checking function int add(int, int) -- @1.6 result
  features/smoketest.feature:25  Thorough checking function int add(int, int) -- @1.7 result
  features/smoketest.feature:26  Thorough checking function int add(int, int) -- @1.8 result
&nbsp;
0 features passed, 1 failed, 0 skipped
0 scenarios passed, 9 failed, 0 skipped
0 steps passed, 9 failed, 18 skipped, 0 undefined
Took 0m0.002s
</pre>

<a href="https://www.root.cz/obrazek/324949/"><img src="https://i.iinfo.cz/images/549/behave1-4-prev.png" class="image-324949" alt="&#160;" width="370" height="233" /></a>
<p><i>Obrázek 3: Výsledek běhu testovacího scénáře ve chvíli, kdy se nepodařilo
načíst nativní funkci.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Modifikace testovacího scénáře &ndash; určení typů parametrů předávaných nativní funkci</h2>

<p>Nyní si testovací scénář nepatrně modifikujeme, protože uvedeme i typy
parametrů předávaných do nativní funkce. V&nbsp;následujícím výpisu jsou
změněné části zvýrazněny tučně:</p>

<pre>
Feature: Smoke test
&nbsp;
  Scenario: Check the function int add(int, int)
    Given The library libadder.so is loaded
    When I call native function add with <strong>integer</strong> arguments 1 and 2
    Then I should get 3 as a result
&nbsp;
  Scenario Outline: Thorough checking function int add(int, int)
    Given The library libadder.so is loaded
    When I call native function add with <strong>integer</strong> arguments &lt;x&gt; and &lt;y&gt;
    Then I should get &lt;result&gt; as a result
&nbsp;
     Examples: result
     |x|y|result|
     # basic arithmetic
     |          0| 0|          0|
     |          1| 2|          3|
     |          1|-2|         -1|
     # no overflows at 16 bit limits
     |      32767| 1|      32768|
     |      65535| 1|      65536|
     # integer overflow
     | 2147483648| 1|-2147483647|
     |-2147483647|-1|-2147483648|
     |-2147483648|-1| 2147483647|
</pre>

<p>I jednotlivé implementace testovacích kroků budeme modifikovat. Zejména se
to týká kroku:</p>

<pre>
&bdquo;I call native function <strong>add</strong> with integer arguments {x:d} and {y:d}&ldquo;
</pre>

<p>který je nahrazen za obecnější krok, v&nbsp;němž se jméno funkce vyskytuje
jako proměnný text:</p>

<pre>
&bdquo;I call native function <strong>{function}</strong> with integer arguments {x:d} and {y:d}&ldquo;
</pre>

<p>Podívejme se nyní na způsob zavolání funkce, jejíž <i>jméno</i> je
proměnné:</p>

<pre>
from behave import given, then, when
&nbsp;
&nbsp;
@<strong>given</strong>('The library {library_name} is loaded')
def <strong>initial_state</strong>(context, library_name):
    context.load_library(context, library_name)
&nbsp;
&nbsp;
@<strong>when</strong>('I call native function {function} with integer arguments {x:d} and {y:d}')
def <strong>call_add</strong>(context, function, x, y):
    context.result = <strong>getattr(context.tested_library, function)(x, y)</strong>
&nbsp;
&nbsp;
@<strong>then</strong>('I should get {result:d} as a result')
def <strong>check_integer_result</strong>(context, result):
    assert context.result == result
</pre>

<p><div class="rs-tip-major">Poznámka: tímto způsobem je vlastně možné po
nepatrné úpravě scénáře testovat libovolnou (nativní) funkci.</div></p>

<p>Po spuštění modifikovaného skriptu s&nbsp;testy by se měly na standardním
výstupu objevit tyto zprávy, které nás informují o tom, že se nativní funkce
<strong>add</strong> skutečně chová podle očekávání:</p>

<pre>
Feature: Smoke test # features/smoketest.feature:1
&nbsp;
  Scenario: Check the function int add(int, int)                   # features/smoketest.feature:4
    Given The library libadder.so is loaded                        # features/steps/common.py:4
    When I call native function add with integer arguments 1 and 2 # features/steps/common.py:9
    Then I should get 3 as a result                                # features/steps/common.py:14
&nbsp;
  Scenario Outline: Thorough checking function int add(int, int) -- @1.1 result  # features/smoketest.feature:17
    Given The library libadder.so is loaded                                      # features/steps/common.py:4
    When I call native function add with integer arguments 0 and 0               # features/steps/common.py:9
    Then I should get 0 as a result                                              # features/steps/common.py:14
&nbsp;
  Scenario Outline: Thorough checking function int add(int, int) -- @1.2 result  # features/smoketest.feature:18
    Given The library libadder.so is loaded                                      # features/steps/common.py:4
    When I call native function add with integer arguments 1 and 2               # features/steps/common.py:9
    Then I should get 3 as a result                                              # features/steps/common.py:14
&nbsp;
  Scenario Outline: Thorough checking function int add(int, int) -- @1.3 result  # features/smoketest.feature:19
    Given The library libadder.so is loaded                                      # features/steps/common.py:4
    When I call native function add with integer arguments 1 and -2              # features/steps/common.py:9
    Then I should get -1 as a result                                             # features/steps/common.py:14
&nbsp;
  Scenario Outline: Thorough checking function int add(int, int) -- @1.4 result  # features/smoketest.feature:21
    Given The library libadder.so is loaded                                      # features/steps/common.py:4
    When I call native function add with integer arguments 32767 and 1           # features/steps/common.py:9
    Then I should get 32768 as a result                                          # features/steps/common.py:14
&nbsp;
  Scenario Outline: Thorough checking function int add(int, int) -- @1.5 result  # features/smoketest.feature:22
    Given The library libadder.so is loaded                                      # features/steps/common.py:4
    When I call native function add with integer arguments 65535 and 1           # features/steps/common.py:9
    Then I should get 65536 as a result                                          # features/steps/common.py:14
&nbsp;
  Scenario Outline: Thorough checking function int add(int, int) -- @1.6 result  # features/smoketest.feature:24
    Given The library libadder.so is loaded                                      # features/steps/common.py:4
    When I call native function add with integer arguments 2147483648 and 1      # features/steps/common.py:9
    Then I should get -2147483647 as a result                                    # features/steps/common.py:14
&nbsp;
  Scenario Outline: Thorough checking function int add(int, int) -- @1.7 result  # features/smoketest.feature:25
    Given The library libadder.so is loaded                                      # features/steps/common.py:4
    When I call native function add with integer arguments -2147483647 and -1    # features/steps/common.py:9
    Then I should get -2147483648 as a result                                    # features/steps/common.py:14
&nbsp;
  Scenario Outline: Thorough checking function int add(int, int) -- @1.8 result  # features/smoketest.feature:26
    Given The library libadder.so is loaded                                      # features/steps/common.py:4
    When I call native function add with integer arguments -2147483648 and -1    # features/steps/common.py:9
    Then I should get 2147483647 as a result                                     # features/steps/common.py:14
&nbsp;
1 feature passed, 0 failed, 0 skipped
9 scenarios passed, 0 failed, 0 skipped
27 steps passed, 0 failed, 0 skipped, 0 undefined
Took 0m0.003s
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
nového Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/testing-in-python">https://github.com/tisnik/testing-in-python</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem &ndash;
alespoň prozatím &ndash; velmi malý, dnes má přibližně několik desítek
kilobajtů), můžete namísto toho použít odkazy na jednotlivé demonstrační
příklady a jejich části, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Zdrojový soubor</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>project1/adder.c</td><td>implementace nativní funkce <strong>add</strong></td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project1/adder.c">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project1/adder.c</a></td></tr>
<tr><td> 2</td><td>project1/call_from_python.py</td><td>zavolání nativní funkce z&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project1/call_from_python.py">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project1/call_from_python.py</a></td></tr>
<tr><td> 3</td><td>project1/make_library.sh</td><td>skript pro překlad nativní knihovny</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project1/make_library.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project1/make_library.sh</a></td></tr>
<tr><td> 4</td><td>project1/run.sh</td><td>skript pro spuštění příkladu</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project1/run.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project1/run.sh</a></td></tr>
<tr><td> 5</td><td>project1/clean.sh</td><td>skript pro vyčištění přeložené knihovny i objektového souboru</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project1/clean.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project1/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>project2/adder.c</td><td>implementace nativní funkce <strong>add</strong></td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project2/adder.c">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project2/adder.c</a></td></tr>
<tr><td> 7</td><td>project2/adder.py</td><td>obalení nativní funkce Pythonovským kódem</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project2/adder.py">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project2/adder.py</a></td></tr>
<tr><td> 8</td><td>project2/call_from_python.py</td><td>zavolání nativní funkce z&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project2/call_from_python.py">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project2/call_from_python.py</a></td></tr>
<tr><td> 9</td><td>project2/make_library.sh</td><td>skript pro překlad nativní knihovny</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project2/make_library.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project2/make_library.sh</a></td></tr>
<tr><td>10</td><td>project2/run.sh</td><td>skript pro spuštění příkladu</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project2/run.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project2/run.sh</a></td></tr>
<tr><td>11</td><td>project2/clean.sh</td><td>skript pro vyčištění přeložené knihovny i objektového souboru</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project2/clean.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project2/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>project3/adder.c</td><td>implementace nativní funkce <strong>add</strong></td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project3/adder.c">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project3/adder.c</a></td></tr>
<tr><td>13</td><td>project3/adder.py</td><td>obalení nativní funkce Pythonovským kódem</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project3/adder.py">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project3/adder.py</a></td></tr>
<tr><td>14</td><td>project3/test_add.py</td><td>implementace jednotkového testu</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project3/test_add.py">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project3/test_add.py</a></td></tr>
<tr><td>15</td><td>project3/make_library.sh</td><td>skript pro překlad nativní knihovny</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project3/make_library.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project3/make_library.sh</a></td></tr>
<tr><td>16</td><td>project3/test.sh</td><td>skript pro spuštění jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project3/test.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project3/test.sh</a></td></tr>
<tr><td>17</td><td>project3/clean.sh</td><td>skript pro vyčištění přeložené knihovny i objektového souboru</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project3/clean.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project3/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>project4/adder.c</td><td>implementace nativní funkce <strong>add</strong></td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project4/adder.c">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project4/adder.c</a></td></tr>
<tr><td>19</td><td>project4/adder.py</td><td>obalení nativní funkce Pythonovským kódem</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project4/adder.py">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project4/adder.py</a></td></tr>
<tr><td>20</td><td>project4/test_add.py</td><td>implementace jednotkového testu</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project4/test_add.py">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project4/test_add.py</a></td></tr>
<tr><td>21</td><td>project4/make_library.sh</td><td>skript pro překlad nativní knihovny</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project4/make_library.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project4/make_library.sh</a></td></tr>
<tr><td>22</td><td>project4/test.sh</td><td>skript pro spuštění jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project4/test.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project4/test.sh</a></td></tr>
<tr><td>23</td><td>project4/clean.sh</td><td>skript pro vyčištění přeložené knihovny i objektového souboru</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project4/clean.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project4/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>24</td><td>project5/test_stdlib.py</td><td>otestování nativních funkcí <strong>time()</strong> a <strong>abs()</strong></td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project5/test_stdlib.py">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project5/test_stdlib.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>project6/test_stdlib.py</td><td>otestování nativní funkce <strong>strlen()</strong> pro Unicode string</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project6/test_stdlib.py">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project6/test_stdlib.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>project7/test_stdlib.py</td><td>otestování nativní funkce <strong>strlen()</strong> pro bajtové pole</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project7/test_stdlib.py">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project7/test_stdlib.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>27</td><td>project8/adder.c</td><td>implementace nativní funkce <strong>add</strong> pro komplexní čísla</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project8/adder.c">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project8/adder.c</a></td></tr>
<tr><td>28</td><td>project8/adder.py</td><td>obalení nativní funkce Pythonovským kódem</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project8/adder.py">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project8/adder.py</a></td></tr>
<tr><td>29</td><td>project8/test_add.py</td><td>implementace jednotkového testu</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project8/test_add.py">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project8/test_add.py</a></td></tr>
<tr><td>30</td><td>project8/make_library.sh</td><td>skript pro překlad nativní knihovny</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project8/make_library.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project8/make_library.sh</a></td></tr>
<tr><td>31</td><td>project8/test.sh</td><td>skript pro spuštění jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project8/test.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project8/test.sh</a></td></tr>
<tr><td>32</td><td>project8/clean.sh</td><td>skript pro vyčištění přeložené knihovny i objektového souboru</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project8/clean.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project8/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>project9/adder.c</td><td>implementace nativní funkce <strong>add</strong> pro komplexní čísla</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project9/adder.c">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project9/adder.c</a></td></tr>
<tr><td>34</td><td>project9/adder.py</td><td>obalení nativní funkce Pythonovským kódem</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project9/adder.py">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project9/adder.py</a></td></tr>
<tr><td>35</td><td>project9/test_add.py</td><td>implementace jednotkového testu</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project9/test_add.py">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project9/test_add.py</a></td></tr>
<tr><td>36</td><td>project9/make_library.sh</td><td>skript pro překlad nativní knihovny</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project9/make_library.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project9/make_library.sh</a></td></tr>
<tr><td>37</td><td>project9/test.sh</td><td>skript pro spuštění jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project9/test.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project9/test.sh</a></td></tr>
<tr><td>38</td><td>project9/clean.sh</td><td>skript pro vyčištění přeložené knihovny i objektového souboru</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/project9/clean.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/project9/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>39</td><td>projectA/adder.c</td><td>implementace nativní funkce <strong>add</strong> pro komplexní čísla</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/projectA/adder.c">https://github.com/tisnik/testing-in-python/tree/master/native_libs/projectA/adder.c</a></td></tr>
<tr><td>40</td><td>projectA/adder.py</td><td>obalení nativní funkce Pythonovským kódem</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/projectA/adder.py">https://github.com/tisnik/testing-in-python/tree/master/native_libs/projectA/adder.py</a></td></tr>
<tr><td>41</td><td>projectA/test_add.py</td><td>implementace jednotkového testu</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/projectA/test_add.py">https://github.com/tisnik/testing-in-python/tree/master/native_libs/projectA/test_add.py</a></td></tr>
<tr><td>42</td><td>projectA/make_library.sh</td><td>skript pro překlad nativní knihovny</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/projectA/make_library.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/projectA/make_library.sh</a></td></tr>
<tr><td>43</td><td>projectA/test.sh</td><td>skript pro spuštění jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/projectA/test.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/projectA/test.sh</a></td></tr>
<tr><td>44</td><td>projectA/clean.sh</td><td>skript pro vyčištění přeložené knihovny i objektového souboru</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/projectA/clean.sh">https://github.com/tisnik/testing-in-python/tree/master/native_libs/projectA/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>45</td><td>test_native_lib1</td><td>projekt založený na frameworku Behave</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/test_native_lib1">https://github.com/tisnik/testing-in-python/tree/master/native_libs/test_native_lib1/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>46</td><td>test_native_lib1</td><td>projekt založený na frameworku Behave</td><td><a href="https://github.com/tisnik/testing-in-python/tree/master/native_libs/test_native_lib1">https://github.com/tisnik/testing-in-python/tree/master/native_libs/test_native_lib1/</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články s&nbsp;tématem testování (nejenom) v&nbsp;Pythonu</h2>

<p>Tématem testování jsme se již na stránkách Rootu několikrát zabývali. Jedná
se mj.&nbsp;o následující články:</p>

<ol>

<li>Použití Pythonu pro tvorbu testů: od jednotkových testů až po testy UI<br />
<a href="https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-od-jednotkovych-testu-az-po-testy-ui/">https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-od-jednotkovych-testu-az-po-testy-ui/</a>
</li>

<li>Použití Pythonu pro tvorbu testů: použití třídy Mock z knihovny unittest.mock<br />
<a href="https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-pouziti-tridy-mock-z-knihovny-unittest-mock/">https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-pouziti-tridy-mock-z-knihovny-unittest-mock/</a>
</li>

<li>Použití nástroje pytest pro tvorbu jednotkových testů a benchmarků<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-pytest-pro-tvorbu-jednotkovych-testu-a-benchmarku/">https://www.root.cz/clanky/pouziti-nastroje-pytest-pro-tvorbu-jednotkovych-testu-a-benchmarku/</a>
</li>

<li>Nástroj pytest a jednotkové testy: fixtures, výjimky, parametrizace testů<br />
<a href="https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-fixtures-vyjimky-parametrizace-testu/">https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-fixtures-vyjimky-parametrizace-testu/</a>
</li>

<li>Nástroj pytest a jednotkové testy: životní cyklus testů, užitečné tipy a triky<br />
<a href="https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-zivotni-cyklus-testu-uzitecne-tipy-a-triky/">https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-zivotni-cyklus-testu-uzitecne-tipy-a-triky/</a>
</li>

<li>Struktura projektů s jednotkovými testy, využití Travis CI<br />
<a href="https://www.root.cz/clanky/struktura-projektu-s-jednotkovymi-testy-vyuziti-travis-ci/">https://www.root.cz/clanky/struktura-projektu-s-jednotkovymi-testy-vyuziti-travis-ci/</a>
</li>

<li>Omezení stavového prostoru testovaných funkcí a metod<br />
<a href="https://www.root.cz/clanky/omezeni-stavoveho-prostoru-testovanych-funkci-a-metod/">https://www.root.cz/clanky/omezeni-stavoveho-prostoru-testovanych-funkci-a-metod/</a>
</li>

<li>Testování aplikací s využitím nástroje Hypothesis<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-s-vyuzitim-nastroje-hypothesis/">https://www.root.cz/clanky/testovani-aplikaci-s-vyuzitim-nastroje-hypothesis/</a>
</li>

<li>Testování aplikací s využitím nástroje Hypothesis (dokončení)<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-s-vyuzitim-nastroje-hypothesis-dokonceni/">https://www.root.cz/clanky/testovani-aplikaci-s-vyuzitim-nastroje-hypothesis-dokonceni/</a>
</li>

<li>Testování webových aplikací s&nbsp;REST API z&nbsp;Pythonu<br />
<a href="https://www.root.cz/clanky/testovani-webovych-aplikaci-s-rest-api-z-pythonu/">https://www.root.cz/clanky/testovani-webovych-aplikaci-s-rest-api-z-pythonu/</a>
</li>

<li>Testování webových aplikací s&nbsp;REST API z&nbsp;Pythonu (2)<br />
<a href="https://www.root.cz/clanky/testovani-webovych-aplikaci-s-rest-api-z-pythonu-2/">https://www.root.cz/clanky/testovani-webovych-aplikaci-s-rest-api-z-pythonu-2/</a>
</li>

<li>Testování webových aplikací s&nbsp;REST API z&nbsp;Pythonu (3)<br />
<a href="https://www.root.cz/clanky/testovani-webovych-aplikaci-s-rest-api-z-pythonu-3/">https://www.root.cz/clanky/testovani-webovych-aplikaci-s-rest-api-z-pythonu-3/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave (druhá část)<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-druha-cast/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-druha-cast/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave (závěrečná část)<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-zaverecna-cast/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-zaverecna-cast/</a>
</li>

<li>Validace datových struktur v Pythonu pomocí knihoven Schemagic a Schema<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/</a>
</li>

<li>Validace datových struktur v Pythonu (2. část)<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-2-cast/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-2-cast/</a>
</li>

<li>Validace datových struktur v Pythonu (dokončení)<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-dokonceni/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-dokonceni/</a>
</li>

<li>Univerzální testovací nástroj Robot Framework<br />
<a href="https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework/">https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework/</a>
</li>

<li>Univerzální testovací nástroj Robot Framework a BDD testy<br />
<a href="https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework-a-bdd-testy/">https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework-a-bdd-testy/</a>
</li>

<li>Úvod do problematiky fuzzingu a fuzz testování<br />
<a href="https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani/">https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani/</a>
</li>

<li>Úvod do problematiky fuzzingu a fuzz testování – složení vlastního fuzzeru<br />
<a href="https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani-slozeni-vlastniho-fuzzeru/">https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani-slozeni-vlastniho-fuzzeru/</a>
</li>

<li>Knihovny a moduly usnadňující testování aplikací naprogramovaných v jazyce Clojure<br />
<a href="https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/">https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/</a>
</li>

<li>Validace dat s využitím knihovny spec v Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

<li>Testování aplikací naprogramovaných v jazyce Go<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/">https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/</a>
</li>

<li>Knihovny určené pro tvorbu testů v programovacím jazyce Go<br />
<a href="https://www.root.cz/clanky/knihovny-urcene-pro-tvorbu-testu-v-programovacim-jazyce-go/">https://www.root.cz/clanky/knihovny-urcene-pro-tvorbu-testu-v-programovacim-jazyce-go/</a>
</li>

<li>Testování aplikací psaných v Go s využitím knihoven Goblin a Frisby<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/">https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/</a>
</li>

<li>Testování Go aplikací s využitím knihovny GΩmega a frameworku Ginkgo<br />
<a href="https://www.root.cz/clanky/testovani-go-aplikaci-s-vyuzitim-knihovny-gomega-mega-a-frameworku-ginkgo/">https://www.root.cz/clanky/testovani-go-aplikaci-s-vyuzitim-knihovny-gomega-mega-a-frameworku-ginkgo/</a>
</li>

<li>Tvorba BDD testů s využitím jazyka Go a nástroje godog<br />
<a href="https://www.root.cz/clanky/tvorba-bdd-testu-s-vyuzitim-jazyka-go-a-nastroje-godog/">https://www.root.cz/clanky/tvorba-bdd-testu-s-vyuzitim-jazyka-go-a-nastroje-godog/</a>
</li>

<li>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem<br />
<a href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/">https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/</a>
</li>

<li>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem (dokončení)<br />
<a href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem-dokonceni/">https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem-dokonceni/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure (2)<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Dokumentace k&nbsp;CFFI<br />
<a href="https://cffi.readthedocs.io/en/latest/overview.html">https://cffi.readthedocs.io/en/latest/overview.html</a>
</li>

<li>How can use CFFI to call an existing C function given the source code?<br />
<a href="https://stackoverflow.com/questions/37936045/how-can-use-cffi-to-call-an-existing-c-function-given-the-source-code">https://stackoverflow.com/questions/37936045/how-can-use-cffi-to-call-an-existing-c-function-given-the-source-code</a>
</li>

<li>Python Bindings: Calling C or C++ From Python<br />
<a href="https://realpython.com/python-bindings-overview/">https://realpython.com/python-bindings-overview/</a>
</li>

<li>Wrapping a C library in Python: C, Cython or ctypes?<br />
<a href="https://stackoverflow.com/questions/1942298/wrapping-a-c-library-in-python-c-cython-or-ctypes">https://stackoverflow.com/questions/1942298/wrapping-a-c-library-in-python-c-cython-or-ctypes</a>
</li>

<li>Calling Rust From Python<br />
<a href="https://bheisler.github.io/post/calling-rust-in-python/">https://bheisler.github.io/post/calling-rust-in-python/</a>
</li>

<li>Calling Rust in Python (komentáře k předchozímu článku)<br />
<a href="https://www.reddit.com/r/rust/comments/63iy5a/calling_rust_in_python/">https://www.reddit.com/r/rust/comments/63iy5a/calling_rust_in_python/</a>
</li>

<li>CFFI Documentation<br />
<a href="https://cffi.readthedocs.io/en/latest/">https://cffi.readthedocs.io/en/latest/</a>
</li>

<li>Build Script Support<br />
<a href="http://doc.crates.io/build-script.html">http://doc.crates.io/build-script.html</a>
</li>

<li>Creating a shared and static library with the gnu compiler [gcc]<br />
<a href="http://www.adp-gmbh.ch/cpp/gcc/create_lib.html">http://www.adp-gmbh.ch/cpp/gcc/create_lib.html</a>
</li>

<li>ctypes — A foreign function library for Python<br />
<a href="https://docs.python.org/2/library/ctypes.html">https://docs.python.org/2/library/ctypes.html</a>
</li>

<li>FFI: Foreign Function Interface<br />
<a href="https://doc.rust-lang.org/book/ffi.html">https://doc.rust-lang.org/book/ffi.html</a>
</li>

<li>Primitive Type pointer<br />
<a href="https://doc.rust-lang.org/std/primitive.pointer.html">https://doc.rust-lang.org/std/primitive.pointer.html</a>
</li>

<li>Requests: HTTP for Humans (dokumentace)<br />
<a href="http://docs.python-requests.org/en/master/">http://docs.python-requests.org/en/master/</a>
</li>

<li>Requests: Introduction<br />
<a href="http://docs.python-requests.org/en/latest/user/intro/">http://docs.python-requests.org/en/latest/user/intro/</a>
</li>

<li>Requests na GitHubu<br />
<a href="https://github.com/requests/requests">https://github.com/requests/requests</a>
</li>

<li>Requests (software) na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Requests_%28software%29">https://en.wikipedia.org/wiki/Requests_%28software%29</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>20 Python libraries you can’t live without<br />
<a href="https://pythontips.com/2013/07/30/20-python-libraries-you-cant-live-without/">https://pythontips.com/2013/07/30/20-python-libraries-you-cant-live-without/</a>
</li>

<li>What are the top 10 most useful and influential Python libraries and frameworks?<br />
<a href="https://www.quora.com/What-are-the-top-10-most-useful-and-influential-Python-libraries-and-frameworks">https://www.quora.com/What-are-the-top-10-most-useful-and-influential-Python-libraries-and-frameworks</a>
</li>

<li>Python: useful modules<br />
<a href="https://wiki.python.org/moin/UsefulModules">https://wiki.python.org/moin/UsefulModules</a>
</li>

<li>Top 15 most popular Python libraries<br />
<a href="https://keyua.org/blog/most-popular-python-libraries/">https://keyua.org/blog/most-popular-python-libraries/</a>
</li>

<li>Hypertext Transfer Protocol<br />
<a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a>
</li>

<li>List of HTTP header fields<br />
<a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">https://en.wikipedia.org/wiki/List_of_HTTP_header_fields</a>
</li>

<li>List of HTTP status codes<br />
<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">https://en.wikipedia.org/wiki/List_of_HTTP_status_codes</a>
</li>

<li>Python requests deep dive<br />
<a href="https://medium.com/@anthonypjshaw/python-requests-deep-dive-a0a5c5c1e093">https://medium.com/@anthonypjshaw/python-requests-deep-dive-a0a5c5c1e093</a>
</li>

<li>The awesome requests module<br />
<a href="https://www.pythonforbeginners.com/requests/the-awesome-requests-module">https://www.pythonforbeginners.com/requests/the-awesome-requests-module</a>
</li>

<li>Send HTTP Requests in Python<br />
<a href="https://code-maven.com/http-requests-in-python">https://code-maven.com/http-requests-in-python</a>
</li>

<li>Introducing JSON<br />
<a href="http://json.org/">http://json.org/</a>
</li>

<li>Writing tests for RESTful APIs in Python using requests – part 1: basic tests<br />
<a href="https://www.ontestautomation.com/writing-tests-for-restful-apis-in-python-using-requests-part-1-basic-tests/">https://www.ontestautomation.com/writing-tests-for-restful-apis-in-python-using-requests-part-1-basic-tests/</a>
</li>

<li>Step by Step Rest API Testing using Python + Pytest + Allure<br />
<a href="https://www.udemy.com/course/api-testing-python/">https://www.udemy.com/course/api-testing-python/</a>
</li>

<li>Prime formulas and polynomial functions<br />
<a href="https://en.wikipedia.org/wiki/Formula_for_primes#Prime_formulas_and_polynomial_functions">https://en.wikipedia.org/wiki/Formula_for_primes#Prime_formulas_and_polynomial_functions</a>
</li>

<li>Prime-Generating Polynomial<br />
<a href="https://mathworld.wolfram.com/Prime-GeneratingPolynomial.html">https://mathworld.wolfram.com/Prime-GeneratingPolynomial.html</a>
</li>

<li>Hoare logic<br />
<a href="https://en.wikipedia.org/wiki/Hoare_logic">https://en.wikipedia.org/wiki/Hoare_logic</a>
</li>

<li>Goto Fail, Heartbleed, and Unit Testing Culture<br />
<a href="https://martinfowler.com/articles/testing-culture.html">https://martinfowler.com/articles/testing-culture.html</a>
</li>

<li>PEP-484<br />
<a href="https://www.python.org/dev/peps/pep-0484/">https://www.python.org/dev/peps/pep-0484/</a>
</li>

<li>In-depth: Functional programming in C++<br />
<a href="https://www.gamasutra.com/view/news/169296/Indepth_Functional_programming_in_C.php">https://www.gamasutra.com/view/news/169296/Indepth_Functional_programming_in_C.php</a>
</li>

<li>mypy<br />
<a href="http://www.mypy-lang.org/">http://www.mypy-lang.org/</a>
</li>

<li>Welcome to Mypy documentation!<br />
<a href="https://mypy.readthedocs.io/en/latest/index.html">https://mypy.readthedocs.io/en/latest/index.html</a>
</li>

<li>mypy na GitHubu<br />
<a href="https://github.com/python/mypy">https://github.com/python/mypy</a>
</li>

<li>mypy 0.770 na PyPi<br />
<a href="https://pypi.org/project/mypy/">https://pypi.org/project/mypy/</a>
</li>

<li>Extensions for mypy (separated out from mypy/extensions)<br />
<a href="https://github.com/python/mypy_extensions">https://github.com/python/mypy_extensions</a>
</li>

<li>The Mypy Blog<br />
<a href="https://mypy-lang.blogspot.com/2020/03/mypy-0770-released.html">https://mypy-lang.blogspot.com/2020/03/mypy-0770-released.html</a>
</li>

<li>Our journey to type checking 4 million lines of Python<br />
<a href="https://dropbox.tech/application/our-journey-to-type-checking-4-million-lines-of-python">https://dropbox.tech/application/our-journey-to-type-checking-4-million-lines-of-python</a>
</li>

<li>Type-Checking Python Programs With Type Hints and mypy<br />
<a href="https://www.youtube.com/watch?v=2xWhaALHTvU">https://www.youtube.com/watch?v=2xWhaALHTvU</a>
</li>

<li>Refactoring to Immutability - Kevlin Henney<br />
<a href="https://www.youtube.com/watch?v=APUCMSPiNh4">https://www.youtube.com/watch?v=APUCMSPiNh4</a>
</li>

<li>Bernat Gabor - Type hinting (and mypy) - PyCon 2019<br />
<a href="https://www.youtube.com/watch?v=hTrjTAPnA_k">https://www.youtube.com/watch?v=hTrjTAPnA_k</a>
</li>

<li>Stanford Seminar - Optional Static Typing for Python<br />
<a href="https://www.youtube.com/watch?v=GiZKuyLKvAA">https://www.youtube.com/watch?v=GiZKuyLKvAA</a>
</li>

<li>mypy Getting to Four Million Lines of Typed Python - Michael Sullivan<br />
<a href="https://www.youtube.com/watch?v=FT_WHV4-QcU">https://www.youtube.com/watch?v=FT_WHV4-QcU</a>
</li>

<li>Shebang<br />
<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">https://en.wikipedia.org/wiki/Shebang_(Unix)</a>
</li>

<li>pytest 5.4.2 na PyPi<br />
<a href="https://pypi.org/project/pytest/">https://pypi.org/project/pytest/</a>
</li>

<li>Hillel Wayne - Beyond Unit Tests: Taking Your Testing to the Next Level - PyCon 2018<br />
<a href="https://www.youtube.com/watch?v=MYucYon2-lk">https://www.youtube.com/watch?v=MYucYon2-lk</a>
</li>

<li>Awesome Python &ndash; testing<br />
<a href="https://github.com/vinta/awesome-python#testing">https://github.com/vinta/awesome-python#testing</a>
</li>

<li>pytest Plugins Compatibility<br />
<a href="http://plugincompat.herokuapp.com/">http://plugincompat.herokuapp.com/</a>
</li>

<li>Selenium (pro Python)<br />
<a href="https://pypi.org/project/selenium/">https://pypi.org/project/selenium/</a>
</li>

<li>Getting Started With Testing in Python<br />
<a href="https://realpython.com/python-testing/">https://realpython.com/python-testing/</a>
</li>

<li>unittest.mock — mock object library<br />
<a href="https://docs.python.org/3.5/library/unittest.mock.html">https://docs.python.org/3.5/library/unittest.mock.html</a>
</li>

<li>mock 2.0.0<br />
<a href="https://pypi.python.org/pypi/mock">https://pypi.python.org/pypi/mock</a>
</li>

<li>An Introduction to Mocking in Python<br />
<a href="https://www.toptal.com/python/an-introduction-to-mocking-in-python">https://www.toptal.com/python/an-introduction-to-mocking-in-python</a>
</li>

<li>Mock - Mocking and Testing Library<br />
<a href="http://mock.readthedocs.io/en/stable/">http://mock.readthedocs.io/en/stable/</a>
</li>

<li>Python Mocking 101: Fake It Before You Make It<br />
<a href="https://blog.fugue.co/2016-02-11-python-mocking-101.html">https://blog.fugue.co/2016-02-11-python-mocking-101.html</a>
</li>

<li>Nauč se Python! - Testování<br />
<a href="http://naucse.python.cz/lessons/intro/testing/">http://naucse.python.cz/lessons/intro/testing/</a>
</li>

<li>Flexmock (dokumentace)<br />
<a href="https://flexmock.readthedocs.io/en/latest/">https://flexmock.readthedocs.io/en/latest/</a>
</li>

<li>Test Fixture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test_fixture">https://en.wikipedia.org/wiki/Test_fixture</a>
</li>

<li>Mock object (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Mock_object">https://en.wikipedia.org/wiki/Mock_object</a>
</li>

<li>Extrémní programování<br />
<a href="https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD">https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD</a>
</li>

<li>Programování řízené testy<br />
<a href="https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy">https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>Tox<br />
<a href="https://tox.readthedocs.io/en/latest/">https://tox.readthedocs.io/en/latest/</a>
</li>

<li>pytest: helps you write better programs<br />
<a href="https://docs.pytest.org/en/latest/">https://docs.pytest.org/en/latest/</a>
</li>

<li>doctest — Test interactive Python examples<br />
<a href="https://docs.python.org/dev/library/doctest.html#module-doctest">https://docs.python.org/dev/library/doctest.html#module-doctest</a>
</li>

<li>unittest — Unit testing framework<br />
<a href="https://docs.python.org/dev/library/unittest.html">https://docs.python.org/dev/library/unittest.html</a>
</li>

<li>Python namespaces<br />
<a href="https://bytebaker.com/2008/07/30/python-namespaces/">https://bytebaker.com/2008/07/30/python-namespaces/</a>
</li>

<li>Namespaces and Scopes<br />
<a href="https://www.python-course.eu/namespaces.php">https://www.python-course.eu/namespaces.php</a>
</li>

<li>Stránka projektu Robot Framework<br />
<a href="https://robotframework.org/">https://robotframework.org/</a>
</li>

<li>GitHub repositář Robot Frameworku<br />
<a href="https://github.com/robotframework/robotframework">https://github.com/robotframework/robotframework</a>
</li>

<li>Robot Framework (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Robot_Framework">https://en.wikipedia.org/wiki/Robot_Framework</a>
</li>

<li>Tutoriál Robot Frameworku<br />
<a href="http://www.robotframeworktutorial.com/">http://www.robotframeworktutorial.com/</a>
</li>

<li>Robot Framework Documentation<br />
<a href="https://robotframework.org/robotframework/">https://robotframework.org/robotframework/</a>
</li>

<li>Robot Framework Introduction<br />
<a href="https://blog.testproject.io/2016/11/22/robot-framework-introduction/">https://blog.testproject.io/2016/11/22/robot-framework-introduction/</a>
</li>

<li>robotframework 3.1.2 na PyPi<br />
<a href="https://pypi.org/project/robotframework/">https://pypi.org/project/robotframework/</a>
</li>

<li>Robot Framework demo (GitHub)<br />
<a href="https://github.com/robotframework/RobotDemo">https://github.com/robotframework/RobotDemo</a>
</li>

<li>Robot Framework web testing demo using SeleniumLibrary<br />
<a href="https://github.com/robotframework/WebDemo">https://github.com/robotframework/WebDemo</a>
</li>

<li>Robot Framework for Mobile Test Automation Demo<br />
<a href="https://www.youtube.com/watch?v=06LsU08slP8">https://www.youtube.com/watch?v=06LsU08slP8</a>
</li>

<li>Gherkin<br />
<a href="https://cucumber.io/docs/gherkin/">https://cucumber.io/docs/gherkin/</a>
</li>

<li>Selenium<br />
<a href="https://selenium.dev/">https://selenium.dev/</a>
</li>

<li>SeleniumLibrary<br />
<a href="https://robotframework.org/">https://robotframework.org/</a>
</li>

<li>The Practical Test Pyramid<br />
<a href="https://martinfowler.com/articles/practical-test-pyramid.html">https://martinfowler.com/articles/practical-test-pyramid.html</a>
</li>

<li>Acceptance Tests and the Testing Pyramid<br />
<a href="http://www.blog.acceptancetestdrivendevelopment.com/acceptance-tests-and-the-testing-pyramid/">http://www.blog.acceptancetestdrivendevelopment.com/acceptance-tests-and-the-testing-pyramid/</a>
</li>

<li>Tab-separated values<br />
<a href="https://en.wikipedia.org/wiki/Tab-separated_values">https://en.wikipedia.org/wiki/Tab-separated_values</a>
</li>

<li>A quick guide about Python implementations<br />
<a href="https://blog.rmotr.com/a-quick-guide-about-python-implementations-aa224109f321">https://blog.rmotr.com/a-quick-guide-about-python-implementations-aa224109f321</a>
</li>

<li>radamsa<br />
<a href="https://gitlab.com/akihe/radamsa">https://gitlab.com/akihe/radamsa</a>
</li>

<li>Fuzzing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Fuzzing">https://en.wikipedia.org/wiki/Fuzzing</a>
</li>

<li>american fuzzy lop<br />
<a href="http://lcamtuf.coredump.cx/afl/">http://lcamtuf.coredump.cx/afl/</a>
</li>

<li>Fuzzing: the new unit testing<br />
<a href="https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide#1">https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide#1</a>
</li>

<li>Corpus for github.com/dvyukov/go-fuzz examples<br />
<a href="https://github.com/dvyukov/go-fuzz-corpus">https://github.com/dvyukov/go-fuzz-corpus</a>
</li>

<li>AFL &ndash; QuickStartGuide.txt<br />
<a href="https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt">https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt</a>
</li>

<li>Introduction to Fuzzing in Python with AFL<br />
<a href="https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/">https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/</a>
</li>

<li>Writing a Simple Fuzzer in Python<br />
<a href="https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/">https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/</a>
</li>

<li>How to Fuzz Go Code with go-fuzz (Continuously)<br />
<a href="https://fuzzit.dev/2019/10/02/how-to-fuzz-go-code-with-go-fuzz-continuously/">https://fuzzit.dev/2019/10/02/how-to-fuzz-go-code-with-go-fuzz-continuously/</a>
</li>

<li>Golang Fuzzing: A go-fuzz Tutorial and Example<br />
<a href="http://networkbit.ch/golang-fuzzing/">http://networkbit.ch/golang-fuzzing/</a>
</li>

<li>Fuzzing Python Modules<br />
<a href="https://stackoverflow.com/questions/20749026/fuzzing-python-modules">https://stackoverflow.com/questions/20749026/fuzzing-python-modules</a>
</li>

<li>0x3 Python Tutorial: Fuzzer<br />
<a href="http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/">http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/</a>
</li>

<li>fuzzing na PyPi<br />
<a href="https://pypi.org/project/fuzzing/">https://pypi.org/project/fuzzing/</a>
</li>

<li>Fuzzing 0.3.2 documentation<br />
<a href="https://fuzzing.readthedocs.io/en/latest/">https://fuzzing.readthedocs.io/en/latest/</a>
</li>

<li>Randomized testing for Go<br />
<a href="https://github.com/dvyukov/go-fuzz">https://github.com/dvyukov/go-fuzz</a>
</li>

<li>HTTP/2 fuzzer written in Golang<br />
<a href="https://github.com/c0nrad/http2fuzz">https://github.com/c0nrad/http2fuzz</a>
</li>

<li>Ffuf (Fuzz Faster U Fool) – An Open Source Fast Web Fuzzing Tool<br />
<a href="https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html">https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html</a>
</li>

<li>Continuous Fuzzing Made Simple<br />
<a href="https://fuzzit.dev/">https://fuzzit.dev/</a>
</li>

<li>Halt and Catch Fire<br />
<a href="https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86">https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86</a>
</li>

<li>Random testing<br />
<a href="https://en.wikipedia.org/wiki/Random_testing">https://en.wikipedia.org/wiki/Random_testing</a>
</li>

<li>Monkey testing<br />
<a href="https://en.wikipedia.org/wiki/Monkey_testing">https://en.wikipedia.org/wiki/Monkey_testing</a>
</li>

<li>Fuzzing for Software Security Testing and Quality Assurance, Second Edition<br />
<a href="https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false">https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false</a>
</li>

<li>libFuzzer – a library for coverage-guided fuzz testing<br />
<a href="https://llvm.org/docs/LibFuzzer.html">https://llvm.org/docs/LibFuzzer.html</a>
</li>

<li>fuzzy-swagger na PyPi<br />
<a href="https://pypi.org/project/fuzzy-swagger/">https://pypi.org/project/fuzzy-swagger/</a>
</li>

<li>fuzzy-swagger na GitHubu<br />
<a href="https://github.com/namuan/fuzzy-swagger">https://github.com/namuan/fuzzy-swagger</a>
</li>

<li>Fuzz testing tools for Python<br />
<a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy#Fuzz_Testing_Tools">https://wiki.python.org/moin/PythonTestingToolsTaxonomy#Fuzz_Testing_Tools</a>
</li>

<li>A curated list of awesome Go frameworks, libraries and software<br />
<a href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go</a>
</li>

<li>gofuzz: a library for populating go objects with random values<br />
<a href="https://github.com/google/gofuzz">https://github.com/google/gofuzz</a>
</li>

<li>tavor: A generic fuzzing and delta-debugging framework<br />
<a href="https://github.com/zimmski/tavor">https://github.com/zimmski/tavor</a>
</li>

<li>hypothesis na GitHubu<br />
<a href="https://github.com/HypothesisWorks/hypothesis">https://github.com/HypothesisWorks/hypothesis</a>
</li>

<li>Hypothesis: Test faster, fix more<br />
<a href="https://hypothesis.works/">https://hypothesis.works/</a>
</li>

<li>Hypothesis<br />
<a href="https://hypothesis.works/articles/intro/">https://hypothesis.works/articles/intro/</a>
</li>

<li>What is Hypothesis?<br />
<a href="https://hypothesis.works/articles/what-is-hypothesis/">https://hypothesis.works/articles/what-is-hypothesis/</a>
</li>

<li>What is Property Based Testing?<br />
<a href="https://hypothesis.works/articles/what-is-property-based-testing/">https://hypothesis.works/articles/what-is-property-based-testing/</a>
</li>

<li>Databáze CVE<br />
<a href="https://www.cvedetails.com/">https://www.cvedetails.com/</a>
</li>

<li>Fuzz test Python modules with libFuzzer<br />
<a href="https://github.com/eerimoq/pyfuzzer">https://github.com/eerimoq/pyfuzzer</a>
</li>

<li>Taof - The art of fuzzing<br />
<a href="https://sourceforge.net/projects/taof/">https://sourceforge.net/projects/taof/</a>
</li>

<li>JQF + Zest: Coverage-guided semantic fuzzing for Java<br />
<a href="https://github.com/rohanpadhye/jqf">https://github.com/rohanpadhye/jqf</a>
</li>

<li>http2fuzz<br />
<a href="https://github.com/c0nrad/http2fuzz">https://github.com/c0nrad/http2fuzz</a>
</li>

<li>Demystifying hypothesis testing with simple Python examples<br />
<a href="https://towardsdatascience.com/demystifying-hypothesis-testing-with-simple-python-examples-4997ad3c5294">https://towardsdatascience.com/demystifying-hypothesis-testing-with-simple-python-examples-4997ad3c5294</a>
</li>

<li>Testování<br />
<a href="http://voho.eu/wiki/testovani/">http://voho.eu/wiki/testovani/</a>
</li>

<li>Unit testing (Wikipedia.en)<br />
<a href="https://en.wikipedia.org/wiki/Unit_testing">https://en.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit testing (Wikipedia.cz)<br />
<a href="https://cs.wikipedia.org/wiki/Unit_testing">https://cs.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit Test vs Integration Test<br />
<a href="https://www.youtube.com/watch?v=0GypdsJulKE">https://www.youtube.com/watch?v=0GypdsJulKE</a>
</li>

<li>TestDouble<br />
<a href="https://martinfowler.com/bliki/TestDouble.html">https://martinfowler.com/bliki/TestDouble.html</a>
</li>

<li>Test Double<br />
<a href="http://xunitpatterns.com/Test%20Double.html">http://xunitpatterns.com/Test%20Double.html</a>
</li>

<li>Test-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test-driven_development">https://en.wikipedia.org/wiki/Test-driven_development</a>
</li>

<li>Acceptance test–driven development<br />
<a href="https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development">https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development</a>
</li>

<li>Gauge<br />
<a href="https://gauge.org/">https://gauge.org/</a>
</li>

<li>Gauge (software)<br />
<a href="https://en.wikipedia.org/wiki/Gauge_(software)">https://en.wikipedia.org/wiki/Gauge_(software)</a>
</li>

<li>PYPL PopularitY of Programming Language<br />
<a href="https://pypl.github.io/PYPL.html">https://pypl.github.io/PYPL.html</a>
</li>

<li>Testing is Good. Pyramids are Bad. Ice Cream Cones are the Worst<br />
<a href="https://medium.com/@fistsOfReason/testing-is-good-pyramids-are-bad-ice-cream-cones-are-the-worst-ad94b9b2f05f">https://medium.com/@fistsOfReason/testing-is-good-pyramids-are-bad-ice-cream-cones-are-the-worst-ad94b9b2f05f</a>
</li>

<li>Články a zprávičky věnující se Pythonu<br />
<a href="https://www.root.cz/n/python/">https://www.root.cz/n/python/</a>
</li>

<li>PythonTestingToolsTaxonomy<br />
<a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy">https://wiki.python.org/moin/PythonTestingToolsTaxonomy</a>
</li>

<li>Top 6 BEST Python Testing Frameworks [Updated 2020 List]<br />
<a href="https://www.softwaretestinghelp.com/python-testing-frameworks/">https://www.softwaretestinghelp.com/python-testing-frameworks/</a>
</li>

<li>pytest-print 0.1.3<br />
<a href="https://pypi.org/project/pytest-print/">https://pypi.org/project/pytest-print/</a>
</li>

<li>pytest fixtures: explicit, modular, scalable<br />
<a href="https://docs.pytest.org/en/latest/fixture.html">https://docs.pytest.org/en/latest/fixture.html</a>
</li>

<li>PyTest Tutorial: What is, Install, Fixture, Assertions<br />
<a href="https://www.guru99.com/pytest-tutorial.html">https://www.guru99.com/pytest-tutorial.html</a>
</li>

<li>Pytest - Fixtures<br />
<a href="https://www.tutorialspoint.com/pytest/pytest_fixtures.htm">https://www.tutorialspoint.com/pytest/pytest_fixtures.htm</a>
</li>

<li>Marking test functions with attributes<br />
<a href="https://docs.pytest.org/en/latest/mark.html">https://docs.pytest.org/en/latest/mark.html</a>
</li>

<li>pytest-print<br />
<a href="https://pytest-print.readthedocs.io/en/latest/">https://pytest-print.readthedocs.io/en/latest/</a>
</li>

<li>Continuous integration<br />
<a href="https://en.wikipedia.org/wiki/Continuous_integration">https://en.wikipedia.org/wiki/Continuous_integration</a>
</li>

<li>Travis CI<br />
<a href="https://travis-ci.org/">https://travis-ci.org/</a>
</li>

<li>Mutation testing<br />
<a href="https://en.wikipedia.org/wiki/Mutation_testing">https://en.wikipedia.org/wiki/Mutation_testing</a>
</li>

<li>Články o Hypothesis<br />
<a href="https://news.ycombinator.com/from?site=hypothesis.works">https://news.ycombinator.com/from?site=hypothesis.works</a>
</li>

<li>Testovací případ<br />
<a href="https://cs.wikipedia.org/wiki/Testovac%C3%AD_p%C5%99%C3%ADpad">https://cs.wikipedia.org/wiki/Testovac%C3%AD_p%C5%99%C3%ADpad</a>
</li>

<li>Most testing is ineffective<br />
<a href="https://hypothesis.works/">https://hypothesis.works/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

