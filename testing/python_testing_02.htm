<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití Pythonu pro tvorbu testů: použití třídy Mock z knihovny unittest.mock</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití Pythonu pro tvorbu testů: použití tříd Mock z knihovny unittest.mock</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části seriálu o testování s&nbsp;využitím programovacího jazyka Python si popíšeme další možnosti, které jsou programátorům nabízeny knihovnou unittest.mock. Zejména si ukážeme způsoby použití třídy nazvané Mock, zjistíme, zda jsou mockované funkce volány s očekávanými parametry apod.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití Pythonu pro tvorbu testů: použití třídy Mock z&nbsp;knihovny unittest.mock</a></p>
<p><a href="#k02">2. Zjištění, zda byla mockovaná funkce zavolána</a></p>
<p><a href="#k03">3. Problematika mockování funkce, která je volaná nepřímo</a></p>
<p><a href="#k04">4. Mockování funkce volané nepřímo</a></p>
<p><a href="#k05">5. Modifikace kódu v&nbsp;případě, že použijeme <strong>import</strong> a nikoli <strong>from X import</strong></a></p>
<p><a href="#k06">6. Mockování metod</a></p>
<p><a href="#k07">7. Testovaná třída</a></p>
<p><a href="#k08">8. Nepřímé volání metody, kterou budeme mockovat</a></p>
<p><a href="#k09">9. Mockování nepřímo volané metody</a></p>
<p><a href="#k10">10. Složitější aplikace implementovaná ve větším množství modulů</a></p>
<p><a href="#k11">11. Mockování funkcí volaných nepřímo z&nbsp;jiných modulů</a></p>
<p><a href="#k12">12. Výsledek spuštění testů</a></p>
<p><a href="#k13">13. Mockování funkce přímo volané z&nbsp;testů</a></p>
<p><a href="#k14">14. Výsledek spuštění testů</a></p>
<p><a href="#k15">15. Přímé použití konstruktoru <strong>patch()</strong> v&nbsp;těle testů</a></p>
<p><a href="#k16">16. Další možnosti nabízené objekty <strong>Mock</strong> a <strong>MagicMock</strong></a></p>
<p><a href="#k17">17. Zjištění kolikrát a s&nbsp;jakými parametry byla mockovaná funkce zavolána</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Předchozí články s&nbsp;tématem testování (nejenom) v&nbsp;Pythonu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití Pythonu pro tvorbu testů: použití třídy Mock z&nbsp;knihovny unittest.mock</h2>

<p>Ve druhé části seriálu o testování s&nbsp;využitím programovacího jazyka <a
href="https://www.root.cz/n/python/">Python</a> si popíšeme některé další
užitečné možnosti, které jsou programátorům nabízeny knihovnou
<i>unittest.mock</i>. Zejména si ukážeme způsoby použití tříd nazvaných
<strong>Mock</strong> a <strong>MagicMock</strong> (což je třída odvozená od
třídy <strong>Mock</strong>), seznámíme se s&nbsp;možnostmi zjištění
(otestování), zda jsou mockované funkce volány s&nbsp;očekávanými parametry a
samozřejmě nezapomeneme ani na velmi důležitou &bdquo;maličkost&ldquo; &ndash;
jakým způsobem se mockování použije společně se standardním testovacím
frameworkem <a href="https://docs.pytest.org/en/latest/">pytest</a> (protože
právě při skutečném testování se mockování funkcí a metod provádí nejčastěji, i
když oblasti použití jsou ve skutečnosti větší).</p>

<p>Připomeňme si, že v&nbsp;současnosti existuje relativně velké množství
různých knihoven, které mockování funkcí a metod v&nbsp;Pythonu umožňují (není
se ostatně čemu divit, protože samotná podstata jazyka Python tyto operace
umožňuje implementovat relativně snadno). Z&nbsp;těchto knihoven jsme již
minule jmenovali projekt <i>Flexmock</i>, který naleznete na adrese <a
href="https://pypi.python.org/pypi/flexmock">https://pypi.python.org/pypi/flexmock</a>.
V&nbsp;Pythonu 3.x se standardem v&nbsp;této oblasti stala knihovna nazvaná <a
href="https://docs.python.org/dev/library/unittest.mock.html">unittest.mock</a>.
V&nbsp;případě, že ještě z&nbsp;nějakého důvodu musíte používat Python 2.x,
použijte namísto knihovny <i>unittest.mock</i> knihovnu nazvanou jednoduše <a
href="https://pypi.python.org/pypi/mock">mock</a>. Tato knihovna nabízí
prakticky stejné možnosti jako <i>unittest.mock</i> (je ostatně založena na
stejném základním kódu, který pouze byl pro potřeby Pythonu 2.x upraven), ovšem
lze ji použít jak v&nbsp;Pythonu 2.x, tak i v&nbsp;Pythonu 3.x, a to bez toho,
abyste museli upravovat zdrojové kódy vašich testů (samozřejmě za předpokladu,
že se v&nbsp;nich nevyskytují konstrukce, které nejsou v&nbsp;Pythonu 2.x
podporovány).</p>

<p><div class="rs-tip-major">Poznámka: (již naposledy k&nbsp;Pythonu 2
v&nbsp;tomto seriálu) všechny dále popsané demonstrační příklady byly
odzkoušeny společně s&nbsp;Pythonem 3.x (od verze 3.4 včetně). Úprava příkladů
pro Python 2.x by však měla být velmi snadná.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zjištění, zda byla mockovaná funkce zavolána</h2>

<p>Mnohdy, zejména při testování složitěji strukturovaného programového kódu
s&nbsp;mnoha podmínkami popř.&nbsp;rozsáhlejším stavovým prostorem aplikace, je
důležité zjistit, zda se vůbec mockovaná funkce při spuštění jednotkových testů
zavolala. A právě v&nbsp;těchto případech nám přijde vhod objekt, který je do
testovací funkce automaticky předáván, v&nbsp;našem případě v&nbsp;prvním
parametru (jméno tohoto parametru si můžeme vybrat sami, důležité je pouze znát
jeho pořadí/index):</p>

<pre>
@patch('application.function1', side_effect=side_effect_handler)
def <strong>test3</strong>(mocked_function_object):
    ...
    ...
    ...
</pre>

<p>Tento objekt obsahuje mj.&nbsp;i vlastnost (<i>property</i>) pojmenovanou
jednoduše <strong>called</strong>. Ve výchozím stavu je tato vlastnost
nastavena na hodnotu <strong>False</strong>, ale po prvním zavolání mockované
funkce se vlastnost nastaví na hodnotu <strong>True</strong>. Ostatně se o
tomto chování můžeme rychle přesvědčit, a to velmi snadno &ndash; vypíšeme
hodnotu vlastnosti <strong>called</strong> před vlastním voláním mockované
funkce a taktéž ihned po tomto volání. Upravený jednotkový test bude vypadat
následovně:</p>

<pre>
def <strong>side_effect_handler</strong>():
    print("side_effect function called")
    return -1
&nbsp;
&nbsp;
@patch('application.function1', side_effect=side_effect_handler)
def <strong>test3</strong>(mocked_function_object):
    print("mocked function called: {c}".format(c=mocked_function_object.called))
    print(application.function1())
    print("mocked function called: {c}".format(c=mocked_function_object.called))
</pre>

<p>Po zavolání testovací funkce <strong>test3</strong> by se na standardní
výstup měla vypsat následující sekvence zpráv:</p>

<pre>
mocked function called: <strong>False</strong>
side_effect function called
-1
mocked function called: <strong>True</strong>
</pre>

<p>Podobně tomu bude v&nbsp;případě, že kombinujeme vlastní handler se
specifikací návratové hodnoty (handler je tedy zavolán, jeho volání je korektně
zaregistrováno, ovšem nakonec se použije programátorem specifikovaná návratová
hodnota):</p>

<pre>
def <strong>side_effect_handler_2</strong>():
    print("side_effect function called")
    return DEFAULT
&nbsp;
&nbsp;
@patch('application.function1', return_value=42, side_effect=side_effect_handler_2)
def <strong>test5</strong>(mocked_function):
    print("mocked function called: {c}".format(c=mocked_function.called))
    print(application.function1())
    print("mocked function called: {c}".format(c=mocked_function.called))
</pre>

<p>Výsledky po spuštění:</p>

<pre>
mocked function called: <strong>False</strong>
side_effect function called
42
mocked function called: <strong>True</strong>
</pre>

<p>Pro úplnost si v&nbsp;této kapitole opět ukážeme úplný zdrojový kód výše
popsaného demonstračního příkladu. V&nbsp;případě potřeby ho naleznete na
adrese <a
href="https://github.com/tisnik/testing-in-python/tree/master/unittest_mock/mock-test3">https://github.com/tisnik/testing-in-python/tree/master/unittest_mock/mock-test3</a>:</p>

<h3>Soubor <strong>application.py</strong> s&nbsp;testovanou funkcí</h3>

<pre>
<i>"""Implementace logiky aplikace, kterou budeme testovat."""</i>
&nbsp;
&nbsp;
def <strong>function1</strong>():
    <i>"""Funkce, kterou v testech nahradíme mockem."""</i>
    print("function1 called")
    return "tested function"
</pre>

<h3>Soubor <strong>test.py</strong></h3>

<pre>
<i>"""Implementace jednotkových testů."""</i>
&nbsp;
from unittest.mock import *
&nbsp;
import application
&nbsp;
&nbsp;
def <strong>test1</strong>():
    <i>"""První test neprovádí prakticky žádné reálné kontroly, jen zavolá testovanou funkci."""</i>
    print(application.function1())
&nbsp;
&nbsp;
@patch('application.function1', return_value=42)
def <strong>test2</strong>(mocked_function):
    <i>"""Druhý test používá fake test double - náhradu volané funkce."""</i>
    print(application.function1())
&nbsp;
&nbsp;
def <strong>side_effect_handler</strong>():
    <i>"""Implementace handleru - stub funkce nahrazované mockem."""</i>
    print("side_effect function called")
    return -1
&nbsp;
&nbsp;
@patch('application.function1', side_effect=side_effect_handler)
def <strong>test3</strong>(mocked_function):
    <i>"""Třetí test používá stub test double - náhradu volané funkce."""</i>
    <i># vytiskneme informaci o tom, zda se mockovaná funkce zavolala</i>
    print("mocked function called: {c}".format(c=mocked_function.called))
    print(application.function1())
    <i># opět vytiskneme informaci o tom, zda se mockovaná funkce zavolala</i>
    print("mocked function called: {c}".format(c=mocked_function.called))
&nbsp;
&nbsp;
@patch('application.function1', return_value=42, side_effect=side_effect_handler)
def <strong>test4</strong>(mocked_function):
    <i>"""Čtvrtý test se snaží zkombinovat fake a stub."""</i>
    print(application.function1())
&nbsp;
&nbsp;
def <strong>side_effect_handler_2</strong>():
    <i>"""Implementace handleru - stub funkce nahrazované mockem, který ovšem ovlivňuje chování testu."""</i>
    print("side_effect function called")
    return DEFAULT
&nbsp;
&nbsp;
@patch('application.function1', return_value=42, side_effect=side_effect_handler_2)
def <strong>test5</strong>(mocked_function):
    <i>"""Pátý test se opět snaží zkombinovat fake a stub."""</i>
    <i># vytiskneme informaci o tom, zda se mockovaná funkce zavolala</i>
    print("mocked function called: {c}".format(c=mocked_function.called))
    print(application.function1())
    <i># opět vytiskneme informaci o tom, zda se mockovaná funkce zavolala</i>
    print("mocked function called: {c}".format(c=mocked_function.called))
&nbsp;
&nbsp;
if __name__ == '__main__':
    print("*** test1 ***")
    test1()
    print()
&nbsp;
    print("*** test2 ***")
    test2()
    print()
&nbsp;
    print("*** test3 ***")
    test3()
    print()
&nbsp;
    print("*** test4 ***")
    test4()
    print()
&nbsp;
    print("*** test5 ***")
    test5()
    print()
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Problematika mockování funkce, která je volaná nepřímo</h2>

<p>Nyní se dostáváme k&nbsp;velmi důležité vlastnosti knihovny
<i>unittest.mock</i>, kterou je užitečné správně pochopit (už jen z&nbsp;toho
důvodu, že dokumentace tuto vlastnost podle mého názoru nepopisuje do všech
podrobností, o čemž ostatně svědčí poměrně časté dotazy na fórech). Týká se to
způsobu určení plného jména funkce, která má být nahrazena svojí
&bdquo;falešnou&ldquo; variantou, tedy mockem. Nejdříve si naschvál
zkomplikujeme kód naší aplikace, kterou budeme testovat. V&nbsp;upravené
variantě budou aplikaci tvořit dvě funkce nazvané <strong>function1</strong> a
<strong>function2</strong>, přičemž si povšimněte, že se z&nbsp;funkce
<strong>function1</strong> volá funkce <strong>function2</strong> (konkrétně
v&nbsp;rámci příkazu <i>return</i>, ale to v&nbsp;tomto konkrétním případě není
tak důležité &ndash; podstatný je fakt, že k&nbsp;volání dojde):</p>

<pre>
<i>"""Implementace logiky aplikace, kterou budeme testovat."""</i>
&nbsp;
&nbsp;
def <strong>function1</strong>():
    <i>"""První funkce, která volá funkci druhou."""</i>
    print("function1 called")
    return function2()
&nbsp;
&nbsp;
def <strong>function2</strong>():
    <i>"""Druhá funkce, kterou v testech nahradíme mockem."""</i>
    print("function2 called")
    return "function 2"
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Mockování funkce volané nepřímo</h2>

<p>Komplikace nastanou ve chvíli, kdy budeme potřebovat nahradit funkci
<strong>function2</strong> za její falešnou variantu, tedy za <i>mock</i>. Tuto
funkci totiž nebudeme volat přímo z&nbsp;testu, ale pouze nepřímo &ndash; přes
vlastní kód aplikace. A právě v&nbsp;tomto okamžiku se projevuje již výše
zmíněná vlastnost &ndash; do anotace <strong>@patch</strong> je nutné uvést
<i>jméno funkce tak, jak ji vidí volající kód</i>. Co to pro nás znamená?
Funkce <strong>function2</strong> je volána z&nbsp;funkce pojmenované
<strong>function1</strong> a přitom k&nbsp;tomuto volání dochází v&nbsp;modulu
<strong>application</strong>. Plné jméno mockované funkce tedy bude
v&nbsp;tomto konkrétním případě znít <strong>application.function2</strong>,
což jen náhodou odpovídá stejnému jménu, jakoby se funkce volala přímo
z&nbsp;testů (lze totiž zavolat i funkci z&nbsp;jiného balíčku atd.). Podívejme
se nyní na příklady jednotkových testů.</p>

<p>Nejprve změníme import testovaného modulu takovým způsobem, aby nebylo nutné
při volání funkcí z&nbsp;modulu <strong>application</strong> používat celé
jméno tohoto modulu s&nbsp;tečkou:</p>

<pre>
from unittest.mock import *
&nbsp;
from application import *
</pre>

<p>Můžeme si otestovat, že se funkce z&nbsp;modulu <strong>application</strong>
mohou volat přímo (jsou totiž naimportovány do aktuálního jmenného
prostoru):</p>

<pre>
def <strong>test1</strong>():
    print("function1 returns: {v}".format(v=function1()))
</pre>

<p>Výsledek je prozatím uspokojující:</p>

<pre>
function1 called
function2 called
function1 returns: function 2
</pre>

<p>Správné určení funkce, která se má mockovat, bude vypadat následovně &ndash;
funkce je totiž volána nepřímo v&nbsp;modulu <strong>application</strong> a
nikoli v&nbsp;modulu <strong>test</strong> (který je aktuálně nastaven), což se
musí projevit v&nbsp;dekorátoru:</p>

<pre>
@patch('application.function2', return_value=42)
def <strong>test2</strong>(mocked_function_object):
    print("mocked function called: {c}".format(c=mocked_function_object.called))
    print("function1 returns: {v}".format(v=function1()))
    print("mocked function called: {c}".format(c=mocked_function_object.called))
</pre>

<p>Výsledek bude v&nbsp;tomto případě vypadat takto:</p>

<pre>
mocked function called: False
function1 called
function1 returns: 42  &lt; zde se volá mock namísto "pravé" funkce function2
mocked function called: True
</pre>

<p>Jakmile známe správné jméno funkce, můžeme samozřejmě použít i její falešnou
verzi, například následovně:</p>

<pre>
def <strong>side_effect_handler</strong>():
    print("side_effect_handler function called")
    return -1
&nbsp;
&nbsp;
@patch('application.function2', side_effect=side_effect_handler)
def <strong>test3</strong>(mocked_function_object):
    print("mocked function called: {c}".format(c=mocked_function_object.called))
    print(function1())
    print("mocked function called: {c}".format(c=mocked_function_object.called))
</pre>

<p>Výsledek:</p>

<pre>
mocked function called: False
function1 called
side_effect_handler function called
-1
mocked function called: True
</pre>

<p>Podobně, jako tomu bylo <a href="#k02">ve druhé kapitole</a>, si uvedeme
úplný zdrojový kód dnešního v&nbsp;pořadí druhého demonstračního příkladu, jenž
je opět složen ze dvou souborů &ndash; <strong>application.py</strong> a
<strong>test.py</strong> (a z&nbsp;pomocného souboru <strong>main.py</strong>).
Tento příklad naleznete na adrese <a
href="https://github.com/tisnik/testing-in-python/tree/master/unittest_mock/mock-test4">https://github.com/tisnik/testing-in-python/tree/master/unittest_mock/mock-test4</a>:</p>

<h3>Soubor <strong>application.py</strong> s&nbsp;testovanou funkcí</h3>

<pre>
<i>"""Implementace logiky aplikace, kterou budeme testovat."""</i>
&nbsp;
&nbsp;
def <strong>function1</strong>():
    <i>"""První funkce, která volá funkci druhou."""</i>
    print("function1 called")
    return function2()
&nbsp;
&nbsp;
def <strong>function2</strong>():
    <i>"""Druhá funkce, kterou v testech nahradíme mockem."""</i>
    print("function2 called")
    return "function 2"
</pre>

<h3>Soubor <strong>test.py</strong></h3>

<pre>
<i>"""Implementace jednotkových testů."""</i>
&nbsp;
from unittest.mock import *
&nbsp;
from application import *
&nbsp;
&nbsp;
def <strong>test1</strong>():
    <i>"""První test neprovádí prakticky žádné reálné kontroly, jen zavolá testovanou funkci."""</i>
    print("function1 returns: {v}".format(v=function1()))
&nbsp;
&nbsp;
@patch('application.function2', return_value=42)
def <strong>test2</strong>(mocked_function):
    <i># vytiskneme informaci o tom, zda se mockovaná funkce zavolala</i>
    print("mocked function called: {c}".format(c=mocked_function.called))
    print("function1 returns: {v}".format(v=function1()))
    <i># opět vytiskneme informaci o tom, zda se mockovaná funkce zavolala</i>
    print("mocked function called: {c}".format(c=mocked_function.called))
&nbsp;
&nbsp;
def <strong>side_effect_handler</strong>():
    print("side_effect_handler function called")
    return -1
&nbsp;
&nbsp;
@patch('application.function2', side_effect=side_effect_handler)
def <strong>test3</strong>(mocked_function):
    <i># vytiskneme informaci o tom, zda se mockovaná funkce zavolala</i>
    print("mocked function called: {c}".format(c=mocked_function.called))
    print(function1())
    <i># opět vytiskneme informaci o tom, zda se mockovaná funkce zavolala</i>
    print("mocked function called: {c}".format(c=mocked_function.called))
&nbsp;
&nbsp;
if __name__ == '__main__':
    test1()
    print()
&nbsp;
    test2()
    print()
&nbsp;
    test3()
    print()
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Modifikace kódu v&nbsp;případě, že použijeme <strong>import</strong> a nikoli <strong>from X import</strong></h2>

<p>Dnešní třetí demonstrační příklad je založen na prakticky stejném kódu jako
příklad předchozí, ovšem s&nbsp;tím podstatným rozdílem, že se modul
<strong>application</strong> importuje do testů nikoli příkazem:</p>

<pre>
from application import *
</pre>

<p>ale naopak následujícím způsobem:</p>

<pre>
import application
</pre>

<p>To vede k&nbsp;tomu, že <i>přímé volání</i> funkcí z&nbsp;modulu
<strong>application</strong> je nutné provádět s&nbsp;uvedením jména modulu.
Samotné testy a dokonce ani obsah dekorátoru (v&nbsp;jiných programovacích
jazycích anotace) <strong>@patch</strong> se ovšem žádným způsobem nezmění.
Testy nyní budou vypadat následovně:</p>

<pre>
from unittest.mock import *
&nbsp;
import application
&nbsp;
&nbsp;
def <strong>test1</strong>():
    <i>"""První test neprovádí prakticky žádné reálné kontroly, jen zavolá testovanou funkci."""</i>
    print("function1 returns: {v}".format(v=application.function1()))
&nbsp;
&nbsp;
@patch('application.function2', return_value=42)
def <strong>test2</strong>(mocked_function_object):
    <i># vytiskneme informaci o tom, zda se mockovaná funkce zavolala</i>
    print("mocked function called: {c}".format(c=mocked_function_object.called))
    print("function1 returns: {v}".format(v=application.function1()))
    <i># opět vytiskneme informaci o tom, zda se mockovaná funkce zavolala</i>
    print("mocked function called: {c}".format(c=mocked_function_object.called))
&nbsp;
&nbsp;
def <strong>side_effect_handler</strong>():
    print("side_effect_handler function called")
    return -1
&nbsp;
&nbsp;
@patch('application.function2', side_effect=side_effect_handler)
def <strong>test3</strong>(mocked_function_object):
    <i># vytiskneme informaci o tom, zda se mockovaná funkce zavolala</i>
    print("mocked function called: {c}".format(c=mocked_function_object.called))
    print("function1 returns: {v}".format(v=application.function1()))
    <i># opět vytiskneme informaci o tom, zda se mockovaná funkce zavolala</i>
    print("mocked function called: {c}".format(c=mocked_function_object.called))
&nbsp;
&nbsp;
if __name__ == '__main__':
    test1()
    print()
&nbsp;
    test2()
    print()
&nbsp;
    test3()
    print()
</pre>

<p>Výsledek běhu testů již dokážeme velmi dobře předvídat:</p>

<pre>
function1 called
function2 called
function1 returns: function 2
&nbsp;
mocked function called: False
function1 called
function1 returns: 42
mocked function called: True
&nbsp;
mocked function called: False
function1 called
side_effect_handler function called
function1 returns: -1
mocked function called: True
</pre>

<p><div class="rs-tip-major">Poznámka: tento demonstrační příklad je umístěn na
adrese <a
href="https://github.com/tisnik/testing-in-python/tree/master/unittest_mock/mock-test5">https://github.com/tisnik/testing-in-python/tree/master/unittest_mock/mock-test5</a>.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Mockování metod</h2>

<p>Prakticky stejným způsobem, jakým jsme vytvářeli &bdquo;falešné&ldquo;
varianty běžných funkcí (tedy mocky), je možné nahrazovat metody vybraných
tříd. Ostatně v&nbsp;programovacím jazyku Python není mezi funkcemi a metodami
tak velký rozdíl, jako v&nbsp;některých jiných programovacích jazycích, které
před programátory skrývají (mj) implicitní parametr <strong>self</strong> či
<strong>this</strong>. V&nbsp;následujících třech kapitolách si ukážeme
vytvoření jednoduchého mocku nepřímo volané (nestatické a netřídní) metody.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Testovaná třída</h2>

<p>Třída, kterou budeme testovat, je opět velmi jednoduchá. Kromě konstruktoru
obsahuje i dvě metody nazvané <strong>method1</strong> a
<strong>method2</strong>, přičemž druhá metoda je automaticky volána
z&nbsp;metody první (opět v&nbsp;příkazu return, což ovšem není podstatné):</p>

<pre>
<i>"""Implementace logiky aplikace, kterou budeme testovat."""</i>
&nbsp;
&nbsp;
class <strong>Application</strong>:
    def <strong>__init__</strong>(self):
        pass
&nbsp;
    def <strong>method1</strong>(self):
        <i>"""První metoda, která volá metodu druhou."""</i>
        print("method1 called")
        return self.method2()
&nbsp;
    def <strong>method2</strong>(self):
        <i>"""Druhá metoda, kterou v testech nahradíme mockem."""</i>
        print("method2 called")
        return "method 2"
</pre>

<p>Poznámka: ve skutečnosti obě metody nepřistupují k&nbsp;žádnému atributu
objektu, takže by se z&nbsp;nich mohly stát statické metody pomocí anotace
<strong>@staticmethod</strong>; alternativně i třídní metody. Nicméně pro
jednoduchost zatím uvažujme o nestatických metodách, kterým se při jejich
volání explicitně předává i parametr <strong>self</strong>.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Nepřímé volání metody, kterou budeme mockovat</h2>

<p>Samotný modul s&nbsp;testem bude začínat přesně tak, jak jsme zvyklí,
tj.&nbsp;importem třídy <strong>unittest.mock</strong> i třídy
<strong>Application</strong> uložené v&nbsp;modulu
<strong>application</strong>:</p>

<pre>
from unittest.mock import *
&nbsp;
from application import Application
</pre>

<p>První jednotkový test prozatím žádnou mockovanou funkci nepoužívá, pouze je
v&nbsp;něm ukázán způsob volání metody <strong>method1</strong> společně
s&nbsp;výpisem návratové hodnoty této metody:</p>

<pre>
def <strong>test1</strong>():
    app = Application()
    print("method1 returns: {v}".format(v=app.method1()))
</pre>

<p>Po spuštění tohoto testu by se na standardní výstup měly vypsat následující
řádky oznamující, že se z&nbsp;první metody volá metoda druhá:</p>

<pre>
method1 called
method2 called
method1 returns: method 2
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Mockování nepřímo volané metody</h2>

<p>Nyní se již dostáváme k&nbsp;popisu mockování metod. Opět si musíme
uvědomit, že je zapotřebí zadat plné jméno metody, a to podle toho,
v&nbsp;jakém kontextu bude tato metoda volána. Vzhledem k&nbsp;tomu, že
mockujeme metodu se jménem <strong>Application.method2</strong>
(&bdquo;Application&ldquo; je jméno třídy), která bude volána nepřímo (nikoli
z&nbsp;testu, ale z&nbsp;první metody <strong>method1</strong>), bude plné
jméno mockované metody znít &bdquo;application.Application.method2&ldquo;.</p>

<p>Zkusme si tento test napsat:</p>

<pre>
@patch('application.Application.method2', return_value=42)
def <strong>test2</strong>(mocked_method):
    app = Application()
    print("mocked method called: {c}".format(c=mocked_method.called))
    print("method1 returns: {v}".format(v=app.method1()))
    print("mocked method called: {c}".format(c=mocked_method.called))
</pre>

<p>Výsledek po spuštění testu:</p>

<pre>
mocked method called: False
method1 called
method1 returns: 42
mocked method called: True
</pre>

<p>Vzhledem k&nbsp;tomu, že vlastnosti mockovaných funkcí a metod jsou
prakticky stejné, můžeme metodu nahradit jiným handlerem atd. atd.:</p>

<pre>
def <strong>side_effect_handler</strong>():
    print("side_effect_handler method called")
    return -1
&nbsp;
&nbsp;
@patch('application.Application.method2', side_effect=side_effect_handler)
def <strong>test3</strong>(mocked_method):
    app = Application()
    print("mocked method called: {c}".format(c=mocked_method.called))
    print("method1 returns: {v}".format(v=app.method1()))
    print("mocked method called: {c}".format(c=mocked_method.called))
</pre>

<p>Výsledek po spuštění testu:</p>

<pre>
mocked method called: False
method1 called
side_effect_handler method called
method1 returns: -1
mocked method called: True
</pre>

<p><div class="rs-tip-major">Poznámka: tento demonstrační příklad je umístěn na
adrese <a
href="https://github.com/tisnik/testing-in-python/tree/master/unittest_mock/mock-test6">https://github.com/tisnik/testing-in-python/tree/master/unittest_mock/mock-test6</a>.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Složitější aplikace implementovaná ve větším množství modulů</h2>

<p>Nyní ukážeme si způsob mockování funkcí u složitěji strukturované aplikace,
v&nbsp;níž se nachází celkem tři moduly pojmenované jednoduše
<strong>module1.py</strong>, <strong>module2.py</strong> a
<strong>module3.py</strong>:</p>

<pre>
module1.py
module2.py
module3.py
</pre>

<p>V&nbsp;prvním modulu <strong>module1</strong> nalezneme funkci nazvanou
<strong>function1</strong>, která pouze na standardní výstup vypíše své jméno a
zavolá funkci <strong>function2</strong> z&nbsp;modulu
<strong>module2</strong>. Tento modul samozřejmě musíme importovat:</p>

<pre>
from module2 import *
&nbsp;
&nbsp;
def <strong>function1</strong>():
    print("function1")
    return "function1 " + function2()
</pre>

<p>Druhý modul pojmenovaný <strong>module2</strong> vypadá podobně jako modul
první, ovšem nachází se v&nbsp;něm funkce <strong>function2</strong> volající
funkci <strong>function3</strong> ze třetího modulu:</p>

<pre>
from module3 import *
&nbsp;
&nbsp;
def <strong>function2</strong>():
    print("function2")
    return "function2 " + function3()
</pre>

<p>Konečně se dostáváme ke třetímu modulu, který je nejjednodušší, protože
neobsahuje žádný import, ale pouze implementaci funkce nazvané
<strong>function3</strong>:</p>

<pre>
def <strong>function3</strong>():
    print("function3")
    return "function3"
</pre>

<p>Celá aplikace se spouští z&nbsp;modulu <strong>main.py</strong>, jehož obsah
je triviální &ndash; spouští se v&nbsp;něm funkce z&nbsp;prvního zmíněného
modulu:</p>

<pre>
from module1 import *
&nbsp;
&nbsp;
if __name__ == '__main__':
    print(function1())
</pre>

<p>Aplikaci si můžeme vyzkoušet například v&nbsp;debuggeru, a to poměrně
jednoduše. Nejprve debugger spustíme (použijeme přitom standardní debugger
Pythonu):</p>

<pre>
$ <strong>python3 -m pdb main.py </strong>
</pre>

<p>Průběh spuštění a inicializace:</p>

<pre>
&gt; /home/tester/temp/python/mocking-in-python/mock-test7/main.py(1)&lt;module&gt;()
-&gt; from module1 import *
</pre>

<p>Dále nastavíme tzv.&nbsp;<i>breakpoint</i> (bod zastavení), a to na poslední
volané funkci <strong>function3</strong>. Tato funkce není v&nbsp;modulu
<strong>main.py</strong> a tudíž ji musíme klasifikovat celým jménem:</p>

<pre>
(Pdb) <strong>break module3.function3</strong>
&nbsp;
Breakpoint 1 at /home/tester/temp/python/mocking-in-python/mock-test7/module3.py:1
</pre>

<p>Program v&nbsp;debuggeru spustíme příkazem <strong>continue</strong>:</p>

<pre>
(Pdb) <strong>continue</strong>
function1
function2
&gt; /home/tester/temp/python/mocking-in-python/mock-test7/module3.py(2)function3()
-&gt; print("function3")
</pre>

<p>A po jeho zastavení se podíváme, jak vypadají zásobníkové rámce:</p>

<pre>
(Pdb) <strong>where</strong>
  /usr/lib/python3.4/bdb.py(431)run()
-&gt; exec(cmd, globals, locals)
  &lt;string&gt;(1)&lt;module&gt;()
  /home/tester/temp/python/mocking-in-python/mock-test7/main.py(5)&lt;module&gt;()
-&gt; print(function1())
  /home/tester/temp/python/mocking-in-python/mock-test7/module1.py(6)function1()
-&gt; return "function1 " + function2()
  /home/tester/temp/python/mocking-in-python/mock-test7/module2.py(6)function2()
-&gt; return "function2 " + function3()
&gt; /home/tester/temp/python/mocking-in-python/mock-test7/module3.py(2)function3()
-&gt; print("function3")
</pre>

<p>Z&nbsp;předchozího výpisu je zřejmý celý řetězec volání.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Mockování funkcí volaných nepřímo z&nbsp;jiných modulů</h2>

<p>Nyní si již můžeme ukázat, jakým způsobem lze mockovat funkce volané
z&nbsp;jiných modulů. V&nbsp;našem konkrétním případě by se jednalo o tato
volání:</p>

<table>
<tr><th>Voláno z</th><th>Volaná funkce</th><th>Modul v němž je funkce definována</th></tr>
<tr><td>(testy).py</td><td>function1</td><td>module1.py</td></tr>
<tr><td>module1.py</td><td>function2</td><td>module2.py</td></tr>
<tr><td>module2.py</td><td>function3</td><td>module3.py</td></tr>
</table>

<p>Připomeňme si základní pravidlo, které platí v&nbsp;Pythonu při použití
<strong>unittest.mock</strong> &ndash; při deklaraci mocku musíme uvést plné
jméno funkce <i>v&nbsp;kontextu jejího volání</i>, tj.&nbsp;z&nbsp;jakého
modulu je funkce <i>volána</i> a nikoli v&nbsp;jakém modulu je
<i>definována</i>.</p>

<p>Zkusme si tedy napsat testovací skript <strong>test.py</strong>. Jeho
začátek je &bdquo;klasický&ldquo;:</p>

<pre>
from unittest.mock import *
&nbsp;
from module1 import *
</pre>

<p>První jednotkový test <strong>test1</strong> bude jednoduše volat funkci
<strong>function1</strong> z&nbsp;modulu <strong>module1</strong>:</p>

<pre>
def <strong>test1</strong>():
    print("*** test1 ***")
    value = function1()
    print("function1 returns: {v}".format(v=value))
</pre>

<p>Ve druhém testu voláme stejnou funkci, ale současně se pokusíme mockovat
funkci <strong>function2</strong> volanou z&nbsp;modulu
<strong>module2</strong> (což ale nebude mít žádný efekt):</p>

<pre>
@patch('module2.function2', return_value="*mocked*")
def <strong>test2</strong>(mocked_function):
    print("*** test2 ***")
    value = function1()
    print("function1 returns: {v}".format(v=value))
</pre>

<p>Třetí test již provede mockování skutečně volané funkce. Stále se jedná o
funkci <strong>function2</strong>, ovšem volanou z&nbsp;modulu
<strong>module1</strong>, což je i případ naší &bdquo;reálné&ldquo;
aplikace:</p>

<pre>
@patch('module1.function2', return_value="*mocked*")
def <strong>test3</strong>(mocked_function):
    print("*** test3 ***")
    value = function1()
    print("function1 returns: {v}".format(v=value))
</pre>

<p>Čtvrtý test posunuje mock o jednu úroveň dále, konkrétně na funkci
<strong>function3</strong> volanou z&nbsp;modulu <strong>module2</strong>:</p>

<pre>
@patch('module2.function3', return_value="*mocked*")
def <strong>test4</strong>(mocked_function):
    print("*** test4 ***")
    value = function1()
    print("function1 returns: {v}".format(v=value))
</pre>

<p>A konečně se pokusíme taktéž mockovat funkci <strong>function3</strong>,
ovšem tentokrát volanou z&nbsp;modulu <strong>module3</strong>, což ve
skutečnosti nikdy nenastane (to však testovací framework neoznámí!):</p>

<pre>
@patch('module3.function3', return_value="*mocked*")
def <strong>test5</strong>(mocked_function):
    print("*** test5 ***")
    value = function1()
    print("function1 returns: {v}".format(v=value))
</pre>

<p>Poslední část skriptu pouze testy spustí bez dalších triků:</p>

<pre>
if __name__ == '__main__':
    test1()
    print()
&nbsp;
    test2()
    print()
&nbsp;
    test3()
    print()
&nbsp;
    test4()
    print()
&nbsp;
    test5()
    print()
</pre>

<p><div class="rs-tip-major">Poznámka: tento demonstrační příklad je umístěn na
adrese <a
href="https://github.com/tisnik/testing-in-python/tree/master/unittest_mock/mock-test7">https://github.com/tisnik/testing-in-python/tree/master/unittest_mock/mock-test7</a>.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Výsledek spuštění testů</h2>

<p>Podívejme se nyní na výsledky, které získáme po spuštění testů definovaných
v&nbsp;předchozím demonstračním příkladu. Vlastní spuštění je jednoduché,
protože postačuje spustit skript nazvaný <strong>test</strong> (ten spustí
interpret Pythonu a předá mu skript <strong>test.py</strong>):</p>

<pre>
$ <strong>./test</strong>
</pre>

<p>První test <strong>test1</strong> ve skutečnosti žádné mockování nepoužívá,
takže se funkce spustí v&nbsp;pořadí <strong>module1.function1</strong> &rarr;
<strong>module2.function2</strong> &rarr;
<strong>module3.function3</strong>:</p>

<pre>
*** test1 ***
function1
function2
function3
function1 returns: function1 function2 function3
</pre>

<p>Ve druhém testu jsme se snažili mockovat funkci
<strong>module2.function2</strong>, ovšem ve skutečnosti se tímto způsobem
žádná funkce nevolá (voláme sice <strong>function2</strong>, ovšem
v&nbsp;kontextu prvního modulu), takže výsledek bude stejný, jako
v&nbsp;příkladu předchozím:</p>

<pre>
*** test2 ***
function1
function2
function3
function1 returns: function1 function2 function3
</pre>

<p>Teprve ve třetím testu, v&nbsp;němž byl mock nastaven na
&bdquo;module1.function2&ldquo; se namísto funkce
<strong>module2.function2</strong> použila nastavená návratová hodnota
&bdquo;*mocked*&ldquo;. Třetí funkce se pochopitelně vůbec nezavolá:</p>

<pre>
*** test3 ***
function1
function1 returns: function1 *mocked*
</pre>

<p>Čtvrtý příklad je obdobný, ovšem s&nbsp;tím rozdílem, že se mock použil
namísto funkce <strong>module3.function3</strong>, ovšem &ndash; to je důležité
&ndash; v&nbsp;kontextu druhého modulu, nikoli modulu třetího:</p>

<pre>
*** test4 ***
function1
function2
function1 returns: function1 function2 *mocked*
</pre>

<p>A konečně v&nbsp;posledním testu byla mockována funkce
<strong>function3</strong> v&nbsp;kontextu modulu <strong>module3</strong>, což
je sice korektní, ovšem v&nbsp;tomto kontextu žádná funkce zavolána není, takže
výsledek je následující:</p>

<pre>
*** test5 ***
function1
function2
function3
function1 returns: function1 function2 function3
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Mockování funkce přímo volané z&nbsp;testů</h2>

<p>V&nbsp;demonstračním příkladu, s&nbsp;nímž jsme se seznámili
v&nbsp;předchozích kapitolách, se modul nazvaný <strong>module1</strong> do
testovacího modulu importoval tímto způsobem:</p>

<pre>
from module1 import *
</pre>

<p>To je samozřejmě zcela legální způsob, ovšem má jednu nevýhodu &ndash;
všechny funkce a třídy z&nbsp;modulu <strong>module1</strong> se stanou
součástí jmenného prostoru testů, takže se při tvorbě mocků těchto funkcí/tříd
dostaneme do zbytečných problémů. Praktičtější bude import nepatrně změnit a
použít následující řádek:</p>

<pre>
import module1
</pre>

<p>Nyní je již možné velmi jednoduše mockovat funkci <strong>function1</strong>
volanou v&nbsp;kontextu modulu <strong>module1</strong>, protože přesně takto
k&nbsp;této funkci budeme muset přistupovat:</p>

<pre>
@patch('module1.function1', return_value="*mocked*")
def <strong>test1</strong>(mocked_function):
    print("*** test1 ***")
    value = module1.function1()
    print("function1 returns: {v}".format(v=value))
</pre>

<p>Podobným způsobem je možné zabezpečit mockování dalších funkcí, tentokrát
již volaných nepřímo. Povšimněte si, že všechny další anotace
<strong>@patch</strong> jsou shodné s&nbsp;prvním demonstračním příkladem:</p>

<pre>
@patch('module2.function2', return_value="*mocked*")
def <strong>test2</strong>(mocked_function):
    print("*** test2 ***")
    value = module1.function1()
    print("function1 returns: {v}".format(v=value))
&nbsp;
&nbsp;
@patch('module1.function2', return_value="*mocked*")
def <strong>test3</strong>(mocked_function):
    print("*** test3 ***")
    value = module1.function1()
    print("function1 returns: {v}".format(v=value))
&nbsp;
&nbsp;
@patch('module2.function3', return_value="*mocked*")
def <strong>test4</strong>(mocked_function):
    print("*** test4 ***")
    value = module1.function1()
    print("function1 returns: {v}".format(v=value))
&nbsp;
&nbsp;
@patch('module3.function3', return_value="*mocked*")
def <strong>test5</strong>(mocked_function):
    print("*** test5 ***")
    value = module1.function1()
    print("function1 returns: {v}".format(v=value))
</pre>

<p>I spuštění testů je pochopitelně stejné (zde se nic nezměnilo):</p>

<pre>
if __name__ == '__main__':
    test1()
    print()
&nbsp;
    test2()
    print()
&nbsp;
    test3()
    print()
&nbsp;
    test4()
    print()
&nbsp;
    test5()
    print()
</pre>

<p><div class="rs-tip-major">Poznámka: tento demonstrační příklad je umístěn na
adrese <a
href="https://github.com/tisnik/testing-in-python/tree/master/unittest_mock/mock-test8">https://github.com/tisnik/testing-in-python/tree/master/unittest_mock/mock-test8</a>.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Výsledek spuštění testů</h2>

<p>Pokud tento demonstrační příklad spustíme, zjistíme snadno, že je skutečně
možné mockovat i funkci pojmenovanou <strong>function1</strong> z&nbsp;modulu
<strong>module1</strong> (viz první dva řádky výpisu):</p>

<pre>
*** test1 ***
function1 returns: *mocked*
</pre>

<p>Další zprávy vypisované v&nbsp;testech jsou již shodné s&nbsp;prvním
příkladem:</p>

<pre>
*** test2 ***
function1
function2
function3
function1 returns: function1 function2 function3
&nbsp;
*** test3 ***
function1
function1 returns: function1 *mocked*
&nbsp;
*** test4 ***
function1
function2
function1 returns: function1 function2 *mocked*
&nbsp;
*** test5 ***
function1
function2
function3
function1 returns: function1 function2 function3
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Přímé použití konstruktoru <strong>patch()</strong> v&nbsp;těle testů</h2>

<p>V&nbsp;některých případech není možné vystačit s&nbsp;tím, že se před
testovací funkci napíše anotace <strong>@patch</strong>. Můžeme se totiž dostat
do situace, kdy budeme jednou potřebovat zavolat funkci původní a jindy
(v&nbsp;tom samém testu) mock této funkce. I toto chování je samozřejmě
podporováno, protože namísto nám již známého zápisu:</p>

<pre>
@patch('module1.function1', return_value="*mocked*")
def <strong>test1</strong>(mocked_function):
    print("*** test1 ***")
    value = module1.function1()
    print("function1 returns: {v}".format(v=value))
</pre>

<p>Je možné použít přímé volání funkce <strong>patch</strong> importované
z&nbsp;modulu <strong>unittest</strong>. Typicky se volání funkce
<strong>patch</strong> používá společně s&nbsp;řídicí konstrukcí
<strong>with</strong>, která omezuje kontext, v&nbsp;němž je mock platný (dnes
se pravděpodobně jedná o idiomatický způsob použití).  Podívejme se na
příklad:</p>

<pre>
def <strong>test1</strong>():
    with patch("module1.function1", return_value="*mocked"):
        print("*** test1 ***")
        value = module1.function1()
        print("function1 returns: {v}".format(v=value))
</pre>

<p>Podobným způsobem lze zapsat i další testovací funkce. Výsledky testů budou
shodné s&nbsp;výsledky předchozího příkladu:</p>

<pre>
*** test1 ***
function1 returns: *mocked
&nbsp;
*** test2 ***
function1
function2
function3
function1 returns: function1 function2 function3
&nbsp;
*** test3 ***
function1
function1 returns: function1 *mocked
&nbsp;
*** test4 ***
function1
function2
function1 returns: function1 function2 *mocked
&nbsp;
*** test5 ***
function1
function2
function3
function1 returns: function1 function2 function3
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Další možnosti nabízené objekty <strong>Mock</strong></h2>

<p><a href="#k02">Ve druhé kapitole</a> jsme si řekli, že je velmi snadné
zjistit, jestli je mockovaná funkce volána či nikoli. To lze samozřejmě provést
i ve chvíli, kdy nepoužijeme anotaci <strong>@patch</strong>, ale namísto toho
přímo zavoláme funkci <strong>patch</strong> v&nbsp;bloku <strong>with</strong>
(předchozí kapitola). Co ovšem musíme doplnit je jméno proměnné obsahující
referenci na mock. Tato reference je vrácena funkcí <strong>patch</strong>,
ovšem kvůli jejímu volání v&nbsp;bloku <strong>with</strong> je syntaxe zápisu
nepatrně odlišná:</p>

<pre>
with patch("jméno_modulu.jméno_funkce") as jméno_proměnné_s_referencí_na mock:
    ...
    ...
    ...
</pre>

<p>Ve chvíli, kdy máme referenci na mock, můžeme zjistit, zda byl volán
přečtením vlastnosti <strong>called</strong>. Příklad použití pro první
test:</p>

<pre>
def <strong>test1</strong>():
    with patch("module1.function1") as mocked_function:
        mocked_function.return_value = "*mocked*"
&nbsp;
        print("*** test1 ***")
        value = module1.function1()
        print("function1 returns: {v}".format(v=value))
        print("mocked function called: {c}".format(c=mocked_function.called))
</pre>

<p>I zbylé testy budou vypadat podobně. Podívejme se ještě na výsledky těchto
testů.</p>

<pre>
*** test1 ***
function1 returns: *mocked*
mocked function called: True
</pre>

<p>U druhého testu k&nbsp;volání mocku nedošlo (což již nepřímo víme
z&nbsp;výsledné hodnoty vrácené funkcí <strong>function1</strong>):</p>

<pre>
*** test2 ***
function1
function2
function3
function1 returns: function1 function2 function3
mocked function called: False
</pre>

<p>V&nbsp;dalších dvou testech se mockovaná funkce volala:</p>

<pre>
*** test3 ***
function1
function1 returns: function1 *mocked*
mocked function called: True

*** test4 ***
function1
function2
function1 returns: function1 function2 *mocked*
mocked function called: True
</pre>

<p>V&nbsp;posledním testu však již opět ne:</p>

<pre>
*** test5 ***
function1
function2
function3
function1 returns: function1 function2 function3
mocked function called: False
</pre>

<p>Tyto postupy naleznete v&nbsp;příkladu dostupném na adrese <a
href="https://github.com/tisnik/testing-in-python/tree/master/unittest_mock/mock-test9">https://github.com/tisnik/testing-in-python/tree/master/unittest_mock/mock-test9</a>.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Zjištění kolikrát a s&nbsp;jakými parametry byla mockovaná funkce zavolána</h2>

<p>Další vlastnost je při testování taktéž nemálo užitečná. Zavoláním
<strong>mock.assert_called_with(hodnota1, hodnota2, ...)</strong> je totiž
možné zjistit, zda vůbec a s&nbsp;jakými parametry je mock zavolán. To však
není zdaleka vše, protože ve vlastnosti <strong>mock_calls</strong> je uložena
sekvence všech volání. Z&nbsp;této sekvence zjistíme jak pořadí volání mocku,
tak i hodnoty parametrů, které byly při volání použity. V&nbsp;dalším testu
budeme mockovat tuto funkci:</p>

<pre>
def <strong>add</strong>(x, y):
    return add_implementation(x, y)
</pre>

<p>První test může vypadat následovně &ndash; nejdříve mock zavoláme, následně
vypíšeme informaci o tom, zda byl skutečně zavolán, posléze otestujeme, jestli
se použili parametry 1 a 2 (popř.&nbsp;při druhém volání 100 a 100) a konečně
si necháme vypsat seznam všech volání dané funkce:</p>

<pre>
def <strong>test1</strong>():
    print("*** test1 ***")
&nbsp;
    with patch("module1.add_implementation") as mocked_function:
        mocked_function.return_value = 42
&nbsp;
        value = module1.add(1, 2)
        print("add returns: {v}".format(v=value))
        print("mocked function called: {c}".format(c=mocked_function.called))
        mocked_function.assert_called_with(1, 2)
&nbsp;
        value = module1.add(100, 100)
        print("add returns: {v}".format(v=value))
        print("mocked function called: {c}".format(c=mocked_function.called))
        mocked_function.assert_called_with(100, 100)
&nbsp;
        print("calls: ", mocked_function.mock_calls)
</pre>

<p>Naproti tomu druhý test je schválně napsán takovým způsobem, aby se při
kontrole zjistilo, že mock byl sice volán, ale s&nbsp;neočekávanými parametry.
Ve skutečnosti totiž voláme funkci s&nbsp;parametry 1 a 2, ale očekáváme volání
s&nbsp;parametry 1 a 1:</p>

<pre>
def <strong>test2</strong>():
    print("*** test2 ***")
&nbsp;
    with patch("module1.add_implementation") as mocked_function:
        mocked_function.return_value = 42
&nbsp;
        value = module1.add(1, 2)
        print("add returns: {v}".format(v=value))
        print("mocked function called: {c}".format(c=mocked_function.called))
        mocked_function.assert_called_with(1, 1)
</pre>

<p>Nejzajímavější je samozřejmě výsledek spuštění testů. V&nbsp;prvním testu se
skutečně mockovaná funkce volala, a to dokonce dvakrát &ndash; poprvé
s&nbsp;parametry 1, 2, podruhé s&nbsp;parametry 100, 100:</p>

<pre>
*** test1 ***
add returns: 42
mocked function called: True
add returns: 42
mocked function called: True
calls:  [call(1, 2), call(100, 100)]
</pre>

<p>U druhého testu však dojde k&nbsp;pádu, protože se mock nezavolal ani
jednou, což kontrola velmi rychle odhalí:</p>

<pre>
*** test2 ***
add returns: 42
mocked function called: True
Traceback (most recent call last):
  File "test.py", line 41, in <module>
    test2()
  File "test.py", line 34, in test2
    mocked_function.assert_called_with(1, 1)
  File "/usr/lib/python3.4/unittest/mock.py", line 771, in assert_called_with
    raise AssertionError(_error_message()) from cause
AssertionError: Expected call: add_implementation(1, 1)
Actual call: add_implementation(1, 2)
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
nového Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/testing-in-python">https://github.com/tisnik/testing-in-python</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem &ndash;
alespoň prozatím &ndash; velmi malý, dnes má přibližně deseti kilobajtů),
můžete namísto toho použít odkazy na jednotlivé demonstrační příklady a jejich
části, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>application.py</td><td>implementace logiky aplikace, kterou budeme testovat</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test3/">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test3/application.py</a></td></tr>
<tr><td> 2</td><td>main.py</td><td>vstupní bod do testované aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test3/main.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test3/main.py</a></td></tr>
<tr><td> 3</td><td>test.py</td><td>implementace jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test3/test.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test3/test.py</a></td></tr>
<tr><td> 4</td><td>run</td><td>skript pro spuštění aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test3/run">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test3/run</a></td></tr>
<tr><td> 5</td><td>test</td><td>skript pro spuštění jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test3/test">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test3/test</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>application.py</td><td>implementace logiky aplikace, kterou budeme testovat</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test4/application.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test4/application.py</a></td></tr>
<tr><td> 7</td><td>main.py</td><td>vstupní bod do testované aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test4/main.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test4/main.py</a></td></tr>
<tr><td> 8</td><td>test.py</td><td>implementace jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test4/test.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test4/test.py</a></td></tr>
<tr><td> 9</td><td>run</td><td>skript pro spuštění aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test4/run">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test4/run</a></td></tr>
<tr><td>10</td><td>test</td><td>skript pro spuštění jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test4/test">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test4/test</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>application.py</td><td>implementace logiky aplikace, kterou budeme testovat</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test5/application.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test5/application.py</a></td></tr>
<tr><td>12</td><td>main.py</td><td>vstupní bod do testované aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test5/main.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test5/main.py</a></td></tr>
<tr><td>13</td><td>test.py</td><td>implementace jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test5/test.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test5/test.py</a></td></tr>
<tr><td>14</td><td>run</td><td>skript pro spuštění aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test5/run">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test5/run</a></td></tr>
<tr><td>15</td><td>test</td><td>skript pro spuštění jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test5/test">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test5/test</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>application.py</td><td>implementace logiky aplikace, kterou budeme testovat</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test6/application.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test6/application.py</a></td></tr>
<tr><td>17</td><td>main.py</td><td>vstupní bod do testované aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test6/main.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test6/main.py</a></td></tr>
<tr><td>18</td><td>test.py</td><td>implementace jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test6/test.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test6/test.py</a></td></tr>
<tr><td>19</td><td>run</td><td>skript pro spuštění aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test6/run">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test6/run</a></td></tr>
<tr><td>20</td><td>test</td><td>skript pro spuštění jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test6/test">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test6/test</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>main.py</td><td>vstupní bod do testované aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test7/main.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test7/main.py</a></td></tr>
<tr><td>22</td><td>module1.py</td><td>první modul</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test7/module1.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test7/module1.py</a></td></tr>
<tr><td>23</td><td>module2.py</td><td>druhý modul</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test7/module2.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test7/module2.py</a></td></tr>
<tr><td>24</td><td>module3.py</td><td>třetí modul</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test7/module3.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test7/module3.py</a></td></tr>
<tr><td>25</td><td>test.py</td><td>implementace jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test7/test.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test7/test.py</a></td></tr>
<tr><td>26</td><td>run</td><td>skript pro spuštění aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test7/run">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test7/run</a></td></tr>
<tr><td>27</td><td>test</td><td>skript pro spuštění jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test7/test">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test7/test</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>28</td><td>main.py</td><td>vstupní bod do testované aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test8/main.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test8/main.py</a></td></tr>
<tr><td>29</td><td>module1.py</td><td>první modul</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test8/module1.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test8/module1.py</a></td></tr>
<tr><td>30</td><td>module2.py</td><td>druhý modul</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test8/module2.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test8/module2.py</a></td></tr>
<tr><td>31</td><td>module3.py</td><td>třetí modul</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test8/module3.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test8/module3.py</a></td></tr>
<tr><td>32</td><td>test.py</td><td>implementace jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test8/test.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test8/test.py</a></td></tr>
<tr><td>33</td><td>run</td><td>skript pro spuštění aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test8/run">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test8/run</a></td></tr>
<tr><td>34</td><td>test</td><td>skript pro spuštění jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test8/test">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test8/test</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>35</td><td>main.py</td><td>vstupní bod do testované aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test9/main.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test9/main.py</a></td></tr>
<tr><td>36</td><td>module1.py</td><td>první modul</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test9/module1.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test9/module1.py</a></td></tr>
<tr><td>37</td><td>module2.py</td><td>druhý modul</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test9/module2.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test9/module2.py</a></td></tr>
<tr><td>38</td><td>module3.py</td><td>třetí modul</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test9/module3.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test9/module3.py</a></td></tr>
<tr><td>39</td><td>test.py</td><td>implementace jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test9/test.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test9/test.py</a></td></tr>
<tr><td>40</td><td>run</td><td>skript pro spuštění aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test9/run">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test9/run</a></td></tr>
<tr><td>41</td><td>test</td><td>skript pro spuštění jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test9/test">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-test9/test</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>42</td><td>main.py</td><td>vstupní bod do testované aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testA/main.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testA/main.py</a></td></tr>
<tr><td>43</td><td>module1.py</td><td>první modul</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testA/module1.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testA/module1.py</a></td></tr>
<tr><td>44</td><td>module2.py</td><td>druhý modul</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testA/module2.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testA/module2.py</a></td></tr>
<tr><td>45</td><td>module3.py</td><td>třetí modul</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testA/module3.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testA/module3.py</a></td></tr>
<tr><td>46</td><td>test.py</td><td>implementace jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testA/test.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testA/test.py</a></td></tr>
<tr><td>47</td><td>run</td><td>skript pro spuštění aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testA/run">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testA/run</a></td></tr>
<tr><td>48</td><td>test</td><td>skript pro spuštění jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testA/test">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testA/test</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>49</td><td>main.py</td><td>vstupní bod do testované aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testB/main.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testB/main.py</a></td></tr>
<tr><td>50</td><td>module1.py</td><td>první modul</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testB/module1.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testB/module1.py</a></td></tr>
<tr><td>51</td><td>module2.py</td><td>druhý modul</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testB/module2.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testB/module2.py</a></td></tr>
<tr><td>52</td><td>module3.py</td><td>třetí modul</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testB/module3.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testB/module3.py</a></td></tr>
<tr><td>53</td><td>test.py</td><td>implementace jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testB/test.py">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testB/test.py</a></td></tr>
<tr><td>54</td><td>run</td><td>skript pro spuštění aplikace</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testB/run">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testB/run</a></td></tr>
<tr><td>55</td><td>test</td><td>skript pro spuštění jednotkových testů</td><td><a href="https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testB/test">https://github.com/tisnik/testing-in-python/blob/master/unittest_mock/mock-testB/test</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články s&nbsp;tématem testování (nejenom) v&nbsp;Pythonu</h2>

<p>Tématem testování jsme se již na stránkách Rootu několikrát zabývali. Jedná
se mj.&nbsp;o následující články:</p>

<ol>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave (druhá část)<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-druha-cast/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-druha-cast/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave (závěrečná část)<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-zaverecna-cast/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-zaverecna-cast/</a>
</li>

<li>Validace datových struktur v Pythonu pomocí knihoven Schemagic a Schema<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/</a>
</li>

<li>Validace datových struktur v Pythonu (2. část)<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-2-cast/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-2-cast/</a>
</li>

<li>Validace datových struktur v Pythonu (dokončení)<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-dokonceni/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-dokonceni/</a>
</li>

<li>Univerzální testovací nástroj Robot Framework<br />
<a href="https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework/">https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework/</a>
</li>

<li>Univerzální testovací nástroj Robot Framework a BDD testy<br />
<a href="https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework-a-bdd-testy/">https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework-a-bdd-testy/</a>
</li>

<li>Úvod do problematiky fuzzingu a fuzz testování<br />
<a href="https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani/">https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani/</a>
</li>

<li>Úvod do problematiky fuzzingu a fuzz testování – složení vlastního fuzzeru<br />
<a href="https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani-slozeni-vlastniho-fuzzeru/">https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani-slozeni-vlastniho-fuzzeru/</a>
</li>

<li>Knihovny a moduly usnadňující testování aplikací naprogramovaných v jazyce Clojure<br />
<a href="https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/">https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/</a>
</li>

<li>Validace dat s využitím knihovny spec v Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

<li>Testování aplikací naprogramovaných v jazyce Go<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/">https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/</a>
</li>

<li>Knihovny určené pro tvorbu testů v programovacím jazyce Go<br />
<a href="https://www.root.cz/clanky/knihovny-urcene-pro-tvorbu-testu-v-programovacim-jazyce-go/">https://www.root.cz/clanky/knihovny-urcene-pro-tvorbu-testu-v-programovacim-jazyce-go/</a>
</li>

<li>Testování aplikací psaných v Go s využitím knihoven Goblin a Frisby<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/">https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/</a>
</li>

<li>Testování Go aplikací s využitím knihovny GΩmega a frameworku Ginkgo<br />
<a href="https://www.root.cz/clanky/testovani-go-aplikaci-s-vyuzitim-knihovny-gomega-mega-a-frameworku-ginkgo/">https://www.root.cz/clanky/testovani-go-aplikaci-s-vyuzitim-knihovny-gomega-mega-a-frameworku-ginkgo/</a>
</li>

<li>Tvorba BDD testů s využitím jazyka Go a nástroje godog<br />
<a href="https://www.root.cz/clanky/tvorba-bdd-testu-s-vyuzitim-jazyka-go-a-nastroje-godog/">https://www.root.cz/clanky/tvorba-bdd-testu-s-vyuzitim-jazyka-go-a-nastroje-godog/</a>
</li>

<li>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem<br />
<a href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/">https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/</a>
</li>

<li>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem (dokončení)<br />
<a href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem-dokonceni/">https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem-dokonceni/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure (2)<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Awesome Python &ndash; testing<br />
<a href="https://github.com/vinta/awesome-python#testing">https://github.com/vinta/awesome-python#testing</a>
</li>

<li>Selenium (pro Python)<br />
<a href="https://pypi.org/project/selenium/">https://pypi.org/project/selenium/</a>
</li>

<li>Getting Started With Testing in Python<br />
<a href="https://realpython.com/python-testing/">https://realpython.com/python-testing/</a>
</li>

<li>unittest.mock — mock object library<br />
<a href="https://docs.python.org/3.5/library/unittest.mock.html">https://docs.python.org/3.5/library/unittest.mock.html</a>
</li>

<li>mock 2.0.0<br />
<a href="https://pypi.python.org/pypi/mock">https://pypi.python.org/pypi/mock</a>
</li>

<li>An Introduction to Mocking in Python<br />
<a href="https://www.toptal.com/python/an-introduction-to-mocking-in-python">https://www.toptal.com/python/an-introduction-to-mocking-in-python</a>
</li>

<li>Mock - Mocking and Testing Library<br />
<a href="http://mock.readthedocs.io/en/stable/">http://mock.readthedocs.io/en/stable/</a>
</li>

<li>Python Mocking 101: Fake It Before You Make It<br />
<a href="https://blog.fugue.co/2016-02-11-python-mocking-101.html">https://blog.fugue.co/2016-02-11-python-mocking-101.html</a>
</li>

<li>Nauč se Python! - Testování<br />
<a href="http://naucse.python.cz/lessons/intro/testing/">http://naucse.python.cz/lessons/intro/testing/</a>
</li>

<li>Flexmock (dokumentace)<br />
<a href="https://flexmock.readthedocs.io/en/latest/">https://flexmock.readthedocs.io/en/latest/</a>
</li>

<li>Test Fixture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test_fixture">https://en.wikipedia.org/wiki/Test_fixture</a>
</li>

<li>Mock object (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Mock_object">https://en.wikipedia.org/wiki/Mock_object</a>
</li>

<li>Extrémní programování<br />
<a href="https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD">https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD</a>
</li>

<li>Programování řízené testy<br />
<a href="https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy">https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>Tox<br />
<a href="https://tox.readthedocs.io/en/latest/">https://tox.readthedocs.io/en/latest/</a>
</li>

<li>pytest: helps you write better programs<br />
<a href="https://docs.pytest.org/en/latest/">https://docs.pytest.org/en/latest/</a>
</li>

<li>doctest — Test interactive Python examples<br />
<a href="https://docs.python.org/dev/library/doctest.html#module-doctest">https://docs.python.org/dev/library/doctest.html#module-doctest</a>
</li>

<li>unittest — Unit testing framework<br />
<a href="https://docs.python.org/dev/library/unittest.html">https://docs.python.org/dev/library/unittest.html</a>
</li>

<li>Python namespaces<br />
<a href="https://bytebaker.com/2008/07/30/python-namespaces/">https://bytebaker.com/2008/07/30/python-namespaces/</a>
</li>

<li>Namespaces and Scopes<br />
<a href="https://www.python-course.eu/namespaces.php">https://www.python-course.eu/namespaces.php</a>
</li>

<li>Stránka projektu Robot Framework<br />
<a href="https://robotframework.org/">https://robotframework.org/</a>
</li>

<li>GitHub repositář Robot Frameworku<br />
<a href="https://github.com/robotframework/robotframework">https://github.com/robotframework/robotframework</a>
</li>

<li>Robot Framework (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Robot_Framework">https://en.wikipedia.org/wiki/Robot_Framework</a>
</li>

<li>Tutoriál Robot Frameworku<br />
<a href="http://www.robotframeworktutorial.com/">http://www.robotframeworktutorial.com/</a>
</li>

<li>Robot Framework Documentation<br />
<a href="https://robotframework.org/robotframework/">https://robotframework.org/robotframework/</a>
</li>

<li>Robot Framework Introduction<br />
<a href="https://blog.testproject.io/2016/11/22/robot-framework-introduction/">https://blog.testproject.io/2016/11/22/robot-framework-introduction/</a>
</li>

<li>robotframework 3.1.2 na PyPi<br />
<a href="https://pypi.org/project/robotframework/">https://pypi.org/project/robotframework/</a>
</li>

<li>Robot Framework demo (GitHub)<br />
<a href="https://github.com/robotframework/RobotDemo">https://github.com/robotframework/RobotDemo</a>
</li>

<li>Robot Framework web testing demo using SeleniumLibrary<br />
<a href="https://github.com/robotframework/WebDemo">https://github.com/robotframework/WebDemo</a>
</li>

<li>Robot Framework for Mobile Test Automation Demo<br />
<a href="https://www.youtube.com/watch?v=06LsU08slP8">https://www.youtube.com/watch?v=06LsU08slP8</a>
</li>

<li>Gherkin<br />
<a href="https://cucumber.io/docs/gherkin/">https://cucumber.io/docs/gherkin/</a>
</li>

<li>Selenium<br />
<a href="https://selenium.dev/">https://selenium.dev/</a>
</li>

<li>SeleniumLibrary<br />
<a href="https://robotframework.org/">https://robotframework.org/</a>
</li>

<li>The Practical Test Pyramid<br />
<a href="https://martinfowler.com/articles/practical-test-pyramid.html">https://martinfowler.com/articles/practical-test-pyramid.html</a>
</li>

<li>Acceptance Tests and the Testing Pyramid<br />
<a href="http://www.blog.acceptancetestdrivendevelopment.com/acceptance-tests-and-the-testing-pyramid/">http://www.blog.acceptancetestdrivendevelopment.com/acceptance-tests-and-the-testing-pyramid/</a>
</li>

<li>Tab-separated values<br />
<a href="https://en.wikipedia.org/wiki/Tab-separated_values">https://en.wikipedia.org/wiki/Tab-separated_values</a>
</li>

<li>A quick guide about Python implementations<br />
<a href="https://blog.rmotr.com/a-quick-guide-about-python-implementations-aa224109f321">https://blog.rmotr.com/a-quick-guide-about-python-implementations-aa224109f321</a>
</li>

<li>radamsa<br />
<a href="https://gitlab.com/akihe/radamsa">https://gitlab.com/akihe/radamsa</a>
</li>

<li>Fuzzing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Fuzzing">https://en.wikipedia.org/wiki/Fuzzing</a>
</li>

<li>american fuzzy lop<br />
<a href="http://lcamtuf.coredump.cx/afl/">http://lcamtuf.coredump.cx/afl/</a>
</li>

<li>Fuzzing: the new unit testing<br />
<a href="https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide#1">https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide#1</a>
</li>

<li>Corpus for github.com/dvyukov/go-fuzz examples<br />
<a href="https://github.com/dvyukov/go-fuzz-corpus">https://github.com/dvyukov/go-fuzz-corpus</a>
</li>

<li>AFL &ndash; QuickStartGuide.txt<br />
<a href="https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt">https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt</a>
</li>

<li>Introduction to Fuzzing in Python with AFL<br />
<a href="https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/">https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/</a>
</li>

<li>Writing a Simple Fuzzer in Python<br />
<a href="https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/">https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/</a>
</li>

<li>How to Fuzz Go Code with go-fuzz (Continuously)<br />
<a href="https://fuzzit.dev/2019/10/02/how-to-fuzz-go-code-with-go-fuzz-continuously/">https://fuzzit.dev/2019/10/02/how-to-fuzz-go-code-with-go-fuzz-continuously/</a>
</li>

<li>Golang Fuzzing: A go-fuzz Tutorial and Example<br />
<a href="http://networkbit.ch/golang-fuzzing/">http://networkbit.ch/golang-fuzzing/</a>
</li>

<li>Fuzzing Python Modules<br />
<a href="https://stackoverflow.com/questions/20749026/fuzzing-python-modules">https://stackoverflow.com/questions/20749026/fuzzing-python-modules</a>
</li>

<li>0x3 Python Tutorial: Fuzzer<br />
<a href="http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/">http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/</a>
</li>

<li>fuzzing na PyPi<br />
<a href="https://pypi.org/project/fuzzing/">https://pypi.org/project/fuzzing/</a>
</li>

<li>Fuzzing 0.3.2 documentation<br />
<a href="https://fuzzing.readthedocs.io/en/latest/">https://fuzzing.readthedocs.io/en/latest/</a>
</li>

<li>Randomized testing for Go<br />
<a href="https://github.com/dvyukov/go-fuzz">https://github.com/dvyukov/go-fuzz</a>
</li>

<li>HTTP/2 fuzzer written in Golang<br />
<a href="https://github.com/c0nrad/http2fuzz">https://github.com/c0nrad/http2fuzz</a>
</li>

<li>Ffuf (Fuzz Faster U Fool) – An Open Source Fast Web Fuzzing Tool<br />
<a href="https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html">https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html</a>
</li>

<li>Continuous Fuzzing Made Simple<br />
<a href="https://fuzzit.dev/">https://fuzzit.dev/</a>
</li>

<li>Halt and Catch Fire<br />
<a href="https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86">https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86</a>
</li>

<li>Random testing<br />
<a href="https://en.wikipedia.org/wiki/Random_testing">https://en.wikipedia.org/wiki/Random_testing</a>
</li>

<li>Monkey testing<br />
<a href="https://en.wikipedia.org/wiki/Monkey_testing">https://en.wikipedia.org/wiki/Monkey_testing</a>
</li>

<li>Fuzzing for Software Security Testing and Quality Assurance, Second Edition<br />
<a href="https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false">https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false</a>
</li>

<li>libFuzzer – a library for coverage-guided fuzz testing<br />
<a href="https://llvm.org/docs/LibFuzzer.html">https://llvm.org/docs/LibFuzzer.html</a>
</li>

<li>fuzzy-swagger na PyPi<br />
<a href="https://pypi.org/project/fuzzy-swagger/">https://pypi.org/project/fuzzy-swagger/</a>
</li>

<li>fuzzy-swagger na GitHubu<br />
<a href="https://github.com/namuan/fuzzy-swagger">https://github.com/namuan/fuzzy-swagger</a>
</li>

<li>Fuzz testing tools for Python<br />
<a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy#Fuzz_Testing_Tools">https://wiki.python.org/moin/PythonTestingToolsTaxonomy#Fuzz_Testing_Tools</a>
</li>

<li>A curated list of awesome Go frameworks, libraries and software<br />
<a href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go</a>
</li>

<li>gofuzz: a library for populating go objects with random values<br />
<a href="https://github.com/google/gofuzz">https://github.com/google/gofuzz</a>
</li>

<li>tavor: A generic fuzzing and delta-debugging framework<br />
<a href="https://github.com/zimmski/tavor">https://github.com/zimmski/tavor</a>
</li>

<li>hypothesis na GitHubu<br />
<a href="https://github.com/HypothesisWorks/hypothesis">https://github.com/HypothesisWorks/hypothesis</a>
</li>

<li>Hypothesis: Test faster, fix more<br />
<a href="https://hypothesis.works/">https://hypothesis.works/</a>
</li>

<li>Hypothesis<br />
<a href="https://hypothesis.works/articles/intro/">https://hypothesis.works/articles/intro/</a>
</li>

<li>What is Hypothesis?<br />
<a href="https://hypothesis.works/articles/what-is-hypothesis/">https://hypothesis.works/articles/what-is-hypothesis/</a>
</li>

<li>Databáze CVE<br />
<a href="https://www.cvedetails.com/">https://www.cvedetails.com/</a>
</li>

<li>Fuzz test Python modules with libFuzzer<br />
<a href="https://github.com/eerimoq/pyfuzzer">https://github.com/eerimoq/pyfuzzer</a>
</li>

<li>Taof - The art of fuzzing<br />
<a href="https://sourceforge.net/projects/taof/">https://sourceforge.net/projects/taof/</a>
</li>

<li>JQF + Zest: Coverage-guided semantic fuzzing for Java<br />
<a href="https://github.com/rohanpadhye/jqf">https://github.com/rohanpadhye/jqf</a>
</li>

<li>http2fuzz<br />
<a href="https://github.com/c0nrad/http2fuzz">https://github.com/c0nrad/http2fuzz</a>
</li>

<li>Demystifying hypothesis testing with simple Python examples<br />
<a href="https://towardsdatascience.com/demystifying-hypothesis-testing-with-simple-python-examples-4997ad3c5294">https://towardsdatascience.com/demystifying-hypothesis-testing-with-simple-python-examples-4997ad3c5294</a>
</li>

<li>Testování<br />
<a href="http://voho.eu/wiki/testovani/">http://voho.eu/wiki/testovani/</a>
</li>

<li>Unit testing (Wikipedia.en)<br />
<a href="https://en.wikipedia.org/wiki/Unit_testing">https://en.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit testing (Wikipedia.cz)<br />
<a href="https://cs.wikipedia.org/wiki/Unit_testing">https://cs.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit Test vs Integration Test<br />
<a href="https://www.youtube.com/watch?v=0GypdsJulKE">https://www.youtube.com/watch?v=0GypdsJulKE</a>
</li>

<li>TestDouble<br />
<a href="https://martinfowler.com/bliki/TestDouble.html">https://martinfowler.com/bliki/TestDouble.html</a>
</li>

<li>Test Double<br />
<a href="http://xunitpatterns.com/Test%20Double.html">http://xunitpatterns.com/Test%20Double.html</a>
</li>

<li>Test-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test-driven_development">https://en.wikipedia.org/wiki/Test-driven_development</a>
</li>

<li>Acceptance test–driven development<br />
<a href="https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development">https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development</a>
</li>

<li>Gauge<br />
<a href="https://gauge.org/">https://gauge.org/</a>
</li>

<li>Gauge (software)<br />
<a href="https://en.wikipedia.org/wiki/Gauge_(software)">https://en.wikipedia.org/wiki/Gauge_(software)</a>
</li>

<li>PYPL PopularitY of Programming Language<br />
<a href="https://pypl.github.io/PYPL.html">https://pypl.github.io/PYPL.html</a>
</li>

<li>Testing is Good. Pyramids are Bad. Ice Cream Cones are the Worst<br />
<a href="https://medium.com/@fistsOfReason/testing-is-good-pyramids-are-bad-ice-cream-cones-are-the-worst-ad94b9b2f05f">https://medium.com/@fistsOfReason/testing-is-good-pyramids-are-bad-ice-cream-cones-are-the-worst-ad94b9b2f05f</a>
</li>

<li>Články a zprávičky věnující se Pythonu<br />
<a href="https://www.root.cz/n/python/">https://www.root.cz/n/python/</a>
</li>

<li>PythonTestingToolsTaxonomy<br />
<a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy">https://wiki.python.org/moin/PythonTestingToolsTaxonomy</a>
</li>

<li>Top 6 BEST Python Testing Frameworks [Updated 2020 List]<br />
<a href="https://www.softwaretestinghelp.com/python-testing-frameworks/">https://www.softwaretestinghelp.com/python-testing-frameworks/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

