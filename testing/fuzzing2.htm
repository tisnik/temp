<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Úvod do problematiky fuzzingu a fuzz testování - nástroj go-fuzz</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Úvod do problematiky fuzzingu a fuzz testování - nástroj go-fuzz</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhém článku o fuzzy testování a o fuzzerech obecně se budeme věnovat popisu způsobů použití existujících nástrojů. Prvním z&nbsp;těchto nástrojů je go-fuzz, který byl použit pro objevení mnoha chyb nejenom ve standardní knihovně jazyka Go.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Úvod do problematiky fuzzingu a fuzz testování &ndash; nástroj go-fuzz</a></p>
<p><a href="#k02">2. Základní algoritmus používaný nástrojem <i>go-fuzz</i></a></p>
<p><a href="#k03">3. Instalace nástroje <i>go-fuzz</i></a></p>
<p><a href="#k04">4. První demonstrační příklad &ndash; prázdná funkce</a></p>
<p><a href="#k05">5. Vytvoření základního korpusu a zahájení testování (fuzzingu)</a></p>
<p><a href="#k06">6. Druhý demonstrační příklad &ndash; funkce zpracovávající vstupní data</a></p>
<p><a href="#k07">7. Získání podezřelých vstupních dat pro druhý příklad</a></p>
<p><a href="#k08">8. Třetí demonstrační příklad s&nbsp;klasickou chybou &bdquo;&pm;1&ldquo;</a></p>
<p><a href="#k09">9. Získání vzorku vstupních dat způsobujících pád</a></p>
<p><a href="#k10">10. Funkce chybně testující vstupní data</a></p>
<p><a href="#k11">11. Příprava vstupů pro testovanou funkci a spuštění testů</a></p>
<p><a href="#k12">12. Analýza výsledků zjištěných fuzzerem</a></p>
<p><a href="#k13">13. Otestování funkčnosti dekodéru grafického formátu GIF</a></p>
<p><a href="#k14">14. Vytvoření <i>reproduceru</i> na základě chyb nalezených fuzzerem</a></p>
<p><a href="#k15">15. Obsah třetí části seriálu</a></p>
<p><a href="#k16">16. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k17">17. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Úvod do problematiky fuzzingu a fuzz testování &ndash; nástroj go-fuzz</h2>

<p>Ve druhém článku o <a
href="https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani/">fuzzy
testování</a> se již budeme věnovat popisu praktických způsobů použití
existujících nástrojů &ndash; <i>fuzzerů</i>. Prvním z&nbsp;těchto nástrojů je
<a href="https://github.com/dvyukov/go-fuzz">go-fuzz</a>, jehož autorem je
Dmitrij Vyukov (zaměstnanec Googlu, který pracuje na vývoji toolingu pro
programovací jazyk Go). Prezentace o <i>go-fuzz</i> (i o dalších nástrojích
určených pro testování) je k&nbsp;dispozici na adrese <a
href="https://talks.golang.org/2015/dynamic-tools.slide#1">https://talks.golang.org/2015/dynamic-tools.slide#1</a>,
ovšem velmi zajímavá je i Dmitrijova prezentace dostupná na <a
href="https://www.youtube.com/watch?v=a9xrxRsIbSU">Youtube</a> (používá
v&nbsp;ní stejné slajdy). <i>go-fuzz</i> je sice primárně určen pro <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">programovací jazyk
Go</a>, ovšem základní myšlenky, které v&nbsp;něm nalezneme, je možné nalézt i
v&nbsp;mnoha dalších podobně koncipovaných nástrojích, s&nbsp;nimiž se
seznámíme později.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Základní algoritmus používaný nástrojem <i>go-fuzz</i></h2>

<p>Základní algoritmus používaný nástrojem <i>go-fuzz</i> je možné popsat
následujícím (dosti zjednodušeným) pseudokódem:</p>

<pre>
proveď instrumentaci programu takovým způsobem, aby bylo možné zjišťovat pokrytí kódu
&nbsp;
for {
    zvol náhodný vstup z korpusu
    vhodným způsobem tento vstup modifikuj (mutuj)
    zavolej volaný kód a zjisti pokrytí kódu vstupními daty
    pokud se zvýšilo pokrytí popř. se nalezla nová cesta v kódu, přidej tento vstup do korpusu
}
</pre>

<p>Cílem základního algoritmu je tedy vytvořit takzvaný <i>korpus</i>, jinými
slovy (ve stručnosti řečeno) sadu vstupních dat, která ideálně pokryje všechny
možné cesty v&nbsp;programovém kódu, tedy i ty části, v&nbsp;nichž by se (pokud
je program korektní) měly testovat hodnoty <strong>nil</strong>, záporné
hodnoty, NaN, nekonečna, nekorektní vstupy atd. atd.</p>

<p>Následně se další algoritmus snaží o minimalizaci korpusu resp.&nbsp;o
nalezení nejkratší sekvence vstupních dat, které vedou k&nbsp;chybě či
k&nbsp;pádu testované aplikace.</p>

<p>Nástroj <i>go-fuzz</i> dokáže detekovat mj.&nbsp;i pády programu (například
při alokaci paměti), zavolání funkce <strong>panic()</strong>, ukončení
aplikace funkcí <strong>os.Exit()</strong>, souběh (<i>deadlock</i>) při práci
s&nbsp;gorutinami atd.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instalace nástroje <i>go-fuzz</i></h2>

<p>Instalace nástroje <i>go-fuzz</i> je (na rozdíl od mnoha jiných fuzzerů)
stejně snadná, jako instalace jakékoli jiné knihovny určené pro ekosystém
programovacího jazyka Go. Postačuje nám použít standardní příkaz <strong>go
get</strong>:</p>

<pre>
$ <strong>go get github.com/google/gofuzz</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: samotná instalace může zabrat určitou
relativně dlouhou dobu, protože v&nbsp;repositáři jsou již připraveny některé
hotové korpusy. Další korpusy jsou součástí samostatného repositáře dostupného
na adrese <a
href="https://github.com/dvyukov/go-fuzz-corpus">https://github.com/dvyukov/go-fuzz-corpus</a>.</div></p>

<p>Následně je dobré zkontrolovat, zda je korektně nastavena proměnná prostředí
<strong>GOPATH</strong> a <strong>PATH</strong>. V&nbsp;prvním případě lze
použít příkaz:</p>

<pre>
$ <strong>go env</strong>
</pre>

<p>V&nbsp;proměnné prostředí <strong>PATH</strong> by se měl objevit i adresář
<strong>$GOPATH/bin</strong>. V&nbsp;tomto adresáři by měly být umístěny
spustitelné soubory pojmenované <strong>go-fuzz</strong> a
<strong>go-fuzz-build</strong>, jejichž existenci a spustitelnost si ostatně
můžeme velmi snadno ověřit:</p>

<pre>
$ <strong>go-fuzz --help</strong>
&nbsp;
Usage of ./go-fuzz:
  -bin string
        test binary built with go-fuzz-build
  -connectiontimeout duration
        time limit for worker to try to connect coordinator (default 1m0s)
  -coordinator string
        coordinator mode (value is coordinator address)
  -covercounters
        use coverage hit counters (default true)
  -dumpcover
        dump coverage profile into workdir
  -dup
        collect duplicate crashers
  -func string
        function to fuzz
  -http string
        HTTP server listen address (coordinator mode only)
  -minimize duration
        time limit for input minimization (default 1m0s)
  -procs int
        parallelism level (default 4)
  -sonar
        use sonar hints (default true)
  -testoutput
        print test binary output to stdout (for debugging only)
  -timeout int
        test timeout, in seconds (default 10)
  -v int
        verbosity level
  -workdir string
        dir with persistent work data (default ".")
  -worker string
        worker mode (value is coordinator address)
</pre>

<p>a:</p>

<pre>
$ <strong>go-fuzz-build --help</strong>
&nbsp;
Usage of go-fuzz-build:
  -cpuprofile
        generate cpu profile in cpu.pprof
  -func string
        preferred entry function
  -libfuzzer
        output static archive for use with libFuzzer
  -o string
        output file
  -preserve string
        a comma-separated list of import paths not to instrument
  -race
        enable race detector
  -tags string
        a space-separated list of build tags to consider satisfied during the build
  -work
        don't remove working directory
  -x    print the commands if build fails
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. První demonstrační příklad &ndash; prázdná funkce</h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu, který naleznete na adrese <a
href="https://github.com/tisnik/fuzzing-examples/tree/master/go-fuzz/example1">https://github.com/tisnik/fuzzing-examples/tree/master/go-fuzz/example1</a>,
si pouze ukážeme, jaká vlastně vypadá základní struktura fuzzy testů a jaké
funkce dokáže nástroj <i>go-fuzz</i> (bez dalších úprav a přidaných vylepšení)
testovat. Nejprve vytvoříme nový balíček nazvaný <strong>example1</strong>,
který bude obsahovat testovanou funkci pojmenovanou pro jednoduchost přímočaře
<strong>TestedFunction</strong>. Tato funkce akceptuje řez bajtů,
tj.&nbsp;libovolně dlouhou (ale na začátku testování i prázdnou) sekvenci
bajtů. Samotná funkce má &ndash; alespoň prozatím &ndash; prázdné tělo, takže
celý balíček vypadá značně primitivně:</p>

<pre>
package <strong>example1</strong>
&nbsp;
func <strong>TestedFunction</strong>(data []byte) {
}
</pre>

<p><div class="rs-tip-major">Poznámka: reálně testované funkce pochopitelně
akceptují odlišné parametry; to je však situace, kterou je nutné zajistit
v&nbsp;dále popsané funkci <strong>Fuzz</strong>, která celé testování řídí.
Tuto možnost si ukážeme v&nbsp;navazujících kapitolách.</div></p>

<p>Následně je nutné vytvořit druhý soubor, v&nbsp;němž bude deklarována funkce
nazvaná <strong>Fuzz</strong> (toto jméno je nutné dodržet). Tato funkce, která
řídí celé testování, taktéž akceptuje parametr, jehož typ je řez bajtů.
Důležitá je i návratová hodnota (typu <strong>int</strong>), kterou je možné
řídit další kroky testování, a to konkrétně následujícím způsobem:</p>

<ul>

<li>Návratová hodnota rovna 1 značí, že by fuzzer měl zvýšit prioritu právě
použitých vstupních dat. Touto hodnotou lze označit všechny vstupy, které jsou
testovanou funkcí zpracovány korektně.</li>

<li>Návratová hodnota -1 naopak značí, že právě použitá vstupní data nemají být
přidána do korpusu, ať již jsou důvody jakékoli (například byla vstupní data
testovanou funkcí odmítnuta, což je zcela korektní).</li>

<li>A konečně hodnota 0 znamená, že se jedná o běžná data, která lze do korpusu
přidat, ale s&nbsp;nenastavenou prioritou.</li>

</ul>

<p><div class="rs-tip-major">Poznámka: žádné další návratové hodnoty by se
používat neměly, jsou totiž rezervovány pro další rozšiřování funkcionality
knihovny <i>go-fuzz</i>.</div></p>

<p>Velmi jednoduchá forma testovací funkce <strong>Fuzz</strong> může přímo
volat funkci testovanou, tedy funkci nazvanou <strong>TestedFunction</strong>.
Jedná se o nejjednodušší možný příklad:</p>

<pre>
<i>// +build gofuzz</i>
&nbsp;
package <strong>example1</strong>
&nbsp;
func <strong>Fuzz</strong>(data []byte) int {
        TestedFunction(data)
        return 0
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vytvoření základního korpusu a zahájení testování (fuzzingu)</h2>

<p>Před vlastním spuštěním testů je nejprve nutné provést přípravu projektu, a
to konkrétně zavoláním příkazu:</p>

<pre>
$ <strong>go-fuzz-build</strong>
</pre>

<p>Tento příkaz vytvoří pomocný soubor nazvaný
<strong>example1-fuzz.zip</strong>. Uvnitř tohoto souboru jsou
mj.&nbsp;zabaleny spustitelné soubory pojmenované <strong>cover.exe</strong> a
<strong>sonar.exe</strong>. I přes neobvyklé koncovky se jedná o soubory
spustitelné na dané architektuře a operačním systému (tedy i na Linuxu,
pochopitelně jen pokud se výše uvedený příkaz spouštěl taktéž na Linuxu).</p>

<p>Ve druhém kroku již můžeme spustit vlastní testy, a to příkazem:</p>

<pre>
$ <strong>go-fuzz</strong>
</pre>

<p>Po spuštění se začnou vypisovat informace o probíhajících testech:</p>

<pre>
2020/03/02 22:31:54 workers: 4, corpus: 1 (3s ago), crashers: 0, restarts: 1/0, execs: 0 (0/sec), cover: 0, uptime: 3s
2020/03/02 22:31:57 workers: 4, corpus: 1 (6s ago), crashers: 0, restarts: 1/0, execs: 0 (0/sec), cover: 2, uptime: 6s
2020/03/02 22:32:00 workers: 4, corpus: 1 (9s ago), crashers: 0, restarts: 1/3180, execs: 25446 (2827/sec), cover: 2, uptime: 9s
2020/03/02 22:32:03 workers: 4, corpus: 1 (12s ago), crashers: 0, restarts: 1/4266, execs: 51202 (4266/sec), cover: 2, uptime: 12s
2020/03/02 22:32:06 workers: 4, corpus: 1 (15s ago), crashers: 0, restarts: 1/6441, execs: 77294 (5152/sec), cover: 2, uptime: 15s
</pre>

<p>Povšimněte si, že se mj.&nbsp;vypisují i informace o čtyřech
&bdquo;workerech&ldquo;, což na mém počítači odpovídá počtu jader, ve
skutečnosti se však postupně spouští a opět zastavuje mnoho dalších procesů,
což nám prozradí například příkaz <strong>pstree</strong>:</p>

<pre>
go-fuzz─┬─4*[go-fuzz93667065───4*[{go-fuzz93667065}]]
        ├─3*[go-fuzz94444180───4*[{go-fuzz94444180}]]
        ├─go-fuzz94444180───5*[{go-fuzz94444180}]
        └─13*[{go-fuzz}]
</pre>

<p>Dále je ve výpisu patrné, že počet takzvaných &bdquo;crasherů&ldquo; je
nulový, což je pochopitelné, protože testovaná funkce je prázdná, tudíž
s&nbsp;velkou pravděpodobností za žádných (běžných) okolností nezhavaruje.</p>

<p>Testy, které lze mít puštěny libovolně dlouhou dobu (pouze narůstá účet za
elektřinu), můžeme kdykoli přerušit klávesovou zkratkou
<strong>Ctrl+C</strong>:</p>

<pre>
^C2020/03/02 22:32:09 shutting down...
</pre>

<p>Po ukončení testů si povšimněte, že se vytvořila trojice adresářů, přičemž
adresář se jménem <strong>corpus</strong> obsahuje prázdný soubor
s&nbsp;korpusem (prázdný je proto, že se nenašel problematický vstup). Adresáře
<strong>crashers</strong> a <strong>suppressions</strong> budou zcela
prázdné:</p>

<pre>
├── corpus
│   └── da39a3ee5e6b4b0d3255bfef95601890afd80709
├── crashers
├── example1-fuzz.zip
├── example1.go
├── fuzz.go
└── suppressions
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Druhý demonstrační příklad &ndash; funkce zpracovávající vstupní data</h2>

<p>Druhý demonstrační příklad, který si dnes ukážeme a který je uložen na
adrese <a
href="https://github.com/tisnik/fuzzing-examples/tree/master/go-fuzz/example2">https://github.com/tisnik/fuzzing-examples/tree/master/go-fuzz/example2</a>,
již bude nepatrně složitější (i když stále umělý), protože testovaná funkce
bude vstupní data generovaná fuzzerem zpracovávat. Konkrétně bude vracet
pravdivostní hodnotu <strong>true</strong> za podmínky, kdy sekvence vstupních
dat začíná bajty s&nbsp;hodnotami 0x03 0x02 a 0x01. Pro všechny ostatní
kombinace se vrátí pravdivostní hodnota <strong>false</strong>. Implementace je
snadná:</p>

<pre>
package <strong>example2</strong>
&nbsp;
func <strong>TestedFunction</strong>(data []byte) bool {
        if len(data) &gt;= 3 {
                if data[0] == 3 &amp;&amp; data[1] == 2 &amp;&amp; data[2] == 1 {
                        return true
                }
        }
        return false
}
</pre>

<p>Testovací funkce pojmenovaná <strong>Fuzz</strong> bude vypadat odlišně
&ndash; v&nbsp;závislosti na návratové hodnotě testované funkce se buď běžným
způsobem vrátí nulová hodnota, nebo funkce zhavaruje zavoláním
<strong>panic()</strong>, což je mimochodem zcela legální, protože fuzzer musí
umět zareagovat i na podobné situace:</p>

<pre>
<strong>// +build gofuzz</strong>
&nbsp;
package <strong>example2</strong>
&nbsp;
func <strong>Fuzz</strong>(data []byte) int {
        if TestedFunction(data) {
                panic("wrong input")
        }
        return 0
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Získání podezřelých vstupních dat pro druhý příklad</h2>

<p>Nyní si tedy otestujme druhý příklad, a to nám již známou sekvencí
příkazů:</p>

<pre>
$ <strong>go-fuzz-build</strong>
&nbsp;
$ <strong>go-fuzz</strong>
</pre>

<p>Samotný průběh testování je již v&nbsp;tomto případě odlišný, protože se již
prakticky od začátku vypisuje informace o tom, že byl nalezen jeden
&bdquo;crasher&ldquo;. Navíc je jiná (tedy nenulová) i velikost korpusu:</p>

<pre>
2020/03/02 22:29:14 workers: 4, corpus: 4 (2s ago), crashers: 1, restarts: 1/0, execs: 0 (0/sec), cover: 0, uptime: 3s
2020/03/02 22:29:17 workers: 4, corpus: 4 (5s ago), crashers: 1, restarts: 1/0, execs: 0 (0/sec), cover: 9, uptime: 6s
2020/03/02 22:29:20 workers: 4, corpus: 4 (8s ago), crashers: 1, restarts: 1/288, execs: 23371 (2596/sec), cover: 9, uptime: 9s
2020/03/02 22:29:23 workers: 4, corpus: 4 (11s ago), crashers: 1, restarts: 1/280, execs: 47101 (3925/sec), cover: 9, uptime: 12s
2020/03/02 22:29:26 workers: 4, corpus: 4 (14s ago), crashers: 1, restarts: 1/279, execs: 69568 (4638/sec), cover: 9, uptime: 15s
2020/03/02 22:29:29 workers: 4, corpus: 4 (17s ago), crashers: 1, restarts: 1/300, execs: 93328 (5185/sec), cover: 9, uptime: 18s
</pre>

<p>Testování lze po chvíli přerušit:</p>

<pre>
^C2020/03/02 22:29:30 shutting down...
</pre>

<p>V&nbsp;adresáři s&nbsp;projektem se opět vytvořilo několik podadresářů, ty
již však nejsou prázdné:</p>

<pre>
├── corpus
│   ├── 685ad06a33b3db3330ad4b19cf95fdd6acf3eceb-1
│   ├── 888693d736b5508655198129dc0ec8cf6d0e7757-2
│   ├── a6cd288e027237b261f24b1d140960ec48b6d63b-1
│   └── da39a3ee5e6b4b0d3255bfef95601890afd80709
├── crashers
│   ├── 134aead1d2020adfb1d2352b1dffb2afd8fe0dc5
│   ├── 134aead1d2020adfb1d2352b1dffb2afd8fe0dc5.output
│   └── 134aead1d2020adfb1d2352b1dffb2afd8fe0dc5.quoted
├── example2-fuzz.zip
├── example2.go
├── fuzz.go
└── suppressions
    └── a5d1237652e2eab23ab4f89b64348a150d2d77fa
</pre>

<p>Z&nbsp;hlediska programátora testujícího svoji aplikaci (resp.&nbsp;prozatím
jedinou funkci z&nbsp;této aplikace) je nejdůležitější obsah podadresáře
<strong>crashers</strong>, protože ten obsahuje ta vstupní data, která
způsobila chybu nebo dokonce pád testované funkce/aplikace/programu. Tyto
soubory můžeme prozkoumat (resp.&nbsp;měli bychom, protože se jedná právě o ty
informace, kvůli kterým se fuzzer pouští).</p>

<p>První z&nbsp;těchto souborů obsahuje binární podobu vstupních dat:</p>

<pre>
$ <strong>hd 134aead1d2020adfb1d2352b1dffb2afd8fe0dc5 </strong>
&nbsp;
00000000  03 02 01                                          |...|
00000003
</pre>

<p>Můžeme zde vidět, že se skutečně jedná o naši &bdquo;speciální&ldquo;
sekvenci tří bajtů.</p>

<p>V&nbsp;mnoha případech je vstup chápán jako text, což je reflektováno třetím
souborem, který obsahuje vstupní data, ovšem tentokrát v&nbsp;řetězcové
podobě:</p>

<pre>
$ <strong>cat 134aead1d2020adfb1d2352b1dffb2afd8fe0dc5.quoted </strong>
&nbsp;
        "\x03\x02\x01"

</pre>

<p>A konečně v&nbsp;posledním souboru jsou uloženy podrobnější informace o tom,
jak vypadal pád testované aplikace (v&nbsp;našem případě jediné funkce):</p>

<pre>
$ <strong>cat 134aead1d2020adfb1d2352b1dffb2afd8fe0dc5.output </strong>
&nbsp;
panic: wrong input
&nbsp;
goroutine 1 [running]:
_/home/tester/temp/out/fuzz/example2.Fuzz(0x7f182f247000, 0x3, 0x3, 0x3)
        /home/tester/temp/out/fuzz/example2/fuzz.go:7 +0xdc
go-fuzz-dep.Main(0xc000036780, 0x1, 0x1)
        /tmp/ramdisk/go-fuzz-build514602391/goroot/src/go-fuzz-dep/main.go:36 +0x1ad
main.main()
        /tmp/ramdisk/go-fuzz-build514602391/gopath/src/_/home/tester/temp/out/fuzz/example2/go.fuzz.main/main.go:15 +0x52
exit status 2
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Třetí demonstrační příklad s&nbsp;klasickou chybou &bdquo;&pm;1&ldquo;</h2>

<p><a
href="https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example3/example3.go">Třetí
testovaná funkce</a> vypadá zdánlivě nevinně &ndash; pokud se ve vstupní
sekvenci nachází bajty s&nbsp;obsahem 'r', 'o', 'o', 't', vypíše se na
standardní výstup zpráva. Ovšem ve skutečnosti je funkce naprogramována špatně
&ndash; obsahuje klasickou &bdquo;chybu &pm;1&ldquo;, protože testovaná délka
řezu by měla být větší nebo rovna čtyřem a nikoli třem:</p>

<pre>
package <strong>example3</strong>
&nbsp;
import "fmt"
&nbsp;
func <strong>TestedFunction</strong>(data []byte) {
        if len(data) &gt;= 3 {
                if data[0] == 'r' &amp;&amp; data[1] == 'o' &amp;&amp; data[2] == 'o' &amp;&amp; data[3] == 't' {
                        fmt.Println("Spravny vstup")
                }
        }
}
</pre>

<p>Tuto funkci budeme testovat prakticky stejným způsobem, jako obě funkce
předchozí, tj.&nbsp;vytvoříme si vlastní <a
href="https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example3/fuzz.go">implementaci
funkce Fuzz</a>:</p>

<pre>
<i>// +build gofuzz</i>
&nbsp;
package <strong>example3</strong>
&nbsp;
func <strong>Fuzz</strong>(data []byte) int {
        TestedFunction(data)
        return 0
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Získání vzorku vstupních dat způsobujících pád</h2>

<p>Nyní přišel čas na to, aby fuzzer správně rozpoznal, která vstupní sekvence
způsobí pád aplikace. Je nám již dopředu jasné, že se jedná o jedinou sekvenci,
ale bude úkolem fuzzeru tuto sekvenci zjistit. Opět použijeme nám již známé dva
příkazy:</p>

<pre>
$ <strong>go-fuzz-build</strong>
&nbsp;
$ <strong>go-fuzz</strong>
&nbsp;
2020/03/03 08:27:15 workers: 4, corpus: 6 (3s ago), crashers: 1, restarts: 1/0, execs: 0 (0/sec), cover: 0, uptime: 3s
2020/03/03 08:27:18 workers: 4, corpus: 6 (6s ago), crashers: 1, restarts: 1/0, execs: 0 (0/sec), cover: 112, uptime: 6s
2020/03/03 08:27:21 workers: 4, corpus: 6 (9s ago), crashers: 1, restarts: 1/532, execs: 22345 (2483/sec), cover: 112, uptime: 9s
2020/03/03 08:27:24 workers: 4, corpus: 6 (12s ago), crashers: 1, restarts: 1/359, execs: 44203 (3683/sec), cover: 112, uptime: 12s
2020/03/03 08:27:27 workers: 4, corpus: 6 (15s ago), crashers: 1, restarts: 1/326, execs: 65232 (4349/sec), cover: 112, uptime: 15s
2020/03/03 08:27:30 workers: 4, corpus: 6 (18s ago), crashers: 1, restarts: 1/306, execs: 86878 (4826/sec), cover: 112, uptime: 18s
2020/03/03 08:27:33 workers: 4, corpus: 6 (21s ago), crashers: 1, restarts: 1/298, execs: 107631 (5125/sec), cover: 112
...
...
...
^C2020/03/03 08:27:48 shutting down...
</pre>

<p>V&nbsp;adresáři <strong>crashers</strong> by se měly nacházet soubory se
sekvencí bajtů, kvůli které funkce zhavaruje:</p>

<pre>
$ <strong>ls -1 crashers/</strong>
&nbsp;
dc76e9f0c0006e8f919e0c515c66dbba3982f785
dc76e9f0c0006e8f919e0c515c66dbba3982f785.output
dc76e9f0c0006e8f919e0c515c66dbba3982f785.quoted
</pre>

<p>Nejdůležitější je hned první soubor s&nbsp;binární sekvencí, kterou skutečně
tvoří znaky "roo":</p>

<pre>
$ <strong>cat crashers/dc76e9f0c0006e8f919e0c515c66dbba3982f785</strong>
&nbsp;
roo
</pre>

<p>Dále zkontrolujeme, jakým způsobem a na základě jaké chyby vlastně aplikace
zhavarovala:</p>

<pre>
$ <strong>cat crashers/dc76e9f0c0006e8f919e0c515c66dbba3982f785.output </strong>
&nbsp;
panic: runtime error: index out of range
&nbsp;
goroutine 1 [running]:
_/home/tester/temp/out/fuzz/example4.TestedFunction.func3(...)
        /home/tester/temp/out/fuzz/example4/example3.go:7
_/home/tester/temp/out/fuzz/example4.TestedFunction(0x7f29a71b7000, 0x3, 0x3)
        /home/tester/temp/out/fuzz/example4/example3.go:7 +0x167
_/home/tester/temp/out/fuzz/example4.Fuzz(0x7f29a71b7000, 0x3, 0x3, 0x3)
        /home/tester/temp/out/fuzz/example4/fuzz.go:6 +0x57
go-fuzz-dep.Main(0xc000096f80, 0x1, 0x1)
        /tmp/ramdisk/go-fuzz-build367173585/goroot/src/go-fuzz-dep/main.go:36 +0x1ad
main.main()
        /tmp/ramdisk/go-fuzz-build367173585/gopath/src/_/home/tester/temp/out/fuzz/example4/go.fuzz.main/main.go:15 +0x52
exit status 2
</pre>

<p>A nakonec pro jistotu zjistíme, jak vypadají vstupní data převedená na
řetězec. Ani zde se o žádné překvapení nebude jednat:</p>

<pre>
$ <strong>cat crashers/dc76e9f0c0006e8f919e0c515c66dbba3982f785.quoted </strong>
&nbsp;
        "roo"
</pre>

<p><div class="rs-tip-major">Poznámka: fuzzer tedy správně zjistil, že funkce
je naprogramovaná špatně a zhavaruje na vstupu "roo".</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Funkce chybně testující vstupní data</h2>

<p>Čtvrtý příklad vznikl zjednodušením reálného programu. Je v&nbsp;něm
deklarována funkce, která na základě dvou vstupních parametrů alokuje paměť pro
bitmapu o zadaných rozměrech. Každý pixel bitmapy je uložen ve čtyřech bajtech.
Funkce (zdánlivě správně) testuje, zda nejsou rozměry bitmapy příliš velké, ale
již se zapomnělo na to, že vstupem mohou být záporná čísla. A ta jsou
nebezpečná ve dvou případech:</p>

<ol>

<li>Jeden vstup je kladný a druhý záporný &ndash; zde dojde k&nbsp;chybě při
alokaci kvůli zápornému počtu prvků</li>

<li>Oba vstupy jsou záporné. Toto je větší problém, protože vynásobením vznikne
kladné číslo, které je buď relativně malé a program nezhavaruje, nebo je naopak
příliš velké a dojde k&nbsp;chybě při alokaci paměti</li>

</ol>

<p>Zdrojový kód problematické funkce je dostupný na adrese <a
href="https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example4/example4.go">https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example4/example4.go</a>:</p>

<pre>
package <strong>example4</strong>
&nbsp;
import "fmt"
&nbsp;
const maxWidth = 1024
const maxHeight = 1024
&nbsp;
func <strong>TestedFunction</strong>(width int32, height int32) {
        if width &lt; maxWidth &amp;&amp; height &lt; maxHeight {
                size := 4 * width * height
                bitmap := make([]byte, size)
                fmt.Println(len(bitmap))
        }
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Příprava vstupů pro testovanou funkci a spuštění testů</h2>

<p>Nyní je již nutné připravit vhodná vstupní data, tedy dvojici hodnot typu
<strong>int32</strong> ze sekvence bajtů. Zvolme si ten nejpřímější a
nejprimitivnější způsob založený na vygenerování <strong>int32</strong> ze
čtveřice bajtů. Implementace funkce <strong>Fuzz</strong> může vypadat
následovně:</p>

<pre>
<i>// +build gofuzz</i>
&nbsp;
package <strong>example4</strong>
&nbsp;
func <strong>Fuzz</strong>(data []byte) int {
        if len(data) &gt;= 8 {
                width := int32(data[0]) + 256*int32(data[1]) + 65536*int32(data[2]) + 16777216*int32(data[3])
                height := int32(data[4]) + 256*int32(data[5]) + 65536*int32(data[6]) + 16777216*int32(data[7])
                TestedFunction(width, height)
        }
        return 0
}
</pre>

<p>Testy samozřejmě musíme spustit, abychom získali potřebné
&bdquo;crashery&ldquo;:</p>

<pre>
$ <strong>go-fuzz-build</strong>
&nbsp;
$ <strong>go-fuzz</strong>
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
2020/03/04 08:13:48 workers: 4, corpus: 3 (2s ago), crashers: 1, restarts: 1/0, execs: 0 (0/sec), cover: 0, uptime: 3s
2020/03/04 08:13:53 workers: 4, corpus: 4 (2s ago), crashers: 1, restarts: 1/0, execs: 0 (0/sec), cover: 7, uptime: 6s
2020/03/04 08:13:54 workers: 4, corpus: 4 (4s ago), crashers: 1, restarts: 1/18, execs: 458 (51/sec), cover: 111, uptime: 9s
2020/03/04 08:13:57 workers: 4, corpus: 4 (7s ago), crashers: 1, restarts: 1/22, execs: 901 (75/sec), cover: 111, uptime: 12s
2020/03/04 08:14:00 workers: 4, corpus: 4 (10s ago), crashers: 1, restarts: 1/22, execs: 901 (60/sec), cover: 111, uptime: 15s
2020/03/04 08:14:03 workers: 4, corpus: 4 (13s ago), crashers: 1, restarts: 1/22, execs: 901 (50/sec), cover: 111, uptime: 18s
2020/03/04 08:14:06 workers: 4, corpus: 4 (16s ago), crashers: 2, restarts: 1/22, execs: 913 (43/sec), cover: 111, uptime: 21s
2020/03/04 08:14:09 workers: 4, corpus: 4 (19s ago), crashers: 2, restarts: 1/43, execs: 1880 (78/sec), cover: 111, uptime: 24s
2020/03/04 08:14:12 workers: 4, corpus: 4 (22s ago), crashers: 2, restarts: 1/44, execs: 2032 (75/sec), cover: 111, uptime: 27s
2020/03/04 08:14:15 workers: 4, corpus: 4 (25s ago), crashers: 2, restarts: 1/44, execs: 2032 (68/sec), cover: 111, uptime: 30s
2020/03/04 08:14:18 workers: 4, corpus: 4 (28s ago), crashers: 2, restarts: 1/44, execs: 2032 (62/sec), cover: 111, uptime: 33s
^C2020/03/04 08:14:20 shutting down...
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že došlo k&nbsp;detekci
dvou &bdquo;crasherů&ldquo;. To je dobře, protože očekáváme výskyt dvou typů
chyb &ndash; použití záporné hodnoty a použití velké kladné hodnoty.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Analýza výsledků zjištěných fuzzerem</h2>

<p>Fuzzer našel obě chyby, což je patrné již při pohledu na počet
vygenerovaných souborů:</p>

<pre>
├── corpus
│   ├── 287ceb7f19a3d5a9ca72916101d863bef2d5fe66-1
│   ├── c487e35e15cf096317bfcd33cf6a95811b3e0b01-1
│   ├── da39a3ee5e6b4b0d3255bfef95601890afd80709
│   └── da67c6d8fb9354c0b9d0391663be4ab82974a0db-1
├── crashers
│   ├── 5a6899fa69a5a0ae44f2cf286c2dee3d83d5ff5c
│   ├── 5a6899fa69a5a0ae44f2cf286c2dee3d83d5ff5c.output
│   ├── 5a6899fa69a5a0ae44f2cf286c2dee3d83d5ff5c.quoted
│   ├── d14623983a778683ea98c8e411a1088aa29a1bdc
│   ├── d14623983a778683ea98c8e411a1088aa29a1bdc.output
│   └── d14623983a778683ea98c8e411a1088aa29a1bdc.quoted
├── example4-fuzz.zip
├── example4.go
├── fuzz.go
└── suppressions
    ├── 3d5a46d793c051d77b04f76d630edef78291da54
    └── a596442269a13f32d85889a173f2d36187a768c6

</pre>

<p>Podívejme se nyní nejprve na oba soubory s&nbsp;koncovkou
<strong>.output</strong>. Ty obsahují informace o nalezené chybě.</p>

<p>První soubor:</p>

<pre>
2018609124
358989248
442121188
panic: runtime error: makeslice: len out of range
&nbsp;
goroutine 1 [running]:
_/home/tester/temp/fuzzing-examples/go-fuzz/example4.TestedFunction(0xbd30efbdbfef30ed)
        /home/tester/temp/fuzzing-examples/go-fuzz/example4/example4.go:11 +0xc5
_/home/tester/temp/fuzzing-examples/go-fuzz/example4.Fuzz(0x7f738baed000, 0x8, 0x8, 0x3)
        /home/tester/temp/fuzzing-examples/go-fuzz/example4/fuzz.go:9 +0xec
go-fuzz-dep.Main(0xc0785acf80, 0x1, 0x1)
        /tmp/ramdisk/go-fuzz-build858165217/goroot/src/go-fuzz-dep/main.go:36 +0x1ad
main.main()
        /tmp/ramdisk/go-fuzz-build858165217/gopath/src/_/home/tester/temp/fuzzing-examples/go-fuzz/example4/go.fuzz.main/main.go:15 +0x52
exit status 2
</pre>

<p>Druhý soubor:</p>

<pre>
program hanged (timeout 10 seconds)
&nbsp;
840167040
1513871568
SIGABRT: abort
PC=0x451b33 m=0 sigcode=0
&nbsp;
goroutine 0 [idle]:
runtime.memclrNoHeapPointers(0xc0321f4000, 0x548f6000)
        /tmp/ramdisk/go-fuzz-build858165217/goroot/src/runtime/memclr_amd64.s:46 +0x83
runtime.(*mheap).alloc(0x57ebc0, 0x2a47b, 0x7ffd47010101, 0x413325)
        /tmp/ramdisk/go-fuzz-build858165217/goroot/src/runtime/mheap.go:764 +0xda
runtime.largeAlloc(0x548f5efc, 0x101, 0xc0321e8e58)
        /tmp/ramdisk/go-fuzz-build858165217/goroot/src/runtime/malloc.go:1019 +0x97
runtime.mallocgc.func1()
        /tmp/ramdisk/go-fuzz-build858165217/goroot/src/runtime/malloc.go:914 +0x46
runtime.systemstack(0x44ec09)
        /tmp/ramdisk/go-fuzz-build858165217/goroot/src/runtime/asm_amd64.s:351 +0x66
runtime.mstart()
        /tmp/ramdisk/go-fuzz-build858165217/goroot/src/runtime/proc.go:1229
&nbsp;
goroutine 1 [running]:
runtime.systemstack_switch()
        /tmp/ramdisk/go-fuzz-build858165217/goroot/src/runtime/asm_amd64.s:311 fp=0xc0321e8d80 sp=0xc0321e8d78 pc=0x44ed00
runtime.mallocgc(0x548f5efc, 0x4b31e0, 0x464201, 0x4)
        /tmp/ramdisk/go-fuzz-build858165217/goroot/src/runtime/malloc.go:913 +0x896 fp=0xc0321e8e20 sp=0xc0321e8d80 pc=0x40ab06
runtime.makeslice(0x4b31e0, 0x548f5efc, 0x548f5efc, 0x13a2d062, 0x13a2d06200000000, 0x5e5f552f)
        /tmp/ramdisk/go-fuzz-build858165217/goroot/src/runtime/slice.go:70 +0x77 fp=0xc0321e8e50 sp=0xc0321e8e20 pc=0x43af07
_/home/tester/temp/fuzzing-examples/go-fuzz/example4.TestedFunction(0x853b95bfef5c3e01)
        /home/tester/temp/fuzzing-examples/go-fuzz/example4/example4.go:11 +0xc5 fp=0xc0321e8ea0 sp=0xc0321e8e50 pc=0x4a27e5
_/home/tester/temp/fuzzing-examples/go-fuzz/example4.Fuzz(0x7fc302a26000, 0xa, 0xa, 0x3)
        /home/tester/temp/fuzzing-examples/go-fuzz/example4/fuzz.go:9 +0xec fp=0xc0321e8eb8 sp=0xc0321e8ea0 pc=0x4a293c
go-fuzz-dep.Main(0xc0321e8f80, 0x1, 0x1)
        /tmp/ramdisk/go-fuzz-build858165217/goroot/src/go-fuzz-dep/main.go:36 +0x1ad fp=0xc0321e8f68 sp=0xc0321e8eb8 pc=0x46400d
main.main()
        /tmp/ramdisk/go-fuzz-build858165217/gopath/src/_/home/tester/temp/fuzzing-examples/go-fuzz/example4/go.fuzz.main/main.go:15 +0x52 fp=0xc0321e8f98 sp=0xc0321e8f68 pc=0x4a2a12
runtime.main()
        /tmp/ramdisk/go-fuzz-build858165217/goroot/src/runtime/proc.go:201 +0x207 fp=0xc0321e8fe0 sp=0xc0321e8f98 pc=0x428bf7
runtime.goexit()
        /tmp/ramdisk/go-fuzz-build858165217/goroot/src/runtime/asm_amd64.s:1333 +0x1 fp=0xc0321e8fe8 sp=0xc0321e8fe0 pc=0x450c61
&nbsp;
rax    0x0
rbx    0x90ac000
rcx    0x548f6000
rdx    0x0
rdi    0xc07da3e000
rsi    0x2a47b
rbp    0x7ffd47930250
rsp    0x7ffd47930208
r8     0x7fc304e9fbe8
r9     0x2a47b
r10    0x1574
r11    0x2a47a
r12    0x0
r13    0x2
r14    0x7
r15    0x4
rip    0x451b33
rflags 0x10206
cs     0x33
fs     0x0
gs     0x0
exit status 2
</pre>

<p>Vidíme, že se v&nbsp;prvním případě jednalo o použití záporného indexu a
v&nbsp;případě druhém o použití dvou záporných čísel, které po vynásobení
vytvořily poměrně velkou kladnou hodnotu. To lze zjistit i z&nbsp;binárních
souborů s&nbsp;obsahem vstupních dat:</p>

<pre>
$ <strong>hd 611d6b397393720522e9fafe1f95081e64a586ff </strong>
&nbsp;
00000000  ed 30 ef bf bd ef 30 bd                           |.0....0.|
00000008
&nbsp;
$ <strong>hd f2d89e79c00e2ab6dfbc262a5ca9fbb30a5e236c </strong>
&nbsp;
00000000  01 3e 5c ef bf 95 3b 85  32 b1                    |.&gt;\...;.2.|
0000000a
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Otestování funkčnosti dekodéru grafického formátu GIF</h2>

<p>Další příklad je již skutečně získán z&nbsp;reálného světa, protože podobným
způsobem Dmitrij zjistil problémy ve standardní knihovně jazyka Go. Tyto
problémy jsou již opraveny, ovšem teoreticky si můžete spustit fuzzer oproti Go
verze 1.5:</p>

<pre>
package <strong>example5</strong>
&nbsp;
import (
        "bytes"
        "image/gif"
)
&nbsp;
func <strong>TestedFunction</strong>(data []byte) int {
        img, err := gif.Decode(bytes.NewReader(data))
        <i>// chyba nastat muze - na vstupu jsou nahodna data</i>
        if err != nil {
                <i>// ovsem img by melo byt rovno nil</i>
                if img != nil {
                        panic("img != nil on error")
                }
                <i>// jinak ok</i>
                return 0
        }
        <i>// pokus o zpetne vytvoreni obrazku</i>
        <i>// pro vsechny vstupy, ktere probehly "korektne"</i>
        var w bytes.Buffer
        err = gif.Encode(&amp;w, img, nil)
        if err != nil {
                panic(err)
        }
        return 1
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že vracíme hodnoty 0 nebo
1, čímž fuzzeru oznamujeme, která data se mají přidat do korpusu a která naopak
nikoli.</div></p>

<p>Testovací funkce je shodná s&nbsp;prvními příklady:</p>

<pre>
<i>// +build gofuzz</i>
&nbsp;
package <strong>example5</strong>
&nbsp;
func <strong>Fuzz</strong>(data []byte) int {
        return TestedFunction(data)
}
</pre>

<p>Testování na novější verzi Go (než 1.5) by mělo proběhnout za všech
okolností v&nbsp;pořádku, ovšem když budete trpěliví, možná nějakou chybu
nakonec objevíte:</p>

<pre>
2020/03/04 08:42:09 workers: 4, corpus: 57 (0s ago), crashers: 0, restarts: 1/0, execs: 0 (0/sec), cover: 0, uptime: 3s
2020/03/04 08:42:12 workers: 4, corpus: 59 (2s ago), crashers: 0, restarts: 1/0, execs: 0 (0/sec), cover: 276, uptime: 6s
2020/03/04 08:42:15 workers: 4, corpus: 59 (5s ago), crashers: 0, restarts: 1/2506, execs: 20048 (2227/sec), cover: 276, uptime: 9s
...
...
...
2020/03/04 08:42:33 workers: 4, corpus: 59 (23s ago), crashers: 0, restarts: 1/6702, execs: 160850 (5957/sec), cover: 276, uptime: 27s
2020/03/04 08:42:36 workers: 4, corpus: 59 (26s ago), crashers: 0, restarts: 1/7481, execs: 179551 (5985/sec), cover: 276, uptime: 30s
2020/03/04 08:42:39 workers: 4, corpus: 59 (29s ago), crashers: 0, restarts: 1/8228, execs: 197480 (5984/sec), cover: 276, uptime: 33s
^C2020/03/04 08:42:40 shutting down...
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Vytvoření <i>reproduceru</i> na základě chyb nalezených fuzzerem</h2>

<p>Pokud fuzzer nalezne sekvenci bajtů, která způsobuje pád nějaké funkce, je
již snadné vytvořit na základě těchto dat <i>reproducer</i>, tj.&nbsp;co
nejkratší kód, který chybu demonstruje a každý si ji může ověřit. Následující
reproducer byl skutečně podobným způsobem vytvořen a naleznete ho na adrese <a
href="https://github.com/golang/go/issues/11150">https://github.com/golang/go/issues/11150</a>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
    "bytes"
    "image/gif"
)
&nbsp;
func <strong>main</strong>() {
    data := []byte("GIF89a000\x00000,00\x00\x00\x00\x000\x000\x02\b\r0000000\x00;")
    img, err := gif.Decode(bytes.NewReader(data))
    if err != nil {
        panic(err)
    }
    var w bytes.Buffer
    err = gif.Encode(&amp;w, img, nil)
    if err != nil {
        panic(err)
    }
    _, err = gif.Decode(&amp;w)
    if err != nil {
        panic(err)
    }
}
</pre>

<p>Chybové hlášení:</p>

<pre>
panic: gif: cannot encode image block with empty palette
&nbsp;
goroutine 1 [running]:
main.main()
    gif.go:17 +0x219
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Obsah třetí části seriálu</h2>

<p>Klasické fuzzery jsou založeny na generování pseudonáhodných sekvencí bajtů,
což je vhodné pro testování binárních API a ABI. Ovšem v&nbsp;praxi se často
setkáme s&nbsp;API akceptující formáty JSON, XML atd., tedy nějakým způsobem
strukturovaná a mnohdy textová data. Touto problematikou se budeme zabývat
příště.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/fuzzing-examples">https://github.com/tisnik/fuzzing-examples</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem &ndash;
alespoň prozatím &ndash; velmi malý, dnes má přibližně šest až sedm megabajtů),
můžete namísto toho použít odkazy na jednotlivé demonstrační příklady, které
naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>example1.go</td><td>prázdná funkce, která se má testovat (nikdy nezhavaruje)</td><td><a href="https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example1/example1.go">https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example1/example1.go</a></td></tr>
<tr><td> 2</td><td>fuzz.go</td><td>vstupní bod fuzzy testů</td><td><a href="https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example1/fuzz.go">https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example1/fuzz.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>example2.go</td><td>funkce, která zpracovává vstupy, nikdy nezhavaruje</td><td><a href="https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example2/example2.go">https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example2/example2.go</a></td></tr>
<tr><td> 4</td><td>fuzz.go</td><td>vstupní bod fuzzy testů, může zhavarovat na základě výsledku</td><td><a href="https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example2/fuzz.go">https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example2/fuzz.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>example3.go</td><td>funkce obsahující chybu &ndash; přístup na neexistující prvek řezu při vhodném vstupu</td><td><a href="https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example3/example3.go">https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example3/example3.go</a></td></tr>
<tr><td> 6</td><td>fuzz.go</td><td>vstupní bod fuzzy testů</td><td><a href="https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example3/fuzz.go">https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example3/fuzz.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>example4.go</td><td>funkce obsahující dvě chyby &ndash; špatná práce se zápornými hodnotami</td><td><a href="https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example4/example4.go">https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example4/example4.go</a></td></tr>
<tr><td> 8</td><td>fuzz.go</td><td>vstupní bod fuzzy testů</td><td><a href="https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example4/fuzz.go">https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example4/fuzz.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>example5.go</td><td>otestování, jak se provádí zápis a čtení rastrových dat ve formátu GIF</td><td><a href="https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example5/example5.go">https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example5/example5.go</a></td></tr>
<tr><td>10</td><td>fuzz.go</td><td>vstupní bod fuzzy testů</td><td><a href="https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example5/fuzz.go">https://github.com/tisnik/fuzzing-examples/blob/master/go-fuzz/example5/fuzz.go</a></td></tr>
</table>



<p><a name="k17"></a></p>
<h2 id="k17">17. Odkazy na Internetu</h2>

<ol>

<li>Fuzzing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Fuzzing">https://en.wikipedia.org/wiki/Fuzzing</a>
</li>

<li>american fuzzy lop<br />
<a href="http://lcamtuf.coredump.cx/afl/">http://lcamtuf.coredump.cx/afl/</a>
</li>

<li>Fuzzing: the new unit testing<br />
<a href="https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide#1">https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide#1</a>
</li>

<li>Corpus for github.com/dvyukov/go-fuzz examples<br />
<a href="https://github.com/dvyukov/go-fuzz-corpus">https://github.com/dvyukov/go-fuzz-corpus</a>
</li>

<li>AFL &ndash; QuickStartGuide.txt<br />
<a href="https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt">https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt</a>
</li>

<li>Introduction to Fuzzing in Python with AFL<br />
<a href="https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/">https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/</a>
</li>

<li>Writing a Simple Fuzzer in Python<br />
<a href="https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/">https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/</a>
</li>

<li>How to Fuzz Go Code with go-fuzz (Continuously)<br />
<a href="https://fuzzit.dev/2019/10/02/how-to-fuzz-go-code-with-go-fuzz-continuously/">https://fuzzit.dev/2019/10/02/how-to-fuzz-go-code-with-go-fuzz-continuously/</a>
</li>

<li>Golang Fuzzing: A go-fuzz Tutorial and Example<br />
<a href="http://networkbit.ch/golang-fuzzing/">http://networkbit.ch/golang-fuzzing/</a>
</li>

<li>Fuzzing Python Modules<br />
<a href="https://stackoverflow.com/questions/20749026/fuzzing-python-modules">https://stackoverflow.com/questions/20749026/fuzzing-python-modules</a>
</li>

<li>0x3 Python Tutorial: Fuzzer<br />
<a href="http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/">http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/</a>
</li>

<li>fuzzing na PyPi<br />
<a href="https://pypi.org/project/fuzzing/">https://pypi.org/project/fuzzing/</a>
</li>

<li>Fuzzing 0.3.2 documentation<br />
<a href="https://fuzzing.readthedocs.io/en/latest/">https://fuzzing.readthedocs.io/en/latest/</a>
</li>

<li>Randomized testing for Go<br />
<a href="https://github.com/dvyukov/go-fuzz">https://github.com/dvyukov/go-fuzz</a>
</li>

<li>HTTP/2 fuzzer written in Golang<br />
<a href="https://github.com/c0nrad/http2fuzz">https://github.com/c0nrad/http2fuzz</a>
</li>

<li>Ffuf (Fuzz Faster U Fool) – An Open Source Fast Web Fuzzing Tool<br />
<a href="https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html">https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html</a>
</li>

<li>Continuous Fuzzing Made Simple<br />
<a href="https://fuzzit.dev/">https://fuzzit.dev/</a>
</li>

<li>Halt and Catch Fire<br />
<a href="https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86">https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86</a>
</li>

<li>Pentium F00F bug<br />
<a href="https://en.wikipedia.org/wiki/Pentium_F00F_bug">https://en.wikipedia.org/wiki/Pentium_F00F_bug</a>
</li>

<li>Random testing<br />
<a href="https://en.wikipedia.org/wiki/Random_testing">https://en.wikipedia.org/wiki/Random_testing</a>
</li>

<li>Monkey testing<br />
<a href="https://en.wikipedia.org/wiki/Monkey_testing">https://en.wikipedia.org/wiki/Monkey_testing</a>
</li>

<li>Fuzzing for Software Security Testing and Quality Assurance, Second Edition<br />
<a href="https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false">https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false</a>
</li>

<li>Z80 Undocumented Instructions<br />
<a href="http://www.z80.info/z80undoc.htm">http://www.z80.info/z80undoc.htm</a>
</li>

<li>The 6502/65C02/65C816 Instruction Set Decoded<br />
<a href="http://nparker.llx.com/a2/opcodes.html">http://nparker.llx.com/a2/opcodes.html</a>
</li>

<li>libFuzzer – a library for coverage-guided fuzz testing<br />
<a href="https://llvm.org/docs/LibFuzzer.html">https://llvm.org/docs/LibFuzzer.html</a>
</li>

<li>fuzzy-swagger na PyPi<br />
<a href="https://pypi.org/project/fuzzy-swagger/">https://pypi.org/project/fuzzy-swagger/</a>
</li>

<li>fuzzy-swagger na GitHubu<br />
<a href="https://github.com/namuan/fuzzy-swagger">https://github.com/namuan/fuzzy-swagger</a>
</li>

<li>Fuzz testing tools for Python<br />
<a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy#Fuzz_Testing_Tools">https://wiki.python.org/moin/PythonTestingToolsTaxonomy#Fuzz_Testing_Tools</a>
</li>

<li>A curated list of awesome Go frameworks, libraries and software<br />
<a href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go</a>
</li>

<li>gofuzz: a library for populating go objects with random values<br />
<a href="https://github.com/google/gofuzz">https://github.com/google/gofuzz</a>
</li>

<li>tavor: A generic fuzzing and delta-debugging framework<br />
<a href="https://github.com/zimmski/tavor">https://github.com/zimmski/tavor</a>
</li>

<li>hypothesis na GitHubu<br />
<a href="https://github.com/HypothesisWorks/hypothesis">https://github.com/HypothesisWorks/hypothesis</a>
</li>

<li>Hypothesis: Test faster, fix more<br />
<a href="https://hypothesis.works/">https://hypothesis.works/</a>
</li>

<li>Hypothesis<br />
<a href="https://hypothesis.works/articles/intro/">https://hypothesis.works/articles/intro/</a>
</li>

<li>What is Hypothesis?<br />
<a href="https://hypothesis.works/articles/what-is-hypothesis/">https://hypothesis.works/articles/what-is-hypothesis/</a>
</li>

<li>Databáze CVE<br />
<a href="https://www.cvedetails.com/">https://www.cvedetails.com/</a>
</li>

<li>Fuzz test Python modules with libFuzzer<br />
<a href="https://github.com/eerimoq/pyfuzzer">https://github.com/eerimoq/pyfuzzer</a>
</li>

<li>Taof - The art of fuzzing<br />
<a href="https://sourceforge.net/projects/taof/">https://sourceforge.net/projects/taof/</a>
</li>

<li>JQF + Zest: Coverage-guided semantic fuzzing for Java<br />
<a href="https://github.com/rohanpadhye/jqf">https://github.com/rohanpadhye/jqf</a>
</li>

<li>http2fuzz<br />
<a href="https://github.com/c0nrad/http2fuzz">https://github.com/c0nrad/http2fuzz</a>
</li>

<li>Demystifying hypothesis testing with simple Python examples<br />
<a href="https://towardsdatascience.com/demystifying-hypothesis-testing-with-simple-python-examples-4997ad3c5294">https://towardsdatascience.com/demystifying-hypothesis-testing-with-simple-python-examples-4997ad3c5294</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

