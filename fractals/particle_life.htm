<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Emergence: struktury vzniklé ze zdánlivého chaosu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Emergence: struktury vzniklé ze zdánlivého chaosu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V některých dynamických systémech mohou i na základě aplikace mnohdy velmi jednoduchých pravidel vznikat složitější emergentní struktury. Dnes si jeden takový systém nazývaný ParticleLife popíšeme a naprogramujeme.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Emergence: struktury vzniklé ze zdánlivého chaosu</a></p>
<p><a href="#k02">2. Jednoduchý framework pro zobrazení částicového systému</a></p>
<p><a href="#k03">3. Ukázka obrazovky s&nbsp;vizualizovaným statickým částicovým systémem</a></p>
<p><a href="#k04">4. Realizace dynamického částicového systému</a></p>
<p><a href="#k05">5. Výpočet nové pozice částic na základě jejich rychlosti a případných odrazů</a></p>
<p><a href="#k06">6. Ukázky grafické plochy s&nbsp;vizualizovaným dynamickým částicovým systémem</a></p>
<p><a href="#k07">7. Přidání pravidla pro vzájemné odpuzování částic</a></p>
<p><a href="#k08">8. Ukázky grafické plochy s&nbsp;vizualizovaným dynamickým částicovým systémem</a></p>
<p><a href="#k09">9. Větší množství částicových systémů</a></p>
<p><a href="#k10">10. Ukázky grafické plochy s&nbsp;vizualizovaným dynamickým částicovým systémem</a></p>
<p><a href="#k11">11. Pravidla pro interakci mezi částicemi z&nbsp;různých systémů</a></p>
<p><a href="#k12">12. Změna funkce <strong>apply_rule</strong> na <strong>apply_rules</strong></a></p>
<p><a href="#k13">13. Ukázky grafické plochy s&nbsp;vizualizovaným dynamickým částicovým systémem</a></p>
<p><a href="#k14">14. Další vylepšení interaktivity</a></p>
<p><a href="#k15">15. Funkce se smyčkou pro obsluhu událostí</a></p>
<p><a href="#k16">*** 16. Ukázky grafické plochy s&nbsp;vizualizovaným dynamickým částicovým systémem</a></p>
<p><a href="#k17">17. Realizace částicového systému v&nbsp;Pythonu</a></p>
<p><a href="#k18">18. Příloha: modul <strong>gfx</strong></a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Emergence: struktury vzniklé ze zdánlivého chaosu</h2>

<p>V&nbsp;některých dynamických systémech mohou i na základě aplikace mnohdy
velmi jednoduchých pravidel vznikat složitější <i>emergentní</i> struktury.
Tato vlastnost se týká mnoha typů <i>komplexních systémů</i> s&nbsp;mnohdy
složitě popsanými entitami (nebo objekty, i když v&nbsp;kontextu IT je tento
termín zavádějící), ovšem nás budou v&nbsp;dnešním (i v&nbsp;navazujícím)
článku zajímat především takové komplexní systémy, v&nbsp;nichž je možné
vlastnosti jejich jednotlivých entit resp.&nbsp;elementů reprezentovat jako
body v&nbsp;ploše či v&nbsp;prostoru. Stav takového dynamického systému je tedy
popsán pozicemi těchto bodů, k&nbsp;nimž se většinou přidává i vektor
rychlosti.</p>

<img src="https://i.iinfo.cz/images/578/bokeh-02-5.png" class="image-576828" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="907" height="915" />
<p><i>Obrázek 1: Lorenzův atraktor je známým dynamickým systémem s&nbsp;podivným atraktorem.</i></p>

<p>Poměrně známým příkladem mohou být různé systémy částic (<i>particle
systems</i>), v&nbsp;nichž je možné při vhodné definici pravidel chování
jednotlivých částic taktéž nalézt mnohdy velmi zajímavě vypadající emergentní
struktury. Toto téma je sice poměrně rozsáhlé a vyžádá si nejméně jeden
samostatný článek (navíc trošku mimo hlavní záběr Roota), ovšem již dnes si
můžeme jeden takový jednoduše implementovatelný částicový systém ukázat. A
vzhledem k&nbsp;tomu, že dále zmíněný částicový systém vede ke vzniku
emergentní struktury (a nikoli pouze náhodného &bdquo;oblaku&ldquo; bodů),
budeme moci výsledek vizualizovat a to nikoli jako pouhý statický obrázek, ale
jako animaci ukazující postupný rozvoj tohoto dynamického systému.</p>

<p><div class="rs-tip-major">Poznámka: vzhledem k&nbsp;tomu, že budeme chtít
zobrazit animaci s&nbsp;postupným vývojem dynamického systému, bude jeho
realizace provedena v&nbsp;jazyku C. Pokud vás zajímá, jak by mohla vypadat
realizace v&nbsp;Pythonu, podívejte se na <a href="#k17">kapitolu
17</a>.</div></p>

<img src="https://i.iinfo.cz/images/392/torch4-4.png" class="image-309065" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 2: Lorenzův atraktor vykreslený ve formě 3D grafu.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Jednoduchý framework pro zobrazení částicového systému</h2>

<p>Pro účely vizualizace postupné změny stavu dynamického systému (tedy pro
tvorbu animací) si vytvoříme jednoduchý framework, který budeme v&nbsp;rámci
dalších kapitol postupně vylepšovat. Nejprve nastavíme okraje okna, do kterých
nebude zasahovat žádná částice. A taktéž specifikujeme maximální počet částic
v&nbsp;systému:</p>

<pre>
<i>/* model options */</i>
#define BORDER 50
&nbsp;
<i>/* total number of particles */</i>
#define MAX_PARTICLES 1000
</pre>

<p>Každá částice bude prozatím reprezentována strukturou s&nbsp;jejími
souřadnicemi:</p>

<pre>
typedef struct {
    float x;
    float y;
} <strong>Particle</strong>;
</pre>

<p>Reprezentace barvy částic v&nbsp;systému je triviální:</p>

<pre>
typedef struct Color {
    unsigned char r;
    unsigned char g;
    unsigned char b;
} <strong>Color</strong>;
</pre>

<p>Celý částicový systém bude prozatím reprezentován strukturou
s&nbsp;částicemi (alokovaný blok &ndash; částice nevytváříme ani je neničíme),
s&nbsp;počtem částic a taktéž s&nbsp;barvou všech částic v&nbsp;systému:</p>

<pre>
typedef struct {
    Particle *particles;
    int max;
    Color color;
} <strong>ParticleSystem</strong>;
</pre>

<p>A modelovaný svět je prozatím reprezentován triviálním způsobem (opět se
postupně tato struktura bude rozšiřovat):</p>

<pre>
typedef struct {
    ParticleSystem particle_system;
} <strong>Model</strong>;

<p>Pro prvotní náhodné rozmístění částic na obrazovce použijeme funkci nazvanou
<strong>create_particles</strong> s&nbsp;pomocnými funkcemi
<strong>random_x</strong> a <strong>random_y</strong> (používám zvláštní
funkce, aby bylo možné generátor souřadnic částic později parametrizovat):</p>

<pre>
float <strong>random_x</strong>() {
    return (WIDTH - BORDER * 2) * (float)rand() / RAND_MAX + BORDER;
}
&nbsp;
float <strong>random_y</strong>() {
    return (HEIGHT - BORDER * 2) * (float)rand() / RAND_MAX + BORDER;
}
&nbsp;
void <strong>create_particles</strong>(int max, Particle *particles) {
    int i;
    for (i = 0; i &lt; max; i++) {
        particles[i].x = random_x();
        particles[i].y = random_y();
    }
}
</pre>

<p>Funkce <strong>init_model</strong> se stará o vytvoření celého modelovaného
světa s&nbsp;částicemi:</p>

<pre>
Model <strong>init_model</strong>(void) {
    Color color = {255, 255, 80};
    Model model;
&nbsp;
    model.particle_system.color = color;
&nbsp;
    model.particle_system.particles =
        (Particle *)malloc(MAX_PARTICLES * sizeof(Particle));
    model.particle_system.max = MAX_PARTICLES;
&nbsp;
    createParticles(MAX_PARTICLES, model.particle_system.particles);
&nbsp;
    return model;
}
</pre>

<p>A konečně funkce <strong>redraw</strong> poslouží pro překreslení
částicového systému na obrazovku. Povšimněte si, že každá částice je vykreslena
jako malý symbol + (samotné vykreslování na úrovni pixelů je dosti pomalé! a
lze ho optimalizovat):</p>

<pre>
void <strong>redraw</strong>(GraphicsState *graphicsState, SDL_Surface *pixmap, Model *model) {
    int i;
&nbsp;
    ParticleSystem particle_system = model-&gt;particle_system;
&nbsp;
    SDL_FillRect(pixmap, NULL, 0x00);
    for (i = 0; i &lt; particle_system.max; i++) {
        Particle particle = particle_system.particles[i];
        Color color = particle_system.color;
        putpixel(pixmap, particle.x, particle.y, color.r, color.g, color.b);
        putpixel(pixmap, particle.x - 1, particle.y, color.r, color.g, color.b);
        putpixel(pixmap, particle.x + 1, particle.y, color.r, color.g, color.b);
        putpixel(pixmap, particle.x, particle.y - 1, color.r, color.g, color.b);
        putpixel(pixmap, particle.x, particle.y + 1, color.r, color.g, color.b);
    }
&nbsp;
    show_pixmap(graphicsState, pixmap);
}
</pre>

<p><div class="rs-tip-major">Poznámka: adresář s&nbsp;tímto projektem se
nachází na adrese <a
href="https://github.com/tisnik/presentations/tree/master/particle_life/v0/">https://github.com/tisnik/presentations/tree/master/particle_life/v0/</a>.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Ukázka obrazovky s&nbsp;vizualizovaným statickým částicovým systémem</h2>

<p>Pro překlad a slinkování programu určeného pro vykreslení statického
částicového systému je nutný překladač céčka (GCC, TCC, Clang atd.) a knihovna
<i>SDL2</i> (její vývojářská varianta). Po spuštění příkladu by se měla
zobrazit obrazovka s&nbsp;přibližně 1000 částicemi. Může jich být méně, pokud
se některé částice překrývají:</p>

*** image ***
<p><i>Obrázek 3: Statický částicový systém vykreslený kódem popsaným
v&nbsp;předchozí kapitole.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Realizace dynamického částicového systému</h2>

<p>Ve druhém kroku začněme realizací velmi jednoduchého částicového systému,
v&nbsp;němž se budou nacházet částice, které se pohybují v&nbsp;dvourozměrné
ploše a po nárazu na okraje plochy (okna) se odrazí. Žádná další pravidla
ovlivňující pohyb částic prozatím nebudou implementována. Každá částice je
uložena jako dvojice údajů [poloha, rychlost], přičemž jak poloha, tak i
rychlost jsou dvourozměrnými vektory. Částici tedy můžeme popsat běžnou
strukturou (oproti předchozí variantě jsme přidali složky vektoru
rychlosti):</p>

<pre>
typedef struct {
    float x;
    float y;
    float vx;
    float vy;
} <strong>Particle</strong>;
</pre>

<p>Celý částicový systém pak může být uložen taktéž ve formě struktury, která
bude obsahovat alokovaný blok s&nbsp;částicemi (ty nebudou vznikat ani
zanikat), počtem částic a taktéž barvou všech částic v&nbsp;systému. Později
uvidíme, z&nbsp;jakého důvodu je barva uložena zrovna zde:</p>

<pre>
typedef struct Color {
    unsigned char r;
    unsigned char g;
    unsigned char b;
} <strong>Color</strong>;
&nbsp;
typedef struct {
    Particle *particles;
    int max;
    Color color;
} <strong>ParticleSystem</strong>;
</pre>

<p>Částicový systém je navíc společně s&nbsp;takzvaným pravidlem (<i>rule</i>,
prozatím jediná hodnota s&nbsp;plovoucí řádovou čárkou) uložen ve struktuře
představující celý modelovaný svět, jenž je složený pouze z&nbsp;částic:</p>

<pre>
typedef struct {
    float rule;
    ParticleSystem particle_system;
} <strong>Model</strong>;
</pre>

<p>Inicializace hodnoty <strong>rule</strong> je prozatím triviální (později se
funkce rozšíří):</p>

<pre>
void <strong>init_rule</strong>(Model *model) {
    model-&gt;rule = 2.0 * (float)rand() / RAND_MAX - 1.0;
}
</pre>

<p>Následuje upravená varianta funkce <strong>create_particles</strong>, která
kromě pozice částic nastaví i jejich počáteční rychlost:</p>

<pre>
void <strong>create_particles</strong>(int max, Particle *particles) {
    int i;
    for (i = 0; i &lt; max; i++) {
        particles[i].x = randomX();
        particles[i].y = randomY();
        particles[i].vx = (float)rand() / RAND_MAX - 0.5;
        particles[i].vy = (float)rand() / RAND_MAX - 0.5;
    }
}
</pre>

<p>Vykreslení částicového systému je realizováno naprosto stejnou funkcí, jako
v&nbsp;prvním příkladu. Jen pro úplnost tedy:</p>

<pre>
void <strong>redraw</strong>(GraphicsState *graphicsState, SDL_Surface *pixmap, Model *model) {
    int i;
&nbsp;
    ParticleSystem particle_system = model-&gt;particle_system;
&nbsp;
    SDL_FillRect(pixmap, NULL, 0x00);
    for (i = 0; i &lt; particle_system.max; i++) {
        Particle particle = particle_system.particles[i];
        Color color = particle_system.color;
        putpixel(pixmap, particle.x, particle.y, color.r, color.g, color.b);
        putpixel(pixmap, particle.x - 1, particle.y, color.r, color.g, color.b);
        putpixel(pixmap, particle.x + 1, particle.y, color.r, color.g, color.b);
        putpixel(pixmap, particle.x, particle.y - 1, color.r, color.g, color.b);
        putpixel(pixmap, particle.x, particle.y + 1, color.r, color.g, color.b);
    }
&nbsp;
    show_pixmap(graphicsState, pixmap);
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Výpočet nové pozice částic na základě jejich rychlosti a případných odrazů</h2>

<p>V&nbsp;každém snímku je nutné vypočítat nové pozice všech částic
v&nbsp;částicovém systému. Každé částici je přiřazena rychlost, takže můžeme
provést pseuodointegraci a vypočítat novou pozici částice <strong>a</strong>
takto:</p>

<pre>
a-&gt;x += a-&gt;vx;
a-&gt;y += a-&gt;vy;
</pre>

<p><div class="rs-tip-major">Poznámka: vektor rychlosti je většinou dostatečně
malý, aby se částice posunula jen o jeden či maximálně několik pixelů &ndash;
viz funkci <strong>create_particles</strong> uvedenou výše.</div></p>

<p>Navíc do programového kódu přidáme i podmínku pro odraz částic od okrajů
obrazovky (a posun částice do vyhrazené oblasti):</p>

<pre>
void <strong>apply_rule</strong>(Model *model) {
    int i;
&nbsp;
    for (i = 0; i &lt; model-&gt;particle_system.max; i++) {
        Particle *a = &amp;model-&gt;particle_system.particles[i];
&nbsp;
        <i>/* move particle */</i>
        a-&gt;x += a-&gt;vx;
        a-&gt;y += a-&gt;vy;
&nbsp;
        <i>/* check if particle touches scene boundary */</i>
        if (a-&gt;x &lt;= 0) {
            a-&gt;vx = -a-&gt;vx;
            a-&gt;x = 0;
        }
        if (a-&gt;x &gt; WIDTH) {
            a-&gt;vx = -a-&gt;vx;
            a-&gt;x = WIDTH - 1;
        }
        if (a-&gt;y &lt;= 0) {
            a-&gt;vy = -a-&gt;vy;
            a-&gt;y = 0;
        }
        if (a-&gt;y &gt; HEIGHT) {
            a-&gt;vy = -a-&gt;vy;
            a-&gt;y = HEIGHT - 1;
        }
    }
}
</pre>

<p>Právě tuto funkci budeme postupně rozšiřovat a vylepšovat v&nbsp;rámci
dalších kapitol.</p>

<p><div class="rs-tip-major">Poznámka: adresář s&nbsp;tímto projektem se
nachází na adrese <a
href="https://github.com/tisnik/presentations/tree/master/particle_life/v1/">https://github.com/tisnik/presentations/tree/master/particle_life/v1/</a>.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Ukázky grafické plochy s&nbsp;vizualizovaným dynamickým částicovým systémem</h2>

*** image ***
<p><i>Obrázek 4: Částicový systém s&nbsp;pohybujícími se částicemi.</i></p>

*** image ***
<p><i>Obrázek 5: Částicový systém s&nbsp;pohybujícími se částicemi.</i></p>

*** image ***
<p><i>Obrázek 6: Částicový systém s&nbsp;pohybujícími se částicemi.</i></p>

<p><div class="rs-tip-major">Poznámka: žádná emergence tedy prozatím
nenastala.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Přidání pravidla pro vzájemné odpuzování částic</h2>

<p>V&nbsp;následujícím kroku částicový systém poměrně razantně modifikujeme.
Upravíme totiž funkci určenou pro aplikaci pravidel, jak se mají částice
pohybovat. Nyní se budou částice odpuzovat ve chvíli, kdy se k&nbsp;sobě
přiblíží na vzdálenost definovanou v&nbsp;konstantě:</p>

<pre>
#define MAX_DISTANCE 50
</pre>

<p>Na základě vzdálenosti dvou částic <strong>a</strong> a <strong>b</strong>
se vypočítá vektor odpudivé síly:</p>

<pre>
float dx = a-&gt;x - b-&gt;x;
float dy = a-&gt;y - b-&gt;y;
if (dx != 0.0 || dy != 0.0) {
    float d = dx * dx + dy * dy;
    if (d &lt; MAX_DISTANCE * MAX_DISTANCE) {
        <i>/* repel force */</i>
        float f = g / sqrt(d);
        fx += f * dx;
        fy += f * dy;
    }
}
</pre>

<p>Navíc se pro dosažení větší stability (aby systém příliš
&bdquo;nekmital&ldquo; a nebyla v&nbsp;něm velká kladná zpětná vazba) rychlost
částic v&nbsp;každém kroku zmenší o koeficient:</p>

<pre>
#define DAMPING_FACTOR 0.5
</pre>

<p>Tímto vztahem:</p>

<pre>
a-&gt;vx = (a-&gt;vx + fx * DT) * DAMPING_FACTOR;
a-&gt;vy = (a-&gt;vy + fy * DT) * DAMPING_FACTOR;
</pre>

<p>Výsledkem je zcela nová podoba funkce <strong>apply_rule</strong>:</p>

<pre>
void <strong>apply_rule</strong>(Model *model) {
    int i, j;
&nbsp;
    for (i = 0; i &lt; model-&gt;particle_system.max; i++) {
        float fx = 0.0;
        float fy = 0.0;
        Particle *a = &amp;model-&gt;particle_system.particles[i];
&nbsp;
        <i>/* compute force for selected particle */</i>
        for (j = 0; j &lt; model-&gt;particle_system.max; j++) {
            if (i != j) {
                Particle *b = &amp;model-&gt;particle_system.particles[j];
                float g = model-&gt;rule;
                float dx = a-&gt;x - b-&gt;x;
                float dy = a-&gt;y - b-&gt;y;
                if (dx != 0.0 || dy != 0.0) {
                    float d = dx * dx + dy * dy;
                    if (d &lt; MAX_DISTANCE * MAX_DISTANCE) {
                        <i>/* repel force */</i>
                        float f = g / sqrt(d);
                        fx += f * dx;
                        fy += f * dy;
                    }
                }
            }
        }
&nbsp;
        <i>/* apply force to selected particle */</i>
        a-&gt;vx = (a-&gt;vx + fx * DT) * DAMPING_FACTOR;
        a-&gt;vy = (a-&gt;vy + fy * DT) * DAMPING_FACTOR;
&nbsp;
        <i>/* move particle */</i>
        a-&gt;x += a-&gt;vx;
        a-&gt;y += a-&gt;vy;
&nbsp;
        <i>/* check if particle touches scene boundary */</i>
        if (a-&gt;x &lt;= 0) {
            a-&gt;vx = -a-&gt;vx;
            a-&gt;x = 0;
        }
        if (a-&gt;x &gt; WIDTH) {
            a-&gt;vx = -a-&gt;vx;
            a-&gt;x = WIDTH - 1;
        }
        if (a-&gt;y &lt;= 0) {
            a-&gt;vy = -a-&gt;vy;
            a-&gt;y = 0;
        }
        if (a-&gt;y &gt; HEIGHT) {
            a-&gt;vy = -a-&gt;vy;
            a-&gt;y = HEIGHT - 1;
        }
    }
}
</pre>

<p><div class="rs-tip-major">Poznámka: adresář s&nbsp;takto upraveným projektem se
nachází na adrese <a
href="https://github.com/tisnik/presentations/tree/master/particle_life/v2/">https://github.com/tisnik/presentations/tree/master/particle_life/v2/</a>.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Ukázky grafické plochy s&nbsp;vizualizovaným dynamickým částicovým systémem</h2>

<p>Pro malý počet částic bude výsledek vypadat přibližně následovně (povšimněte
si, jak jsou částice od sebe odpuzeny na přibližně stejnou vzdálenost):</p>

*** image ***
<p><i>Obrázek 7: Částicový systém s&nbsp;pohybujícími se částicemi, které se odpuzují, po ustálení.</i></p>

<p>Postupná stabilizace systému s&nbsp;větším počtem částic:</p>

*** image ***
<p><i>Obrázek 8: Částicový systém s&nbsp;pohybujícími se částicemi, které se odpuzují.</i></p>

*** image ***
<p><i>Obrázek 9: Částicový systém s&nbsp;pohybujícími se částicemi, které se odpuzují.</i></p>

*** image ***
<p><i>Obrázek 10: Částicový systém s&nbsp;pohybujícími se částicemi, které se odpuzují.</i></p>

<p>A pro systém s&nbsp;větším množstvím částic již dojde k&nbsp;seskupení
některých částic do &bdquo;atomů&ldquo; (i když se částice stále odpuzují). A
v&nbsp;průběhu vývoje systému se stane, že některá částice doputuje od jednoho
atomu k&nbsp;atomu dalšímu:</p>

*** image ***
<p><i>Obrázek 11: Částicový systém s&nbsp;pohybujícími se částicemi, které se odpuzují.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Větší množství částicových systémů</h2>

<p>I přesto, že už v&nbsp;předchozím systému vznikla nějaká struktura, nejedná
se o pravou emergenci. Abychom jí dosáhli, musíme provést ještě dvě úpravy
systému. Nejdříve namísto jednoho částicového systému přidáme do modelového
světa hned čtyři skupiny části. Prozatím se částice budou odlišovat jen svým
typem a barvou vykreslení, takže by se modelovaný svět jako celek měl stále
chovat stejně.</p>

<p>Nejprve si připravíme potřebné konstanty:</p>

<pre>
<i>/* constants used by model */</i>
#define RED 0
#define GREEN 1
#define YELLOW 2
#define BLUE 3
&nbsp;
<i>/* number of particles of different colors/attributes */</i>
#define MAX_RED 3000
#define MAX_GREEN 200
#define MAX_BLUE 100
#define MAX_YELLOW 100
&nbsp;
<i>/* total number of particles */</i>
#define MAX_PARTICLES (MAX_RED + MAX_GREEN + MAX_BLUE + MAX_YELLOW)
</pre>

<p>Samotná struktura s&nbsp;informacemi o částici bude navíc obsahovat i její
typ, tj.&nbsp;ke které ze čtyř skupin částic náleží:</p>

<pre>
typedef struct {
    float x;
    float y;
    float vx;
    float vy;
    int type;
} <strong>Particle</strong>;
</pre>

<p>Změní se i definice částicového systému, protože si musíme zapamatovat čtyři
barvy částic:</p>

<pre>
typedef struct {
    Particle *particles;
    int max;
    Color colors[4];
} <strong>ParticleSystem</strong>;
</pre>

<p>A konečně změníme i funkci pro inicializaci celého modelovaného světa tak,
aby podporoval čtyři skupiny částic, každou skupinu s&nbsp;odlišnou barvou:</p>

<pre>
Model <strong>init_model</strong>(void) {
    Color redColor = {255, 80, 80};
    Color greenColor = {80, 255, 80};
    Color blueColor = {80, 80, 255};
    Color yellowColor = {255, 255, 80};
&nbsp;
    Model model;
&nbsp;
    init_rules(&amp;model);
    model.particle_system.colors[RED] = redColor;
    model.particle_system.colors[GREEN] = greenColor;
    model.particle_system.colors[BLUE] = blueColor;
    model.particle_system.colors[YELLOW] = yellowColor;
&nbsp;
    model.particle_system.particles =
        (Particle *)malloc(MAX_PARTICLES * sizeof(Particle));
    model.particle_system.max = MAX_PARTICLES;
&nbsp;
    create_particles(MAX_RED, model.particle_system.particles, RED);
    create_particles(MAX_GREEN, model.particle_system.particles + MAX_RED, GREEN);
    create_particles(MAX_BLUE, model.particle_system.particles + MAX_RED + MAX_GREEN,
                    BLUE);
    create_particles(MAX_YELLOW,
                    model.particle_system.particles + MAX_RED + MAX_GREEN + MAX_BLUE,
                    YELLOW);
&nbsp;
    return model;
}
</pre>

<p><div class="rs-tip-major">Poznámka: adresář s&nbsp;takto upraveným projektem se
nachází na adrese <a
href="https://github.com/tisnik/presentations/tree/master/particle_life/v3/">https://github.com/tisnik/presentations/tree/master/particle_life/v3/</a>.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Ukázky grafické plochy s&nbsp;vizualizovaným dynamickým částicovým systémem</h2>

<p>Opět se podívejme na postupný vývoj dynamického systému, který reprezentuje
náš modelovaný svět:</p>

*** image ***
<p><i>Obrázek 12: Postupný vývoj systému se čtyřmi typy částic.</i></p>

*** image ***
<p><i>Obrázek 13: Postupný vývoj systému se čtyřmi typy částic.</i></p>

*** image ***
<p><i>Obrázek 14: Postupný vývoj systému se čtyřmi typy částic.</i></p>

*** image ***
<p><i>Obrázek 15: Postupný vývoj systému se čtyřmi typy částic.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Pravidla pro interakci mezi částicemi z&nbsp;různých systémů</h2>

<p>Poslední a nejdůležitější modifikací částicového systému je specifikace
pravidel aplikovaných na částice podle barev. V&nbsp;předchozím kódu jsme
přiřadili každé částici jednu ze čtyř barev. Pokud se k&nbsp;sobě přiblíží dvě
částice, budou od sebe stále odpuzovány, ale míra této odpudivé síly bude různá
podle toho, jaké barvy částice jsou. Vzhledem k&nbsp;tomu, že obě interagující
částice mohou nabývat jedné ze čtyř barev, máme k&nbsp;dispozici celkem
4&times;4=16 různých pravidel (hodnot typu <strong>float</strong>), takže si
upravíme model našeho světa následovně:</p>

<pre>
typedef struct {
    float rules[4][4];
    ParticleSystem particle_system;
} <strong>Model</strong>;
</pre>

<p>Z&nbsp;funkce <strong>init_rule</strong> se tedy stane funkce nazvaná
<strong>init_rules</strong>:</p>

<pre>
void <strong>init_rules</strong>(Model *model) {
    int i, j;
&nbsp;
    for (j = 0; j &lt; 4; j++) {
        for (i = 0; i &lt; 4; i++) {
            model-&gt;rules[i][j] = 2.0 * (float)rand() / RAND_MAX - 1.0;
        }
    }
}
</pre>

<p><div class="rs-tip-major">Poznámka: hodnoty 0 až 3 ve smyčkách mají tento
význam:</div></p>

<pre>
#define RED 0
#define GREEN 1
#define YELLOW 2
#define BLUE 3
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Změna funkce <strong>apply_rule</strong> na <strong>apply_rules</strong></h2>

<p>Modifikovat pochopitelně musíme i funkci <strong>apply_rule</strong>, kterou
přejmenujeme na <strong>apply_rules</strong>. To však není tak důležité jako
změna logiky, která je na dalším výpisu zvýrazněná:</p>

<pre>
for (j = 0; j &lt; model-&gt;particle_system.max; j++) {
    if (i != j) {
        Particle *b = &amp;model-&gt;particle_system.particles[j];
        float g = <strong>model-&gt;rules[a-&gt;type][b-&gt;type]</strong> * SCALE_FACTOR;
        ...
        ...
        ...
    }
}
</pre>

<p>To znamená, že na základě typu první a druhé částice vybereme jedno ze
šestnácti pravidel. A toto pravidlo (prozatím konstanta) je použita při výpočtu
síly působící na částice.</p>

<p>Úplný kód funkce <strong>apply_rules</strong>, která tvoří jádro celého
částicového systému, vypadá takto:</p>

<pre>
void <strong>apply_rules</strong>(Model *model) {
    int i, j;
&nbsp;
    for (i = 0; i &lt; model-&gt;particle_system.max; i++) {
        float fx = 0.0;
        float fy = 0.0;
        Particle *a = &amp;model-&gt;particle_system.particles[i];
&nbsp;
        <i>/* compute force for selected particle */</i>
        for (j = 0; j &lt; model-&gt;particle_system.max; j++) {
            if (i != j) {
                Particle *b = &amp;model-&gt;particle_system.particles[j];
                float g = <strong>model-&gt;rules[a-&gt;type][b-&gt;type]</strong> * SCALE_FACTOR;
                float dx = a-&gt;x - b-&gt;x;
                float dy = a-&gt;y - b-&gt;y;
                if (dx != 0.0 || dy != 0.0) {
                    float d = dx * dx + dy * dy;
                    if (d &lt; MAX_DISTANCE * MAX_DISTANCE) {
                        /* repel force */
                        float f = g / sqrt(d);
                        fx += f * dx;
                        fy += f * dy;
                    }
                }
            }
        }
&nbsp;
        <i>/* apply force to selected particle */</i>
        a-&gt;vx = (a-&gt;vx + fx * DT) * DAMPING_FACTOR;
        a-&gt;vy = (a-&gt;vy + fy * DT) * DAMPING_FACTOR;
&nbsp;
        <i>/* move particle */</i>
        a-&gt;x += a-&gt;vx;
        a-&gt;y += a-&gt;vy;
&nbsp;
        <i>/* check if particle touches scene boundary */</i>
        if (a-&gt;x &lt;= 0) {
            a-&gt;vx = -a-&gt;vx;
            a-&gt;x = 0;
        }
        if (a-&gt;x &gt; WIDTH) {
            a-&gt;vx = -a-&gt;vx;
            a-&gt;x = WIDTH - 1;
        }
        if (a-&gt;y &lt;= 0) {
            a-&gt;vy = -a-&gt;vy;
            a-&gt;y = 0;
        }
        if (a-&gt;y &gt; HEIGHT) {
            a-&gt;vy = -a-&gt;vy;
            a-&gt;y = HEIGHT - 1;
        }
    }
}
</pre>

<p><div class="rs-tip-major">Poznámka: adresář s&nbsp;takto upraveným projektem se
nachází na adrese <a
href="https://github.com/tisnik/presentations/tree/master/particle_life/v4/">https://github.com/tisnik/presentations/tree/master/particle_life/v4/</a>.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Ukázky grafické plochy s&nbsp;vizualizovaným dynamickým částicovým systémem</h2>

<p>Opět se podívejme na výsledky, které sice nejsou na statických obrázcích
příliš přesvědčivé, ale nic by nám nemělo bránit v&nbsp;překladu a pohledu na
postupně se vyvíjející dynamický systém:</p>

*** image ***
<p><i>Obrázek 16: Pravidla jsou nastavena tak, že se červené částice snaží o
vytvoření pravidelné mřížky, zatímco částice ostatních barev jsou
&bdquo;živější&ldquo;.</i></p>

*** image ***
<p><i>Obrázek 17: V&nbsp;systému začínají &bdquo;oživovat&ldquo; zelené a žluté
organismy.</i></p>

*** image ***
<p><i>Obrázek 18: Žluté a zelené částice tvoří ucelenější struktury, které se
v&nbsp;systému pohybují podobně jako hejno ryb.</i></p>

*** image ***
<p><i>Obrázek 19: Podobné chování, jaké můžeme vidět na předchozím
obrázku.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Další vylepšení interaktivity</h2>

<p>Celý systém s&nbsp;modelem jednoduchého světa složeného z&nbsp;částic by
mělo být možné interaktivně ovládat. Pro účely dnešního článku jsem ještě
zdrojový kód upravil tak, aby reagoval na následující klávesové zkratky:</p>

<table>
<tr><th>Klávesa</th><th>Stručný popis</th><th>Funkce s&nbsp;implementací</th></tr>
<tr><td>d</td><td>pozastavení částic (delay, slow down)</td><td>slow_down(model)</td></tr>
<tr><td>i</td><td>nastavení nových pravidel (init rules)</td><td>init_rules(model)</td></tr>
<tr><td>c</td><td>vytvoření nového částicového systému (náhodné rozmístění částic)</td><td>create_particles(model)</td></tr>
<tr><td>s</td><td>povolení či zákaz rozmazání snímku (lze přidat i motion blur)</td><td>smooth_scene(pixma)</td></tr>
</table>



<p><a name="k15"></a></p>
<h2 id="k15">15. Funkce se smyčkou pro obsluhu událostí</h2>

<p>A takto vypadá programová smyčka pro obsluhu událostí. Reagujeme pouze na
stisk kláves popř.&nbsp;na uzavření okna s&nbsp;vizualizovaným částicovým
systémem:</p>

<pre>
static void <strong>main_event_loop</strong>(GraphicsState *graphicsState, SDL_Surface *pixmap,
                            Model *model) {
    SDL_Event event;
    int done = 0;
&nbsp;
    do {
        while (SDL_PollEvent(&amp;event)) {
            switch (event.type) {
            case SDL_QUIT:
                done = 1;
                break;
            case SDL_KEYDOWN:
                switch (event.key.keysym.sym) {
                case 'd':
                    slow_down(model);
                    break;
                case 'i':
                    init_rules(model);
                    break;
                case 'c':
                    create_particles_of_all_colors(model);
                    break;
                case 's':
                    smooth_enabled = !smooth_enabled;
                    break;
                case SDLK_ESCAPE:
                case SDLK_q:
                    done = 1;
                    break;
                default:
                    break;
                }
                break;
            default:
                break;
            }
        }
        apply_rules(model);
        redraw(graphicsState, pixmap, model);
        SDL_Delay(10);
    } while (!done);
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Ukázky grafické plochy s&nbsp;vizualizovaným dynamickým částicovým systémem</h2>

*** image ***
<p><i>Obrázek 20: Vznik pohybujících se &bdquo;živočichů&ldquo; na základě jednoduchých pravidel.</i></p>

*** image ***
<p><i>Obrázek 21: Vznik pohybujících se &bdquo;živočichů&ldquo; na základě jednoduchých pravidel.</i></p>

*** image ***
<p><i>Obrázek 22: Červených částic je nejvíce, takže se odpuzují a mohou vytvořit pravidelné mřížky.</i></p>

*** image ***
<p><i>Obrázek 23: Odlišná pravidla vedou k&nbsp;vývoji jakýchsi sítí.</i></p>

*** image ***
<p><i>Obrázek 24: Odlišné nastavení pravidel.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Realizace částicového systému v&nbsp;Pythonu</h2>

<p>Výše popsaný částicový systém lze pochopitelně realizovat v&nbsp;různých
programovacích jazycích a s&nbsp;využitím různých knihoven pro vykreslování.
Můžeme si tedy vyzkoušet variantu naprogramovanou <a
href="https://www.root.cz/n/python/">v&nbsp;Pythonu</a>. Struktura tohoto
programu se nebude příliš lišit od céčkové varianty (použijeme zde knihovnu
PyGame postavenou taktéž nad SDL), ovšem výpočty a vykreslování budou znatelně
pomalejší &ndash; minimálně o jeden řád. Kdo má tedy dostatečně výkonný
počítač, může si otestovat tuto variantu:</p>

<p>Pro inicializaci grafického subsystému, otevření okna i vykreslování se
používá pomocný jednoduchý modul napsaný v&nbsp;jazyce C a operující nad
knihovnou SDL2. Modul obsahuje pouze základní potřebné funkce a navíc i funkci
pro práci s&nbsp;rastrovými obrázky, kterou lze využít například při tvorbě
videa. Hlavičkový soubor modulu <strong>gfx</strong>:</p>

<pre>
#ifndef _GFX_H_
#define _GFX_H_
&nbsp;
typedef struct GraphicsState {
    SDL_Window *window;
    SDL_Surface *screen_surface;
} GraphicsState;
&nbsp;
void <strong>init_sdl</strong>(GraphicsState *graphicsState, const char *title, const int width,
              const int height);
&nbsp;
void <strong>finalize</strong>(GraphicsState *graphicsState, SDL_Surface *pixmap);
&nbsp;
void <strong>show_pixmap</strong>(GraphicsState *graphicsState, SDL_Surface *surface);
&nbsp;
SDL_Surface *<strong>create_pixmap</strong>(const int width, const int height);
&nbsp;
void <strong>putpixel</strong>(SDL_Surface *surface, int x, int y, unsigned char r,
              unsigned char g, unsigned char b);
&nbsp;
#endif
</pre>

<p>Realizace všech funkcí v&nbsp;céčku:</p>

<pre>
#include &lt;SDL2/SDL.h&gt;
&nbsp;
#include "gfx.h"
&nbsp;
void <strong>init_sdl</strong>(GraphicsState *graphicsState, const char *title, const int width,
              const int height) {
    graphicsState-&gt;window = NULL;
    graphicsState-&gt;screen_surface = NULL;
&nbsp;
    if (SDL_Init(SDL_INIT_VIDEO) &lt; 0) {
        fprintf(stderr, "Error initializing SDL: %s\n", SDL_GetError());
        exit(1);
    } else {
        puts("SDL_Init ok");
    }
&nbsp;
    graphicsState-&gt;window = SDL_CreateWindow(title, SDL_WINDOWPOS_UNDEFINED,
                                             SDL_WINDOWPOS_UNDEFINED, width,
                                             height, SDL_WINDOW_SHOWN);
&nbsp;
    if (!graphicsState-&gt;window) {
        puts("Error creating window");
        puts(SDL_GetError());
        exit(1);
    } else {
        puts("SDL_CreateWindow ok");
    }
&nbsp;
    graphicsState-&gt;screen_surface = SDL_GetWindowSurface(graphicsState-&gt;window);

    if (!graphicsState-&gt;screen_surface) {
        fprintf(stderr, "Error setting video mode: %s\n", SDL_GetError());
        exit(1);
    } else {
        puts("SDL_GetWindowSurface ok");
    }
}
&nbsp;
void <strong>finalize</strong>(GraphicsState *graphicsState, SDL_Surface *pixmap) {
    SDL_FreeSurface(pixmap);
    SDL_FreeSurface(graphicsState-&gt;screen_surface);
    SDL_DestroyWindow(graphicsState-&gt;window);
    SDL_Quit();
}
&nbsp;
void <strong>show_pixmap</strong>(GraphicsState *graphicsState, SDL_Surface *surface) {
    SDL_BlitSurface(surface, NULL, graphicsState-&gt;screen_surface, NULL);
    SDL_UpdateWindowSurface(graphicsState-&gt;window);
}
&nbsp;
SDL_Surface *<strong>create_pixmap</strong>(const int width, const int height) {
    SDL_Surface *pixmap;
    pixmap = SDL_CreateRGBSurface(SDL_SWSURFACE, width, height, 32, 0x00ff0000,
                                  0x0000ff00, 0x000000ff, 0x00000000);
    if (!pixmap) {
        puts("Can not create pixmap");
        exit(1);
    } else {
        puts("Off screen pixmap created");
    }
    return pixmap;
}
&nbsp;
void <strong>putpixel</strong>(SDL_Surface *surface, int x, int y, unsigned char r,
              unsigned char g, unsigned char b) {
    if (x &gt;= 0 &amp;&amp; x &lt; surface-&gt;w &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; surface-&gt;h) {
        if (surface-&gt;format-&gt;BitsPerPixel == 24) {
            Uint8 *pixel = (Uint8 *)surface-&gt;pixels;
            pixel += x * 3;
            pixel += y * surface-&gt;pitch;
            *pixel++ = b;
            *pixel++ = g;
            *pixel = r;
            return;
        }
        if (surface-&gt;format-&gt;BitsPerPixel == 32) {
            Uint8 *pixel = (Uint8 *)surface-&gt;pixels;
            pixel += x * 4;
            pixel += y * surface-&gt;pitch;
            *pixel++ = b;
            *pixel++ = g;
            *pixel = r;
            return;
        }
    }
}
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Jednotlivé postupně se vylepšující implementace částicového systému
naprogramované v&nbsp;jazyku C i v&nbsp;Pythonu byly uloženy do Git repositáře,
který je dostupný na adrese <a
href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář, můžete namísto toho
použít odkazy na jednotlivé projekty, které naleznete v&nbsp;následující
tabulce:</p>

<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Emergence (Wikipedia CS)<br />
<a href="https://cs.wikipedia.org/wiki/Emergence">https://cs.wikipedia.org/wiki/Emergence</a>
</li>

<li>Emergence (Wikipedia EN)<br />
<a href="https://en.wikipedia.org/wiki/Emergence">https://en.wikipedia.org/wiki/Emergence</a>
</li>

<li>Particle Life: Vivid structures from rudimentary rules<br />
<a href="https://particle-life.com/">https://particle-life.com/</a>
</li>

<li>Self-organization<br />
<a href="https://en.wikipedia.org/wiki/Self-organization">https://en.wikipedia.org/wiki/Self-organization</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

