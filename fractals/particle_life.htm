<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Emergence: struktury vzniklé ze zdánlivého chaosu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Emergence: struktury vzniklé ze zdánlivého chaosu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V některých dynamických systémech mohou i na základě aplikace mnohdy velmi jednoduchých pravidel vznikat složitější emergentní struktury. Dnes si jeden takový systém nazývaný ParticleLife popíšeme a naprogramujeme.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Emergence: struktury vzniklé ze zdánlivého chaosu</a></p>
<p><a href="#k02">2. Jednoduchý framework pro zobrazení částicového systému</a></p>
<p><a href="#k03">3. Ukázka obrazovky s&nbsp;vizualizovaným statickým částicovým systémem</a></p>
<p><a href="#k04">4. Realizace dynamického částicového systému</a></p>
<p><a href="#k05">5. Výpočet nové pozice částic na základě jejich rychlosti a případných odrazů</a></p>
<p><a href="#k06">6. Ukázky grafické plochy s&nbsp;vizualizovaným dynamickým částicovým systémem</a></p>
<p><a href="#k07">7. Přidání pravidla pro vzájemné odpuzování částic</a></p>
<p><a href="#k08">8. Ukázky grafické plochy s&nbsp;vizualizovaným dynamickým částicovým systémem</a></p>
<p><a href="#k09">9. Větší množství částicových systémů</a></p>
<p><a href="#k10">10. Ukázky grafické plochy s&nbsp;vizualizovaným dynamickým částicovým systémem</a></p>
<p><a href="#k11">11. Pravidla pro interakci mezi částicemi z&nbsp;různých systémů</a></p>
<p><a href="#k12">12. Změna funkce <strong>apply_rule</strong> na <strong>apply_rules</strong></a></p>
<p><a href="#k13">13. Ukázky grafické plochy s&nbsp;vizualizovaným dynamickým částicovým systémem</a></p>
<p><a href="#k14">14. Další vylepšení interaktivity</a></p>
<p><a href="#k15">15. Funkce se smyčkou pro obsluhu událostí</a></p>
<p><a href="#k16">*** 16. Ukázky grafické plochy s&nbsp;vizualizovaným dynamickým částicovým systémem</a></p>
<p><a href="#k17">17. Realizace částicového systému v&nbsp;Pythonu</a></p>
<p><a href="#k18">18. Příloha: modul <strong>gfx</strong></a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Emergence: struktury vzniklé ze zdánlivého chaosu</h2>

<p>V&nbsp;některých dynamických systémech mohou i na základě aplikace mnohdy
velmi jednoduchých pravidel vznikat složitější <i>emergentní</i> struktury.
Tato vlastnost se týká mnoha typů <i>komplexních systémů</i> s&nbsp;mnohdy
složitě popsanými entitami (nebo objekty, i když v&nbsp;kontextu IT je tento
termín zavádějící), ovšem nás budou v&nbsp;dnešním (i v&nbsp;navazujícím)
článku zajímat především takové komplexní systémy, v&nbsp;nichž je možné
vlastnosti jejich jednotlivých entit resp.&nbsp;elementů reprezentovat jako
body v&nbsp;ploše či v&nbsp;prostoru. Stav takového dynamického systému je tedy
popsán pozicemi těchto bodů, k&nbsp;nimž se většinou přidává i vektor
rychlosti.</p>

<img src="https://i.iinfo.cz/images/578/bokeh-02-5.png" class="image-576828" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="907" height="915" />
<p><i>Obrázek 1: Lorenzův atraktor je známým dynamickým systémem s&nbsp;podivným atraktorem.</i></p>

<p>Poměrně známým příkladem mohou být různé systémy částic (<i>particle
systems</i>), v&nbsp;nichž je možné při vhodné definici pravidel chování
jednotlivých částic taktéž nalézt mnohdy velmi zajímavě vypadající emergentní
struktury. Toto téma je sice poměrně rozsáhlé a vyžádá si nejméně jeden
samostatný článek (navíc trošku mimo hlavní záběr Roota), ovšem již dnes si
můžeme jeden takový jednoduše implementovatelný částicový systém ukázat. A
vzhledem k&nbsp;tomu, že dále zmíněný částicový systém vede ke vzniku
emergentní struktury (a nikoli pouze náhodného &bdquo;oblaku&ldquo; bodů),
budeme moci výsledek vizualizovat a to nikoli jako pouhý statický obrázek, ale
jako animaci ukazující postupný rozvoj tohoto dynamického systému.</p>

<p><div class="rs-tip-major">Poznámka: vzhledem k&nbsp;tomu, že budeme chtít
zobrazit animaci s&nbsp;postupným vývojem dynamického systému, bude jeho
realizace provedena v&nbsp;jazyku C. Pokud vás zajímá, jak by mohla vypadat
realizace v&nbsp;Pythonu, podívejte se na <a href="#k17">kapitolu
17</a>.</div></p>

<img src="https://i.iinfo.cz/images/392/torch4-4.png" class="image-309065" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 2: Lorenzův atraktor vykreslený ve formě 3D grafu.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Jednoduchý framework pro zobrazení částicového systému</h2>

<p>Pro účely vizualizace postupné změny stavu dynamického systému (tedy pro
tvorbu animací) si vytvoříme jednoduchý framework, který budeme v&nbsp;rámci
dalších kapitol postupně vylepšovat. Nejprve nastavíme okraje okna, do kterých
nebude zasahovat žádná částice. A taktéž specifikujeme maximální počet částic
v&nbsp;systému:</p>

<pre>
<i>/* model options */</i>
#define BORDER 50
&nbsp;
<i>/* total number of particles */</i>
#define MAX_PARTICLES 1000
</pre>

<p>Každá částice bude prozatím reprezentována strukturou s&nbsp;jejími
souřadnicemi:</p>

<pre>
typedef struct {
    float x;
    float y;
} <strong>Particle</strong>;
</pre>

<p>Reprezentace barvy částic v&nbsp;systému je triviální:</p>

<pre>
typedef struct Color {
    unsigned char r;
    unsigned char g;
    unsigned char b;
} <strong>Color</strong>;
</pre>

<p>Celý částicový systém bude prozatím reprezentován strukturou
s&nbsp;částicemi (alokovaný blok &ndash; částice nevytváříme ani je neničíme),
s&nbsp;počtem částic a taktéž s&nbsp;barvou všech částic v&nbsp;systému:</p>

<pre>
typedef struct {
    Particle *particles;
    int max;
    Color color;
} <strong>ParticleSystem</strong>;
</pre>

<p>A modelovaný svět je prozatím reprezentován triviálním způsobem (opět se
postupně tato struktura bude rozšiřovat):</p>

<pre>
typedef struct {
    ParticleSystem particle_system;
} <strong>Model</strong>;

<p>Pro prvotní náhodné rozmístění částic na obrazovce použijeme funkci nazvanou
<strong>create_particles</strong> s&nbsp;pomocnými funkcemi
<strong>random_x</strong> a <strong>random_y</strong> (používám zvláštní
funkce, aby bylo možné generátor souřadnic částic později parametrizovat):</p>

<pre>
float <strong>random_x</strong>() {
    return (WIDTH - BORDER * 2) * (float)rand() / RAND_MAX + BORDER;
}
&nbsp;
float <strong>random_y</strong>() {
    return (HEIGHT - BORDER * 2) * (float)rand() / RAND_MAX + BORDER;
}
&nbsp;
void <strong>create_particles</strong>(int max, Particle *particles) {
    int i;
    for (i = 0; i &lt; max; i++) {
        particles[i].x = random_x();
        particles[i].y = random_y();
    }
}
</pre>

<p>Funkce <strong>init_model</strong> se stará o vytvoření celého modelovaného
světa s&nbsp;částicemi:</p>

<pre>
Model <strong>init_model</strong>(void) {
    Color color = {255, 255, 80};
    Model model;
&nbsp;
    model.particle_system.color = color;
&nbsp;
    model.particle_system.particles =
        (Particle *)malloc(MAX_PARTICLES * sizeof(Particle));
    model.particle_system.max = MAX_PARTICLES;
&nbsp;
    createParticles(MAX_PARTICLES, model.particle_system.particles);
&nbsp;
    return model;
}
</pre>

<p>A konečně funkce <strong>redraw</strong> poslouží pro překreslení
částicového systému na obrazovku. Povšimněte si, že každá částice je vykreslena
jako malý symbol + (samotné vykreslování na úrovni pixelů je dosti pomalé! a
lze ho optimalizovat):</p>

<pre>
void <strong>redraw</strong>(GraphicsState *graphicsState, SDL_Surface *pixmap, Model *model) {
    int i;
&nbsp;
    ParticleSystem particle_system = model-&gt;particle_system;
&nbsp;
    SDL_FillRect(pixmap, NULL, 0x00);
    for (i = 0; i &lt; particle_system.max; i++) {
        Particle particle = particle_system.particles[i];
        Color color = particle_system.color;
        putpixel(pixmap, particle.x, particle.y, color.r, color.g, color.b);
        putpixel(pixmap, particle.x - 1, particle.y, color.r, color.g, color.b);
        putpixel(pixmap, particle.x + 1, particle.y, color.r, color.g, color.b);
        putpixel(pixmap, particle.x, particle.y - 1, color.r, color.g, color.b);
        putpixel(pixmap, particle.x, particle.y + 1, color.r, color.g, color.b);
    }
&nbsp;
    show_pixmap(graphicsState, pixmap);
}
</pre>

<p><div class="rs-tip-major">Poznámka: adresář s&nbsp;tímto projektem se
nachází na adrese <a
href="https://github.com/tisnik/presentations/tree/master/particle_life/v0/">https://github.com/tisnik/presentations/tree/master/particle_life/v0/</a>.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Ukázka obrazovky s&nbsp;vizualizovaným statickým částicovým systémem</h2>

<p>Pro překlad a slinkování programu určeného pro vykreslení statického
částicového systému je nutný překladač céčka (GCC, TCC, Clang atd.) a knihovna
<i>SDL2</i> (její vývojářská varianta). Po spuštění příkladu by se měla
zobrazit obrazovka s&nbsp;přibližně 1000 částicemi. Může jich být méně, pokud
se některé částice překrývají:</p>

*** image ***
<p><i>Obrázek 3: Statický částicový systém vykreslený kódem popsaným
v&nbsp;předchozí kapitole.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Realizace dynamického částicového systému</h2>

<p>Ve druhém kroku začněme realizací velmi jednoduchého částicového systému,
v&nbsp;němž se budou nacházet částice, které se pohybují v&nbsp;dvourozměrné
ploše a po nárazu na okraje plochy (okna) se odrazí. Žádná další pravidla
ovlivňující pohyb částic prozatím nebudou implementována. Každá částice je
uložena jako dvojice údajů [poloha, rychlost], přičemž jak poloha, tak i
rychlost jsou dvourozměrnými vektory. Částici tedy můžeme popsat běžnou
strukturou (oproti předchozí variantě jsme přidali složky vektoru
rychlosti):</p>

<pre>
typedef struct {
    float x;
    float y;
    float vx;
    float vy;
} <strong>Particle</strong>;
</pre>

<p>Celý částicový systém pak může být uložen taktéž ve formě struktury, která
bude obsahovat alokovaný blok s&nbsp;částicemi (ty nebudou vznikat ani
zanikat), počtem částic a taktéž barvou všech částic v&nbsp;systému. Později
uvidíme, z&nbsp;jakého důvodu je barva uložena zrovna zde:</p>

<pre>
typedef struct Color {
    unsigned char r;
    unsigned char g;
    unsigned char b;
} <strong>Color</strong>;
&nbsp;
typedef struct {
    Particle *particles;
    int max;
    Color color;
} <strong>ParticleSystem</strong>;
</pre>

<p>Částicový systém je navíc společně s&nbsp;takzvaným pravidlem (<i>rule</i>,
prozatím jediná hodnota s&nbsp;plovoucí řádovou čárkou) uložen ve struktuře
představující celý modelovaný svět, jenž je složený pouze z&nbsp;částic:</p>

<pre>
typedef struct {
    float rule;
    ParticleSystem particle_system;
} <strong>Model</strong>;
</pre>

<p>Inicializace hodnoty <strong>rule</strong> je prozatím triviální (později se
funkce rozšíří):</p>

<pre>
void <strong>init_rule</strong>(Model *model) {
    model-&gt;rule = 2.0 * (float)rand() / RAND_MAX - 1.0;
}
</pre>

<p>Následuje upravená varianta funkce <strong>create_particles</strong>, která
kromě pozice částic nastaví i jejich počáteční rychlost:</p>

<pre>
void <strong>create_particles</strong>(int max, Particle *particles) {
    int i;
    for (i = 0; i &lt; max; i++) {
        particles[i].x = randomX();
        particles[i].y = randomY();
        particles[i].vx = (float)rand() / RAND_MAX - 0.5;
        particles[i].vy = (float)rand() / RAND_MAX - 0.5;
    }
}
</pre>

<p>Vykreslení částicového systému je realizováno naprosto stejnou funkcí, jako
v&nbsp;prvním příkladu. Jen pro úplnost tedy:</p>

<pre>
void <strong>redraw</strong>(GraphicsState *graphicsState, SDL_Surface *pixmap, Model *model) {
    int i;
&nbsp;
    ParticleSystem particle_system = model-&gt;particle_system;
&nbsp;
    SDL_FillRect(pixmap, NULL, 0x00);
    for (i = 0; i &lt; particle_system.max; i++) {
        Particle particle = particle_system.particles[i];
        Color color = particle_system.color;
        putpixel(pixmap, particle.x, particle.y, color.r, color.g, color.b);
        putpixel(pixmap, particle.x - 1, particle.y, color.r, color.g, color.b);
        putpixel(pixmap, particle.x + 1, particle.y, color.r, color.g, color.b);
        putpixel(pixmap, particle.x, particle.y - 1, color.r, color.g, color.b);
        putpixel(pixmap, particle.x, particle.y + 1, color.r, color.g, color.b);
    }
&nbsp;
    show_pixmap(graphicsState, pixmap);
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Výpočet nové pozice částic na základě jejich rychlosti a případných odrazů</h2>

<p>V&nbsp;každém snímku je nutné vypočítat nové pozice všech částic
v&nbsp;částicovém systému. Každé částici je přiřazena rychlost, takže můžeme
provést pseuodointegraci a vypočítat novou pozici částice <strong>a</strong>
takto:</p>

<pre>
a-&gt;x += a-&gt;vx;
a-&gt;y += a-&gt;vy;
</pre>

<p><div class="rs-tip-major">Poznámka: vektor rychlosti je většinou dostatečně
malý, aby se částice posunula jen o jeden či maximálně několik pixelů &ndash;
viz funkci <strong>create_particles</strong> uvedenou výše.</div></p>

<p>Navíc do programového kódu přidáme i podmínku pro odraz částic od okrajů
obrazovky (a posun částice do vyhrazené oblasti):</p>

<pre>
void <strong>apply_rule</strong>(Model *model) {
    int i;
&nbsp;
    for (i = 0; i &lt; model-&gt;particle_system.max; i++) {
        Particle *a = &amp;model-&gt;particle_system.particles[i];
&nbsp;
        <i>/* move particle */</i>
        a-&gt;x += a-&gt;vx;
        a-&gt;y += a-&gt;vy;
&nbsp;
        <i>/* check if particle touches scene boundary */</i>
        if (a-&gt;x &lt;= 0) {
            a-&gt;vx = -a-&gt;vx;
            a-&gt;x = 0;
        }
        if (a-&gt;x &gt; WIDTH) {
            a-&gt;vx = -a-&gt;vx;
            a-&gt;x = WIDTH - 1;
        }
        if (a-&gt;y &lt;= 0) {
            a-&gt;vy = -a-&gt;vy;
            a-&gt;y = 0;
        }
        if (a-&gt;y &gt; HEIGHT) {
            a-&gt;vy = -a-&gt;vy;
            a-&gt;y = HEIGHT - 1;
        }
    }
}
</pre>

<p>Právě tuto funkci budeme postupně rozšiřovat a vylepšovat v&nbsp;rámci
dalších kapitol.</p>

<p><div class="rs-tip-major">Poznámka: adresář s&nbsp;tímto projektem se
nachází na adrese <a
href="https://github.com/tisnik/presentations/tree/master/particle_life/v1/">https://github.com/tisnik/presentations/tree/master/particle_life/v1/</a>.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Ukázky grafické plochy s&nbsp;vizualizovaným dynamickým částicovým systémem</h2>

*** image ***
<p><i>Obrázek 4: Částicový systém s&nbsp;pohybujícími se částicemi.</i></p>

*** image ***
<p><i>Obrázek 5: Částicový systém s&nbsp;pohybujícími se částicemi.</i></p>

*** image ***
<p><i>Obrázek 6: Částicový systém s&nbsp;pohybujícími se částicemi.</i></p>

<p><div class="rs-tip-major">Poznámka: žádná emergence tedy prozatím
nenastala.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Přidání pravidla pro vzájemné odpuzování částic</h2>

<p>V&nbsp;následujícím kroku částicový systém poměrně razantně modifikujeme.
Upravíme totiž funkci určenou pro aplikaci pravidel, jak se mají částice
pohybovat. Nyní se budou částice odpuzovat ve chvíli, kdy se k&nbsp;sobě
přiblíží na vzdálenost definovanou v&nbsp;konstantě:</p>

<pre>
#define MAX_DISTANCE 50
</pre>

<p>Na základě vzdálenosti dvou částic <strong>a</strong> a <strong>b</strong>
se vypočítá vektor odpudivé síly:</p>

<pre>
float dx = a-&gt;x - b-&gt;x;
float dy = a-&gt;y - b-&gt;y;
if (dx != 0.0 || dy != 0.0) {
    float d = dx * dx + dy * dy;
    if (d &lt; MAX_DISTANCE * MAX_DISTANCE) {
        <i>/* repel force */</i>
        float f = g / sqrt(d);
        fx += f * dx;
        fy += f * dy;
    }
}
</pre>

<p>Navíc se pro dosažení větší stability (aby systém příliš
&bdquo;nekmital&ldquo; a nebyla v&nbsp;něm velká kladná zpětná vazba) rychlost
částic v&nbsp;každém kroku zmenší o koeficient:</p>

<pre>
#define DAMPING_FACTOR 0.5
</pre>

<p>Tímto vztahem:</p>

<pre>
a-&gt;vx = (a-&gt;vx + fx * DT) * DAMPING_FACTOR;
a-&gt;vy = (a-&gt;vy + fy * DT) * DAMPING_FACTOR;
</pre>

<p>Výsledkem je zcela nová podoba funkce <strong>apply_rule</strong>:</p>

<pre>
void <strong>apply_rule</strong>(Model *model) {
    int i, j;
&nbsp;
    for (i = 0; i &lt; model-&gt;particle_system.max; i++) {
        float fx = 0.0;
        float fy = 0.0;
        Particle *a = &amp;model-&gt;particle_system.particles[i];
&nbsp;
        <i>/* compute force for selected particle */</i>
        for (j = 0; j &lt; model-&gt;particle_system.max; j++) {
            if (i != j) {
                Particle *b = &amp;model-&gt;particle_system.particles[j];
                float g = model-&gt;rule;
                float dx = a-&gt;x - b-&gt;x;
                float dy = a-&gt;y - b-&gt;y;
                if (dx != 0.0 || dy != 0.0) {
                    float d = dx * dx + dy * dy;
                    if (d &lt; MAX_DISTANCE * MAX_DISTANCE) {
                        <i>/* repel force */</i>
                        float f = g / sqrt(d);
                        fx += f * dx;
                        fy += f * dy;
                    }
                }
            }
        }
&nbsp;
        <i>/* apply force to selected particle */</i>
        a-&gt;vx = (a-&gt;vx + fx * DT) * DAMPING_FACTOR;
        a-&gt;vy = (a-&gt;vy + fy * DT) * DAMPING_FACTOR;
&nbsp;
        <i>/* move particle */</i>
        a-&gt;x += a-&gt;vx;
        a-&gt;y += a-&gt;vy;
&nbsp;
        <i>/* check if particle touches scene boundary */</i>
        if (a-&gt;x &lt;= 0) {
            a-&gt;vx = -a-&gt;vx;
            a-&gt;x = 0;
        }
        if (a-&gt;x &gt; WIDTH) {
            a-&gt;vx = -a-&gt;vx;
            a-&gt;x = WIDTH - 1;
        }
        if (a-&gt;y &lt;= 0) {
            a-&gt;vy = -a-&gt;vy;
            a-&gt;y = 0;
        }
        if (a-&gt;y &gt; HEIGHT) {
            a-&gt;vy = -a-&gt;vy;
            a-&gt;y = HEIGHT - 1;
        }
    }
}
</pre>

<p><div class="rs-tip-major">Poznámka: adresář s&nbsp;takto upraveným projektem se
nachází na adrese <a
href="https://github.com/tisnik/presentations/tree/master/particle_life/v2/">https://github.com/tisnik/presentations/tree/master/particle_life/v2/</a>.</div></p>




