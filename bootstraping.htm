<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Můžeme věřit překladačům? Projekty řešící schéma "důvěřivé důvěry"</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Můžeme věřit překladačům? Projekty řešící schéma "důvěřivé důvěry"</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Můžeme věřit překladačům? Projekty řešící schéma "důvěřivé důvěry"</a></p>
<p><a href="#k02">*** 2. Klasický problém slepice-vejce</a></p>
<p><a href="#k03">*** 3. Ukázka provedená Thompsonem</a></p>
<p><a href="#k04">*** 4. Kam tedy nejlépe schovat zadní vrátka?</a></p>
<p><a href="#k05">*** 5. &bdquo;Cykly&ldquo; v&nbsp;použitých nástrojích</a></p>
<p><a href="#k06">*** 6. Možná řešení &bdquo;cyklu&ldquo; v&nbsp;použitých nástrojích</a></p>
<p><a href="#k07">*** 7. Nástroje psané v&nbsp;assembleru</a></p>
<p><a href="#k08">*** 8. Zajímavá lekce z&nbsp;minulosti: assemblery A1 a A2</a></p>
<p><a href="#k09">*** 9. Projekt Stage0</a></p>
<p><a href="#k10">*** 10. Základní sada nástrojů vyvinutých v&nbsp;rámci projektu Stage0</a></p>
<p><a href="#k11">*** 11. Další nástroje, které nalezneme v&nbsp;projektu Stage0</a></p>
<p><a href="#k12">*** 12. Projekt Bootstrap</a></p>
<p><a href="#k13">*** 13. Projekt bcompiler</a></p>
<p><a href="#k14">*** 14. Použití druhého překladače pro zjištění modifikovaného kódu</a></p>
<p><a href="#k15">*** 15. Překladač <strong>tcc</strong></a></p>
<p><a href="#k16">*** 16. Postačuje provést překlad <strong>gcc</strong> s&nbsp;využitím <strong>tcc</strong>?</a></p>
<p><a href="#k17">*** 17. Alternativní cesta: jednoduché a verifikovatelné virtuální stroje</a></p>
<p><a href="#k18">*** 18. Forth</a></p>
<p><a href="#k19">*** 19. TinyBASIC</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Můžeme věřit překladačům? Projekty řešící schéma "důvěřivé důvěry"</h2>




<p><a name="k02"></a></p>
<h2 id="k02">2. Klasický problém slepice-vejce</h2>

<p><i>"Recipe for yogurt: Add yogurt to milk." - Anon.</i></p>

<p>Jádro celého problému spočívá v&nbsp;tom, že existuje způsob jak zajistit, aby se zdrojové kódy, které při kontrole programátorem evidentně žádná zadní vrátka neobsahují, přeložily do spustitelného binárního kódu popř.&nbsp;do staticky/dynamicky linkované knihovny, kde už ovšem zadní vrátka být mohou. Běžní programátoři totiž (i z&nbsp;časových důvodů) podrobně nezkoumají výsledek překladu, tj.&nbsp;relativně špatně rozluštitelný strojový kód, navíc kombinovaný s&nbsp;daty atd. Navíc &ndash; pokud už nevěříme překladači, jak můžeme vědět, že budou správné ladicí informace? Překladač totiž může poměrně snadno do strojového kódu přidat instrukce, které nebudou mapovány na žádný zdrojový řádek.</p>

Multics Security Evaluation: Vulnerability Analysis
http://csrc.nist.gov/publications/history/karg74.pdf

<p>Že je takový útok prakticky možný ukázal už Ken Thompson a po něm mnozí další. Ve známých případech se většinou jednalo o akademické práce, které měly Thompsonovu teorii dokázat s&nbsp;využitím různých programovacích jazyků (typicky C, Scheme, z&nbsp;poslední doby je například článek <a href="https://manishearth.github.io/blog/2016/12/02/reflections-on-rusting-trust/">Reflections on Rusting Trust</a>) apod. Zajímavá (ovšem zdrojovými kódy nedoložená) je také historka prezentovaná v&nbsp;článečku <a href="https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute">What is a coder's worst nightmare?</a>. Skutečnými útoky tohoto typu se pravděpodobně nikdo nechlubí (ani útočník, ani oběť), ale víme například o viru The W32/Induc-A virus určený pro programy psané v&nbsp;Delphi.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Ukázka provedená Thompsonem</h2>

<p>Podívejme se nyní na známou ukázku <a href="https://en.wikipedia.org/wiki/Ken_Thompson">Kena Thompsona</a>. Ukázka platí pro programovací jazyk C, ale lze ji samozřejmě aplikovat na prakticky jakýkoli jiný překladač.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Kam tedy nejlépe schovat zadní vrátka?</h2>

“It’s just so odd that the C source would be clean but the assembly have these weird op-codes,” I said.

“I thought you had tracked it down to the compiler,” said Dave.

“I don’t mean in your code, I mean in the compiler itself.”

“The compiler could be responsible for that too.”

“No, I checked the code.”

“But the code is compiled by the compiler.”

http://opensource.apple.com/source/Security/Security-55471/libsecurity_ssl/lib/sslKeyExchange.c

<pre>
    if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != 0)
        goto fail;
        goto fail;
</pre>


<a href="https://www.infoq.com/news/2016/06/visual-cpp-telemetry"></a>
</li>

https://www.reddit.com/r/cpp/comments/4ibauu/visual_studio_adding_telemetry_function_calls_to/d30dmvu/


<p><a name="k05"></a></p>
<h2 id="k05">5. &bdquo;Cykly&ldquo; v&nbsp;použitých nástrojích</h2>



<p><a name="k06"></a></p>
<h2 id="k06">6. Možná řešení &bdquo;cyklu&ldquo; v&nbsp;použitých nástrojích</h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. Nástroje psané v&nbsp;assembleru</h2>

https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;a=tree;f=gas;h=bc1ca0cf8ffb1415090f3ca87441b30e8ec25621;hb=HEAD
https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;a=blob_plain;f=gas/as.c;hb=HEAD

http://repo.or.cz/nasm.git/tree/HEAD:/asm



<p><a name="k08"></a></p>
<h2 id="k08">8. Zajímavá lekce z&nbsp;minulosti: assemblery A1 a A2</h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. Projekt Stage0</h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. Základní sada nástrojů vyvinutých v&nbsp;rámci projektu Stage0</h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. Další nástroje, které nalezneme v&nbsp;projektu Stage0</h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. Projekt Bootstrap</h2>

https://github.com/ras52/bootstrap

<table>
<tr><th>Fáze</th><th>Nástroje</th></tr>
<tr><td>0</td><td>unhex</td></tr>
<tr><td>1</td><td>unhexl, elfify</td></tr>
<tr><td>2</td><td>as</td></tr>
<tr><td>3</td><td>as, ld</td></tr>
<tr><td>4</td><td>cc, crt0.o, libc.o</td></tr>
<tr><td>5</td><td>ccx, cpp, cc, cmp</td></tr>
</table>


<p><a name="k13"></a></p>
<h2 id="k13">13. Projekt bcompiler</h2>

https://github.com/certik/bcompiler

<table>
<tr><th>Fáze</th><th>Nástroje</th></tr>
<tr><td>0</td><td></td></tr>
<tr><td>1</td><td></td></tr>
<tr><td>2</td><td></td></tr>
<tr><td>3</td><td></td></tr>
<tr><td>4</td><td></td></tr>
<tr><td>5</td><td></td></tr>
<tr><td>6</td><td></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Použití druhého překladače pro zjištění modifikovaného kódu</h2>

<p>Kromě překladače céčka patřícího do skupiny nástrojů GCC (i samotný překladač se jmenuje GCC &ndash; <i>GNU C Compiler</i>, což může být poněkud matoucí &ndash; je nutné vždy sledovat kontext, ve kterém se o GCC mluví či píše) je možné v&nbsp;operačním systému Linux použít i další překladače programovacího jazyka C. Mezi ně patří například <i>Clang</i> z&nbsp;projektu LLVM, jenž je zajímavý především po technologické stránce i z&nbsp;hlediska výpočetního výkonu výsledných binárních souborů. Dále se pak můžeme setkat s&nbsp;překladači komerčních firem, například překladačem vytvořeným společností Intel, který v&nbsp;případě některých typů optimalizací překonává GCC. V&nbsp;neposlední řadě je pak možné v&nbsp;Linuxu (a nutno říci, že nejenom v&nbsp;něm) použít překladač nazvaný <i>Tiny C Compiler</i> (<i>tcc</i>), jehož krátkým popisem a porovnáním s&nbsp;GCC se budeme zabývat v&nbsp;následující kapitole.</p>




<p><a name="k15"></a></p>
<h2 id="k15">15. Překladač <strong>tcc</strong></h2>

<p>Tiny C Compiler (tcc) je překladač programovacího jazyka C, který byl původně vytvořen Fabrice Bellardem a nyní se o jeho další vývoj a portaci na nové platformy stará komunita vývojářů, protože se samozřejmě jedná o open source projekt. Tiny C Compiler  kromě vlastního překladače v sobě obsahuje i linker, což znamená, že jeden binární program může sloužit jak pro překlad zdrojových textů (včetně preprocesingu) do objektového kódu, tak i pro vytvoření výsledného spustitelného binárního programu. Všechny tři zmíněné funkce jsou implementovány v jediném spustitelném souboru, jehož velikost na platformě x86 nepřesahuje sto kilobajtů, což je například v porovnání s GCC zcela zanedbatelná velikost (dokonce i pouze GNU assembler je v binární podobě větší, než celý tcc).</p>

<p>Tiny C Compiler podporuje standard C89/C90 i velkou část standardu C99, a to do té míry, že úpravy zdrojových kódů určených pro GCC většinou nejsou zapotřebí. Největší devizou překladače tcc je blesková rychlost překladu, protože vlastní překlad je jednoprůchodový. Na stránkách tohoto projektu se uvádí, že tcc je přibližně osmkrát rychlejší než překladač GCC (s použitím standardních voleb, tj. bez optimalizací), ovšem jak se můžete dozvědět z dalšího textu, může být tcc v extrémním případě rychlejší zhruba čtyřicetkrát (!). Na druhou stranu však tcc za většinou ostatních moderních překladačů céčka pokulhává v případě optimalizací prováděných při překladu.</p>

<p>Pro nás je ovšem v&nbsp;kontextu dnešního článku nejzajímavější fakt, že Tiny C Compiler lze úspěšně použít pro překlad GCC a naopak. Tím by se &ndash; alespoň teoreticky &ndash; mohl vyřešit problém, se kterým jsme se seznámili v&nbsp;předchozí kapitole.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Postačuje provést překlad <strong>gcc</strong> s&nbsp;využitím <strong>tcc</strong>?</h2>

<p>Mohlo by se zdát, že pokud použijeme pro překlad GNU C překladače (nebo libovolného jiného překladače, kterému v&nbsp;daný okamžik nedůvěřujeme) přímo <strong>tcc</strong>, byl problém důvěry vyřešen, protože nový binární soubor <strong>gcc</strong> sice bude relativně pomalý (Tiny C Compiler nedokáže provádět složitější optimalizace), ale jeho chování by mělo odpovídat jeho zdrojovým kódům. Ve skutečnosti tomu tam bohužel není, protože samotný <strong>tcc</strong> sice provede překlad, ovšem samotný překlad je jen součástí celého procesu vytvoření nového binárního souboru. Kromě toho se totiž používají další nástroje spouštěné například ze skriptu <strong>configure</strong>. A tyto nástroje bývají přeloženy právě (možná napadeným) překladačem <strong>gcc</strong>. Na druhou stranu ovšem <strong>tcc</strong> používá vlastní linker, takže jsme na tom paradoxně lépe, než při snaze o použití assembleru.</p>

<p>Co to znamená v&nbsp;praxi? Stále je nutné provést postup dvojí kompilace zmíněný <a href="#k14">ve čtrnácté kapitole</a>.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Alternativní cesta: jednoduché a verifikovatelné virtuální stroje</h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Forth</h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. TinyBASIC</h2>

<p>Zajímavě byl </p>

<p>Na základě článku Dennise Allisona vzniklo a vzápětí se i rozšířilo několik
různých implementací BASICu, které byly většinou nazvány (opět podle článku)
<i>Tiny BASIC</i>. Tyto implementace byly dostupné jak pro osmibitové
mikroprocesory firmy Intel, tak i pro procesor Motorola 6800 či MOS 6502, a to
buď zcela zdarma nebo pod de-facto symbolickou částkou pěti dolarů (tato částka
většinou zahrnovala i poštovné). Ovšem díky vzniku tolik žádoucí konkurence na
trhu s&nbsp;domácími osmibitovými počítači se firmy začaly přetahovat o
zákazníky, takže se snažily nabízet počítače již se základním programovým
vybavením (uloženým v&nbsp;naprosté většině případů přímo v&nbsp;ROM) a nejenom
skládačku typu počítače <i>Altair</i>, kde si uživatelé kromě ceny za počítač
(400 dolarů) většinou museli připlatit i již zmíněných 150 dolarů za interpret
programovacího jazyka.</p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Defending Against Compiler-Based Backdoors<br />
<a href="https://blog.regehr.org/archives/1241">https://blog.regehr.org/archives/1241</a>
</li>

<li>Reflections on Trusting Trust<br />
<a href="https://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html">https://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html</a>
</li>

<li>Coding Machines (povídka)<br />
<a href="https://www.teamten.com/lawrence/writings/coding-machines/">https://www.teamten.com/lawrence/writings/coding-machines/</a>
</li>

<li>Stage0<br />
<a href="https://bootstrapping.miraheze.org/wiki/Stage0">https://bootstrapping.miraheze.org/wiki/Stage0</a>
</li>

<li>Projekt stage0 na GitHubu<br />
<a href="https://github.com/oriansj/stage0">https://github.com/oriansj/stage0</a>
</li>

<li>Bootstraping wiki<br />
<a href="https://bootstrapping.miraheze.org/wiki/Main_Page">https://bootstrapping.miraheze.org/wiki/Main_Page</a>
</li>

<li>Bootstrapped 6502 Assembler<br />
<a href="https://github.com/robinluckey/bootstrap-6502">https://github.com/robinluckey/bootstrap-6502</a>
</li>

<li>IBM Basic assembly language and successors<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>run6502, lib6502 — 6502 microprocessor emulator<br />
<a href="http://piumarta.com/software/lib6502/">http://piumarta.com/software/lib6502/</a>
</li>

<li>Simple Computer Simulator Instruction-Set<br />
<a href="http://www.science.smith.edu/dftwiki/index.php/Simple_Computer_Simulator_Instruction-Set">http://www.science.smith.edu/dftwiki/index.php/Simple_Computer_Simulator_Instruction-Set</a>
</li>

<li>Bootstrapping#Computing<br />
<a href="https://en.wikipedia.org/wiki/Bootstrapping#Computing">https://en.wikipedia.org/wiki/Bootstrapping#Computing</a>
</li>

<li>Bootstrapping (compilers)<br />
<a href="https://en.wikipedia.org/wiki/Bootstrapping_%28compilers%29">https://en.wikipedia.org/wiki/Bootstrapping_%28compilers%29</a>
</li>

<li>Bootstrapable Builds<br />
<a href="http://bootstrappable.org/">http://bootstrappable.org/</a>
</li>

<li>What is a coder's worst nightmare?<br />
<a href="https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute">https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute</a>
</li>

<li>Linux Assembly<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Tombstone diagram<br />
<a href="https://en.wikipedia.org/wiki/Tombstone_diagram">https://en.wikipedia.org/wiki/Tombstone_diagram</a>
</li>

<li>History of compiler construction<br />
<a href="https://en.wikipedia.org/wiki/History_of_compiler_construction">https://en.wikipedia.org/wiki/History_of_compiler_construction</a>
</li>

<li>Self-hosting<br />
<a href="https://en.wikipedia.org/wiki/Self-hosting">https://en.wikipedia.org/wiki/Self-hosting</a>
</li>

<li>GNU Mes: Maxwell Equations of Software<br />
<a href="https://gitlab.com/janneke/mes">https://gitlab.com/janneke/mes</a>
</li>

<li>Tiny C Compiler<br />
<a href="https://bellard.org/tcc/">https://bellard.org/tcc/</a>
</li>

<li>Welcome to C--<br />
<a href="https://www.cs.tufts.edu/~nr/c--/index.html">https://www.cs.tufts.edu/~nr/c--/index.html</a>
</li>

<li>c4 - C in four functions<br />
<a href="https://github.com/rswier/c4">https://github.com/rswier/c4</a>
</li>

<li>Tiny BASIC<br />
<a href="https://en.wikipedia.org/wiki/Tiny_BASIC">https://en.wikipedia.org/wiki/Tiny_BASIC</a>
</li>

<li>David A. Wheeler’s Page on Fully Countering Trusting Trust through Diverse Double-Compiling (DDC) - Countering Trojan Horse attacks on Compilers<br />
<a href="https://www.dwheeler.com/trusting-trust/">https://www.dwheeler.com/trusting-trust/</a>
</li>

<li>Reviewing Microsoft's Automatic Insertion of Telemetry into C++ Binaries<br />
<a href="https://www.infoq.com/news/2016/06/visual-cpp-telemetry">https://www.infoq.com/news/2016/06/visual-cpp-telemetry</a>
</li>

<li>Visual Studio adding telemetry function calls to binary?<br />
<a href="https://www.reddit.com/r/cpp/comments/4ibauu/visual_studio_adding_telemetry_function_calls_to/d30dmvu/">https://www.reddit.com/r/cpp/comments/4ibauu/visual_studio_adding_telemetry_function_calls_to/d30dmvu/</a>
</li>

<li>LWN - The Trojan Horse<br />
<a href="https://www.dwheeler.com/trusting-trust/spencer-19981123.txt">https://www.dwheeler.com/trusting-trust/spencer-19981123.txt</a>
</li>

<li>reproducible-builds.org<br />
<a href="https://reproducible-builds.org/">https://reproducible-builds.org/</a>
</li>

<li>Other Assemblers<br />
<a href="http://asm.sourceforge.net/howto/other.html">http://asm.sourceforge.net/howto/other.html</a>
</li>

<li>Projekt bootstrap<br />
<a href="https://github.com/ras52/bootstrap">https://github.com/ras52/bootstrap</a>
</li>

<li>Projekt bcompiler<br />
<a href="https://github.com/certik/bcompiler">https://github.com/certik/bcompiler</a>
</li>

<li>Zadní vrátka<br />
<a href="https://cs.wikipedia.org/wiki/Zadn%C3%AD_vr%C3%A1tka#Reflections_on_Trusting_Trust">https://cs.wikipedia.org/wiki/Zadn%C3%AD_vr%C3%A1tka#Reflections_on_Trusting_Trust</a>
</li>

<li>David A. Wheeler’s Personal Home Page<br />
<a href="https://www.dwheeler.com/">https://www.dwheeler.com/</a>
</li>

<li>David A. Wheeler<br />
<a href="https://en.wikipedia.org/wiki/David_A._Wheeler">https://en.wikipedia.org/wiki/David_A._Wheeler</a>
</li>

<li>Multics Security Evaluation: Vulnerability Analysis<br />
<a href="http://csrc.nist.gov/publications/history/karg74.pdf">http://csrc.nist.gov/publications/history/karg74.pdf</a>
</li>

<li>Reflections on Rusting Trust<br />
<a href="https://manishearth.github.io/blog/2016/12/02/reflections-on-rusting-trust/">https://manishearth.github.io/blog/2016/12/02/reflections-on-rusting-trust/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

