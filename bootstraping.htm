<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Můžeme věřit překladačům? Projekty řešící schéma "důvěřivé důvěry"</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Můžeme věřit překladačům? Projekty řešící schéma "důvěřivé důvěry"</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku se seznámíme s&nbsp;některými zajímavými projekty, které se snaží &ndash; každý svým způsobem &ndash; vyřešit schéma &bdquo;důvěřivé důvěry&ldquo;, přesněji řečeno problém, kdy máme věřit, že námi používaný překladač například neobsahuje sofistikovaného trojského koně.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Můžeme věřit překladačům? Projekty řešící schéma "důvěřivé důvěry"</a></p>
<p><a href="#k02">2. Klasický problém slepice-vejce</a></p>
<p><a href="#k03">3. Kam schovat zadní vrátka ve chvíli, kdy je zdrojový kód překladače k&nbsp;dispozici?</a></p>
<p><a href="#k04">4. Ukázka z&nbsp;povídky &bdquo;Coding Machines&ldquo;</a></p>
<p><a href="#k05">5. &bdquo;Cykly&ldquo; v&nbsp;použitých nástrojích</a></p>
<p><a href="#k06">6. Možná řešení &bdquo;cyklu&ldquo; v&nbsp;použitých nástrojích</a></p>
<p><a href="#k07">7. Nástroje psané v&nbsp;assembleru</a></p>
<p><a href="#k08">8. Zajímavá lekce z&nbsp;minulosti: assemblery A1 a A2</a></p>
<p><a href="#k09">9. Projekt Stage0</a></p>
<p><a href="#k10">10. Základní sada nástrojů vyvinutých v&nbsp;rámci projektu Stage0</a></p>
<p><a href="#k11">11. Další nástroje, které nalezneme v&nbsp;projektu Stage0</a></p>
<p><a href="#k12">12. Projekt Bootstrap</a></p>
<p><a href="#k13">*** 13. Projekt bcompiler</a></p>
<p><a href="#k14">*** 14. Použití druhého překladače pro zjištění modifikovaného kódu</a></p>
<p><a href="#k15">*** 15. Překladač <strong>tcc</strong></a></p>
<p><a href="#k16">*** 16. Postačuje provést překlad <strong>gcc</strong> s&nbsp;využitím <strong>tcc</strong>?</a></p>
<p><a href="#k17">*** 17. Alternativní cesta: jednoduché a verifikovatelné virtuální stroje</a></p>
<p><a href="#k18">*** 18. Forth</a></p>
<p><a href="#k19">*** 19. TinyBASIC</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Můžeme věřit překladačům? Projekty řešící schéma "důvěřivé důvěry"</h2>

<p></p>

*** image ***
<p><i>Obrázek 1: Idylická situace &ndash; překladač přesně přeloží náš zdrojový
kód a výsledná binární podoba aplikace dělá přesně to, co bylo ve zdrojovém
kódu napsáno.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Klasický problém slepice-vejce</h2>

<p><i>"Recipe for yogurt: Add yogurt to milk." - Anon.</i></p>

<p>Jádro celého problému důvěryhodnosti nebo nedůvěryhodnosti překladače
spočívá v&nbsp;tom, že existuje způsob jak zajistit, aby se &bdquo;čisté&ldquo;
zdrojové kódy, které při kontrole programátorem evidentně žádná zadní vrátka
neobsahují, přeložily do spustitelného binárního kódu popř.&nbsp;do staticky
nebo dynamicky linkované knihovny, kde už ovšem zadní vrátka být mohou. Běžní
programátoři totiž (mj.&nbsp;i z&nbsp;časových důvodů) podrobně nezkoumají
výsledek překladu, tj.&nbsp;relativně špatně rozluštitelný strojový kód, navíc
kombinovaný s&nbsp;daty atd. Navíc &ndash; pokud už nevěříme použitému
překladači, jak můžeme vědět, že ve výsledném binárním souboru budou správné
ladicí informace? Překladač totiž může poměrně snadno do strojového kódu přidat
instrukce, které nebudou mapovány na žádný zdrojový řádek. Koncept podobného
útoku byl rozpracován již v&nbsp;roce 1974 ve zprávě <a
href="http://csrc.nist.gov/publications/history/karg74.pdf">Multics Security
Evaluation: Vulnerability Analysis</a>.</p>

*** image ***
<p><i>Obrázek 2: Pokud je překladač z&nbsp;nějakého důvodu upraven, může
produkovat binární kód, který (možná) odpovídá zdrojovému kódu, ale taktéž může
obsahovat nějaká zadní vrátka (nebo obecně trojského koně).</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Kam schovat zadní vrátka ve chvíli, kdy je zdrojový kód překladače k&nbsp;dispozici?</h2>

<p>Mohlo by se zdát, že pokud jsme v&nbsp;situaci, kdy máme k&nbsp;dispozici
zdrojový kód překladače (například překladače céčka z&nbsp;projektu GCC), máme
vyhráno, protože můžeme libovolně dlouho a s&nbsp;vynaložením libovolně
vysokých finančních prostředků analyzovat zdrojové kódy překladače a ověřit si
tak, že žádná zadní vrátka neobsahuje. Navíc můžeme tento zdrojový kód přeložit
a získat tak druhou binární kopii GCC, která bude bezpečná a verifikovaná (však
také vznikla překladem z&nbsp;verifikovaných zdrojových kódů ne?):</p>

*** image ***
<p><i>Obrázek 3: Ve chvíli, kdy není překladač nijak napaden, vznikne překladem
jeho vlastních zdrojových kódů opět &bdquo;čistý&ldquo; (nenapadený) překladač.
Pokud se jedná stále o stejnou verzi, měly by být binární obrazy totožné
(předpokládáme použití stejných přepínačů, shodnou architekturu, žádná časová
razítka atd.).</i></p>

<p>Ve skutečnosti však může být situace mnohem horší, protože napadený
překladač může být upraven tak sofistikovaně, že pozná, že překládá sám sebe a
vloží do výsledného binárního kódu příslušnou část <i>pro generování trojského
koně</i> ve chvíli, kdy bude nový překladač použit:</p>

*** image ***
<p><i>Obrázek 4: Ve chvíli, kdy nemůžeme důvěřovat binárnímu kódu překladače,
není vůbec jisté, co vznikne překladem čistých zdrojových kódů.
V&nbsp;nejhorším případě musíme předpokládat, že získáme opět napadený
překladač!</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Ukázka provedená Thompsonem</h2>

<p>Že je takový útok prakticky možný ukázal už Ken Thompson a po něm mnozí
další. Ve známých případech se většinou jednalo o akademické práce, které měly
Thompsonovu teorii dokázat s&nbsp;využitím různých programovacích jazyků
(typicky se jednalo o C, Scheme, z&nbsp;poslední doby je například článek <a
href="https://manishearth.github.io/blog/2016/12/02/reflections-on-rusting-trust/">Reflections
on Rusting Trust</a> popř.&nbsp;<a
href="https://www.slideshare.net/yeokm1/reflections-on-trusting-trust-for-go">Reflections
on Trusting Trust for Go</a>) apod. Zajímavá (ovšem zdrojovými kódy nedoložená)
je také historka prezentovaná v&nbsp;článečku <a
href="https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute">What
is a coder's worst nightmare?</a>. Skutečnými útoky tohoto typu se
pravděpodobně nikdo nechlubí (ani útočník, ani oběť), ale víme například o viru
The W32/Induc-A virus určený pro programy psané v&nbsp;Delphi popř.&nbsp;o
Xcodeghost (napadený překladač Xcode).</p>

<p>Podívejme se nyní na známou ukázku <a
href="https://en.wikipedia.org/wiki/Ken_Thompson">Kena Thompsona</a>. Ukázka
platí pro programovací jazyk C, ale lze ji samozřejmě aplikovat na prakticky
jakýkoli jiný překladač.</p>

<p>První fáze spočívá v&nbsp;úpravě zdrojových kódů překladače a vložení dvou
nových funkcí:</p>

<ol>

<li>Pokud překladač pozná, že se překládá běžná aplikace, vloží do ní zadní
vrátka (například si otevře nějaký port, na kterém bude aplikace
poslouchat).</li>

<li>Pokud překladač pozná, že překládá sám sebe, zajistí, aby se v&nbsp;nové
binární podobě překladače objevil kód z&nbsp;bodu číslo 1.</li>

</ol>

*** image ***
<p><i>Obrázek 5: První fáze popsaná v&nbsp;předchozím textu.</i></p>

<p>Nyní jsme tedy v&nbsp;situaci, kdy se napadený překladač dokáže sám šířit
<i>nezávisle na tom, že vstupní zdrojové kódy jsou verifikovány</i>:</p>

*** image ***
<p><i>Obrázek 6: Situace, ve které máme překladač, který ze svého
&bdquo;čistého&ldquo; zdrojového kódu vygeneruje napadený binární podobu
překladače.</i></p>

<p>Důležité je, aby útočníkem upravené zdrojové kódy nebyly nikde
distribuovány. Postačuje pouze jednou (na začátku) rozšířit napadený překladač,
který (při vhodném naprogramování) může zadní vrátka šířit libovolně
dlouho:</p>

*** image ***
<p><i>Obrázek 7: Takto musí celou situaci vidět zbytek světa nebo alespoň oběť
útoku.</i></p>

<p><div class="rs-tip-major">Poznámka: výše uvedený postup musí útočník dodržet
v&nbsp;případě, že uživatel má přístup ke zdrojovým kódům překladače. Pokud
tomu tak není, je situace samozřejmě mnohem jednodušší. Náznak případných
problémů (v&nbsp;tomto konkrétním případě trošku zveličených) <a
href="https://www.infoq.com/news/2016/06/visual-cpp-telemetry">naleznete
například zde</a> a reakci <a
href="https://www.reddit.com/r/cpp/comments/4ibauu/visual_studio_adding_telemetry_function_calls_to/d30dmvu/">zde</a>.</div></p>

<p><div class="rs-tip-major">Poznámka 2: na druhou stranu je nutné poznamenat,
že už jsme se poučili, že ani otevřené zdrojové kódy <a
href="http://opensource.apple.com/source/Security/Security-55471/libsecurity_ssl/lib/sslKeyExchange.c">nemusí
zaručit bezpečnost</a>:</div></p>

<pre>
    if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != 0)
        goto fail;
        goto fail;
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Ukázka z&nbsp;povídky &bdquo;Coding Machines&ldquo;</h2>

<p>Následuje ukázka z&nbsp;krátké povídky &bdquo;Coding Machines&ldquo;, kterou
si můžete celou přečíst na stránce <a
href="https://www.teamten.com/lawrence/writings/coding-machines/">https://www.teamten.com/lawrence/writings/coding-machines/</a>.
Povídka je založena na podobném konceptu, jaký byl naznačen výše:</p>

<p>“It’s just so odd that the C source would be clean but the assembly have these weird op-codes,” I said.</p>

<p>“I thought you had tracked it down to the compiler,” said Dave.</p>

<p>“I don’t mean in your code, I mean in the compiler itself.”</p>

<p>“The compiler could be responsible for that too.”</p>

<p>“No, I checked the code.”</p>

<p>“But the code is compiled by the compiler.”</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. &bdquo;Cykly&ldquo; v&nbsp;použitých nástrojích</h2>

<p>Jeden z&nbsp;důvodů, proč může být podvržení překladače navržené Kenem
Thompsonem úspěšné, spočívá v&nbsp;tom, že mnoho v&nbsp;současnosti používaných
&bdquo;toolchainů&ldquo; obsahuje cyklus, tj.&nbsp;nějaký nástroj (typicky
právě překladač) je použit pro překlad sama sebe. Cyklus může být ovšem i
nepřímý, protože například prakticky všechny nástroje GCC jsou psány
v&nbsp;céčku a pro překlad céčka jsou zapotřebí právě tyto nástroje :-)</p>

*** image ***
<p><i>Obrázek 8: Některé (skutečně jen některé) nástroje použité pro překlad
céčkovských zdrojových kódů.</i></p>

<p>Znalost cyklu v&nbsp;toolchainu je důležitá: útočník například bude vědět,
že potenciální oběť používá dva různé překladače (řekněme GCC a LLVM), takže by
mohla napadení jednoho z&nbsp;těchto překladačů odhalit, například způsobem
naznačeným v&nbsp;dalších kapitolách. Ovšem překladač samozřejmě není jedinou
součástí toolchainu, protože lze napadnout například assembler (pokud se volá),
linker, nástroj <strong>ar</strong> apod. A ve chvíli, kdy jsou tyto nástroje
použity oběma překladači, problém stále přetrvává, i když je nutné poznamenat,
že úprava překladače je potenciálně nejjednodušší, protože tento nástroj má
nejvíce informací o kódu, který má pozměnit.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Možná řešení &bdquo;cyklu&ldquo; v&nbsp;použitých nástrojích</h2>

<p>Existuje několik metod, jak vyřešit &bdquo;cyklus&ldquo;, o němž jsme se
zmínili v&nbsp;předchozí kapitole. Buď je možné použít alternativní (druhý)
překladač, který ani nemusí být výkonný, ale postačuje, aby byl verifikován
(nebo prostě, abychom věřili, že neobsahuje žádná zadní vrátka). Touto
možností, jejíž správnost byla dokázána i matematicky, se budeme zabývat <a
href="#k14">ve čtrnácté kapitole</a>. Ovšem z&nbsp;pohledu programátora je
zajímavější odlišný přístup, který spočívá v&nbsp;tom, že se bude používat celá
&bdquo;pyramida&ldquo; nástrojů. Na nejnižší úrovni budou použity velmi
primitivní nástroje, jejichž chování si ovšem může každý znalý uživatel ověřit.
Na každé vyšší úrovni jsou přidávány složitější nástroje s&nbsp;větší úrovní
abstrakce, až nakonec skončíme u překladače vyššího programovacího jazyka
(například právě céčka). Ovšem ten vznikne sadou kroků, z&nbsp;nichž každý je
verifikovatelný; tudíž i výsledný překladač by neměl obsahovat žádné trojské
koně ani kód pro jejich generování.</p>

<p><div class="rs-tip-major">Poznámka: postupné použití sady nástrojů vedoucích
k&nbsp;vytvoření plnohodnotného překladače se nazývá
<i>bootstraping</i>.</div></p>

*** image ***
<p><i>Obrázek 9: Strohé uživatelské rozhraní monitoru pro československé
mikropočítače PMD-85. Kdo říká, že minimalismus je &bdquo;in&ldquo; až
v&nbsp;současnosti?</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Nástroje psané v&nbsp;assembleru</h2>

<p>Jen malá poznámka <a href="#k06">k&nbsp;předchozí kapitole</a>. Mohlo by se
zdát, že pokud si dáme tu práci a vytvoříme sadu základních nástrojů přímo
v&nbsp;assembleru, bude problém &bdquo;důvěřivé důvěry&ldquo; spolehlivě
vyřešen. Ovšem ve skutečnosti je většina v&nbsp;současnosti používaných
assemblerů (minimálně těch určených pro PC a Linux) naprogramována právě
v&nbsp;programovacím jazyku C nebo C++, takže problém ve skutečnosti přetrvává
(bylo by ovšem zajímavé zjistit, zda už někdo provedl úpravu céčka tak, aby byl
napaden jím překládaný assembler). Můžeme se ostatně podívat na zdrojové kódy
dvou známých assemblerů &ndash; <a
href="https://mojefedora.cz/pouziti-assembleru-v-linuxu/#k05">GNU
Assembleru</a> i <a
href="https://mojefedora.cz/pouziti-assembleru-v-linuxu/#k06">NASMu (Netwide
Assembleru)</a>:</p>

<ul>
<ol><a href="https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;a=tree;f=gas;h=bc1ca0cf8ffb1415090f3ca87441b30e8ec25621;hb=HEAD">všechny zdrojové kódy GNU Assembleru</a></ol>
<ol><a href="https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;a=blob_plain;f=gas/as.c;hb=HEAD">soubor <strong>as.c</strong></a></ol>
<ol><a href="http://repo.or.cz/nasm.git/tree/HEAD:/asm">zdrojové kódy NASMu</a></ol>
</ul>

<p><div class="rs-tip-major">Poznámka: jen pro zajímavost &ndash; existuje
dokonce i <a
href="https://lists.gnu.org/archive/html/bug-bash/2001-02/msg00054.html">assembler
implementovaný v&nbsp;BASHi</a>.</div></p>

*** image ***
<p><i>Obrázek 10: Někteří programátoři dokázali i v&nbsp;primitivním monitoru
naprogramovat rozsáhlé aplikace a to včetně her. V&nbsp;takovém případě se pro
ruční převod assembleru do strojového kódu používaly takovéto tabulky (i když
osobně znám člověka, který si dokázal zapamatovat kódy všech strojových
instrukcí i jejich variant).</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zajímavá lekce z&nbsp;minulosti: assemblery A1 a A2</h2>

<p>Bootstraping, který řeší problém cyklu ve vývojových nástrojích, se
používal, resp.&nbsp;musel použít i v&nbsp;minulosti. Důvodem byl fakt, že pro
první vyráběné mainframy bylo nutné nějakým způsobem vytvořit překladač či
alespoň assembler (později bylo samozřejmě možné provést cross překlad na jiné
platformě, ovšem někde se začít musí :-). Zcela první nástroj pro nový
mainframe byl vytvořen a přeložen ručně na papíře; následně byl výsledek
představovaný binárním kódem převeden na paměťové médium. Tento nástroj byl
značně primitivní, protože pouze dokázal převést několik jednoduchých instrukcí
do binárního kódu. Na platformě IBM 650 se tento nástroj jmenoval
<strong>A1</strong> (A od slova <i>assembler</i>). Následně byl v&nbsp;tomto
primitivním assembleru naprogramován složitější assembler nazvaný
<strong>A2</strong>, který již rozuměl celé instrukční sadě. V&nbsp;ještě
dalším kroku vznikl <strong>SAOP</strong> (<i>Symbolic Optimal Assembly
Program</i>), v&nbsp;němž se nakonec naprogramovaly další základní nástroje
&ndash; překladač, linker, loader programů, pomocné nástroje aj.</p>

*** image ***
<p><i>Obrázek 11: Klasické assemblery na osmibitových mikropočítačích již
vznikaly v&nbsp;jiném assembleru. Ovšem operační systém (nahraný do ROM)
typicky vznikal na minipočítačích, tj.&nbsp;nejednalo se o klasický
bootstraping.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Projekt Stage0</h2>

<p>Konečně se dostáváme k&nbsp;projektům, jejichž cílem je realizace
<i>bootstrapingu</i> překladače takovým způsobem, aby každý další krok mohl být
plně verifikovatelný znalým uživatelem. První z&nbsp;těchto projektů se jmenuje
<i>Stage0</i>. Informace o tomto projektu nalezneme na adrese <a
href="https://bootstrapping.miraheze.org/wiki/Stage0">https://bootstrapping.miraheze.org/wiki/Stage0</a>,
všechny zdrojové kódy i obrazy disket pak na GitHubu, konkrétně na adrese <a
href="https://github.com/oriansj/stage0">https://github.com/oriansj/stage0</a>.
V&nbsp;současné podobě není poslední fází bootstrapingu překladač céčka
(ostatně se jedná o one man show, takže nemůžeme čekat zázraky), ovšem namísto
toho dostane uživatel k&nbsp;dispozici interaktivní prostředí
s&nbsp;programovacím jazykem FORTH a taktéž interpret LISPu (resp.&nbsp;jednoho
z&nbsp;desítek či spíše stovek dialektů tohoto jazyka).</p>

<p>V&nbsp;rámci tohoto projektu vznikla i specifikace virtuálního stroje, nad
kterým jsou všechny nástroje implementovány. Ve skutečnosti se vlastně jedná o
definici <a
href="http://git.savannah.nongnu.org/cgit/stage0.git/tree/ISA_HEX_Map.org">instrukční
sady</a> (která se nijak nevymyká obvyklým instrukčním sadám registrových CPU,
ale autor se zde nemusel omezovat šířkou instrukcí ani snahou o čistý RISC), do
které je doplněno pět pseudoinstrukcí pro práci se zařízeními:
<strong>FOPEN_READ</strong>, <strong>FOPEN_WRITE</strong>,
<strong>FCLOSE</strong>, <strong>REWIND</strong> a <strong>SEEK</strong>. VM má
k&nbsp;dispozici tři zařízení, a to konzoli a dále pásku 1 a pásku 2 (což jsou
idealizovaná zařízení s&nbsp;nenáhodným přístupem).</p>

<p><div class="rs-tip-major">Poznámka: důležité je, že u každé instrukce je
přesně specifikován její formát v&nbsp;hexadecimálním tvaru (čtyři nebo šest
bajtů, tedy osm nebo dvanáct nibblů), protože nástroje na nulté a první úrovni
pracují pouze s&nbsp;hexadecimálně zapsanými instrukcemi.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Základní sada nástrojů vyvinutých v&nbsp;rámci projektu Stage0</h2>

<p>Již víme, že každý projekt pro bootstrap překladače musí obsahovat sadu
nástrojů, přičemž ty nejjednodušší nástroje slouží pro postupné vytváření
nástrojů složitějších a složitějších (ovšem i náležitě abstraktnějších).
Nejinak je tomu i v&nbsp;projektu <i>Stage0</i>. První nástroj se jmenuje
<strong>hex0</strong> a jedná se skutečně o dosti syrovou, ovšem snadno
verifikovatelnou aplikaci. Úkolem tohoto nástroje je načítat dvojice
hexadecimálních číslic a převádět je na bajty. Podporovány jsou i řádkové
komentáře začínající na # a ;. Všechny ostatní znaky by měly být ignorovány.
Například následující zdrojový kód představuje program, který po svém spuštění
pouze nastaví návratový kód a ukončí se. <strong>hex0</strong> zpracovává pouze
hexadecimální číslice, takže zápis instrukcí je zde pouze pro programátora:</p>

<pre>
48 c7 c0 3c 00 00 00  # mov $0x3c,%rax
48 c7 c7 00 00 00 00  # mov $0x0,%rdi
0f 05                 # syscall
</pre>

<p>V&nbsp;GNU Assembleru by tento program <a
href="https://github.com/tisnik/presentations/blob/master/assembler/01_gas_template/template_x86_64.s">mohl
vypadat takto</a>:</p>

<pre>
# Linux kernel system call table
sys_exit=60
&nbsp;
&nbsp;
&nbsp;
#-----------------------------------------------------------------------------
.section .data
&nbsp;
&nbsp;
&nbsp;
#-----------------------------------------------------------------------------
.section .bss
&nbsp;
&nbsp;
&nbsp;
#-----------------------------------------------------------------------------
.section .text
        .global _start          # tento symbol ma byt dostupny i linkeru
&nbsp;
_start:
        movl  $sys_exit,%eax    # cislo sycallu pro funkci "exit"
        movl  $0,%edi           # exit code = 0
        syscall                 # volani Linuxoveho kernelu
</pre>

<p>Následují nástroje nazvané <strong>hex1</strong> a <strong>hex2</strong>,
přičemž první z&nbsp;nich je pochopitelně implementován
v&nbsp;<strong>hex0</strong> a druhý v&nbsp;<strong>hex1</strong>. Tyto
nástroje přidávají jednu zásadní novinku &ndash; možnost zápisu symbolických
adres (formou návěští &ndash; <i>label</i>), protože ruční překlad instrukcí je
sice (s&nbsp;tabulkou) jednoduchý, ovšem výpočet relativních skoků, adres
proměnných atd. je již o mnoho pracnější. Příklad programu zapsaného
v&nbsp;<strong>hex2</strong>:</p>

<pre>
18020000                        # LOADe2 R0 R2 0
23010000                        # STORE32 R0 R1 0
&nbsp;
<strong>:Identify_Macros_1</strong>
18010000                        # LOAD32 R0 R1 0
A0300000                        # CMPSKIPI.NE R0 0
3C00 <strong>@Identify_Macros_Done</strong>      # JUMP @Identify_Macros_Done ; Be done
# ;; Otherwise keep looping
3C00 <strong>@Identify_Macros_0</strong>         # JUMP @Identify_Macros_0
<strong>:Identify_Macros_Done</strong>
# ;; Restore registers
0902803F        # POPR R3 R15
0902802F        # POPR R2 R15
0902801F        # POPR R1 R15
0902800F        # POPR R0 R15
0D01001F        # RET R15
&nbsp;
<strong>:Identify_Macros_string</strong>
444546494E450000        # "DEFINE"
</pre>

<p>Povšimněte si, že návěští začínají dvojtečkou (nástroj si musí adresu
zapamatovat) a relativní adresa se zapisuje přes zavináč. Podporovány jsou i
absolutní adresy zapisované přes znaky dolar a &amp;.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Další nástroje, které nalezneme v&nbsp;projektu Stage0</h2>

<p>Nástroj <strong>hex2</strong> poskytuje dostatečnou úroveň abstrakce pro
implementaci assembleru nazvaného <strong>m0</strong>, jehož zdrojový kód
můžete nalézt na adrese <a
href="http://git.savannah.nongnu.org/cgit/stage0.git/tree/stage1/M0-macro.hex2">http://git.savannah.nongnu.org/cgit/stage0.git/tree/stage1/M0-macro.hex2</a>.
S&nbsp;assemblerem se již dostáváme do známé oblasti a mohli bychom říci, že
klasický <i>bootstraping</i> by zde mohl skončit.</p>

<p>Autor však ještě doplnil další více či méně hodnotné nástroje. Především se
jedná o implementaci programovacího jazyka FORTH a taktéž o již výše zmíněný
interpret jazyka LISP. V&nbsp;současnosti se čeká na programátora šíleného do
takové míry, že by v&nbsp;<strong>m0</strong> nebo <strong>m1</strong>
naprogramoval překladač céčka, čímž by byl celý proces dokončen
(v&nbsp;repositáři sice existuje <strong>cc_x86.c</strong>, ale ve skutečnosti
to není plnohodnotný bootstrapovaný céčkový překladač).</p>

<p>Jednotlivé fáze, tak jak jsou v&nbsp;tomto projektu navrženy:</p>

<table>
<tr><th>Fáze</th><th>Nástroje</th></tr>
<tr><td>0</td><td><strong>hex0</strong></td></tr>
<tr><td>1</td><td><strong>hex1</strong>, <strong>hex2</strong>, <strong>m0</strong></td></tr>
<tr><td>2</td><td><strong>m0</strong>, implementace Forthu, LISPu a překladače C</td></tr>
<tr><td>3</td><td>Forth, LISP, ...</td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Projekt Bootstrap</h2>

<p>Podobnou cestou, i když s&nbsp;vyššími cíli, se vydal i autor toolchainu
nazvaného jednoznačně <i>Bootstrap</i>. Tento projekt naleznete na adrese <a
href="https://github.com/ras52/bootstrap">https://github.com/ras52/bootstrap</a>.
Autor Richard Smith navrhl rozdělit nástroje do jednotlivých fází bootstrapingu
následujícím způsobem:</p>

<table>
<tr><th>Fáze</th><th>Nástroje</th><th>Popis</th></tr>
<tr><td>0</td><td><strong>unhex</strong></td><td>odpovídá nástroji <strong>hex0</strong> ze Stage0</td></tr>
<tr><td>1</td><td><strong>unhexl</strong>, <strong>elfify</strong></td><td>odpovídá <strong>hex1/2</strong> + výstup do ELF</td></tr>
<tr><td>2</td><td><strong>as</strong></td><td>zjednodušený assembler, který nedokáže provádět skoky dopředu (jednoprůchodový)</td></tr>
<tr><td>3</td><td><strong>as</strong>, <strong>ld</strong></td><td>přepis assembleru do assembleru :-) a přidání linkeru</td></tr>
<tr><td>4</td><td>cc, crt0.o, libc.o</td><td>jednoduchý překladač jazyka podobného céčku (bez typů) + základní knihovny</td></tr>
<tr><td>5</td><td>ccx, cpp, cc, cmp</td><td>překladač céčka, preprocesor atd.</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: podrobnější popis jednotlivých nástrojů
si už nebudeme uvádět, protože princip je shodný &ndash; začít od primitivního
translátoru <i>hex &rarr; binary</i>, pokračovat směrem k&nbsp;jednoduchému
assembleru a poté již (ve dvou či třech fázích) k&nbsp;plnohodnotným
překladačům a knihovnám.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Projekt bcompiler</h2>

https://github.com/certik/bcompiler

<table>
<tr><th>Fáze</th><th>Nástroje</th></tr>
<tr><td>0</td><td></td></tr>
<tr><td>1</td><td></td></tr>
<tr><td>2</td><td></td></tr>
<tr><td>3</td><td></td></tr>
<tr><td>4</td><td></td></tr>
<tr><td>5</td><td></td></tr>
<tr><td>6</td><td></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Použití druhého překladače pro zjištění modifikovaného kódu</h2>

<p>Kromě překladače céčka patřícího do skupiny nástrojů GCC (i samotný překladač se jmenuje GCC &ndash; <i>GNU C Compiler</i>, což může být poněkud matoucí &ndash; je nutné vždy sledovat kontext, ve kterém se o GCC mluví či píše) je možné v&nbsp;operačním systému Linux použít i další překladače programovacího jazyka C. Mezi ně patří například <i>Clang</i> z&nbsp;projektu LLVM, jenž je zajímavý především po technologické stránce i z&nbsp;hlediska výpočetního výkonu výsledných binárních souborů. Dále se pak můžeme setkat s&nbsp;překladači komerčních firem, například překladačem vytvořeným společností Intel, který v&nbsp;případě některých typů optimalizací překonává GCC. V&nbsp;neposlední řadě je pak možné v&nbsp;Linuxu (a nutno říci, že nejenom v&nbsp;něm) použít překladač nazvaný <i>Tiny C Compiler</i> (<i>tcc</i>), jehož krátkým popisem a porovnáním s&nbsp;GCC se budeme zabývat v&nbsp;následující kapitole.</p>




<p><a name="k15"></a></p>
<h2 id="k15">15. Překladač <strong>tcc</strong></h2>

<p>Tiny C Compiler (tcc) je překladač programovacího jazyka C, který byl původně vytvořen Fabrice Bellardem a nyní se o jeho další vývoj a portaci na nové platformy stará komunita vývojářů, protože se samozřejmě jedná o open source projekt. Tiny C Compiler  kromě vlastního překladače v sobě obsahuje i linker, což znamená, že jeden binární program může sloužit jak pro překlad zdrojových textů (včetně preprocesingu) do objektového kódu, tak i pro vytvoření výsledného spustitelného binárního programu. Všechny tři zmíněné funkce jsou implementovány v jediném spustitelném souboru, jehož velikost na platformě x86 nepřesahuje sto kilobajtů, což je například v porovnání s GCC zcela zanedbatelná velikost (dokonce i pouze GNU assembler je v binární podobě větší, než celý tcc).</p>

<p>Tiny C Compiler podporuje standard C89/C90 i velkou část standardu C99, a to do té míry, že úpravy zdrojových kódů určených pro GCC většinou nejsou zapotřebí. Největší devizou překladače tcc je blesková rychlost překladu, protože vlastní překlad je jednoprůchodový. Na stránkách tohoto projektu se uvádí, že tcc je přibližně osmkrát rychlejší než překladač GCC (s použitím standardních voleb, tj. bez optimalizací), ovšem jak se můžete dozvědět z dalšího textu, může být tcc v extrémním případě rychlejší zhruba čtyřicetkrát (!). Na druhou stranu však tcc za většinou ostatních moderních překladačů céčka pokulhává v případě optimalizací prováděných při překladu.</p>

<p>Pro nás je ovšem v&nbsp;kontextu dnešního článku nejzajímavější fakt, že Tiny C Compiler lze úspěšně použít pro překlad GCC a naopak. Tím by se &ndash; alespoň teoreticky &ndash; mohl vyřešit problém, se kterým jsme se seznámili v&nbsp;předchozí kapitole.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Postačuje provést překlad <strong>gcc</strong> s&nbsp;využitím <strong>tcc</strong>?</h2>

<p>Mohlo by se zdát, že pokud použijeme pro překlad GNU C překladače (nebo libovolného jiného překladače, kterému v&nbsp;daný okamžik nedůvěřujeme) přímo <strong>tcc</strong>, byl problém důvěry vyřešen, protože nový binární soubor <strong>gcc</strong> sice bude relativně pomalý (Tiny C Compiler nedokáže provádět složitější optimalizace), ale jeho chování by mělo odpovídat jeho zdrojovým kódům. Ve skutečnosti tomu tam bohužel není, protože samotný <strong>tcc</strong> sice provede překlad, ovšem samotný překlad je jen součástí celého procesu vytvoření nového binárního souboru. Kromě toho se totiž používají další nástroje spouštěné například ze skriptu <strong>configure</strong>. A tyto nástroje bývají přeloženy právě (možná napadeným) překladačem <strong>gcc</strong>. Na druhou stranu ovšem <strong>tcc</strong> používá vlastní linker, takže jsme na tom paradoxně lépe, než při snaze o použití assembleru.</p>

<p>Co to znamená v&nbsp;praxi? Stále je nutné provést postup dvojí kompilace zmíněný <a href="#k14">ve čtrnácté kapitole</a>.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Alternativní cesta: jednoduché a verifikovatelné virtuální stroje</h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Forth</h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. TinyBASIC</h2>

<p>Zajímavě byl </p>

<p>Na základě článku Dennise Allisona vzniklo a vzápětí se i rozšířilo několik
různých implementací BASICu, které byly většinou nazvány (opět podle článku)
<i>Tiny BASIC</i>. Tyto implementace byly dostupné jak pro osmibitové
mikroprocesory firmy Intel, tak i pro procesor Motorola 6800 či MOS 6502, a to
buď zcela zdarma nebo pod de-facto symbolickou částkou pěti dolarů (tato částka
většinou zahrnovala i poštovné). Ovšem díky vzniku tolik žádoucí konkurence na
trhu s&nbsp;domácími osmibitovými počítači se firmy začaly přetahovat o
zákazníky, takže se snažily nabízet počítače již se základním programovým
vybavením (uloženým v&nbsp;naprosté většině případů přímo v&nbsp;ROM) a nejenom
skládačku typu počítače <i>Altair</i>, kde si uživatelé kromě ceny za počítač
(400 dolarů) většinou museli připlatit i již zmíněných 150 dolarů za interpret
programovacího jazyka.</p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Defending Against Compiler-Based Backdoors<br />
<a href="https://blog.regehr.org/archives/1241">https://blog.regehr.org/archives/1241</a>
</li>

<li>Reflections on Trusting Trust<br />
<a href="https://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html">https://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html</a>
</li>

<li>Coding Machines (povídka)<br />
<a href="https://www.teamten.com/lawrence/writings/coding-machines/">https://www.teamten.com/lawrence/writings/coding-machines/</a>
</li>

<li>Stage0<br />
<a href="https://bootstrapping.miraheze.org/wiki/Stage0">https://bootstrapping.miraheze.org/wiki/Stage0</a>
</li>

<li>Projekt stage0 na GitHubu<br />
<a href="https://github.com/oriansj/stage0">https://github.com/oriansj/stage0</a>
</li>

<li>Bootstraping wiki<br />
<a href="https://bootstrapping.miraheze.org/wiki/Main_Page">https://bootstrapping.miraheze.org/wiki/Main_Page</a>
</li>

<li>Bootstrapped 6502 Assembler<br />
<a href="https://github.com/robinluckey/bootstrap-6502">https://github.com/robinluckey/bootstrap-6502</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>run6502, lib6502 — 6502 microprocessor emulator<br />
<a href="http://piumarta.com/software/lib6502/">http://piumarta.com/software/lib6502/</a>
</li>

<li>Simple Computer Simulator Instruction-Set<br />
<a href="http://www.science.smith.edu/dftwiki/index.php/Simple_Computer_Simulator_Instruction-Set">http://www.science.smith.edu/dftwiki/index.php/Simple_Computer_Simulator_Instruction-Set</a>
</li>

<li>Bootstrapping#Computing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Bootstrapping#Computing">https://en.wikipedia.org/wiki/Bootstrapping#Computing</a>
</li>

<li>Bootstrapping (compilers)<br />
<a href="https://en.wikipedia.org/wiki/Bootstrapping_%28compilers%29">https://en.wikipedia.org/wiki/Bootstrapping_%28compilers%29</a>
</li>

<li>Bootstrapable Builds<br />
<a href="http://bootstrappable.org/">http://bootstrappable.org/</a>
</li>

<li>What is a coder's worst nightmare?<br />
<a href="https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute">https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute</a>
</li>

<li>Linux Assembly<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Tombstone diagram (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Tombstone_diagram">https://en.wikipedia.org/wiki/Tombstone_diagram</a>
</li>

<li>History of compiler construction (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_compiler_construction">https://en.wikipedia.org/wiki/History_of_compiler_construction</a>
</li>

<li>Self-hosting (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Self-hosting">https://en.wikipedia.org/wiki/Self-hosting</a>
</li>

<li>GNU Mes: Maxwell Equations of Software<br />
<a href="https://gitlab.com/janneke/mes">https://gitlab.com/janneke/mes</a>
</li>

<li>Tiny C Compiler<br />
<a href="https://bellard.org/tcc/">https://bellard.org/tcc/</a>
</li>

<li>Welcome to C--<br />
<a href="https://www.cs.tufts.edu/~nr/c--/index.html">https://www.cs.tufts.edu/~nr/c--/index.html</a>
</li>

<li>c4 - C in four functions<br />
<a href="https://github.com/rswier/c4">https://github.com/rswier/c4</a>
</li>

<li>Tiny BASIC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Tiny_BASIC">https://en.wikipedia.org/wiki/Tiny_BASIC</a>
</li>

<li>David A. Wheeler’s Page on Fully Countering Trusting Trust through Diverse Double-Compiling (DDC) - Countering Trojan Horse attacks on Compilers<br />
<a href="https://www.dwheeler.com/trusting-trust/">https://www.dwheeler.com/trusting-trust/</a>
</li>

<li>Reviewing Microsoft's Automatic Insertion of Telemetry into C++ Binaries<br />
<a href="https://www.infoq.com/news/2016/06/visual-cpp-telemetry">https://www.infoq.com/news/2016/06/visual-cpp-telemetry</a>
</li>

<li>Visual Studio adding telemetry function calls to binary?<br />
<a href="https://www.reddit.com/r/cpp/comments/4ibauu/visual_studio_adding_telemetry_function_calls_to/d30dmvu/">https://www.reddit.com/r/cpp/comments/4ibauu/visual_studio_adding_telemetry_function_calls_to/d30dmvu/</a>
</li>

<li>LWN - The Trojan Horse<br />
<a href="https://www.dwheeler.com/trusting-trust/spencer-19981123.txt">https://www.dwheeler.com/trusting-trust/spencer-19981123.txt</a>
</li>

<li>reproducible-builds.org<br />
<a href="https://reproducible-builds.org/">https://reproducible-builds.org/</a>
</li>

<li>Other Assemblers<br />
<a href="http://asm.sourceforge.net/howto/other.html">http://asm.sourceforge.net/howto/other.html</a>
</li>

<li>Projekt bootstrap<br />
<a href="https://github.com/ras52/bootstrap">https://github.com/ras52/bootstrap</a>
</li>

<li>Projekt bcompiler<br />
<a href="https://github.com/certik/bcompiler">https://github.com/certik/bcompiler</a>
</li>

<li>Zadní vrátka<br />
<a href="https://cs.wikipedia.org/wiki/Zadn%C3%AD_vr%C3%A1tka#Reflections_on_Trusting_Trust">https://cs.wikipedia.org/wiki/Zadn%C3%AD_vr%C3%A1tka#Reflections_on_Trusting_Trust</a>
</li>

<li>David A. Wheeler’s Personal Home Page<br />
<a href="https://www.dwheeler.com/">https://www.dwheeler.com/</a>
</li>

<li>David A. Wheeler<br />
<a href="https://en.wikipedia.org/wiki/David_A._Wheeler">https://en.wikipedia.org/wiki/David_A._Wheeler</a>
</li>

<li>Multics Security Evaluation: Vulnerability Analysis<br />
<a href="http://csrc.nist.gov/publications/history/karg74.pdf">http://csrc.nist.gov/publications/history/karg74.pdf</a>
</li>

<li>Reflections on Rusting Trust<br />
<a href="https://manishearth.github.io/blog/2016/12/02/reflections-on-rusting-trust/">https://manishearth.github.io/blog/2016/12/02/reflections-on-rusting-trust/</a>
</li>

<li>Reflections on Trusting Trust for Go (slajdy)<br />
<a href="https://www.slideshare.net/yeokm1/reflections-on-trusting-trust-for-go">https://www.slideshare.net/yeokm1/reflections-on-trusting-trust-for-go</a>
</li>

<li>Reflections on Trusting Trust for Go (zdrojové materiály)<br />
<a href="https://github.com/yeokm1/reflections-on-trusting-trust-go">https://github.com/yeokm1/reflections-on-trusting-trust-go</a>
</li>

<li>Reflections on Trusting Trust for Go - GopherConSG 2018<br />
<a href="https://www.youtube.com/watch?v=T82JttlJf60">https://www.youtube.com/watch?v=T82JttlJf60</a>
</li>

<li>Reproducing Go binaries byte-by-byte<br />
<a href="https://blog.filippo.io/reproducing-go-binaries-byte-by-byte/">https://blog.filippo.io/reproducing-go-binaries-byte-by-byte/</a>
</li>

<li>Trojský kůň<br />
<a href="https://cs.wikipedia.org/wiki/Trojsk%C3%BD_k%C5%AF%C5%88_%28program%29">https://cs.wikipedia.org/wiki/Trojsk%C3%BD_k%C5%AF%C5%88_%28program%29</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

