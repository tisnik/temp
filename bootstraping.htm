<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Můžeme věřit překladačům? Projekty řešící schéma "důvěřivé důvěry"</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Můžeme věřit překladačům? Projekty řešící schéma "důvěřivé důvěry"</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku se seznámíme s&nbsp;některými zajímavými projekty, které se snaží &ndash; každý svým způsobem &ndash; vyřešit schéma &bdquo;důvěřivé důvěry&ldquo;, přesněji řečeno problém, kdy máme věřit, že námi používaný překladač například neobsahuje sofistikovaného trojského koně.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Můžeme věřit překladačům? Projekty řešící schéma "důvěřivé důvěry"</a></p>
<p><a href="#k02">2. Klasický problém slepice-vejce</a></p>
<p><a href="#k03">3. Kam schovat zadní vrátka ve chvíli, kdy je zdrojový kód překladače k&nbsp;dispozici?</a></p>
<p><a href="#k04">4. Ukázka z&nbsp;povídky &bdquo;Coding Machines&ldquo;</a></p>
<p><a href="#k05">5. &bdquo;Cykly&ldquo; v&nbsp;použitých nástrojích</a></p>
<p><a href="#k06">*** 6. Možná řešení &bdquo;cyklu&ldquo; v&nbsp;použitých nástrojích</a></p>
<p><a href="#k07">7. Nástroje psané v&nbsp;assembleru</a></p>
<p><a href="#k08">*** 8. Zajímavá lekce z&nbsp;minulosti: assemblery A1 a A2</a></p>
<p><a href="#k09">*** 9. Projekt Stage0</a></p>
<p><a href="#k10">*** 10. Základní sada nástrojů vyvinutých v&nbsp;rámci projektu Stage0</a></p>
<p><a href="#k11">*** 11. Další nástroje, které nalezneme v&nbsp;projektu Stage0</a></p>
<p><a href="#k12">*** 12. Projekt Bootstrap</a></p>
<p><a href="#k13">*** 13. Projekt bcompiler</a></p>
<p><a href="#k14">*** 14. Použití druhého překladače pro zjištění modifikovaného kódu</a></p>
<p><a href="#k15">*** 15. Překladač <strong>tcc</strong></a></p>
<p><a href="#k16">*** 16. Postačuje provést překlad <strong>gcc</strong> s&nbsp;využitím <strong>tcc</strong>?</a></p>
<p><a href="#k17">*** 17. Alternativní cesta: jednoduché a verifikovatelné virtuální stroje</a></p>
<p><a href="#k18">*** 18. Forth</a></p>
<p><a href="#k19">*** 19. TinyBASIC</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Můžeme věřit překladačům? Projekty řešící schéma "důvěřivé důvěry"</h2>

<p></p>

*** image ***
<p><i>Obrázek 1: Idylická situace &ndash; překladač přesně přeloží náš zdrojový
kód a výsledná binární podoba aplikace dělá přesně to, co bylo ve zdrojovém
kódu napsáno.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Klasický problém slepice-vejce</h2>

<p><i>"Recipe for yogurt: Add yogurt to milk." - Anon.</i></p>

<p>Jádro celého problému důvěryhodnosti nebo nedůvěryhodnosti překladače
spočívá v&nbsp;tom, že existuje způsob jak zajistit, aby se &bdquo;čisté&ldquo;
zdrojové kódy, které při kontrole programátorem evidentně žádná zadní vrátka
neobsahují, přeložily do spustitelného binárního kódu popř.&nbsp;do staticky
nebo dynamicky linkované knihovny, kde už ovšem zadní vrátka být mohou. Běžní
programátoři totiž (mj.&nbsp;i z&nbsp;časových důvodů) podrobně nezkoumají
výsledek překladu, tj.&nbsp;relativně špatně rozluštitelný strojový kód, navíc
kombinovaný s&nbsp;daty atd. Navíc &ndash; pokud už nevěříme použitému
překladači, jak můžeme vědět, že ve výsledném binárním souboru budou správné
ladicí informace? Překladač totiž může poměrně snadno do strojového kódu přidat
instrukce, které nebudou mapovány na žádný zdrojový řádek. Koncept podobného
útoku byl rozpracován již v&nbsp;roce 1974 ve zprávě <a
href="http://csrc.nist.gov/publications/history/karg74.pdf">Multics Security
Evaluation: Vulnerability Analysis</a>.</p>

*** image ***
<p><i>Obrázek 2: Pokud je překladač z&nbsp;nějakého důvodu upraven, může
produkovat binární kód, který (možná) odpovídá zdrojovému kódu, ale taktéž může
obsahovat nějaká zadní vrátka (nebo obecně trojského koně).</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Kam schovat zadní vrátka ve chvíli, kdy je zdrojový kód překladače k&nbsp;dispozici?</h2>

<p>Mohlo by se zdát, že pokud jsme v&nbsp;situaci, kdy máme k&nbsp;dispozici
zdrojový kód překladače (například překladače céčka z&nbsp;projektu GCC), máme
vyhráno, protože můžeme libovolně dlouho a s&nbsp;vynaložením libovolně
vysokých finančních prostředků analyzovat zdrojové kódy překladače a ověřit si
tak, že žádná zadní vrátka neobsahuje. Navíc můžeme tento zdrojový kód přeložit
a získat tak druhou binární kopii GCC, která bude bezpečná a verifikovaná (však
také vznikla překladem z&nbsp;verifikovaných zdrojových kódů ne?):</p>

*** image ***
<p><i>Obrázek 3: Ve chvíli, kdy není překladač nijak napaden, vznikne překladem
jeho vlastních zdrojových kódů opět &bdquo;čistý&ldquo; (nenapadený) překladač.
Pokud se jedná stále o stejnou verzi, měly by být binární obrazy totožné
(předpokládáme použití stejných přepínačů, shodnou architekturu, žádná časová
razítka atd.).</i></p>

<p>Ve skutečnosti však může být situace mnohem horší, protože napadený
překladač může být upraven tak sofistikovaně, že pozná, že překládá sám sebe a
vloží do výsledného binárního kódu příslušnou část <i>pro generování trojského
koně</i> ve chvíli, kdy bude nový překladač použit:</p>

*** image ***
<p><i>Obrázek 4: Ve chvíli, kdy nemůžeme důvěřovat binárnímu kódu překladače,
není vůbec jisté, co vznikne překladem čistých zdrojových kódů.
V&nbsp;nejhorším případě musíme předpokládat, že získáme opět napadený
překladač!</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Ukázka provedená Thompsonem</h2>

<p>Že je takový útok prakticky možný ukázal už Ken Thompson a po něm mnozí
další. Ve známých případech se většinou jednalo o akademické práce, které měly
Thompsonovu teorii dokázat s&nbsp;využitím různých programovacích jazyků
(typicky se jednalo o C, Scheme, z&nbsp;poslední doby je například článek <a
href="https://manishearth.github.io/blog/2016/12/02/reflections-on-rusting-trust/">Reflections
on Rusting Trust</a> popř.&nbsp;<a
href="https://www.slideshare.net/yeokm1/reflections-on-trusting-trust-for-go">Reflections
on Trusting Trust for Go</a>) apod. Zajímavá (ovšem zdrojovými kódy nedoložená)
je také historka prezentovaná v&nbsp;článečku <a
href="https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute">What
is a coder's worst nightmare?</a>. Skutečnými útoky tohoto typu se
pravděpodobně nikdo nechlubí (ani útočník, ani oběť), ale víme například o viru
The W32/Induc-A virus určený pro programy psané v&nbsp;Delphi popř.&nbsp;o
Xcodeghost (napadený překladač Xcode).</p>

<p>Podívejme se nyní na známou ukázku <a
href="https://en.wikipedia.org/wiki/Ken_Thompson">Kena Thompsona</a>. Ukázka
platí pro programovací jazyk C, ale lze ji samozřejmě aplikovat na prakticky
jakýkoli jiný překladač.</p>

<p>První fáze spočívá v&nbsp;úpravě zdrojových kódů překladače a vložení dvou
nových funkcí:</p>

<ol>

<li>Pokud překladač pozná, že se překládá běžná aplikace, vloží do ní zadní
vrátka (například si otevře nějaký port, na kterém bude aplikace
poslouchat).</li>

<li>Pokud překladač pozná, že překládá sám sebe, zajistí, aby se v&nbsp;nové
binární podobě překladače objevil kód z&nbsp;bodu číslo 1.</li>

</ol>

*** image ***
<p><i>Obrázek 5: První fáze popsaná v&nbsp;předchozím textu.</i></p>

<p>Nyní jsme tedy v&nbsp;situaci, kdy se napadený překladač dokáže sám šířit
<i>nezávisle na tom, že vstupní zdrojové kódy jsou verifikovány</i>:</p>

*** image ***
<p><i>Obrázek 6: Situace, ve které máme překladač, který ze svého
&bdquo;čistého&ldquo; zdrojového kódu vygeneruje napadený binární podobu
překladače.</i></p>

<p>Důležité je, aby útočníkem upravené zdrojové kódy nebyly nikde
distribuovány. Postačuje pouze jednou (na začátku) rozšířit napadený překladač,
který (při vhodném naprogramování) může zadní vrátka šířit libovolně
dlouho:</p>

*** image ***
<p><i>Obrázek 7: Takto musí celou situaci vidět zbytek světa nebo alespoň oběť
útoku.</i></p>

<p><div class="rs-tip-major">Poznámka: výše uvedený postup musí útočník dodržet
v&nbsp;případě, že uživatel má přístup ke zdrojovým kódům překladače. Pokud
tomu tak není, je situace samozřejmě mnohem jednodušší. Náznak případných
problémů (v&nbsp;tomto konkrétním případě trošku zveličených) <a
href="https://www.infoq.com/news/2016/06/visual-cpp-telemetry">naleznete
například zde</a> a reakci <a
href="https://www.reddit.com/r/cpp/comments/4ibauu/visual_studio_adding_telemetry_function_calls_to/d30dmvu/">zde</a>.</div></p>

<p><div class="rs-tip-major">Poznámka 2: na druhou stranu je nutné poznamenat,
že už jsme se poučili, že ani otevřené zdrojové kódy <a
href="http://opensource.apple.com/source/Security/Security-55471/libsecurity_ssl/lib/sslKeyExchange.c">nemusí
zaručit bezpečnost</a>:</div></p>

<pre>
    if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != 0)
        goto fail;
        goto fail;
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Ukázka z&nbsp;povídky &bdquo;Coding Machines&ldquo;</h2>

<p>Následuje ukázka z&nbsp;krátké povídky &bdquo;Coding Machines&ldquo;, kterou
si můžete celou přečíst na stránce <a
href="https://www.teamten.com/lawrence/writings/coding-machines/">https://www.teamten.com/lawrence/writings/coding-machines/</a>.
Povídka je založena na podobném konceptu, jaký byl naznačen výše:</p>

<p>“It’s just so odd that the C source would be clean but the assembly have these weird op-codes,” I said.</p>

<p>“I thought you had tracked it down to the compiler,” said Dave.</p>

<p>“I don’t mean in your code, I mean in the compiler itself.”</p>

<p>“The compiler could be responsible for that too.”</p>

<p>“No, I checked the code.”</p>

<p>“But the code is compiled by the compiler.”</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. &bdquo;Cykly&ldquo; v&nbsp;použitých nástrojích</h2>

<p>Jeden z&nbsp;důvodů, proč může být podvržení překladače navržené Kenem
Thompsonem úspěšné, spočívá v&nbsp;tom, že mnoho v&nbsp;současnosti používaných
&bdquo;toolchainů&ldquo; obsahuje cyklus, tj.&nbsp;nějaký nástroj (typicky
právě překladač) je použit pro překlad sama sebe. Cyklus může být ovšem i
nepřímý, protože například prakticky všechny nástroje GCC jsou psány
v&nbsp;céčku a pro překlad céčka jsou zapotřebí právě tyto nástroje :-)</p>

*** image ***
<p><i>Obrázek 8: Některé (skutečně jen některé) nástroje použité pro překlad
céčkovských zdrojových kódů.</i></p>

<p>Znalost cyklu v&nbsp;toolchainu je důležitá: útočník například bude vědět,
že potenciální oběť používá dva různé překladače (řekněme GCC a LLVM), takže by
mohla napadení jednoho z&nbsp;těchto překladačů odhalit, například způsobem
naznačeným v&nbsp;dalších kapitolách. Ovšem překladač samozřejmě není jedinou
součástí toolchainu, protože lze napadnout například assembler (pokud se volá),
linker, nástroj <strong>ar</strong> apod. A ve chvíli, kdy jsou tyto nástroje
použity oběma překladači, problém stále přetrvává, i když je nutné poznamenat,
že úprava překladače je potenciálně nejjednodušší, protože tento nástroj má
nejvíce informací o kódu, který má pozměnit.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Možná řešení &bdquo;cyklu&ldquo; v&nbsp;použitých nástrojích</h2>

<p></p>

*** image ***
<p><i>Obrázek 9: Strohé uživatelské rozhraní monitoru pro československé
mikropočítače PMD-85. Kdo říká, že minimalismus je &bdquo;in&ldquo; až
v&nbsp;současnosti?</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Nástroje psané v&nbsp;assembleru</h2>

<p>Jen malá poznámka <a href="#k06">k&nbsp;předchozí kapitole</a>. Mohlo by se
zdát, že pokud si dáme tu práci a vytvoříme sadu základních nástrojů přímo
v&nbsp;assembleru, bude problém &bdquo;důvěřivé důvěry&ldquo; spolehlivě
vyřešen. Ovšem ve skutečnosti je většina v&nbsp;současnosti používaných
assemblerů (minimálně těch určených pro PC a Linux) naprogramována právě
v&nbsp;programovacím jazyku C nebo C++, takže problém ve skutečnosti přetrvává
(bylo by ovšem zajímavé zjistit, zda už někdo provedl úpravu céčka tak, aby byl
napaden jím překládaný assembler). Můžeme se ostatně podívat na zdrojové kódy
dvou známých assemblerů &ndash; <a
href="https://mojefedora.cz/pouziti-assembleru-v-linuxu/#k05">GNU
Assembleru</a> i <a
href="https://mojefedora.cz/pouziti-assembleru-v-linuxu/#k06">NASMu (Netwide
Assembleru)</a>:</p>

<ul>
<ol><a href="https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;a=tree;f=gas;h=bc1ca0cf8ffb1415090f3ca87441b30e8ec25621;hb=HEAD">všechny zdrojové kódy GNU Assembleru</a></ol>
<ol><a href="https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;a=blob_plain;f=gas/as.c;hb=HEAD">soubor <strong>as.c</strong></a></ol>
<ol><a href="http://repo.or.cz/nasm.git/tree/HEAD:/asm">zdrojové kódy NASMu</a></ol>
</ul>

<p><div class="rs-tip-major">Poznámka: jen pro zajímavost &ndash; existuje
dokonce i <a
href="https://lists.gnu.org/archive/html/bug-bash/2001-02/msg00054.html">assembler
implementovaný v&nbsp;BASHi</a>.</div></p>

*** image ***
<p><i>Obrázek 10: Někteří programátoři dokázali i v&nbsp;primitivním monitoru
naprogramovat rozsáhlé aplikace a to včetně her. V&nbsp;takovém případě se pro
ruční převod assembleru do strojového kódu používaly takovéto tabulky (i když
osobně znám člověka, který si dokázal zapamatovat kódy všech strojových
instrukcí i jejich variant).</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zajímavá lekce z&nbsp;minulosti: assemblery A1 a A2</h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. Projekt Stage0</h2>

<p>Konečně se dostáváme k&nbsp;projektům, jejichž cílem je realizace bootstrapingu překladače takovým způsobem, aby každý další krok mohl být plně verifikovatelný znalým uživatelem.</p>


<p><a name="k10"></a></p>
<h2 id="k10">10. Základní sada nástrojů vyvinutých v&nbsp;rámci projektu Stage0</h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. Další nástroje, které nalezneme v&nbsp;projektu Stage0</h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. Projekt Bootstrap</h2>

https://github.com/ras52/bootstrap

<table>
<tr><th>Fáze</th><th>Nástroje</th></tr>
<tr><td>0</td><td>unhex</td></tr>
<tr><td>1</td><td>unhexl, elfify</td></tr>
<tr><td>2</td><td>as</td></tr>
<tr><td>3</td><td>as, ld</td></tr>
<tr><td>4</td><td>cc, crt0.o, libc.o</td></tr>
<tr><td>5</td><td>ccx, cpp, cc, cmp</td></tr>
</table>


<p><a name="k13"></a></p>
<h2 id="k13">13. Projekt bcompiler</h2>

https://github.com/certik/bcompiler

<table>
<tr><th>Fáze</th><th>Nástroje</th></tr>
<tr><td>0</td><td></td></tr>
<tr><td>1</td><td></td></tr>
<tr><td>2</td><td></td></tr>
<tr><td>3</td><td></td></tr>
<tr><td>4</td><td></td></tr>
<tr><td>5</td><td></td></tr>
<tr><td>6</td><td></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Použití druhého překladače pro zjištění modifikovaného kódu</h2>

<p>Kromě překladače céčka patřícího do skupiny nástrojů GCC (i samotný překladač se jmenuje GCC &ndash; <i>GNU C Compiler</i>, což může být poněkud matoucí &ndash; je nutné vždy sledovat kontext, ve kterém se o GCC mluví či píše) je možné v&nbsp;operačním systému Linux použít i další překladače programovacího jazyka C. Mezi ně patří například <i>Clang</i> z&nbsp;projektu LLVM, jenž je zajímavý především po technologické stránce i z&nbsp;hlediska výpočetního výkonu výsledných binárních souborů. Dále se pak můžeme setkat s&nbsp;překladači komerčních firem, například překladačem vytvořeným společností Intel, který v&nbsp;případě některých typů optimalizací překonává GCC. V&nbsp;neposlední řadě je pak možné v&nbsp;Linuxu (a nutno říci, že nejenom v&nbsp;něm) použít překladač nazvaný <i>Tiny C Compiler</i> (<i>tcc</i>), jehož krátkým popisem a porovnáním s&nbsp;GCC se budeme zabývat v&nbsp;následující kapitole.</p>




<p><a name="k15"></a></p>
<h2 id="k15">15. Překladač <strong>tcc</strong></h2>

<p>Tiny C Compiler (tcc) je překladač programovacího jazyka C, který byl původně vytvořen Fabrice Bellardem a nyní se o jeho další vývoj a portaci na nové platformy stará komunita vývojářů, protože se samozřejmě jedná o open source projekt. Tiny C Compiler  kromě vlastního překladače v sobě obsahuje i linker, což znamená, že jeden binární program může sloužit jak pro překlad zdrojových textů (včetně preprocesingu) do objektového kódu, tak i pro vytvoření výsledného spustitelného binárního programu. Všechny tři zmíněné funkce jsou implementovány v jediném spustitelném souboru, jehož velikost na platformě x86 nepřesahuje sto kilobajtů, což je například v porovnání s GCC zcela zanedbatelná velikost (dokonce i pouze GNU assembler je v binární podobě větší, než celý tcc).</p>

<p>Tiny C Compiler podporuje standard C89/C90 i velkou část standardu C99, a to do té míry, že úpravy zdrojových kódů určených pro GCC většinou nejsou zapotřebí. Největší devizou překladače tcc je blesková rychlost překladu, protože vlastní překlad je jednoprůchodový. Na stránkách tohoto projektu se uvádí, že tcc je přibližně osmkrát rychlejší než překladač GCC (s použitím standardních voleb, tj. bez optimalizací), ovšem jak se můžete dozvědět z dalšího textu, může být tcc v extrémním případě rychlejší zhruba čtyřicetkrát (!). Na druhou stranu však tcc za většinou ostatních moderních překladačů céčka pokulhává v případě optimalizací prováděných při překladu.</p>

<p>Pro nás je ovšem v&nbsp;kontextu dnešního článku nejzajímavější fakt, že Tiny C Compiler lze úspěšně použít pro překlad GCC a naopak. Tím by se &ndash; alespoň teoreticky &ndash; mohl vyřešit problém, se kterým jsme se seznámili v&nbsp;předchozí kapitole.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Postačuje provést překlad <strong>gcc</strong> s&nbsp;využitím <strong>tcc</strong>?</h2>

<p>Mohlo by se zdát, že pokud použijeme pro překlad GNU C překladače (nebo libovolného jiného překladače, kterému v&nbsp;daný okamžik nedůvěřujeme) přímo <strong>tcc</strong>, byl problém důvěry vyřešen, protože nový binární soubor <strong>gcc</strong> sice bude relativně pomalý (Tiny C Compiler nedokáže provádět složitější optimalizace), ale jeho chování by mělo odpovídat jeho zdrojovým kódům. Ve skutečnosti tomu tam bohužel není, protože samotný <strong>tcc</strong> sice provede překlad, ovšem samotný překlad je jen součástí celého procesu vytvoření nového binárního souboru. Kromě toho se totiž používají další nástroje spouštěné například ze skriptu <strong>configure</strong>. A tyto nástroje bývají přeloženy právě (možná napadeným) překladačem <strong>gcc</strong>. Na druhou stranu ovšem <strong>tcc</strong> používá vlastní linker, takže jsme na tom paradoxně lépe, než při snaze o použití assembleru.</p>

<p>Co to znamená v&nbsp;praxi? Stále je nutné provést postup dvojí kompilace zmíněný <a href="#k14">ve čtrnácté kapitole</a>.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Alternativní cesta: jednoduché a verifikovatelné virtuální stroje</h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Forth</h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. TinyBASIC</h2>

<p>Zajímavě byl </p>

<p>Na základě článku Dennise Allisona vzniklo a vzápětí se i rozšířilo několik
různých implementací BASICu, které byly většinou nazvány (opět podle článku)
<i>Tiny BASIC</i>. Tyto implementace byly dostupné jak pro osmibitové
mikroprocesory firmy Intel, tak i pro procesor Motorola 6800 či MOS 6502, a to
buď zcela zdarma nebo pod de-facto symbolickou částkou pěti dolarů (tato částka
většinou zahrnovala i poštovné). Ovšem díky vzniku tolik žádoucí konkurence na
trhu s&nbsp;domácími osmibitovými počítači se firmy začaly přetahovat o
zákazníky, takže se snažily nabízet počítače již se základním programovým
vybavením (uloženým v&nbsp;naprosté většině případů přímo v&nbsp;ROM) a nejenom
skládačku typu počítače <i>Altair</i>, kde si uživatelé kromě ceny za počítač
(400 dolarů) většinou museli připlatit i již zmíněných 150 dolarů za interpret
programovacího jazyka.</p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Defending Against Compiler-Based Backdoors<br />
<a href="https://blog.regehr.org/archives/1241">https://blog.regehr.org/archives/1241</a>
</li>

<li>Reflections on Trusting Trust<br />
<a href="https://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html">https://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html</a>
</li>

<li>Coding Machines (povídka)<br />
<a href="https://www.teamten.com/lawrence/writings/coding-machines/">https://www.teamten.com/lawrence/writings/coding-machines/</a>
</li>

<li>Stage0<br />
<a href="https://bootstrapping.miraheze.org/wiki/Stage0">https://bootstrapping.miraheze.org/wiki/Stage0</a>
</li>

<li>Projekt stage0 na GitHubu<br />
<a href="https://github.com/oriansj/stage0">https://github.com/oriansj/stage0</a>
</li>

<li>Bootstraping wiki<br />
<a href="https://bootstrapping.miraheze.org/wiki/Main_Page">https://bootstrapping.miraheze.org/wiki/Main_Page</a>
</li>

<li>Bootstrapped 6502 Assembler<br />
<a href="https://github.com/robinluckey/bootstrap-6502">https://github.com/robinluckey/bootstrap-6502</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>run6502, lib6502 — 6502 microprocessor emulator<br />
<a href="http://piumarta.com/software/lib6502/">http://piumarta.com/software/lib6502/</a>
</li>

<li>Simple Computer Simulator Instruction-Set<br />
<a href="http://www.science.smith.edu/dftwiki/index.php/Simple_Computer_Simulator_Instruction-Set">http://www.science.smith.edu/dftwiki/index.php/Simple_Computer_Simulator_Instruction-Set</a>
</li>

<li>Bootstrapping#Computing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Bootstrapping#Computing">https://en.wikipedia.org/wiki/Bootstrapping#Computing</a>
</li>

<li>Bootstrapping (compilers)<br />
<a href="https://en.wikipedia.org/wiki/Bootstrapping_%28compilers%29">https://en.wikipedia.org/wiki/Bootstrapping_%28compilers%29</a>
</li>

<li>Bootstrapable Builds<br />
<a href="http://bootstrappable.org/">http://bootstrappable.org/</a>
</li>

<li>What is a coder's worst nightmare?<br />
<a href="https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute">https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute</a>
</li>

<li>Linux Assembly<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Tombstone diagram (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Tombstone_diagram">https://en.wikipedia.org/wiki/Tombstone_diagram</a>
</li>

<li>History of compiler construction (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_compiler_construction">https://en.wikipedia.org/wiki/History_of_compiler_construction</a>
</li>

<li>Self-hosting (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Self-hosting">https://en.wikipedia.org/wiki/Self-hosting</a>
</li>

<li>GNU Mes: Maxwell Equations of Software<br />
<a href="https://gitlab.com/janneke/mes">https://gitlab.com/janneke/mes</a>
</li>

<li>Tiny C Compiler<br />
<a href="https://bellard.org/tcc/">https://bellard.org/tcc/</a>
</li>

<li>Welcome to C--<br />
<a href="https://www.cs.tufts.edu/~nr/c--/index.html">https://www.cs.tufts.edu/~nr/c--/index.html</a>
</li>

<li>c4 - C in four functions<br />
<a href="https://github.com/rswier/c4">https://github.com/rswier/c4</a>
</li>

<li>Tiny BASIC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Tiny_BASIC">https://en.wikipedia.org/wiki/Tiny_BASIC</a>
</li>

<li>David A. Wheeler’s Page on Fully Countering Trusting Trust through Diverse Double-Compiling (DDC) - Countering Trojan Horse attacks on Compilers<br />
<a href="https://www.dwheeler.com/trusting-trust/">https://www.dwheeler.com/trusting-trust/</a>
</li>

<li>Reviewing Microsoft's Automatic Insertion of Telemetry into C++ Binaries<br />
<a href="https://www.infoq.com/news/2016/06/visual-cpp-telemetry">https://www.infoq.com/news/2016/06/visual-cpp-telemetry</a>
</li>

<li>Visual Studio adding telemetry function calls to binary?<br />
<a href="https://www.reddit.com/r/cpp/comments/4ibauu/visual_studio_adding_telemetry_function_calls_to/d30dmvu/">https://www.reddit.com/r/cpp/comments/4ibauu/visual_studio_adding_telemetry_function_calls_to/d30dmvu/</a>
</li>

<li>LWN - The Trojan Horse<br />
<a href="https://www.dwheeler.com/trusting-trust/spencer-19981123.txt">https://www.dwheeler.com/trusting-trust/spencer-19981123.txt</a>
</li>

<li>reproducible-builds.org<br />
<a href="https://reproducible-builds.org/">https://reproducible-builds.org/</a>
</li>

<li>Other Assemblers<br />
<a href="http://asm.sourceforge.net/howto/other.html">http://asm.sourceforge.net/howto/other.html</a>
</li>

<li>Projekt bootstrap<br />
<a href="https://github.com/ras52/bootstrap">https://github.com/ras52/bootstrap</a>
</li>

<li>Projekt bcompiler<br />
<a href="https://github.com/certik/bcompiler">https://github.com/certik/bcompiler</a>
</li>

<li>Zadní vrátka<br />
<a href="https://cs.wikipedia.org/wiki/Zadn%C3%AD_vr%C3%A1tka#Reflections_on_Trusting_Trust">https://cs.wikipedia.org/wiki/Zadn%C3%AD_vr%C3%A1tka#Reflections_on_Trusting_Trust</a>
</li>

<li>David A. Wheeler’s Personal Home Page<br />
<a href="https://www.dwheeler.com/">https://www.dwheeler.com/</a>
</li>

<li>David A. Wheeler<br />
<a href="https://en.wikipedia.org/wiki/David_A._Wheeler">https://en.wikipedia.org/wiki/David_A._Wheeler</a>
</li>

<li>Multics Security Evaluation: Vulnerability Analysis<br />
<a href="http://csrc.nist.gov/publications/history/karg74.pdf">http://csrc.nist.gov/publications/history/karg74.pdf</a>
</li>

<li>Reflections on Rusting Trust<br />
<a href="https://manishearth.github.io/blog/2016/12/02/reflections-on-rusting-trust/">https://manishearth.github.io/blog/2016/12/02/reflections-on-rusting-trust/</a>
</li>

<li>Reflections on Trusting Trust for Go (slajdy)<br />
<a href="https://www.slideshare.net/yeokm1/reflections-on-trusting-trust-for-go">https://www.slideshare.net/yeokm1/reflections-on-trusting-trust-for-go</a>
</li>

<li>Reflections on Trusting Trust for Go (zdrojové materiály)<br />
<a href="https://github.com/yeokm1/reflections-on-trusting-trust-go">https://github.com/yeokm1/reflections-on-trusting-trust-go</a>
</li>

<li>Reflections on Trusting Trust for Go - GopherConSG 2018<br />
<a href="https://www.youtube.com/watch?v=T82JttlJf60">https://www.youtube.com/watch?v=T82JttlJf60</a>
</li>

<li>Reproducing Go binaries byte-by-byte<br />
<a href="https://blog.filippo.io/reproducing-go-binaries-byte-by-byte/">https://blog.filippo.io/reproducing-go-binaries-byte-by-byte/</a>
</li>

<li>Trojský kůň<br />
<a href="https://cs.wikipedia.org/wiki/Trojsk%C3%BD_k%C5%AF%C5%88_%28program%29">https://cs.wikipedia.org/wiki/Trojsk%C3%BD_k%C5%AF%C5%88_%28program%29</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

