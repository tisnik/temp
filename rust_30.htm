<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Rust: použití FFI při předávání struktur</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Rust: použití FFI při předávání struktur</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Při popisu FFI (Foreign Function Interface) jsme si již řekli, jakým způsobem je možné do nativní céčkové knihovny předávat primitivní datové typy, řetězce i pole. Ještě nám však zbývá si popsat způsob předávání struktur (struct), a to jak hodnotou, tak i odkazem.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Předávání struktur mezi Rustem a céčkovou knihovnou</a></p>
<p><a href="#k02">2. Vytvoření nového projektu</a></p>
<p><a href="#k03">3. Céčková část příkladu &ndash; definice struktury a funkce akceptující tuto strukturu</a></p>
<p><a href="#k04">4. Volání céčkové funkce z&nbsp;Rustu s&nbsp;předáním struktury</a></p>
<p><a href="#k05">5. Překlad a spuštění prvního příkladu</a></p>
<p><a href="#k06">6. Problematika zarovnání prvků ve struktuře a &bdquo;výplní&ldquo; mezi prvky</a></p>
<p><a href="#k07">7. Změna pořadí prvků struktury</a></p>
<p><a href="#k08">8. Překlad a spuštění druhého příkladu</a></p>
<p><a href="#k09">9. Export binární podoby struktury</a></p>
<p><a href="#k10">10. Předání struktury odkazem (přes ukazatel)</a></p>
<p><a href="#k11">11. Céčková část aplikace</a></p>
<p><a href="#k12">12. Část aplikace naprogramovaná v&nbsp;Rustu</a></p>
<p><a href="#k13">13. Ukazatel versus reference</a></p>
<p><a href="#k14">14. Modifikace prvků struktury v&nbsp;nativním kódu</a></p>
<p><a href="#k15">15. Rustovská část</a></p>
<p><a href="#k16">16. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k17">17. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Předávání struktur mezi Rustem a céčkovou knihovnou</h2>

<p>V&nbsp;programovacím jazyku C je možné používat primitivní numerické datové
typy, ukazatele, homogenní datovou strukturu (neboli pole), unie, bitová pole a
taktéž <a
href="https://cs.wikipedia.org/wiki/Z%C3%A1znam_%28informatika%29">záznamy</a>,
které jsou v&nbsp;céčku pojmenovány <strong>struct</strong>, takže se jim běžně
říká i struktury. Tyto složené datové typy jsou podporovány i Rustem, takže
vzniká zcela logická otázka, do jaké míry je možné při komunikaci mezi céčkem a
Rustem záznamy/struktury používat. Ve skutečnosti je tato operace podporována a
je velmi často používána &ndash; záznamy je možné předávat jak hodnotou, tak i
odkazem (neboli přes ukazatel). Dnes si ukážeme některá úskalí použití záznamů,
protože při komunikaci mezi Rustem a C je samozřejmě nutné zaručit, že se budou
používat shodné typy prvků, stejný způsob zarovnání prvků atd.</p>

<p>Poznámka: komunikace s&nbsp;využitím bitových polí a unií je složitější a
setkáme se s&nbsp;ní méně často.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vytvoření nového projektu</h2>

<p>Podobně jako minule, i dnes budeme používat pro správu projektů (překlad,
slinkování, spuštění, otestování) nástroj Cargo. Zkusme si nejprve vytvořit
prázdný projekt spravovaný systémem Cargo. Projekt bude sloužit
k&nbsp;vytvoření spustitelné binární aplikace a proto musíme použít přepínač
<strong>--bin</strong>:</p>

<pre>
$ <strong>cargo new --bin ffi_project1</strong>
</pre>

<p>Po spuštění předchozího příkazu získáme následující adresářovou strukturu
projektu:</p>

<pre>
.
├── Cargo.toml
└── src
    └── main.rs
</pre>

<p>Do projektu přidáme soubor <strong>build.rs</strong>:</p>

<pre>
// balicek gcc zajisti preklad a vytvoreni knihovny za nas
extern crate gcc;
&nbsp;
fn main() {
    // preklad a vytvoreni knihovny
    gcc::compile_library("libffi3.a", &gt;["src/ffi3.c"]);
}
</pre>

<p>Projektový soubor nepatrně upravíme:</p>

<pre>
[package]
name = "ffi_project3"
version = "0.1.0"
authors = ["Pavel Tisnovsky &lt;ptisnovs@redhat.com&gt;"]
build = "build.rs"
&nbsp;
[dependencies]
&nbsp;
[build-dependencies]
gcc = "0.3"
</pre>

<p>A přidáme (příkazem <strong>touch</strong>) prázdný zdrojový soubor psaný
v&nbsp;céčku:</p>

<pre>
$ <strong>touch src/ffi3.c</strong>
</pre>

<p>Výsledkem by měla být tato adresářová struktura:</p>

<pre>
.
├── build.rs
├── Cargo.lock
├── Cargo.toml
└── src
    ├── ffi3.c
    └── main.rs
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Céčková část příkladu &ndash; definice struktury a funkce akceptující tuto strukturu</h2>

<p>Podívejme se nejprve na céčkovou část celého projektu, protože zde by
programátory nemělo prakticky nic překvapit :-). Nejprve definujeme strukturu
s&nbsp;přesným popisem datových typů včetně jejich šířky, tj.&nbsp;nepoužíváme
jen <strong>char</strong> nebo <strong>int</strong>, ale explicitně
<strong>uint8_t</strong>, <strong>int32_t</strong> atd. (pokud použijete
<strong>int</strong> apod., bude problematické takový projekt spustit na jiných
platformách):</p>

<pre>
typedef struct {
    uint8_t a;
    uint8_t b;
    uint8_t c;
    int32_t d;
    int32_t e;
    float   f;
} test_struct;
</pre>

<p>Následně je definována funkce, která po svém zavolání vypíše velikost
předané struktury (ta je známa v&nbsp;době překladu) a její prvky. Povšimněte
si, že této funkci skutečně předáváme <i>celou strukturu</i>, což nemusí být ve
všech případech žádoucí chování (struktury mohou být poměrně rozsáhlé):</p>

<pre>
void print_struct(test_struct s)
{
    printf("sizeof(test_struct) = %lu bytes\n", sizeof(s));
    printf("a = %d\n", s.a);
    printf("b = %d\n", s.b);
    printf("c = %d\n", s.c);
    printf("d = %d\n", s.d);
    printf("e = %d\n", s.e);
    printf("f = %f\n", s.f);
}
</pre>

<p>Úplný zdrojový kód céčkové části vypadá takto:</p>

<pre>
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
&nbsp;
typedef struct {
    uint8_t a;
    uint8_t b;
    uint8_t c;
    int32_t d;
    int32_t e;
    float   f;
} test_struct;
&nbsp;
void print_struct(test_struct s)
{
    printf("sizeof(test_struct) = %lu bytes\n", sizeof(s));
    printf("a = %d\n", s.a);
    printf("b = %d\n", s.b);
    printf("c = %d\n", s.c);
    printf("d = %d\n", s.d);
    printf("e = %d\n", s.e);
    printf("f = %f\n", s.f);
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Volání céčkové funkce z&nbsp;Rustu s&nbsp;předáním struktury</h2>

<p>V&nbsp;části naprogramované v&nbsp;Rustu je nutné nejprve deklarovat datovou
strukturu takovým způsobem, aby přesně odpovídala céčkové části. Pro tento účel
je nutné použít <strong>#[repr(C)]</strong>, protože překladač Rustu musí
uspořádat prvky struktury takovým způsobem, aby byla struktura bitově
kompatibilní s&nbsp;céčkem (bitové obrazy struktury musí být naprosto shodné).
Samozřejmě je také nutné dodržet pořadí prvků (na druhou stranu se může
pojmenování prvků lišit):</p>

<pre>
<strong>#[repr(C)]</strong>
struct TestStruct {
    a: u8,
    b: u8,
    c: u8,
    d: i32,
    e: i32,
    f: f32
}
</pre>

<p>V&nbsp;další části kódu musíme provést deklaraci externí (nativní) funkce
napsané v&nbsp;céčku. Povšimněte si, že hlavička funkce přesně odpovídá
konvencím Rustu (typ parametru, návratová hodnota):</p>

<pre>
extern {
    fn print_struct(s:TestStruct) -&gt; ();
}
</pre>

<p>Tuto funkci voláme opět v&nbsp;bloku <strong>unsafe</strong>:</p>

<pre>
let s : TestStruct = TestStruct{a:1, b:255, c:42, d:10000, e:-10000, f:3.14};
unsafe {
    print_struct(s);
}
</pre>

<p>V&nbsp;programu dále strukturu vytvoříme a následně vypíšeme její velikost,
a to konkrétně funkcí <strong>mem::size_of()</strong>, která velikost zjistí
z&nbsp;generického typu:</p>

<pre>
use std::mem;
&nbsp;
let s : TestStruct = TestStruct{a:1, b:255, c:42, d:10000, e:-10000, f:3.14};
println!("sizeof on Rust side = {} bytes", mem::size_of::&lt;TestStruct&gt;());
</pre>

<p>Úplný zdrojový kód části psané v&nbsp;Rustu tedy bude vypadat
následovně:</p>

<pre>
use std::mem;
&nbsp;
#[repr(C)]
struct TestStruct {
    a: u8,
    b: u8,
    c: u8,
    d: i32,
    e: i32,
    f: f32
}
&nbsp;
extern {
    fn print_struct(s:TestStruct) -&gt; ();
}
&nbsp;
fn main() {
    let s : TestStruct = TestStruct{a:1, b:255, c:42, d:10000, e:-10000, f:3.14};
    println!("sizeof on Rust side = {} bytes", mem::size_of::&lt;TestStruct&gt;());
    unsafe {
        print_struct(s);
    }
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Překlad a spuštění příkladu</h2>

<p>Vzhledem k&nbsp;tomu, že je celý projekt spravován nástrojem Cargo, je jeho
překlad a slinkování jednoduché, což už ostatně známe z&nbsp;předchozích částí
tohoto seriálu:</p>

<pre>
$ <strong>cargo build</strong>
   Compiling gcc v0.3.50
   Compiling ffi_project3 v0.1.0 (file:///home/tester/ffi_project3)
    Finished debug [unoptimized + debuginfo] target(s) in 3.42 secs
</pre>

<p>I pro spuštění projektu použijeme nástroj Cargo. Měl by se vypsat
následující text:</p>

<pre>
$ <strong>cargo run</strong>
    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/ffi_project3`
sizeof on Rust side = 16 bytes
sizeof(test_struct) = 16 bytes
a = 1
b = 255
c = 42
d = 10000
e = -10000
f = 3.140000
</pre>

<p>Poznámka: na architekturách odlišných od x86-64 se může lišit velikost
struktury hlášené jak céčkovou částí, tak i částí psanou v&nbsp;Rustu. Stále by
však měly být obě velikosti shodné (pokud nebudou shodné, budou se velmi
pravděpodobně lišit i hodnoty přečtené v&nbsp;céčkové části).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Problematika zarovnání prvků ve struktuře a &bdquo;výplní&ldquo; mezi prvky</h2>

<p>Pokud jste se pečlivě podívali na výstup vypsaný předchozím projektem, asi
jste si všimli, že datová struktura má hlášenou velikost 16 bajtů a nikoli
pouze 15 bajtů, jak by se mohlo zdát při pouhém součtu velikostí jednotlivých
prvků:</p>

<pre>
    a: u8,    1 bajt
    b: u8,    1 bajt
    c: u8,    1 bajt
    d: i32,   4 bajty
    e: i32,   4 bajty
    f: f32    4 bajty
celkem:      15 bajtů
</pre>

<p>Ve skutečnosti totiž na většině v&nbsp;současnosti používaných architektur
mikroprocesorů (snad jen s&nbsp;výjimkou osmibitových mikrořadičů) mohou mezi
prvky struktury vznikat volná místa, která sice zbytečně zabírají paměť, ovšem
umožňují, aby se k&nbsp;prvkům struktury o velikosti slov přistupovalo mnohem
rychleji, protože tyto prvky budou takzvaně <i>zarovnány (aligned)</i>. To
znamená, že prvky budou například umístěny na adresách dělitelných čtyřmi, osmi
atd. (v&nbsp;závislosti na platformě a architektuře procesoru, například na x86
bude zarovnání většinou odpovídat šířce ukládaného slova). Bajty mezi prvky,
které nejsou použity, se nazývají <i>padding bytes</i>:</p>

<pre>
    a: u8,    1 bajt
    b: u8,    1 bajt
    c: u8,    1 bajt
    xxx       1 bajt - výplň (padding)
    d: i32,   4 bajty
    e: i32,   4 bajty
    f: f32    4 bajty
celkem:      16 bajtů
</pre>

<p>Na jiných architekturách může být způsob zarovnání odlišný a některé
překladače ho umožňují zcela vypnout. V&nbsp;případě GCC je možné použít
<strong>__attribute__((__packed__))</strong> atd. To znamená, že další příklad
po překladu pomocí GCC a spuštění vypíše 16 bajtů a 15 bajtů:</p>

<pre>
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
&nbsp;
typedef struct {
    uint8_t a;
    uint8_t b;
    uint8_t c;
    int32_t d;
    int32_t e;
    float   f;
} test_struct1;
&nbsp;
typedef struct __attribute__((__packed__)) {
    uint8_t a;
    uint8_t b;
    uint8_t c;
    int32_t d;
    int32_t e;
    float   f;
} test_struct2;
&nbsp;
int main(void)
{
    printf("sizeof(test_struct1) = %lu bytes\n", sizeof(test_struct1));
    printf("sizeof(test_struct2) = %lu bytes\n", sizeof(test_struct2));
    return 0;
}
</pre>


<p><a name="k07"></a></p>
<h2 id="k07">7. Změna pořadí prvků struktury</h2>

<p>Zkusme si nyní prohodit pořadí prvků ve struktuře. Namísto uspořádání:</p>

<pre>
typedef struct {
    uint8_t a;
    uint8_t b;
    uint8_t c;
    int32_t d;
    int32_t e;
    float   f;
} test_struct;
</pre>

<p>Použijeme strukturu, v&nbsp;níž je vždy mezi prvky se šířkou čtyři bajty
vložen prvek jednobajtový:</p>

<pre>
typedef struct {
    uint8_t a;
    int32_t b;
    uint8_t c;
    int32_t d;
    uint8_t e;
    float   f;
} test_struct;
</pre>

<p>Upravená céčková část programu vypadá takto:</p>

<pre>
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
&nbsp;
typedef struct {
    uint8_t a;
    int32_t b;
    uint8_t c;
    int32_t d;
    uint8_t e;
    float   f;
} test_struct;
&nbsp;
void print_struct(test_struct s)
{
    printf("sizeof(test_struct) = %lu bytes\n", sizeof(s));
    printf("a = %d\n", s.a);
    printf("b = %d\n", s.b);
    printf("c = %d\n", s.c);
    printf("d = %d\n", s.d);
    printf("e = %d\n", s.e);
    printf("f = %f\n", s.f);
}
</pre>

<p>Část psaná v&nbsp;Rustu samozřejmě musí reflektovat všechny změny ve
struktuře (ostatně &ndash; sami si vyzkoušejte, co se stane, když tuto část
nezměníte):</p>

<pre>
use std::mem;
&nbsp;
#[repr(C)]
struct TestStruct {
    a: u8,
    b: i32,
    c: u8,
    d: i32,
    e: u8,
    f: f32
}
&nbsp;
extern {
    fn print_struct(s:TestStruct) -&gt; ();
}
&nbsp;
fn main() {
    let s : TestStruct = TestStruct{a:1, b:1000, c:255, d:10000, e:127, f:3.14};
    println!("sizeof on Rust side = {} bytes", mem::size_of::&lt;TestStruct&gt;());
    unsafe {
        print_struct(s);
    }
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Překlad a spuštění druhého příkladu</h2>

<p>Překlad se provede naprosto stejným způsobem, jako v&nbsp;předchozím
příkladu:</p>

<pre>
$ <strong>cargo build</strong>
   Compiling gcc v0.3.50
   Compiling ffi_project4 v0.1.0 (file:///home/tester/ffi_project4)
    Finished debug [unoptimized + debuginfo] target(s) in 3.45 secs
</pre>

<p>Po spuštění však dostaneme odlišný výsledek, protože je hlášeno, že
struktura má nyní velikost 24 bajtů a nikoli šestnáct bajtů, i když prvky
zůstaly zachovány, pouze se prohodily:</p>

<pre>
$ <strong>cargo run</strong>
    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/ffi_project4`
sizeof on Rust side = 24 bytes
sizeof(test_struct) = 24 bytes
a = 1
b = 1000
c = 255
d = 10000
e = 127
f = 3.140000
</pre>

<p>Ve skutečnosti totiž nyní naše datová struktura vypadá následovně:</p>

<pre>
    a: u8,    1 bajt
    xxx       3 bajty - výplň (padding)
    b: i32,   4 bajty
    c: u8,    1 bajt
    xxx       3 bajty - výplň (padding)
    d: i32,   4 bajty
    e: u8,    1 bajt
    xxx       3 bajty - výplň (padding)
    f: f32    4 bajty
celkem:      24 bajtů
</pre>

<p>Povšimněte si, že prvky o šířce čtyř bajtů skutečně budou začínat na adrese
dělitelné čtyřmi (předpokládáme, že i celá struktura začíná na adrese dělitelné
čtyřmi, což je pravda).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Export binární podoby struktury</h2>

<p>Nepatrnou změnou céčkové části projektu si můžeme ověřit, jakým způsobem je
struktura uložena v&nbsp;paměti. Kromě funkce <strong>print_struct()</strong>
použijeme novou funkci <strong>export_struct()</strong> určenou pro export
binárního obrazu struktury do souboru (pro jednoduchost bez testů, zda se
soubor podařilo vytvořit, otevřít, zapsat data a zavřít:</p>

<pre>
void export_struct(test_struct s)
{
    FILE *fout = fopen("test.bin", "wb");
    fwrite(&amp;s, sizeof(s), 1, fout);
    fclose(fout);
}
</pre>

<p>Nová varianta céčkové části bude vypadat následovně:</p>

<pre>
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
&nbsp;
typedef struct {
    uint8_t a;
    int32_t b;
    uint8_t c;
    int32_t d;
    uint8_t e;
    float   f;
} test_struct;
&nbsp;
void export_struct(test_struct s)
{
    FILE *fout = fopen("test.bin", "wb");
    fwrite(&amp;s, sizeof(s), 1, fout);
    fclose(fout);
}
&nbsp;
void print_struct(test_struct s)
{
    printf("sizeof(test_struct) = %lu bytes\n", sizeof(s));
    printf("a = %d\n", s.a);
    printf("b = %d\n", s.b);
    printf("c = %d\n", s.c);
    printf("d = %d\n", s.d);
    printf("e = %d\n", s.e);
    printf("f = %f\n", s.f);
}
</pre>

<p>Pokud volání nové funkce přidáme do části psané v&nbsp;Rustu, získáme po
spuštění projektu soubor pojmenovaný <strong>test.bin</strong>, který bude mít
na architektuře x86-64 délku 24 bajtů a následující obsah:</p>

<pre>
$ <strong>hexdump -C test.bin </strong>
00000000  01 a4 8f 30 e8 03 00 00  ff 94 5f 53 10 27 00 00  |...0......_S.'..|
00000010  7f d0 61 2f c3 f5 48 40                           |..a/..H@|
00000018
</pre>

<p>Poznámka: na jiných architekturách může být obsah odlišný, protože se mohou
použít odlišná pravidla pro zarovnávání a taktéž může být rozdílný způsob
uložení bajtů v&nbsp;širších slovech (<i>little endian</i> versus <i>big
endian</i>).</p>

<p>Význam jednotlivých bajtů v&nbsp;souboru je následující:</p>

<table>
<tr><th>Offset</th><th>Sekvence bajtů</th><th>Význam</th></tr>
<tr><td>0</td><td>01</td><td>0x01 = 1, první celočíselná konstanta typu bajt</td></tr>
<tr><td>1</td><td>a4 8f 30</td><td>výplň (padding)</td></tr>
<tr><td>4</td><td>e8 03 00 00</td><td>0x000003e8 = 1000, druhá celočíselná konstanta typu int32</td></tr>
<tr><td>8</td><td>ff</td><td>0xff = 255, třetí celočíselná konstanta typu bajt</td></tr>
<tr><td>9</td><td>94 5f 53</td><td>výplň (padding)</td></tr>
<tr><td>12</td><td>10 27 00 00</td><td>0x00002710 = 10000, čtvrtá celočíselná konstanta typu int32</td></tr>
<tr><td>16</td><td>7f</td><td>0x7f = 127, pátá celočíselná konstanta typu bajt</td></tr>
<tr><td>17</td><td>d0 61 2f</td><td>výplň (padding)</td></tr>
<tr><td>20</td><td>c3 f5 48 40</td><td>0x4048f5c3 = &pi; <a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">v&nbsp;IEEE 754 reprezentaci</a></td></tr>
</table>

<p>Porovnejte si tuto tabulku s&nbsp;rozborem struktury provedené <a
href="#k09">v&nbsp;předchozí kapitole</a>.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Předání struktury odkazem (přes ukazatel)</h2>

<p>Předávání struktur hodnotou (<i>by value</i>), tedy způsobem, který jsme si
ukázali v&nbsp;předchozích kapitolách, se sice používá, ale nemusí být vždy
ideální. Nejedná se totiž o příliš efektivní operaci, protože &ndash; jak jsme
sami viděli &ndash; je nutné do nativní funkce překopírovat celou strukturu,
která je relativně velká (a v&nbsp;reálných příkladech může být ještě větší).
Navíc není možné prvky struktury předané hodnotou měnit, což však na druhou
stranu může být vítaná vlastnost. Ovšem při komunikaci mezi Rustem a céčkem lze
předat i pouhé <i>ukazatele na strukturu</i>, která tak bude mezi oběma částmi
aplikace sdílená. V&nbsp;navazujících kapitolách si ukážeme, jak se to
provádí.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Céčková část aplikace</h2>

<p>Nejprve si ukažme, jak se změní céčková část aplikace ve chvíli, kdy jí
potřebujeme předat ukazatel na strukturu. Hlavička funkce bude nyní následující
(čteme &ndash; &bdquo;s je ukazatel na hodnotu typu test_struct&ldquo;):</p>

<pre>
void print_struct(test_struct *s);
</pre>

<p>Přístup k&nbsp;prvkům struktury přes ukazatel je v&nbsp;céčku velmi snadný,
protože lze použít operátor -&gt; a zápis <strong>s-&gt;prvek</strong> je
mnohem čitelnější než <strong>(*s).prvek</strong> (zde je navíc nutné použít
závorky kvůli prioritě operátorů):</p>

<pre>
printf("a = %d\n", s-&gt;a);
printf("b = %d\n", s-&gt;b);
printf("c = %d\n", s-&gt;c);
printf("d = %d\n", s-&gt;d);
printf("e = %d\n", s-&gt;e);
printf("f = %f\n", s-&gt;f);
</pre>

<p>V&nbsp;upraveném příkladu si navíc necháváme vytisknout jak velikost
struktury, tak i velikost ukazatele předaného do volané funkce:</p>

<pre>
printf("sizeof(pointer)     = %lu bytes\n", sizeof(s));
printf("sizeof(test_struct) = %lu bytes\n", sizeof(*s));
</pre>

<p>Úplný zdrojový kód céčkové části vypadá takto:</p>

<pre>
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
&nbsp;
typedef struct {
    uint8_t a;
    int32_t b;
    uint8_t c;
    int32_t d;
    uint8_t e;
    float   f;
} test_struct;
&nbsp;
void print_struct(test_struct *s)
{
    printf("sizeof(pointer)     = %lu bytes\n", sizeof(s));
    printf("sizeof(test_struct) = %lu bytes\n", sizeof(*s));
    printf("a = %d\n", s-&gt;a);
    printf("b = %d\n", s-&gt;b);
    printf("c = %d\n", s-&gt;c);
    printf("d = %d\n", s-&gt;d);
    printf("e = %d\n", s-&gt;e);
    printf("f = %f\n", s-&gt;f);
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Část aplikace naprogramovaná v&nbsp;Rustu</h2>

<p>I v&nbsp;té části aplikace, která je psaná v&nbsp;Rustu, musí dojít
k&nbsp;úpravě, protože potřebujeme získat ukazatel na strukturu. To se provede
až překvapivě jednoduše, konkrétně pomocí operátoru &amp;, který slouží
k&nbsp;získání reference:</p>

<pre>
let s : TestStruct = TestStruct{a:1, b:1000, c:255, d:10000, e:127, f:3.14};
unsafe {
    let pointer = &amp;s;
    print_struct(pointer);
}
</pre>

<p>Taktéž je nutné upravit hlavičku externí funkce, protože této funkci
předáváme referenci (adresu):</p>

<pre>
extern {
    fn print_struct(s: *const TestStruct) -&gt; ();
}
</pre>

<p>Upravený program bude vypadat takto:</p>

<pre>
use std::mem;
&nbsp;
#[repr(C)]
struct TestStruct {
    a: u8,
    b: i32,
    c: u8,
    d: i32,
    e: u8,
    f: f32
}
&nbsp;
extern {
    fn print_struct(s: *const TestStruct) -&gt; ();
}
&nbsp;
fn main() {
    let s : TestStruct = TestStruct{a:1, b:1000, c:255, d:10000, e:127, f:3.14};
    println!("sizeof on Rust side = {} bytes", mem::size_of::&lt;TestStruct&gt;());
    unsafe {
        let pointer = &amp;s;
        print_struct(pointer);
    }
}
</pre>

<p>Spuštění příkladu:</p>

<pre>
$ <strong>cargo run</strong>
    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/ffi_project5`
sizeof on Rust side = 24 bytes
sizeof(pointer)     = 8 bytes
sizeof(test_struct) = 24 bytes
a = 1
b = 1000
c = 255
d = 10000
e = 127
f = 3.140000
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Ukazatel versus reference</h2>

<p>Ve skutečnosti zápisem:</p>

<pre>
let pointer = &amp;s;
</pre>

<p>získáme <i>referenci</i> a nikoli skutečný ukazatel. Ten lze získat spíše
následovně:</p>

<pre>
let pointer :*const TestStruct = &amp;s;
</pre>

<p>Samotná hodnota je sice stejná (= adresa struktury), ale způsob práce se
liší. U ukazatelů se například nekontroluje, zda ukazují na živou hodnotu,
takže lze zapsat:</p>

<pre>
#[repr(C)]
#[derive(Debug)]
struct TestStruct {
    a: u8,
    b: i32,
    c: u8,
    d: i32,
    e: u8,
    f: f32
}
&nbsp;
fn main() {
    let pointer :*const TestStruct;
    {
        let s : TestStruct = TestStruct{a:1, b:1000, c:255, d:10000, e:127, f:3.14};
        pointer = &amp;s;
        println!("{:?}", pointer);
    }
    println!("{:?}", pointer);
}
</pre>

<p>U referencí naproti tomu získáme všechny kontroly překladače:</p>

<pre>
#[derive(Debug)]
struct TestStruct {
    a: u8,
    b: i32,
    c: u8,
    d: i32,
    e: u8,
    f: f32
}
&nbsp;
fn main() {
    let pointer;
    {
        let s : TestStruct = TestStruct{a:1, b:1000, c:255, d:10000, e:127, f:3.14};
        pointer = &amps;
        println!("{:?}", pointer);
    }
    println!("{:?}", pointer);
}
</pre>

<p>Tento program se již nepřeloží (což je ostatně zcela korektní):</p>

<pre>
error: `s` does not live long enough
  --&gt; test.rs:16:20
   |
16 |         pointer = &amp;s;
   |                    ^
   |
note: reference must be valid for the block suffix following statement 0 at 13:16...
  --&gt; test.rs:13:17
   |
13 |     let pointer;
   |                 ^
note: ...but borrowed value is only valid for the block suffix following statement 0 at 15:84
  --&gt; test.rs:15:85
   |
15 |         let s : TestStruct = TestStruct{a:1, b:1000, c:255, d:10000, e:127, f:3.14};
   |                                                                                     ^
&nbsp;
error: aborting due to previous error
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Modifikace prvků struktury v&nbsp;nativním kódu</h2>

<p>Připomeňme si, že céčková část se strukturou předanou přes ukazatel provádět
prakticky cokoli, například měnit její prvky:</p>

<pre>
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
&nbsp;
typedef struct {
    uint8_t a;
    int32_t b;
    uint8_t c;
    int32_t d;
    uint8_t e;
    float   f;
} test_struct;
&nbsp;
void print_struct(test_struct *s)
{
    printf("sizeof(pointer)     = %lu bytes\n", sizeof(s));
    printf("sizeof(test_struct) = %lu bytes\n", sizeof(*s));
    printf("a = %d\n", s-&gt;a);
    printf("b = %d\n", s-&gt;b);
    printf("c = %d\n", s-&gt;c);
    printf("d = %d\n", s-&gt;d);
    printf("e = %d\n", s-&gt;e);
    printf("f = %f\n", s-&gt;f);
}
&nbsp;
void change_struct(test_struct *s)
{
    s-&gt;a = 10;
    s-&gt;b = 20;
    s-&gt;c = 30;
    s-&gt;d = 40;
    s-&gt;e = 50;
    s-&gt;f = 60.0;
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Rustovská část</h2>

<p>To je ovšem v&nbsp;rozporu s&nbsp;Rustovskou deklarací, kde chybí
modifikátor <strong>mut</strong>:</p>

<pre>
#[derive(Debug)]
#[repr(C)]
struct TestStruct {
    a: u8,
    b: i32,
    c: u8,
    d: i32,
    e: u8,
    f: f32
}
&nbsp;
extern {
    fn print_struct(s: *const TestStruct) -&gt; ();
    fn change_struct(s: *const TestStruct) -&gt; ();
}
&nbsp;
fn main() {
    let s : TestStruct = TestStruct{a:1, b:1000, c:255, d:10000, e:127, f:3.14};
    println!("original value: {:?}", s);
    unsafe {
        let pointer = &amp;s;
        print_struct(pointer);
        change_struct(pointer);
        print_struct(pointer);
    }
    println!("changed value: {:?}", s);
}
</pre>

<p>Na tento rozpor nás ovšem překladač neupozorní (ani překladač Rustu a
samozřejmě ani překladač céčka). Podívejme se, co se stane po spuštění
aplikace:</p>

<pre>
$ <strong>cargo run</strong>
    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/ffi_project6`
original value: TestStruct { a: 1, b: 1000, c: 255, d: 10000, e: 127, f: 3.14 }
sizeof(pointer)     = 8 bytes
sizeof(test_struct) = 24 bytes
a = 1
b = 1000
c = 255
d = 10000
e = 127
f = 3.140000
sizeof(pointer)     = 8 bytes
sizeof(test_struct) = 24 bytes
a = 10
b = 20
c = 30
d = 40
e = 50
f = 60.000000
changed value: TestStruct { a: 10, b: 20, c: 30, d: 40, e: 50, f: 60 }
</pre>

<p>Vidíme, že céčková funkce <strong>change_struct()</strong> skutečně změnila
data Rustu &bdquo;pod rukama&ldquo;, což obecně není korektní chování.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady (projekty) byly, ostatně
podobně jako ve všech předchozích částech <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">tohoto seriálu</a>,
uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě
bez nutnosti klonovat celý repositář (ovšem u projektů je lepší mít celý
repositář, abyste nemuseli pracně stahovat všechny potřebné soubory):</p>

<table>
<tr><th>Příklad</th><th>Adresa</th></tr>
<tr><td>Projekt číslo 3</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project3/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project3/Cargo.toml</a></td></tr>
<tr><td>build.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project3/build.rs">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project3/build.rs</a></td></tr>
<tr><td>ffi3.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project3/src/ffi3.c">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project3/src/ffi3.c</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project3/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project3/src/main.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Projekt číslo 4</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project4/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project4/Cargo.toml</a></td></tr>
<tr><td>build.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project4/build.rs">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project4/build.rs</a></td></tr>
<tr><td>ffi4.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project4/src/ffi4.c">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project4/src/ffi4.c</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project4/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project4/src/main.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Projekt číslo 5</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project5/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project5/Cargo.toml</a></td></tr>
<tr><td>build.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project5/build.rs">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project5/build.rs</a></td></tr>
<tr><td>ffi5.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project5/src/ffi5.c">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project5/src/ffi5.c</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project5/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project5/src/main.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Projekt číslo 6</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project6/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project6/Cargo.toml</a></td></tr>
<tr><td>build.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project6/build.rs">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project6/build.rs</a></td></tr>
<tr><td>ffi6.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project6/src/ffi6.c">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project6/src/ffi6.c</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project6/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi_project6/src/main.rs</a></td></tr>
</table>



<p><a name="k17"></a></p>
<h2 id="k17">17. Odkazy na Internetu</h2>

<ol>

<li>Build Script Support<br />
<a href="http://doc.crates.io/build-script.html">http://doc.crates.io/build-script.html</a>
</li>

<li>Creating a shared and static library with the gnu compiler [gcc]<br />
<a href="http://www.adp-gmbh.ch/cpp/gcc/create_lib.html">http://www.adp-gmbh.ch/cpp/gcc/create_lib.html</a>
</li>

<li>FFI: Foreign Function Interface<br />
<a href="https://doc.rust-lang.org/book/ffi.html">https://doc.rust-lang.org/book/ffi.html</a>
</li>

<li>Primitive Type pointer<br />
<a href="https://doc.rust-lang.org/std/primitive.pointer.html">https://doc.rust-lang.org/std/primitive.pointer.html</a>
</li>

<li>Cargo: správce projektů a balíčků pro programovací jazyk Rust<br />
<a href="https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/">https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/</a>
</li>

<li>Network Communication and Serialization in Rust<br />
<a href="https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/">https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/</a>
</li>

<li>Crate bincode<br />
<a href="http://tyoverby.com/bincode/bincode/index.html">http://tyoverby.com/bincode/bincode/index.html</a>
</li>

<li>Struct std::fs::File<br />
<a href="https://doc.rust-lang.org/std/fs/struct.File.html">https://doc.rust-lang.org/std/fs/struct.File.html</a>
</li>

<li>Trait std::io::Seek<br />
<a href="https://doc.rust-lang.org/std/io/trait.Seek.html">https://doc.rust-lang.org/std/io/trait.Seek.html</a>
</li>

<li>Trait std::io::Read<br />
<a href="https://doc.rust-lang.org/std/io/trait.Read.html">https://doc.rust-lang.org/std/io/trait.Read.html</a>
</li>

<li>Trait std::io::Write<br />
<a href="https://doc.rust-lang.org/std/io/trait.Write.html">https://doc.rust-lang.org/std/io/trait.Write.html</a>
</li>

<li>Trait std::io::BufRead<br />
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html">https://doc.rust-lang.org/std/io/trait.BufRead.html</a>
</li>

<li>Module std::io::prelude<br />
<a href="https://doc.rust-lang.org/std/io/prelude/index.html">https://doc.rust-lang.org/std/io/prelude/index.html</a>
</li>

<li>std::net::IpAddr<br />
<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">https://doc.rust-lang.org/std/net/enum.IpAddr.html</a>
</li>

<li>std::net::Ipv4Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html</a>
</li>

<li>std::net::Ipv6Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html</a>
</li>

<li>TcpListener<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">https://doc.rust-lang.org/std/net/struct.TcpListener.html</a>
</li>

<li>TcpStream<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html">https://doc.rust-lang.org/std/net/struct.TcpStream.html</a>
</li>

<li>Binary heap (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Binary_heap">https://en.wikipedia.org/wiki/Binary_heap</a>
</li>

<li>Binární halda (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda">https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda</a>
</li>

<li>Halda (datová struktura)<br />
<a href="https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29">https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29</a>
</li>

<li>Struct std::collections::HashSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">https://doc.rust-lang.org/std/collections/struct.HashSet.html</a>
</li>

<li>Struct std::collections::BTreeSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">https://doc.rust-lang.org/std/collections/struct.BTreeSet.html</a>
</li>

<li>Struct std::collections::BinaryHeap<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html">https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html</a>
</li>

<li>Set (abstract data type)<br />
<a href="https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support">https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support</a>
</li>

<li>Associative array<br />
<a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a>
</li>

<li>Hash Table<br />
<a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a>
</li>

<li>B-tree<br />
<a href="https://en.wikipedia.org/wiki/B-tree">https://en.wikipedia.org/wiki/B-tree</a>
</li>

<li>Pedro Celis: Robin Hood Hashing (naskenované PDF!)<br />
<a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf</a>
</li>

<li>Robin Hood hashing<br />
<a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">http://codecapsule.com/2013/11/11/robin-hood-hashing/</a>
</li>

<li>Robin Hood hashing: backward shift deletion<br />
<a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/</a>
</li>

<li>Module std::collections<br />
<a href="https://doc.rust-lang.org/std/collections/">https://doc.rust-lang.org/std/collections/</a>
</li>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Struct std::collections::VecDeque<br />
<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">https://doc.rust-lang.org/std/collections/struct.VecDeque.html</a>
</li>

<li>Struct std::collections::LinkedList<br />
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">https://doc.rust-lang.org/std/collections/struct.LinkedList.html</a>
</li>

<li>Module std::fmt<br />
<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>
</li>

<li>Macro std::println<br />
<a href="https://doc.rust-lang.org/std/macro.println.html">https://doc.rust-lang.org/std/macro.println.html</a>
</li>

<li>Enum std::result::Result<br />
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">https://doc.rust-lang.org/std/result/enum.Result.html</a>
</li>

<li>Module std::result<br />
<a href="https://doc.rust-lang.org/std/result/">https://doc.rust-lang.org/std/result/</a>
</li>

<li>Result<br />
<a href="http://rustbyexample.com/std/result.html">http://rustbyexample.com/std/result.html</a>
</li>

<li>Rust stdlib: Option<br />
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">https://doc.rust-lang.org/std/option/enum.Option.html</a>
</li>

<li>Module std::option<br />
<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>
</li>

<li>Rust by example: option<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>Rust by example: if-let<br />
<a href="http://rustbyexample.com/flow_control/if_let.html">http://rustbyexample.com/flow_control/if_let.html</a>
</li>

<li>Rust by example: while let<br />
<a href="http://rustbyexample.com/flow_control/while_let.html">http://rustbyexample.com/flow_control/while_let.html</a>
</li>

<li>Rust by example: Option&lt;i32&gt;<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>


</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

