<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>SQLite-vec: vektorové rozšíření databáze SQLite</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>SQLite-vec: vektorové rozšíření databáze SQLite</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku se seznámíme se základními vlastnosti rozšíření databáze SQLite, které se jmenuje SQLite-vec. Toto rozšíření umožňuje SQLite používat ve funkci vektorové databáze, zejména při zpracování přirozeného jazyka, rozpoznávání obrázků, detekci anomálií atd.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. SQLite-vec: vektorové rozšíření databáze SQLite</a></p>
<p><a href="#k02">2. Koncept virtuálních tabulek v&nbsp;SQLite</a></p>
<p><a href="#k03">3. Instalace rozšíření <strong>sqlite-vec</strong></a></p>
<p><a href="#k04">4. Základy práce s&nbsp;rozšířením <strong>sqlite-vec</strong></a></p>
<p><a href="#k05">5. Nové možnosti dotazu <strong>SELECT</strong></a></p>
<p><a href="#k06">6. Vizualizace výpočtů vzdáleností pro 2D vektory</a></p>
<p><a href="#k07">7. Vytvoření a naplnění tabulky pro uložení 2D vektorů</a></p>
<p><a href="#k08">8. Výpis obsahu tabulky se sloupcem s&nbsp;vektory</a></p>
<p><a href="#k09">9. Vyhledávání na základě vzdálenosti vektorů</a></p>
<p><a href="#k10">10. Tabulky obsahující jak sloupec s&nbsp;vektory, tak i sloupce s&nbsp;dalšími daty</a></p>
<p><a href="#k11">11. Výpis hodnot podle vzdálenosti</a></p>
<p><a href="#k12">12. Využití databáze SQLite s&nbsp;rozšířením SQLite-vec z&nbsp;Pythonu</a></p>
<p><a href="#k13">13. Instalace balíčku <strong>sqllite-vec</strong></a></p>
<p><a href="#k14">14. Zjištění verze rozšíření SQLite-vec</a></p>
<p><a href="#k15">15. Vytvoření virtuální tabulky s&nbsp;vektory</a></p>
<p><a href="#k16">16. Naplnění tabulek s&nbsp;vektory</a></p>
<p><a href="#k17">17. Dotazy: zjištění nejbližších vektorů</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Předchozí články věnující se problematice vyhledávání podobných vektorů v&nbsp;databázích</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. SQLite-vec: vektorové rozšíření databáze SQLite</h2>

<p>V&nbsp;posledních několika letech můžeme sledovat poměrně výrazné a stále
častější nasazování takzvaných <i>vektorových databází</i>. Jedná se (alespoň
většinou) o specializované databáze, které umožňují ukládat vektory numerických
hodnot (pevné délky) a především efektivně vyhledávat vektory podle jejich
podobnosti (například se zadaným vzorem), přičemž podobností může být myšlena
například vzdálenost koncových bodů vektorů v&nbsp;Eukleidovském prostoru,
kosinus úhlu mezi vektory, výsledek skalárního součinu atd. Tyto operace se
dnes používají v&nbsp;mnoha oblastech. Například se s&nbsp;nimi můžeme setkat
při rozpoznávání a zpracování přirozeného jazyka (<i>NLP &ndash; Native
Language Processing</i>), při rozpoznávání obrázků, rozpoznávání hlasů, detekci
anomálií, ale i (a to zejména) v&nbsp;souvislosti s&nbsp;velkými jazykovými
modely (<i>LLM</i>). K&nbsp;tomuto stále ještě aktuálnímu tématu se ještě
vrátíme v&nbsp;samostatném článku.</p>

<p>Ovšem namísto specializovaných databází je možné si zvolit nějakou
existující technologii, která se v&nbsp;praxi osvědčuje už desítky let. Na
stránkách Roota jsme se již setkali s&nbsp;relační databází PostgreSQL, pro
kterou vzniklo rozšíření nazvané <i>pgvector</i>. Toto rozšíření umožňuje
efektivní ukládání vektorů do tabulek, ale zejména podporuje i vyhledávání
vektorů na základě jejich podobnosti (navíc lze využít různé varianty indexů
atd.). Ovšem nejedná se o jedinou klasickou relační databázi, která byla
rozšířena i do oblasti vyhledávání podobných vektorů. Podobné rozšíření
existuje i pro databázi SQLite; samotné rozšíření se jmenuje jednoduše
<i>SQLite-vec</i>.</p>

<p>Dnes se seznámíme se základními vlastnostmi tohoto rozšíření a ve druhé
části článku i s&nbsp;příklady použití <i>SQLite-vec</i> v&nbsp;aplikacích
vytvářených v&nbsp;programovacím jazyku Python.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Koncept virtuálních tabulek v&nbsp;SQLite</h2>

<p>V&nbsp;popisu vektorového rozšíření databáze SQLite se setkáme
s&nbsp;termínem <i>virtuální tabulka</i>. Jedná se o potenciálně velmi
užitečnou vlastnost databáze SQLite, na kterou se můžeme dívat ze dvou stran.
Častější je pohled vývojáře, který SQLite používá jako běžnou SQL databázi.
Z&nbsp;pohledu tohoto vývojáře se virtuální tabulka do značné míry podobá běžné
tabulce (až na poněkud odlišný způsob její konstrukce). Typicky jsou
podporovány všechny základní operace pro manipulaci s&nbsp;daty (<i>insert</i>,
<i>update</i>, <i>delete</i>) i operace pro vyhledávání (<i>query</i>). Odlišný
je však pohled vývojáře, který vytváří rozšíření pro databázi SQLite. Virtuální
tabulka je totiž objektem s&nbsp;callback metodami, které se volají pro všechny
databázové operace nad touto tabulkou. Jinými slovy to znamená, že například
příkaz <strong>INSERT INTO virtuální_tabulka ...</strong> bude interně převeden
na volání metody příslušného (zaregistrovaného) objektu.</p>

<p>To, jak konkrétně bude virtuální tabulka uložena, je zcela v&nbsp;kompetenci
příslušného objektu, tj.&nbsp;záleží na implementaci příslušného rozšíření.
Konkrétně v&nbsp;případě vektorového rozšíření je každá virtuální tabulka
interně uložena jako několik (konkrétně pět) běžných tabulek, což je ovšem do
značné míry implementační detail.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instalace rozšíření <strong>sqlite-vec</strong></h2>

<p>Rozšíření <strong>sqlite-vec</strong> není standardní součástí databáze
SQLlite, takže je nutné ho nainstalovat zvlášť. V&nbsp;této kapitole si
ukážeme, jakým způsobem je možné toto rozšíření přeložit do sdílené knihovny,
která se poté načte do spuštěné konzole SQLite. K&nbsp;překladu postačují jen
základní nástroje GCC nebo Clang a taktéž nástroj <strong>make</strong>.</p>

<p>Nejdříve je nutné nainstalovat balíček <strong>sqlite-devel</strong> (pozor,
v&nbsp;názvu chybí trojka). Tento balíček obsahuje hlavičkové soubory použité
při překladu <strong>sqlite-vec</strong> a taktéž sdílenou knihovnu
<strong>libsqlite3.so</strong>:</p>

<pre>
/usr/include/sqlite3.h
/usr/include/sqlite3ext.h
/usr/lib/libsqlite3.so
/usr/lib/pkgconfig/sqlite3.pc
/usr/lib64/libsqlite3.so
/usr/lib64/pkgconfig/sqlite3.pc
</pre>

<p>Instalace tohoto balíčku vypadá na distribucích Linux s&nbsp;RPM
následovně:</p>

<pre>
$ <strong>sudo dnf install sqlite-devel</strong>
&nbsp;
Updating and loading repositories:
Repositories loaded.
Package                                      Arch        Version                                      Repository                    Size
Installing:
 sqlite-devel                                x86_64      3.47.2-5.fc42                                updates                  673.4 KiB
&nbsp;
Transaction Summary:
 Installing:         1 package
&nbsp;
Total size of inbound packages is 146 KiB. Need to download 146 KiB.
After this operation, 673 KiB extra will be used (install 673 KiB, remove 0 B).
Is this ok [y/N]: y
[1/1] sqlite-devel-0:3.47.2-5.fc42.x86_64                                                       100% | 617.3 KiB/s | 146.3 KiB |  00m00s
----------------------------------------------------------------------------------------------------------------------------------------
[1/1] Total                                                                                     100% | 143.4 KiB/s | 146.3 KiB |  00m01s
Running transaction
[1/3] Verify package files                                                                      100% | 166.0   B/s |   1.0   B |  00m00s
[2/3] Prepare transaction                                                                       100% |   4.0   B/s |   1.0   B |  00m00s
[3/3] Installing sqlite-devel-0:3.47.2-5.fc42.x86_64                                            100% |   1.4 MiB/s | 674.1 KiB |  00m00s
Complete!
</pre>

<p>Ve druhém kroku se provede naklonování repositáře se zdrojovými kódy
rozšíření <strong>sqlite-vec</strong>:</p>

<pre>
$ <strong>git clone git@github.com:asg017/sqlite-vec.git</strong>
&nbsp;
Cloning into 'sqlite-vec'...
remote: Enumerating objects: 2475, done.
remote: Counting objects: 100% (1033/1033), done.
remote: Compressing objects: 100% (234/234), done.
remote: Total 2475 (delta 873), reused 799 (delta 799), pack-reused 1442 (from 1)
Receiving objects: 100% (2475/2475), 955.37 KiB | 640.00 KiB/s, done.
Resolving deltas: 100% (1379/1379), done.
</pre>

<p>Přejdeme do adresáře s&nbsp;projektem:</p>

<pre>
$ <strong>cd sqlite-vec</strong>
</pre>

<p>Překlad se provede tímto příkazem:</p>

<pre>
$ <strong>make loadable static</strong>
&nbsp;
mkdir -p dist
cc \
        -fPIC -shared \
        -Wall -Wextra \
        -Ivendor/ \
        -O3 \
        -lm \
        sqlite-vec.c -o dist/vec0.so
        ...
        ...
        ...
</pre>

<p><div class="rs-tip-major">Poznámka: schválně nepoužívám <strong>make
all</strong>, protože potřebujeme získat pouze statickou knihovnu a nikoli
plnohodnotnou konzoli atd.</div></p>

<p>Po (doufejme že úspěšném) překladu by se v&nbsp;podadresáři
<strong>dist</strong> měla nacházet jak sdílená knihovna
<strong>vec0.so</strong>, tak i <strong>libsqlite_vec0.a</strong> (archiv
s&nbsp;objektovým souborem <strong>vec0.o</strong>, ten ovšem nepoužijeme):</p>

<pre>
$ <strong>ls -l dist</strong>
total 360
-rw-r--r--. 1 ptisnovs ptisnovs 210222 Jan  8 16:50 libsqlite_vec0.a
-rwxr-xr-x. 1 ptisnovs ptisnovs 153120 Jan  8 16:50 vec0.so
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Základy práce s&nbsp;rozšířením <strong>sqlite-vec</strong></h2>

<p>Ve chvíli, kdy máme k&nbsp;dispozici sdílenou nativní knihovnu
s&nbsp;vektorovým rozšířením, si toto rozšíření můžeme otestovat. V&nbsp;této
kapitole si ukážeme základy práce s&nbsp;vektorovým rozšířením; podrobnější
popis bude uveden později.</p>

<p><div class="rs-tip-major">Poznámka: ve všech dále uvedených příkladech
počítám s&nbsp;tím, že se v&nbsp;aktuálním adresáři nachází i sdílená knihovna
<strong>vec0.so</strong>. Samozřejmě se nejedná o ideální situaci využitelnou
v&nbsp;produkčním nasazení; lepší bude nainstalovat sdílenou knihovnu například
do adresářové struktury <strong>/opt/</strong> atd.</div></p>

<p>Spustíme REPL databáze SQLite s&nbsp;předáním jména souboru, do kterého má
být uloženo schéma i vlastní tabulky. Tento soubor je v&nbsp;případě potřeby
vytvořen:</p>

<pre>
$ <strong>sqlite3 test1.db</strong>
&nbsp;
SQLite version 3.47.2 2024-12-07 20:39:59
Enter ".help" for usage hints.
</pre>

<p>Příkazem <strong>.load</strong> se pokusíme o načtení rozšíření:</p>

<pre>
sqlite&gt; <strong>.load ./vec0</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: tento příkaz se pokusí o nalezení
souboru <strong>vec0.so</strong>, <strong>vec0.dylib</strong> nebo
<strong>vec0.dll</strong> (podle použitého operačního systému) a pokud se to
nepodaří, přidá ještě <strong>libvec0.*</strong>.</div></p>

<p>Vypíšeme si existující tabulky, přičemž by se měl vrátit prázdný seznam:</p>

<pre>
sqlite&gt; <strong>.tables</strong>
</pre>

<p>Nyní vytvoříme novou virtuální tabulku nazvanou
<strong>vec_examples</strong>, která obsahuje sloupec
<strong>sample_embedding</strong> s&nbsp;osmiprvkovými vektory:</p>

<pre>
sqlite&gt; <strong>create virtual table vec_examples using vec0(</strong>
  <strong>sample_embedding float[8]</strong>
<strong>);</strong>
</pre>

<p>Znovu se pokusíme o výpis existujících tabulek:</p>

<pre>
sqlite&gt; <strong>.tables</strong>
&nbsp;
vec_examples                  vec_examples_rowids
vec_examples_chunks           vec_examples_vector_chunks00
vec_examples_info
</pre>

<p>Z&nbsp;výpisu je patrné, že virtuální tabulka <strong>vec_examples</strong>
je ve skutečnosti tvořena pěti dalšími tabulkami.</p>

<p>Jediná nová tabulka obsahující nějaké údaje se jmenuje
<strong>vec_examples_info</strong>. Ta obsahuje metadata o verzi vektorového
rozšíření:</p>

<pre>
sqlite&gt; <strong>select * from vec_examples_info;</strong>
&nbsp;
CREATE_VERSION|v0.1.7-alpha.2
CREATE_VERSION_MAJOR|0
CREATE_VERSION_MINOR|1
CREATE_VERSION_PATCH|7
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Nové možnosti dotazu <strong>SELECT</strong></h2>

<p>Vektorové rozšíření nejenom že umožňuje do databáze ukládat vektory, ale
navíc byl upraven i příkaz <strong>SELECT</strong>, který dokáže získat seznam
nejbližších vektorů, tj.&nbsp;provádět klasickou operaci nazývanou <i>vector
similarity search</i>. Jedná se o velmi užitečnou vlastnost, kterou si nyní
ukážeme.</p>

<p>Nejdříve do virtuální tabulky <strong>vec_examples</strong> vložíme čtveřici
osmiprvkových vektorů:</p>

<pre>
sqlite&gt; <strong>insert into vec_examples(rowid, sample_embedding) values (1, '[1, 0, 0, 0, 0, 0, 0, 0]');</strong>
sqlite&gt; <strong>insert into vec_examples(rowid, sample_embedding) values (2, '[0, 1, 0, 0, 0, 0, 0, 0]');</strong>
sqlite&gt; <strong>insert into vec_examples(rowid, sample_embedding) values (3, '[0, 0, 1, 0, 0, 0, 0, 0]');</strong>
sqlite&gt; <strong>insert into vec_examples(rowid, sample_embedding) values (4, '[1, 0, 1, 0, 0, 0, 0, 0]');</strong>
</pre>

<p>Nově je možné v&nbsp;příkazu <strong>SELECT</strong> použít pseudosloupec
<strong>distance</strong>, například následujícím způsobem:</p>

<pre>
<strong>SELECT</strong>
  <strong>rowid,</strong>
  <strong>distance</strong>
<strong>FROM vec_examples</strong>
<strong>WHERE sample_embedding MATCH '[0, 0.5, 0.5, 0., 0., 0., 0., 0.]'</strong>
<strong>ORDER BY distance</strong>
<strong>LIMIT 4;</strong>
</pre>

<p>Tento příkaz by měl vrátit čtveřici hodnot &ndash; vzdáleností od vektoru,
který byl zadán v&nbsp;příkazu <strong>SELECT</strong> v&nbsp;klauzuli
<strong>WHERE MATCH</strong>:</p>

<pre>
3|0.70710676908493
2|0.70710676908493
4|1.22474491596222
1|1.22474491596222
</pre>

<p>Podobný příkaz, ovšem pro vektor, který je v&nbsp;databázi uložen:</p>

<pre>
<strong>SELECT</strong>
  <strong>rowid,</strong>
  <strong>distance</strong>
<strong>FROM vec_examples</strong>
<strong>WHERE sample_embedding MATCH '[1, 0., 0., 0., 0., 0., 0., 0.]'</strong>
<strong>ORDER BY distance</strong>
<strong>LIMIT 4;</strong>
</pre>

<p>Asi nebude velkým překvapením, že první nalezený vektor bude mít nulovou
vzdálenost:</p>

<pre>
1|0.0
4|1.0
3|1.41421353816986
2|1.41421353816986
</pre>

<p>Pro čitelnější výsledky je vhodné zadat příkaz:</p>

<pre>
sqlite&gt; <strong>.mode qbox</strong>
</pre>

<p>Zkusme si výše uvedené příkazy zadat znovu:</p>

<pre>
sqlite&gt; <strong>select rowid, distance from vec_examples where sample_embedding match '[0, 0.5, 0.5, 0., 0., 0., 0., 0.]' order by distance limit 4;</strong>
</pre>

<p>Výsledky:</p>

<pre>
┌───────┬──────────────────┐
│ rowid │     distance     │
├───────┼──────────────────┤
│ 3     │ 0.70710676908493 │
│ 2     │ 0.70710676908493 │
│ 4     │ 1.22474491596222 │
│ 1     │ 1.22474491596222 │
└───────┴──────────────────┘
</pre>

<p>A:</p>

<pre>
sqlite&gt; <strong>select rowid, distance from vec_examples where sample_embedding match '[1, 0., 0., 0., 0., 0., 0., 0.]' order by distance limit 4;</strong>
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
┌───────┬──────────────────┐
│ rowid │     distance     │
├───────┼──────────────────┤
│ 1     │ 0.0              │
│ 4     │ 1.0              │
│ 3     │ 1.41421353816986 │
│ 2     │ 1.41421353816986 │
└───────┴──────────────────┘
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vizualizace výpočtů vzdáleností pro 2D vektory</h2>

<p>Na 2D vektory se můžeme (i když to není zcela přesné) dívat jako na koncové
souřadnice orientovaných šipek vycházejících z&nbsp;počátku kartézské soustavy
souřadnic. V&nbsp;případě, že si tyto souřadnice vykreslíme do plochy, získáme
například následující graf (do kterého jsem doplnil numerické souřadnice u
vybraných koncových bodů):</p>

<pre>
                                       │ y
                                       │
                                       │
                                       │
                                       │                [5,5]
                     o       o         │          o   o   o
                                       │          o   o   o
                         o             │          o   o   o
                      [-4, 3]          │
                                       │
─────────────────────────────────────[0,0]──────────────────────────────────────
                                       │                                       x
                                       │              o
                                       │
                                       │          o       o
                                       │                [5,-5]
                                       │
                                       │
                                       │
                                       │
</pre>

<p>Tento diagram obsahuje následující koncové souřadnice vektorů (použijeme je
později v&nbsp;reálné databázi):</p>

<table>
<tr><th>Souřadnice</th></tr>
<tr><td>[-5,  5]</td></tr>
<tr><td>[-4,  3]</td></tr>
<tr><td>[-3,  5]</td></tr>
<tr><td>[ 3, -5]</td></tr>
<tr><td>[ 4, -3]</td></tr>
<tr><td>[ 5, -5]</td></tr>
<tr><td>[ 3,  3]</td></tr>
<tr><td>[ 3,  4]</td></tr>
<tr><td>[ 3,  5]</td></tr>
<tr><td>[ 4,  3]</td></tr>
<tr><td>[ 4,  4]</td></tr>
<tr><td>[ 4,  5]</td></tr>
<tr><td>[ 5,  3]</td></tr>
<tr><td>[ 5,  4]</td></tr>
<tr><td>[ 5,  5]</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vytvoření a naplnění tabulky pro uložení 2D vektorů</h2>

<p>Podívejme se nyní podrobněji na způsob využití rozšíření
<strong>sqlite-vec</strong>. Nejdříve vytvoříme virtuální tabulku nazvanou
<strong>v2</strong>, která bude obsahovat jediný explicitně zadaný sloupec
s&nbsp;názvem <strong>embedding</strong>. Do tohoto sloupce se budou ukládat
dvouprvkové vektory, přičemž každý prvek bude typu <strong>float</strong>
(numerická hodnota s&nbsp;plovoucí řádovou čárkou):</p>

<pre>
CREATE virtual TABLE v2 USING vec0(
  embedding float[2]
);
</pre>

<p>Následně tabulku naplníme patnácti záznamy (vektory). Souřadnice těchto
vektorů odpovídají diagramu, který byl uveden <a href="#k06">v&nbsp;předchozí
kapitole</a>:</p>

<pre>
INSERT INTO v2(rowid, embedding) VALUES(1, '[-5,  5]');
INSERT INTO v2(rowid, embedding) VALUES(2, '[-4,  3]');
INSERT INTO v2(rowid, embedding) VALUES(3, '[-3,  5]');
INSERT INTO v2(rowid, embedding) VALUES(4, '[ 3, -5]');
INSERT INTO v2(rowid, embedding) VALUES(5, '[ 4, -3]');
INSERT INTO v2(rowid, embedding) VALUES(6, '[ 5, -5]');
INSERT INTO v2(rowid, embedding) VALUES(7, '[ 3,  3]');
INSERT INTO v2(rowid, embedding) VALUES(8, '[ 3,  4]');
INSERT INTO v2(rowid, embedding) VALUES(9, '[ 3,  5]');
INSERT INTO v2(rowid, embedding) VALUES(10, '[ 4,  3]');
INSERT INTO v2(rowid, embedding) VALUES(11, '[ 4,  4]');
INSERT INTO v2(rowid, embedding) VALUES(12, '[ 4,  5]');
INSERT INTO v2(rowid, embedding) VALUES(13, '[ 5,  3]');
INSERT INTO v2(rowid, embedding) VALUES(14, '[ 5,  4]');
INSERT INTO v2(rowid, embedding) VALUES(15, '[ 5,  5]');
</pre>

<p>Pro jistotu si ověříme, že tabulka <strong>v2</strong> skutečně obsahuje
patnáct záznamů:</p>

<pre>
sqlite&gt; <strong>select count(*) from v2;</strong>
15
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Výpis obsahu tabulky se sloupcem s&nbsp;vektory</h2>

<p>Pokusme se vypsat všech patnáct záznamů, které jsou v&nbsp;tabulce
<strong>v2</strong> uloženy. Nastavíme hezčí (nebo &bdquo;hezčí&ldquo;) způsob
výpisu příkazem <strong>.mode</strong> a poté spustíme standardní dotaz
<strong>select</strong>:</p>

<pre>
sqlite&gt; <strong>.mode qbox</strong>
&nbsp;
sqlite&gt; <strong>select * from v2;</strong>
</pre>

<p>Z&nbsp;výpisu je patrné, že tabulka ve skutečnosti obsahuje ještě sloupec
<strong>rowid</strong>, který jsme sice při definici tabulky nepožadovali, ale
který byl doplněn automaticky. A taktéž je patrné, že se obsah vektorů zobrazil
v&nbsp;hexadecimální (interní) podobě; každý vektor jako osmice bajtů:</p>

<pre>
┌───────┬─────────────────────┐
│ rowid │      embedding      │
├───────┼─────────────────────┤
│ 1     │ x'0000a0c00000a040' │
│ 2     │ x'000080c000004040' │
│ 3     │ x'000040c00000a040' │
│ 4     │ x'000040400000a0c0' │
│ 5     │ x'00008040000040c0' │
│ 6     │ x'0000a0400000a0c0' │
│ 7     │ x'0000404000004040' │
│ 8     │ x'0000404000008040' │
│ 9     │ x'000040400000a040' │
│ 10    │ x'0000804000004040' │
│ 11    │ x'0000804000008040' │
│ 12    │ x'000080400000a040' │
│ 13    │ x'0000a04000004040' │
│ 14    │ x'0000a04000008040' │
│ 15    │ x'0000a0400000a040' │
└───────┴─────────────────────┘
</pre>

<p>Abychom získali vektory v&nbsp;čitelné podobě, musíme použít malý trik
&ndash; necháme si obsah vektorů převést na JSON, tedy v&nbsp;tomto případě
konkrétně na seznam s&nbsp;dvojicí numerických hodnot:</p>

<pre>
sqlite&gt; <strong>select rowid, vec_to_json(embedding) from v2;</strong>
</pre>

<p>Nyní bude výpis snadno čitelný:</p>

<pre>
┌───────┬────────────────────────┐
│ rowid │ vec_to_json(embedding) │
├───────┼────────────────────────┤
│ 1     │ '[-5.000000,5.000000]' │
│ 2     │ '[-4.000000,3.000000]' │
│ 3     │ '[-3.000000,5.000000]' │
│ 4     │ '[3.000000,-5.000000]' │
│ 5     │ '[4.000000,-3.000000]' │
│ 6     │ '[5.000000,-5.000000]' │
│ 7     │ '[3.000000,3.000000]'  │
│ 8     │ '[3.000000,4.000000]'  │
│ 9     │ '[3.000000,5.000000]'  │
│ 10    │ '[4.000000,3.000000]'  │
│ 11    │ '[4.000000,4.000000]'  │
│ 12    │ '[4.000000,5.000000]'  │
│ 13    │ '[5.000000,3.000000]'  │
│ 14    │ '[5.000000,4.000000]'  │
│ 15    │ '[5.000000,5.000000]'  │
└───────┴────────────────────────┘
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vyhledávání na základě vzdálenosti vektorů</h2>

<p>Nyní se pokusme vyhledat tři nejbližší vektory k&nbsp;vektoru [-4, 4]:</p>

<pre>
<strong>SELECT rowid, distance FROM v2 WHERE embedding MATCH '[-4, 4]' ORDER BY distance LIMIT 3;</strong>
</pre>

<p>Výsledky by měly vypadat následovně (druhé dvě hodnoty odpovídají mocnině
dvou, tedy vzdálenosti bodů po úhlopříčce):</p>

<pre>
┌───────┬──────────────────┐
│ rowid │     distance     │
├───────┼──────────────────┤
│ 2     │ 1.0              │
│ 3     │ 1.41421353816986 │
│ 1     │ 1.41421353816986 │
└───────┴──────────────────┘
</pre>

<p>Což si pochopitelně můžeme vizualizovat v&nbsp;rovině (hvězdičkou je
naznačen vektor z&nbsp;podmínky, kolečkem vektory vrácené jako výsledek dotazu
a tečkou ostatní vektory, které neodpovídají dotazu):</p>

<pre>
                                       │ y
                                       │
                                       │
                                       │
                                       │
                     o       o         │          .   .   .
                         *             │          .   .   .
                         o             │          .   .   .
                                       │
                                       │
─────────────────────────────────────[0,0]──────────────────────────────────────
                                       │                                       x
                                       │
                                       │              .
                                       │
                                       │          .       .
                                       │
                                       │
                                       │
                                       │
</pre>

<p>Podobně můžeme získat pět vektorů, které jsou nejpodobnější vektoru [4,
4]:</p>

<pre>
<strong>SELECT rowid, distance FROM v2 WHERE embedding MATCH '[4, 4]' ORDER BY distance LIMIT 5;</strong>
</pre>

<p>Získané výsledky:</p>

<pre>
┌───────┬──────────┐
│ rowid │ distance │
├───────┼──────────┤
│ 11    │ 0.0      │
│ 14    │ 1.0      │
│ 12    │ 1.0      │
│ 10    │ 1.0      │
│ 8     │ 1.0      │
└───────┴──────────┘
</pre>

<p>Výsledných pět vrácených vektorů si opět zobrazíme v&nbsp;2D rovině (první
bod/vektor je totožný se zadaným vektorem):</p>

<pre>
                                       │ y
                                       │
                                       │
                                       │
                                       │
                     .       .         │          .   o   .
                         .             │          o   *   o
                         .             │          .   o   .
                                       │
                                       │
─────────────────────────────────────[0,0]──────────────────────────────────────
                                       │                                       x
                                       │
                                       │              .
                                       │
                                       │          .       .
                                       │
                                       │
                                       │
                                       │
</pre>

<p>Tři vektory nejpodobnější vektoru [3, 3]:</p>

<pre>
<strong>SELECT rowid, distance FROM v2 WHERE embedding MATCH '[3, 3]' ORDER BY distance LIMIT 3;</strong>
</pre>

<p>Výsledky:</p>

<pre>
┌───────┬──────────┐
│ rowid │ distance │
├───────┼──────────┤
│ 7     │ 0.0      │
│ 10    │ 1.0      │
│ 8     │ 1.0      │
└───────┴──────────┘
</pre>

<p>V&nbsp;2D rovině budou výsledky vypadat takto:</p>

<pre>
                                       │ y
                                       │
                                       │
                                       │
                                       │
                     .       .         │          .   .   .
                         .             │          o   .   .
                         .             │          *   o   .
                                       │
                                       │
─────────────────────────────────────[0,0]──────────────────────────────────────
                                       │                                       x
                                       │
                                       │              .
                                       │
                                       │          .       .
                                       │
                                       │
                                       │
                                       │
</pre>

<p>A konečně vzdálenosti nejbližších deseti vektorů:</p>

<pre>
sqlite&gt; <strong>SELECT rowid, distance FROM v2 WHERE embedding MATCH '[3, 3]' and k=10;</strong>
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
┌───────┬──────────────────┐
│ rowid │     distance     │
├───────┼──────────────────┤
│ 7     │ 0.0              │
│ 10    │ 1.0              │
│ 8     │ 1.0              │
│ 11    │ 1.41421353816986 │
│ 13    │ 2.0              │
│ 9     │ 2.0              │
│ 14    │ 2.2360680103302  │
│ 12    │ 2.2360680103302  │
│ 15    │ 2.82842707633972 │
│ 5     │ 6.08276271820068 │
└───────┴──────────────────┘
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Tabulky obsahující jak sloupec s&nbsp;vektory, tak i sloupce s&nbsp;dalšími daty</h2>

<p>Samozřejmě je možné, aby virtuální tabulka obsahující sloupec s&nbsp;vektory
obsahovala i další sloupce, například s&nbsp;původními texty (před embeddingem)
atd. Ukažme si tuto vlastnost na příkladu tabulky pojmenované
<strong>v3</strong>, která kromě sloupce <strong>embedding</strong>
s&nbsp;vektory obsahuje i sloupec <strong>name</strong>, jenž může obsahovat
běžný text:</p>

<pre>
CREATE virtual TABLE v3 USING vec0(
  embedding float[2],
  name text
);
</pre>

<p>Tabulku naplníme našimi patnácti vektory a navíc ještě doplníme nějaké
texty:</p>

<pre>
INSERT INTO v3(rowid, embedding, name) VALUES(1, '[-5,  5]', 'one');
INSERT INTO v3(rowid, embedding, name) VALUES(2, '[-4,  3]', 'two');
INSERT INTO v3(rowid, embedding, name) VALUES(3, '[-3,  5]', 'three');
INSERT INTO v3(rowid, embedding, name) VALUES(4, '[ 3, -5]', 'four');
INSERT INTO v3(rowid, embedding, name) VALUES(5, '[ 4, -3]', 'five');
INSERT INTO v3(rowid, embedding, name) VALUES(6, '[ 5, -5]', 'six');
INSERT INTO v3(rowid, embedding, name) VALUES(7, '[ 3,  3]', 'seven');
INSERT INTO v3(rowid, embedding, name) VALUES(8, '[ 3,  4]', 'eight');
INSERT INTO v3(rowid, embedding, name) VALUES(9, '[ 3,  5]', 'nine');
INSERT INTO v3(rowid, embedding, name) VALUES(10, '[ 4,  3]', 'ten');
INSERT INTO v3(rowid, embedding, name) VALUES(11, '[ 4,  4]', 'evelen');
INSERT INTO v3(rowid, embedding, name) VALUES(12, '[ 4,  5]', 'twelve');
INSERT INTO v3(rowid, embedding, name) VALUES(13, '[ 5,  3]', 'thirteen');
INSERT INTO v3(rowid, embedding, name) VALUES(14, '[ 5,  4]', 'fourteen');
INSERT INTO v3(rowid, embedding, name) VALUES(15, '[ 5,  5]', 'fifteen');
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Výpis hodnot podle vzdálenosti</h2>

<p>V&nbsp;tomto okamžiku může dotaz (podle očekávání) obsahovat i pokyn
k&nbsp;výpisu jak vzdálenosti, tak i obsahu získaného ze sloupce
s&nbsp;textem:</p>

<pre>
sqlite&gt; <strong>.mode qbox</strong>
sqlite&gt; <strong>SELECT rowid, distance, name FROM v3 WHERE embedding MATCH '[-4, 4]' ORDER BY distance LIMIT 10;</strong>
</pre>

<p>Ze zobrazených výsledků je patrné, že vše pracuje podle očekávání,
tj.&nbsp;vypíšou se jak vypočtené vzdálenosti, tak i obsahy sloupce
<strong>name</strong>:</p>

<pre>
┌───────┬──────────────────┬────────────┐
│ rowid │     distance     │    name    │
├───────┼──────────────────┼────────────┤
│ 2     │ 1.0              │ 'two'      │
│ 3     │ 1.41421353816986 │ 'three'    │
│ 1     │ 1.41421353816986 │ 'one'      │
│ 8     │ 7.0              │ 'eight'    │
│ 9     │ 7.07106781005859 │ 'nine'     │
│ 7     │ 7.07106781005859 │ 'seven'    │
│ 11    │ 8.0              │ 'evelen'   │
│ 12    │ 8.06225776672363 │ 'twelve'   │
│ 10    │ 8.06225776672363 │ 'ten'      │
│ 14    │ 9.0              │ 'fourteen' │
└───────┴──────────────────┴────────────┘
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Využití databáze SQLite s&nbsp;rozšířením SQLite-vec z&nbsp;Pythonu</h2>

<p>Ve druhé části dnešního článku si ukážeme základní způsoby využití rozšíření
<strong>SQLite-vec</strong> z&nbsp;programovacího jazyka Python. Demonstrační
příklady budou postaveny nad balíčkem <strong>sqllite-vec</strong>, který však
(což je logické) ke své činnosti vyžaduje i balíček <strong>sqlite3</strong>,
který je v&nbsp;současnosti součástí standardní knihovny Pythonu (viz <a
href="https://docs.python.org/3/library/sqlite3.html">sqlite3 &ndash; DB-API
2.0 interface for SQLite databases</a>. Oba balíčky zajišťují jednoduché
načtení rozšíření <strong>sqlite-vec</strong>, takže se programátor nemusí
příliš starat o to, kde je vlastně umístěna příslušná sdílená nativní knihovna.
A současně jsou k&nbsp;dispozici i pomocné funkce zajišťující převod seznamů a
popř.&nbsp;i n-dimenzionálních polí (<strong>ndarray</strong>) na vektory. Tyto
konverzní funkce se používají jak při manipulaci s&nbsp;daty uloženými
v&nbsp;databázi (<i>insert</i>, <i>update</i>, <i>delete</i>), tak i při
provádění dotazů (<i>query</i>).</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Instalace balíčku <strong>sqllite-vec</strong></h2>

<p>Druhá část tohoto článku je zaměřena na praktické ukázky použití knihovny
s&nbsp;vektorovým rozšířením SQLlite. Musíme si tedy připravit projekt
v&nbsp;Pythonu a následně do něj knihovnu <strong>sqlite-vec</strong> přidat
formou přímé závislosti (<i>dependency</i>). Pro vytvoření projektu použijeme
buď nástroj <i>PDM</i> &ndash; viz též <a
href="https://www.root.cz/clanky/pdm-moderni-spravce-balicku-a-virtualnich-prostredi-pythonu/">PDM:
moderní správce balíčků a virtuálních prostředí Pythonu</a> nebo (což je
v&nbsp;současnosti výhodnější) nástroj <a
href="https://docs.astral.sh/uv/">uv</a>:</p>

<pre>
$ <strong>uv init test-sqlite-vec</strong>
&nbsp;
Initialized project `test-sqlite-vec`
</pre>

<p>Následně do projektu přidáme nový balíček <strong>sqlite-vec</strong>, který
bude nainstalován do virtuálního prostředí Pythonu:</p>

<pre>
$ <strong>uv add sqlite-vec</strong>
&nbsp;
Using CPython 3.13.9 interpreter at: /usr/bin/python3.13
Creating virtual environment at: .venv
Resolved 2 packages in 258ms
Prepared 1 package in 156ms
Installed 1 package in 3ms
 + sqlite-vec==0.1.6
</pre>

<p>Výsledný projektový soubor bude vypadat takto:</p>

<pre>
[project]
name = "test-sqlite-vec"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = "&gt;=3.13"
dependencies = [
    "sqlite-vec&gt;=0.1.6",
]
</pre>

<p>Od této chvíle je nutné všechny dále uvedené příklady spouštět takto:</p>

<pre>
$ <strong>uv run jméno_skriptu</strong>
</pre>

<p>Dále si můžete doinstalovat &ndash; i když to dnes není zapotřebí &ndash; i
užitečný balíček <strong>sqlite-utils</strong>, který vlastně slouží jako
manažer celého ekosystému postaveného nad SQLite:</p>

<pre>
$ <strong>uv add sqlite-utils</strong>
&nbsp;
Resolved 12 packages in 363ms
Prepared 9 packages in 428ms
Installed 9 packages in 22ms
 + click==8.3.1
 + click-default-group==1.2.4
 + pip==25.3
 + pluggy==1.6.0
 + python-dateutil==2.9.0.post0
 + six==1.17.0
 + sqlite-fts4==1.0.3
 + sqlite-utils==3.39
 + tabulate==0.9.0
</pre>

<p>Jak se tento balíček používá? Jedná se o nový příkaz, kterým lze například
doinstalovat další rozšíření knihovny SQLite atd. Pro zajímavost si uveďme
příklad jeho použití:</p>

<pre>
$ <strong>uv run sqlite-utils install sqlite-utils-sqlite-vec</strong>
&nbsp;
Collecting sqlite-utils-sqlite-vec
  Downloading sqlite_utils_sqlite_vec-0.1.6-py3-none-any.whl.metadata (275 bytes)
Requirement already satisfied: sqlite-utils in ./.venv/lib64/python3.13/site-packages (from sqlite-utils-sqlite-vec) (3.39)
Requirement already satisfied: sqlite-vec==0.1.6 in ./.venv/lib64/python3.13/site-packages (from sqlite-utils-sqlite-vec) (0.1.6)
Requirement already satisfied: sqlite-fts4 in ./.venv/lib64/python3.13/site-packages (from sqlite-utils-&gt;sqlite-utils-sqlite-vec) (1.0.3)
Requirement already satisfied: click&gt;=8.3.1 in ./.venv/lib64/python3.13/site-packages (from sqlite-utils-&gt;sqlite-utils-sqlite-vec) (8.3.1)
Requirement already satisfied: click-default-group&gt;=1.2.3 in ./.venv/lib64/python3.13/site-packages (from sqlite-utils-&gt;sqlite-utils-sqlite-vec) (1.2.4)
Requirement already satisfied: tabulate in ./.venv/lib64/python3.13/site-packages (from sqlite-utils-&gt;sqlite-utils-sqlite-vec) (0.9.0)
Requirement already satisfied: python-dateutil in ./.venv/lib64/python3.13/site-packages (from sqlite-utils-&gt;sqlite-utils-sqlite-vec) (2.9.0.post0)
Requirement already satisfied: pluggy in ./.venv/lib64/python3.13/site-packages (from sqlite-utils-&gt;sqlite-utils-sqlite-vec) (1.6.0)
Requirement already satisfied: pip in ./.venv/lib64/python3.13/site-packages (from sqlite-utils-&gt;sqlite-utils-sqlite-vec) (25.3)
Requirement already satisfied: six&gt;=1.5 in ./.venv/lib64/python3.13/site-packages (from python-dateutil-&gt;sqlite-utils-&gt;sqlite-utils-sqlite-vec) (1.17.0)
Downloading sqlite_utils_sqlite_vec-0.1.6-py3-none-any.whl (2.3 kB)
Installing collected packages: sqlite-utils-sqlite-vec
Successfully installed sqlite-utils-sqlite-vec-0.1.6
</pre>

<p>Výsledný projektový soubor bude vypadat takto:</p>

<pre>
[project]
name = "test-sqlite-vec"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = "&gt;=3.13"
dependencies = [
    "sqlite-utils&gt;=3.39",
    "sqlite-vec&gt;=0.1.6",
]
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Zjištění verze rozšíření SQLite-vec</h2>

<p>Nyní, když již máme nainstalovány všechny potřebné balíčky Pythonu, si
můžeme vyzkoušet, jakým způsobem se s&nbsp;balíčkem
<strong>sqlite-vec</strong>pracuje. V&nbsp;dnešním prvním Pythonovském
demonstračním příkladu je nejdříve provedeno připojení k&nbsp;databázi uložené
v&nbsp;souboru <strong>v0.db</strong>. Pokud tato databáze a/nebo soubor
neexistuje, dojde k&nbsp;jejich vytvoření:</p>

<pre>
db = sqlite3.connect("v0.db")
</pre>

<p>Následně načteme vektorové rozšíření. Tato operace by měla proběhnout
korektně, protože nativní sdílená knihovna je součástí virtuálního prostředí
Pythonu:</p>

<pre>
db.enable_load_extension(True)
sqlite_vec.load(db)
db.enable_load_extension(False)
</pre>

<p>V&nbsp;posledním kroku si necháme vypsat verzi rozšíření:</p>

<pre>
vec_version, = db.execute("select vec_version()").fetchone()
print(f"vec_version={vec_version}")
</pre>

<p>Pokud byly dodrženy všechny kroky uvedené <a href="#k13">v&nbsp;předchozí
kapitole</a>, měl by tento příklad vypsat:</p>

<pre>
vec_version=v0.1.6
</pre>

<p>Následuje výpis celého zdrojového kódu tohoto demonstračního příkladu:</p>

<pre>
<i># Knihovna SQLite s rozšířením SQLite-vec</i>
<i>#</i>
<i># - připojení k databázi uložené v souboru</i>
<i># - databáze je v případě potřeby vytvořena (nový soubor)</i>
<i># - načtení rozšíření SQLite-vec</i>
<i># - tisk verze rozšíření SQLite-vec</i>
&nbsp;
import sqlite3
import sqlite_vec
&nbsp;
<i># připojení k databázi uložené v souboru</i>
<i># v případě potřeby je databáze vytvořena</i>
db = sqlite3.connect("v0.db")
&nbsp;
<i># načtení rozšíření SQLite-vec</i>
db.enable_load_extension(True)
sqlite_vec.load(db)
db.enable_load_extension(False)
&nbsp;
<i># tisk verze rozšíření SQLite-vec</i>
vec_version, = db.execute("select vec_version()").fetchone()
print(f"vec_version={vec_version}")
</pre>

<p>SQLite navíc umožňuje vytvoření databáze pouze v&nbsp;operační paměti,
tj.&nbsp;bez toho, aby se databáze ukládala do reálného souboru. Pro tento účel
je nutné při připojování k&nbsp;databází použít &bdquo;magické&ldquo; jméno
<strong>:memory:</strong>:</p>

<pre>
db = sqlite3.connect(":memory:")
</pre>

<p>Skript po této úpravě bude vypadat následovně:</p>

<pre>
<i># Knihovna SQLite s rozšířením SQLite-vec</i>
<i>#</i>
<i># - připojení k databázi uložené v paměti</i>
<i># - databáze je (nutně) vždy vytvořena</i>
<i># - načtení rozšíření SQLite-vec</i>
<i># - tisk verze rozšíření SQLite-vec</i>
&nbsp;
import sqlite3
import sqlite_vec
&nbsp;
<i># připojení k databázi uložené v paměti</i>
<i># databáze je vždy vytvořena</i>
db = sqlite3.connect(":memory:")
&nbsp;
<i># načtení rozšíření SQLite-vec</i>
db.enable_load_extension(True)
sqlite_vec.load(db)
db.enable_load_extension(False)
&nbsp;
<i># tisk verze rozšíření SQLite-vec</i>
vec_version, = db.execute("select vec_version()").fetchone()
print(f"vec_version={vec_version}")
</pre>

<p>Výsledkem však bude naprosto stejná zpráva s&nbsp;informací o verzi
vektorového rozšíření:</p>

<pre>
vec_version=v0.1.6
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Vytvoření virtuální tabulky s&nbsp;vektory</h2>

<p>V&nbsp;dalším kroku pochopitelně budeme muset vytvořit tabulku, která
obsahuje sloupec nebo sloupce určené pro uložení vektorů (pochopitelně
s&nbsp;předem známým počtem prvků). Je přitom nutné, aby již bylo načteno
vektorové rozšíření, což jsme si ukázali v&nbsp;předchozí kapitole.</p>

<p>Při práci s&nbsp;relačními databázemi v&nbsp;Pythonu se typicky postupuje
takovým způsobem, že se nejdříve získá <i>kurzor</i> a další příkazy pro
manipulaci s&nbsp;daty nebo pro dotazy se provádí přes tento objekt. Ovšem
standardní balíček <strong>sqlite3</strong> nabízí v&nbsp;tomto případě
&bdquo;zkratku&ldquo;, protože příkazy pro manipulaci s&nbsp;daty (ale i
například pro vytvoření tabulky atd.) lze provádět přímo nad objektem, který
získáme po připojení k&nbsp;databázi.</p>

<p>Celý postup, při kterém vytvoříme virtuální tabulku, tedy může vypadat
následovně:</p>

<pre>
db = sqlite3.connect("v1.db")
&nbsp;
<strong>TABLE_STATEMENT</strong> = """
    CREATE virtual TABLE v1 USING vec0(
        embedding float[2]
    );
"""
&nbsp;
db.execute(TABLE_STATEMENT)
&nbsp;
db.commit()
db.close()
</pre>

<p>Následuje úplný zdrojový kód dnešního třetího demonstračního příkladu
napsaného v&nbsp;Pythonu:</p>

<pre>
<i># Knihovna SQLite s rozšířením SQLite-vec</i>
<i>#</i>
<i># - připojení k databázi uložené v souboru</i>
<i># - databáze je v případě potřeby vytvořena</i>
<i># - načtení rozšíření SQLite-vec</i>
<i># - vytvoření virtuální tabulky s jedním sloupcem</i>
<i># - nepoužívá se kurzor (zkrácený zápis)</i>
&nbsp;
import sqlite3
import sqlite_vec
&nbsp;
<i># připojení k databázi uložené v souboru</i>
<i># v případě potřeby je databáze vytvořena</i>
db = sqlite3.connect("v1.db")
&nbsp;
<i># načtení rozšíření SQLite-vec</i>
db.enable_load_extension(True)
sqlite_vec.load(db)
db.enable_load_extension(False)
&nbsp;
<strong>TABLE_STATEMENT</strong> = """
    CREATE virtual TABLE v1 USING vec0(
        embedding float[2]
    );
"""
&nbsp;
<i># vytvoření virtuální tabulky</i>
result = db.execute(TABLE_STATEMENT)
print(result)
&nbsp;
db.commit()
db.close()
</pre>

<p>V&nbsp;praxi je však výhodnější se explicitnímu odpojení od databáze vyhnout
(kvůli nutnosti zachytávání výjimek atd.) a použít namísto toho <i>context
manager</i>. Zápis je čitelnější, kratší a navíc i bezpečnější (databázi zavře
i při vzniku výjimky):</p>

<pre>
with sqlite3.connect("v1.db") as db:
    <strong>TABLE_STATEMENT</strong> = """
        CREATE virtual TABLE v1 USING vec0(
            embedding float[2]
        );
    """
&nbsp;
    db.execute(TABLE_STATEMENT)
&nbsp;
    db.commit()
</pre>

<p>Výsledná podoba demonstračního příkladu:</p>

<pre>
<i># Knihovna SQLite s rozšířením SQLite-vec</i>
<i>#</i>
<i># - připojení k databázi uložené v souboru</i>
<i># - databáze je v případě potřeby vytvořena</i>
<i># - načtení rozšíření SQLite-vec</i>
<i># - vytvoření virtuální tabulky s jedním sloupcem</i>
<i># - využití kontext manažeru</i>
<i># - nepoužívá se kurzor (zkrácený zápis)</i>
&nbsp;
import sqlite3
import sqlite_vec
&nbsp;
<i># připojení k databázi uložené v souboru</i>
<i># v případě potřeby je databáze vytvořena</i>
with sqlite3.connect("v1.db") as db:
    <i># načtení rozšíření SQLite-vec</i>
    db.enable_load_extension(True)
    sqlite_vec.load(db)
    db.enable_load_extension(False)
&nbsp;
    <strong>TABLE_STATEMENT</strong> = """
        CREATE virtual TABLE v1 USING vec0(
            embedding float[2]
        );
    """
&nbsp;
    <i># vytvoření virtuální tabulky</i>
    result = db.execute(TABLE_STATEMENT)
    print(result)
&nbsp;
    db.commit()
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Naplnění tabulek s&nbsp;vektory</h2>

<p>Tabulku, resp.&nbsp;přesněji řečeno virtuální tabulku, která byla vytvořena
skripty uvedenými <a href="#k15">v&nbsp;předchozí kapitole</a>, je pochopitelně
možné naplnit záznamy, které obsahují dvouprvkové vektory. V&nbsp;knihovně
<strong>sqlite_vec</strong> je mj.&nbsp;dostupná i funkce nazvaná
<strong>serialize_float32</strong>, která dokáže převést obsah běžného
Pythonovského seznamu na vektor, jenž je možné uložit do databáze. Můžeme tedy
provést například tuto operaci:</p>

<pre>
<strong>INSERT_STATEMENT</strong> = "INSERT INTO v2(embedding) VALUES(?)"
&nbsp;
db.execute(INSERT_STATEMENT, [sqlite_vec.serialize_float32([1, 2])])
</pre>

<p>V&nbsp;tomto demonstračním příkladu opět používáme &bdquo;zkratku&ldquo;,
protože voláme přímo metodu <strong>execute</strong> nad objektem získaným po
připojení do databáze. V&nbsp;případě, že se použije odlišná databáze (což zde
nemá smysl) by se musel vytvořit kurzor:</p>

<pre>
<i># Knihovna SQLite s rozšířením SQLite-vec</i>
<i>#</i>
<i># - připojení k databázi uložené v souboru</i>
<i># - databáze je v případě potřeby vytvořena</i>
<i># - načtení rozšíření SQLite-vec</i>
<i># - vytvoření virtuální tabulky</i>
<i># - naplnění tabulky několika vektory</i>
&nbsp;
import sqlite3
import sqlite_vec
&nbsp;
<i># připojení k databázi uložené v souboru</i>
<i># v případě potřeby je databáze vytvořena</i>
with sqlite3.connect("v2.db") as db:
    <i># načtení rozšíření SQLite-vec</i>
    db.enable_load_extension(True)
    sqlite_vec.load(db)
    db.enable_load_extension(False)
&nbsp;
    <strong>TABLE_STATEMENT</strong> = """
        CREATE virtual TABLE v2 USING vec0(
            embedding float[2]
        );
    """
&nbsp;
    db.execute(TABLE_STATEMENT)
&nbsp;
    <strong>INSERT_STATEMENT</strong> = "INSERT INTO v2(embedding) VALUES(?)"
&nbsp;
    db.execute(INSERT_STATEMENT, [sqlite_vec.serialize_float32([1, 2])])
    db.execute(INSERT_STATEMENT, [sqlite_vec.serialize_float32([1, 2])])
    db.execute(INSERT_STATEMENT, [sqlite_vec.serialize_float32([1, 2])])
&nbsp;
    db.commit()
</pre>

<p>Výše uvedený demonstrační příklad nyní nepatrně upravíme, a to tak, abychom
do (nové) virtuální tabulky uložili všech patnáct vektorů v&nbsp;2D, které byly
použity v&nbsp;úvodní části dnešního článku. Vektory jsou původně
reprezentovány seznamem seznamů a do tabulky jsou vloženy ve smyčce (což ovšem
není nejrychlejší způsob):</p>

<pre>
<i># Knihovna SQLite s rozšířením SQLite-vec</i>
<i>#</i>
<i># - připojení k databázi uložené v souboru</i>
<i># - databáze je v případě potřeby vytvořena</i>
<i># - načtení rozšíření SQLite-vec</i>
<i># - vytvoření virtuální tabulky</i>
<i># - naplnění tabulky patnácti vektory</i>
&nbsp;
import sqlite3
import sqlite_vec
&nbsp;
<i># připojení k databázi uložené v souboru</i>
<i># v případě potřeby je databáze vytvořena</i>
with sqlite3.connect("v2.db") as db:
    <i># načtení rozšíření SQLite-vec</i>
    db.enable_load_extension(True)
    sqlite_vec.load(db)
    db.enable_load_extension(False)
&nbsp;
    <strong>TABLE_STATEMENT</strong> = """
    CREATE virtual TABLE v2 USING vec0(
        embedding float[2]
    );
    """
&nbsp;
    db.execute(TABLE_STATEMENT)
&nbsp;
    <strong>INSERT_STATEMENT</strong> = "INSERT INTO v2(rowid, embedding) VALUES(?, ?)"
&nbsp;
    data_to_insert = [
        [1, [-5,  5]],
        [2, [-4,  3]],
        [3, [-3,  5]],
        [4, [ 3, -5]],
        [5, [ 4, -3]],
        [6, [ 5, -5]],
        [7, [ 3,  3]],
        [8, [ 3,  4]],
        [9, [ 3,  5]],
        [10, [ 4,  3]],
        [11, [ 4,  4]],
        [12, [ 4,  5]],
        [13, [ 5,  3]],
        [14, [ 5,  4]],
        [15, [ 5,  5]],
    ]
&nbsp;
    for data in data_to_insert:
        print(f"Inserting {data[1]}")
        db.execute(INSERT_STATEMENT, [data[0], sqlite_vec.serialize_float32(data[1])])
&nbsp;
    db.commit()
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Dotazy: zjištění nejbližších vektorů</h2>

<p>V&nbsp;poslední dvojici demonstračních příkladů nejenže vytvoříme virtuální
tabulku a naplníme ji daty (vektory), ale taktéž provedeme dotaz, který zjistí
tři nejbližší vektory k&nbsp;vektoru zadanému. Se znalostmi z&nbsp;předchozích
kapitol by měl být tento příklad snadno pochopitelný:</p>

<pre>
<i># Knihovna SQLite s rozšířením SQLite-vec</i>
<i>#</i>
<i># - připojení k databázi uložené v paměti</i>
<i># - načtení rozšíření SQLite-vec</i>
<i># - vytvoření virtuální tabulky</i>
<i># - naplnění tabulky patnácti vektory</i>
<i># - nalezení tří vektorů nejbližích k [-4, 4]</i>
&nbsp;
import sqlite3
import sqlite_vec
&nbsp;
<i># připojení k databázi uložené v souboru</i>
<i># v případě potřeby je databáze vytvořena</i>
with sqlite3.connect(":memory:") as db:
    <i># načtení rozšíření SQLite-vec</i>
    db.enable_load_extension(True)
    sqlite_vec.load(db)
    db.enable_load_extension(False)
&nbsp;
    <strong>TABLE_STATEMENT</strong> = """
    CREATE virtual TABLE v2 USING vec0(
        embedding float[2]
    );
    """
&nbsp;
    db.execute(TABLE_STATEMENT)
&nbsp;
    <strong>INSERT_STATEMENT</strong> = "INSERT INTO v2(rowid, embedding) VALUES(?, ?)"
&nbsp;
    data_to_insert = [
        [1, [-5,  5]],
        [2, [-4,  3]],
        [3, [-3,  5]],
        [4, [ 3, -5]],
        [5, [ 4, -3]],
        [6, [ 5, -5]],
        [7, [ 3,  3]],
        [8, [ 3,  4]],
        [9, [ 3,  5]],
        [10, [ 4,  3]],
        [11, [ 4,  4]],
        [12, [ 4,  5]],
        [13, [ 5,  3]],
        [14, [ 5,  4]],
        [15, [ 5,  5]],
    ]
&nbsp;
    for data in data_to_insert:
        print(f"Inserting {data[1]}")
        db.execute(INSERT_STATEMENT, [data[0], sqlite_vec.serialize_float32(data[1])])
&nbsp;
    db.commit()
&nbsp;
    <strong>SELECT_STATEMENT</strong> = """
        SELECT
          rowid,
          distance
        FROM v2
        WHERE embedding MATCH ?
        ORDER BY distance
        LIMIT 3
    """
&nbsp;
    print()
    print("Finding vectors close to [-4, 4]")
    results = db.execute(SELECT_STATEMENT, [sqlite_vec.serialize_float32([-4, 4])]).fetchall()
&nbsp;
    for result in results:
        print(result)
</pre>

<p>V&nbsp;dnešním posledním demonstračním příkladu je naznačeno, že i hodnota
předaná v&nbsp;klauzuli <strong>LIMIT</strong> je volitelná, resp.&nbsp;že se
jedná o parametr, který může být databázi předán při pokládání dotazu:</p>

<pre>
<i># Knihovna SQLite s rozšířením SQLite-vec</i>
<i>#</i>
<i># - připojení k databázi uložené v paměti</i>
<i># - načtení rozšíření SQLite-vec</i>
<i># - vytvoření virtuální tabulky</i>
<i># - naplnění tabulky patnácti vektory</i>
<i># - nalezení pěti vektorů nejbližích k [4, 4]</i>
&nbsp;
import sqlite3
import sqlite_vec
&nbsp;
<i># připojení k databázi uložené v souboru</i>
<i># v případě potřeby je databáze vytvořena</i>
with sqlite3.connect(":memory:") as db:
    <i># načtení rozšíření SQLite-vec</i>
    db.enable_load_extension(True)
    sqlite_vec.load(db)
    db.enable_load_extension(False)
&nbsp;
    <strong>TABLE_STATEMENT</strong> = """
    CREATE virtual TABLE v2 USING vec0(
        embedding float[2]
    );
    """
&nbsp;
    db.execute(TABLE_STATEMENT)
&nbsp;
    <strong>INSERT_STATEMENT</strong> = "INSERT INTO v2(rowid, embedding) VALUES(?, ?)"
&nbsp;
    data_to_insert = [
        [1, [-5,  5]],
        [2, [-4,  3]],
        [3, [-3,  5]],
        [4, [ 3, -5]],
        [5, [ 4, -3]],
        [6, [ 5, -5]],
        [7, [ 3,  3]],
        [8, [ 3,  4]],
        [9, [ 3,  5]],
        [10, [ 4,  3]],
        [11, [ 4,  4]],
        [12, [ 4,  5]],
        [13, [ 5,  3]],
        [14, [ 5,  4]],
        [15, [ 5,  5]],
    ]
&nbsp;
    for data in data_to_insert:
        print(f"Inserting {data[1]}")
        db.execute(INSERT_STATEMENT, [data[0], sqlite_vec.serialize_float32(data[1])])
&nbsp;
    db.commit()
&nbsp;
    <strong>SELECT_STATEMENT</strong> = """
        SELECT
          rowid,
          distance
        FROM v2
        WHERE embedding MATCH ?
        ORDER BY distance
        LIMIT ?
    """
&nbsp;
    print()
    print("Finding vectors close to [4, 4]")
    results = db.execute(SELECT_STATEMENT, [sqlite_vec.serialize_float32([4, 4]), 5]).fetchall()
&nbsp;
    for result in results:
        print(result)
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady, s&nbsp;nimiž jsme se dnes seznámili a které jsou
určeny pro Python 3.11 (a libovolnou vyšší verzi Pythonu) a knihovnu SQLite
s&nbsp;rozšíření SQLite-vec, jsou dostupné, jak je zvykem, na GitHubu.
V&nbsp;tabulce níže jsou uvedeny odkazy na jednotlivé zdrojové kódy i na
definice formulářů:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>1</td><td>pyproject.toml</td><td>projektový soubor pro všechny demonstrační příklady</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sqlite-vec-tests/pyproject.toml">https://github.com/tisnik/most-popular-python-libs/blob/master/sqlite-vec-tests/pyproject.toml</a></td></tr>
<tr><td>2</td><td>intro_file.py</td><td>tisk informace o verzi vektorového rozšíření <strong>sqlite-vec</strong>, verze s&nbsp;databází uložené v&nbsp;souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sqlite-vec-tests/intro_file.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sqlite-vec-tests/intro_file.py</a></td></tr>
<tr><td>3</td><td>intro_mem.py</td><td>tisk informace o verzi vektorového rozšíření <strong>sqlite-vec</strong>, verze s&nbsp;databází uložené v&nbsp;operační paměti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sqlite-vec-tests/intro_mem.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sqlite-vec-tests/intro_mem.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>create_table_1.py</td><td>vytvoření virtuální tabulky s&nbsp;jedním sloupcem pro vektory, základní způsob zápisu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sqlite-vec-tests/create_table_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sqlite-vec-tests/create_table_1.py</a></td></tr>
<tr><td>5</td><td>create_table_2.py</td><td>vytvoření virtuální tabulky s&nbsp;jedním sloupcem s&nbsp;vektory, použití kontext manažeru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sqlite-vec-tests/create_table_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sqlite-vec-tests/create_table_2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>fill_in_table_1.py</td><td>naplnění virtuální tabulky několika vektory, základní varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sqlite-vec-tests/fill_in_table_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sqlite-vec-tests/fill_in_table_1.py</a></td></tr>
<tr><td>7</td><td>fill_in_table_2.py</td><td>naplnění virtuální tabulky patnácti vektory, rozšiřitelná varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sqlite-vec-tests/fill_in_table_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sqlite-vec-tests/fill_in_table_2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>8</td><td>query_1.py</td><td>dotaz vracející tři nejbližší vektory k&nbsp;vektoru [-4, 4]</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sqlite-vec-tests/query_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sqlite-vec-tests/query_1.py</a></td></tr>
<tr><td>9</td><td>query_2.py</td><td>dotaz vracející pět nejbližších vektorů k&nbsp;vektoru [4, 4]</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sqlite-vec-tests/query_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sqlite-vec-tests/query_2.py</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články věnující se problematice vyhledávání podobných vektorů v&nbsp;databázích</h2>

<p>Na stránkách Roota jsme se již několikrát setkali s&nbsp;problematikou
vyhledávání vektorů v&nbsp;databázích (ať již se jedná o mainstreamové
databáze, nebo o databáze specializované). Následují odkazy na tyto články:</p>

<ol>

<li>pgvector: vektorová databáze postavená na Postgresu<br />
<a href="https://www.root.cz/clanky/pgvector-vektorova-databaze-postavena-na-postgresu/">https://www.root.cz/clanky/pgvector-vektorova-databaze-postavena-na-postgresu/</a>
</li>

<li>Rozšíření PostgreSQL jménem pgvector, embedding a sémantické vyhledávání (1. část)<br />
<a href="https://www.root.cz/clanky/rozsireni-postgresql-jmenem-pgvector-embedding-a-semanticke-vyhledavani-1-cast/">https://www.root.cz/clanky/rozsireni-postgresql-jmenem-pgvector-embedding-a-semanticke-vyhledavani-1-cast/</a>
</li>

<li>FAISS: knihovna pro rychlé a efektivní vyhledávání podobných vektorů<br />
<a href="https://www.root.cz/clanky/faiss-knihovna-pro-rychle-a-efektivni-vyhledavani-podobnych-vektoru/">https://www.root.cz/clanky/faiss-knihovna-pro-rychle-a-efektivni-vyhledavani-podobnych-vektoru/</a>
</li>

<li>FAISS: knihovna pro rychlé a efektivní vyhledávání podobných vektorů (2. část)<br />
<a href="https://www.root.cz/clanky/faiss-knihovna-pro-rychle-a-efektivni-vyhledavani-podobnych-vektoru-2-cast/">https://www.root.cz/clanky/faiss-knihovna-pro-rychle-a-efektivni-vyhledavani-podobnych-vektoru-2-cast/</a>
</li>

<li>Knihovna FAISS a embedding: základ jazykových modelů<br />
<a href="https://www.root.cz/clanky/knihovna-faiss-a-embedding-zaklad-jazykovych-modelu/">https://www.root.cz/clanky/knihovna-faiss-a-embedding-zaklad-jazykovych-modelu/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>sqlite-vec repository<br />
<a href="https://github.com/asg017/sqlite-vec">https://github.com/asg017/sqlite-vec</a>
</li>

<li>SQlite-vec <br />
<a href="https://builders.mozilla.org/project/sqlite-vec/">https://builders.mozilla.org/project/sqlite-vec/</a>
</li>

<li>How to use sqlite-vec to store and query vector embeddings<br />
<a href="https://dev.to/stephenc222/how-to-use-sqlite-vec-to-store-and-query-vector-embeddings-58mf">https://dev.to/stephenc222/how-to-use-sqlite-vec-to-store-and-query-vector-embeddings-58mf</a>
</li>

<li>SQLite-Vector<br />
<a href="https://www.sqlite.ai/sqlite-vector">https://www.sqlite.ai/sqlite-vector</a>
</li>

<li>Vector database<br />
<a href="https://en.wikipedia.org/wiki/Vector_database">https://en.wikipedia.org/wiki/Vector_database</a>
</li>

<li>Nearest neighbor search<br />
<a href="https://en.wikipedia.org/wiki/Nearest_neighbor_search#Approximation_methods">https://en.wikipedia.org/wiki/Nearest_neighbor_search#Approximation_methods</a>
</li>

<li>RAG - Retrieval-augmented generation<br />
<a href="https://en.wikipedia.org/wiki/Retrieval-augmented_generation">https://en.wikipedia.org/wiki/Retrieval-augmented_generation</a>
</li>

<li>pgvector na GitHubu<br />
<a href="https://github.com/pgvector/pgvector">https://github.com/pgvector/pgvector</a>
</li>

<li>Why we replaced Pinecone with PGVector<br />
<a href="https://www.confident-ai.com/blog/why-we-replaced-pinecone-with-pgvector">https://www.confident-ai.com/blog/why-we-replaced-pinecone-with-pgvector</a>
</li>

<li>PostgreSQL as VectorDB - Beginner Tutorial<br />
<a href="https://www.youtube.com/watch?v=Ff3tJ4pJEa4">https://www.youtube.com/watch?v=Ff3tJ4pJEa4</a>
</li>

<li>What is a Vector Database? (neobsahuje odpověď na otázku v titulku :-)<br />
<a href="https://www.youtube.com/watch?v=t9IDoenf-lo">https://www.youtube.com/watch?v=t9IDoenf-lo</a>
</li>

<li>PGVector: Turn PostgreSQL Into A Vector Database<br />
<a href="https://www.youtube.com/watch?v=j1QcPSLj7u0">https://www.youtube.com/watch?v=j1QcPSLj7u0</a>
</li>

<li>Milvus<br />
<a href="https://milvus.io/">https://milvus.io/</a>
</li>

<li>Vector Databases simply explained! (Embeddings &amp; Indexes)<br />
<a href="https://www.youtube.com/watch?v=dN0lsF2cvm4">https://www.youtube.com/watch?v=dN0lsF2cvm4</a>
</li>

<li>Vector databases are so hot right now. WTF are they?<br />
<a href="https://www.youtube.com/watch?v=klTvEwg3oJ4">https://www.youtube.com/watch?v=klTvEwg3oJ4</a>
</li>

<li>Step-by-Step Guide to Installing “pgvector” and Loading Data in PostgreSQL<br />
<a href="https://medium.com/@besttechreads/step-by-step-guide-to-installing-pgvector-and-loading-data-in-postgresql-f2cffb5dec43">https://medium.com/@besttechreads/step-by-step-guide-to-installing-pgvector-and-loading-data-in-postgresql-f2cffb5dec43</a>
</li>

<li>Best 17 Vector Databases for 2025<br />
<a href="https://lakefs.io/blog/12-vector-databases-2023/">https://lakefs.io/blog/12-vector-databases-2023/</a>
</li>

<li>Top 15 Vector Databases that You Must Try in 2025<br />
<a href="https://www.geeksforgeeks.org/top-vector-databases/">https://www.geeksforgeeks.org/top-vector-databases/</a>
</li>

<li>Picking a vector database: a comparison and guide for 2023<br />
<a href="https://benchmark.vectorview.ai/vectordbs.html">https://benchmark.vectorview.ai/vectordbs.html</a>
</li>

<li>Top 9 Vector Databases as of Feburary 2025<br />
<a href="https://www.shakudo.io/blog/top-9-vector-databases">https://www.shakudo.io/blog/top-9-vector-databases</a>
</li>

<li>What is a vector database?<br />
<a href="https://www.ibm.com/think/topics/vector-database">https://www.ibm.com/think/topics/vector-database</a>
</li>

<li>SQL injection<br />
<a href="https://en.wikipedia.org/wiki/SQL_injection">https://en.wikipedia.org/wiki/SQL_injection</a>
</li>

<li>Cosine similarity<br />
<a href="https://en.wikipedia.org/wiki/Cosine_similarity">https://en.wikipedia.org/wiki/Cosine_similarity</a>
</li>

<li>Hammingova vzdálenost<br />
<a href="https://cs.wikipedia.org/wiki/Hammingova_vzd%C3%A1lenost">https://cs.wikipedia.org/wiki/Hammingova_vzd%C3%A1lenost</a>
</li>

<li>Jaccard index<br />
<a href="https://en.wikipedia.org/wiki/Jaccard_index">https://en.wikipedia.org/wiki/Jaccard_index</a>
</li>

<li>Manhattanská metrika<br />
<a href="https://cs.wikipedia.org/wiki/Manhattansk%C3%A1_metrika">https://cs.wikipedia.org/wiki/Manhattansk%C3%A1_metrika</a>
</li>

<li>FAISS (Facebook AI Similarity Search)<br />
<a href="https://en.wikipedia.org/wiki/FAISS">https://en.wikipedia.org/wiki/FAISS</a>
</li>

<li>FAISS documentation<br />
<a href="https://faiss.ai/">https://faiss.ai/</a>
</li>

<li>Introduction to Facebook AI Similarity Search (Faiss)<br />
<a href="https://www.pinecone.io/learn/series/faiss/faiss-tutorial/">https://www.pinecone.io/learn/series/faiss/faiss-tutorial/</a>
</li>

<li>Faiss: Efficient Similarity Search and Clustering of Dense Vectors<br />
<a href="https://medium.com/@pankaj_pandey/faiss-efficient-similarity-search-and-clustering-of-dense-vectors-dace1df1e235">https://medium.com/@pankaj_pandey/faiss-efficient-similarity-search-and-clustering-of-dense-vectors-dace1df1e235</a>
</li>

<li>Cosine Distance vs Dot Product vs Euclidean in vector similarity search<br />
<a href="https://medium.com/data-science-collective/cosine-distance-vs-dot-product-vs-euclidean-in-vector-similarity-search-227a6db32edb">https://medium.com/data-science-collective/cosine-distance-vs-dot-product-vs-euclidean-in-vector-similarity-search-227a6db32edb</a>
</li>

<li>F16C<br />
<a href="https://en.wikipedia.org/wiki/F16C">https://en.wikipedia.org/wiki/F16C</a>
</li>

<li>FP16 (AVX-512)<br />
<a href="https://en.wikipedia.org/wiki/AVX-512#FP16">https://en.wikipedia.org/wiki/AVX-512#FP16</a>
</li>

<li>Top 8 Vector Databases in 2025: Features, Use Cases, and Comparisons<br />
<a href="https://synapsefabric.com/top-8-vector-databases-in-2025-features-use-cases-and-comparisons/">https://synapsefabric.com/top-8-vector-databases-in-2025-features-use-cases-and-comparisons/</a>
</li>

<li>Is FAISS a Vector Database? Complete Guide<br />
<a href="https://mljourney.com/is-faiss-a-vector-database-complete-guide/">https://mljourney.com/is-faiss-a-vector-database-complete-guide/</a>
</li>

<li>FAISS and sentence-transformers in 5 Minutes<br />
<a href="https://www.stephendiehl.com/posts/faiss/">https://www.stephendiehl.com/posts/faiss/</a>
</li>

<li>Sentence Transformer: Quickstart<br />
<a href="https://sbert.net/docs/quickstart.html#sentence-transformer">https://sbert.net/docs/quickstart.html#sentence-transformer</a>
</li>

<li>Sentence Transformers: Embeddings, Retrieval, and Reranking<br />
<a href="https://pypi.org/project/sentence-transformers/">https://pypi.org/project/sentence-transformers/</a>
</li>

<li>uv<br />
<a href="https://docs.astral.sh/uv/">https://docs.astral.sh/uv/</a>
</li>

<li>A Gentle Introduction to Retrieval Augmented Generation (RAG)<br />
<a href="https://wandb.ai/cosmo3769/RAG/reports/A-Gentle-Introduction-to-Retrieval-Augmented-Generation-RAG---Vmlldzo1MjM4Mjk1">https://wandb.ai/cosmo3769/RAG/reports/A-Gentle-Introduction-to-Retrieval-Augmented-Generation-RAG---Vmlldzo1MjM4Mjk1</a>
</li>

<li>The Beginner’s Guide to Text Embeddings<br />
<a href="https://www.deepset.ai/blog/the-beginners-guide-to-text-embeddings">https://www.deepset.ai/blog/the-beginners-guide-to-text-embeddings</a>
</li>

<li>SQLite: Run-Time Loadable Extensions<br />
<a href="https://sqlite.org/loadext.html">https://sqlite.org/loadext.html</a>
</li>

<li>SQLite: Load An Extension<br />
<a href="https://sqlite.org/c3ref/load_extension.html">https://sqlite.org/c3ref/load_extension.html</a>
</li>

<li>The Virtual Table Mechanism Of SQLite<br />
<a href="https://sqlite.org/vtab.html">https://sqlite.org/vtab.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2026</small></p>
</body>
</html>

