<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Realizace transakcí v systému Redis</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Realizace transakcí v systému Redis</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku se seznámíme s tím, jakým způsobem jsou v systému Redis realizovány (či spíše nerealizovány) transakce a jakým způsobem je možné si je naprogramovat, a to s využitím takzvané pipeline a optimistického zamykání.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Realizace transakcí v&nbsp;systému Redis</a></p>
<p><a href="#k02">2. Instalace Redisu a použití klienta <strong>redis-cli</strong></a></p>
<p><a href="#k03">3. Transakce a atomické operace v&nbsp;Redisu</a></p>
<p><a href="#k04">4. Jak jsou transakce realizovány?</a></p>
<p><a href="#k05">5. Optimistické zamykání</a></p>
<p><a href="#k06">6. Od samostatně probíhajících operací k&nbsp;transakcím</a></p>
<p><a href="#k07">7. Přepis hodnot uložených pod jediným klíčem</a></p>
<p><a href="#k08">8. Otestování chování Redisu</a></p>
<p><a href="#k09">9. Úprava producenta tak, aby po zápisu neočekávané hodnoty ihned zapsal hodnotu korektní</a></p>
<p><a href="#k10">10. Transakce realizovaná formou pipeline</a></p>
<p><a href="#k11">11. Operace typu <strong>get-and-set</strong></a></p>
<p><a href="#k12">12. Lze vytvořit pipeline pro operaci <strong>get-and-set</strong>?</a></p>
<p><a href="#k13">13. Operace <strong>get</strong> následovaná transakcí</a></p>
<p><a href="#k14">14. Realizace optimistického zamykání</a></p>
<p><a href="#k15">15. Pipeline použitá jako správce kontextu</a></p>
<p><a href="#k16">16. Chování klienta ve chvíli, kdy běží další klient zapisující do prvku se stejným klíčem</a></p>
<p><a href="#k17">17. Konkrétní problém &ndash; atomické připojení zpráv do seznamu uloženého v&nbsp;Redisu</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na předchozí části seriálu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Realizace transakcí v&nbsp;systému Redis</h2>

<p>Databáze <i>Redis</i> (<i>REmote DIctionary Server</i>) patří do rozsáhlé a
dnes již značně nehomogenní skupiny nerelačních databází. Konkrétně se
v&nbsp;případě Redisu v&nbsp;první řadě jedná o databázi typu key-value, což
znamená, že hodnoty ukládané do databáze je možné jednoznačně identifikovat
(najít, smazat, změnit jejich hodnotu atd.) na základě klíče, který je
reprezentován řetězcem. Podobných databází samozřejmě existuje celá řada; za
zmínku stojí především <i>Berkeley DB</i>, dále pak <i>MemcacheDB</i>,
<i>Dynamo</i> či <i>InfinityDB</i>. Dnes popisovaná databáze <i>Redis</i> může
být pro vývojáře zajímavá a užitečná zejména z&nbsp;toho důvodu, že podporuje i
další užitečné datové typy (tedy hodnotami nemusí být jen řetězce, ale
například i mapy, seznamy, proudy atd). Dále se jedná o velmi flexibilní
systém, který je možné v&nbsp;případě potřeby škálovat nejenom
&bdquo;nahoru&ldquo; (distribuované systémy se shardingem a/nebo replikací),
ale i &bdquo;dolů&ldquo; (jednoduše nastavitelné datové odkladiště pro
jednouživatelskou aplikaci).</p>

<p>Na jedné straně je možné <i>Redis</i> provozovat na jediném stroji
s&nbsp;tím, že data budou uložena pouze v&nbsp;operační paměti, na straně druhé
je však možné relativně snadno nakonfigurovat <i>Redis</i> takovým způsobem, že
data budou rozložena mezi více strojů (<i>sharding</i>), popř.&nbsp;se použije
architektura typu master-slave, kdy bude <i>Redis</i> data replikovat na pozadí
mezi uzlem typu master a uzly typu slave (se všemi z&nbsp;toho vyplývajícími
důsledky).</p>

<p>Díky této flexibilitě je možné systém <i>Redis</i> v&nbsp;praxi využít mnoha
různými způsoby. Používá se například ve formě vyrovnávací paměti
(<i>cache</i>), přičemž je dokonce možné specifikovat dobu životnosti dat,
takže mazání starších položek nemusí být řešeno přímo v&nbsp;aplikaci
(životnost údajů lze snadno obnovit, což se hodí například při ukládání
informací o <i>session/sezení</i> u webových aplikací). Ovšem <i>Redis</i>
můžeme použít i jako plnohodnotnou key-value databázi s&nbsp;tím, že data budou
na pozadí ukládána na nevolatilní paměť (typicky na pevný disk či dnes spíše na
SSD), což znamená, že údaje přežijí restart Redisu, pád počítače či systému
atd. K&nbsp;dispozici mají vývojáři dvě základní strategie ukládání dat do
nevolatilní paměti, které lze dokonce použít současně.</p>

<p>V&nbsp;případě potřeby je možné realizovat i systém s&nbsp;transakcemi
popř.&nbsp;využít některé atomické operace, které <i>Redis</i> podporuje už ve
své základní sadě příkazů. A právě touto problematikou se budeme zabývat
v&nbsp;dnešním článku. Zaměříme se sice především na řešení naprogramované
v&nbsp;Pythonu, ovšem samotný princip je zcela univerzální a je ho možné
realizovat i v&nbsp;dalších programovacích jazycích.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instalace Redisu a použití klienta <strong>redis-cli</strong></h2>

<p>Instalace Redisu do Linuxu je snadná, protože ve většině Linuxových
distribucí existuje příslušný balíček s&nbsp;touto službou. Tímto tématem jsme
se ostatně již zabývali <a
href="https://www.root.cz/clanky/nastroj-huey-uzitecna-knihovna-pro-praci-s-frontami-uloh-v-pythonu/#k05">v&nbsp;páté
kapitole</a> článku <a
href="https://www.root.cz/clanky/nastroj-huey-uzitecna-knihovna-pro-praci-s-frontami-uloh-v-pythonu/">Nástroj
huey: užitečná knihovna pro práci s&nbsp;frontami úloh v&nbsp;Pythonu</a>.</p>

<p><div class="rs-tip-major">Poznámka: pokud je k&nbsp;dispozici pouze starší
balíček (Linux Mint atd.), můžete si Redis snadno přeložit. Postačuje
k&nbsp;tomu GCC, Make a popř.&nbsp;i knihovna OpenSSL. Viz též krátký návod
vystavený na <a
href="https://redis.io/docs/install/install-redis/install-redis-from-source/">https://redis.io/docs/install/install-redis/install-redis-from-source/</a>.
V&nbsp;dalším textu budu používat právě takto přeložený Redis.</div></p>

<p>Po instalaci a úpravě konfiguračního souboru <strong>redis.conf</strong>
celou službu <i>Redis</i> spustíme příkazem:</p>

<pre>
$ <strong>redis-server redis.conf</strong>
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
784933:C 16 Mar 2024 10:22:36.843 * oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
784933:C 16 Mar 2024 10:22:36.843 * Redis version=7.2.4, bits=64, commit=00000000, modified=0, pid=784933, just started
784933:C 16 Mar 2024 10:22:36.843 * Configuration loaded
784933:M 16 Mar 2024 10:22:36.843 * Increased maximum number of open files to 10032 (it was originally set to 1024).
784933:M 16 Mar 2024 10:22:36.843 * monotonic clock: POSIX clock_gettime
784933:M 16 Mar 2024 10:22:36.844 # Failed to write PID file: Permission denied
                _._                                                  
           _.-``__ ''-._                                             
      _.-``    `.  `_.  ''-._           Redis 7.2.4 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._                                  
 (    '      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
 |    `-._   `._    /     _.-'    |     PID: 784933
  `-._    `-._  `-./  _.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |           https://redis.io       
  `-._    `-._`-.__.-'_.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |                                  
  `-._    `-._`-.__.-'_.-'    _.-'                                   
      `-._    `-.__.-'    _.-'                                       
          `-._        _.-'                                           
              `-.__.-'                                               
&nbsp;
784933:M 16 Mar 2024 10:22:36.844 * Server initialized
784933:M 16 Mar 2024 10:22:36.844 * DB loaded from append only file: 0.000 seconds
784933:M 16 Mar 2024 10:22:36.844 * Opening AOF incr file appendonly.aof.1.incr.aof on server start
784933:M 16 Mar 2024 10:22:36.844 * Ready to accept connections tcp
</pre>

<p>V&nbsp;jiném terminálu si můžeme pustit klienta ovládaného
z&nbsp;příkazového řádku:</p>

<pre>
$ <strong>redis-cli</strong>
</pre>

<p>Měla by se zobrazit takzvaná <i>výzva</i> (<i>prompt</i>) očekávající
uživatelem zapisované příkazy:</p>

<pre>
127.0.0.1:6379&gt;
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Transakce a atomické operace v&nbsp;Redisu</h2>

<p>Jak jsme si napsali v&nbsp;závěru <a href="#k01">úvodní kapitoly</a>,
umožňuje systém Redis do určité míry i realizaci transakcí (ovšem
s&nbsp;relativně velkými omezeními, jak ostatně uvidíme dále &ndash; některé
operace musíme provádět ručně). U příkazů, které jsou součástí transakce, jsou
dodrženy (zajištěny) následující podmínky:</p>

<ol>

<li>Všechny příkazy uvedené v&nbsp;transakci jsou provedeny v&nbsp;takovém
pořadí, v&nbsp;jakém jsou specifikovány uživatelem nebo programátorem.</li>

<li>Mezi tyto příkazy se nikdy nevmísí příkazy vyžadované jiným klientem.</li>

<li>Transakce je atomická: buď se provede celá (všechny příkazy), nebo se
neprovede vůbec. O provedení či neprovedení transakce rozhoduje poslední příkaz
(<strong>exec</strong> nebo <strong>discard</strong>).</li>

</ol>

<p>Pro práci s&nbsp;transakcemi jsou určeny příkazy <strong>multi</strong> a
již výše zmíněné příkazy <strong>exec</strong> a <strong>discard</strong>.
Podívejme se nyní na velmi jednoduchý &bdquo;školní&ldquo; příklad, v&nbsp;němž
se převádí nějaká částka mezi dvěma účty s&nbsp;částkami uloženými pod klíči
&bdquo;ucet1&ldquo; a &bdquo;ucet2&ldquo;:</p>

<pre>
127.0.0.1:6379&gt; <strong>set ucet1 1000.0</strong>
OK
&nbsp;
127.0.0.1:6379&gt; <strong>set ucet2 0.0</strong>
OK
</pre>

<p>Tuto peněžní transakci musíme provést v&nbsp;databázové transakci,
tj.&nbsp;zadáme ji mezi příkazy <strong>multi</strong> a
<strong>exec</strong>:</p>

<pre>
127.0.0.1:6379&gt; <strong>multi</strong>
OK
127.0.0.1:6379&gt; <strong>incrbyfloat ucet1 -150.50</strong>
QUEUED
127.0.0.1:6379&gt; <strong>incrbyfloat ucet2 +150.50</strong>
QUEUED
127.0.0.1:6379&gt; <strong>exec</strong>
1) "849.5"
2) "150.5"
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že příkazy
<strong>incrbyfloat</strong> nejsou ihned vykonány, ale pouze zařazeny do
&bdquo;fronty&ldquo;. Kdyby byly tyto příkazy vykonány ihned po svém zadání,
zobrazil by se výsledek výpočtu (tedy nová hodnota na účtu). A naopak &ndash;
výsledky (849,5 a 150,5) se vypíšou až po provedení příkazu
<strong>exec</strong> (výsledkem je pole &ndash; <i>array</i>). Na tomto
příkladu je tedy patrné, že se skutečně mezi <strong>multi</strong> a
<strong>exec</strong> příkazy pouze zapamatují a poté provedou společně (a to
konkrétně v&nbsp;transakci, ale to ještě nemáme ověřeno).</div></p>

<p>Výsledné hodnoty na účtu po provedení transakce získáme následujícím
způsobem:</p>

<pre>
127.0.0.1:6379&gt; <strong>get ucet1</strong>
"849.5"
127.0.0.1:6379&gt; <strong>get ucet2</strong>
"150.5"
</pre>

<p>Získané hodnoty odpovídají hodnotám vypsaným po provedení příkazu
<strong>exec</strong>, kterým se transakce potvrdí a ukončí.</p>

<p><div class="rs-tip-major">Upozornění: v&nbsp;současné verzi Redisu není
možné transakce vnořovat:</div></p>

<pre>
127.0.0.1:6379&gt; <strong>multi</strong>
OK
&nbsp;
127.0.0.1:6379(TX)&gt; <strong>multi</strong>
(error) ERR MULTI calls can not be nested
</pre>

<p>Po příkazu <strong>multi</strong> se změnila výzva &ndash; obsahuje řetězec
&bdquo;(TX)&ldquo;.</p>

<p>Systém Redis navíc neumožňuje ani rollback v&nbsp;případě, že při zpracování
transakce dojde k&nbsp;chybě nějakého příkazu.</p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je práce
s&nbsp;transakcemi v&nbsp;Redisu ještě složitější, neboť je nutné sledovat
výsledek (zda transakce proběhla či nikoli) a v&nbsp;případě neúspěchu se
transakci pokusit provést znovu. S&nbsp;podrobnostmi se seznámíme za
chvíli.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Jak jsou transakce realizovány?</h2>

<p>Samotný systém Redis sice nepodporuje skutečné transakce
(s&nbsp;plnohodnotným rollbackem), ovšem alespoň zajišťuje možnost spuštění
několika příkazů v&nbsp;jediném nepřerušitelném bloku. Tyto příkazy jsou
nejdříve zapamatovány a posléze spuštěny (nebo jsou jako celek zrušeny). Pro
tento účel slouží trojice základních příkazů <strong>multi</strong>,
<strong>exec</strong> a <strong>discard</strong>, o nichž jsme se zmínili.
Ovšem důležitý je především fakt, že se skupina příkazů skutečně provede jako
celek a není přerušena jinými příkazy.</p>

<p>Jak se však tento koncept odlišuje od běžných databází? Například si to
můžeme ukázat na sekvenci příkazů <a href="#k03">z&nbsp;předchozí
kapitoly</a>:</p>

<pre>
multi
incrbyfloat ucet1 -150.50
incrbyfloat ucet2 +150.50
exec
</pre>

<p>Příkaz <strong>multi</strong> ve skutečnosti nezahájí transakci (tedy
nezamkne databázi nebo její část). Pouze se změní stav klienta, který si
jednotlivé příkazy bude pamatovat a příkazem <strong>exec</strong> je pošle do
Redisu jako jeden blok (takže <strong>exec</strong> je vlastně kombinací
začátek transakce + commit). Neboli jinými slovy: mezi <strong>multi</strong> a
<strong>exec</strong> bude Redis stále obsluhovat další klienty.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Optimistické zamykání</h2>

<p>Při pokusu o práci s&nbsp;transakcemi v&nbsp;Redisu se setkáme s&nbsp;pojmem
<i>optimistické zamykání</i> (<i>optimistic lock</i>). Jedná se o postup, kdy
se pokusíme realizovat transakci a přitom budeme sledovat, zda jiný klient
nepřistupuje k&nbsp;hodnotám, které v&nbsp;transakci měníme (zahájení sledování
řeší příkaz <strong>watch</strong>, ukončení sledování pak příkaz
<strong>unwatch</strong>). V&nbsp;případě, že se v&nbsp;průběhu zápisu
transakce nějaká hodnota změní, provedeme transakci znovu. Jak uvidíme
v&nbsp;dalším textu, je realizace tohoto algoritmu celkem jednoduchá, ale má
svoje problémy &ndash; zejména se může stát, že s&nbsp;velkým množstvím zápisů
nedojde k&nbsp;dokončení transakce nikdy nebo až po delším čase. Také musí být
programové řešení zapsáno korektně a nesmí se zapomenout na dokončení transakce
a taktéž se nesmí zapomenout na ukončení sledování hodnoty či hodnot.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Od samostatně probíhajících operací k&nbsp;transakcím</h2>

<p>V&nbsp;navazujících kapitolách si ukážeme postupnou změnu klienta, který do
Redisu zapisuje nějaké údaje pod stále stejným klíčem. Původní verze klienta
nebude používat transakce. K&nbsp;těm se dostaneme postupně a v&nbsp;závěrečné
verzi bude klient realizovat i optimistické zamykání.</p>

<p>Klient bude realizován v&nbsp;Pythonu a bude používat knihovnu <a
href="https://github.com/redis/redis-py">Redis-Py</a>, kterou je možné
nainstalovat přes <strong>pip</strong>.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Přepis hodnot uložených pod jediným klíčem</h2>

<p>Podívejme se nejprve na velmi jednoduchý skript, který neustále do Redisu
zapisuje hodnoty uložené pod stejným klíčem. Nejprve se zapíše hodnota
(řetězec) &bdquo;^&ldquo; a po určité době řetězec &bdquo;^$&ldquo;. Tyto
operace se neustále opakují, pouze s&nbsp;malou časovou prodlevou.
V&nbsp;Pythonu by bylo možné takového klienta naprogramovat následujícím
způsobem:</p>

<pre>
import time
import redis
&nbsp;
&nbsp;
redis_client = redis.StrictRedis(
    host="localhost",
    port="6379",
    decode_responses=True,
)
&nbsp;
key = "foo"
sleep_time = 0.1
&nbsp;
while True:
    v = "^"
    redis_client.set(key, v)
    time.sleep(sleep_time)
    v = "^$"
    redis_client.set(key, v)
    time.sleep(sleep_time)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto skriptu
naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer1.py</a>.</div></p>

<p>Dále vytvoříme druhého klienta, který naopak bude hodnoty ze stejného klíče
číst a bude zjišťovat, o jakou hodnotu se jedná. Pokud se nalezne hodnota
odlišná od řetězce &bdquo;^$&ldquo;, bude to považováno za chybu, zvýší se
počitadlo chyb a vypočte se průměrná frekvence chyb za sekundu:</p>

<pre>
import redis
import time
&nbsp;
&nbsp;
redis_client = redis.StrictRedis(
    host="localhost",
    port="6379",
    decode_responses=True,
)
&nbsp;
key = "foo"
expected_value = "^$"
sleep_time = 0.01
&nbsp;
start_time = time.perf_counter()
&nbsp;
errors = 0
&nbsp;
while True:
    value = redis_client.get(key)
    if value != expected_value:
        errors += 1
        now = time.perf_counter()
        duration = now - start_time
        frequency = errors / duration
        print(f"{value:3} {errors:3}  {duration:6.3}  {frequency:4.3}")
    time.sleep(sleep_time)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto skriptu
naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/consumer1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/consumer1.py</a>.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Otestování chování Redisu</h2>

<p>Nyní v&nbsp;jednom terminálu pustíme &bdquo;producenta&ldquo; hodnot
ukládaných pod klíčem &bdquo;foo&ldquo;:</p>

<pre>
$ <strong>python3 producer.py</strong>
</pre>

<p>A v&nbsp;terminálu druhém spustíme konzumenta, který kontroluje, zda je pod
klíčem &bdquo;foo&ldquo; uložena hodnota &bdquo;^$&ldquo; nebo hodnota
jiná:</p>

<pre>
$ <strong>python3 consumer1.py</strong>
</pre>

<p>Podle očekávání se začne vypisovat značné množství chyb, protože přibližně
v&nbsp;50% případů se přečte odlišná hodnota (viz zdrojový kód producenta):</p>

<pre>
     chyb čas(s) chyb/s
^     1   0.105  9.52
^     2   0.115  17.3
^     3   0.126  23.9
^     4   0.136  29.4
^     5   0.146  34.2
^     6   0.157  38.3
^     7   0.167  41.9
^     8   0.177  45.1
^     9   0.188  48.0
^    10   0.198  50.6
^    11   0.302  36.5
^    12   0.313  38.4
^    13   0.324  40.1
^    14   0.335  41.8
^    15   0.346  43.3
^    16   0.358  44.7
^    17   0.369  46.1
^    18    0.38  47.4
^    19   0.391  48.6
^    20   0.512  39.0
^    21   0.523  40.1
^    22   0.535  41.2
^    23   0.546  42.1
</pre>

<p><div class="rs-tip-major">Poznámka: počet neočekávaných hodnot je tedy
vysoký &ndash; přibližně 40 hodnot za sekundu (což se blíží očekávané frekvenci
50%).</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Úprava producenta tak, aby po zápisu neočekávané hodnoty ihned zapsal hodnotu korektní</h2>

<p>Producenta ve druhém kroku upravíme do takové podoby, že ihned po zápisu
hodnoty &bdquo;^&ldquo; zapíše pod stejným klíčem správnou (resp.&nbsp;přesněji
řečeno očekávanou) hodnotu &bdquo;^$&ldquo;. Tím pochopitelně nedosáhneme
atomicity operací, ovšem počet neočekávaných hodnot na straně konzumenta by měl
být nižší:</p>

<pre>
import time
import redis
&nbsp;
&nbsp;
redis_client = redis.StrictRedis(
    host="localhost",
    port="6379",
    decode_responses=True,
)
&nbsp;
key = "foo"
sleep_time = 0.1
&nbsp;
while True:
    v = "^"
    redis_client.set(key, v)
    v = "^$"
    redis_client.set(key, v)
    time.sleep(sleep_time)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto skriptu
naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer2.py</a>.</div></p>

<p>Nyní bude po kontrole konzumentem počet chyb (neočekávaných hodnot) o dva
řády nižší:</p>

<pre>
$ <strong>python3 consumer1.py </strong>
&nbsp;
     chyb čas(s) chyb/s
^     1    15.3  0.0655
^     2    18.9  0.106
^     3    20.6  0.145
^     4    23.2  0.173
^     5    24.2  0.207
^     6    24.7  0.243
^     7    26.9  0.26
^     8    29.3  0.273
^     9    31.9  0.282
^    10    32.4  0.309
^    11    33.9  0.324
^    12    35.1  0.342
^    13    36.4  0.358
^    14    37.9  0.37
^    15    38.4  0.391
^    16    38.9  0.411
</pre>

<p><div class="rs-tip-major">Poznámka: výsledek je sice mnohem lepší, ovšem ani
v&nbsp;tomto případě jsme nedosáhli toho, aby se oba zápisy provedly
v&nbsp;transakci (a aby tedy nebyl první zápis vůbec viditelný pro další
klienty).</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Transakce realizovaná formou pipeline</h2>

<p>Oba zápisy lze ovšem provést atomicky, tedy takovým způsobem, aby žádný jiný
klient nemohl vidět stav uložené hodnoty mezi oběma operacemi
<strong>set</strong>. K&nbsp;tomuto účelu se používají transakce, které jsou
v&nbsp;klientovi pro Python realizovány formou takzvané <i>pipeline</i>.
V&nbsp;tomto případě se nejprve vytvoří pipeline, příkazy se
&bdquo;zapamatují&ldquo; a následně se provedou v&nbsp;jediném bloku, a to tak,
že další klienti uvidí až celkový výsledek. Transakce se zahajuje metodou
<strong>multi</strong> a ukončuje metodou <strong>execute</strong> (nebo
<strong>discarc</strong>, pokud naopak potřebujeme všechny příkazy
v&nbsp;pipeline zahodit):</p>

<pre>
import time
import redis
&nbsp;
&nbsp;
redis_client = redis.StrictRedis(
    host="localhost",
    port="6379",
    decode_responses=True,
)
&nbsp;
key = "foo"
sleep_time = 0.1
&nbsp;
while True:
    pipeline = redis_client.pipeline(transaction=True)
    pipeline.multi()
    v = "^"
    pipeline.set(key, v)
    time.sleep(sleep_time)
    v = "^$"
    pipeline.set(key, v)
    time.sleep(sleep_time)
    pipeline.execute()
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto skriptu
naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer3.py</a>.</div></p>

<p>Spuštěním testu (producent + konzument) je možné zjistit, že nyní již
konzument nikdy neuvidí mezistav, tedy hodnotu &bdquo;^&ldquo;.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Operace typu <strong>get-and-set</strong></h2>

<p>Nyní se předchozí demonstrační příklad pokusíme upravit, a to tak, že
naimplementujeme operaci typu <strong>get-and-set</strong>. Jedná se o operaci,
která nejdříve přečte hodnotu z&nbsp;Redisu, nějakým způsobem ji modifikuje a
následně ji uloží zpět (stále pod stejným klíčem). Naimplementujeme si
například obdobu operace <strong>append</strong>, kdy budeme k&nbsp;uložené
hodnotě přidávat znaky &bdquo;^&ldquo; a &bdquo;$&ldquo;:</p>

<pre>
import time
import redis
&nbsp;
&nbsp;
redis_client = redis.StrictRedis(
    host="localhost",
    port="6379",
    decode_responses=True,
)
&nbsp;
key = "bar"
sleep_time = 0.1
&nbsp;
while True:
    v = redis_client.get(key) or ""
    v += "^"
    redis_client.set(key, v)
    <i># time.sleep(1.4)</i>
    v += "$"
    redis_client.set(key, v)
    time.sleep(sleep_time)
    print(v)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto skriptu
naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer4.py</a>.</div></p>

<p>Výsledek budeme kontrolovat upraveným konzumentem, který bude sledovat pouze
poslední dva znaky zprávy (jestli se bude jednat o sekvenci &bdquo;^$&ldquo; či
nikoli):</p>

<pre>
import redis
import time
&nbsp;
&nbsp;
redis_client = redis.StrictRedis(
    host="localhost",
    port="6379",
    decode_responses=True,
)
&nbsp;
key = "bar"
expected_value = "^$"
sleep_time = 0.01
&nbsp;
start_time = time.perf_counter()
&nbsp;
errors = 0
&nbsp;
while True:
    value = redis_client.get(key)
    if value is None:
        continue
    last_chars = value[-2:]
    if last_chars != expected_value:
        errors += 1
        now = time.perf_counter()
        duration = now - start_time
        frequency = errors / duration
        print(f"{last_chars:3} {errors:3}  {duration:6.3}  {frequency:4.3}")
    time.sleep(sleep_time)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto skriptu
naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/consumer2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/consumer2.py</a>.</div></p>

<p>Konzument, opět podle očekávání, nalezne &bdquo;neočekávané&ldquo; hodnoty,
protože přidání znaků do hodnoty uložené v&nbsp;Redisu je provedeno po
jednotlivých znacích, takže je v&nbsp;některých okamžicích viditelný i mezistav
mezi oběma příkazy <strong>set</strong>:</p>

<pre>
^     1    3.21  0.311
$^    2    3.62  0.552
$^    3    3.83  0.784
$^    4    4.03  0.993
$^    5    4.23  1.18
$^    6    5.76  1.04
$^    7    9.84  0.712
$^    8    10.8  0.744
$^    9    13.0  0.693
$^   10    14.1  0.708
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Lze vytvořit pipeline pro operaci <strong>get-and-set</strong>?</h2>

<p>Pokusme se nyní vytvořit pipeline (a tím pádem i možnost spuštění
v&nbsp;transakci) pro operaci <strong>get-and-set</strong>. Budeme postupovat
naprosto stejným způsobem, jako <a href="#k10">v&nbsp;desáté kapitole</a>,
tj.&nbsp;vytvoříme pipeline a operace <strong>get</strong> a
<strong>set</strong> budeme volat jako metody pipeline:</p>

<pre>
import time
import redis
&nbsp;
&nbsp;
redis_client = redis.StrictRedis(
    host="localhost",
    port="6379",
    decode_responses=True,
)
&nbsp;
key = "bar"
sleep_time = 0.1
&nbsp;
while True:
    pipeline = redis_client.pipeline(transaction=True)
    pipeline.multi()
    v = pipeline.get(key) or ""
    v += "^"
    pipeline.set(key, v)
    time.sleep(sleep_time)
    v += "$"
    pipeline.set(key, v)
    pipeline.execute()
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto skriptu
naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer5.py</a>.</div></p>

<p>Tento skript ovšem nepůjde spustit, protože se detekuje chyba na řádku,
v&nbsp;němž se pokoušíme k&nbsp;výsledku operace <strong>get</strong> přičíst
další část řetězce:</p>

<pre>
$ <strong>python3 producer5.py </strong>
&nbsp;
Traceback (most recent call last):
  File "producer5.py", line 18, in <module>
    v += "^"
TypeError: unsupported operand type(s) for +=: 'Pipeline' and 'str'
</pre>

<p>Proč tomu tak je? Připomeňme si, že operace zapsané do pipeline jsou nejprve
shromážděny a teprve poté poslány (jako jeden nedělitelný blok) do Redisu. To
znamená, že výsledek operace <strong>get</strong> nemůžeme použít jako parametr
do navazující funkce <strong>set</strong>.</p>

<p><div class="rs-tip-major">Poznámka: jedno z&nbsp;možných řešení spočívá
v&nbsp;zápisu transakce <a
href="https://www.root.cz/serialy/programovaci-jazyk-lua/">v&nbsp;jazyce
Lua</a> a spuštění tohoto příkazu přímo v&nbsp;rámci Redisu.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Operace <strong>get</strong> následovaná transakcí</h2>

<p>Předchozí skript můžeme upravit takovým způsobem, že bude funkční
v&nbsp;případě, že se použije jen jediný klient zapisující data. Toto řešení je
postaveno na &bdquo;běžné&ldquo; operaci <strong>get</strong>, která je
následována transakcí, v&nbsp;níž již můžeme výsledek operace
<strong>get</strong> bez problémů použít. Jako celek se tedy sice nebude jednat
o atomickou operaci, na druhou stranu minimálně hodnota viditelná konzumenty
bude vždy končit správnou dvojicí znaků &bdquo;^$&ldquo; (neuvidíme tedy
nechtěný &bdquo;mezistav&ldquo;):</p>

<pre>
import time
import redis
&nbsp;
&nbsp;
redis_client = redis.StrictRedis(
    host="localhost",
    port="6379",
    decode_responses=True,
)
&nbsp;
key = "bar"
sleep_time = 0.1
&nbsp;
while True:
    pipeline = redis_client.pipeline(transaction=True)
    error_count = 0
    v = redis_client.get(key) or ""
    v += "^"
    pipeline.set(key, v)
    time.sleep(sleep_time)
    v += "$"
    pipeline.set(key, v)
    pipeline.execute()
    time.sleep(sleep_time)
    print(v)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto skriptu
naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer6.py</a>.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Realizace optimistického zamykání</h2>

<p>V&nbsp;další verzi původního klienta ještě vylepšíme, a to konkrétně o
algoritmus optimistického zamykání. Nejprve se vytvoří objekt typu pipeline
(může se používat i jako správce kontextu, to uvidíme dále):</p>

<pre>
pipeline = redis_client.pipeline(transaction=True)
</pre>

<p>Dále začneme sledovat ostatní klienty, zda přistupují k&nbsp;hodnotě uložené
pod daným klíčem:</p>

<pre>
pipeline.watch(key)
</pre>

<p>Přečteme hodnotu uloženou pod klíčem (nikoli v&nbsp;pipeline, to jíž víme,
že není možné):</p>

<pre>
v = redis_client.get(key) or ""
v += "^"
</pre>

<p>Samotná modifikace hodnoty je však již v&nbsp;pipeline realizována:</p>

<pre>
pipeline.multi()
pipeline.set(key, v)
time.sleep(sleep_time)
v += "$"
pipeline.set(key, v)
pipeline.execute()
</pre>

<p><div class="rs-tip-major">Poznámka: <strong>sleep</strong> vůbec nevadí,
protože příkazy Redisu prozatím nejsou spuštěny, spuštění je provedeno
v&nbsp;<strong>execute</strong>.</div></p>

<p>Nyní lze pipeline zavřít popř.&nbsp;navíc přestat sledovat hodnotu uloženou
pod daným klíčem:</p>

<pre>
pipeline.unwatch()
</pre>

<p>V&nbsp;případě zápisu jiným klientem do klíče se vyvolá výjimka:</p>

<pre>
except redis.WatchError as err:
    error_count += 1
    print(f"Watch error #{error_count}:", err)
</pre>

<p>A takto vypadá úplný zdrojový kód již sedmé verze klienta:</p>

<pre>
import time
import redis
&nbsp;
&nbsp;
redis_client = redis.StrictRedis(
    host="localhost",
    port="6379",
    decode_responses=True,
)
&nbsp;
key = "bar"
sleep_time = 0.1
&nbsp;
error_count = 0
&nbsp;
while True:
    pipeline = redis_client.pipeline(transaction=True)
    try:
        print("transaction started...", end="")
        pipeline.watch(key)
        v = redis_client.get(key) or ""
        v += "^"
        pipeline.multi()
        pipeline.set(key, v)
        time.sleep(sleep_time)
        v += "$"
        pipeline.set(key, v)
        pipeline.execute()
        pipeline.unwatch()
        print("...commited")
        time.sleep(sleep_time)
    except redis.WatchError as err:
        error_count += 1
        print(f"Watch error #{error_count}:", err)
print(v)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto skriptu
naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer7.py</a>.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Pipeline použitá jako správce kontextu</h2>

<p><a href="#k14">V&nbsp;předchozí kapitole</a> jsme si řekli, že se objekt
typu pipeline může použít i jako správce kontextu (<i>context manager</i>), což
je (podle mého názoru) čitelnější řešení. Namísto zápisu:</p>

<pre>
pipeline = redis_client.pipeline(transaction=True)
</pre>

<p>tedy použijeme zápis:</p>

<pre>
with redis_client.pipeline(transaction=True) as pipeline:
    ...
    ...
    ...
</pre>

<p>To vede k&nbsp;takto upravenému zdrojovému kódu klienta:</p>

<pre>
import time
import redis
&nbsp;
&nbsp;
redis_client = redis.StrictRedis(
    host="localhost",
    port="6379",
    decode_responses=True,
)
&nbsp;
key = "bar"
sleep_time = 0.1
&nbsp;
error_count = 0
&nbsp;
while True:
    with redis_client.pipeline(transaction=True) as pipeline:
        try:
            print("transaction started...", end="")
            pipeline.watch(key)
            v = redis_client.get(key) or ""
            v += "^"
            pipeline.multi()
            pipeline.set(key, v)
            time.sleep(sleep_time)
            v += "$"
            pipeline.set(key, v)
            pipeline.execute()
            pipeline.unwatch()
            print("...commited")
            time.sleep(sleep_time)
        except redis.WatchError as err:
            error_count += 1
            print(f"Watch error #{error_count}:", err)
    print(len(v))
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto skriptu
naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer8.py</a>.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Chování klienta ve chvíli, kdy běží další klient zapisující do prvku se stejným klíčem</h2>

<p>Klient popsaný <a href="#k15">v&nbsp;předchozí kapitole</a> by se měl chovat
korektně i v&nbsp;případě, že se během jeho transakce provede přístup
k&nbsp;hodnotě pod stejným klíčem. Můžeme si to ověřit, když souběžně
v&nbsp;jiném terminálu spustíme následujícího klienta. Ten se snaží hodnotu
zcela přepsat, bez ohledu na transakce či další klienty:</p>

<pre>
import time
import redis
&nbsp;
&nbsp;
redis_client = redis.StrictRedis(
    host="localhost",
    port="6379",
    decode_responses=True,
)
&nbsp;
key = "bar"
sleep_time = 0.18
&nbsp;
while True:
    redis_client.set(key, "that's me")
    time.sleep(sleep_time)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto skriptu
naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/annoying_producer.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/annoying_producer.py</a>.</div></p>

<p>Po současném spuštění obou producentů (i testovacího konzumenta) je snadné
zjistit, že se skutečně detekují zápisy hodnoty pod stejným klíčem a že se
v&nbsp;tomto případě transakce (jako celek) neprovede, protože se nezavolá
metoda <strong>exec</strong> (namísto toho se přejde do obsluhy výjimky):</p>

<pre>
transaction started...Watch error #8: Watched variable changed.
transaction started......commited
transaction started......commited
transaction started......commited
transaction started......commited
transaction started...Watch error #9: Watched variable changed.
transaction started......commited
transaction started......commited
transaction started......commited
transaction started......commited
transaction started...Watch error #10: Watched variable changed.
transaction started......commited
transaction started......commited
transaction started......commited
transaction started......commited
transaction started...Watch error #11: Watched variable changed.
transaction started......commited
transaction started......commited
transaction started......commited
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Konkrétní problém &ndash; atomické připojení zpráv do seznamu uloženého v&nbsp;Redisu</h2>

<p>Pro zajímavost se podívejme na konkrétní problém řešený s&nbsp;využitím
Redisu. Jedná se o cache určenou pro úschovu konverzace (seznamu zpráv),
přičemž kromě klasické operace <strong>get</strong> potřebujeme realizovat i
operaci typu <strong>insert_or_append</strong> (klasický příkaz
<strong>append</strong> nebude plně funkční). A právě tuto operaci je možné
naprogramovat s&nbsp;využitím optimistického zamykání v&nbsp;kombinaci
s&nbsp;pipeline:</p>

<pre>
<i>"""Cache that uses Redis to store cached values."""</i>
&nbsp;
import pickle
import threading
from typing import Any, Optional
import logging
&nbsp;
import redis
from redis.retry import Retry
&nbsp;
&nbsp;
class <strong>BaseMessage</strong>:
    def <strong>__init__</strong>(self, content):
        self.content = content
&nbsp;
    def <strong>__str__</strong>(self):
        return self.content
&nbsp;
&nbsp;
class <strong>RedisCache</strong>:
    <i>"""Cache that uses Redis to store cached values."""</i>
&nbsp;
    def <strong>__init__</strong>(self):
        self.initialize_redis()
&nbsp;
    def <strong>initialize_redis</strong>(self) -&gt; None:
        <i>"""Initialize the Redis client and logging.</i>
&nbsp;
        <i>This method sets up the Redis client with custom configuration parameters.</i>
        <i>"""</i>
&nbsp;
        <i># initialize Redis client</i>
        self.redis_client = redis.StrictRedis(
            host="localhost",
            port=6379,
            decode_responses=False,  <i># we store serialized messages as bytes, not strings</i>
        )
        <i># Set custom configuration parameters</i>
&nbsp;
    def <strong>get</strong>(self, user_id: str, conversation_id: str):
        <i>"""Get the value associated with the given key.</i>
&nbsp;
        <i>Args:</i>
            <i>user_id: User identification.</i>
            <i>conversation_id: Conversation ID unique for given user.</i>
&nbsp;
        <i>Returns:</i>
            <i>The value associated with the key, or None if not found.</i>
        <i>"""</i>
        key = user_id + ":" + conversation_id
&nbsp;
        value = self.redis_client.get(key)
        if value is None:
            return None
        return pickle.loads(value, errors="strict")  <i># noqa S301</i>
&nbsp;
    def <strong><strong>insert_or_append</strong></strong>(self, user_id: str, conversation_id: str, value) -&gt; None:
        <i>"""Set the value associated with the given key.</i>
&nbsp;
        <i>Args:</i>
            <i>user_id: User identification.</i>
            <i>conversation_id: Conversation ID unique for given user.</i>
            <i>value: The value to set.</i>
&nbsp;
        <i>Raises:</i>
            <i>OutOfMemoryError: If item is evicted when Redis allocated</i>
                <i>memory is higher than maxmemory.</i>
        <i>"""</i>
        key = user_id + ":" + conversation_id
&nbsp;
        while True:
            with self.redis_client.pipeline(transaction=True) as pipeline:
                try:
                    logging.debug("Transaction started")
                    pipeline.watch(key)
                    old_value = self.get(user_id, conversation_id)
                    pipeline.multi()
                    if old_value:
                        old_value.extend(value)
                        pipeline.set(
                            key,
                            pickle.dumps(old_value, protocol=pickle.HIGHEST_PROTOCOL),
                        )
                    else:
                        pipeline.set(
                            key, pickle.dumps(value, protocol=pickle.HIGHEST_PROTOCOL)
                        )
                    pipeline.execute()
                    pipeline.unwatch()
                    logging.debug("Transaction finished")
                    break
                except redis.WatchError as err:
                    logging.info("Watch error", err)
</pre>

<p>A takto vypadá test, který ověřuje atomičnost operace
<strong>insert_or_append</strong> i ve chvíli, kdy běží dva klienti připojující
zprávy do historie:</p>

<pre>
import multiprocessing
import time
import redis
&nbsp;
&nbsp;
PRODUCER_CYCLES = 100
PRODUCER_SLEEP_TIME = 0.1
&nbsp;
USER_ID = "1234"
CONVERSATION_ID = "5678"
&nbsp;
&nbsp;
from redis_cache import RedisCache
from redis_cache import BaseMessage
&nbsp;
&nbsp;
def producer_1(cycles, user_id, conversation_id, sleep_time):
    redis_cache = RedisCache()
&nbsp;
    for i in range(cycles):
        message = [BaseMessage(f"message #{i}")]
        redis_cache.insert_or_append(user_id, conversation_id, message)
        time.sleep(sleep_time)
&nbsp;
&nbsp;
def producer_2(cycles, user_id, conversation_id, sleep_time):
    redis_cache = RedisCache()
&nbsp;
    for i in range(cycles):
        message = [BaseMessage(f"second producer")]
        redis_cache.insert_or_append(user_id, conversation_id, message)
        time.sleep(sleep_time)
&nbsp;
&nbsp;
def test_atomic_insert_or_append():
    redis_cache = RedisCache()
&nbsp;
    <i># make sure the conversation is cleared before testing</i>
    redis_cache.redis_client.delete(USER_ID + ":" + CONVERSATION_ID)
&nbsp;
    queue = multiprocessing.Queue()
&nbsp;
    <i># construct both producers</i>
    producer_1_process = multiprocessing.Process(
        target=producer_1,
        args=(PRODUCER_CYCLES, USER_ID, CONVERSATION_ID, PRODUCER_SLEEP_TIME),
    )
    producer_2_process = multiprocessing.Process(
        target=producer_2,
        args=(PRODUCER_CYCLES, USER_ID, CONVERSATION_ID, PRODUCER_SLEEP_TIME),
    )
&nbsp;
    start_time = time.perf_counter()
&nbsp;
    <i># start both producers</i>
    producer_1_process.start()
    producer_2_process.start()
&nbsp;
    <i># wait for producers</i>
    print("Waiting for producers to finish")
    producer_1_process.join()
    producer_2_process.join()
    print("Finished")
&nbsp;
    <i># compute duration</i>
    end_time = time.perf_counter()
    duration = end_time - start_time
    print(f"Duration: {duration:4.3} seconds")
&nbsp;
    <i># read messages from cache and perform elementary checks</i>
    messages = redis_cache.get(USER_ID, CONVERSATION_ID)
    assert len(messages) == PRODUCER_CYCLES * 2
&nbsp;
    <i># PRODUCER_CYCLES messages needs to be in cache in proper order</i>
    index = 0
    for message in messages:
        if message.content == "second producer":
            continue
        expected = f"message #{index}"
        assert message.content == expected, f"Wrong message content {message.content}"
        index += 1
&nbsp;
&nbsp;
if __name__ == "__main__":
    print("Running test")
    test_atomic_insert_or_append()
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů (resp.&nbsp;spíše
pomocných skriptů) určených pro programovací jazyk Python 3 a knihovnu
<i>redis-py</i> byly uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>consumer1.py</td><td>konzument, který neustále hodnotu uloženou pod určitým klíčem a sleduje, zda nedošlo k&nbsp;její změně</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/consumer1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/consumer1.py</a></td></tr>
<tr><td> 2</td><td>consumer2.py</td><td>podobně koncipovaný konzument, ovšem testující pouze poslední dva znaky v&nbsp;hodnotě čtené z&nbsp;databáze</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/consumer2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/consumer2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>producer1.py</td><td>producent zapisující pod stejným klíčem dvě rozdílné hodnoty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer1.py</a></td></tr>
<tr><td> 4</td><td>producer2.py</td><td>producent zapisující pod stejným klíčem dvě rozdílné hodnoty rychle za sebou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer2.py</a></td></tr>
<tr><td> 5</td><td>producer3.py</td><td>producent používající transakci (pipeline)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer3.py</a></td></tr>
<tr><td> 6</td><td>producer4.py</td><td>operace <strong>get-and-set</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer4.py</a></td></tr>
<tr><td> 7</td><td>producer5.py</td><td>pokus o realizaci operace <strong>get-and-set</strong> v&nbsp;pipeline</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer5.py</a></td></tr>
<tr><td> 8</td><td>producer6.py</td><td>operace <strong>get</strong> následovaná pipeline</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer6.py</a></td></tr>
<tr><td> 9</td><td>producer7.py</td><td>optimistické zamykání</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer7.py</a></td></tr>
<tr><td>10</td><td>producer8.py</td><td>optimistické zamykání, pipeline je správce kontextu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer8.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>annoying_producer.py</td><td>producent, který do Redisu posílá neočekávané hodnoty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/annoying_producer.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/annoying_producer.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>producer_consumer_test1.py</td><td>spojení prvního producenta a konzumenta do uceleného testu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer_consumer_test1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer_consumer_test1.py</a></td></tr>
<tr><td>13</td><td>producer_consumer_test2.py</td><td>spojení druhého producenta a konzumenta do uceleného testu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer_consumer_test2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer_consumer_test2.py</a></td></tr>
<tr><td>14</td><td>producer_consumer_test3.py</td><td>spojení třetího producenta a konzumenta do uceleného testu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer_consumer_test3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer_consumer_test3.py</a></td></tr>
<tr><td>15</td><td>producer_consumer_test4.py</td><td>spojení čtvrtého producenta a konzumenta do uceleného testu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer_consumer_test4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer_consumer_test4.py</a></td></tr>
<tr><td>16</td><td>producer_consumer_test6.py</td><td>spojení šestého producenta a konzumenta do uceleného testu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer_consumer_test6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer_consumer_test6.py</a></td></tr>
<tr><td>17</td><td>producer_consumer_test7.py</td><td>spojení sedmého producenta a konzumenta do uceleného testu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer_consumer_test7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/producer_consumer_test7.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>redis_cache.py</td><td>implementace jednoduché cache založené na Redisu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/redis_cache.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/redis_cache.py</a></td></tr>
<tr><td>19</td><td>test_atomic_redis_cache.py</td><td>test atomicity operací implementované cache</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/redis/test_atomic_redis_cache.py">https://github.com/tisnik/most-popular-python-libs/blob/master/redis/test_atomic_redis_cache.py</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části seriálu</h2>

<p>V&nbsp;této kapitole jsou uvedeny odkazy na všechny části seriálu,
v&nbsp;němž se zabýváme různými způsoby implementace front zpráv a k&nbsp;nim
přidružených technologií (a to včetně Redisu &ndash; i když dnes jsme Redis
používali spíše jako key-value databázi):</p>

<ol>

<li>Databáze Redis (nejenom) pro vývojáře používající Python<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python (dokončení)<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/</a>
</li>

<li>Použití databáze Redis v&nbsp;aplikacích naprogramovaných v Go<br />
<a href="https://www.root.cz/clanky/pouziti-databaze-redis-v-aplikacich-naprogramovanych-v-go/">https://www.root.cz/clanky/pouziti-databaze-redis-v-aplikacich-naprogramovanych-v-go/</a>
</li>

<li>Použití databáze Redis v&nbsp;aplikacích naprogramovaných v Go (2)<br />
<a href="https://www.root.cz/clanky/pouziti-databaze-redis-v-aplikacich-naprogramovanych-v-go-2/">https://www.root.cz/clanky/pouziti-databaze-redis-v-aplikacich-naprogramovanych-v-go-2/</a>
</li>

<li>Použití nástroje RQ (Redis Queue) pro správu úloh zpracovávaných na pozadí<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/">https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/</a>
</li>

<li>Celery: systém implementující asynchronní fronty úloh pro Python<br />
<a href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python/">https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python/</a>
</li>

<li>Celery: systém implementující asynchronní fronty úloh pro Python (dokončení)<br />
<a href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python-dokonceni/">https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python-dokonceni/</a>
</li>

<li>RabbitMQ: jedna z nejúspěšnějších implementací brokera<br />
<a href="https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/">https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/</a>
</li>

<li>Pokročilejší operace nabízené systémem RabbitMQ<br />
<a href="https://www.root.cz/clanky/pokrocilejsi-operace-nabizene-systemem-rabbitmq/">https://www.root.cz/clanky/pokrocilejsi-operace-nabizene-systemem-rabbitmq/</a>
</li>

<li>ØMQ: knihovna pro asynchronní předávání zpráv<br />
<a href="https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/">https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/</a>
</li>

<li>Další možnosti poskytované knihovnou ØMQ<br />
<a href="https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/">https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/</a>
</li>

<li>Další možnosti nabízené knihovnou ØMQ, implementace protokolů ØMQ v&nbsp;čisté Javě<br />
<a href="https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/">https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/</a>
</li>

<li>Apache ActiveMQ &ndash; další systém implementující message brokera<br />
<a href="https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/">https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/</a>
</li>

<li>Použití Apache ActiveMQ s&nbsp;protokolem STOMP<br />
<a href="https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-stomp/">https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-stomp/</a>
</li>

<li>Použití Apache ActiveMQ s&nbsp;protokolem AMQP, jazyk Go a message brokeři<br />
<a href="https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-amqp-jazyk-go-a-message-brokeri/">https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-amqp-jazyk-go-a-message-brokeri/</a>
</li>

<li>Komunikace s&nbsp;message brokery z&nbsp;programovacího jazyka Go<br />
<a href="https://www.root.cz/clanky/komunikace-s-message-brokery-z-programovaciho-jazyka-go/">https://www.root.cz/clanky/komunikace-s-message-brokery-z-programovaciho-jazyka-go/</a>
</li>

<li>Použití message brokeru NATS<br />
<a href="https://www.root.cz/clanky/pouziti-message-brokeru-nats/">https://www.root.cz/clanky/pouziti-message-brokeru-nats/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://www.root.cz/clanky/nats-streaming-server/">https://www.root.cz/clanky/nats-streaming-server/</a>
</li>

<li>Implementace různých komunikačních strategií s využitím knihovny nanomsg<br />
<a href="https://www.root.cz/clanky/implementace-ruznych-komunikacnich-strategii-s-vyuzitim-knihovny-nanomsg/">https://www.root.cz/clanky/implementace-ruznych-komunikacnich-strategii-s-vyuzitim-knihovny-nanomsg/</a>
</li>

<li>Dokončení popisu komunikačních strategií poskytovaných knihovnou nanomsg<br />
<a href="https://www.root.cz/clanky/dokonceni-popisu-komunikacnich-strategii-poskytovanych-knihovnou-nanomsg/">https://www.root.cz/clanky/dokonceni-popisu-komunikacnich-strategii-poskytovanych-knihovnou-nanomsg/</a>
</li>

<li>Komunikace s&nbsp;využitím knihovny nanomsg a programovacího jazyka Python<br />
<a href="https://www.root.cz/clanky/komunikace-s-vyuzitim-knihovny-nanomsg-a-programovaciho-jazyka-python/">https://www.root.cz/clanky/komunikace-s-vyuzitim-knihovny-nanomsg-a-programovaciho-jazyka-python/</a>
</li>

<li>Dramatiq: knihovna pro práci s&nbsp;frontami úloh v&nbsp;Pythonu<br />
<a href="https://www.root.cz/clanky/dramatiq-knihovna-pro-praci-s-frontami-uloh-v-pythonu/">https://www.root.cz/clanky/dramatiq-knihovna-pro-praci-s-frontami-uloh-v-pythonu/</a>
</li>

<li>Durable Queue aneb implementace front zpráv bez použití klasického message brokera<br />
<a href="https://www.root.cz/clanky/durable-queue-aneb-implementace-front-zprav-bez-pouziti-klasickeho-message-brokera/">https://www.root.cz/clanky/durable-queue-aneb-implementace-front-zprav-bez-pouziti-klasickeho-message-brokera/</a>
</li>

<li>Nsq &ndash; systém pro doručování zpráv bez centrálního message brokera<br />
<a href="https://www.root.cz/clanky/nsq-system-pro-dorucovani-zprav-bez-centralniho-message-brokera/">https://www.root.cz/clanky/nsq-system-pro-dorucovani-zprav-bez-centralniho-message-brokera/</a>
</li>

<li>NSQ &ndash; systém pro doručování zpráv bez centrálního message brokera (dokončení)<br />
<a href="https://www.root.cz/clanky/nsq-system-pro-dorucovani-zprav-bez-centralniho-message-brokera-dokonceni/">https://www.root.cz/clanky/nsq-system-pro-dorucovani-zprav-bez-centralniho-message-brokera-dokonceni/</a>
</li>

<li>Fronty zpráv podle Systemu V<br />
<a href="https://www.root.cz/clanky/fronty-zprav-podle-systemu-v/">https://www.root.cz/clanky/fronty-zprav-podle-systemu-v/</a>
</li>

<li>Implementace front zpráv podle normy POSIX<br />
<a href="https://www.root.cz/clanky/implementace-front-zprav-podle-normy-posix/">https://www.root.cz/clanky/implementace-front-zprav-podle-normy-posix/</a>
</li>

<li>Apache Kafka: distribuovaná streamovací platforma<br />
<a href="https://www.root.cz/clanky/apache-kafka-distribuovana-streamovaci-platforma/">https://www.root.cz/clanky/apache-kafka-distribuovana-streamovaci-platforma/</a>
</li>

<li>Nástroj huey: užitečná knihovna pro práci s frontami úloh v Pythonu<br />
<a href="https://www.root.cz/clanky/nastroj-huey-uzitecna-knihovna-pro-praci-s-frontami-uloh-v-pythonu/">https://www.root.cz/clanky/nastroj-huey-uzitecna-knihovna-pro-praci-s-frontami-uloh-v-pythonu/</a>
</li>

<li>Pokročilý streaming založený na Apache Kafce, jazyku Clojure a knihovně Jackdaw<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw/</a>
</li>

<li>Pokročilý streaming založený na Apache Kafce, jazyku Clojure a knihovně Jackdaw (2. část)<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw-2-cast/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw-2-cast/</a>
</li>

<li>Pokročilý streaming založený na projektu Apache Kafka, jazyku Clojure a knihovně Jackdaw (streamy a kolony)<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-projektu-apache-kafka-jazyku-clojure-a-knihovne-jackdaw-streamy-a-kolony/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-projektu-apache-kafka-jazyku-clojure-a-knihovne-jackdaw-streamy-a-kolony/</a>
</li>

<li>Sledování činnosti systému Apache Kafka přes JMX i metriky Promethea<br />
<a href="https://www.root.cz/clanky/sledovani-cinnosti-systemu-apache-kafka-pres-jmx-i-metriky-promethea/">https://www.root.cz/clanky/sledovani-cinnosti-systemu-apache-kafka-pres-jmx-i-metriky-promethea/</a>
</li>

<li>Sledování činnosti systému Apache Kafka přes JMX i metriky Promethea (dokončení)<br />
<a href="https://www.root.cz/clanky/sledovani-cinnosti-systemu-apache-kafka-pres-jmx-i-metriky-promethea-dokonceni/">https://www.root.cz/clanky/sledovani-cinnosti-systemu-apache-kafka-pres-jmx-i-metriky-promethea-dokonceni/</a>
</li>

<li>Využití Redisu z jazyka Clojure pomocí knihovny Carmine<br />
<a href="https://www.root.cz/clanky/vyuziti-redisu-z-jazyka-clojure-pomoci-knihovny-carmine/">https://www.root.cz/clanky/vyuziti-redisu-z-jazyka-clojure-pomoci-knihovny-carmine/</a>
</li>

<li>Využití Redisu z jazyka Clojure pomocí knihovny Carmine (dokončení)<br />
<a href="https://www.root.cz/clanky/vyuziti-redisu-z-jazyka-clojure-pomoci-knihovny-carmine-dokonceni/">https://www.root.cz/clanky/vyuziti-redisu-z-jazyka-clojure-pomoci-knihovny-carmine-dokonceni/</a>
</li>

<li>JetStream: nová technologie brokeru NATS konkurující Kafce<br />
<a href="https://www.root.cz/clanky/jetstream-nova-technologie-brokeru-nats-konkurujici-kafce/">https://www.root.cz/clanky/jetstream-nova-technologie-brokeru-nats-konkurujici-kafce/</a>
</li>

<li>Kafka Connect: tvorba producentů a konzumentů bez zdrojového kódu <br />
<a href="https://www.root.cz/clanky/kafka-connect-tvorba-producentu-a-konzumentu-bez-zdrojoveho-kodu/">https://www.root.cz/clanky/kafka-connect-tvorba-producentu-a-konzumentu-bez-zdrojoveho-kodu/</a>
</li>

<li>Kafka Connect: definice a kontrola schématu zpráv<br />
<a href="https://www.root.cz/clanky/kafka-connect-definice-a-kontrola-schematu-zprav/">https://www.root.cz/clanky/kafka-connect-definice-a-kontrola-schematu-zprav/</a>
</li>

<li>Témata, oddíly a replikace v systému Apache Kafka<br />
<a href="https://www.root.cz/clanky/temata-oddily-a-replikace-v-systemu-apache-kafka/">https://www.root.cz/clanky/temata-oddily-a-replikace-v-systemu-apache-kafka/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Transactions<br />
<a href="https://redis.io/docs/interact/transactions/">https://redis.io/docs/interact/transactions/</a>
</li>

<li>MULTI<br />
<a href="https://redis.io/commands/multi/">https://redis.io/commands/multi/</a>
</li>

<li>EXEC<br />
<a href="https://redis.io/commands/exec/">https://redis.io/commands/exec/</a>
</li>

<li>DISCARD<br />
<a href="https://redis.io/commands/discard/">https://redis.io/commands/discard/</a>
</li>

<li>WATCH<br />
<a href="https://redis.io/commands/watch/">https://redis.io/commands/watch/</a>
</li>

<li>UNWATCH<br />
<a href="https://redis.io/commands/unwatch/">https://redis.io/commands/unwatch/</a>
</li>

<li>You Don’t Need Transaction Rollbacks in Redis<br />
<a href="https://redis.com/blog/you-dont-need-transaction-rollbacks-in-redis/">https://redis.com/blog/you-dont-need-transaction-rollbacks-in-redis/</a>
</li>

<li>Proudy (streams) podporované systémem Redis<br />
<a href="https://www.root.cz/clanky/proudy-streams-podporovane-systemem-redis/">https://www.root.cz/clanky/proudy-streams-podporovane-systemem-redis/</a>
</li>

<li>Proudy (streams) podporované systémem Redis (dokončení)<br />
<a href="https://www.root.cz/clanky/proudy-streams-podporovane-systemem-redis-dokonceni/">https://www.root.cz/clanky/proudy-streams-podporovane-systemem-redis-dokonceni/</a>
</li>

<li>Redis Queue (RQ)<br />
<a href="https://www.fullstackpython.com/redis-queue-rq.html">https://www.fullstackpython.com/redis-queue-rq.html</a>
</li>

<li>Python Celery &amp; RabbitMQ Tutorial<br />
<a href="https://tests4geeks.com/python-celery-rabbitmq-tutorial/">https://tests4geeks.com/python-celery-rabbitmq-tutorial/</a>
</li>

<li>Introducing RQ<br />
<a href="https://nvie.com/posts/introducing-rq/">https://nvie.com/posts/introducing-rq/</a>
</li>

<li>Asynchronous Tasks with Flask and Redis Queue<br />
<a href="https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue">https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Stránky projektu Redis<br />
<a href="https://redis.io/">https://redis.io/</a>
</li>

<li>Introduction to Redis<br />
<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a>
</li>

<li>Try Redis<br />
<a href="http://try.redis.io/">http://try.redis.io/</a>
</li>

<li>Redis tutorial, April 2010 (starší, ale pěkně udělaný)<br />
<a href="https://static.simonwillison.net/static/2010/redis-tutorial/">https://static.simonwillison.net/static/2010/redis-tutorial/</a>
</li>

<li>Python Redis<br />
<a href="https://redislabs.com/lp/python-redis/">https://redislabs.com/lp/python-redis/</a>
</li>

<li>Redis: key-value databáze v paměti i na disku<br />
<a href="https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/">https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/</a>
</li>

<li>Praktický úvod do Redis (1): vaše distribuovaná NoSQL cache<br />
<a href="http://www.cloudsvet.cz/?p=253">http://www.cloudsvet.cz/?p=253</a>
</li>

<li>Praktický úvod do Redis (2): transakce<br />
<a href="http://www.cloudsvet.cz/?p=256">http://www.cloudsvet.cz/?p=256</a>
</li>

<li>Praktický úvod do Redis (3): cluster<br />
<a href="http://www.cloudsvet.cz/?p=258">http://www.cloudsvet.cz/?p=258</a>
</li>

<li>Connection pool<br />
<a href="https://en.wikipedia.org/wiki/Connection_pool">https://en.wikipedia.org/wiki/Connection_pool</a>
</li>

<li>Instant Redis Sentinel Setup<br />
<a href="https://github.com/ServiceStack/redis-config">https://github.com/ServiceStack/redis-config</a>
</li>

<li>How to install REDIS in Linux<br />
<a href="https://linuxtechlab.com/how-install-redis-server-linux/">https://linuxtechlab.com/how-install-redis-server-linux/</a>
</li>

<li>Redis RDB Dump File Format<br />
<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a>
</li>

<li>Redis Persistence<br />
<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a>
</li>

<li>Redis persistence demystified<br />
<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a>
</li>

<li>Redis reliable queues with Lua scripting<br />
<a href="http://oldblog.antirez.com/post/250">http://oldblog.antirez.com/post/250</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

