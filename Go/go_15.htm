<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Go a grafika: tvorba animovaných GIFů, grafická knihovna GG</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Go a grafika: tvorba animovaných GIFů, grafická knihovna GG</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Základní vlastnosti grafického formátu GIF</a></p>
<p><a href="#k02">*** 2. Export rastrových obrázků do formátu GIF</a></p>
<p><a href="#k03">*** 3. Rozdíl při exportu obrázků s&nbsp;barvovým prostorem RGBA a obrázků s&nbsp;barvovou paletou</a></p>
<p><a href="#k04">*** 4. </a></p>
<p><a href="#k05">*** 5. </a></p>
<p><a href="#k06">*** 6. Vytvoření jednoduchého animovaného GIFu &ndash; blikající čtvereček</a></p>
<p><a href="#k07">*** 7. Vytvoření jednoduchého animovaného GIFu &ndash; blikající čtvereček</a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Základní vlastnosti grafického formátu GIF</h2>

<p><i>&bdquo;This format has the unique quality that, like the AK47, in a lot
of circumstances, it just works, unlike the more complex
alternatives.&ldquo;</i></p>

<p>V&nbsp;úvodní části dnešního článku si ukážeme práci s&nbsp;grafickým formátem GIF v&nbsp;programovacím jazyku Go. První varianta grafického formátu GIF vznikla již v&nbsp;roce 1987 (ostatně proto se taky tato verze jmenuje GIF87a), takže se jedná o formát, který se v&nbsp;oboru IT udržel již neskutečných 32 let. Dnes se budeme zabývat převážně novější verzí GIFu pocházející z&nbsp;roku 1989. Tato varianta se jmenuje GIF89a a jedná se o formát, jenž je význačný především tím, že podporuje animace a v&nbsp;neposlední řadě i tím, že GIF je prakticky univerzálně akceptovaný napříč většinou počítačových architektur a platforem (a to i těch historických). Pokud je tedy zapotřebí vložit na webovou stránku nějakou jednoduchou animaci (ideálně v&nbsp;případě, že se jedná o animaci s&nbsp;objekty ostrých tvarů s&nbsp;malým počtem barev), je u GIFu prakticky zaručeno, že příjemce bude schopen si animaci prohlédnout, a to bez nutnosti instalace kodeků či nějakých pluginů do prohlížečů.</p>

<p>V&nbsp;dalších odstavcích se zmíníme o některých omezeních GIFu. Jedno zásadní omezení spočívacící v&nbsp;patentovaném algoritmu už sice není relevantní, ale technická omezení způsobila, že vzniklo několik alternativ, které měly GIF v&nbsp;oblasti jednoduchých animací nahradit. V&nbsp;první řadě se jednalo o formát MNG (Multiple-image Network Graphics), jenž je založený na populárním PNG. Na rozdíl od PNG (pouze statické obrázky) se však MNG příliš nerozšířil a nakonec byla jeho podpora odstraněna i z&nbsp;webových prohlížečů, s&nbsp;tím, že by měl být MNG nahrazen jiným formátem nazvaným APNG neboli Animated Portable Network Graphics. Tento formát je podporován ve většině významných prohlížečů, viz též <a href="https://caniuse.com/#feat=apng">Can I use: Animated PNG (APNG)</a>, ovšem s&nbsp;tím varováním, že podpora chybí pro IE a Edge: <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/apngimageformat/">Edge platform status</a>. I přes relativně dobrou podporu jak na straně prohlížečů, tak i na straně SW pro výrobu animací, však není APNG zdaleka tak rozšířen, jako &bdquo;starý dobrý&ldquo; GIF a proto je znalost práce s&nbsp;GIFem stále relevantní.</p>

<p><div class="rs-tip-major">Poznámka: dnes nás pochopitelně bude zajímat především programová tvorba animovaných GIFů, protože jazyk Go se bude v&nbsp;tomto případě používat na straně serveru vytvářejícího a nabízejícího (dynamický) obsah.</div></p>

*** image ***
<p><i>Obrázek 1: Takřka ideální kandidát na použití animovaného GIFu &ndash; výsledek jednoduché simulace.</i></p>

<p>Grafický formát GIF primárně slouží pro záznam a přenos grafických informací
uložených ve formě bitmapy, tj.&nbsp;obecně vícebarevného rastrového obrázku.
Většina z&nbsp;dnes používaných grafických formátů, například JPEG, PNG, TGA či
BMP obsahuje popis rastrového obrázku jako celku, přičemž se (buď přímo nebo
v&nbsp;komprimované podobě) ukládají barvové hodnoty všech pixelů, ze kterých
se rastrový obrázek skládá.</p>

<p>V&nbsp;grafickém formátu GIF je však použit odlišný přístup. Celý obrázek,
který je zde nazývaný logická obrazovka (<i>logical screen</i>), není
v&nbsp;souboru uložen jako jeden celek, ale skládá se z&nbsp;několika
takzvaných rámců (<i>frame</i>), což jsou obdélníkové oblasti umístěné uvnitř
logické obrazovky. Minimálně musí být vždy přítomen jeden rámec, jejich
maximální množství však není omezeno. Každý rámec je možné chápat jako rastrový
obrázek, který je celou svou plochou umístěn v&nbsp;logické obrazovce &ndash;
podle specifikace nesmí žádný pixel z&nbsp;rámce padnout mimo logickou
obrazovku. Pozice rámce v&nbsp;logické obrazovce je určena souřadnicí jeho
horního levého rohu a velikostí (šířkou, výškou) zadanou v&nbsp;pixelech. Dále
může být k&nbsp;rámci přiřazena <i>lokální barvová paleta</i>, pokud však není
přítomna, použije se <i>globální barvová paleta</i> (viz další text).</p>

<p><div class="rs-tip-major">Poznámka: právě nutnost specifikace velikosti a umístění rámce vedla k&nbsp;tomu, že ve standardní knihovně <strong>draw</strong> <a href="">popsané minule</a> se při vytváření rastrových obrázků používá datová struktura <strong>Rectangle</strong>, i když by v&nbsp;jiném případě postačovalo specifikovat šířku a výšku obrázků v&nbsp;pixelech.</div></p>

*** image ***
<p><i>Obrázek 2: Vztah mezi logickou obrazovkou a rámci</p></i></p>

<p>Na předchozím obrázku je naznačené, jakým způsobem může být logická
obrazovka popsána pomocí rámců. Vidíme, že není nutné, aby rámce pokryly celou
logickou obrazovku, rámce se dokonce mohou v&nbsp;případě potřeby navzájem
překrývat. Jak uvidíme dále, je při překryvu rámců možné použít transparentní
pixely, takže překryv může být ve skutečnosti mnohem složitější, než pouhé
přepsání barev pixelů v&nbsp;zadané obdélníkové oblasti.</p>

<p>Rámce nachází v&nbsp;grafickém formátu GIF mnoho uplatnění. Na dalších dvou
obrázcích je naznačeno, jakým způsobem je možné použít rámce pro redukci
celkové velikosti obrázku. Prázdné bílé plochy není nutné explicitně ukládat,
může se zde pouze vykreslit barva pozadí. Algoritmus LZW je, podobně jako
některé další algoritmy použité pro komprimaci obrázků (kromě primitivního
RLE), poměrně hloupý a zbytečně by si sekvencemi stejných bytů zaplnil
hashovací tabulku a tím by byl nucen ji buď rozšířit, nebo uvést do původní
podoby (bez zapamatovaných sekvencí delších než jeden pixel). Obojí však vede
ke zvětšení výsledného souboru. Mimochodem, na obrázcích 5 a 6 je ukázána
úvodní stránka z&nbsp;první kapitoly T<sub>E</sub>Xbooku.</p>

<p><img src="gif2_5.gif" /><br />
Obrázek 5: Obrázek uložený v&nbsp;jednom rámci</p>

<p><img src="gif2_6.gif" /><br />
Obrázek 6: Obrázek rozdělený na tři rámce s&nbsp;využitím barvy pozadí (ta je pro ilustraci zobrazena šedě)</p>

<p>Vzhledem k&nbsp;tomu, že každý pixel umístěný v&nbsp;rámci může být popsán
maximálně osmi bity, znamená to, že jeho barvu je možné vybrat z&nbsp;barvové
palety obsahující nejvýše 256 barev. Každá barva je v&nbsp;barvové paletě
popsána trojicí hodnot &ndash; barvových složek označených písmeny R
(<i>red</i>), G (<i>green</i>) a B (<i>blue</i>), přičemž každá barvová složka
je uložena v&nbsp;jednom bytu. Minimální velikost barvové palety (se dvěma
barvami) je proto rovna šesti bytům (2&times;3), maximální velikost barvové
palety s&nbsp;256 barvami pak 768 bytům (256&times;3). U&nbsp;mnoha obrázků se
proto může stát, že barvová paleta tvoří nezanedbatelnou část jejich celkové
velikosti.</p>

<p><div class="rs-tip-major">Poznámka: to znamená, že knihovna
<strong>draw</strong> musí obrázky převádět do barvového prostoru omezeného
paletou s&nbsp;maximálně 256 barvami (i když je teoreticky možné
s&nbsp;využitím rámců dosáhnout efektu většího množství barev).</div></p>

<p>V&nbsp;grafickém formátu GIF rozlišujeme dvě barvové palety: globální a
lokální. Globální barvová paleta (<i>global color table</i>) může
v&nbsp;souboru typu GIF existovat maximálně jednou a její velikost
(tj.&nbsp;počet barev) je zadána v&nbsp;hlavičce popisující logickou obrazovku.
V&nbsp;některých případech nemusí být globální barvová paleta přítomna vůbec.
Lokální barvová paleta (<i>local color table</i>) může být přiřazena ke každému
rámci, opět se však nejedná o povinnou součást rámce. V&nbsp;případě, že není
přítomna ani globální ani lokální barvová paleta, měl by prohlížecí program
použít systémovou paletu, v&nbsp;případě webových prohlížečů takzvanou web-safe
paletu složenou z&nbsp;216 barev rovnoměrně umístěných v&nbsp;jednotkové RGB
krychli; zbylé barvy tvoří odstíny šedi. Absence obou barvových palet sice může
zmenšit celkovou velikost souboru, způsob zobrazení se však může v&nbsp;různých
prohlížečích lišit, proto se většinou (99% případů) alespoň jedna barvová
paleta používá.</p>

<p>Důležitou součástí popisu logické obrazovky je index jedné barvy
v&nbsp;globální barvové paletě, která bude použita pro vykreslení pozadí.
Dodnes sice většina programů při ukládání GIFů každý obrázek uloží do jednoho
velikého rámce, ale při optimalizaci na velikost je možné (a některé
sofistikovanější programy to provádí), aby některé pixely logické obrazovky
nebyly pokryty žádným z&nbsp;rámců. Nepokryté pixely by poté měly být vybarveny
právě barvou pozadí. Tímto způsobem, jak si ostatně ukážeme v&nbsp;další části,
je možné vytvořit optimalizované obrázky, či dokonce obrázky o prakticky
jakékoli velikosti, které však stále budou zabírat malé místo na disku (díky
tomu, že je uložen například pouze malý rámec uprostřed obrovské volné
plochy).</p>

<p><div class="rs-tip-major">Poznámka: tuto vlastnost GIFu použijeme
v&nbsp;některých demonstračních příkladech.</div></p>

<p>Verze GIF89a přinesla oproti původní verzi GIF87a jednu podstatnou novinku
&ndash; pomocí rozšiřujícího řídicího bloku (<i>graphics control extension</i>)
je možné v&nbsp;každém rámci specifikovat jeden index do barvové palety, který
představuje průhledné pixely. Díky tomu je možné, aby optický tvar rámce nebyl
pouze obdélníkový, ale v&nbsp;podstatě libovolný. Vzhledem k&nbsp;tomu, že je
možné &bdquo;průhlednými&ldquo; pixely překreslit i původně neprůhlednou barvu
pozadí, může mít i obrázek jako celek neobdélníkový tvar, což je velmi často
využíváno zejména při tvorbě různých log na webových stránkách a
v&nbsp;neposlední řadě i v&nbsp;řadě animací. Na třetím obrázku je ukázka GIFu
s&nbsp;průhledností.</p>

*** image ***
<p><i>Obrázek 2: GIF s&nbsp;průhlednými pixely.</p></i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Export rastrových obrázků do formátu GIF</h2>

<p></p>

<pre>
img := CreateChessboard(256, 256, BoardSize)
</pre>

<pre>
outfile, err := os.Create("02.gif")
if err != nil {
        panic(err)
}
defer outfile.Close()
</pre>

<pre>
err = gif.Encode(outfile, img, nil)
if err != nil {
        panic(err)
}
</pre>

<p><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/02_gif_export_rgba.go">https://github.com/tisnik/go-fedora/blob/master/article_14/02_gif_export_rgba.go</a></p>

<pre>
package main
&nbsp;
import (
        "image"
        "image/color"
        "image/draw"
        "image/gif"
        "os"
)
&nbsp;
const BoardSize = 8
&nbsp;
func CreateChessboard(width int, height int, board_size int) *image.RGBA {
        var palette = []color.Color{
                color.RGBA{150, 205, 50, 255},
                color.RGBA{0, 100, 0, 255},
        }
&nbsp;
        img := image.NewRGBA(image.Rect(0, 0, width, height))
&nbsp;
        index_color := 0
        hor_block := int(width / board_size)
        ver_block := int(height / board_size)
&nbsp;
        x_from := 0
        x_to := hor_block
        for x := 0; x &lt; board_size; x++ {
                y_from := 0
                y_to := ver_block
                for y := 0; y &lt; board_size; y++ {
                        r := image.Rect(x_from, y_from, x_to, y_to)
                        draw.Draw(img, r, &amp;image.Uniform{palette[index_color]}, image.ZP, draw.Src)
                        y_from = y_to
                        y_to += ver_block
                        index_color = 1 - index_color
                }
                x_from = x_to
                x_to += hor_block
                index_color = 1 - index_color
        }
        return img
}
&nbsp;
func main() {
        img := CreateChessboard(256, 256, BoardSize)
&nbsp;
        outfile, err := os.Create("02.gif")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()
&nbsp;
        err = gif.Encode(outfile, img, nil)
        if err != nil {
                panic(err)
        }
}
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Rozdíl při exportu obrázků s&nbsp;barvovým prostorem RGBA a obrázků s&nbsp;barvovou paletou</h2>

<p></p>

<pre>
c := color.RGBA{255, 0, 0, 255}
img := image.NewRGBA(image.Rect(0, 0, 1, 1))
img.Set(0, 0, c)
</pre>

*** image ***
<p><i>Obrázek XX: </i></p>

<p>Pokud takový obrázek otevřeme v&nbsp;nějakém grafickém editoru, můžeme se přesvědčit o tom, že obsahuje úplnou barvovou paletu s&nbsp;256 barvami:</p>

*** image ***
<p><i>Obrázek XX: </i></p>

<p>Celková velikost souboru s&nbsp;obrázkem je taktéž až enormně velká v&nbsp;poměru k&nbsp;obrazovým informacím, které obsahuje: celých 798 bajtů!</p>

<p><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/03_gif_1x1_rgba.go">https://github.com/tisnik/go-fedora/blob/master/article_14/03_gif_1x1_rgba.go</a></p>

<pre>
package main
&nbsp;
import (
        "image"
        "image/color"
        "image/gif"
        "os"
)
&nbsp;
func CreateImage(width int, height int) *image.RGBA {
        c := color.RGBA{255, 0, 0, 255}
        img := image.NewRGBA(image.Rect(0, 0, width, height))
        img.Set(0, 0, c)
&nbsp;
        return img
}
&nbsp;
func main() {
        img := CreateImage(1, 1)
&nbsp;
        outfile, err := os.Create("03.gif")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()
&nbsp;
        err = gif.Encode(outfile, img, nil)
        if err != nil {
                panic(err)
        }
}
</pre>

<p>Tento příklad ovšem můžeme modifikovat, a to konkrétně takovým způsobem, že se namísto obrázku s&nbsp;barvovým prostorem RGBA (16 milionů barvových odstínů) použije obrázek s&nbsp;paletou. Minimální velikost palety je ve formátu GIF rovna dvěma položkám, takže si takovou paletu vytvoříme:</p>

<pre>
var palette = []color.Color{
        color.RGBA{255, 128, 128, 255},
        color.RGBA{255, 255, 255, 255},
}
</pre>

<p>Následně je možné vytvořit rastrový obrázek používající tuto paletu a nastavit jeho (jediný) pixel na zvolenou barvu vybranou z&nbsp;palety:</p>

<pre>
c := color.RGBA{255, 128, 128, 255}
img := image.NewPaletted(image.Rect(0, 0, 1, 1), palette)
img.Set(0, 0, c)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že druhým parametrem konstruktoru <strong>NewPaletted</strong> je právě barvová palety, tj.&nbsp;pole s&nbsp;prvky typu <strong>Color</strong>.</div></p>

<p>Po uložení získáme tento soubor:</p>

*** image ***
<p><i>Obrázek XX: </i></p>

<p>Jeho velikost je nyní pouhých <strong>34 bajtů</strong>, což je současně nejmenší možná velikost zcela validního obrázku uloženého ve formátu GIF.</p>

<p>Po otevření vytvořeného obrázku v&nbsp;grafickém editoru je patrné, že paleta se rapidně zmenšila na dvě položky:</p>

*** image ***
<p><i>Obrázek XX: </i></p>

<p>Upravený demonstrační příklad, který vytvoří obrázek s&nbsp;naprosto stejnou obrazovou informací jako obrázek předchozí, <a href="">může vypadat následovně</a>:</p>

<pre>
package main
&nbsp;
import (
        "image"
        "image/color"
        "image/gif"
        "os"
)
&nbsp;
func CreateImage(width int, height int) *image.Paletted {
        var palette = []color.Color{
                color.RGBA{255, 128, 128, 255},
                color.RGBA{255, 255, 255, 255},
        }
&nbsp;
        c := color.RGBA{255, 128, 128, 255}
        img := image.NewPaletted(image.Rect(0, 0, width, height), palette)
        img.Set(0, 0, c)
&nbsp;
        return img
}
&nbsp;
func main() {
        img := CreateImage(1, 1)
&nbsp;
        outfile, err := os.Create("04.gif")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()
&nbsp;
        err = gif.Encode(outfile, img, nil)
        if err != nil {
                panic(err)
        }
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Nastavení vlastností výsledného GIFu</h2>

<pre>
options := gif.Options{NumColors: 255, Quantizer: nil, Drawer: nil}
</pre>

<pre>
err = gif.Encode(outfile, img, &amp;options)
if err != nil {
        panic(err)
}
</pre>

<pre>
package main

import (
        "image"
        "image/color"
        "image/draw"
        "image/gif"
        "os"
)

const BoardSize = 8

func CreateChessboard(width int, height int, board_size int) *image.RGBA {
        var palette = []color.Color{
                color.RGBA{150, 205, 50, 255},
                color.RGBA{0, 100, 0, 255},
        }

        img := image.NewRGBA(image.Rect(0, 0, width, height))

        index_color := 0
        hor_block := int(width / board_size)
        ver_block := int(height / board_size)

        x_from := 0
        x_to := hor_block
        for x := 0; x &lt; board_size; x++ {
                y_from := 0
                y_to := ver_block
                for y := 0; y &lt; board_size; y++ {
                        r := image.Rect(x_from, y_from, x_to, y_to)
                        draw.Draw(img, r, &amp;image.Uniform{palette[index_color]}, image.ZP, draw.Src)
                        y_from = y_to
                        y_to += ver_block
                        index_color = 1 - index_color
                }
                x_from = x_to
                x_to += hor_block
                index_color = 1 - index_color
        }
        return img
}

func main() {
        img := CreateChessboard(256, 256, BoardSize)

        outfile, err := os.Create("05.gif")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()

        options := gif.Options{NumColors: 255, Quantizer: nil, Drawer: nil}

        err = gif.Encode(outfile, img, &amp;options)
        if err != nil {
                panic(err)
        }
}
</pre>

package main

import (
        "image"
        "image/color"
        "image/draw"
        "image/gif"
        "os"
)

const BoardSize = 8

func CreateChessboard(width int, height int, board_size int) *image.Paletted {
        var palette = []color.Color{
                color.RGBA{150, 205, 50, 255},
                color.RGBA{0, 100, 0, 255},
        }

        img := image.NewPaletted(image.Rect(0, 0, width, height), palette)

        index_color := 0
        hor_block := int(width / board_size)
        ver_block := int(height / board_size)

        x_from := 0
        x_to := hor_block
        for x := 0; x < board_size; x++ {
                y_from := 0
                y_to := ver_block
                for y := 0; y < board_size; y++ {
                        r := image.Rect(x_from, y_from, x_to, y_to)
                        draw.Draw(img, r, &amp;image.Uniform{palette[index_color]}, image.ZP, draw.Src)
                        y_from = y_to
                        y_to += ver_block
                        index_color = 1 - index_color
                }
                x_from = x_to
                x_to += hor_block
                index_color = 1 - index_color
        }
        return img
}

func main() {
        img := CreateChessboard(256, 256, BoardSize)

        outfile, err := os.Create("06.gif")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()

        err = gif.Encode(outfile, img, nil)
        if err != nil {
                panic(err)
        }
}



<p><a name="k05"></a></p>
<h2 id="k05">5. Omezení počtu barev ve výsledném GIFu</h2>

<pre>
package main

import (
        "fmt"
        "image"
        "image/color"
        "image/gif"
        "os"
)

const width = 512
const height = 512

func main() {
        img := image.NewNRGBA(image.Rect(0, 0, width, height))

        for x := 0; x < 256; x++ {
                for y := 0; y < 256; y++ {
                        c := color.NRGBA{0, byte(x), byte(y), 255}
                        img.SetNRGBA(x, y, c)

                        c = color.NRGBA{85, byte(x), byte(y), 255}
                        img.SetNRGBA(x+256, y, c)

                        c = color.NRGBA{170, byte(x), byte(y), 255}
                        img.SetNRGBA(x, y+256, c)

                        c = color.NRGBA{255, byte(x), byte(y), 255}
                        img.SetNRGBA(x+256, y+256, c)
                }
        }

        for colors := 1; colors <= 256; colors <<= 1 {
                filename := fmt.Sprintf("07_%03d.gif", colors)

                outfile, err := os.Create(filename)
                if err != nil {
                        panic(err)
                }
                defer outfile.Close()

                options := gif.Options{NumColors: colors, Quantizer: nil, Drawer: nil}

                gif.Encode(outfile, img, &options)
        }
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Animované GIFy</h2>

<p>Grafický formát GIF je na Internetu stále oblíbený zejména z&nbsp;toho
důvodu, že podporuje animace &ndash; a to bez nutnosti instalace pluginů na
straně prohlížeče nebo použití speciálních technik (JavaScript, streamované
video apod.). Animace byly na Internetu zavedeny s&nbsp;příchodem Netscape 2 a
posléze Internet Exploreru 3. Ve skutečnosti nejsou animace nic jiného, než
sled po sobě jdoucích rámců (které mohou ležet na sobě), mezi jejichž
zobrazením je vložena krátká či delší časová prodleva. Pokud jsou rámce
překreslovány rychlostí cca 10 snímků za sekundu, vzniká dojem poměrně plynulé
animace.</p>

<p>V&nbsp;některých případech, například při požadavcích na prezentaci krátkého
videa na webových stránkách, musí tvůrce stránek porovnat možnosti grafického
formátu GIF se souborovými či streamovými formáty určenými pro ukládání videa a
zjistit, který formát je pro jeho aplikaci výhodnější. GIF není v&nbsp;žádném
případě vhodný pro ukládání ani přehrávání větších animací, protože osmibitová
paleta je mnohdy nedostačující a mezisnímková komprimace je obecně
nedostatečná, zejména při práci s&nbsp;"reálným", tj.&nbsp;zašuměným videem.
GIF také nepodporuje ukládání zvukových stop ani přesné časování snímků (o tom
jsme se mohli předminule přesvědčit při práci s&nbsp;"true color" GIFy).</p>

<p>Pro filmy je použita větší snímková frekvence, typicky 24 či 25 snímků za
sekundu, musíme si však uvědomit, že filmové políčko má většinou mnohem větší
rozlišení, než animovaný GIF, takže případné &bdquo;trhání&ldquo; není u GIFu
tak patrné. Animace byly zavedeny až ve verzi GIF89a.</p>

<pre>
func EncodeAll(w io.Writer, g *GIF) error
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vytvoření jednoduchého animovaného GIFu &ndash; blikající čtvereček</h2>

<p>V&nbsp;dalším příkladu je ukázáno, jak snadno je možné s&nbsp;použitím základních balíčků programovacího jazyka Go vytvořit jednoduchý animovaný GIF. Celá animace bude obsahovat pouhé dva snímky, každý o rozměrech 32&times;32 pixelů, které budou vyplněny konstantní barvou. Snímky se budou opakovat ve smyčce (což je výchozí nastavení řízené jedním bitem hlavičky GIFu) a bude mezi nimi prodleva přibližně jedné sekundy.</p>

<pre>
images := []*image.Paletted{
        CreateImage(32, 32, 0),
        CreateImage(32, 32, 1),
}
</pre>

<pre>
delays := []int{100, 100}
</pre>

<pre>
gif.EncodeAll(outfile, &amp;gif.GIF{
        Image: images,
        Delay: delays,
})
</pre>

<p>Velikost výsledného animovaného GIFu s&nbsp;dvojicí snímků je rovna pouhým 147 bajtům, což je prakticky stejná velikost, jakou zabírá tato věta:</p>

*** image ***
<p><i>Obrázek XX: </i></p>

<p>Opět si ukážeme <a href="https://github.com/tisnik/go-fedora/blob/master/article_14/08_gif_animation_blink.go">úplný zdrojový kód tohoto jednoduchého demonstračního příkladu</a>:</p>

<pre>
package main
&nbsp;
import (
        "image"
        "image/color"
        "image/draw"
        "image/gif"
        "os"
)
&nbsp;
const BoardSize = 8
&nbsp;
func CreateImage(width int, height int, paletteIndex int) *image.Paletted {
        var palette []color.Color
&nbsp;
        if paletteIndex == 0 {
                palette = []color.Color{
                        color.RGBA{150, 150, 150, 255},
                }
        } else {
                palette = []color.Color{
                        color.RGBA{250, 0, 0, 255},
                }
        }
&nbsp;
        img := image.NewPaletted(image.Rect(0, 0, width, height), palette)
&nbsp;
        r := image.Rect(0, 0, width, height)
        draw.Draw(img, r, &amp;image.Uniform{palette[0]}, image.ZP, draw.Src)
&nbsp;
        return img
}
&nbsp;
func main() {
        images := []*image.Paletted{
                CreateImage(32, 32, 0),
                CreateImage(32, 32, 1),
        }
&nbsp;
        delays := []int{100, 100}
&nbsp;
        outfile, err := os.Create("08.gif")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()
&nbsp;
        gif.EncodeAll(outfile, &amp;gif.GIF{
                Image: images,
                Delay: delays,
        })
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Složitější animace &ndash; pohybující se šachovnice</h2>

<pre>
package main

import (
        "image"
        "image/color"
        "image/draw"
        "image/gif"
        "os"
)

const BoardSize = 8

func CreateChessboard(width int, height int, board_size int, xoffset int, yoffset int, step_size int) *image.Paletted {
        var palette = []color.Color{
                color.RGBA{150, 205, 50, 255},
                color.RGBA{0, 100, 0, 255},
        }

        img := image.NewPaletted(image.Rect(0, 0, width, height), palette)

        index_color := 0
        hor_block := int(width / board_size)
        ver_block := int(height / board_size)

        x_from := 0
        x_to := hor_block
        for x := 0; x < board_size+step_size; x++ {
                y_from := 0
                y_to := ver_block
                for y := 0; y < board_size+step_size; y++ {
                        r := image.Rect(x_from+xoffset, y_from+yoffset, x_to+xoffset, y_to+yoffset)
                        draw.Draw(img, r, &image.Uniform{palette[index_color]}, image.ZP, draw.Src)
                        y_from = y_to
                        y_to += ver_block
                        index_color = 1 - index_color
                }
                x_from = x_to
                x_to += hor_block
                index_color = 1 - index_color
        }
        return img
}

func main() {
        var images []*image.Paletted
        var delays []int

        steps := 2 * 256 / BoardSize
        for step := 0; step < steps; step++ {
                img := CreateChessboard(256, 256, BoardSize, step*2-steps*2, step-steps, steps*2)
                images = append(images, img)
                delays = append(delays, 10)
        }

        outfile, err := os.Create("09.gif")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()

        gif.EncodeAll(outfile, &gif.GIF{
                Image: images,
                Delay: delays,
        })
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Volba metody přechodu mezi jednotlivými snímky animace</h2>

<p></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Výchozí metoda přechodu mezi snímky</h2>

<pre>
package main

import (
        "image"
        "image/color"
        "image/draw"
        "image/gif"
        "os"
)

const BoardSize = 8

func CreateImage(width int, height int, imageIndex int) *image.Paletted {
        var palette = []color.Color{
                color.RGBA{150, 150, 150, 255},
                color.RGBA{250, 0, 0, 255},
        }

        img := image.NewPaletted(image.Rect(0, 0, width, height), palette)

        r := image.Rect(0, 0, width, height)
        draw.Draw(img, r, &amp;image.Uniform{palette[0]}, image.ZP, draw.Src)

        r2 := image.Rect(imageIndex*60, 0, imageIndex*60+50, height)
        draw.Draw(img, r2, &amp;image.Uniform{palette[1]}, image.ZP, draw.Src)

        return img
}

func main() {
        var images []*image.Paletted
        var delays []int

        for i := 0; i &lt; 6; i++ {
                img := CreateImage(350, 50, i)
                images = append(images, img)
                delays = append(delays, 100)
        }

        outfile, err := os.Create("10.gif")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()

        gif.EncodeAll(outfile, &amp;gif.GIF{
                Image: images,
                Delay: delays,
        })
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Použití nastaveného pozadí GIFu</h2>

<pre>
package main

import (
        "image"
        "image/color"
        "image/draw"
        "image/gif"
        "os"
)

const BoardSize = 8

func CreateImage(width int, height int, imageIndex int) *image.Paletted {
        var palette = []color.Color{
                color.RGBA{150, 150, 150, 0},
                color.RGBA{250, 0, 0, 255},
        }

        if imageIndex == 0 {
                img := image.NewPaletted(image.Rect(0, 0, width, height), palette)

                r := image.Rect(0, 0, width, height)
                draw.Draw(img, r, &amp;image.Uniform{palette[0]}, image.ZP, draw.Src)

                r2 := image.Rect(0, 0, 50, height)
                draw.Draw(img, r2, &amp;image.Uniform{palette[1]}, image.ZP, draw.Src)

                return img
        } else {
                img := image.NewPaletted(image.Rect(imageIndex*60, 0, imageIndex*60+50, height), palette)

                r2 := image.Rect(imageIndex*60, 0, imageIndex*60+50, height)
                draw.Draw(img, r2, &amp;image.Uniform{palette[1]}, image.ZP, draw.Src)

                return img
        }

}

func main() {
        var images []*image.Paletted
        var delays []int
        var disposals []byte

        for i := 0; i &lt; 6; i++ {
                img := CreateImage(350, 50, i)
                images = append(images, img)
                delays = append(delays, 100)
                disposals = append(disposals, gif.DisposalBackground)
        }

        outfile, err := os.Create("11.gif")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()

        gif.EncodeAll(outfile, &amp;gif.GIF{
                Image:           images,
                Delay:           delays,
                Disposal:        disposals,
                BackgroundIndex: 0,
        })
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Přechod na další snímek bez smazání snímku předchozího</h2>

<pre>
package main

import (
        "image"
        "image/color"
        "image/draw"
        "image/gif"
        "os"
)

const BoardSize = 8

func CreateImage(width int, height int, imageIndex int) *image.Paletted {
        var palette = []color.Color{
                color.RGBA{150, 150, 150, 255},
                color.RGBA{250, 0, 0, 255},
        }

        if imageIndex == 0 {
                img := image.NewPaletted(image.Rect(0, 0, width, height), palette)

                r := image.Rect(0, 0, width, height)
                draw.Draw(img, r, &amp;image.Uniform{palette[0]}, image.ZP, draw.Src)

                r2 := image.Rect(0, 0, 50, height)
                draw.Draw(img, r2, &amp;image.Uniform{palette[1]}, image.ZP, draw.Src)

                return img
        } else {
                img := image.NewPaletted(image.Rect(imageIndex*60, 0, imageIndex*60+50, height), palette)

                r2 := image.Rect(imageIndex*60, 0, imageIndex*60+50, height)
                draw.Draw(img, r2, &amp;image.Uniform{palette[1]}, image.ZP, draw.Src)

                return img
        }

}

func main() {
        var images []*image.Paletted
        var delays []int
        var disposals []byte

        for i := 0; i &lt; 6; i++ {
                img := CreateImage(350, 50, i)
                images = append(images, img)
                delays = append(delays, 100)
                disposals = append(disposals, gif.DisposalNone)
        }

        outfile, err := os.Create("12.gif")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()

        gif.EncodeAll(outfile, &amp;gif.GIF{
                Image:    images,
                Delay:    delays,
                Disposal: disposals,
        })
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Vytvoření GIFu s&nbsp;animovaným progress barem</h2>

<pre>
package main

import (
        "image"
        "image/color"
        "image/draw"
        "image/gif"
        "os"
)

const BoardSize = 8

func CreateImage(width int, height int, imageIndex int) *image.Paletted {
        var palette = []color.Color{
                color.RGBA{50, 50, 50, 255},
                color.RGBA{0, 200, 200, 255},
        }

        if imageIndex == 0 {
                img := image.NewPaletted(image.Rect(0, 0, width, height), palette)

                r := image.Rect(0, 0, width, height)
                draw.Draw(img, r, &amp;image.Uniform{palette[0]}, image.ZP, draw.Src)

                return img
        } else {
                img := image.NewPaletted(image.Rect(imageIndex, 0, imageIndex+1, height), palette)

                r := image.Rect(imageIndex, 0, imageIndex+1, height)
                draw.Draw(img, r, &amp;image.Uniform{palette[1]}, image.ZP, draw.Src)

                return img
        }

}

func main() {
        var images []*image.Paletted
        var delays []int
        var disposals []byte

        for i := 0; i &lt; 200; i++ {
                img := CreateImage(200, 10, i)
                images = append(images, img)
                delays = append(delays, 2)
                disposals = append(disposals, gif.DisposalNone)
        }

        outfile, err := os.Create("13.gif")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()

        gif.EncodeAll(outfile, &amp;gif.GIF{
                Image:    images,
                Delay:    delays,
                Disposal: disposals,
        })
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Tvorba 2D grafiky s&nbsp;využitím knihovny GG</h2>

<pre>
package main

import "github.com/fogleman/gg"

func main() {
        const width = 320
        const height = 240

        dc := gg.NewContext(width, height)

        dc.SetRGB(0.2, 0.0, 0.8)
        dc.DrawCircle(width/2, height/2, 100)

        dc.Fill()

        dc.SavePNG("14.png")
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Parametry kreslení zapamatované v&nbsp;kontextu</h2>

<pre>
package main

import "github.com/fogleman/gg"

func main() {
        const width = 320
        const height = 240

        dc := gg.NewContext(width, height)

        dc.DrawCircle(width/2, height/2, 100)

        dc.SetRGB(0.2, 0.0, 0.8)
        dc.Fill()

        dc.SavePNG("15.png")
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Kreslení otevřených tvarů (úseček) pomocí příkazu <strong>Stroke</strong></h2>

<pre>
package main

import "github.com/fogleman/gg"

func main() {
        const width = 320
        const height = 240

        dc := gg.NewContext(width, height)

        dc.SetRGB(0.2, 0.0, 0.8)
        dc.DrawLine(10, 10, width-10, height-10)
        dc.Stroke()

        dc.SetRGB(0.8, 0.0, 0.2)
        dc.DrawLine(10, height-10, width-10, 10)
        dc.Stroke()

        dc.SavePNG("16.png")
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Vyplnění uzavřené křivky příkazem <strong>Fill</strong></h2>

<pre>
package main

import "github.com/fogleman/gg"

func main() {
        const width = 320
        const height = 240

        dc := gg.NewContext(width, height)

        dc.DrawRectangle(0, 0, width, height)
        dc.SetRGB(1.0, 1.0, 1.0)
        dc.Fill()

        dc.DrawLine(10, 10, width-10, height-10)
        dc.SetRGB(0.2, 0.0, 0.8)
        dc.Stroke()

        dc.DrawLine(10, height-10, width-10, 10)
        dc.SetRGB(0.8, 0.0, 0.2)
        dc.Stroke()

        dc.SavePNG("17.png")
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Nastavení základních parametrů cest: průhlednost, šířka tahu a styl vykreslení</h2>

<pre>
package main

import "github.com/fogleman/gg"

func main() {
        const width = 320
        const height = 240

        dc := gg.NewContext(width, height)

        dc.DrawRectangle(0, 0, width, height)
        dc.SetRGB(1.0, 1.0, 1.0)
        dc.Fill()

        for i := 0; i &lt; 256; i += 8 {
                alpha := float64(i) / 256.0
                dc.SetRGBA(0.0, 0.0, 0.0, alpha)

                x := float64(i + 32)
                dc.DrawLine(x, 20, x, height-20)

                dc.Stroke()
        }

        dc.SavePNG("18.png")
}
</pre>

<pre>
</pre>

<pre>
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně jeden megabajt), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_blending.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/01_blending.go">https://github.com/tisnik/go-fedora/blob/master/article_15/01_blending.go</a></td></tr>
<tr><td> 2</td><td>02_gif_export_rgba.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/02_gif_export_rgba.go">https://github.com/tisnik/go-fedora/blob/master/article_15/02_gif_export_rgba.go</a></td></tr>
<tr><td> 3</td><td>03_gif_1x1_rgba.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/03_gif_1x1_rgba.go">https://github.com/tisnik/go-fedora/blob/master/article_15/03_gif_1x1_rgba.go</a></td></tr>
<tr><td> 4</td><td>04_gif_1x1_palette.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/04_gif_1x1_palette.go">https://github.com/tisnik/go-fedora/blob/master/article_15/04_gif_1x1_palette.go</a></td></tr>
<tr><td> 5</td><td>05_gif_export_colors.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/05_gif_export_colors.go">https://github.com/tisnik/go-fedora/blob/master/article_15/05_gif_export_colors.go</a></td></tr>
<tr><td> 6</td><td>06_gif_export_palette.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/06_gif_export_palette.go">https://github.com/tisnik/go-fedora/blob/master/article_15/06_gif_export_palette.go</a></td></tr>
<tr><td> 7</td><td>07_rgba_to_palette.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/07_rgba_to_palette.go">https://github.com/tisnik/go-fedora/blob/master/article_15/07_rgba_to_palette.go</a></td></tr>
<tr><td> 8</td><td>08_gif_animation_blink.go</td><td>jednoduchá animace se dvěma snímky o velikosti 32&times;32 pixelů</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/08_gif_animation_blink.go">https://github.com/tisnik/go-fedora/blob/master/article_15/08_gif_animation_blink.go</a></td></tr>
<tr><td> 9</td><td>09_gif_animation.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/09_gif_animation.go">https://github.com/tisnik/go-fedora/blob/master/article_15/09_gif_animation.go</a></td></tr>
<tr><td>10</td><td>10_default_disposal_methods.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/10_default_disposal_methods.go">https://github.com/tisnik/go-fedora/blob/master/article_15/10_default_disposal_methods.go</a></td></tr>
<tr><td>11</td><td>11_background_disposal_methods.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/11_background_disposal_methods.go">https://github.com/tisnik/go-fedora/blob/master/article_15/11_background_disposal_methods.go</a></td></tr>
<tr><td>12</td><td>12_none_disposal_methods.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/12_none_disposal_methods.go">https://github.com/tisnik/go-fedora/blob/master/article_15/12_none_disposal_methods.go</a></td></tr>
<tr><td>13</td><td>13_progress_bar.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/13_progress_bar.go">https://github.com/tisnik/go-fedora/blob/master/article_15/13_progress_bar.go</a></td></tr>
<tr><td>14</td><td>14_gg_basic.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/14_gg_basic.go">https://github.com/tisnik/go-fedora/blob/master/article_15/14_gg_basic.go</a></td></tr>
<tr><td>15</td><td>15_gg_context_properties.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/15_gg_context_properties.go">https://github.com/tisnik/go-fedora/blob/master/article_15/15_gg_context_properties.go</a></td></tr>
<tr><td>16</td><td>16_gg_path_stroke.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/16_gg_path_stroke.go">https://github.com/tisnik/go-fedora/blob/master/article_15/16_gg_path_stroke.go</a></td></tr>
<tr><td>17</td><td>17_gg_filled_background.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/17_gg_filled_background.go">https://github.com/tisnik/go-fedora/blob/master/article_15/17_gg_filled_background.go</a></td></tr>
<tr><td>18</td><td>18_gg_alpha_rgba.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/18_gg_alpha_rgba.go">https://github.com/tisnik/go-fedora/blob/master/article_15/18_gg_alpha_rgba.go</a></td></tr>
<tr><td>19</td><td>19_gg_line_width.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/19_gg_line_width.go">https://github.com/tisnik/go-fedora/blob/master/article_15/19_gg_line_width.go</a></td></tr>
<tr><td>20</td><td>20_gg_set_dash.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/20_gg_set_dash.go">https://github.com/tisnik/go-fedora/blob/master/article_15/20_gg_set_dash.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Go image package<br />
<a href="https://blog.golang.org/go-image-package">https://blog.golang.org/go-image-package</a>
</li>

<li>Balíček draw2D: 2D rendering for different output (raster, pdf, svg)<br />
<a href="https://github.com/llgcode/draw2d">https://github.com/llgcode/draw2d</a>
</li>

<li>Draw a rectangle in Golang?<br />
<a href="https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang">https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang</a>
</li>

<li>YAML<br />
<a href="https://yaml.org/">https://yaml.org/</a>
</li>

<li>edn<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Smile<br />
<a href="https://github.com/FasterXML/smile-format-specification">https://github.com/FasterXML/smile-format-specification</a>
</li>

<li>Protocol-Buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>Marshalling (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
</li>

<li>Unmarshalling<br />
<a href="https://en.wikipedia.org/wiki/Unmarshalling">https://en.wikipedia.org/wiki/Unmarshalling</a>
</li>

<li>Introducing JSON<br />
<a href="http://json.org/">http://json.org/</a>
</li>

<li>Package json<br />
<a href="https://golang.org/pkg/encoding/json/">https://golang.org/pkg/encoding/json/</a>
</li>

<li>The Go Blog: JSON and Go<br />
<a href="https://blog.golang.org/json-and-go">https://blog.golang.org/json-and-go</a>
</li>

<li>Go by Example: JSON<br />
<a href="https://gobyexample.com/json">https://gobyexample.com/json</a>
</li>

<li>Writing Web Applications<br />
<a href="https://golang.org/doc/articles/wiki/">https://golang.org/doc/articles/wiki/</a>
</li>

<li>Golang Web Apps<br />
<a href="https://www.reinbach.com/blog/golang-webapps-1/">https://www.reinbach.com/blog/golang-webapps-1/</a>
</li>

<li>Build web application with Golang<br />
<a href="https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details">https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details</a>
</li>

<li>Golang Templates - Golang Web Pages<br />
<a href="https://www.youtube.com/watch?v=TkNIETmF-RU">https://www.youtube.com/watch?v=TkNIETmF-RU</a>
</li>

<li>Simple Golang HTTPS/TLS Examples<br />
<a href="https://github.com/denji/golang-tls">https://github.com/denji/golang-tls</a>
</li>

<li>Playing with images in HTTP response in golang<br />
<a href="https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang">https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang</a>
</li>

<li>MIME Types List<br />
<a href="https://www.freeformatter.com/mime-types-list.html">https://www.freeformatter.com/mime-types-list.html</a>
</li>

<li>Go Mutex Tutorial<br />
<a href="https://tutorialedge.net/golang/go-mutex-tutorial/">https://tutorialedge.net/golang/go-mutex-tutorial/</a>
</li>

<li>Creating A Simple Web Server With Golang<br />
<a href="https://tutorialedge.net/golang/creating-simple-web-server-with-golang/">https://tutorialedge.net/golang/creating-simple-web-server-with-golang/</a>
</li>

<li>Building a Web Server in Go<br />
<a href="https://thenewstack.io/building-a-web-server-in-go/">https://thenewstack.io/building-a-web-server-in-go/</a>
</li>

<li>How big is the pipe buffer?<br />
<a href="https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer">https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer</a>
</li>

<li>How to turn off buffering of stdout in C<br />
<a href="https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c">https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c</a>
</li>

<li>setbuf(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/setbuf">https://linux.die.net/man/3/setbuf</a>
</li>

<li>setvbuf(3) - Linux man page (stejný obsah jako předchozí stránka)<br />
<a href="https://linux.die.net/man/3/setvbuf">https://linux.die.net/man/3/setvbuf</a>
</li>

<li>Select waits on a group of channels<br />
<a href="https://yourbasic.org/golang/select-explained/">https://yourbasic.org/golang/select-explained/</a>
</li>

<li>Rob Pike: Simplicity is Complicated (video)<br />
<a href="http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893">http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893</a>
</li>

<li>Algorithms to Go<br />
<a href="https://yourbasic.org/">https://yourbasic.org/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů: vlastní filtry a lexery<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/</a>
</li>

<li>Go Defer Simplified with Practical Visuals<br />
<a href="https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff">https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff</a>
</li>

<li>5 More Gotchas of Defer in Go — Part II<br />
<a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa">https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa</a>
</li>

<li>The Go Blog: Defer, Panic, and Recover<br />
<a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a>
</li>

<li>The defer keyword in Swift 2: try/finally done right<br />
<a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer">https://www.hackingwithswift.com/new-syntax-swift-2-defer</a>
</li>

<li>Swift Defer Statement<br />
<a href="https://andybargh.com/swift-defer-statement/">https://andybargh.com/swift-defer-statement/</a>
</li>

<li>Modulo operation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Modulo_operation">https://en.wikipedia.org/wiki/Modulo_operation</a>
</li>

<li>Node.js vs Golang: Battle of the Next-Gen Languages<br />
<a href="https://www.hostingadvice.com/blog/nodejs-vs-golang/">https://www.hostingadvice.com/blog/nodejs-vs-golang/</a>
</li>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go<br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>JavaScript vs. Golang for IoT: Is Gopher Winning?<br />
<a href="https://www.iotforall.com/javascript-vs-golang-iot/">https://www.iotforall.com/javascript-vs-golang-iot/</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

<li>Printf Format Strings<br />
<a href="https://www.cprogramming.com/tutorial/printf-format-strings.html">https://www.cprogramming.com/tutorial/printf-format-strings.html</a>
</li>

<li>Java: String.format<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-</a>
</li>

<li>Java: format string syntax<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a>
</li>

<li>Selectors<br />
<a href="https://golang.org/ref/spec#Selectors">https://golang.org/ref/spec#Selectors</a>
</li>

<li>Calling Go code from Python code<br />
<a href="http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/">http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/</a>
</li>

<li>Go Data Structures: Interfaces <br />
<a href="https://research.swtch.com/interfaces">https://research.swtch.com/interfaces</a>
</li>

<li>How to use interfaces in Go<br />
<a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go</a>
</li>

<li>Interfaces in Go (part I)<br />
<a href="https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c">https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c</a>
</li>

<li>Part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>What about Trait support in Golang?<br />
<a href="https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/">https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/</a>
</li>

<li>Don't Get Bitten by Pointer vs Non-Pointer Method Receivers in Golang<br />
<a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/">https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/</a>
</li>

<li>Control Flow<br />
<a href="https://en.wikipedia.org/wiki/Control_flow">https://en.wikipedia.org/wiki/Control_flow</a>
</li>

<li>Structured programming<br />
<a href="https://en.wikipedia.org/wiki/Structured_programming">https://en.wikipedia.org/wiki/Structured_programming</a>
</li>

<li>Control Structures<br />
<a href="https://www.golang-book.com/books/intro/5">https://www.golang-book.com/books/intro/5</a>
</li>

<li>Control structures - Go if else statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html">http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html</a>
</li>

<li>Control structures - Go switch case statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html</a>
</li>

<li>Control structures - Go for loop, break, continue, range<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html</a>
</li>

<li>Single Function Exit Point<br />
<a href="http://wiki.c2.com/?SingleFunctionExitPoint">http://wiki.c2.com/?SingleFunctionExitPoint</a>
</li>

<li>Entry point<br />
<a href="https://en.wikipedia.org/wiki/Entry_point">https://en.wikipedia.org/wiki/Entry_point</a>
</li>

<li>Why does Go have a GOTO statement?!<br />
<a href="https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/">https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/</a>
</li>

<li>Effective Go<br />
<a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a>
</li>

<li>GoClipse: an Eclipse IDE for the Go programming language<br />
<a href="http://goclipse.github.io/">http://goclipse.github.io/</a>
</li>

<li>GoClipse Installation<br />
<a href="https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation">https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

