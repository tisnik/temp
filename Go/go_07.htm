<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Go: dokončení popisu vlastností samotného jazyka</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Go: dokončení popisu vlastností samotného jazyka</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V sedmé části seriálu o programovacím jazyce Go dokončíme popis vlastního jazyka. Nejprve se budeme zabývat zbylými operátory, ukážeme si způsob využití konstrukce select-case pro komunikaci mezi gorutinami a popíšeme si deklaraci konstant i význam identifikátoru iota.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Dokončení popisu operátorů</a></p>
<p><a href="#k02">2. Bitové operátory</a></p>
<p><a href="#k03">3. Logické (Booleovské) operátory</a></p>
<p><a href="#k04">4. Logické operátory a typové kontroly jazyka Go</a></p>
<p><a href="#k05">5. Operace pro zvýšení a snížení hodnoty o jedničku</a></p>
<p><a href="#k06">6. Nepodporovaná použití operátorů ++ a --</a></p>
<p><a href="#k07">7. Klíčové slovo <strong>select</strong>: posílání zpráv přes kanály</a></p>
<p><a href="#k08">8. Použití konstrukce <strong>select-case</strong> pro čekání na data z&nbsp;gorutin</a></p>
<p><a href="#k09">9. Význam větve <strong>default</strong> v&nbsp;konstrukci <strong>select-case</strong></a></p>
<p><a href="#k10">10. Použití konstrukce <strong>select-case</strong> při posílání dat</a></p>
<p><a href="#k11">11. Blokující zápis do kanálu</a></p>
<p><a href="#k12">12. Kombinace čtení a zápisu v&nbsp;konstrukci <strong>select-case</strong></a></p>
<p><a href="#k13">13. Deklarace konstant v&nbsp;programovacím jazyku Go</a></p>
<p><a href="#k14">14. Demonstrační příklad: konstanty různých typů, blok s&nbsp;konstantami</a></p>
<p><a href="#k15">15. Automatické generování celočíselné řady pomocí klíčového slova <strong>iota</strong></a></p>
<p><a href="#k16">16. Praktické použití klíčového slova <strong>iota</strong></a></p>
<p><a href="#k17">17. Funkce s&nbsp;variabilním počtem parametrů v&nbsp;programovacím jazyku Go</a></p>
<p><a href="#k18">18. Základní informace o adresářové struktuře při práci se složitějšími projekty</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Dokončení popisu operátorů</h2>

<p>V&nbsp;úvodní části dnešního článku navážeme na <a
href="https://www.root.cz/clanky/konstrukce-pro-rizeni-behu-programu-v-jazyce-go-dokonceni/#k15">článek
předchozí</a>, v&nbsp;němž jsme se kromě dalších věcí zabývali i operátory,
které je možné v&nbsp;programovacím jazyku Go použít. Již jsme si popsali
standardní aritmetické operátory, relační operátory (a jejich omezení) a taktéž
bitové posuny. Musíme si ovšem popsat i bitové operátory a mj.&nbsp;i operace
určené pro zvýšení či snížení číselné hodnoty o jedničku (což ovšem nejsou
plnohodnotné operátory, jak ostatně uvidíme v&nbsp;dalším textu).</p>

<p>Jen pro připomenutí si znovu ukažme tabulku všech operátorů, které je možné
použít v&nbsp;programovacím jazyce Go:</p>

<table>
<tr><td>aritmetické</td><td>+</td><td>-</td><td>*</td><td>/</td><td>%</td><td>&nbsp;</td></tr>
<tr><td>aritmetické s&nbsp;přiřazením</td><td>+=</td><td>-=</td><td>*=</td><td>/=</td><td>%=</td><td>&nbsp;</td></tr>
<tr><td>logické</td><td>&amp;&amp;</td><td>||</td><td>!</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>posuny a bitové operace</td><td>&lt;&lt;</td><td>&gt;&gt;</td><td>&amp;</td><td>|</td><td>^</td><td>&amp;^</td></tr>
<tr><td>posuny a bitové operace s přiřazením</td><td>&lt;&lt;=</td><td>&gt;&gt;=</td><td>&amp;=</td><td>|=</td><td>^=</td><td>&amp;^=</td></tr>
<tr><td>relační</td><td>==</td><td>!=</td><td>&lt;</td><td>&lt;=</td><td>&gt;</td><td>&gt;=</td></tr>
<tr><td>operace s adresami</td><td>*</td><td>&amp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>unární operátory</td><td>+</td><td>-</td><td>^</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>další operátory</td><td>&lt;-</td><td>:=</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Bitové operátory</h2>

<p>V&nbsp;této kapitole se budeme zabývat bitovými operacemi, které jsou
v&nbsp;programovacím jazyce Go realizovány s&nbsp;využitím pětice operátorů.
Tyto operátory jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>Operátor</th><th>Kombinace s&nbsp;přiřazením</th><th>Význam</th></tr>
<tr><td>^</td><td>&nbsp;</td><td>negace bit po bitu (podobně jako operátor ~ v&nbsp;C)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&amp;</td><td>&amp;=</td><td>logický součin prováděný bit po bitu</td></tr>
<tr><td>|</td><td>|=</td><td>logický součet prováděný bit po bitu</td></tr>
<tr><td>^</td><td>^=</td><td>logická nonekvivalence prováděná bit po bitu</td></tr>
<tr><td>&amp;^</td><td>&amp;^=</td><td>maskování bitů vybraných zadanou maskou (operace AND NOT)</td></tr>
</table>

<p>První operátor je unární, tj.&nbsp;aplikuje se pouze na jediný operand,
který je zapsán za operátor, podobně jako u dalších unárních operátorů (operace
++ a -- jsou výjimkou, ale v&nbsp;tomto případě se nejedná o plnohodnotné
operátory). Tento operátor slouží pro negaci všech bitů v&nbsp;celočíselné
hodnotě. Operátor lze aplikovat jak na hodnoty bez znaménka (<i>unsigned</i>),
tak i na hodnoty se znaménkem (<i>signed</i>), takže můžeme například
napsat:</p>

<pre>
var b uint8 = 0
&nbsp;
var x uint = 1
var y uint = 2
var z int = 1
var w int = 2
&nbsp;
fmt.Printf("%x\n", ^b)
fmt.Printf("%x\n", ^x)
fmt.Printf("%x\n", ^y)
fmt.Printf("%x\n", ^z)
fmt.Printf("%x\n", ^w)
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
ff
fffffffffffffffe
fffffffffffffffd
-2
-3
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;programovacích jazycích
odvozených od céčka se tento operátor většinou nezapisuje znakem ^, ale
s&nbsp;využitím znaku ~.</div></p>

<p>Další trojice operátorů zapisovaných znaky &amp;, | a ^ patří mezi binární
operátory, které jsou aplikovány na dvojici operandů. Opět se může jednat jak o
hodnoty se znaménkem, tak i o hodnoty bez znaménka. Význam těchto operátorů
odpovídá podobně zapisovaným operátorům v&nbsp;C, C++ či Javě (viz též
demonstrační příklad uvedený v&nbsp;závěru kapitoly). Zajímavější a ve vyšších
programovacích jazycích pravděpodobně i unikátní je však poslední
z&nbsp;bitových operátorů, který se zapisuje dvojicí znaků &amp;^. Tento
operátor provádí logický součin bit po bitu, ovšem všechny bity druhého
operandu jsou nejdříve znegovány. Operátor &amp;^ se tedy používá pro
maskování, kdy například budeme potřebovat vynulovat bit 1 pomocí operace
<strong>x &amp;^ 1</strong> atd.:</p>

<pre>
var b uint8 = 0xff
&nbsp;
fmt.Printf("%x\n", b)
fmt.Printf("%x\n", b &amp;^ 1)
fmt.Printf("%x\n", b &amp;^ 2)
fmt.Printf("%x\n", b &amp;^ 0x0f)
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
ff
fe
fd
f0
</pre>

<p>Všechny binární bitové operátory jsou představeny v&nbsp;dnešním <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/01_bit_operators.go">prvním
demonstračním příkladu</a>, v&nbsp;němž jsou aplikovány na dvě celočíselné
proměnné:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        x := 1
        y := 0xfe
&nbsp;
        fmt.Printf("%x &amp; %x == %x\n", x, y, <strong>x&amp;y</strong>)
        fmt.Printf("%x &amp;^ %x == %x\n", x, y, <strong>x&amp;^y</strong>)
        fmt.Printf("%x | %x == %x\n", x, y, <strong>x|y</strong>)
        fmt.Printf("%x ^ %x == %x\n", x, y, <strong>x^y</strong>)
&nbsp;
        <strong>x ^= y</strong>
        fmt.Printf("new x = %x\n", x)
&nbsp;
        <strong>x |= y</strong>
        fmt.Printf("new x = %x\n", x)
&nbsp;
        <strong>x ^= y</strong>
        fmt.Printf("new x = %x\n", x)
&nbsp;
        <strong>x &amp;^= 0x01</strong>
        fmt.Printf("new x = %x\n", x)
&nbsp;
        fmt.Println()
&nbsp;
        x = 1
        y = 2
&nbsp;
        fmt.Printf("%x &amp; %x == %x\n", x, y, <strong>x&amp;y</strong>)
        fmt.Printf("%x &amp;^ %x == %x\n", x, y, <strong>x&amp;^y</strong>)
        fmt.Printf("%x | %x == %x\n", x, y, <strong>x|y</strong>)
        fmt.Printf("%x ^ %x == %x\n", x, y, <strong>x^y</strong>)
&nbsp;
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že pokud se bitové
operátory použijí ve své základní formě (bez přiřazení), zapisují se
&bdquo;nalepené&ldquo; na operandy &ndash; nepoužívají se zde oddělovací mezery
(viz příkaz <strong>go fmt</strong>).</div></p>

<p>Po spuštění tohoto příkladu získáme tyto výsledky:</p>

<pre>
1 &amp; fe == 0
1 &amp;^ fe == 1
1 | fe == ff
1 ^ fe == ff
new x = ff
new x = ff
new x = 1
new x = 0
&nbsp;
1 &amp; 2 == 0
1 &amp;^ 2 == 1
1 | 2 == 3
1 ^ 2 == 3
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Logické (Booleovské) operátory</h2>

<p>Pro úplnost si ještě zopakujme, že v&nbsp;programovacím jazyku Go nalezneme
tři operátory, které jsou aplikovatelné na logické (pravdivostní) hodnoty
<strong>true</strong> a <strong>false</strong>. Jedná se o logickou negaci,
logický součin a logický součet. Tyto tři operátory se zapisují následujícím
způsobem (u binárních operátorů existuje i možnost jejich kombinace
s&nbsp;přiřazením):</p>

<table>
<tr><th>Operátor</th><th>Kombinace s&nbsp;přiřazením</th><th>Význam</th></tr>
<tr><td>!</td><td>&nbsp;</td><td>negace pravdivostní hodnoty</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&amp;&amp;</td><td>&amp;&amp;=</td><td>logický součin dvou pravdivostních hodnot</td></tr>
<tr><td>||</td><td>||=</td><td>logický součet dvou pravdivostních hodnot</td></tr>
</table>

<p>Opět se podívejme na <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/02_boolean_operators.go">jednoduchý
demonstrační příklad</a>, v&nbsp;němž jsou všechny tři výše zmíněné operátory
použity:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        x := true
        y := false
&nbsp;
        fmt.Printf("!%v == %v\n", x, <strong>!x</strong>)
        fmt.Printf("!%v == %v\n", y, <strong>!y</strong>)
&nbsp;
        fmt.Printf("%v &amp;&amp; %v == %v\n", x, y, <strong>x &amp;&amp; y</strong>)
        fmt.Printf("%v || %v == %v\n", x, y, <strong>x || y</strong>)
&nbsp;
        fmt.Printf("%v &amp;&amp; %v || %v &amp;&amp; %v == %v\n", x, y, true, false, <strong>x &amp;&amp; y || x &amp;&amp; false</strong>)
        fmt.Printf("%v &amp;&amp; %v || %v &amp;&amp; %v == %v\n", x, y, true, false, <strong>x &amp;&amp; y || x &amp;&amp; true</strong>)
}
</pre>

<p>Po překladu a spuštění tohoto příkladu získáme tyto výsledky:</p>

<pre>
!true == false
!false == true
true &amp;&amp; false == false
true || false == true
true &amp;&amp; false || true &amp;&amp; false == false
true &amp;&amp; false || true &amp;&amp; false == true
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že funkce
<strong>fmt.Printf</strong> podporuje přímý tisk pravdivostních hodnot, takže
je nemusíme převádět na celočíselné hodnoty.</div></p>

<p>V&nbsp;Go nelze použít varianty &amp; a | s&nbsp;nezkráceným vyhodnocením
výrazu. Operátory &amp;&amp; a || vždy používají zkrácené vyhodnocování
(<i>short circuit</i>), což konkrétně znamená, že pokud je po vyhodnocení
prvního operandu zřejmé, jaký bude výsledek operace, druhý operand se
nevyhodnocuje. To má význam v&nbsp;případě, že se při vyhodnocování volají
funkce popř.&nbsp;pokud se například dělí nulou atd.:</div></p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func f1() bool {
        println("f1")
        return true
}
&nbsp;
func f2() bool {
        println("f2")
        return false
}
&nbsp;
func f3() bool {
        println("f2")
        return false
}
&nbsp;
func main() {
        fmt.Printf("short circuit &amp;&amp;: %v\n", <strong>f1() &amp;&amp; f2()</strong>)
        fmt.Printf("short circuit ||: %v\n", <strong>f1() || f2()</strong>)
        fmt.Printf("short circuit &amp;&amp;: %v\n", <strong>f2() &amp;&amp; f3()</strong>)
        fmt.Printf("short circuit ||: %v\n", <strong>f2() || f3()</strong>)
}
</pre>

<p>Při pohledu na výsledky <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/02A_boolean_operators_short_circuit.go">předchozího
demonstračního příkladu</a> se skutečně můžeme přesvědčit, že se druhá funkce
ve výrazu v&nbsp;některých případech vůbec nevolá:</p>

<pre>
f1
f2
short circuit &amp;&amp;: false
f1
short circuit ||: true
f2
short circuit &amp;&amp;: false
f2
f2
short circuit ||: false
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Logické operátory a typové kontroly jazyka Go</h2>

<p>Žádné další operace nejsou s&nbsp;pravdivostními (logickými) hodnotami
dovoleny! To například znamená, že <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/02B_boolean_operators_improper_usage.go">následující
demonstrační příklad</a> nebude možné přeložit a pochopitelně ani spustit:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        x := true
        y := false
&nbsp;
        fmt.Printf("^%v == %v\n", x, <strong>^x</strong>)
        fmt.Printf("^%v == %v\n", y, <strong>^y</strong>)
&nbsp;
        fmt.Printf("%v &amp; %v == %v\n", x, y, <strong>x &amp; y</strong>)
        fmt.Printf("%v | %v == %v\n", x, y, <strong>x | y</strong>)
        fmt.Printf("%v + %v == %v\n", x, y, <strong>x + y</strong>)
        fmt.Printf("%v - %v == %v\n", x, y, <strong>x - y</strong>)
}
</pre>

<p>Při pokusu o překlad vypíše překladač tato chybová hlášení:</p>

<pre>
./02B_boolean_operators_improper_usage.go:16:31: invalid operation: ^ bool
./02B_boolean_operators_improper_usage.go:17:31: invalid operation: ^ bool
./02B_boolean_operators_improper_usage.go:19:40: invalid operation: x &amp; y (operator &amp; not defined on bool)
./02B_boolean_operators_improper_usage.go:20:40: invalid operation: x | y (operator | not defined on bool)
./02B_boolean_operators_improper_usage.go:21:40: invalid operation: x + y (operator + not defined on bool)
./02B_boolean_operators_improper_usage.go:22:40: invalid operation: x - y (operator - not defined on bool)
</pre>

<p>Samozřejmě to platí i naopak &ndash; logické operátory nejsou aplikovatelné
na celá čísla, čísla s&nbsp;plovoucí řádovou čárkou apod. Ani <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/02C_boolean_operators_improper_usage.go">tento
program</a> tedy není v&nbsp;žádném případě korektní:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        x := 1
        y := 2
&nbsp;
        fmt.Printf("!%v == %v\n", x, <strong>!x</strong>)
        fmt.Printf("!%v == %v\n", y, <strong>!y</strong>)
&nbsp;
        fmt.Printf("%v &amp;&amp; %v == %v\n", x, y, <strong>x &amp;&amp; y</strong>)
        fmt.Printf("%v || %v == %v\n", x, y, <strong>x || y</strong>)
&amp;nbsp;
        fmt.Printf("%v &amp;&amp; %v || %v &amp;&amp; %v == %v\n", x, y, true, false, <strong>x &amp;&amp; y || x &amp;&amp; false</strong>)
        fmt.Printf("%v &amp;&amp; %v || %v &amp;&amp; %v == %v\n", x, y, true, false, <strong>x &amp;&amp; y || x &amp;&amp; true</strong>)
}
</pre>

<p>Takto krátký program obsahuje až překvapivě mnoho chyb:</p>

<pre>
./02C_boolean_operators_improper_usage.go:16:31: invalid operation: ! int
./02C_boolean_operators_improper_usage.go:17:31: invalid operation: ! int
./02C_boolean_operators_improper_usage.go:19:41: invalid operation: x &amp;&amp; y (operator &amp;&amp; not defined on int)
./02C_boolean_operators_improper_usage.go:20:41: invalid operation: x || y (operator || not defined on int)
./02C_boolean_operators_improper_usage.go:22:66: invalid operation: x &amp;&amp; y (operator &amp;&amp; not defined on int)
./02C_boolean_operators_improper_usage.go:22:76: cannot convert false (type untyped bool) to type int
./02C_boolean_operators_improper_usage.go:22:76: invalid operation: x &amp;&amp; false (mismatched types int and bool)
./02C_boolean_operators_improper_usage.go:23:66: invalid operation: x &amp;&amp; y (operator &amp;&amp; not defined on int)
./02C_boolean_operators_improper_usage.go:23:76: cannot convert true (type untyped bool) to type int
./02C_boolean_operators_improper_usage.go:23:76: invalid operation: x &amp;&amp; true (mismatched types int and bool)
</pre>

<p><div class="rs-tip-major">Poznámka: již minule jsme si řekli, že pro logické
hodnoty <strong>true</strong> a <strong>false</strong> není definováno
uspořádání (jinými slovy, není možné rozhodnout, která z&nbsp;těchto hodnot je
větší nebo menší). To znamená, že ze šesti dostupných relačních operací je
možné pro logické hodnoty použít pouze porovnání na rovnost == a nerovnost
!=.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Operace pro zvýšení a snížení hodnoty o jedničku</h2>

<p>Programovací jazyk Go umožňuje jednoduché zvýšení či snížení nějaké číselné
hodnoty (celého čísla, čísla s&nbsp;plovoucí řádovou čárkou, dokonce i čísla
komplexního). Tyto operace jsou zapisovány znaky ++ a --, které musíme vždy
zapsat ZA operand. Na rozdíl od prakticky všech céčkovských programovacích
jazyků ovšem není povoleno použít tyto znaky před operandem. Navíc &ndash; což
je ještě více omezující podmínka &ndash; musí být tyto operace zapsány jako
<i>příkaz</i> (<i>statement</i>), nikoli jako součást složitějšího
<i>výrazu</i> (<i>expression</i>). Z&nbsp;těchto důvodů se operace ++ a --
většinou ani neuvádí v&nbsp;seznamu operátorů, protože tvoří samostatnou
syntaktickou kategorii. Nejjednodušší příklad použití operací ++ a -- může
vypadat následovně:</p>

<pre>
x := 1
<strong>x++</strong>
</pre>

<p>popř.&nbsp;pochopitelně můžeme celočíselnou hodnotu o jedničku snížit:</p>

<pre>
x := 1
<strong>x--</strong>
</pre>

<p>Zajímavé a užitečné je chování operací ++ a -- ve chvíli, kdy máme
k&nbsp;dispozici ukazatel na proměnnou (resp.&nbsp;obecněji ukazatel na
hodnotu). V&nbsp;takovém případě můžeme napsat:</p>

<pre>
x := 1
px := &amp;x
<strong>*px++</strong>
</pre>

<p>Na posledním řádku se zvýší hodnota proměnné <strong>x</strong>, protože
jazyk Go má odlišnou tabulku priorit operátorů. V&nbsp;programovacím jazyku C
má ovšem stejně zapsaný příkaz odlišný význam, protože zvýší hodnotu ukazatele
a potom přečte hodnotu z&nbsp;paměťové oblasti ZA proměnnou x (což je operace,
která je samozřejmě chybná a může vést k&nbsp;pádu programu).</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int main(void) {
    int x = 1;
    int *px = &x;
    <strong>*px++;</strong>
    printf("%d\n", x);
    return 0;
}
</pre>

<p>Můžeme si vyzkoušet, že <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/inc1.c">předchozí
céčkovský příklad</a> se skutečně chová odlišně:</p>

<pre>
$ <strong>gcc px.c</strong>
$ <strong>./a.out</strong>
1
</pre>

<p>Stejné chování, jakého jsme dosáhli v&nbsp;Go, <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/inc2.c">musíme
naprogramovat</a> s&nbsp;využitím závorek pro změnu priorit operátorů:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int main(void) {
    int x = 1;
    int *px = &x;
    <strong>(*px)++;</strong>
    printf("%d\n", x);
    return 0;
}
</pre>

<p>Otestování chování upraveného céčkovského programu:</p>

<pre>
$ <strong>gcc px.c</strong>
$ <strong>./a.out</strong>
2
</pre>

<p>Vraťme se nyní zpět k&nbsp;popisu programovacího jazyka Go. Operace ++ a --
je možné použít i pro hodnoty typu <i>complex64</i> a <i>complex128</i>.
V&nbsp;tomto případě se operace týkají reálné složky komplexních čísel,
imaginární složka zůstane nezměněna:</p>

<pre>
z := 1 + 2i
z++
</pre>

<p>V&nbsp;dalším demonstračním příkladu, jehož úplný zdrojový kód naleznete na
adrese <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/03_inc_dec.go">https://github.com/tisnik/go-fedora/blob/master/article_07/03_inc_dec.go</a>,
jsou ukázány některé možnosti korektního použití operací ++ a --:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        x := 1
        fmt.Printf("x = %d\n", x)
&nbsp;
        <strong>x++</strong>
        fmt.Printf("x = %d\n", x)
&nbsp;
        <strong>x--</strong>
        fmt.Printf("x = %d\n", x)
&nbsp;
        px := &amp;x
        fmt.Printf("x = %d\n", *px)
&nbsp;
        <strong>*px++</strong>
        fmt.Printf("x = %d\n", *px)
&nbsp;
        <strong>*px--</strong>
        fmt.Printf("x = %d\n", *px)
&nbsp;
        y := 3.14
        fmt.Printf("y = %f\n", y)
        <strong>y++</strong>
        fmt.Printf("y = %f\n", y)
&nbsp;
        z := 1 + 2i
        fmt.Printf("z = %f\n", z)
        <strong>z++</strong>
        fmt.Printf("z = %f\n", z)
}
</pre>

<p>Po překladu a spuštění tohoto příkladu by se na standardním výstupu měly
objevit tyto řádky:</p>

<pre>
x = 1
x = 2
x = 1
x = 1
x = 2
x = 1
y = 3.140000
y = 4.140000
z = (1.000000+2.000000i)
z = (2.000000+2.000000i)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Nepodporovaná použití operátorů ++ a --</h2>

<p><a href="#k05">V&nbsp;předchozí kapitole</a> jsme si řekli, že možnosti
použití operací ++ a -- jsou v&nbsp;programovacím jazyku Go omezenější, než je
tomu v&nbsp;klasických jazycích odvozených od céčka. V&nbsp;první řadě není
dovoleno zapsat tyto operace před operandy. Na toto nekorektní použití nás
upozorní překladač:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        x := 1
        fmt.Printf("x = %d\n", x)
&nbsp;
        <strong>++x</strong>
        fmt.Printf("x = %d\n", x)
&nbsp;
        <strong>--x</strong>
        fmt.Printf("x = %d\n", x)
}
</pre>

<p>Při pokusu o překlad <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/04_inc_dec_bad_usage.go">tohoto
demonstračního příkladu</a> se vypíše chyba u první operace ++x</p>

<pre>
./04_inc_dec_bad_usage.go:16:2: syntax error: unexpected ++, expecting }
</pre>

<p>Dále je nutné ++ a -- použít jen v&nbsp;samostatném příkazu, nikoli ve
výrazu. Ani <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/05_inc_dec_bad_usage.go">následující
příklad</a> tedy není pro překladač programovacího jazyka Go korektní:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        x := 1
        fmt.Printf("x = %d\n", x)
&nbsp;
        fmt.Printf("x = %d\n", <strong>x++</strong>)
&nbsp;
        fmt.Printf("x = %d\n", <strong>x--</strong>)
}
</pre>

<p>Překladač nyní vypíše chyby u obou operací ++ i --:</p>

<pre>
./05_inc_dec_bad_usage.go:16:26: syntax error: unexpected ++, expecting comma or )
./05_inc_dec_bad_usage.go:18:26: syntax error: unexpected --, expecting comma or )
</pre>

<p>Naproti tomu v&nbsp;počítané variantě programové smyčky <strong>for</strong>
operace ++ a -- použít můžeme, protože se na příslušném místě očekává iterační
příkaz:</p>

<pre>
package main
&nbsp;
func main() {
        var i int
        for i = 0; i &lt; 10; i++ {
                println(i)
        }
        println()
        println(i)
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Klíčové slovo <strong>select</strong>: posílání zpráv přes kanály</h2>

<p>Jedno z&nbsp;posledních klíčových slov programovacího jazyka Go, s&nbsp;nímž
jsme se doposud nesetkali, je slovo <strong>select</strong>. Toto klíčové slovo
se používá společně s&nbsp;větvemi <strong>case</strong> a popř.&nbsp;i
s&nbsp;větví <strong>default</strong> pro vytvoření programové konstrukce
určené pro příjem dat popř.&nbsp;i pro vysílání dat do gorutin s&nbsp;využitím
kanálů. V&nbsp;některých aplikacích totiž nemůžeme čekat na data posílaná do
jediného kanálů tak, jak je to naznačeno v&nbsp;následujícím kódu:</p>

<pre>
func main() {
        channel := make(chan int)
&nbsp;
        go message(1, channel)
&nbsp;
        code, status := &lt;-channel
&nbsp;
        fmt.Printf("received code: %d and status: %t\n", code, status)
        fmt.Println("main end")
}
</pre>

<p>Namísto toho je někdy zapotřebí zapsat zhruba následující kód:</p>

<pre>
func main() {
        channel1 := make(chan int)
        channel2 := make(chan int)
&nbsp;
        go message(1, channel1)
        go message(2, channel2)
        go message(3, channel3)
&nbsp;
        <strong>code, status := &lt;-channel1</strong>
        <strong>NEBO</strong>
        <strong>code, status := &lt;-channel2</strong>
        <strong>NEBO</strong>
        <strong>code, status := &lt;-channel3</strong>
&nbsp;
        fmt.Printf("received code: %d and status: %t\n", code, status)
        fmt.Println("main end")
}
</pre>

<p>A právě zvýrazněná část kódu je zapisována s&nbsp;využitím slova
<strong>select</strong>.</p>

<p>Toto slovo se ovšem může použít i v&nbsp;opačném významu, tj.&nbsp;při
posílání dat, tedy přibližně v&nbsp;tomto významu:</p>

<pre>
func main() {
        channel1 := make(chan int)
        channel2 := make(chan int)
&nbsp;
        go message(1, channel1)
        go message(2, channel2)
        go message(3, channel3)
&nbsp;
        <strong>channel1 &lt;- data1</strong>
        <strong>NEBO</strong>
        <strong>channel2 &lt;- data2</strong>
        <strong>NEBO</strong>
        <strong>channel3 &lt;- data3</strong>
&nbsp;
        fmt.Printf("received code: %d and status: %t\n", code, status)
        fmt.Println("main end")
}
</pre>

<p><div class="rs-tip-major">Poznámka: opět si dovolím poukázat na to, jak
jednoduše (a především bez potenciálních chyb) je možné v&nbsp;Go implementovat
paralelní popř.&nbsp;asynchronní kód s&nbsp;využitím základních konstrukcí
tohoto jazyka: gorutin (klíčové slovo <strong>go</strong>), kanálů (operátor
&lt;-) a klíčového slova <strong>select</strong>.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Použití konstrukce <strong>select-case</strong> pro čekání na data z&nbsp;gorutin</h2>

<p>Ukažme si nyní velmi jednoduché použití konstrukce
<strong>select-case</strong> při čekání na data, která mohou být poslána do
jednoho ze dvou kanálů <strong>ch1</strong> a <strong>ch2</strong>.
V&nbsp;tomto programu jsou nejdříve vytvořeny dva kanály s&nbsp;kapacitou 1
(jediné celé číslo):</p>

<pre>
ch1 := make(chan int)
ch2 := make(chan int)
</pre>

<p>Následně jsou spuštěny dvě gorutiny, z&nbsp;nichž první
pošle data do prvního kanálu <strong>ch1</strong> a druhá do druhého kanálu
<strong>ch2</strong>:</p>

<pre>
go worker(ch1, 1)
go worker(ch2, 2)
</pre>

<p>Nakonec V&nbsp;konstrukci <strong>select-case</strong> počkáme na
to, až jsou data dostupná v&nbsp;libovolném z&nbsp;těchto kanálů (teoreticky
ani nemusíme jeden z&nbsp;workerů-gorutin spouštět):</p>

<pre>
<strong>select</strong> {
<strong>case &lt;-ch1</strong>:
        fmt.Println("Data z kanálu 1")
<strong>case &lt;-ch2</strong>:
        fmt.Println("Data z kanálu 2")
}
</pre>

<p>Ve chvíli, kdy jsou data přijata, je konstrukce <strong>select-case</strong>
ukončena a ihned poté se ukončí i běh celé aplikace.</p>

<p>Úplný zdrojový kód tohoto demonstračního příkladu naleznete na adrese <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/06_select_statement_receive.go">https://github.com/tisnik/go-fedora/blob/master/article_07/06_select_statement_receive.go</a>:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "time"
)
&nbsp;
func worker(channel chan int, worker int) {
        fmt.Printf("Worker %d spuštěn\n", worker)
        time.Sleep(2 * time.Second)
        channel &lt;- 1
        fmt.Printf("Worker %d ukončen\n", worker)
}
&nbsp;
func main() {
        ch1 := make(chan int)
        ch2 := make(chan int)
&nbsp;
        go worker(ch1, 1)
        go worker(ch2, 2)
&nbsp;
        <strong>select</strong> {
        <strong>case &lt;-ch1</strong>:
                fmt.Println("Data z kanálu 1")
        <strong>case &lt;-ch2</strong>:
                fmt.Println("Data z kanálu 2")
        }
}
</pre>

<p>Po spuštění tohoto příkladu můžeme vidět, že se obě gorutiny skutečně
spustily, přičemž se v&nbsp;příkazu <strong>select</strong> náhodně vybrala
druhá větev <strong>case</strong>, v&nbsp;níž se přečetla data z&nbsp;druhého
kanálu, takže se příslušný worker stihl ukončit (což ovšem není nijak zaručené
chování):</p>

<pre>
Worker 2 spuštěn
Worker 1 spuštěn
Worker 2 ukončen
Data z kanálu 2
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Význam větve <strong>default</strong> v&nbsp;konstrukci <strong>select-case</strong></h2>

<p>V&nbsp;některých aplikacích může být výhodné, aby se v&nbsp;případě, že
žádný kanál zpracovávaný v&nbsp;konstrukci <strong>select-case</strong>
neobsahuje data, pokračovalo v&nbsp;nějakém dalším výpočtu. K&nbsp;tomuto účelu
slouží větev <strong>default</strong> zavolaná ve chvíli, kdy není možné
zpracovat ani jednu z&nbsp;větví <strong>case</strong>. Příklad použití této
nové větve je ukázán na <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/07_select_statement_receive_default.go">dalším
demonstračním příkladu</a>:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "time"
)
&nbsp;
func worker(channel chan int, worker int) {
        fmt.Printf("Worker %d spuštěn\n", worker)
        time.Sleep(2 * time.Second)
        channel &lt;- 1
        fmt.Printf("Worker %d ukončen\n", worker)
}
&nbsp;
func main() {
        ch1 := make(chan int)
        ch2 := make(chan int)
&nbsp;
        go worker(ch1, 1)
        go worker(ch2, 2)
&nbsp;
        for true {
                <strong>select</strong> {
                <strong>case &lt;-ch1</strong>:
                        fmt.Println("Data z kanálu 1")
                <strong>case &lt;-ch2</strong>:
                        fmt.Println("Data z kanálu 2")
                <strong>default</strong>:
                        fmt.Println("Žádná data nejsou k dispozici")
                }
                time.Sleep(1 * time.Second)
        }
}
</pre>

<p>V&nbsp;příkladu je implementována nekonečná smyčka a v&nbsp;konstrukci
<strong>select-case</strong> je umístěna i větev <strong>defalt</strong>
zavolaná ve chvíli, kdy nejsou k&nbsp;dispozici data v&nbsp;žádném
kontrolovaném kanálu.  V&nbsp;tomto případě není <strong>select-case</strong>
blokující, jak ostatně můžeme vidět i z&nbsp;výpisů:</p>

<pre>
Worker 1 spuštěn
Žádná data nejsou k dispozici
Worker 2 spuštěn
Žádná data nejsou k dispozici
Data z kanálu 1
Worker 1 ukončen
Data z kanálu 2
Worker 2 ukončen
Žádná data nejsou k dispozici
Žádná data nejsou k dispozici
Žádná data nejsou k dispozici
...
...
...
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Použití konstrukce <strong>select-case</strong> při posílání dat</h2>

<p>Programovou konstrukci typu <strong>select-case</strong> je možné využít
nejenom pro příjem dat (s&nbsp;případným čekáním na okamžik, až se data objeví
v&nbsp;kanálu), ale i pro posílání dat. Význam je přitom stejný &ndash; obě
operace mohou být blokující a mnohdy potřebujeme, aby jedna gorutina posílala
data většímu množství gorutin, samozřejmě opět s&nbsp;využitím kanálů.
V&nbsp;následujícím <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/08_select_statement_send.go">demonstračním
příkladu</a> budeme posílat náhodná data (buď nulu nebo jedničku) do gorutiny
reprezentované funkcí <strong>worker</strong>:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func worker(channel chan int) {
        for true {
                value, ok := &lt;-channel
                if ok {
                        fmt.Printf("Přijata hodnota %d\n", value)
                } else {
                        fmt.Printf("Kanál je uzavřen\n")
                }
        }
}
&nbsp;
func main() {
        ch1 := make(chan int)
&nbsp;
        go worker(ch1)
&nbsp;
        for i := 0; i &lt; 10; i++ {
                <strong>select</strong> {
                <strong>case ch1 &lt;- 0</strong>:
                        fmt.Println("Poslána nula")
                <strong>case ch1 &lt;- 1</strong>:
                        fmt.Println("Poslána jednička")
                }
        }
}
</pre>

<p>Příklad chování tohoto příkladu po jeho spuštění:</p>

<pre>
Přijata hodnota 0
Poslána nula
Poslána jednička
Přijata hodnota 1
Přijata hodnota 0
Poslána nula
Poslána jednička
Přijata hodnota 1
Přijata hodnota 0
Poslána nula
Poslána nula
Přijata hodnota 0
Přijata hodnota 1
Poslána jednička
Poslána jednička
Přijata hodnota 1
Přijata hodnota 0
Poslána nula
Poslána jednička
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jak se promíchávají
zprávy workera a hlavní gorutiny. Mohlo by se zdát, že gorutina přijímá data,
která ještě nebyla poslána, to je ovšem způsobeno tím, že worker po příjmu dat
ještě stihne provést tisk zprávy před přepnutím vlákna do hlavní
gorutiny.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Blokující zápis do kanálu</h2>

<p>Předchozí příklad je možné rozšířit o druhou gorutinu-workera. Oba workeři
nyní budou sdílet jediný komunikační kanál a při zápisu hodnoty do kanálu je
tedy náhodně vybrán ten worker, který je v&nbsp;daný okamžik k&nbsp;dispozici.
<a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/09_select_statement_send.go">První
varianta příkladu</a> používá kanál s&nbsp;kapacitou jediné položky (jedná se
tedy vlastně o jednoduchý <i>mailbox</i>):</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "time"
)
&nbsp;
func worker(channel chan int, worker int) {
        for true {
                value, ok := &lt;-channel
                if ok {
                        fmt.Printf("Worker %d přijal hodnotu %d\n", worker, value)
                } else {
                        fmt.Printf("Kanál je uzavřen pro workera %d\n", worker)
                }
                time.Sleep(1 * time.Second)
        }
}
&nbsp;
func main() {
        ch1 := make(chan int)
&nbsp;
        go worker(ch1, 1)
        go worker(ch1, 2)
&nbsp;
        for i := 0; i &lt; 10; i++ {
                <strong>select</strong> {
                <strong>case ch1 &lt;- 0</strong>:
                        fmt.Println("Poslána nula")
                <strong>case ch1 &lt;- 1</strong>:
                        fmt.Println("Poslána jednička")
                }
        }
}
</pre>

<p>Zápis do kanálu je v&nbsp;tomto případě blokující operace a opět se náhodně
vybere jedna z&nbsp;větví v&nbsp;konstrukci <strong>select-case</strong>:</p>

<pre>
Worker 2 přijal hodnotu 1
Poslána jednička
Poslána nula
Worker 1 přijal hodnotu 0
Worker 2 přijal hodnotu 0
Poslána nula
Poslána nula
Worker 1 přijal hodnotu 0
Worker 2 přijal hodnotu 0
Poslána nula
Worker 1 přijal hodnotu 0
Poslána nula
Worker 1 přijal hodnotu 0
Poslána nula
Poslána jednička
Worker 2 přijal hodnotu 1
Worker 1 přijal hodnotu 1
Poslána jednička
Poslána nula
</pre>

<p>Pokud ovšem v&nbsp;příkladu změníme řádek, na němž se vytváří kanál, z:</p>

<pre>
ch1 := make(chan int)
</pre>

<p>na:</p>

<pre>
ch1 := make(chan int, 20)
</pre>

<p>stane se zápis neblokující operací, protože kanál bude mít kapacitu dvaceti
položek (jedná se o frontu) a my do něj zapíšeme pouze deset položek. Chování
aplikace se změní:</p>

<pre>
Poslána nula
Poslána nula
Poslána nula
Poslána nula
Poslána jednička
Poslána nula
Poslána jednička
Poslána jednička
Poslána nula
Poslána jednička
</pre>

<p>Další text se (většinou) nevypíše, a to z&nbsp;toho prostého důvodu, že
hlavní gorutina skončí, aniž by došlo k&nbsp;přepnutí kontextu do prvního či
druhého workera.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Kombinace čtení a zápisu v&nbsp;konstrukci <strong>select-case</strong></h2>

<p>V&nbsp;posledním <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/10_select_statement_send_receive.go">demonstračním
příkladu</a>, v&nbsp;němž použijeme konstrukci <strong>select-case</strong>,
zkombinujeme jak čtení, tak i zápis do různých kanálů. I tuto kombinaci je
možné v&nbsp;jazyku Go použít, takže následující zápis je zcela korektní, a to
jak syntakticky, tak i sémanticky:</p>

<pre>
<strong>select</strong> {
<strong>case ch1 &lt;- 0</strong>:
        fmt.Println("Poslána nula")
<strong>case ch1 &lt;- 1</strong>:
        fmt.Println("Poslána jednička")
<strong>case data, ok := &lt;-ch2</strong>:
        if ok {
                fmt.Printf("Přijata data %d z kanálu 2\n", data)
        }
<strong>case data, ok := &lt;-ch3</strong>:
        if ok {
                fmt.Printf("Přijata data %d z kanálu 3\n", data)
        }
}
</pre>

<p>V&nbsp;předchozí konstrukci se vybere vždy pouze jediná větev
v&nbsp;závislosti na tom, zda jsou v&nbsp;prvních dvou kanálech data
popř.&nbsp;zda jsou druhé dva kanály prázdné či obsazené.</p>

<p>Úplný zdrojový kód tohoto demonstračního příkladu vypadá následovně:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "time"
)
&nbsp;
func receiver(channel chan int, receiver int) {
        for true {
                value, ok := &lt;-channel
                if ok {
                        fmt.Printf("Příjemce %d přijal hodnotu %d\n", receiver, value)
                } else {
                        fmt.Printf("Kanál je pro příjemce %d uzavřen\n", receiver)
                }
                time.Sleep(2 * time.Second)
        }
}
&nbsp;
func sender(channel chan int, sender int) {
        fmt.Printf("Odesílatel %d byl spuštěn\n", sender)
        for i := 1; i &lt;= 5; i++ {
                time.Sleep(1 * time.Second)
                channel &lt;- i
        }
        fmt.Printf("Odesílatel %d byl ukončen\n", sender)
}
&nbsp;
func main() {
        ch1 := make(chan int)
        ch2 := make(chan int)
        ch3 := make(chan int)
        // ch1 := make(chan int, 20)
&nbsp;
        go receiver(ch1, 1)
        go receiver(ch1, 2)
        go sender(ch2, 1)
        go sender(ch3, 2)
&nbsp;
        for i := 0; i &lt; 20; i++ {
                <strong>select</strong> {
                <strong>case ch1 &lt;- 0</strong>:
                        fmt.Println("Poslána nula")
                <strong>case ch1 &lt;- 1</strong>:
                        fmt.Println("Poslána jednička")
                <strong>case data, ok := &lt;-ch2</strong>:
                        if ok {
                                fmt.Printf("Přijata data %d z kanálu 2\n", data)
                        }
                <strong>case data, ok := &lt;-ch3</strong>:
                        if ok {
                                fmt.Printf("Přijata data %d z kanálu 3\n", data)
                        }
                }
        }
}
</pre>

<p>Příklad výsledků vypsaných tímto příkladem po jeho spuštění:</p>

<pre>
Odesílatel 1 byl spuštěn
Odesílatel 2 byl spuštěn
Poslána nula
Poslána jednička
Příjemce 1 přijal hodnotu 1
Příjemce 2 přijal hodnotu 0
Přijata data 1 z kanálu 2
Přijata data 1 z kanálu 3
Příjemce 2 přijal hodnotu 1
Poslána jednička
Přijata data 2 z kanálu 2
Poslána jednička
Příjemce 1 přijal hodnotu 1
Přijata data 2 z kanálu 3
Přijata data 3 z kanálu 2
Přijata data 3 z kanálu 3
Příjemce 2 přijal hodnotu 1
Poslána jednička
Poslána nula
Příjemce 1 přijal hodnotu 0
Přijata data 4 z kanálu 3
Přijata data 4 z kanálu 2
Odesílatel 2 byl ukončen
Přijata data 5 z kanálu 3
Přijata data 5 z kanálu 2
Odesílatel 1 byl ukončen
Příjemce 2 přijal hodnotu 0
Poslána nula
Příjemce 1 přijal hodnotu 1
Poslána jednička
Příjemce 2 přijal hodnotu 0
Poslána nula
Příjemce 1 přijal hodnotu 0
Poslána nula
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Deklarace konstant v&nbsp;programovacím jazyku Go</h2>

<p>V&nbsp;programovacím jazyku Go je možné deklarovat konstanty s&nbsp;využitím
klíčového slova <strong>const</strong>, za nímž se zapíše jméno konstanty, její
typ a hodnota konstanty (oddělená přiřazovacím operátorem =). V&nbsp;případě,
že se nespecifikuje typ konstanty, bude odvozen automaticky překladačem na
základě přiřazované hodnoty. <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/11_constants.go">Příklad
deklarací konstant</a> různých typů (povšimněte si, že již definované konstanty
mohou být součástí dalších konstantních výrazů):</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
<strong>const Pi float64 = 3.1415927</strong>
<strong>const E = 2.71828</strong>
&nbsp;
<strong>const z0 int = 0</strong>
<strong>const z1 = 0</strong>
&nbsp;
<strong>const z2 = z0 + z1</strong>
&nbsp;
func main() {
        fmt.Printf("Pi = %f\n", Pi)
        fmt.Printf("e = %f\n", E)
&nbsp;
        fmt.Printf("z0 = %d\n", z0)
        fmt.Printf("z1 = %d\n", z1)
&nbsp;
        fmt.Printf("z2 = %d\n", z2)
}
</pre>

<p>Výsledek po spuštění tohoto příkladu:</p>

<pre>
Pi = 3.141593
e = 2.718280
z0 = 0
z1 = 0
z2 = 0
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Demonstrační příklad: konstanty různých typů, blok s&nbsp;konstantami</h2>

<p>Poměrně často se setkáme i s&nbsp;uzavřením všech konstant do jediného bloku
začínajícího klíčovým slovem <strong>const</strong>. Před jednotlivými
konstantami se potom toto slovo již nezapisuje, což je ostatně patrné i při
pohledu na další <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/12_constants.go">příklad</a>:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
const (
        Pi float64 = 3.1415927
        E          = 2.71828
&nbsp;
        z0 int = 0
        z1     = 0
        z2     = z0 + z1
)
&nbsp;
func main() {
        fmt.Printf("Pi = %f\n", Pi)
        fmt.Printf("e = %f\n", E)
&nbsp;
        fmt.Printf("z0 = %d\n", z0)
        fmt.Printf("z1 = %d\n", z1)
&nbsp;
        fmt.Printf("z2 = %d\n", z2)
}
</pre>

<p>Výsledek, který získáme po spuštění tohoto příkladu:</p>

<pre>
Pi = 3.141593
e = 2.718280
z0 = 0
z1 = 0
z2 = 0
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Automatické generování celočíselné řady pomocí klíčového slova <strong>iota</strong></h2>

<p>S&nbsp;blokem s&nbsp;konstantami, který jsme si ukázali <a
href="#k14">v&nbsp;předchozí kapitole</a>, souvisí i speciální identifikátor
<strong>iota</strong>. Jedná se o konstantu, která má při prvním použití
hodnotu 0, při druhém použití hodnotu 1 atd. Jinými slovy je tento
identifikátor interně realizován jako celočíselný čítač v&nbsp;překladači,
jehož hodnota se nastavuje na nulu při každém vstupu do bloku
<strong>const</strong>. Podívejme se na následující <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/13_iota.go">demonstrační
příklad</a>, v&nbsp;němž se speciální identifikátor <strong>iota</strong>
používá pro realizaci (v&nbsp;Go neexistujícího) výčtového typu:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
const (
        Pondeli = <strong>iota</strong>
        Utery   = <strong>iota</strong>
        Streda  = <strong>iota</strong>
        Ctvrtek = <strong>iota</strong>
        Patek   = <strong>iota</strong>
        Sobota  = <strong>iota</strong>
        Nedele  = <strong>iota</strong>
)
&nbsp;
func main() {
        fmt.Printf("%d\n", Pondeli)
        fmt.Printf("%d\n", Streda)
        fmt.Printf("%d\n", Patek)
}
</pre>

<p>Po překladu a spuštění tohoto příkladu získáme tři hodnoty odpovídající dnům
pondělí, středa a pátek:</p>

<pre>
0
2
4
</pre>

<p><div class="rs-tip-major">Poznámka: opět zde můžeme vidět, že se v&nbsp;Go
používá obecnější konstrukce, než je tomu například v&nbsp;jazyku C a jeho typu
<strong>enum</strong>.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Praktické použití klíčového slova <strong>iota</strong></h2>

<p>Při praktickém použití klíčového slova <strong>iota</strong> se většinou
tento identifikátor zapisuje pouze za první jméno konstanty v&nbsp;bloku
<strong>const</strong>. U dalších konstant již není zapotřebí zapisovat ani
typ, ani do nich explicitně přiřazovat hodnotu. Pokud není přiřazení zapsáno,
automaticky se v&nbsp;průběhu překladu doplní text &bdquo;= iota&ldquo;, což je
ukázáno <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/14_iota_better_usage.go">na
dalším příkladu</a>:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
const (
        Pondeli = <strong>iota</strong>
        Utery
        Streda
        Ctvrtek
        Patek
        Sobota
        Nedele
)
&nbsp;
func main() {
        fmt.Printf("%d\n", Pondeli)
        fmt.Printf("%d\n", Streda)
        fmt.Printf("%d\n", Patek)
}
</pre>

<p>Výsledek bude stejný, jako v&nbsp;předchozím příkladu:</p>

<pre>
0
2
4
</pre>

<p>Ve skutečnosti nám ovšem nic nebrání <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/15_iota_another_usage.go">použít
<strong>iota</strong></a> i poněkud netradičně v&nbsp;prakticky libovolných
konstantních výrazech (proto je <strong>iota</strong> obecnějším
konceptem):</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
const (
        a = <strong>iota</strong> + 0.5i
        b = <strong>iota</strong> + 0.5i
        c = 1.0 / <strong>iota</strong>
        d = 1 &lt;&lt; <strong>iota</strong>
        e = <strong>iota</strong> ^ 0xff
)
&nbsp;
func main() {
        fmt.Printf("%f\n", a)
        fmt.Printf("%f\n", b)
        fmt.Printf("%f\n", c)
        fmt.Printf("%d\n", d)
        fmt.Printf("%d\n", e)
}
</pre>

<pre>
(0.000000+0.500000i)
(1.000000+0.500000i)
0.500000
8
251
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Funkce s&nbsp;variabilním počtem parametrů v&nbsp;programovacím jazyku Go</h2>

<p>Poslední vlastností programovacího jazyka Go, s&nbsp;níž se dnes seznámíme,
je koncept variadických funkcí, tj.&nbsp;funkcí s&nbsp;variabilním počtem
parametrů. Tyto parametry jsou ovšem typované (nelze použít obdobu <strong>void
*</strong>). Pokud funkce obsahuje jak běžné parametry, tak i nepovinné
parametry, musí být běžné parametry umístěny před parametry nepovinné,
tj.&nbsp;tak, jak je to ukázáno <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/16_variadic_function.go">v&nbsp;dalším
příkladu</a>:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func f1(<strong>msg string</strong>) {
        fmt.Printf("%s\n", msg)
}
&nbsp;
func f2(<strong>parts ...string</strong>) {
        for _, val := range parts {
                fmt.Printf("%s ", val)
        }
        fmt.Println()
}
&nbsp;
func f3(<strong>prefix string, parts ...string</strong>) {
        fmt.Println(prefix)
        for _, val := range parts {
                fmt.Printf("%s ", val)
        }
        fmt.Println()
}
&nbsp;
func main() {
        f1("Hello")
        f2("Hello", "world", "!")
        f3("Message:", "Hello", "world", "again", "!")
}
</pre>

<p>Funkce <strong>f1</strong> akceptuje jeden parametr, funkce
<strong>f2</strong> libovolný počet parametrů (i žádný parametr) a funkce
<strong>f3</strong> akceptuje minimálně jeden parametr. Všechny parametry jsou
typu řetězec:</p>

<pre>
Hello
Hello world ! 
Message:
Hello world again ! 
</pre>

<p>Nepovinné parametry ovšem mohou být uvedeny jen na konci seznamu parametrů,
takže například <a
href="https://github.com/tisnik/go-fedora/blob/master/article_07/17_variadic_function_improper_usage.go">tento příklad</a> není korektní a nebude ho možné přeložit:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func f4(<strong>prefix string, parts1 ...string, parts2 ...string</strong>) {
        fmt.Println(prefix)
        for _, val := range parts1 {
                fmt.Printf("%s ", val)
        }
        fmt.Println()
        for _, val := range parts2 {
                fmt.Printf("%s ", val)
        }
        fmt.Println()
}
&nbsp;
func main() {
        f4("Message:", "Hello", "world", "again", "!")
}
</pre>

<p>Při pokusu o překlad se vypíše:</p>

<pre>
./17_variadic_function_improper_usage.go:12:34: can only use ... with final parameter in list
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Základní informace o adresářové struktuře při práci se složitějšími projekty</h2>

<p>Již v&nbsp;úvodním článku jsme si řekli, že při instalaci jazyka Go je
vhodné nastavit proměnnou <strong>GOPATH</strong>, například na adresář
<strong>~/home/go</strong>. Ve skutečnosti je problematika proměnné prostředí
<strong>GOPATH</strong> a jejího významu poněkud složitější, protože tato
proměnná by měla obsahovat absolutní (!) cestu k&nbsp;adresáři, který má tuto
strukturu:</p>

<pre>
.
├── bin
│   ├──
│   └──
├── pkg
│   ├──
│   └──
└── src
    ├──
    ├──
    └──
</pre>

<p>Celý adresář se nazývá pracovní plocha (<i>workspace</i>) a obsahuje tři
podadresáře pojmenované <strong>src</strong>, <strong>pkg</strong> a
<strong>bin</strong>. Prozatím nás bude zajímat především podadresář
<strong>src</strong>, v&nbsp;němž jsou typicky uloženy repositáře
(<i>repository</i>) a v&nbsp;každém repositáři je libovolný počet balíčků
(<i>package</i>). V&nbsp;balíčcích už nalezneme zdrojové soubory
<strong>.go</strong>, pomocné skripty, datové soubory, dokumentaci atd.
Workspace představovaný adresářem nazvaným <strong>go</strong>, v&nbsp;němž
jsou umístěny tři repositáře, může vypadat následovně:</p>

<pre>
.
└── go
    ├── bin
    ├── pkg
    └── src
        ├── repository1
        │   ├── hello1
        │   │   └── hello.go
        │   └── hello2
        │       └── hello.go
        ├── repository2
        └── repository3
</pre>

<p>Vidíme, že v&nbsp;repositáři pojmenovaném <strong>repository1</strong> jsou
umístěny dva balíčky s&nbsp;názvy <strong>hello1</strong> a
<strong>hello2</strong>, přičemž v&nbsp;každém balíčku je jediný zdrojový
soubor, který je (čistě náhodou) shodně pojmenován
<strong>hello.go</strong>.</p>

<pre>
package main
&nbsp;
func main() {
        println("repository1: Hello world!")
}
</pre>

<p>Další informace o této adresářové struktuře a jejím významu si podrobněji
popíšeme v&nbsp;navazujícím článku, v&nbsp;němž se budeme věnovat správě
balíčků, jejich instalaci apod.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
doslova několik kilobajtů), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_bit_operators.go</td><td>všechny binární bitové operátory</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/01_bit_operators.go">https://github.com/tisnik/go-fedora/blob/master/article_07/01_bit_operators.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>02_boolean_operators.go</td><td>logické operátory aplikované na pravdivostní hodnoty</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/02_boolean_operators.go">https://github.com/tisnik/go-fedora/blob/master/article_07/02_boolean_operators.go</a></td></tr>
<tr><td> 3</td><td>02A_boolean_operators_short_circuit.go</td><td>zkrácené vyhodnocování logických operátorů</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/02A_boolean_operators_short_circuit.go">https://github.com/tisnik/go-fedora/blob/master/article_07/02A_boolean_operators_short_circuit.go</a></td></tr>
<tr><td> 4</td><td>02B_boolean_operators_improper_usage.go</td><td>nekorektní použití logických operátorů</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/02B_boolean_operators_improper_usage.go">https://github.com/tisnik/go-fedora/blob/master/article_07/02B_boolean_operators_improper_usage.go</a></td></tr>
<tr><td> 5</td><td>02C_boolean_operators_improper_usage.go</td><td>nekorektní použití logických operátorů</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/02C_boolean_operators_improper_usage.go">https://github.com/tisnik/go-fedora/blob/master/article_07/02C_boolean_operators_improper_usage.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>inc1.c</td><td>operátor ++ a ukazatele v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/inc1.c">https://github.com/tisnik/go-fedora/blob/master/article_07/inc1.c</a></td></tr>
<tr><td> 7</td><td>inc2.c</td><td>operátor ++ a ukazatele v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/inc1.c">https://github.com/tisnik/go-fedora/blob/master/article_07/inc1.c</a></td></tr>
<tr><td> 8</td><td>03_inc_dec.go</td><td>použití operací ++ a -- v&nbsp;Go</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/03_inc_dec.go">https://github.com/tisnik/go-fedora/blob/master/article_07/03_inc_dec.go</a></td></tr>
<tr><td> 9</td><td>04_inc_dec_bad_usage.go</td><td>nekorektní použití operací ++ a --</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/04_inc_dec_bad_usage.go">https://github.com/tisnik/go-fedora/blob/master/article_07/04_inc_dec_bad_usage.go</a></td></tr>
<tr><td>10</td><td>05_inc_dec_bad_usage.go</td><td>nekorektní použití operací ++ a --</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/05_inc_dec_bad_usage.go">https://github.com/tisnik/go-fedora/blob/master/article_07/05_inc_dec_bad_usage.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>06_select_statement_receive.go</td><td>použití <strong>select</strong> pro příjem dat</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/06_select_statement_receive.go">https://github.com/tisnik/go-fedora/blob/master/article_07/06_select_statement_receive.go</a></td></tr>
<tr><td>12</td><td>07_select_statement_receive_default.go</td><td>konstrukce <strong>select</strong> a větev <strong>default</strong></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/07_select_statement_receive_default.go">https://github.com/tisnik/go-fedora/blob/master/article_07/07_select_statement_receive_default.go</a></td></tr>
<tr><td>13</td><td>08_select_statement_send.go</td><td>posílání dat v&nbsp;konstrukci <strong>select</strong></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/08_select_statement_send.go">https://github.com/tisnik/go-fedora/blob/master/article_07/08_select_statement_send.go</a></td></tr>
<tr><td>14</td><td>09_select_statement_send.go</td><td>dvě gorutiny sdílející jediný kanál s&nbsp;kapacitou 1</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/09_select_statement_send.go">https://github.com/tisnik/go-fedora/blob/master/article_07/09_select_statement_send.go</a></td></tr>
<tr><td>15</td><td>09B_select_statement_send.go</td><td>dvě gorutiny sdílející jediný kanál s&nbsp;kapacitou 20</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/09B_select_statement_send.go">https://github.com/tisnik/go-fedora/blob/master/article_07/09B_select_statement_send.go</a></td></tr>
<tr><td>16</td><td>10_select_statement_send_receive.go</td><td>čtení i zápis do kanálu</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/10_select_statement_send_receive.go">https://github.com/tisnik/go-fedora/blob/master/article_07/10_select_statement_send_receive.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>11_constants.go</td><td>deklarace konstant různých typů</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/11_constants.go">https://github.com/tisnik/go-fedora/blob/master/article_07/11_constants.go</a></td></tr>
<tr><td>17</td><td>12_constants.go</td><td>deklarace konstant v&nbsp;bloku</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/12_constants.go">https://github.com/tisnik/go-fedora/blob/master/article_07/12_constants.go</a></td></tr>
<tr><td>18</td><td>13_iota.go</td><td>použití identifikátoru <strong>iota</strong></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/13_iota.go">https://github.com/tisnik/go-fedora/blob/master/article_07/13_iota.go</a></td></tr>
<tr><td>19</td><td>14_iota_better_usage.go</td><td>praktické použití identifikátoru <strong>iota</strong></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/14_iota_better_usage.go">https://github.com/tisnik/go-fedora/blob/master/article_07/14_iota_better_usage.go</a></td></tr>
<tr><td>20</td><td>15_iota_another_usage.go</td><td>další příklad použití identifikátoru <strong>iota</strong></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/15_iota_another_usage.go">https://github.com/tisnik/go-fedora/blob/master/article_07/15_iota_another_usage.go</a></td></tr>
<tr><td>21</td><td>16_variadic_function.go</td><td>variadické funkce</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/16_variadic_function.go">https://github.com/tisnik/go-fedora/blob/master/article_07/16_variadic_function.go</a></td></tr>
<tr><td>22</td><td>17_variadic_function_improper_usage.go</td><td>variadické funkce, nekorektní použití</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/17_variadic_function_improper_usage.go">https://github.com/tisnik/go-fedora/blob/master/article_07/17_variadic_function_improper_usage.go</a></td></tr>
<tr><td>23</td><td>gopath_directory</td><td>adresářová struktura GOPATH</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_07/gopath_directory">https://github.com/tisnik/go-fedora/blob/master/article_07/gopath_directory</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Select waits on a group of channels<br />
<a href="https://yourbasic.org/golang/select-explained/">https://yourbasic.org/golang/select-explained/</a>
</li>

<li>Rob Pike: Simplicity is Complicated (video)<br />
<a href="http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893">http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893</a>
</li>

<li>Algorithms to Go<br />
<a href="https://yourbasic.org/">https://yourbasic.org/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů: vlastní filtry a lexery<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/</a>
</li>

<li>Go Defer Simplified with Practical Visuals<br />
<a href="https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff">https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff</a>
</li>

<li>5 More Gotchas of Defer in Go — Part II<br />
<a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa">https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa</a>
</li>

<li>The Go Blog: Defer, Panic, and Recover<br />
<a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a>
</li>

<li>The defer keyword in Swift 2: try/finally done right<br />
<a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer">https://www.hackingwithswift.com/new-syntax-swift-2-defer</a>
</li>

<li>Swift Defer Statement<br />
<a href="https://andybargh.com/swift-defer-statement/">https://andybargh.com/swift-defer-statement/</a>
</li>

<li>Modulo operation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Modulo_operation">https://en.wikipedia.org/wiki/Modulo_operation</a>
</li>

<li>Node.js vs Golang: Battle of the Next-Gen Languages<br />
<a href="https://www.hostingadvice.com/blog/nodejs-vs-golang/">https://www.hostingadvice.com/blog/nodejs-vs-golang/</a>
</li>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go<br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

<li>Printf Format Strings<br />
<a href="https://www.cprogramming.com/tutorial/printf-format-strings.html">https://www.cprogramming.com/tutorial/printf-format-strings.html</a>
</li>

<li>Java: String.format<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-</a>
</li>

<li>Java: format string syntax<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a>
</li>

<li>Selectors<br />
<a href="https://golang.org/ref/spec#Selectors">https://golang.org/ref/spec#Selectors</a>
</li>

<li>Calling Go code from Python code<br />
<a href="http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/">http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/</a>
</li>

<li>Go Data Structures: Interfaces <br />
<a href="https://research.swtch.com/interfaces">https://research.swtch.com/interfaces</a>
</li>

<li>How to use interfaces in Go<br />
<a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go</a>
</li>

<li>Interfaces in Go (part I)<br />
<a href="https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c">https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c</a>
</li>

<li>Part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>What about Trait support in Golang?<br />
<a href="https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/">https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/</a>
</li>

<li>Don't Get Bitten by Pointer vs Non-Pointer Method Receivers in Golang<br />
<a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/">https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/</a>
</li>

<li>Control Flow<br />
<a href="https://en.wikipedia.org/wiki/Control_flow">https://en.wikipedia.org/wiki/Control_flow</a>
</li>

<li>Structured programming<br />
<a href="https://en.wikipedia.org/wiki/Structured_programming">https://en.wikipedia.org/wiki/Structured_programming</a>
</li>

<li>Control Structures<br />
<a href="https://www.golang-book.com/books/intro/5">https://www.golang-book.com/books/intro/5</a>
</li>

<li>Control structures - Go if else statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html">http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html</a>
</li>

<li>Control structures - Go switch case statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html</a>
</li>

<li>Control structures - Go for loop, break, continue, range<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html</a>
</li>

<li>Single Function Exit Point<br />
<a href="http://wiki.c2.com/?SingleFunctionExitPoint">http://wiki.c2.com/?SingleFunctionExitPoint</a>
</li>

<li>Entry point<br />
<a href="https://en.wikipedia.org/wiki/Entry_point">https://en.wikipedia.org/wiki/Entry_point</a>
</li>

<li>Why does Go have a GOTO statement?!<br />
<a href="https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/">https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/</a>
</li>

<li>Effective Go<br />
<a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a>
</li>

<li>GoClipse: an Eclipse IDE for the Go programming language<br />
<a href="http://goclipse.github.io/">http://goclipse.github.io/</a>
</li>

<li>GoClipse Installation<br />
<a href="https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation">https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

