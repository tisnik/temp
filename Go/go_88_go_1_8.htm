<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. </a></p>
<p><a href="#k03">*** 3. </a></p>
<p><a href="#k04">*** 4. </a></p>
<p><a href="#k05">*** 5. </a></p>
<p><a href="#k06">*** 6. </a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<p>Již <a href="https://www.root.cz/clanky/go-minimalisticky-a-prekvapive-vykonny-programovaci-jazyk/">v&nbsp;úvodní části</a> <a href="https://www.root.cz/serialy/programovaci-jazyk-go/">seriálu o programovacím jazyku Go</a> jsme si mj.&nbsp;řekli, že tento jazyk byl navržen takovým způsobem, že obsahuje pouze ty syntaktické a sémantické prvky, na nichž se <a href="https://www.informit.com/articles/article.aspx?p=1623555">shodli všichni tři</a> autoři tohoto projektu. Všechny vlastnosti, u nichž nebylo na sto procent jisté, že jsou správně navrženy a že jejich implementace nebude zpomalovat překladač ani výsledný zkompilovaný a slinkovaný kód, nebyly do první verze programovacího jazyka Go přidány. Týká se to některých vlastností, které mohou programátorům chybět &ndash; například výjimek, tříd (a na třídách postavené větvi objektově orientovaného programování) a taktéž generických datových typů a generických funkcí. A zejména neexistence generických datových typů může být pro některé typy aplikací značně omezující, protože je například složité implementovat obecné a současně i typově bezpečné datové struktury typu graf, strom, zásobník, fronta atd.</p>

<p>V&nbsp;dnešním článku se nejprve ve stručnosti seznámíme s&nbsp;tím, jakým způsobem jsou generické datové typy implementovány <a href="#k05">v&nbsp;Javě</a> a taktéž <a href="#08">v&nbsp;Rustu</a>, tedy v&nbsp;těch programovacích jazycích, jejichž niky se částečně překrývají s&nbsp;oblastí použití jazyka Go. Ve druhé části článku si pak ukážeme, jak je tento problém řešen v&nbsp;Go 1.18, které přineslo právě podporu generických typů &ndash; což byla mnohými vývojáři netrpělivě očekávaná novinka.</p>

<p><div class="rs-tip-major">Poznámka: zabývat se tedy nebudeme jazyky typu <a href="https://www.root.cz/n/python/">Python</a>, v&nbsp;nichž je použit <a href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a> a tedy zcela jiný přístup k&nbsp;práci s&nbsp;hodnotami a datovými strukturami.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Beztypové a jednoúčelové kontejnery</h2>

<p>V&nbsp;některých programovacích jazycích (a nejedná se pouze o dynamicky typované jazyky) se setkáme s&nbsp;takzvanými beztypovými popř.&nbsp;s&nbsp;jednoúčelovými kontejnery, kterými můžeme do jisté míry nahradit kontejnery s&nbsp;generickými typy. Typicky se jedná o implementace seznamů, front, zásobníků, různých typů stromů, obecných orientovaných i neorientovaných grafů atd. Beztypové kontejnery jsou většinou založeny na vlastnostech třídního OOP (dědění a polymorfismus) a většinou taktéž na tom, že hierarchie tříd mívá v&nbsp;mnoha jazycích společného předka. To tedy znamená, že pokud vytvoříme kontejner (řekněme seznam) pro prvky typu &bdquo;instance třídy na vrcholu hierarchie tříd&ldquo;, bude možné do takové třídy uložit jakýkoli objekt, ovšem za tu cenu, že se ztrácí informace o uloženém typu (tu je nutné získávat pro každý prvek zvlášť, pokud to jazyk díky <a href="https://en.wikipedia.org/wiki/Run-time_type_information">RTTI</a> umožňuje).</p>

<p><div class="rs-tip-major">Podobné řešení nabízela Java před verzí
5.</div></p>

<p>Naopak je mnohdy možné vytvořit takzvané jednoúčelové kontejnery. Ty dokážou ukládat prvky jediného typu popř.&nbsp;v&nbsp;OOP jazycích i odvozeného typu (potomci třídy). Popř.&nbsp;se může jednat o prvky implementující či splňující nějaké rozhraní. Typickým příkladem může být pole či řez v&nbsp;jazyku Go. Při použití jednoúčelových kontejnerů se informace o typu prvků neztratí a naopak je striktně kontrolována překladačem. Nevýhoda je ovšem zřejmá &ndash; pro každý datový typ je mnohdy nutné vytvořit prakticky stejný kontejner, jehož implementace se mnohdy odlišuje pouze v&nbsp;několika maličkostech.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Statická genericita</h2>

<p>Generické datové typy a generické funkce lze realizovat rozličnými způsoby.  Pokud samotný programovací jazyk genericitu nepodporuje, ovšem má rozumný makrosystém, lze použít (či spíše zneužít) právě tento makrosystém, kdy makra budou expandována na konkrétní datový typ (například komplexní číslo s&nbsp;položkami typu <strong>float</strong>), popř.&nbsp;na konkrétní funkci (s&nbsp;tím, že jméno funkce bude muset být nějakým způsobem unikátní). Jedná se ovšem o velmi křehké řešení &ndash; mnoho chybových hlášení bude používat expandovaný kód, který uživatel nenapsal atd.</p>

<p>V&nbsp;některých programovacích jazycích, například v&nbsp;Javě, se používá odlišný způsob, při němž se ve zdrojovém kódu konkrétní datový typ (vhodným způsobem) zapíše a překladač ho tedy zpracuje a použije pro případné typové kontroly. Ovšem interně &ndash; v&nbsp;generovaném kódu nebo bajtkódu &ndash; se použije nějaký obecný společný nadtyp, typicky třída <strong>Object</strong> (v&nbsp;závislosti na konkrétní hierarchii tříd a datových typů). Prakticky stejným způsobem je vyřešeno vytváření funkcí a metod z&nbsp;generických funkcí a metod.</p>

<p><div class="rs-tip-major">Poznámka: existuje ještě třetí možnost, a to přímo generování zdrojového kódu. S&nbsp;touto možností jsme se již seznámili v&nbsp;souvislosti s&nbsp;projektem <i>Genny</i>. Krátce: jedná se o tu nejhorší možnou variantu, a to z&nbsp;mnoha pohledů &ndash; </div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. </h2>



<p><a name="k05"></a></p>
<h2 id="k05">5. </h2>



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Go Data Structures: Binary Search Tree<br />
<a href="https://flaviocopes.com/golang-data-structure-binary-search-tree/">https://flaviocopes.com/golang-data-structure-binary-search-tree/</a>
</li>

<li>Gobs of data<br />
<a href="https://blog.golang.org/gobs-of-data">https://blog.golang.org/gobs-of-data</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

