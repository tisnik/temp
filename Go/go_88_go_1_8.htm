<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Dlouho očekávaná novinka v Go 1.8 - generické datové typy</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Dlouho očekávaná novinka v Go 1.8 - generické datové typy</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Mnohými vývojáři netrpělivě očekávanou vlastností jazyka Go jsou (resp. byly) generické funkce a generické datové typy. Návrhů na jejich začlenění do Go bylo několik a nakonec byl vybrán návrh, který se nakonec objevil v nedávno vydané stabilní verzi Go 1.8.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Dlouho očekávaná novinka v Go 1.8 &ndash; generické datové typy</a></p>
<p><a href="#k02">2. Beztypové a jednoúčelové kontejnery</a></p>
<p><a href="#k03">3. Statická a dynamická genericita</a></p>
<p><a href="#k04">4. Generické datové typy v&nbsp;Javě a Rustu</a></p>
<p><a href="#k05">5. Funkce s&nbsp;konkrétními datovými typy vs.&nbsp;s&nbsp;generickými typy</a></p>
<p><a href="#k06">6. Použití prázdných rozhraní, které splňuje jakýkoli datový typ</a></p>
<p><a href="#k07">7. Novinka v&nbsp;Go 1.18 &ndash; typové parametry</a></p>
<p><a href="#k08">8. Explicitní volání konkrétní varianty generické funkce</a></p>
<p><a href="#k09">9. Kontrola překladačem při explicitním volání konkrétní varianty generické funkce</a></p>
<p><a href="#k10">10. Datový systém jazyka Go a přetížené operátory</a></p>
<p><a href="#k11">11. Sada funkcí pro porovnání dvojice hodnot různých typů</a></p>
<p><a href="#k12">12. Jediná funkce pro porovnání dvojice hodnot různých typů</a></p>
<p><a href="#k13">13. Příprava generické funkce pro součet dvou hodnot</a></p>
<p><a href="#k14">14. Generická forma funkce <strong>add</strong></a></p>
<p><a href="#k15">15. Problematika odvozených datových typů</a></p>
<p><a href="#k16">16. Aproximace datového typu</a></p>
<p><a href="#k17">17. Překlad běžné funkce <strong>compare</strong> do assembleru</a></p>
<p><a href="#k18">18. Překlad funkce s&nbsp;typovými parametry do assembleru</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Dlouho očekávaná novinka v Go 1.8 &ndash; generické datové typy</h2>

<p>Již <a
href="https://www.root.cz/clanky/go-minimalisticky-a-prekvapive-vykonny-programovaci-jazyk/">v&nbsp;úvodní
části</a> <a href="https://www.root.cz/serialy/programovaci-jazyk-go/">seriálu
o programovacím jazyku Go</a> jsme si mj.&nbsp;řekli, že tento dnes dosti
populární programovací jazyk byl navržen takovým způsobem, že obsahuje
(resp.&nbsp;přesněji řečen původně obsahoval) pouze ty syntaktické a sémantické
prvky, na nichž se <a
href="https://www.informit.com/articles/article.aspx?p=1623555">shodli všichni
tři</a> původní autoři tohoto projektu. Všechny vlastnosti, u nichž nebylo na
sto procent jisté, že jsou správně navrženy a že jejich implementace nebude
zpomalovat překladač ani výsledný zkompilovaný a slinkovaný kód, nebyly do
první verze programovacího jazyka Go přidány. Týká se to některých vlastností,
které mohou programátorům chybět při řešení praktických úkolů &ndash; například
výjimek, tříd (a na třídách postavené větvi objektově orientovaného
programování) a taktéž generických datových typů a generických funkcí. A
zejména neexistence generických datových typů může být pro některé typy
aplikací značně omezující, protože je například složité implementovat obecné a
současně i typově bezpečné datové struktury typu graf, strom, zásobník, fronta
atd.</p>

<p>V&nbsp;dnešním článku se nejprve ve stručnosti seznámíme s&nbsp;tím, jakým
způsobem jsou generické datové typy implementovány například v&nbsp;Javě a
taktéž v&nbsp;Rustu, tedy v&nbsp;těch programovacích jazycích, jejichž niky se
částečně (ale skutečně jen částečně) překrývají s&nbsp;oblastí použití
programovacího jazyka Go. Ve druhé části článku si pak ukážeme, jak je tento
problém řešen v&nbsp;Go 1.18, které přineslo právě podporu generických typů
&ndash; což byla mnohými vývojáři netrpělivě očekávaná novinka (ta ovšem možná
poněkud paradoxně vede ke zesložitění překladače i velikosti výsledného kódu;
navíc není jednoduché takové funkce exportovat způsobem kompatibilním
s&nbsp;céčkem či dalšími programovacími jazyky).</p>

<p><div class="rs-tip-major">Poznámka: zabývat se tedy nebudeme jazyky typu <a
href="https://www.root.cz/n/python/">Python</a>, v&nbsp;nichž je použit <a
href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a> a tedy zcela
jiný přístup k&nbsp;práci s&nbsp;hodnotami a datovými strukturami.</div></p>

<p>Pro příklady omezení, které nám předchozí verze programovacího jazyka Go
v&nbsp;některých případech kladly, nemusíme chodit daleko. Připomeňme si
například články o frameworku Gonum, který do určité míry reflektuje možnosti
balíčku Numpy pro Python. Zatímco v&nbsp;Numpy lze pracovat s&nbsp;vektory a
maticemi, jejichž prvky jsou různých typů, v&nbsp;balíčcích Gonum je tomu jinak
&ndash; zde se primárně pracuje s&nbsp;prvky typu <strong>float64</strong>, a
to i v&nbsp;případech, kdy by z&nbsp;různých důvodů postačovalo použít prvky
<strong>float32</strong> nebo naopak <strong>complex64</strong>
popř.&nbsp;<strong>complex128</strong>.</p>

<p>Takto se pracuje s&nbsp;vektory, jejichž prvky jsou striktně omezeny na typ
<strong>float64</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "gonum.org/v1/gonum/mat"
)
&nbsp;
func <strong>main</strong>() {
        v1 := mat.NewVecDense(5, nil)
        v2 := mat.NewVecDense(5, []float64{1, 0, 2, 0, 3})
&nbsp;
        fmt.Printf("dot(v1, v1): %f\n", mat.Dot(v1, v1))
        fmt.Printf("dot(v1, v2): %f\n", mat.Dot(v1, v2))
        fmt.Printf("dot(v2, v2): %f\n", mat.Dot(v2, v2))
        fmt.Printf("max(v2):     %f\n", mat.Max(v2))
        fmt.Printf("min(v2):     %f\n", mat.Min(v2))
        fmt.Printf("sum(v2):     %f\n", mat.Sum(v2))
}
</pre>

<p>A takto s&nbsp;maticemi:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "gonum.org/v1/gonum/mat"
)
&nbsp;
func <strong>main</strong>() {
        d := mat.NewDiagDense(10, []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})
        fmt.Printf("Value:\n%v\n\n", mat.Formatted(d))
&nbsp;
        d.SetDiag(1, 100)
        fmt.Printf("Value:\n%v\n\n", mat.Formatted(d))
}
</pre>

<p><div class="rs-tip-major">Poznámka: nejedná se tedy o příliš elegantní
řešení.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Beztypové a jednoúčelové kontejnery</h2>

<p>V&nbsp;některých programovacích jazycích (a nejedná se v&nbsp;žádném případě
pouze o dynamicky typované jazyky) se setkáme s&nbsp;takzvanými beztypovými
popř.&nbsp;s&nbsp;jednoúčelovými kontejnery, kterými můžeme do jisté míry
nahradit kontejnery s&nbsp;generickými typy. Typicky se jedná o implementace
seznamů, front, zásobníků, různých typů stromů, obecných orientovaných i
neorientovaných grafů atd. Beztypové kontejnery jsou většinou založeny na
vlastnostech třídního OOP (dědění a polymorfismus) a většinou taktéž na tom, že
hierarchie tříd mívá v&nbsp;mnoha programovacích jazycích společného předka. To
tedy znamená, že pokud vytvoříme kontejner (řekněme seznam) pro prvky typu
&bdquo;instance třídy na vrcholu hierarchie tříd&ldquo;, bude možné do takové
třídy uložit jakýkoli objekt, ovšem za tu cenu, že se ztrácí informace o
uloženém typu (tu je nutné získávat pro každý prvek zvlášť, pokud to jazyk díky
<a href="https://en.wikipedia.org/wiki/Run-time_type_information">RTTI</a>
umožňuje &ndash; to ovšem není ani intuitivní, ani efektivní).</p>

<p><div class="rs-tip-major">Podobné řešení nabízela Java před verzí
5.</div></p>

<p>Naopak je mnohdy možné vytvořit takzvané <i>jednoúčelové kontejnery</i>. Ty
dokážou ukládat prvky jediného typu popř.&nbsp;v&nbsp;OOP jazycích i odvozeného
typu (potomci třídy). Popř.&nbsp;se může jednat o prvky implementující či
splňující nějaké rozhraní. Typickým příkladem může být pole či řez (slice)
v&nbsp;programovacím jazyku Go. Při použití jednoúčelových kontejnerů se
informace o typu prvků neztratí a naopak je striktně kontrolována překladačem.
Nevýhoda je ovšem zřejmá &ndash; pro každý datový typ je mnohdy nutné vytvořit
prakticky stejný kontejner, jehož implementace se mnohdy odlišuje pouze
v&nbsp;několika maličkostech.</p>

<p><div class="rs-tip-major">Poznámka: další nevýhodou je fakt, že se složitě
vytváří dostatečně dobře použitelné knihovny nad takovými kontejnery, tedy
knihovny s&nbsp;funkcemi, které by byly na jednu stranu obecné a na stranu
druhou dobře použitelné (ideálně bez nutnosti použití RTTI). Například <a
href="https://github.com/ssoroka/slice">tato užitečná knihovna</a> pro práci
s&nbsp;řezy v&nbsp;jazyku Go mohla vzniknout až po zavedení generických
datových typů. Taktéž knihovny srovnatelné s&nbsp;Numpy lze v&nbsp;Go
v&nbsp;plné síle vytvořit až s&nbsp;využitím generických typů.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Statická a dynamická genericita</h2>

<p>Generické datové typy a generické funkce lze realizovat rozličnými způsoby.
Pokud samotný programovací jazyk genericitu nepodporuje, ovšem má rozumný
makrosystém, lze použít (či možná spíše zneužít) právě tento makrosystém, kdy
makra budou expandována na konkrétní datový typ (například komplexní číslo
s&nbsp;položkami typu <strong>float</strong>), popř.&nbsp;na konkrétní funkci
(s&nbsp;tím, že jméno funkce bude muset být nějakým způsobem unikátní). Jedná
se ovšem o velmi křehké řešení &ndash; mnoho chybových hlášení bude používat
expandovaný kód, který uživatel nenapsal, totéž někdy platí o ladění atd.</p>

<p><div class="rs-tip-major">Poznámka: ideálně by se mělo jednat o makrosystém
manipulující s&nbsp;AST a nikoli na úrovni zdrojového kódu.</div></p>

<p>V&nbsp;některých programovacích jazycích, například v&nbsp;Javě, se používá
odlišný způsob, při němž se ve zdrojovém kódu konkrétní datový typ (vhodným
způsobem) zapíše a překladač ho tedy zpracuje a použije pro případné typové
kontroly. Ovšem interně &ndash; v&nbsp;generovaném kódu nebo (v&nbsp;případě
Javy) bajtkódu &ndash; se použije nějaký obecný společný nadtyp, typicky třída
<strong>Object</strong> (v&nbsp;závislosti na konkrétní hierarchii tříd a
datových typů). Prakticky stejným způsobem je vyřešeno vytváření funkcí a metod
z&nbsp;generických funkcí a metod.</p>

<p><div class="rs-tip-major">Poznámka: existuje ještě třetí možnost, a to přímo
generování zdrojového kódu. S&nbsp;touto možností jsme se již seznámili
v&nbsp;souvislosti s&nbsp;projektem <i>Genny</i>. Krátce: jedná se o tu
nejhorší možnou variantu, a to z&nbsp;mnoha pohledů. Po uvedení Go 1.18 je však
možné na existenci tohoto projektu zcela zapomenout :-)</div></p>

<p>V&nbsp;případě, že překladač programovacího jazyka vytváří kód běžící ve
virtuálním stroji, je možné generické datové typy popř.&nbsp;i generické funkce
a metody vytvářet právě virtuálním strojem, a to přímo za běhu aplikace. Toto
řešení má některé výhody (vytvoří se pouze tolik variant, kolik je skutečně
zapotřebí), ovšem samozřejmě za tuto možnost zaplatíme pomalejším během a
mnohdy i většími paměťovými nároky.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Generické datové typy v&nbsp;Javě a Rustu</h2>

<p><div class="rs-tip-major">Poznámka: pokud vás zajímají jen nové vlastnosti
Go, můžete <a href="#k05">přeskočit na navazující kapitolu</a>.</div></p>

<p>Nejprve se alespoň ve stručnosti podívejme na způsob použití generických
datových typů v&nbsp;programovacím jazyku Java. Uvedeme si jeden
z&nbsp;nejtypičtějších motivačních příkladů, na němž se například
v&nbsp;učebnicích ukazují výhody generických datových typů v&nbsp;silně
typovaných programovacích jazycích. V&nbsp;příkladu je vytvořen obecný seznam
(jehož konkrétní implementace je založena na sekvenci prvků uložených
v&nbsp;poli). Do tohoto seznamu můžeme vkládat libovolné objekty, přesněji
řečeno instance jakékoli třídy. Proč tomu tak je? Seznam je kontejnerem pro
objekty typu <strong>Object</strong> a právě třída <strong>Object</strong> leží
na vrcholu hierarchie všech tříd Javy (jedná se o stromovou strukturu
s&nbsp;jediným kořenem). Platí zde tedy jeden z&nbsp;principů třídního OOP
&ndash; potomek může nahradit předka. Ve zdrojovém kódu vidíme, že do seznamu
lze vložit i celé číslo, ovšem v&nbsp;tomto případě je interně použit takzvaný
<i>boxing</i>, v&nbsp;němž je numerická hodnota nahrazena objektem, zde
konkrétně instancí třídy <strong>Integer</strong>:</p>

<pre>
import java.util.List;
import java.util.ArrayList;
import java.awt.Color;
&nbsp;
public class <strong>Test1</strong> {
    public static void <strong>main</strong>(String[] args) {
        List l = new ArrayList();
        l.add(new Object());
        l.add("foobar");
        l.add(42);
        l.add(Color.green);
&nbsp;
        for (Object i : l) {
            System.out.println(i);
        }
    }
}
</pre>

<p>Výše uvedené řešení má mnoho nevýhod. Překladač (nikoli ovšem runtime)
ztrácí informace o tom, jaké typy objektů jsou vlastně v&nbsp;seznamu uloženy.
Proto například není možné přeložit následující program, a to přesto, že
sémanticky je zdánlivě v&nbsp;pořádku &ndash; do seznamu jsme uložili pouze
řetězce, takže by mělo být možné volat pro všechny prvky seznamu metodu
<strong>length()</strong>. Ovšem z&nbsp;pohledu překladače jsou všechny prvky
(netypového) seznamu typu <strong>Object</strong>, takže to přímo možné
není:</p>

<pre>
import java.util.List;
import java.util.ArrayList;
import java.awt.Color;
&nbsp;
public class <strong>Test2</strong> {
    public static void <strong>main</strong>(String[] args) {
        List l = new ArrayList();
        l.add("foo");
        l.add("bar");
        l.add("baz");
&nbsp;
        String s = l.get(0);
        System.out.println(s.length());
    }
}
</pre>

<p>Výsledek pokusu o překlad dopadne neslavně:</p>

<pre>
Test2.java:8: warning: [unchecked] unchecked call to add(E) as a member of the raw type List
        l.add("foo");
             ^
  where E is a type-variable:
    E extends Object declared in interface List
Test2.java:9: warning: [unchecked] unchecked call to add(E) as a member of the raw type List
        l.add("bar");
             ^
  where E is a type-variable:
    E extends Object declared in interface List
Test2.java:10: warning: [unchecked] unchecked call to add(E) as a member of the raw type List
        l.add("baz");
             ^
  where E is a type-variable:
    E extends Object declared in interface List
Test2.java:12: error: incompatible types
        String s = l.get(0);
                        ^
  required: String
  found:    Object
1 error
3 warnings
</pre>

<p>V&nbsp;Javě se navíc setkáme s&nbsp;takzvaným <i>type erasure</i>. Jedná se
o odstranění informace o generickém typu překladačem při vytváření bajtkódu. To
má několik důsledků &ndash; striktní typová kontrola je prováděna v&nbsp;době
překladu (<i>compile time</i>), ovšem typová informace (například o typu prvků
kontejneru) je v&nbsp;čase běhu (<i>runtime</i>) ztracena.</p>

<pre>
import java.util.Collection;
import java.util.ArrayList;
import java.awt.Color;
&nbsp;
public class <strong>Test6</strong> {
    public static void main(String[] args) {
        Collection&lt;String&gt; l1 = new ArrayList&lt;String&gt;();
        Collection&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;();
&nbsp;
        System.out.println(l1.getClass().getName());
        System.out.println(l2.getClass().getName());
&nbsp;
        System.out.println(l1.getClass() == l2.getClass());
    }
}
</pre>

<p>Po spuštění tohoto demonstračního příkladu získáme dvakrát stejné jméno
třídy. Na posledním řádku je patrné, že jsou třídy (z&nbsp;pohledu virtuálního
stroje v&nbsp;Runtime) skutečně shodné:</p>

<pre>
java.util.ArrayList
java.util.ArrayList
true
</pre>

<p>Generické datové typy jsou podporovány i dalším (i když mnohdy nepřímým)
konkurentem Go &ndash; programovacím jazykem Rust. Generické typy v&nbsp;Rustu
mohou při správném použití zjednodušit tvorbu znovupoužitelného programového
kódu a současně zajistit silnou typovou kontrolu při překladu (což jsou bez
použití generických typů mnohdy současně nesplnitelné požadavky).</p>

<p>Programovací jazyk Rust například podporuje definici struktury představující
komplexní čísla, přičemž typy složek jsou generické (znak <strong>T</strong>
není klíčovým slovem, ovšem je v&nbsp;kontextu generických datových typů často
používán, takže tento úzus taktéž dodržíme):</p>

<pre>
struct <strong>Complex&lt;T&gt;</strong> {
    real: <strong>T</strong>,
    imag: <strong>T</strong>,
}
</pre>

<p>Tento zápis znamená, že se za <strong>T</strong> při překladu doplní
konkrétní rozpoznaný datový typ, což si ostatně můžeme snadno vyzkoušet:</p>

<pre>
fn <strong>main</strong>() {
    let c1 = Complex{real:10, imag:20};
    let c2 = Complex{real:10.1, imag:20.1};
    let c3 = Complex{real:10.2f64, imag:20.2f64};
    let c4 = Complex{real:true, imag:false};
&nbsp;
    println!("{}+{}i", c1.real, c1.imag);
    println!("{}+{}i", c2.real, c2.imag);
    println!("{}+{}i", c3.real, c3.imag);
    println!("{}+{}i", c4.real, c4.imag);
}
</pre>

<p>V&nbsp;programovacím jazyku Rust je možné kromě deklarace generických
datových typů vytvářet i generické funkce, tj.&nbsp;funkce, u nichž lze
specifikovat parametrizovatelné typy argumentů i návratový typ. Podívejme se
nyní na sice poněkud umělý, ale o to kratší demonstrační příklad. V&nbsp;tomto
příkladu nejprve deklarujeme výčtový typ a následně funkci, která akceptuje dva
parametry typu <strong>i32</strong> (celé číslo se znaménkem) a třetí parametr,
na základě jehož hodnoty funkce vrátí buď první či druhý parametr. Nejprve si
povšimněte, jak se používá výčtový typ (má vlastní jmenný prostor, proto se
zapisuje stylem <strong>Item::First</strong> a nikoli pouze
<strong>First</strong>). Použití konstrukce <strong>match</strong> je
v&nbsp;tomto případě idiomatické a mnohem lepší, než pokus o použití
<strong>if</strong>, a to z&nbsp;toho důvodu, že překladač sám zkontroluje, zda
v&nbsp;konstrukci <strong>match</strong> korektně reagujeme na všechny možné
vstupy (což samozřejmě děláme :-):</p>

<pre>
enum <strong>Item</strong> {
    First,
    Second,
}
&nbsp;
fn <strong>select_item</strong>(first_item:i32, second_item:i32, item:Item) -&gt; i32 {
    match item {
        Item::First  =&gt; first_item,
        Item::Second =&gt; second_item,
    }
}
&nbsp;
fn <strong>main</strong>() {
    let x = 10;
    let y = 20;
    println!("1st item = {}", select_item(x, y, Item::First));
    println!("2nd item = {}", select_item(x, y, Item::Second));
    
}
</pre>

<p>Funkce <strong>select_item</strong> v&nbsp;podobě, v&nbsp;jaké jsme si ji
ukázali, není příliš použitelná ani obecná, protože ji ve skutečnosti lze volat
pouze s&nbsp;parametry typu <strong>i32</strong>. Pokusme se tedy vytvořit
podobnou funkci, ovšem generickou. V&nbsp;tomto případě to znamená, že typy
prvních dvou parametrů musí být shodné a musí odpovídat návratovému typu funkce
&ndash; ta totiž nemá provádět žádné konverze, pouze vybírat mezi prvním a
druhým argumentem. Takto navržená generická funkce může vypadat následovně
(povšimněte si především zápisu &lt;T&gt; za jménem funkce):</p>

<pre>
fn <strong>select_item&lt;T&gt;</strong>(first_item:<strong>T</strong>, second_item:<strong>T</strong>, item:Item) -&gt; <strong>T</strong> {
    match item {
        Item::First  =&gt; first_item,
        Item::Second =&gt; second_item,
    }
}
</pre>

<p><div class="rs-tip-major">Poznámka: s&nbsp;oběma koncepty, tedy jak
s&nbsp;generickými funkcemi, tak i s&nbsp;generickými datovými typy, se setkáme
v&nbsp;jazyku Go a tím pádem i v&nbsp;navazujícím textu.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Funkce s&nbsp;konkrétními datovými typy vs.&nbsp;s&nbsp;generickými typy</h2>

<p>Abychom pochopili, v&nbsp;jakých situacích může být použití generických
funkcí a generických datových typů užitečné, je vhodné si nejdříve
zrekapitulovat základní vlastnosti funkcí v&nbsp;programovacím jazyku Go
z&nbsp;pohledu typového systému tohoto jazyka. Pokud se nejedná o generickou
funkci, je funkce kromě svého jména jednoznačně určena i počtem, pořadím a
typem parametrů. Jméno funkce v&nbsp;daném balíčku musí být unikátní. To
mj.&nbsp;znamená, že taková funkce se přeloží do strojového kódu v&nbsp;jediné
variantě:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
func <strong>printValue</strong>(value string) {
        fmt.Println(value)
}
&nbsp;
func <strong>main</strong>() {
        printValue("www.root.cz")
}
</pre>

<p>Funkce není možné přetěžovat (na rozdíl od mnoha dalších jazyků typu C++ či
Javy):</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
func <strong>printValue</strong>(value string) {
        fmt.Println(value)
}
&nbsp;
func <strong>printValue</strong>(int string) {
        fmt.Println(value)
}
&nbsp;
func <strong>main</strong>() {
        printValue("www.root.cz")
}
</pre>

<p>Takový kód nelze přeložit:</p>

<pre>
./02_print_overload.go:9:6: printValue redeclared in this block
        ./02_print_overload.go:5:6: other declaration of printValue
./02_print_overload.go:10:14: undefined: value
</pre>

<p>A navíc je typový systém Go velmi striktní s&nbsp;ohledem na odvozené typy
&ndash; hodnota odvozeného typu není automaticky konvertována na původní
(bázový) typ. Ani následující kód tedy není korektní:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
type <strong>Value</strong> string
&nbsp;
func <strong>printValue</strong>(value Value) {
        fmt.Println(value)
}
&nbsp;
func <strong>main</strong>() {
        v := "www.root.cz" <i>// string</i>
        printValue(v)
}
</pre>

<p>Tento kód opět nelze přeložit:</p>

<pre>
./03_print_no_conversion.go:13:13: cannot use v (variable of type string) as type Value in argument to printValue
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Použití prázdných rozhraní, které splňuje jakýkoli datový typ</h2>

<p>V&nbsp;některých situacích je možné vytvořit prakticky použitelnou funkci,
která akceptuje parametr či parametry typu <strong>interface{}</strong>.
V&nbsp;jazyce Go každý datový typ uspokojuje (<i>satisfy</i>) toto rozhraní, a
to z&nbsp;toho prostého důvodu, že implementuje všechny metody předepsané
v&nbsp;tomto rozhraní &ndash; žádné takové metody ve skutečnosti neexistují,
takže je jejich implementace prostá všech programátorských chyb a výsledný kód
je velmi efektivní :-):</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
func <strong>printValue</strong>(value interface{}) {
        fmt.Println(value)
}
&nbsp;
func <strong>main</strong>() {
        printValue("www.root.cz")
        printValue('*')
        printValue(42)
        printValue(3.14)
        printValue(1 + 2i)
        printValue([]int{1, 2, 3})
}
</pre>

<p>V&nbsp;praxi je však mnohdy nutné uvnitř takové funkce kontrolovat skutečný
typ parametru. A možná ještě horší je nemožnost rozumným způsobem zapsat funkci
typu:</p>

<pre>
func <strong>add</strong>(x, y interface{}) interface{} {
}
</pre>

<p>a očekávat, že pokud se funkce zavolá například s&nbsp;parametry typu
<strong>int</strong>, odvodí si překladač, že výsledkem bude taktéž hodnota
typu <strong>int</strong>.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Novinka v&nbsp;Go 1.18 &ndash; typové parametry</h2>

<p>Do programovacího jazyka Go verze 1.18 byla přidána podpora pro takzvané
<i>typové parametry</i>, s&nbsp;jejichž využitím lze realizovat generické
funkce. Začneme tím nejjednodušším příkladem, konkrétně definicí funkce
akceptující hodnotu jakéhokoli typu. Informace o tomto typu je zapsána právě
formou typového parametru &ndash; viz první podtrženou část definice. A tento
typ je posléze použit pro určení typu parametru funkce (druhá podtržená část
kódu):</p>

<pre>
func <strong>printValue</strong><u>[T any]</u>(value <u>T</u>) {
        fmt.Println(value)
}
</pre>

<p><div class="rs-tip-major">Poznámka: &bdquo;any&ldquo; se ve Scale nazývá
&bdquo;top type&ldquo;, zatímco jeho přesný opak &bdquo;nothing&ldquo; je
&bdquo;bottom type&ldquo;. Všechny další datové typy leží mezi těmito dvěma
extrémy (v&nbsp;Go se takové označení prozatím pravděpodobně
neujalo).</div></p>

<p>Vraťme se však k&nbsp;upravené definici funkce <strong>printValue</strong>.
Tu lze volat s&nbsp;parametrem jakéhokoli typu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
func <strong>printValue</strong><u>[T any]</u>(value <u>T</u>) {
        fmt.Println(value)
}
&nbsp;
func <strong>main</strong>() {
        printValue("www.root.cz")
        printValue('*')
        printValue(42)
        printValue(3.14)
        printValue(1 + 2i)
        printValue([]int{1, 2, 3})
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Explicitní volání konkrétní varianty generické funkce</h2>

<p>Při volání funkce je možné si zvolit, jakou variantu generické funkce chceme
volat. Interně totiž (což si ukážeme dále) překladač vygeneruje strojový kód
pro všechny použité varianty). Výběr konkrétní varianty volaného kódu se
provádí opět s&nbsp;využitím hranatých závorek, tentokrát ovšem při volání
funkce:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
func <strong>printValue</strong><u>[T any]</u>(value <u>T</u>) {
        fmt.Println(value)
}
&nbsp;
func <strong>main</strong>() {
        printValue<u>[string]</u>("www.root.cz")
        printValue<u>[rune]</u>('*')
        printValue<u>[int]</u>(42)
        printValue<u>[float32]</u>(3.14)
        printValue<u>[complex64]</u>(1 + 2i)
        printValue<u>[[]int]</u>([]int{1, 2, 3})
}
</pre>

<p><div class="rs-tip-major">Poznámka: na posledním řádku jsou hranaté závorky
použity ve dvou různých významech &ndash; pro určení varianty generické funkce
a pro určení, že se má použít varianta akceptující řez prvků typu
<strong>int</strong>.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Kontrola překladačem při explicitním volání konkrétní varianty generické funkce</h2>

<p>Explicitní výběr zavolání konkrétní varianty generické funkce je sice zcela
ponechán na vůli vývojáře, ovšem skutečné typy parametrů musí zvolené variantě
odpovídat, což kontroluje překladač (nikoli runtime):</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
func <strong>printValue</strong>[T any](value T) {
        fmt.Println(value)
}
&nbsp;
func <strong>main</strong>() {
        printValue<u>[int]</u>("www.root.cz")
        printValue<u>[[]string]</u>('*')
        printValue<u>[string]</u>(42)
        printValue<u>[int]</u>(3.14)
        printValue<u>[byte]</u>(1 + 2i)
        printValue<u>[[]byte]</u>([]int{1, 2, 3})
}
</pre>

<p>Nyní ovšem překladač vypíše mnoho chyb, protože se snažíme volat konkrétní
variantu generické funkce, ovšem s&nbsp;nesprávnými typy parametrů:</p>

<pre>
./05_type_parameter_check.go:10:18: cannot use "www.root.cz" (untyped string constant) as int value in argument to printValue[int]
./05_type_parameter_check.go:11:23: cannot use '*' (untyped rune constant 42) as []string value in argument to printValue[[]string]
./05_type_parameter_check.go:12:21: cannot use 42 (untyped int constant) as string value in argument to printValue[string]
./05_type_parameter_check.go:13:18: cannot use 3.14 (untyped float constant) as int value in argument to printValue[int] (truncated)
./05_type_parameter_check.go:14:19: cannot use 1 + 2i (untyped complex constant (1 + 2i)) as byte value in argument to printValue[byte] (truncated)
./05_type_parameter_check.go:15:21: cannot use []int{…} (value of type []int) as type []byte in argument to printValue[[]byte]
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Datový systém jazyka Go a přetížené operátory</h2>

<p>Jeden z&nbsp;problémů řešitelných generickými funkcemi a generickými
datovými typy spočívá v&nbsp;zápisu funkcí, v&nbsp;nichž je použit nějaký
přetížený operátor. Příkladem přetíženého operátoru je operátor &lt;, který lze
použít pro porovnání celých čísel, čísel s&nbsp;plovoucí řádovou čárkou,
komplexních čísel či dokonce řetězců. Příkladem použití může být porovnání dvou
celých čísel v&nbsp;uživatelem definované funkci nazvané (nepříliš nápaditě a
korektně) <strong>compare</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
func <strong>compare</strong>(x int, y int) bool {
        return x &lt; y
}
&nbsp;
func <strong>main</strong>() {
        fmt.Println(compare(1, 2))
}
</pre>

<p>V&nbsp;navazujících dvou kapitolách si ukážeme, jak lze tuto funkci zobecnit
tak, aby dokázala například porovnat dva řetězce.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Sada funkcí pro porovnání dvojice hodnot různých typů</h2>

<p>Jeden ze způsobů zobecnění funkce <strong>compare</strong> spočívá
v&nbsp;reimplementaci toho samého algoritmu pro každý podporovaný datový typ.
Každou z&nbsp;variant funkce je přitom nutné jednoznačně pojmenovat.
V&nbsp;žádném případě se nejedná o elegantní řešení, ovšem je ho možné využít i
ve starších verzích programovacího jazyka Go:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
func <strong>compareInts</strong>(x int, y int) bool {
        return x &lt; y
}
&nbsp;
func <strong>compareFloats</strong>(x float64, y float64) bool {
        return x &lt; y
}
&nbsp;
func <strong>compareStrings</strong>(x string, y string) bool {
        return x &lt; y
}
&nbsp;
func <strong>main</strong>() {
        fmt.Println(compareInts(1, 2))
        fmt.Println(compareFloats(1.5, 2.6))
        fmt.Println(compareStrings("foo", "bar"))
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Jediná funkce pro porovnání dvojice hodnot různých typů</h2>

<p>S&nbsp;využitím generických datových typů a současně i typových parametrů
můžeme deklarovat jedinou funkci, která bude korektně porovnávat dvojici
hodnot, přičemž typy těchto hodnot si sami zvolíme. Nejdříve musíme definovat
množinu typů obou parametrů funkce<strong>compare</strong>. Tuto množinu
nazveme například <strong>comparable</strong>. Zápis (syntaxe) je novinkou:</p>

<pre>
type <strong>comparable</strong> interface {
        int | float64 | string
}
</pre>

<p>Tímto zápisem jsme si usnadnili zápis hlavičky funkce
<strong>compare</strong>, která bude vypadat následovně:</p>

<pre>
func <strong>compare</strong><u>[T comparable]</u>(x T, y T) bool {
        return x &lt; y
}
</pre>

<p>Takový zápis určuje, že oba parametry musí být stejného typu, ovšem tento
typ může být při konkrétním volání funkce <strong>int</strong>,
<strong>float64</strong> nebo <strong>string</strong>. Překladač navíc
(pochopitelně) zkontroluje, zda je možné operátor &lt; použít pro každou
kombinaci typů parametrů.</p>

<p>Příklad praktického (a zcela korektního) použití této funkce:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
type <strong>comparable</strong> interface {
        int | float64 | string
}
&nbsp;
func <strong>compare</strong><u>[T comparable]</u>(x T, y T) bool {
        return x &lt; y
}
&nbsp;
func <strong>main</strong>() {
        fmt.Println(compare(1, 2))
        fmt.Println(compare(1.5, 2.6))
        fmt.Println(compare("foo", "bar"))
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Příprava generické funkce pro součet dvou hodnot</h2>

<p>Před vydáním programovacího jazyka Go verze 1.18 nebyly generické datové
typy ani generické funkce v&nbsp;programovacím jazyce Go přímo podporovány.
Zkusme se tedy nyní podívat, jaké další problémy neexistence generických typů
může přinášet (resp.&nbsp;přesněji řečeno <i>mohla</i> přinášet a mnohdy i
přinášela). Začněme zcela jednoduchou funkcí určenou pro součet dvou celých
čísel. Tu lze zapsat a zavolat takto:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
func <strong>add</strong>(x int, y int) int {
        return x + y
}
&nbsp;
func <strong>main</strong>() {
        fmt.Println(add(1, 2))
}
</pre>

<p>Pokud budeme chtít tuto funkci zobecnit, aby sečetla numerické hodnoty
libovolného typu a vrátila typově správný výsledek, poměrně (pokud nepoužijeme
generické typy) brzy narazíme. Už jen z&nbsp;toho důvodu, že funkce (jejich
názvy) nelze v&nbsp;Go přetěžovat, takže v&nbsp;jednom modulu nemůžeme vytvořit
funkci stejného jména, pouze s&nbsp;jinými typy parametrů a návratové hodnoty.
Tuto funkci již tedy nebude možné do stejného modulu přidat:</p>

<pre>
func <strong>add</strong>(x float32, y float32) float32 {
    return x + y
}
</pre>

<p>Toto chování programovacího jazyka Go si ostatně můžeme velmi snadno
otestovat, a to konkrétně na následujícím příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
func <strong>add</strong>(x int, y int) int {
        return x + y
}
&nbsp;
func <strong>add</strong>(x float32, y float32) float32 {
        return x + y
}
&nbsp;
func <strong>main</strong>() {
        fmt.Println(add(1, 2))
        fmt.Println(add(1.1, 2.2))
}
</pre>

<p>Pokus o překlad tohoto demonstračního příkladu skončí s&nbsp;chybou:</p>

<pre>
$ <strong>go build add2.go </strong>
&nbsp;
# command-line-arguments
./add2.go:9:6: add redeclared in this block
        previous declaration at ./add2.go:5:24
</pre>

<p><div class="rs-tip-major">Poznámka: na druhou stranu lze toto omezení
chápat. To, že funkce lze přetěžovat (například v&nbsp;C++) přináší i mnohé
problémy související mj.&nbsp;se jmény funkcí (<a
href="https://en.wikipedia.org/wiki/Name_mangling#C++">Name mangling</a>) a tím
pádem i s&nbsp;podporou takových funkcí a metod v&nbsp;IDE, debuggerech apod.
To stejné lze říci i o generických datových typech, pokud se jejich jména
exportují (ještě jinými slovy &ndash; jazyk C a jeho zvyklosti tady s&nbsp;námi
bude ještě hodně dlouho a bude nepřímo ovlivňovat i další programovací
jazyky).</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Generická forma funkce <strong>add</strong></h2>

<p>Přechod od jediné konkrétní implementace funkce <strong>add</strong> ke
generické implementaci již nebude složitý. Některé přípravné kroky jsme ostatně
udělali v&nbsp;rámci předchozích kapitol. Nejprve tedy budeme definovat novou
množinu typů, která bude určovat povolený typ parametrů nově vznikající
funkce:</p>

<pre>
type <strong>numeric</strong> interface {
        int | float64 | complex128
}
</pre>

<p>Následně napíšeme funkci, která bude akceptovat dva parametry typu
<strong>int/float64/complex128</strong> a vracet bude hodnotu stejného typu
&ndash; oba parametry tedy musí (pro dané volání funkce) být současně typu
<strong>int</strong> nebo současně typu <strong>float64</strong> atd. &ndash; a
totéž platí pro výsledek:</p>

<pre>
func <strong>add</strong><u>[T numeric]</u>(x T, y T) T {
        return x + y
}
</pre>

<p>Takové funkci již můžeme předat různé parametry:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
type <strong>numeric</strong> interface {
        int | float64 | complex128
}
&nbsp;
func <strong>add</strong><u>[T numeric]</u>(x T, y T) T {
        return x + y
}
&nbsp;
func <strong>main</strong>() {
        fmt.Println(add(1, 2))
        fmt.Println(add(1.5, 2.6))
        fmt.Println(add(1i, 2+4i))
}
</pre>

<p><div class="rs-tip-major">Poznámka: rozšíření funkce je možné například i
pro typ <strong>string</strong>, který rovněž podporuje operátor
<strong>+</strong>.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Problematika odvozených datových typů</h2>

<p>Výše uvedená funkce je sice generická a bude pracovat korektně pro parametry
typu <strong>int</strong>, <strong>float64</strong> nebo
<strong>complex128</strong>, ovšem již <a href="#k05">z&nbsp;páté kapitoly</a>
víme, že následující zápis je nekorektní, protože typ <strong>Value</strong> je
sice odvozený od typu <strong>string</strong>, ale konverze se neprovádí
automaticky (což je mimochodem jedna z&nbsp;nejlepších praktických vlastností
jazyka Go):</p>

<pre>
type <strong>Value</strong> string
&nbsp;
func <strong>printValue</strong>(value Value) {
        fmt.Println(value)
}
&nbsp;
func <strong>main</strong>() {
        v := "www.root.cz" <i>// string</i>
        printValue(v)
}
</pre>

<p>Totéž bude platit i pro naši generickou funkci, která z&nbsp;tohoto pohledu
není až tak generická, jak by to bylo možné:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
type <strong>numeric</strong> interface {
        int | float64 | complex128
}
&nbsp;
func <strong>add</strong><u>[T numeric]</u>(x T, y T) T {
        return x + y
}
&nbsp;
type <strong>myInt</strong> int
&nbsp;
type <strong>myFloat</strong> float64
&nbsp;
type <strong>myComplex</strong> complex128
&nbsp;
func <strong>main</strong>() {
        var x myInt = 42
        var y myFloat = 3.14
        var z myComplex = 1 + 2i
&nbsp;
        fmt.Println(add(x, x))
        fmt.Println(add(y, y))
        fmt.Println(add(z, z))
}
</pre>

<p>Funkci není možné volat s&nbsp;parametry typu <strong>myInt</strong>
atd.:</p>

<pre>
./13_add_type_parameters.go:24:17: myInt does not implement numeric (possibly missing ~ for int in constraint numeric)
./13_add_type_parameters.go:25:17: myFloat does not implement numeric (possibly missing ~ for float64 in constraint numeric)
./13_add_type_parameters.go:26:17: myComplex does not implement numeric (possibly missing ~ for complex128 in constraint numeric)
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Aproximace datového typu</h2>

<p>Řešení předchozího problému je v&nbsp;Go 1.18 řešeno novou syntaxí a
sémantikou při deklaraci množiny datových typů. Pokud namísto:</p>

<pre>
type <strong>numeric</strong> interface {
        int | float64 | complex128
}
</pre>

<p>napíšeme:</p>

<pre>
type <strong>numeric</strong> interface {
        ~int | ~float64 | ~complex128
}
</pre>

<p>určujeme tímto zápisem, že <strong>numeric</strong> bude odpovídat nejenom
explicitně zapsaným typům, ale i odvozeným typům, tedy například našemu typu
<strong>myInt</strong> atd.</p>

<p>Můžeme si to ostatně velmi snadno otestovat:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
type <strong>numeric</strong> interface {
        ~int | ~float64 | ~complex128
}
&nbsp;
func <strong>add</strong>[T numeric](x T, y T) T {
        return x + y
}
&nbsp;
type <strong>myInt</strong> int
&nbsp;
type <strong>myFloat</strong> float64
&nbsp;
type <strong>myComplex</strong> complex128
&nbsp;
func <strong>main</strong>() {
        var x myInt = 42
        var y myFloat = 3.14
        var z myComplex = 1 + 2i
&nbsp;
        fmt.Println(add(x, x))
        fmt.Println(add(y, y))
        fmt.Println(add(z, z))
}
</pre>

<p>Tento kód již bude bez problémů přeložitelný.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Překlad běžné funkce <strong>compare</strong> do assembleru</h2>

<p>Prozatím jsme si ukázali, jakým způsobem lze s&nbsp;generickými funkcemi a
generickými datovými typy pracovat na úrovni programovacího jazyka Go. Poměrně
užitečné je však zjistit, jak se například přeloží generické funkce z&nbsp;Go
do strojového kódu. Nejprve se ve stručnosti seznámíme s&nbsp;poněkud zvláštním
zápisem kódu přeloženého do assembleru (assembler je pro Go specifický a
odlišný například od GNU Assembleru, nicméně alespoň základní struktura by měla
být poměrně dobře rozpoznatelná). Překládat budeme (prozatím) jednoduchou
negenerickou funkcí <strong>compare</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
func <strong>compare</strong>(x int, y int) bool {
        return x &lt; y
}
&nbsp;
func <strong>main</strong>() {
        fmt.Println(compare(1, 2))
}
</pre>

<p>Překlad do assembleru provedeme tímto příkazem:</p>

<pre>
$ <strong>go tool compile -S 06_comparable.go &gt; 06_comparable.s</strong>
</pre>

<p>Výsledkem bude soubor nazvaný &bdquo;06_comparable.s&ldquo;, v&nbsp;němž lze
nalézt i přeloženou funkci <strong>compare</strong>. Z&nbsp;výpisu by mělo být
patrné, že funkce byla přeložena do tří instrukcí (poslední tři řádky) &ndash;
porovnání parametrů, nastavení výstupního registru <strong>AL</strong> na
základě výsledku porovnání a výskok (návrat) z&nbsp;funkce
(resp.&nbsp;v&nbsp;žargonu assembleru návrat ze subrutiny):</p>

<pre>
<strong>"".compare STEXT nosplit size=7 args=0x10 locals=0x0 funcid=0x0 align=0x0</strong>
        0x0000 00000 (06_comparable.go:5)       TEXT    "".compare(SB), NOSPLIT|ABIInternal, $0-16
        0x0000 00000 (06_comparable.go:5)       FUNCDATA        $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (06_comparable.go:5)       FUNCDATA        $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (06_comparable.go:5)       FUNCDATA        $5, "".compare.arginfo1(SB)
        0x0000 00000 (06_comparable.go:5)       FUNCDATA        $6, "".compare.argliveinfo(SB)
        0x0000 00000 (06_comparable.go:5)       PCDATA  $3, $1
        0x0000 00000 (06_comparable.go:6)       CMPQ    BX, AX
        0x0003 00003 (06_comparable.go:6)       SETGT   AL
        0x0006 00006 (06_comparable.go:6)       RET
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Překlad funkce s&nbsp;typovými parametry do assembleru</h2>

<p>Nyní se ovšem podívejme na to, jakým způsobem bude přeložena generická
varianta funkce <strong>compare</strong>, konkrétně varianta akceptující tři
různé typy parametrů:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
type <strong>comparable</strong> interface {
        int | float64 | string
}
&nbsp;
func <strong>compare</strong><u>[T comparable]</u>(x T, y T) bool {
        return x &lt; y
}
&nbsp;
func <strong>main</strong>() {
        fmt.Println(compare(1, 2))
        fmt.Println(compare(1.5, 2.6))
        fmt.Println(compare("foo", "bar"))
}
</pre>

<p>Opět provedeme překlad:</p>

<pre>
$ <strong>go tool compile -S 08_compare_type_parameters.go > 08_compare_type_parameters.s</strong>
</pre>

<p>Ve výsledném souboru &bdquo;08_compare_type_parameters.s&ldquo; nyní
nalezneme nikoli jedinou přeloženou funkci <strong>compare</strong>, ale hned
<i>tři varianty</i>. Strojový kód prvních dvou variant je dobře čitelný, u
varianty třetí je to sice složitější, ale minimálně volání funkce
<strong>runtime.cmpstring</strong> (která lexikograficky porovná řetězce) je
možné rozeznat:</p>

<pre>
<strong>"".compare[go.shape.int_0] STEXT dupok nosplit size=7 args=0x18 locals=0x0 funcid=0x0 align=0x0</strong>
        0x0000 00000 (08_compare_type_parameters.go:9)  TEXT    "".compare[go.shape.int_0](SB), DUPOK|NOSPLIT|ABIInternal, $0-24
        0x0000 00000 (08_compare_type_parameters.go:9)  FUNCDATA        $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (08_compare_type_parameters.go:9)  FUNCDATA        $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (08_compare_type_parameters.go:9)  FUNCDATA        $5, "".compare[go.shape.int_0].arginfo1(SB)
        0x0000 00000 (08_compare_type_parameters.go:9)  FUNCDATA        $6, "".compare[go.shape.int_0].argliveinfo(SB)
        0x0000 00000 (08_compare_type_parameters.go:9)  PCDATA  $3, $1
        0x0000 00000 (08_compare_type_parameters.go:10) CMPQ    CX, BX
        0x0003 00003 (08_compare_type_parameters.go:10) SETGT   AL
        0x0006 00006 (08_compare_type_parameters.go:10) RET
        0x0000 48 39 d9 0f 9f c0 c3                             H9.....
&nbsp;
<strong>"".compare[go.shape.float64_0] STEXT dupok nosplit size=8 args=0x18 locals=0x0 funcid=0x0 align=0x0</strong>
        0x0000 00000 (08_compare_type_parameters.go:9)  TEXT    "".compare[go.shape.float64_0](SB), DUPOK|NOSPLIT|ABIInternal, $0-24
        0x0000 00000 (08_compare_type_parameters.go:9)  FUNCDATA        $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (08_compare_type_parameters.go:9)  FUNCDATA        $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (08_compare_type_parameters.go:9)  FUNCDATA        $5, "".compare[go.shape.float64_0].arginfo1(SB)
        0x0000 00000 (08_compare_type_parameters.go:9)  FUNCDATA        $6, "".compare[go.shape.float64_0].argliveinfo(SB)
        0x0000 00000 (08_compare_type_parameters.go:9)  PCDATA  $3, $1
        0x0000 00000 (08_compare_type_parameters.go:10) UCOMISD X0, X1
        0x0004 00004 (08_compare_type_parameters.go:10) SETHI   AL
        0x0007 00007 (08_compare_type_parameters.go:10) RET
        0x0000 66 0f 2e c8 0f 97 c0 c3                          f.......
&nbsp;
<strong>"".compare[go.shape.string_0] STEXT dupok size=120 args=0x28 locals=0x28 funcid=0x0 align=0x0</strong>
        0x0000 00000 (08_compare_type_parameters.go:9)  TEXT    "".compare[go.shape.string_0](SB), DUPOK|ABIInternal, $40-40
        0x0000 00000 (08_compare_type_parameters.go:9)  CMPQ    SP, 16(R14)
        0x0004 00004 (08_compare_type_parameters.go:9)  PCDATA  $0, $-2
        0x0004 00004 (08_compare_type_parameters.go:9)  JLS     63
        0x0006 00006 (08_compare_type_parameters.go:9)  PCDATA  $0, $-1
        0x0006 00006 (08_compare_type_parameters.go:9)  SUBQ    $40, SP
        0x000a 00010 (08_compare_type_parameters.go:9)  MOVQ    BP, 32(SP)
        0x000f 00015 (08_compare_type_parameters.go:9)  LEAQ    32(SP), BP
        0x0014 00020 (08_compare_type_parameters.go:9)  MOVQ    BX, "".x+56(FP)
        0x0019 00025 (08_compare_type_parameters.go:9)  MOVQ    DI, "".y+72(FP)
        0x001e 00030 (08_compare_type_parameters.go:9)  FUNCDATA        $0, gclocals·7a680c56c7799a8f60d071b2f2541840(SB)
        0x001e 00030 (08_compare_type_parameters.go:9)  FUNCDATA        $1, gclocals·69c1753bd5f81501d95132d08af04464(SB)
        0x001e 00030 (08_compare_type_parameters.go:9)  FUNCDATA        $5, "".compare[go.shape.string_0].arginfo1(SB)
        0x001e 00030 (08_compare_type_parameters.go:9)  FUNCDATA        $6, "".compare[go.shape.string_0].argliveinfo(SB)
        0x001e 00030 (08_compare_type_parameters.go:9)  PCDATA  $3, $1
        0x001e 00030 (08_compare_type_parameters.go:10) MOVQ    BX, AX
        0x0021 00033 (08_compare_type_parameters.go:10) MOVQ    CX, BX
        0x0024 00036 (08_compare_type_parameters.go:10) MOVQ    DI, CX
        0x0027 00039 (08_compare_type_parameters.go:10) MOVQ    SI, DI
        0x002a 00042 (08_compare_type_parameters.go:10) PCDATA  $1, $1
        0x002a 00042 (08_compare_type_parameters.go:10) CALL    runtime.cmpstring(SB)
        0x002f 00047 (08_compare_type_parameters.go:10) TESTQ   AX, AX
        0x0032 00050 (08_compare_type_parameters.go:10) SETLT   AL
        0x0035 00053 (08_compare_type_parameters.go:10) MOVQ    32(SP), BP
        0x003a 00058 (08_compare_type_parameters.go:10) ADDQ    $40, SP
        0x003e 00062 (08_compare_type_parameters.go:10) RET
        0x003f 00063 (08_compare_type_parameters.go:10) NOP
        0x003f 00063 (08_compare_type_parameters.go:9)  PCDATA  $1, $-1
        0x003f 00063 (08_compare_type_parameters.go:9)  PCDATA  $0, $-2
        0x003f 00063 (08_compare_type_parameters.go:9)  MOVQ    AX, 8(SP)
        0x0044 00068 (08_compare_type_parameters.go:9)  MOVQ    BX, 16(SP)
        0x0049 00073 (08_compare_type_parameters.go:9)  MOVQ    CX, 24(SP)
        0x004e 00078 (08_compare_type_parameters.go:9)  MOVQ    DI, 32(SP)
        0x0053 00083 (08_compare_type_parameters.go:9)  MOVQ    SI, 40(SP)
        0x0058 00088 (08_compare_type_parameters.go:9)  CALL    runtime.morestack_noctxt(SB)
        0x005d 00093 (08_compare_type_parameters.go:9)  MOVQ    8(SP), AX
        0x0062 00098 (08_compare_type_parameters.go:9)  MOVQ    16(SP), BX
        0x0067 00103 (08_compare_type_parameters.go:9)  MOVQ    24(SP), CX
        0x006c 00108 (08_compare_type_parameters.go:9)  MOVQ    32(SP), DI
        0x0071 00113 (08_compare_type_parameters.go:9)  MOVQ    40(SP), SI
        0x0076 00118 (08_compare_type_parameters.go:9)  PCDATA  $0, $-1
        0x0076 00118 (08_compare_type_parameters.go:9)  JMP     0
</pre>

<p><div class="rs-tip-major">Poznámka: používání generických funkcí je sice
elegantní, ale může vést k&nbsp;mnohdy významnému nárůstu velikosti výsledného
strojového kódu se všemi z&nbsp;toho plynoucími důsledky &ndash; větší tlak na
L1 cache atd.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně stovku kilobajtů), můžete namísto toho použít odkazy na jednotlivé
demonstrační příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad/soubor</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_print.go</td><td>funkce s&nbsp;konkrétními datovými typy</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/01_print.go">https://github.com/tisnik/go-root/blob/master/article_88/01_print.go</a></td></tr>
<tr><td> 2</td><td>02_print_overload.go</td><td>pokus o přetížení funkce</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/02_print_overload.go">https://github.com/tisnik/go-root/blob/master/article_88/02_print_overload.go</a></td></tr>
<tr><td> 3</td><td>03_print_no_conversion.go</td><td>konverze datových typů není automatická</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/03_print_no_conversion.go">https://github.com/tisnik/go-root/blob/master/article_88/03_print_no_conversion.go</a></td></tr>
<tr><td> 4</td><td>04_print_interface.go</td><td>použití prázdných rozhraní, které splňuje jakýkoli datový typ</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/04_print_interface.go">https://github.com/tisnik/go-root/blob/master/article_88/04_print_interface.go</a></td></tr>
<tr><td> 5</td><td>05_generic_print.go</td><td>využití typových parametrů funkce</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/05_generic_print.go">https://github.com/tisnik/go-root/blob/master/article_88/05_generic_print.go</a></td></tr>
<tr><td> 6</td><td>06_type_parameter.go</td><td>explicitní volání konkrétní varianty generické funkce</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/06_type_parameter.go">https://github.com/tisnik/go-root/blob/master/article_88/06_type_parameter.go</a></td></tr>
<tr><td> 7</td><td>07_type_parameter_check.go</td><td>kontrola typů parametrů volané funkce</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/07_type_parameter_check.go">https://github.com/tisnik/go-root/blob/master/article_88/07_type_parameter_check.go</a></td></tr>
<tr><td> 8</td><td>08_comparable.go</td><td>triviální porovnání dvou hodnot typu <strong>int</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/08_comparable.go">https://github.com/tisnik/go-root/blob/master/article_88/08_comparable.go</a></td></tr>
<tr><td> 9</td><td>09_comparable_variable_types.go</td><td>sada funkcí pro porovnání dvojice hodnot různých typů</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/09_comparable_variable_types.go">https://github.com/tisnik/go-root/blob/master/article_88/09_comparable_variable_types.go</a></td></tr>
<tr><td>10</td><td>10_compare_type_parameters.go</td><td>jediná funkce pro porovnání dvojice hodnot různých typů</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/10_compare_type_parameters.go">https://github.com/tisnik/go-root/blob/master/article_88/10_compare_type_parameters.go</a></td></tr>
<tr><td>11</td><td>11_add_int.go</td><td>datový systém jazyka Go a přetížené operátory: součet dvou hodnot</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/11_add_int.go">https://github.com/tisnik/go-root/blob/master/article_88/11_add_int.go</a></td></tr>
<tr><td>12</td><td>12_add_type_parameters.go</td><td>sada funkcí pro porovnání dvojice hodnot různých typů</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/12_add_type_parameters.go">https://github.com/tisnik/go-root/blob/master/article_88/12_add_type_parameters.go</a></td></tr>
<tr><td>13</td><td>13_add_type_parameters.go</td><td>jediná funkce pro porovnání dvojice hodnot různých typů</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/13_add_type_parameters.go">https://github.com/tisnik/go-root/blob/master/article_88/13_add_type_parameters.go</a></td></tr>
<tr><td>14</td><td>14_add_type_parameters.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/14_add_type_parameters.go">https://github.com/tisnik/go-root/blob/master/article_88/12_add_type_parameters.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Go Programming Language Specification<br />
<a href="https://go.dev/ref/spec">https://go.dev/ref/spec</a>
</li>

<li>Generics in Go<br />
<a href="https://bitfieldconsulting.com/golang/generics">https://bitfieldconsulting.com/golang/generics</a>
</li>

<li>Tutorial: Getting started with generics<br />
<a href="https://go.dev/doc/tutorial/generics">https://go.dev/doc/tutorial/generics</a>
</li>

<li>Type parameters in Go<br />
<a href="https://bitfieldconsulting.com/golang/type-parameters">https://bitfieldconsulting.com/golang/type-parameters</a>
</li>

<li>Go Data Structures: Binary Search Tree<br />
<a href="https://flaviocopes.com/golang-data-structure-binary-search-tree/">https://flaviocopes.com/golang-data-structure-binary-search-tree/</a>
</li>

<li>Gobs of data<br />
<a href="https://blog.golang.org/gobs-of-data">https://blog.golang.org/gobs-of-data</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Go 1.18 Release Notes<br />
<a href="https://golang.org/doc/go1.18">https://golang.org/doc/go1.18</a>
</li>

<li>Go 1.17 Release Notes<br />
<a href="https://golang.org/doc/go1.17">https://golang.org/doc/go1.17</a>
</li>

<li>Go 1.16 Release Notes<br />
<a href="https://golang.org/doc/go1.16">https://golang.org/doc/go1.16</a>
</li>

<li>Go 1.15 Release Notes<br />
<a href="https://golang.org/doc/go1.15">https://golang.org/doc/go1.15</a>
</li>

<li>Go 1.14 Release Notes<br />
<a href="https://golang.org/doc/go1.14">https://golang.org/doc/go1.14</a>
</li>

<li>Go 1.13 Release Notes<br />
<a href="https://golang.org/doc/go1.13">https://golang.org/doc/go1.13</a>
</li>

<li>Go 1.12 Release Notes<br />
<a href="https://golang.org/doc/go1.12">https://golang.org/doc/go1.12</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>A Proposal for Adding Generics to Go<br />
<a href="https://go.dev/blog/generics-proposal">https://go.dev/blog/generics-proposal</a>
</li>

<li>Proposal: Go should have generics<br />
<a href="https://github.com/golang/proposal/blob/master/design/15292-generics.md">https://github.com/golang/proposal/blob/master/design/15292-generics.md</a>
</li>

<li>Know Go: Generics (Kniha)<br />
<a href="https://bitfieldconsulting.com/books/generics">https://bitfieldconsulting.com/books/generics</a>
</li>

<li>Balíček constraints<br />
<a href="https://pkg.go.dev/golang.org/x/exp/constraints">https://pkg.go.dev/golang.org/x/exp/constraints</a>
</li>

<li>What are the libraries/tools you missed from other programming languages in Golang?<br />
<a href="https://www.quora.com/What-are-the-libraries-tools-you-missed-from-other-programming-languages-in-Golang?share=1">https://www.quora.com/What-are-the-libraries-tools-you-missed-from-other-programming-languages-in-Golang?share=1</a>
</li>

<li>Golang Has Generics—Why I Don't Miss Generics Anymore<br />
<a href="https://blog.jonathanoliver.com/golang-has-generics/">https://blog.jonathanoliver.com/golang-has-generics/</a>
</li>

<li>Go 1.18 Generics based slice package<br />
<a href="https://golangexample.com/go-1-18-generics-based-slice-package/">https://golangexample.com/go-1-18-generics-based-slice-package/</a>
</li>

<li>The missing slice package<br />
<a href="https://github.com/ssoroka/slice">https://github.com/ssoroka/slice</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

