<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. </a></p>
<p><a href="#k03">*** 3. </a></p>
<p><a href="#k04">*** 4. </a></p>
<p><a href="#k05">*** 5. Funkce s&nbsp;konkrétními datovými typy vs.&nbsp;s&nbsp;generickými typy</a></p>
<p><a href="#k06">*** 6. Použití prázdných rozhraní, které splňuje jakýkoli datový typ</a></p>
<p><a href="#k07">*** 7. Novinka v&nbsp;Go 1.18 &ndash; typové parametry</a></p>
<p><a href="#k08">*** 8. Explicitní určení volané funkce</a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. Sada funkcí pro porovnání dvojice hodnot různých typů</a></p>
<p><a href="#k12">*** 12. Jediná funkce pro porovnání dvojice hodnot různých typů</a></p>
<p><a href="#k13">*** 13. Příprava generické funkce pro součet dvou hodnot</a></p>
<p><a href="#k14">*** 14. Generická forma funkce <strong>add</strong></a></p>
<p><a href="#k15">*** 15. Problematika odvozených datových typů</a></p>
<p><a href="#k16">*** 16. Aproximace datového typu</a></p>
<p><a href="#k17">*** 17. Překlad běžné funkce <strong>compare</strong> do assembleru</a></p>
<p><a href="#k18">*** 18. Překlad funkce s&nbsp;typovými parametry do assembleru</a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<p>Již <a href="https://www.root.cz/clanky/go-minimalisticky-a-prekvapive-vykonny-programovaci-jazyk/">v&nbsp;úvodní části</a> <a href="https://www.root.cz/serialy/programovaci-jazyk-go/">seriálu o programovacím jazyku Go</a> jsme si mj.&nbsp;řekli, že tento jazyk byl navržen takovým způsobem, že obsahuje pouze ty syntaktické a sémantické prvky, na nichž se <a href="https://www.informit.com/articles/article.aspx?p=1623555">shodli všichni tři</a> autoři tohoto projektu. Všechny vlastnosti, u nichž nebylo na sto procent jisté, že jsou správně navrženy a že jejich implementace nebude zpomalovat překladač ani výsledný zkompilovaný a slinkovaný kód, nebyly do první verze programovacího jazyka Go přidány. Týká se to některých vlastností, které mohou programátorům chybět &ndash; například výjimek, tříd (a na třídách postavené větvi objektově orientovaného programování) a taktéž generických datových typů a generických funkcí. A zejména neexistence generických datových typů může být pro některé typy aplikací značně omezující, protože je například složité implementovat obecné a současně i typově bezpečné datové struktury typu graf, strom, zásobník, fronta atd.</p>

<p>V&nbsp;dnešním článku se nejprve ve stručnosti seznámíme s&nbsp;tím, jakým způsobem jsou generické datové typy implementovány <a href="#k05">v&nbsp;Javě</a> a taktéž <a href="#08">v&nbsp;Rustu</a>, tedy v&nbsp;těch programovacích jazycích, jejichž niky se částečně překrývají s&nbsp;oblastí použití jazyka Go. Ve druhé části článku si pak ukážeme, jak je tento problém řešen v&nbsp;Go 1.18, které přineslo právě podporu generických typů &ndash; což byla mnohými vývojáři netrpělivě očekávaná novinka.</p>

<p><div class="rs-tip-major">Poznámka: zabývat se tedy nebudeme jazyky typu <a href="https://www.root.cz/n/python/">Python</a>, v&nbsp;nichž je použit <a href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a> a tedy zcela jiný přístup k&nbsp;práci s&nbsp;hodnotami a datovými strukturami.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Beztypové a jednoúčelové kontejnery</h2>

<p>V&nbsp;některých programovacích jazycích (a nejedná se pouze o dynamicky typované jazyky) se setkáme s&nbsp;takzvanými beztypovými popř.&nbsp;s&nbsp;jednoúčelovými kontejnery, kterými můžeme do jisté míry nahradit kontejnery s&nbsp;generickými typy. Typicky se jedná o implementace seznamů, front, zásobníků, různých typů stromů, obecných orientovaných i neorientovaných grafů atd. Beztypové kontejnery jsou většinou založeny na vlastnostech třídního OOP (dědění a polymorfismus) a většinou taktéž na tom, že hierarchie tříd mívá v&nbsp;mnoha jazycích společného předka. To tedy znamená, že pokud vytvoříme kontejner (řekněme seznam) pro prvky typu &bdquo;instance třídy na vrcholu hierarchie tříd&ldquo;, bude možné do takové třídy uložit jakýkoli objekt, ovšem za tu cenu, že se ztrácí informace o uloženém typu (tu je nutné získávat pro každý prvek zvlášť, pokud to jazyk díky <a href="https://en.wikipedia.org/wiki/Run-time_type_information">RTTI</a> umožňuje).</p>

<p><div class="rs-tip-major">Podobné řešení nabízela Java před verzí
5.</div></p>

<p>Naopak je mnohdy možné vytvořit takzvané jednoúčelové kontejnery. Ty dokážou ukládat prvky jediného typu popř.&nbsp;v&nbsp;OOP jazycích i odvozeného typu (potomci třídy). Popř.&nbsp;se může jednat o prvky implementující či splňující nějaké rozhraní. Typickým příkladem může být pole či řez v&nbsp;jazyku Go. Při použití jednoúčelových kontejnerů se informace o typu prvků neztratí a naopak je striktně kontrolována překladačem. Nevýhoda je ovšem zřejmá &ndash; pro každý datový typ je mnohdy nutné vytvořit prakticky stejný kontejner, jehož implementace se mnohdy odlišuje pouze v&nbsp;několika maličkostech.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Statická genericita</h2>

<p>Generické datové typy a generické funkce lze realizovat rozličnými způsoby.  Pokud samotný programovací jazyk genericitu nepodporuje, ovšem má rozumný makrosystém, lze použít (či spíše zneužít) právě tento makrosystém, kdy makra budou expandována na konkrétní datový typ (například komplexní číslo s&nbsp;položkami typu <strong>float</strong>), popř.&nbsp;na konkrétní funkci (s&nbsp;tím, že jméno funkce bude muset být nějakým způsobem unikátní). Jedná se ovšem o velmi křehké řešení &ndash; mnoho chybových hlášení bude používat expandovaný kód, který uživatel nenapsal atd.</p>

<p>V&nbsp;některých programovacích jazycích, například v&nbsp;Javě, se používá odlišný způsob, při němž se ve zdrojovém kódu konkrétní datový typ (vhodným způsobem) zapíše a překladač ho tedy zpracuje a použije pro případné typové kontroly. Ovšem interně &ndash; v&nbsp;generovaném kódu nebo bajtkódu &ndash; se použije nějaký obecný společný nadtyp, typicky třída <strong>Object</strong> (v&nbsp;závislosti na konkrétní hierarchii tříd a datových typů). Prakticky stejným způsobem je vyřešeno vytváření funkcí a metod z&nbsp;generických funkcí a metod.</p>

<p><div class="rs-tip-major">Poznámka: existuje ještě třetí možnost, a to přímo generování zdrojového kódu. S&nbsp;touto možností jsme se již seznámili v&nbsp;souvislosti s&nbsp;projektem <i>Genny</i>. Krátce: jedná se o tu nejhorší možnou variantu, a to z&nbsp;mnoha pohledů &ndash; </div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Dynamická genericita</h2>

<p>V&nbsp;případě, že překladač programovacího jazyka vytváří kód běžící ve virtuálním stroji, je možné generické datové typy popř.&nbsp;i generické funkce a metody vytvářet právě virtuálním strojem, a to přímo za běhu aplikace. Toto řešení má některé výhody (vytvoří se pouze tolik variant, kolik je skutečně zapotřebí), ovšem samozřejmě za tuto možnost zaplatíme pomalejším během a mnohdy i většími paměťovými nároky.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Funkce s&nbsp;konkrétními datovými typy vs.&nbsp;s&nbsp;generickými typy</h2>

<pre>
package <strong>main</strong>

import "fmt"

func <strong>printValue</strong>(value string) {
        fmt.Println(value)
}

func <strong>main</strong>() {
        printValue("www.root.cz")
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Použití prázdných rozhraní, které splňuje jakýkoli datový typ</h2>

<pre>
package <strong>main</strong>

import "fmt"

func <strong>printValue</strong>(value interface{}) {
        fmt.Println(value)
}

func <strong>main</strong>() {
        printValue("www.root.cz")
        printValue('*')
        printValue(42)
        printValue(3.14)
        printValue(1 + 2i)
        printValue([]int{1, 2, 3})
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Novinka v&nbsp;Go 1.18 &ndash; typové parametry</h2>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
func <strong>printValue</strong><u>[T any]</u>(value <u>T</u>) {
        fmt.Println(value)
}
&nbsp;
func <strong>main</strong>() {
        printValue("www.root.cz")
        printValue('*')
        printValue(42)
        printValue(3.14)
        printValue(1 + 2i)
        printValue([]int{1, 2, 3})
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Explicitní určení volané funkce</h2>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
func <strong>printValue</strong><u>[T any]</u>(value <u>T</u>) {
        fmt.Println(value)
}
&nbsp;
func <strong>main</strong>() {
        printValue[string]("www.root.cz")
        printValue[rune]('*')
        printValue[int](42)
        printValue[float32](3.14)
        printValue[complex64](1 + 2i)
        printValue[[]int]([]int{1, 2, 3})
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>

<pre>
package <strong>main</strong>

import "fmt"

func <strong>printValue</strong>[T any](value T) {
        fmt.Println(value)
}

func <strong>main</strong>() {
        printValue[int]("www.root.cz")
        printValue[[]string]('*')
        printValue[string](42)
        printValue[int](3.14)
        printValue[byte](1 + 2i)
        printValue[[]byte]([]int{1, 2, 3})
}
</pre>

<pre>
# command-line-arguments
./05_type_parameter_check.go:10:18: cannot use "www.root.cz" (untyped string constant) as int value in argument to printValue[int]
./05_type_parameter_check.go:11:23: cannot use '*' (untyped rune constant 42) as []string value in argument to printValue[[]string]
./05_type_parameter_check.go:12:21: cannot use 42 (untyped int constant) as string value in argument to printValue[string]
./05_type_parameter_check.go:13:18: cannot use 3.14 (untyped float constant) as int value in argument to printValue[int] (truncated)
./05_type_parameter_check.go:14:19: cannot use 1 + 2i (untyped complex constant (1 + 2i)) as byte value in argument to printValue[byte] (truncated)
./05_type_parameter_check.go:15:21: cannot use []int{…} (value of type []int) as type []byte in argument to printValue[[]byte]
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

<pre>
package <strong>main</strong>

import "fmt"

func <strong>compare</strong>(x int, y int) bool {
        return x &lt; y
}

func <strong>main</strong>() {
        fmt.Println(compare(1, 2))
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Sada funkcí pro porovnání dvojice hodnot různých typů</h2>

<pre>
package <strong>main</strong>

import "fmt"

func <strong>compareInts</strong>(x int, y int) bool {
        return x &lt; y
}

func <strong>compareFloats</strong>(x float64, y float64) bool {
        return x &lt; y
}

func <strong>compareStrings</strong>(x string, y string) bool {
        return x &lt; y
}

func <strong>main</strong>() {
        fmt.Println(compareInts(1, 2))
        fmt.Println(compareFloats(1.5, 2.6))
        fmt.Println(compareStrings("foo", "bar"))
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Jediná funkce pro porovnání dvojice hodnot různých typů</h2>

<pre>
package <strong>main</strong>

import "fmt"

type <strong>comparable</strong> interface {
        int | float64 | string
}

func <strong>compare</strong>[T comparable](x T, y T) bool {
        return x &lt; y
}

func <strong>main</strong>() {
        fmt.Println(compare(1, 2))
        fmt.Println(compare(1.5, 2.6))
        fmt.Println(compare("foo", "bar"))
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Příprava generické funkce pro součet dvou hodnot</h2>

<pre>
package <strong>main</strong>

import "fmt"

func <strong>add</strong>(x int, y int) int {
        return x + y
}

func <strong>main</strong>() {
        fmt.Println(add(1, 2))
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Generická forma funkce <strong>add</strong></h2>

<pre>
package <strong>main</strong>

import "fmt"

type <strong>numeric</strong> interface {
        int | float64 | complex128
}

func <strong>add</strong>[T numeric](x T, y T) T {
        return x + y
}

func <strong>main</strong>() {
        fmt.Println(add(1, 2))
        fmt.Println(add(1.5, 2.6))
        fmt.Println(add(1i, 2+4i))
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Problematika odvozených datových typů</h2>

<pre>
package <strong>main</strong>

import "fmt"

type <strong>numeric</strong> interface {
        int | float64 | complex128
}

func <strong>add</strong>[T numeric](x T, y T) T {
        return x + y
}

type <strong>myInt</strong> int

type <strong>myFloat</strong> float64

type <strong>myComplex</strong> complex128

func <strong>main</strong>() {
        var x myInt = 42
        var y myFloat = 3.14
        var z myComplex = 1 + 2i

        fmt.Println(add(x, x))
        fmt.Println(add(y, y))
        fmt.Println(add(z, z))
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Aproximace datového typu</h2>

<pre>
package <strong>main</strong>

import "fmt"

type <strong>numeric</strong> interface {
        ~int | ~float64 | ~complex128
}

func <strong>add</strong>[T numeric](x T, y T) T {
        return x + y
}

type <strong>myInt</strong> int

type <strong>myFloat</strong> float64

type <strong>myComplex</strong> complex128

func <strong>main</strong>() {
        var x myInt = 42
        var y myFloat = 3.14
        var z myComplex = 1 + 2i

        fmt.Println(add(x, x))
        fmt.Println(add(y, y))
        fmt.Println(add(z, z))
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Překlad běžné funkce <strong>compare</strong> do assembleru</h2>

<pre>
package <strong>main</strong>

import "fmt"

func <strong>compare</strong>(x int, y int) bool {
        return x &lt; y
}

func <strong>main</strong>() {
        fmt.Println(compare(1, 2))
}
</pre>

<pre>
$ <strong>go tool compile -S 06_comparable.go > 06_comparable.s</strong>
</pre>

<pre>
<strong>"".compare STEXT nosplit size=7 args=0x10 locals=0x0 funcid=0x0 align=0x0</strong>
        0x0000 00000 (06_comparable.go:5)       TEXT    "".compare(SB), NOSPLIT|ABIInternal, $0-16
        0x0000 00000 (06_comparable.go:5)       FUNCDATA        $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (06_comparable.go:5)       FUNCDATA        $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (06_comparable.go:5)       FUNCDATA        $5, "".compare.arginfo1(SB)
        0x0000 00000 (06_comparable.go:5)       FUNCDATA        $6, "".compare.argliveinfo(SB)
        0x0000 00000 (06_comparable.go:5)       PCDATA  $3, $1
        0x0000 00000 (06_comparable.go:6)       CMPQ    BX, AX
        0x0003 00003 (06_comparable.go:6)       SETGT   AL
        0x0006 00006 (06_comparable.go:6)       RET
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Překlad funkce s&nbsp;typovými parametry do assembleru</h2>

<pre>
package <strong>main</strong>

import "fmt"

type <strong>comparable</strong> interface {
        int | float64 | string
}

func <strong>compare</strong>[T comparable](x T, y T) bool {
        return x &lt; y
}

func <strong>main</strong>() {
        fmt.Println(compare(1, 2))
        fmt.Println(compare(1.5, 2.6))
        fmt.Println(compare("foo", "bar"))
}
</pre>

<pre>
$ <strong>go tool compile -S 08_compare_type_parameters.go > 08_compare_type_parameters.s</strong>
</pre>

<pre>
<strong>"".compare[go.shape.int_0] STEXT dupok nosplit size=7 args=0x18 locals=0x0 funcid=0x0 align=0x0</strong>
        0x0000 00000 (08_compare_type_parameters.go:9)  TEXT    "".compare[go.shape.int_0](SB), DUPOK|NOSPLIT|ABIInternal, $0-24
        0x0000 00000 (08_compare_type_parameters.go:9)  FUNCDATA        $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (08_compare_type_parameters.go:9)  FUNCDATA        $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (08_compare_type_parameters.go:9)  FUNCDATA        $5, "".compare[go.shape.int_0].arginfo1(SB)
        0x0000 00000 (08_compare_type_parameters.go:9)  FUNCDATA        $6, "".compare[go.shape.int_0].argliveinfo(SB)
        0x0000 00000 (08_compare_type_parameters.go:9)  PCDATA  $3, $1
        0x0000 00000 (08_compare_type_parameters.go:10) CMPQ    CX, BX
        0x0003 00003 (08_compare_type_parameters.go:10) SETGT   AL
        0x0006 00006 (08_compare_type_parameters.go:10) RET
        0x0000 48 39 d9 0f 9f c0 c3                             H9.....
<strong>"".compare[go.shape.float64_0] STEXT dupok nosplit size=8 args=0x18 locals=0x0 funcid=0x0 align=0x0</strong>
        0x0000 00000 (08_compare_type_parameters.go:9)  TEXT    "".compare[go.shape.float64_0](SB), DUPOK|NOSPLIT|ABIInternal, $0-24
        0x0000 00000 (08_compare_type_parameters.go:9)  FUNCDATA        $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (08_compare_type_parameters.go:9)  FUNCDATA        $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (08_compare_type_parameters.go:9)  FUNCDATA        $5, "".compare[go.shape.float64_0].arginfo1(SB)
        0x0000 00000 (08_compare_type_parameters.go:9)  FUNCDATA        $6, "".compare[go.shape.float64_0].argliveinfo(SB)
        0x0000 00000 (08_compare_type_parameters.go:9)  PCDATA  $3, $1
        0x0000 00000 (08_compare_type_parameters.go:10) UCOMISD X0, X1
        0x0004 00004 (08_compare_type_parameters.go:10) SETHI   AL
        0x0007 00007 (08_compare_type_parameters.go:10) RET
        0x0000 66 0f 2e c8 0f 97 c0 c3                          f.......
<strong>"".compare[go.shape.string_0] STEXT dupok size=120 args=0x28 locals=0x28 funcid=0x0 align=0x0</strong>
        0x0000 00000 (08_compare_type_parameters.go:9)  TEXT    "".compare[go.shape.string_0](SB), DUPOK|ABIInternal, $40-40
        0x0000 00000 (08_compare_type_parameters.go:9)  CMPQ    SP, 16(R14)
        0x0004 00004 (08_compare_type_parameters.go:9)  PCDATA  $0, $-2
        0x0004 00004 (08_compare_type_parameters.go:9)  JLS     63
        0x0006 00006 (08_compare_type_parameters.go:9)  PCDATA  $0, $-1
        0x0006 00006 (08_compare_type_parameters.go:9)  SUBQ    $40, SP
        0x000a 00010 (08_compare_type_parameters.go:9)  MOVQ    BP, 32(SP)
        0x000f 00015 (08_compare_type_parameters.go:9)  LEAQ    32(SP), BP
        0x0014 00020 (08_compare_type_parameters.go:9)  MOVQ    BX, "".x+56(FP)
        0x0019 00025 (08_compare_type_parameters.go:9)  MOVQ    DI, "".y+72(FP)
        0x001e 00030 (08_compare_type_parameters.go:9)  FUNCDATA        $0, gclocals·7a680c56c7799a8f60d071b2f2541840(SB)
        0x001e 00030 (08_compare_type_parameters.go:9)  FUNCDATA        $1, gclocals·69c1753bd5f81501d95132d08af04464(SB)
        0x001e 00030 (08_compare_type_parameters.go:9)  FUNCDATA        $5, "".compare[go.shape.string_0].arginfo1(SB)
        0x001e 00030 (08_compare_type_parameters.go:9)  FUNCDATA        $6, "".compare[go.shape.string_0].argliveinfo(SB)
        0x001e 00030 (08_compare_type_parameters.go:9)  PCDATA  $3, $1
        0x001e 00030 (08_compare_type_parameters.go:10) MOVQ    BX, AX
        0x0021 00033 (08_compare_type_parameters.go:10) MOVQ    CX, BX
        0x0024 00036 (08_compare_type_parameters.go:10) MOVQ    DI, CX
        0x0027 00039 (08_compare_type_parameters.go:10) MOVQ    SI, DI
        0x002a 00042 (08_compare_type_parameters.go:10) PCDATA  $1, $1
        0x002a 00042 (08_compare_type_parameters.go:10) CALL    runtime.cmpstring(SB)
        0x002f 00047 (08_compare_type_parameters.go:10) TESTQ   AX, AX
        0x0032 00050 (08_compare_type_parameters.go:10) SETLT   AL
        0x0035 00053 (08_compare_type_parameters.go:10) MOVQ    32(SP), BP
        0x003a 00058 (08_compare_type_parameters.go:10) ADDQ    $40, SP
        0x003e 00062 (08_compare_type_parameters.go:10) RET
        0x003f 00063 (08_compare_type_parameters.go:10) NOP
        0x003f 00063 (08_compare_type_parameters.go:9)  PCDATA  $1, $-1
        0x003f 00063 (08_compare_type_parameters.go:9)  PCDATA  $0, $-2
        0x003f 00063 (08_compare_type_parameters.go:9)  MOVQ    AX, 8(SP)
        0x0044 00068 (08_compare_type_parameters.go:9)  MOVQ    BX, 16(SP)
        0x0049 00073 (08_compare_type_parameters.go:9)  MOVQ    CX, 24(SP)
        0x004e 00078 (08_compare_type_parameters.go:9)  MOVQ    DI, 32(SP)
        0x0053 00083 (08_compare_type_parameters.go:9)  MOVQ    SI, 40(SP)
        0x0058 00088 (08_compare_type_parameters.go:9)  CALL    runtime.morestack_noctxt(SB)
        0x005d 00093 (08_compare_type_parameters.go:9)  MOVQ    8(SP), AX
        0x0062 00098 (08_compare_type_parameters.go:9)  MOVQ    16(SP), BX
        0x0067 00103 (08_compare_type_parameters.go:9)  MOVQ    24(SP), CX
        0x006c 00108 (08_compare_type_parameters.go:9)  MOVQ    32(SP), DI
        0x0071 00113 (08_compare_type_parameters.go:9)  MOVQ    40(SP), SI
        0x0076 00118 (08_compare_type_parameters.go:9)  PCDATA  $0, $-1
        0x0076 00118 (08_compare_type_parameters.go:9)  JMP     0
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly
uloženy do nového Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý,
dnes má přibližně stovku kilobajtů), můžete namísto toho použít odkazy
na jednotlivé demonstrační příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Příklad/soubor</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_print.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/01_print.go">https://github.com/tisnik/go-root/blob/master/article_88/01_print.go</a></td></tr>
<tr><td> 2</td><td>02_print_interface.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/02_print_interface.go">https://github.com/tisnik/go-root/blob/master/article_88/02_print_interface.go</a></td></tr>
<tr><td> 3</td><td>03_generic_print.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/03_generic_print.go">https://github.com/tisnik/go-root/blob/master/article_88/03_generic_print.go</a></td></tr>
<tr><td> 4</td><td>04_type_parameter.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/04_type_parameter.go">https://github.com/tisnik/go-root/blob/master/article_88/04_type_parameter.go</a></td></tr>
<tr><td> 5</td><td>05_type_parameter_check.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/05_type_parameter_check.go">https://github.com/tisnik/go-root/blob/master/article_88/05_type_parameter_check.go</a></td></tr>
<tr><td> 6</td><td>06_comparable.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/06_comparable.go">https://github.com/tisnik/go-root/blob/master/article_88/06_comparable.go</a></td></tr>
<tr><td> 7</td><td>07_comparable_variable_types.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/07_comparable_variable_types.go">https://github.com/tisnik/go-root/blob/master/article_88/07_comparable_variable_types.go</a></td></tr>
<tr><td> 8</td><td>08_compare_type_parameters.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/08_compare_type_parameters.go">https://github.com/tisnik/go-root/blob/master/article_88/08_compare_type_parameters.go</a></td></tr>
<tr><td> 9</td><td>09_add_int.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/09_add_int.go">https://github.com/tisnik/go-root/blob/master/article_88/09_add_int.go</a></td></tr>
<tr><td>10</td><td>10_add_type_parameters.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/10_add_type_parameters.go">https://github.com/tisnik/go-root/blob/master/article_88/10_add_type_parameters.go</a></td></tr>
<tr><td>11</td><td>11_add_type_parameters.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/11_add_type_parameters.go">https://github.com/tisnik/go-root/blob/master/article_88/10_add_type_parameters.go</a></td></tr>
<tr><td>12</td><td>12_add_type_parameters.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_88/12_add_type_parameters.go">https://github.com/tisnik/go-root/blob/master/article_88/10_add_type_parameters.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Go Programming Language Specification<br />
<a href="https://go.dev/ref/spec">https://go.dev/ref/spec</a>
</li>

<li>Generics in Go<br />
<a href="https://bitfieldconsulting.com/golang/generics">https://bitfieldconsulting.com/golang/generics</a>
</li>

<li>Tutorial: Getting started with generics<br />
<a href="https://go.dev/doc/tutorial/generics">https://go.dev/doc/tutorial/generics</a>
</li>

<li>Type parameters in Go<br />
<a href="https://bitfieldconsulting.com/golang/type-parameters">https://bitfieldconsulting.com/golang/type-parameters</a>
</li>

<li>Go Data Structures: Binary Search Tree<br />
<a href="https://flaviocopes.com/golang-data-structure-binary-search-tree/">https://flaviocopes.com/golang-data-structure-binary-search-tree/</a>
</li>

<li>Gobs of data<br />
<a href="https://blog.golang.org/gobs-of-data">https://blog.golang.org/gobs-of-data</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Go 1.18 Release Notes<br />
<a href="https://golang.org/doc/go1.18">https://golang.org/doc/go1.18</a>
</li>

<li>Go 1.17 Release Notes<br />
<a href="https://golang.org/doc/go1.17">https://golang.org/doc/go1.17</a>
</li>

<li>Go 1.16 Release Notes<br />
<a href="https://golang.org/doc/go1.16">https://golang.org/doc/go1.16</a>
</li>

<li>Go 1.15 Release Notes<br />
<a href="https://golang.org/doc/go1.15">https://golang.org/doc/go1.15</a>
</li>

<li>Go 1.14 Release Notes<br />
<a href="https://golang.org/doc/go1.14">https://golang.org/doc/go1.14</a>
</li>

<li>Go 1.13 Release Notes<br />
<a href="https://golang.org/doc/go1.13">https://golang.org/doc/go1.13</a>
</li>

<li>Go 1.12 Release Notes<br />
<a href="https://golang.org/doc/go1.12">https://golang.org/doc/go1.12</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>A Proposal for Adding Generics to Go<br />
<a href="https://go.dev/blog/generics-proposal">https://go.dev/blog/generics-proposal</a>
</li>

<li>Proposal: Go should have generics<br />
<a href="https://github.com/golang/proposal/blob/master/design/15292-generics.md">https://github.com/golang/proposal/blob/master/design/15292-generics.md</a>
</li>

<li>Know Go: Generics (Kniha)<br />
<a href="https://bitfieldconsulting.com/books/generics">https://bitfieldconsulting.com/books/generics</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

