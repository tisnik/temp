<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. </a></p>
<p><a href="#k03">*** 3. </a></p>
<p><a href="#k04">*** 4. </a></p>
<p><a href="#k05">*** 5. </a></p>
<p><a href="#k06">*** 6. </a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<p>Již v&nbsp;úvodních částech <a href="https://www.root.cz/serialy/programovaci-jazyk-go/">seriálu o programovacím jazyce Go</a> jsme si řekli, že se tento programovací jazyk velmi často a nutno říci, že i s&nbsp;úspěchem používá pro implementaci různých webových služeb a mikroslužeb (této problematice jsme se ostatně věnovali i <a href="https://www.root.cz/clanky/tvorba-webovych-aplikaci-v-go-s-vyuzitim-projektu-gorilla-web-toolkit/">v&nbsp;tomto článku</a>). Ovšem mnohé služby pochopitelně potřebují používat nějakou formu databáze pro perzistentní data. Může se jednat o relační databáze, dokumentové databáze, grafové databáze, objektové databáze atd. Způsob práce s&nbsp;relačními databázemi jsme si již taktéž popsali, a to včetně zmínky o několika systémech pro ORM. Popsali jsme si taktéž propojení aplikací psaných v&nbsp;jazyce Go s&nbsp;nerelační databází Redis. Dnes se ovšem zaměříme na poněkud odlišné téma &ndash; jak testovat aplikace, které databázi používají. Pro integrační a end-to-end testy lze samozřejmě použít reálnou databázi (pochopitelně odlišnou instanci, než je instance produkční), ovšem v&nbsp;případě jednotkových testů je situace nepatrně složitější.</p>

<p>V&nbsp;demonstračních příkladech se zaměříme na nízkoúrovňový přístup. Při použití tohoto přístupu je nutné explicitně zapisovat všechny SQL příkazy, předávat jim parametry a popř.&nbsp;explicitně načítat a zpracovávat jednotlivé záznamy vrácené dotazem <strong>SELECT</strong>. V&nbsp;některých případech je tento přístup velmi užitečný, protože například umožňuje snadné optimalizace dotazů. Mnoho programátorů však dává přednost jinému přístupu, který spočívá ve využití nějaké knihovny zajišťující ORM, tedy (zjednodušeně řečeno) mapování mezi záznamy uloženými v&nbsp;databázi a datovými strukturami vytvářenými na straně aplikace. Nicméně dále popsané řešení jednotkových testů bude použitelné jak při nízkoúrovňovém přístupu, tak i při použití ORM.</p>


<table>
<tr><th>Databáze</th><th>Driver pro Go</th></tr>
<tr><td>Apache H2:</td><td><a href="https://github.com/jmrobles/h2go">https://github.com/jmrobles/h2go</a></td></tr>
<tr><td>Apache Ignite/GridGain:</td><td><a href="https://github.com/amsokol/ignite-go-client">https://github.com/amsokol/ignite-go-client</a></td></tr>
<tr><td>Apache Impala:</td><td><a href="https://github.com/bippio/go-impala">https://github.com/bippio/go-impala</a></td></tr>
<tr><td>Apache Avatica/Phoenix:</td><td><a href="https://github.com/apache/calcite-avatica-go">https://github.com/apache/calcite-avatica-go</a></td></tr>
<tr><td>Amazon AWS Athena:</td><td><a href="https://github.com/uber/athenadriver">https://github.com/uber/athenadriver</a></td></tr>
<tr><td>AWS Athena:</td><td><a href="https://github.com/segmentio/go-athena">https://github.com/segmentio/go-athena</a></td></tr>
<tr><td>Azure Cosmos DB:</td><td><a href="https://github.com/btnguyen2k/gocosmos">https://github.com/btnguyen2k/gocosmos</a></td></tr>
<tr><td>ClickHouse (uses native TCP interface):</td><td><a href="https://github.com/ClickHouse/clickhouse-go">https://github.com/ClickHouse/clickhouse-go</a></td></tr>
<tr><td>ClickHouse (uses HTTP API):</td><td><a href="https://github.com/mailru/go-clickhouse">https://github.com/mailru/go-clickhouse</a></td></tr>
<tr><td>CockroachDB:</td><td><a href="Use any PostgreSQL driver">Use any PostgreSQL driver</a></td></tr>
<tr><td>Couchbase N1QL:</td><td><a href="https://github.com/couchbase/go_n1ql">https://github.com/couchbase/go_n1ql</a></td></tr>
<tr><td>DB2 LUW and DB2/Z with DB2-Connect:</td><td><a href="https://bitbucket.org/phiggins/db2cli (Last updated 2015-08)">https://bitbucket.org/phiggins/db2cli (Last updated 2015-08)</a></td></tr>
<tr><td>DB2 LUW (uses cgo):</td><td><a href="https://github.com/asifjalil/cli">https://github.com/asifjalil/cli</a></td></tr>
<tr><td>DB2 LUW, z/OS, iSeries and Informix:</td><td><a href="https://github.com/ibmdb/go_ibm_db">https://github.com/ibmdb/go_ibm_db</a></td></tr>
<tr><td>Firebird SQL:</td><td><a href="https://github.com/nakagami/firebirdsql">https://github.com/nakagami/firebirdsql</a></td></tr>
<tr><td>Genji (pure go):</td><td><a href="https://github.com/genjidb/genji">https://github.com/genjidb/genji</a></td></tr>
<tr><td>Google Cloud BigQuery:</td><td><a href="https://github.com/solcates/go-sql-bigquery">https://github.com/solcates/go-sql-bigquery</a></td></tr>
<tr><td>Google Cloud Spanner:</td><td><a href="https://github.com/rakyll/go-sql-driver-spanner">https://github.com/rakyll/go-sql-driver-spanner</a></td></tr>
<tr><td>MS ADODB:</td><td><a href="https://github.com/mattn/go-adodb">https://github.com/mattn/go-adodb</a></td></tr>
<tr><td>MS SQL Server (pure go):</td><td><a href="https://github.com/denisenkom/go-mssqldb">https://github.com/denisenkom/go-mssqldb</a></td></tr>
<tr><td>MS SQL Server (uses cgo):</td><td><a href="https://github.com/minus5/gofreetds">https://github.com/minus5/gofreetds</a></td></tr>
<tr><td>MySQL:</td><td><a href="https://github.com/go-sql-driver/mysql/">https://github.com/go-sql-driver/mysql/</a></td></tr>
<tr><td>MySQL:</td><td><a href="https://github.com/siddontang/go-mysql/">https://github.com/siddontang/go-mysql/</a></td></tr>
<tr><td>MySQL:</td><td><a href="https://github.com/ziutek/mymysql">https://github.com/ziutek/mymysql</a></td></tr>
<tr><td>ODBC:</td><td><a href="https://bitbucket.org/miquella/mgodbc">https://bitbucket.org/miquella/mgodbc</a></td></tr>
<tr><td>ODBC:</td><td><a href="https://github.com/alexbrainman/odbc">https://github.com/alexbrainman/odbc</a></td></tr>
<tr><td>Oracle (uses cgo):</td><td><a href="https://github.com/mattn/go-oci8">https://github.com/mattn/go-oci8</a></td></tr>
<tr><td>Oracle (uses cgo):</td><td><a href="https://gopkg.in/rana/ora.v4">https://gopkg.in/rana/ora.v4</a></td></tr>
<tr><td>Oracle (uses cgo):</td><td><a href="https://github.com/godror/godror">https://github.com/godror/godror</a></td></tr>
<tr><td>Oracle (pure go):</td><td><a href="https://github.com/sijms/go-ora">https://github.com/sijms/go-ora</a></td></tr>
<tr><td>QL:</td><td><a href="http://godoc.org/github.com/cznic/ql/driver">http://godoc.org/github.com/cznic/ql/driver</a></td></tr>
<tr><td>Postgres (pure Go):</td><td><a href="https://github.com/lib/pq">https://github.com/lib/pq</a></td></tr>
<tr><td>Postgres (uses cgo):</td><td><a href="https://github.com/jbarham/gopgsqldriver">https://github.com/jbarham/gopgsqldriver</a></td></tr>
<tr><td>Postgres (pure Go):</td><td><a href="https://github.com/jackc/pgx">https://github.com/jackc/pgx</a></td></tr>
<tr><td>Presto:</td><td><a href="https://github.com/prestodb/presto-go-client">https://github.com/prestodb/presto-go-client</a></td></tr>
<tr><td>SAP HANA (uses cgo):</td><td><a href="https://help.sap.com/viewer/0eec0d68141541d1b07893a39944924e/2.0.03/en-US/0ffbe86c9d9f44338441829c6bee15e6.html">https://help.sap.com/viewer/0eec0d68141541d1b07893a39944924e/2.0.03/en-US/0ffbe86c9d9f44338441829c6bee15e6.html</a></td></tr>
<tr><td>SAP HANA (pure go):</td><td><a href="https://github.com/SAP/go-hdb">https://github.com/SAP/go-hdb</a></td></tr>
<tr><td>SAP ASE (uses cgo):</td><td><a href="https://github.com/SAP/go-ase - package cgo (pure go package planned)">https://github.com/SAP/go-ase - package cgo (pure go package planned)</a></td></tr>
<tr><td>Snowflake (pure Go):</td><td><a href="https://github.com/snowflakedb/gosnowflake">https://github.com/snowflakedb/gosnowflake</a></td></tr>
<tr><td>SQLite (uses cgo):</td><td><a href="https://github.com/mattn/go-sqlite3">https://github.com/mattn/go-sqlite3</a></td></tr>
<tr><td>SQLite (uses cgo):</td><td><a href="https://github.com/gwenn/gosqlite">https://github.com/gwenn/gosqlite</a></td></tr>
<tr><td>SQLite (uses cgo):</td><td><a href="https://github.com/mxk/go-sqlite">https://github.com/mxk/go-sqlite</a></td></tr>
<tr><td>SQLite:</td><td><a href="(uses cgo): https://github.com/rsc/sqlite">(uses cgo): https://github.com/rsc/sqlite</a></td></tr>
<tr><td>SQLite:</td><td><a href="(pure go): https://modernc.org/sqlite">(pure go): https://modernc.org/sqlite</a></td></tr>
<tr><td>SQL over REST:</td><td><a href="https://github.com/adaptant-labs/go-sql-rest-driver">https://github.com/adaptant-labs/go-sql-rest-driver</a></td></tr>
<tr><td>Sybase SQL Anywhere:</td><td><a href="https://github.com/a-palchikov/sqlago">https://github.com/a-palchikov/sqlago</a></td></tr>
<tr><td>Sybase ASE (pure go):</td><td><a href="https://github.com/thda/tds">https://github.com/thda/tds</a></td></tr>
<tr><td>Vertica:</td><td><a href="https://github.com/vertica/vertica-sql-go">https://github.com/vertica/vertica-sql-go</a></td></tr>
<tr><td>Vitess:</td><td><a href="https://godoc.org/vitess.io/vitess/go/vt/vitessdriver">https://godoc.org/vitess.io/vitess/go/vt/vitessdriver</a></td></tr>
<tr><td>YQL (Yahoo! Query Language):</td><td><a href="https://github.com/mattn/go-yql">https://github.com/mattn/go-yql</a></td></tr>
<tr><td>Apache Hive:</td><td><a href="https://github.com/sql-machine-learning/gohive">https://github.com/sql-machine-learning/gohive</a></td></tr>
<tr><td>MaxCompute:</td><td><a href="https://github.com/sql-machine-learning/gomaxcompute">https://github.com/sql-machine-learning/gomaxcompute</a></td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. </h2>

<pre>
$ psql -U postgres
Password for user postgres: 
psql (9.6.10)
Type "help" for help.

postgres=# CREATE DATABASE testDB;
CREATE DATABASE

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges
------------+----------+----------+-------------+-------------+-----------------------
 aggregator | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 controller | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 ptisnovs   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 test       | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 testdb     | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
(8 rows)

postgres=# \c testdb
You are now connected to database "testdb" as user "postgres".

CREATE TABLE persons(
    id        SERIAL PRIMARY KEY,
    name      VARCHAR(50) NOT NULL,
    surname   VARCHAR(50)  NOT NULL);

testdb=# \dt
 public | persons | table | postgres

testdb=# \d persons
 id      | integer               | not null default nextval('persons_id_seq'::regclass)
 name    | character varying(50) | not null
 surname | character varying(50) | not null

INSERT INTO persons(name, surname) VALUES('Eliška', 'Najbrtová');
INSERT INTO persons(name, surname) VALUES('Jenny', 'Suk');
INSERT INTO persons(name, surname) VALUES('Anička', 'Šafářová');
INSERT INTO persons(name, surname) VALUES('Sváťa', 'Pulec');
INSERT INTO persons(name, surname) VALUES('Blažej', 'Motyčka');
INSERT INTO persons(name, surname) VALUES('Eda', 'Wasserfall');
INSERT INTO persons(name, surname) VALUES('Přemysl', 'Hájek');

testdb=# select * from persons;
  1 | Eliška  | Najbrtová
  2 | Jenny   | Suk
  3 | Anička  | Šafářová
  4 | Sváťa   | Pulec
  5 | Blažej  | Motyčka
  6 | Eda     | Wasserfall
  7 | Přemysl | Hájek



8:02PM DBG Started
8:02PM INF DB connection configuration driverName=postgres
8:02PM INF Record ID=1 name="Eliška" surname="Najbrtová"
8:02PM INF Record ID=2 name=Jenny surname=Suk
8:02PM INF Record ID=3 name="Anička" surname="Šafářová"
8:02PM INF Record ID=4 name="Sváťa" surname=Pulec
8:02PM INF Record ID=5 name="Blažej" surname="Motyčka"
8:02PM INF Record ID=6 name=Eda surname=Wasserfall
8:02PM INF Record ID=7 name="Přemysl" surname="Hájek"
8:02PM INF DELETE deleted rows=1
8:02PM INF INSERT inserted rows=1
8:02PM INF Record ID=1 name="Eliška" surname="Najbrtová"
8:02PM INF Record ID=2 name=Jenny surname=Suk
8:02PM INF Record ID=3 name="Anička" surname="Šafářová"
8:02PM INF Record ID=4 name="Sváťa" surname=Pulec
8:02PM INF Record ID=5 name="Blažej" surname="Motyčka"
8:02PM INF Record ID=7 name="Přemysl" surname="Hájek"
8:02PM INF Record ID=8 name=Eda surname="Vodopád"
8:02PM DBG Finished

testdb=# select * from persons;
 id |  name   |  surname
----+---------+-----------
  1 | Eliška  | Najbrtová
  2 | Jenny   | Suk
  3 | Anička  | Šafářová
  4 | Sváťa   | Pulec
  5 | Blažej  | Motyčka
  7 | Přemysl | Hájek
  8 | Eda     | Vodopád
(7 rows)
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. </h2>

<pre>
package main

import (
        "fmt"
        "os"

        "database/sql"

        _ "github.com/lib/pq"           // PostgreSQL database driver
        _ "github.com/mattn/go-sqlite3" // SQLite database driver

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

// Datová struktura s konfigurací připojení k databázi
type StorageConfiguration struct {
        Driver           string `mapstructure:"db_driver" toml:"db_driver"`
        SQLiteDataSource string `mapstructure:"sqlite_datasource" toml:"sqlite_datasource"`
        PGUsername       string `mapstructure:"pg_username" toml:"pg_username"`
        PGPassword       string `mapstructure:"pg_password" toml:"pg_password"`
        PGHost           string `mapstructure:"pg_host" toml:"pg_host"`
        PGPort           int    `mapstructure:"pg_port" toml:"pg_port"`
        PGDBName         string `mapstructure:"pg_db_name" toml:"pg_db_name"`
        PGParams         string `mapstructure:"pg_params" toml:"pg_params"`
}

// Chybové zprávy
const (
        canNotConnectToDataStorageMessage = "Can not connect to data storage"
        connectionToDBNotEstablished      = "Connection to database not established"
        unableToCloseDBRowsHandle         = "Unable to close the DB rows handle"
        databaseOperationFailed           = "Database operation failed"
)

// Inicializace připojení k databázi
func initDatabaseConnection(configuration StorageConfiguration) (*sql.DB, error) {
        driverName := configuration.Driver
        dataSource := ""
        log.Info().Str("driverName", configuration.Driver).Msg("DB connection configuration")

        // inicializace připojení s vybraným driverem
        switch driverName {
        case "sqlite3":
                //driverType := DBDriverSQLite3
                //driver = &sqlite3.SQLiteDriver{}
                dataSource = configuration.SQLiteDataSource
        case "postgres":
                //driverType := DBDriverPostgres
                //driver = &pq.Driver{}
                dataSource = fmt.Sprintf(
                        "postgresql://%v:%v@%v:%v/%v?%v",
                        configuration.PGUsername,
                        configuration.PGPassword,
                        configuration.PGHost,
                        configuration.PGPort,
                        configuration.PGDBName,
                        configuration.PGParams,
                )
        default:
                // neznámý driver
                err := fmt.Errorf("driver %v is not supported", driverName)
                log.Err(err).Msg(canNotConnectToDataStorageMessage)
                return nil, err
        }

        // pokus o inicializaci připojení k databázi
        connection, err := sql.Open(driverName, dataSource)

        // test, zda bylo připojení k databázi úspěšné
        if err != nil {
                log.Err(err).Msg(canNotConnectToDataStorageMessage)
                return nil, err
        }

        return connection, nil
}

// Zobrazení všech záznamů v tabulce "persons"
func displayAllRecords(connection *sql.DB) error {
        // dotaz do databáze
        query := "SELECT id, name, surname FROM persons"
        rows, err := connection.Query(query)

        // test, zda byl SQL příkaz proveden bez chyby
        if err != nil {
                return err
        }

        defer func() {
                // pokud dojde k chybě nebo na konci smyčky, musíme uvolnit prostředky
                if closeErr := rows.Close(); closeErr != nil {
                        log.Error().Err(closeErr).Msg(unableToCloseDBRowsHandle)
                }
        }()

        // projít všemi vrácenými řádky
        for rows.Next() {
                var (
                        id      int
                        name    string
                        surname string
                )

                // přečtení dat z jednoho vráceného řádku
                if err := rows.Scan(&id, &name, &surname); err != nil {
                        return err
                }

                // výpis načteného záznamu
                log.Info().Int("ID", id).
                        Str("name", name).
                        Str("surname", surname).
                        Msg("Record")
        }

        return nil
}

// Vložení nového záznamu do tabulky "persons"
func insertRecord(connection *sql.DB, name string, surname string) (int, error) {
        // provedení SQL příkazu se dvěma parametry
        sqlStatement := "INSERT INTO persons (name, surname) VALUES($1, $2);"
        result, err := connection.Exec(sqlStatement, name, surname)

        // test, zda byl SQL příkaz proveden bez chyby
        if err != nil {
                return 0, err
        }

        // přečíst počet řádků v tabulce, které byly SQL příkazem upraveny
        affected, err := result.RowsAffected()

        // i tato operace může teoreticky skončit s chybou nebo nemusí být podporována
        if err != nil {
                return 0, err
        }
        return int(affected), nil
}

// Vymazání záznamu nebo záznamů na základě zapsaného jména
func deleteByName(connection *sql.DB, name string) (int, error) {
        // provedení SQL příkazu s jedním parametrem
        sqlStatement := "DELETE FROM persons WHERE name = $1;"
        result, err := connection.Exec(sqlStatement, name)

        // test, zda byl SQL příkaz proveden bez chyby
        if err != nil {
                return 0, err
        }

        // přečíst počet řádků v tabulce, které byly SQL příkazem upraveny
        affected, err := result.RowsAffected()

        // i tato operace může teoreticky skončit s chybou nebo nemusí být podporována
        if err != nil {
                return 0, err
        }
        return int(affected), nil
}

func main() {
        // nastavit logovací systém pro barevný výstup na terminál
        log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr})

        // konfigurace připojení do databáze
        config := StorageConfiguration{
                Driver:     "postgres",
                PGUsername: "postgres",
                PGPassword: "postgres",
                PGHost:     "localhost",
                PGPort:     5432,
                PGDBName:   "testdb",
                PGParams:   "sslmode=disable",
        }

        log.Debug().Msg("Started")

        // inicializace připojení k databázi
        connection, err := initDatabaseConnection(config)
        if err != nil {
                log.Err(err).Msg(connectionToDBNotEstablished)
                return
        }

        // přečtení všech záznamů z tabulky "persons"
        err = displayAllRecords(connection)
        if err != nil {
                log.Err(err).Msg(databaseOperationFailed)
                return
        }

        // vymazání záznamu či záznamů na základě zapsaného jména
        affected, err := deleteByName(connection, "Eda")
        if err != nil {
                log.Err(err).Msg(databaseOperationFailed)
                return
        }
        log.Info().Int("deleted rows", affected).Msg("DELETE")

        // přidání nového záznamu do databáze
        affected, err = insertRecord(connection, "Eda", "Vodopád")
        if err != nil {
                log.Err(err).Msg(databaseOperationFailed)
                return
        }
        log.Info().Int("inserted rows", affected).Msg("INSERT")

        // přečtení všech záznamů z tabulky "persons"
        err = displayAllRecords(connection)
        if err != nil {
                log.Err(err).Msg(databaseOperationFailed)
                return
        }

        log.Debug().Msg("Finished")
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. </h2>



<p><a name="k05"></a></p>
<h2 id="k05">5. </h2>

<p>Tvorba testů, ať již testů jednotkových, integračních, výkonnostních atd., je v&nbsp;současnosti prakticky nedílnou součástí vývoje nových informačních systémů. I z&nbsp;tohoto důvodu se v&nbsp;nabídce standardních nástrojů jazyka Go nachází i nástroj určený pro spouštění jednotkových testů (<i>unit tests</i>) s&nbsp;vyhodnocením jejich výsledků, zjištěním, která část zdrojových kódů je jednotkovými testy pokryta atd. V&nbsp;souvislosti s&nbsp;jednotkovými testy je mnohdy nutné určité části programu nahradit jejich zjednodušenými (umělými) variantami, které se nazývají <i>mock</i>. Nástroj či knihovnu pro <i>mockování</i> sice přímo v&nbsp;základní sadě nástrojů Go nenalezneme (lze ji doinstalovat), ovšem jak si ukážeme v&nbsp;navazujících kapitolách, je většinou možné si vystačit s&nbsp;možnostmi poskytovanými samotným programovacím jazykem (zejména se to týká využití rozhraní &ndash; <i>interface</i>).</p>

<p>Jak jsme si již řekli v&nbsp;úvodním odstavci této kapitoly, obsahuje standardní instalace programovacího jazyka Go i knihovnu určenou pro psaní jednotkových testů. Tato knihovna se jmenuje <strong>testing</strong> a základní informace o ní získáme stejným způsobem, jako je tomu v&nbsp;případě všech dalších knihoven či balíčků &ndash; příkazem <strong>go doc</strong>. Zde konkrétně následujícím způsobem:</p>

<pre>
$ <strong>go doc testing</strong>
&nbsp;
package testing // import "testing"
&nbsp;
Package testing provides support for automated testing of Go packages. It is
intended to be used in concert with the ``go test'' command, which automates
execution of any function of the form
&nbsp;
    func TestXxx(*testing.T)
&nbsp;
where Xxx does not start with a lowercase letter. The function name serves
to identify the test routine.
...
...
...
</pre>

<p>Samotná implementace jednotkových testů je představována běžnými funkcemi, jejichž jména začínají na <strong>Test</strong> a akceptují parametr typu <strong>*testing.T</strong>, tj.&nbsp;ukazatel na strukturu obsahující informace o kontextu, ve kterém jsou jednotlivé testy spouštěny:</p>

<pre>
type <strong>T</strong> struct {
        common <i>// další struktura s informacemi o času spuštění testu atd. atd.</i>
        isParallel bool
        context    *testContext <i>// For running tests and subtests.</i>
}
</pre>

<p>Důležité je, že existuje množství metod pro strukturu <strong>testing.T</strong>, které jsou použity právě při tvorbě jednotkových testů. Jedná se především o tyto metody:</p>

<table>
<tr><th>#</th><th>Metoda</th><th>Stručný popis metody</th></tr>
<tr><td>1</td><td>Error</td><td>provede se zalogování chyby a funkce s&nbsp;testem se označí příznakem &bdquo;chyba&ldquo;</td></tr>
<tr><td>2</td><td>Fail</td><td>funkce s&nbsp;testem se označí příznakem &bdquo;chyba&ldquo;</td></tr>
<tr><td>3</td><td>FailNow</td><td>dtto, ovšem současně se příslušná funkce i ukončí</td></tr>
<tr><td>4</td><td>Log</td><td>zalogování zprávy, typicky s&nbsp;informací o chybě</td></tr>
<tr><td>5</td><td>Fatal</td><td>odpovídá kombinaci volání funkcí <strong>Log</strong>+<strong>FailNow</strong></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: typicky tedy ve funkcích <strong>TestXXX</strong> nalezneme volání metody <strong>Error</strong> nebo <strong>Fatal</strong>, podle toho, zda se má celá testovací funkce ukončit či nikoli.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>

<p>Již v&nbsp;dokumentaci je zmíněno, jakým způsobem se mají jednotkové testy tvořit, ovšem jedná se o tak důležité téma, že se mu budeme věnovat podrobněji v&nbsp;první polovině dnešního článku. Nejprve se podívejme na <a href="https://github.com/tisnik/go-root/blob/master/article_17/tests01/add.go">zdrojový kód</a> obsahující funkci nazvanou <strong>Add</strong>, kterou budeme chtít otestovat. Kód funkce <strong>Add</strong> i příslušné funkce <strong>main</strong> je uložen v&nbsp;souboru pojmenovaném &bdquo;add.go&ldquo;:</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>DATA-DOG / go-sqlmock repository<br />
<a href="https://github.com/DATA-DOG/go-sqlmock">https://github.com/DATA-DOG/go-sqlmock</a>
</li>

<li>Sql driver mock for Golang<br />
<a href="https://pkg.go.dev/github.com/DATA-DOG/go-sqlmock?utm_source=godoc">https://pkg.go.dev/github.com/DATA-DOG/go-sqlmock?utm_source=godoc</a>
</li>

<li>The fantastic ORM library for Golang<br />
<a href="http://gorm.io/">http://gorm.io/</a>
</li>

<li>Package sql<br />
<a href="https://golang.org/pkg/database/sql/">https://golang.org/pkg/database/sql/</a>
</li>

<li>Go database/sql tutorial<br />
<a href="http://go-database-sql.org/">http://go-database-sql.org/</a>
</li>

<li>SQLDrivers<br />
<a href="https://github.com/golang/go/wiki/SQLDrivers">https://github.com/golang/go/wiki/SQLDrivers</a>
</li>

<li>Package testing<br />
<a href="https://golang.org/pkg/testing/">https://golang.org/pkg/testing/</a>
</li>

<li>Golang basics - writing unit tests<br />
<a href="https://blog.alexellis.io/golang-writing-unit-tests/">https://blog.alexellis.io/golang-writing-unit-tests/</a>
</li>

<li>An Introduction to Programming in Go / Testing<br />
<a href="https://www.golang-book.com/books/intro/12">https://www.golang-book.com/books/intro/12</a>
</li>

<li>An Introduction to Testing in Go<br />
<a href="https://tutorialedge.net/golang/intro-testing-in-go/">https://tutorialedge.net/golang/intro-testing-in-go/</a>
</li>

<li>Advanced Go Testing Tutorial<br />
<a href="https://tutorialedge.net/golang/advanced-go-testing-tutorial/">https://tutorialedge.net/golang/advanced-go-testing-tutorial/</a>
</li>

<li>GoConvey<br />
<a href="http://goconvey.co/">http://goconvey.co/</a>
</li>

<li>Testing Techniques<br />
<a href="https://talks.golang.org/2014/testing.slide">https://talks.golang.org/2014/testing.slide</a>
</li>

<li>5 simple tips and tricks for writing unit tests in #golang<br />
<a href="https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742">https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

