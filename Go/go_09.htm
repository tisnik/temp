<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Užitečné balíčky pro každodenní použití jazyka Go</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Užitečné balíčky pro každodenní použití jazyka Go</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku o programovacím jazyce Go se seznámíme s některými užitečnými knihovnami. Kromě základních knihoven (práce s řetězci atd.) si ukážeme některé možnosti nabízené knihovnou nazvanou GoDS neboli Go Data Structures.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Užitečné balíčky pro každodenní použití jazyka Go</a></p>
<p><a href="#k02">2. Získání seznamu nainstalovaných balíčků</a></p>
<p><a href="#k03">3. Použití webového prohlížeče pro získání podrobnějších informací o balíčcích</a></p>
<p><a href="#k04">4. Instalace externího balíčku</a></p>
<p><a href="#k05">5. Použití nově nainstalovaného balíčku</a></p>
<p><a href="#k06">6. Funkce pro konverzi řetězců na pravdivostní hodnotu</a></p>
<p><a href="#k07">7. Konverze řetězců na číselné hodnoty</a></p>
<p><a href="#k08">8. Převod popř.&nbsp;naformátování celočíselné hodnoty na řetězec</a></p>
<p><a href="#k09">9. Převod hodnoty s&nbsp;plovoucí čárkou na řetězec</a></p>
<p><a href="#k10">10. Obecné formátování hodnot s&nbsp;jejich uložením do řetězce (<strong>Sprintf</strong>)</a></p>
<p><a href="#k11">11. Kontejnery implementované ve standardní knihovně</a></p>
<p><a href="#k12">12. Základní operace se seznamy</a></p>
<p><a href="#k13">13. Praktičtější příklad: použití seznamů ve funkci zásobníku pro implementaci RPN</a></p>
<p><a href="#k14">14. Externí knihovna GoDS (Go Data Structures)</a></p>
<p><a href="#k15">15. Datová struktura <strong>arraylist</strong>, jednosměrně a obousměrně vázané seznamy</a></p>
<p><a href="#k16">16. Implementace zásobníků, přepis a vylepšení příkladu s&nbsp;implementací RPN</a></p>
<p><a href="#k17">17. Množiny, implementace Eratosthenova síta</a></p>
<p><a href="#k18">18. Stromy, struktura Red-Black tree</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Užitečné balíčky pro každodenní použití jazyka Go</h2>

<p>V&nbsp;předchozích částech <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">tohoto seriálu</a>
jsme se zaměřili především na popis samotného jazyka Go a později i na způsob
vytváření a použití nových balíčků (<i>packages</i>). Mnoho demonstračních
příkladů používalo některé základní balíčky, které jsou součástí instalace
samotného jazyka Go a jeho základní sady nástrojů. Jednalo se především o
balíčky <a href="https://golang.org/pkg/fmt/">fmt</a>, <a
href="https://golang.org/pkg/math/">math</a> a <a
href="https://golang.org/pkg/time/">time</a> (připomeňme si, že je zvykem, aby
názvy balíčků byly jednoslovní a aby byly zapisovány malými písmeny).
V&nbsp;praxi je ovšem většinou nutné použít i mnohé další balíčky, a to jak
balíčky ze standardní knihovny programovacího jazyka Go, tak i externí balíčky,
které implementují další funkcionalitu. Dnes se s&nbsp;některými užitečnými a
často používanými balíčky seznámíme. Již na úvod je nutné poznamenat, že se
(alespoň prozatím) zaměříme na instalaci a správu balíčků s&nbsp;využitím
základních nástrojů jazyka Go. Použitím pokročilejších správců balíčků se
budeme zabývat v&nbsp;samostatném článku.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Získání seznamu nainstalovaných balíčků</h2>

<p>Seznam základních balíčků patřících do standardní knihovny jazyka Go
nalezneme i s&nbsp;jejich popisem na stránce <a
href="https://golang.org/pkg/">https://golang.org/pkg/</a>. Povšimněte si, že
balíčky jsou rozděleny do několika kategorií, ovšem prakticky vždy se jedná o
základní funkcionalitu (práce se sítí, balíčky umožňující vytvoření HTTP
serveru, zpracování datových struktur, volání funkcí operačního systému,
kryptografické a hešovací funkce, podpora pro práci s&nbsp;několika rastrovými
formáty apod.). Nenajdeme zde tedy například knihovny pro tvorbu grafického
uživatelského rozhraní, multimediální funkce, či zpracování XML (kromě
jednoduchého parseru představovaného balíčkem <a
href="https://golang.org/pkg/encoding/xml/">encoding/xml</a>). V&nbsp;případě,
že budete potřebovat získat seznam <i>aktuálně</i> nainstalovaných balíčků na
vašem systému, je pro tento účel možné použít prostředky nabízené vlastním
jazykem Go a jeho základní sady nástrojů.</p>

<p>Základním příkazem, který můžeme pro tento účel použít, je příkaz <strong>go
list</strong>. Nápovědu k&nbsp;tomuto příkazu získáme následujícím
způsobem:</p>

<pre>
$ <strong>go help list</strong>
&nbsp;
usage: go list [-f format] [-json] [-m] [list flags] [build flags] [packages]
...
...
...
</pre>

<p><div class="rs-tip-major">Poznámka: pozor na velký rozdíl mezi příkazem
<strong>go help list</strong>, který zobrazí nápovědu k&nbsp;příkazu <strong>go
list</strong> a příkazem <strong>go doc list</strong>, jenž zobrazí nápovědu
k&nbsp;balíčku <strong>list</strong>.</div></p>

<p>Ukažme si nyní několik praktických příkladů. Pro výpis všech balíčků
použijte následující příkaz:</p>

<pre>
$ <strong>go list ...</strong>
</pre>

<p>popř.&nbsp;alternativně:</p>

<pre>
$ <strong>go list all</strong>
</pre>

<p>V&nbsp;našem případě (čistá instalace Go + několik testovacích balíčků) by
měl výstup vypadat takto &ndash; nejdříve se vypíšou balíčky ze standardní
knihovny a po nich šest balíčků, které jsme vytvořili minule:</p>

<pre>
&nbsp;
archive/tar
archive/zip
bufio
bytes
cmd/addr2line
cmd/api
cmd/asm
...
...
...
hello1
hello2
hello3
hello4
say_hello_1
say_hello_2
</pre>

<p><div class="rs-tip-major">Poznámka: tři tečky ve specifikaci balíčků se
chovají podobně, jako znak * v&nbsp;názvech souborů, tj.&nbsp;nahrazují nějakou
sekvenci znaků. Díky tomu, že tři tečky nemají v&nbsp;shellu žádný speciální
význam, nemusíme se starat o jejich uvození speciálními znaky či o uzavírání do
uvozovek, abychom zabránili jejich expanzi shellem.</div></p>

<p>U tohoto příkazu je dokonce možné specifikovat formát výstupu a tím i
ovlivnit, jaké informace se zobrazí na standardním výstupu. Následující příkaz
zobrazí napřed název balíčku (i s&nbsp;cestou) a poté seznam všech dalších
balíčků, které jsou explicitně importovány:</p>

<pre>
$ <strong>go list -f "{{.ImportPath}} {{.Imports}}" all</strong>
&nbsp;
archive/tar [bytes errors fmt io io/ioutil math os os/user path reflect runtime sort strconv strings sync syscall time]
archive/zip [bufio compress/flate encoding/binary errors fmt hash hash/crc32 io io/ioutil os path strings sync time unicode/utf8]
bufio [bytes errors io unicode/utf8]
...
...
...
</pre>

<p>V&nbsp;případě, že upravíme balíček <strong>say_hello</strong> takovým
způsobem, aby obsahoval:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        fmt.Println("Hello world #1!")
}
</pre>

<p>Projeví se tato změna ihned i ve výpisu balíčků:</p>

<pre>
$ <strong>go list -f "{{.ImportPath}} {{.Imports}}" say_hello_...</strong>
&nbsp;
say_hello_1 [fmt]
say_hello_2 []
</pre>

<p>Všechny závislosti (tedy nikoli jen přímo importované balíčky), lze vypsat
například takto:</p>

<pre>
$ <strong>go list -f "{{.ImportPath}} {{.Deps}}" say_hello_...</strong>
&nbsp;
say_hello_1 [errors fmt internal/bytealg internal/cpu internal/poll internal/race internal/syscall/unix internal/testlog io math math/bits os reflect runtime runtime/internal/atomic runtime/internal/sys strconv sync sync/atomic syscall time unicode unicode/utf8 unsafe]
say_hello_2 [internal/bytealg internal/cpu runtime runtime/internal/atomic runtime/internal/sys unsafe]
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě jsou závislosti
hledány rekurzivně.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Použití webového prohlížeče pro získání podrobnějších informací o balíčcích</h2>

<p>Existuje ještě jedna možnost, jak se dozvědět podrobnější informace o
nainstalovaných balíčcích. Můžeme si totiž lokálně spustit webový (HTTP)
server, který nám zpřístupní veškerou automaticky generovanou dokumentaci.
Samotné spuštění serveru je jednoduché:</p>

<pre>
$ <strong>godoc --http :8080</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: na uvedeném portu 8080 by samozřejmě
neměla běžet jiná služba. Pokud tedy dojde k&nbsp;této chybě:</div></p>

<pre>
2019/01/22 21:21:40 ListenAndServe :8080: listen tcp :8080: bind: address already in use
</pre>

<p><div class="rs-tip-major">můžete vyzkoušet použít jiný port (typicky větší
než 1024, protože porty s&nbsp;nižšími čísly vyžadují vyšší
oprávnění).</div></p>

<p>Následně ve webovém prohlížeči otevřete adresu <a
href="http://localhost:8080/pkg">http://localhost:8080/pkg</a>. Pro
jednoduchost můžeme zůstat v&nbsp;terminálu a použít <strong>Lynx</strong> nebo
<strong>Links</strong>:</p>

<pre>
   The Go Programming Language
   Go
   ▽
   Documents Packages The Project Help Blog ____________________ (BUTTON)
&nbsp;
Packages
&nbsp;
   Standard library
   Third party
   Other packages
          Sub-repositories
          Community
&nbsp;
Standard library ▹
&nbsp;
Standard library ▾
&nbsp;
   Name Synopsis
   archive
   tar Package tar implements access to tar archives.
   zip Package zip provides support for reading and writing ZIP archives.
</pre>

<a href="https://www.root.cz/obrazek/350992/"><img src="https://i.iinfo.cz/images/538/golang-09-1-prev.png" class="image-350992" alt="&#160;" width="320" height="270" /></a>
<p><i>Obrázek 1: Zobrazení automaticky vygenerované stránky se seznamem
balíčků.</i></p>

<p>Na vygenerované stránce nalezneme i seznam balíčků, které jsme vytvořili
v&nbsp;rámci předchozího článku. Ovšem jak je patrné, nejsou tyto balíčky
rozumně zdokumentovány:</p>

<pre>
Third party ▾
&nbsp;
       Name    Synopsis
   hello1
   hello2
   hello3
   hello4
   say_hello_1
   say_hello_2
&nbsp;
Other packages
&nbsp;
Sub-repositories
&nbsp;
   These packages are part of the Go Project but outside the main Go tree.
   They are developed under looser compatibility requirements than the Go
   core. Install them with "go get".
</pre>

<a href="https://www.root.cz/obrazek/350993/"><img src="https://i.iinfo.cz/images/538/golang-09-2-prev.png" class="image-350993" alt="&#160;" width="320" height="270" /></a>
<p><i>Obrázek 2: Zobrazení balíčků &bdquo;třetích stran&ldquo;, což jsou
v&nbsp;tomto okamžiku balíčky, které jsme vytvořili v&nbsp;rámci předchozího
článku.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instalace a použití externího balíčku</h2>

<p>Nyní si ukážeme, jakým způsobem je vlastně možné nainstalovat nějaký externí
balíček. Použijeme přitom pouze základní nástroje, které byly nainstalovány
společně s&nbsp;překladačem a základními knihovnami programovacího jazyka Go.
Balíčky se budou instalovat do adresářové struktury, na níž ukazuje proměnná
<strong>$GOPATH</strong>, což je typicky adresář <strong>~/go</strong>. Tento
adresář by měl vypadat zhruba následovně:</p>

<pre>
├── bin
├── pkg
└── src
    ├── hello1
    │   └── hello1.go
    ├── hello2
    │   └── hello1.go
    ├── hello3
    │   └── hello1.go
    ├── hello4
    │   └── hello4.go
    ├── say_hello_1
    │   └── hello.go
    └── say_hello_2
        └── hello.go
&nbsp;
9 directories, 6 files
</pre>

<p>Vidíme, že se v&nbsp;adresáři &ndash; alespoň prozatím &ndash; nachází pouze
balíčky vytvořené z&nbsp;demonstračních příkladů popsaných <a
href="https://www.root.cz/clanky/tvorba-balicku-a-pokrocilejsi-operace-s-kanaly-v-jazyce-go/">v&nbsp;předchozí
části</a> <a href="https://www.root.cz/serialy/programovaci-jazyk-go/">tohoto
seriálu</a>.</p>

<p>Pokud například budeme potřebovat vypočítat <a
href="https://cs.wikipedia.org/wiki/Leven%C5%A1tejnova_vzd%C3%A1lenost">Levenštejnovu
vzdálenost dvou řetězců</a> (což se provádí poměrně často například při
implementaci uživatelsky přívětivé funkce <i>Search</i>), můžeme pro tento účel
použít knihovnu/balíček s&nbsp;názvem <strong>levenshtein</strong> a
s&nbsp;cestou <strong>github.com/agext/levenshtein</strong>, která je dostupná
na GitHubu, konkrétně na adrese <a
href="https://github.com/agext/levenshtein">https://github.com/agext/levenshtein</a>
(součástí plné cesty balíčku je skutečně i &bdquo;github.com&ldquo;).</p>

<p><div class="rs-tip-major">Mimochodem &ndash; odkazy na tuto a další knihovny
naleznete na stránce <a
href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go</a>,
která samozřejmě neobsahuje všechny balíčky, které pro Go vznikly, ale pouze
okomentované a odzkoušené knihovny (neměl by se zde tedy vyskytnout žádný
&bdquo;odpad&ldquo; ani potenciálně škodlivé knihovny).</p></div></p>

<p>Balíček <strong>agext/levenshtein</strong> se instaluje velmi snadno, a to
příkazem <strong>go get</strong>, kterému předáme jméno repositáře
s&nbsp;balíčkem (ovšem vynechá se protokol!):</p>

<pre>
$ <strong>go get github.com/agext/levenshtein</strong>
</pre>

<p>Pokud chcete vidět, jaké operace se provádí, přidejte přepínač
<strong>-v</strong>:</p>

<pre>
$ <strong>go get -v github.com/agext/levenshtein</strong>
&nbsp;
github.com/agext/levenshtein (download)
</pre>

<p>Nyní by měla adresářová struktura <strong>~/go</strong> (přesněji řečeno
adresář, na který ukazuje proměnná prostředí <strong>$GOPATH</strong>) vypadat
zhruba následovně:</p>

<pre>
.
├── bin
├── pkg
│   └── linux_amd64
│       └── github.com
│           └── agext
│               └── levenshtein.a
└── src
    ├── github.com
    │   └── agext
    │       └── levenshtein
    │           ├── DCO
    │           ├── levenshtein.go
    │           ├── levenshtein_test.go
    │           ├── LICENSE
    │           ├── MAINTAINERS
    │           ├── NOTICE
    │           ├── params.go
    │           ├── params_test.go
    │           └── README.md
    ├── hello1
    │   └── hello1.go
    ├── hello2
    │   └── hello1.go
    ├── hello3
    │   └── hello1.go
    ├── hello4
    │   └── hello4.go
    ├── say_hello_1
    │   └── hello.go
    └── say_hello_2
        └── hello.go
&nbsp;
15 directories, 16 files
</pre>

<p>Povšimněte si, že se balíček nainstaloval jak do podadresáře
<strong>src</strong> (vlastní zdrojové kódy, testy, licence, další
dokumentace), tak i do podadresáře <strong>pkg</strong> (binární knihovna
určená pro slinkování s&nbsp;kódem výsledných aplikací). Po instalaci je
součástí cesty k&nbsp;balíčku skutečně i prefix <strong>github.com</strong>,
protože zdrojové kódy balíčku leží v&nbsp;podadresáři
<strong>src/github.com/agext/levenshtein</strong>.</p>

<p>Příkaz <strong>go list</strong> by nyní měl ukázat informace i o nově
nainstalované knihovně <strong>agext/levenshtein</strong>:</p>

<pre>
$ <strong>go list ...</strong>
&nbsp;
...
...
...
github.com/agext/levenshtein
...
...
...
</pre>

<p>Podobně uvidíme základní informace o balíčku i na dynamicky generovaných
stránkách s&nbsp;dokumentací:</p>

<a href="https://www.root.cz/obrazek/350994/"><img src="https://i.iinfo.cz/images/538/golang-09-3-prev.png" class="image-350994" alt="&#160;" width="320" height="270" /></a>
<p><i>Obrázek 3: Automaticky vygenerované stránky s&nbsp;dokumentací
k&nbsp;balíčku <strong>github.com/agext/levenshtein</strong>.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Použití nově nainstalovaného balíčku</h2>

<p>Po instalaci balíčku si můžeme zobrazit jeho nápovědu, a to opět přímo na
příkazovém řádku:</p>

<pre>
$ <strong>go doc levenshtein</strong>
</pre>

<p>Začátek nápovědy pro celý balíček:</p>

<pre>
package levenshtein // import "github.com/agext/levenshtein"
&nbsp;
Package levenshtein implements distance and similarity metrics for strings,
based on the Levenshtein measure.
&nbsp;
The underlying `Calculate` function is also exported, to allow the building
of other derivative metrics, if needed.
&nbsp;
func Calculate(str1, str2 []rune, maxCost, insCost, subCost, delCost int) (dist, prefixLen, suffixLen int)
func Distance(str1, str2 string, p *Params) int
func Match(str1, str2 string, p *Params) float64
func Similarity(str1, str2 string, p *Params) float64
type Params struct{ ... }
    func NewParams() *Params
</pre>

<p>Nápovědu si můžeme zobrazit i pro libovolnou exportovanou funkci
popř.&nbsp;pro datový typ (exportují se pouze ty objekty, které začínají velkým
písmenem):</p>

<pre>
$ <strong>go doc levenshtein.Distance</strong>
&nbsp;
package levenshtein // import "github.com/agext/levenshtein"
&nbsp;
func Distance(str1, str2 string, p *Params) int
    Distance returns the Levenshtein distance between str1 and str2, using the
    default or provided cost values. Pass nil for the third argument to use the
    default cost of 1 for all three operations, with no maximum.
</pre>

<p><a
href="https://github.com/tisnik/go-fedora/blob/master/article_09/01_levenshtein.go">V&nbsp;testovacím
příkladu</a> se balíček naimportuje, přičemž při importu musíme použít celou
cestu, a to včetně prefixu &bdquo;github.com&ldquo;. Po importu můžeme zavolat
funkci <strong>levenshtein.Distance()</strong> a zjistit vzdálenost mezi dvěma
řetězci. Posledním parametrem této funkce jsou případné další parametry,
jejichž význam si můžete přečíst v&nbsp;nápovědě (my je ovšem nebudeme
potřebovat ani nastavovat, takže v&nbsp;posledním parametru předáme pouze
<strong>nil</strong>):</p>

<pre>
package main
&nbsp;
import (
        <strong>"github.com/agext/levenshtein"</strong>
)
&nbsp;
func <strong>main</strong>() {
        s1 := "Hello"
        s2 := "hello"
        println(levenshtein.Distance(s1, s2, nil))
&nbsp;
        s1 = "Marta"
        s2 = "Markéta"
        println(levenshtein.Distance(s1, s2, nil))
&nbsp;
        s1 = " foo"
        s2 = "jiný naprosto odlišný text nesouvisející s foo"
        println(levenshtein.Distance(s1, s2, nil))
}
</pre>

<p>Po překladu a spuštění tohoto příkladu by se na standardní výstup měly
vypsat tyto tři Levenštejnovy vzdálenosti:</p>

<pre>
1
2
42
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Funkce pro konverzi řetězců na pravdivostní hodnotu</h2>

<p>Nyní si popíšeme některé často používané funkce, které jsou používány
prakticky dennodenně a které nalezneme ve standardní knihovně programovacího
jazyka Go. Mnohokrát se setkáme s&nbsp;potřebou konvertovat řetězec obsahující
pravdivostní hodnotu zapsanou ve formě textu na skutečnou pravdivostní hodnotu
typu <strong>bool</strong>. K&nbsp;tomuto účelu se používá funkce nazvaná <a
href="https://golang.org/pkg/strconv/#ParseBool">ParseBool</a>, kterou
nalezneme v&nbsp;balíčku <a href="https://golang.org/pkg/strconv/">strconv</a>.
Této funkci se předá řetězec a po konverzi se vrátí dvě hodnoty &ndash; vlastní
pravdivostní hodnota typu <strong>bool</strong> a hodnota typu
<strong>error</strong>, která může nést informace o případné chybě (jak je
zvykem, pokud k&nbsp;chybě nedošlo, vrací se <strong>nil</strong>). Zbývá
doplnit informaci o tom, jak se konkrétně provádí konverze:</p>

<table>
<tr><th>Řetězec</th><th>Výsledek</th></tr>
<tr><td>"true"</td><td>true, error==nil</td></tr>
<tr><td>"True"</td><td>true, error==nil</td></tr>
<tr><td>"TRUE"</td><td>true, error==nil</td></tr>
<tr><td>"t"</td><td>true, error==nil</td></tr>
<tr><td>"T"</td><td>true, error==nil</td></tr>
<tr><td>"1"</td><td>true, error==nil</td></tr>
<tr><td>"false"</td><td>false, error==nil</td></tr>
<tr><td>"False"</td><td>false, error==nil</td></tr>
<tr><td>"FALSE"</td><td>false, error==nil</td></tr>
<tr><td>"f"</td><td>false, error==nil</td></tr>
<tr><td>"F"</td><td>false, error==nil</td></tr>
<tr><td>"0"</td><td>false, error==nil</td></tr>
<tr><td>jiná hodnota</td><td>chyba, error!=nil</td></tr>
</table>

<p>Chování této funkce je tedy snadno pochopitelné, takže si ji odzkoušíme na
<a
href="https://github.com/tisnik/go-fedora/blob/master/article_09/02_string_parsing_bool.go">tomto
demonstračním příkladu</a>:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "strconv"
)
&nbsp;
func <strong>tryToParseBool</strong>(s string) {
        i, err := strconv.ParseBool(s)
        if err == nil {
                fmt.Printf("%t\n", i)
        } else {
                fmt.Printf("%v\n", err)
        }
}
&nbsp;
func <strong>main</strong>() {
        tryToParseBool("true")
        tryToParseBool("True")
        tryToParseBool("TRUE")
        tryToParseBool("T")
        tryToParseBool("t")
        tryToParseBool("false")
        tryToParseBool("False")
        tryToParseBool("FALSE")
        tryToParseBool("F")
        tryToParseBool("f")
        tryToParseBool("Foobar")
        tryToParseBool("0")
        tryToParseBool("1")
        tryToParseBool("no")
        tryToParseBool("")
}
</pre>

<p>Po překladu a spuštění by se na standardním výstupu měly objevit následující
řádky s&nbsp;výsledky konverze:</p>

<pre>
true
true
true
true
true
false
false
false
false
false
strconv.ParseBool: parsing "Foobar": invalid syntax
false
true
strconv.ParseBool: parsing "no": invalid syntax
strconv.ParseBool: parsing "": invalid syntax
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Konverze řetězců na číselné hodnoty</h2>

<p>Velmi často se v&nbsp;praxi setkáme s&nbsp;nutností získat číselné hodnoty
uložené v&nbsp;řetězcích. Může se například jednat o zpracování vstupů
z&nbsp;příkazové řádky, zpracování zpráv předaných přes sockety atd.
K&nbsp;tomuto účelu nám standardní knihovna programovacího jazyka Go nabízí
několik funkcí, které jsou vypsány v&nbsp;tabulce. Až na poslední funkci
nalezneme ostatní funkce v&nbsp;balíčku <strong>strconv</strong>, podobně jako
výše popsanou funkci <strong>ParseBool</strong>:</p>

<table>
<tr><th>Funkce</th><th>Stručný popis</th></tr>
<tr><td>ParseInt</td><td>převod řetězce na celé číslo se znaménkem, je možné specifikovat základ číselné soustavy</td></tr>
<tr><td>ParseUint</td><td>převod řetězce na celé číslo bez znaménka, opět je možné specifikovat základ číselné soustavy</td></tr>
<tr><td>ParseFloat</td><td>převod řetězce na číslo s&nbsp;plovoucí řádovou čárkou</td></tr>
<tr><td>Atoi</td><td>odpovídá funkci <strong>ParseInt</strong> se základem 10 a bitovou šířkou typu <strong>int</strong></td></tr>
<tr><td>Scanf</td><td>na základě řetězce se specifikací formátu vstupu se snaží ve vstupním řetězci nalézt číselné popř.&nbsp;i další hodnoty</td></tr>
</table>

<p>První funkcí, kterou si popíšeme, je funkce <strong>ParseInt</strong>
sloužící pro převod řetězce na celé číslo se znaménkem, přesněji řečeno na
hodnotu typu <strong>int64</strong> (nikoli <strong>int</strong>). Této funkci
se předávají tři parametry:</p>

<ol>

<li>Samotný řetězec, který se má převést. Pokud řetězec nebude obsahovat pouze
číslice, ale i další znaky, vrátí se (ve druhé návratové hodnotě) příslušná
chyba.</li>

<li>Základ číselné soustavy, ve které je číslo v&nbsp;řetězci zapsáno (od 2 do
36, což je dáno omezením na znaky 0-9 a A-Z). Můžeme použít i hodnotu 0;
v&nbsp;tomto případě se při konverzi budou rozeznávat čísla v&nbsp;desítkové
soustavě, osmičkové soustavě (prefix <strong>0</strong>) a v&nbsp;soustavě
šestnáctkové (prefix <strong>0x</strong>).</li>

<li>Bitovou šířkou výsledku, protože vrácená hodnota je sice typu
<strong>int64</strong>, ovšem mnohdy ji potřebujeme zkonvertovat například na
osmibitové číslo, 32bitové číslo atd.</li>

</ol>

<p>Tato funkce opět vrací dvě hodnoty &ndash; vlastní číslo a informaci o
chybě. Pokud se konverze podařila, bude druhá vrácená hodnota obsahovat
<strong>nil</strong>.</p>

<p>Podívejme se nyní na <a
href="https://github.com/tisnik/go-fedora/blob/master/article_09/03_string_parsing_int.go">jednoduchý
demonstrační příklad</a> s&nbsp;konverzí různých typů řetězců:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "strconv"
)
&nbsp;
func <strong>tryToParseInteger</strong>(s string, base int) {
        i, err := strconv.ParseInt(s, base, 32)
        if err == nil {
                fmt.Printf("%d\n", i)
        } else {
                fmt.Printf("%v\n", err)
        }
}
&nbsp;
func <strong>main</strong>() {
        tryToParseInteger("42", 10)
        tryToParseInteger("42", 0)
        tryToParseInteger("42", 16)
        tryToParseInteger("42", 2)
        tryToParseInteger("42x", 10)
        println()
        tryToParseInteger("-42", 10)
        tryToParseInteger("-42", 0)
        tryToParseInteger("-42", 16)
        tryToParseInteger("-42", 2)
        tryToParseInteger("-42x", 10)
        println()
}
</pre>

<p>Po spuštění a překladu získáme tyto číselné hodnoty (popř.&nbsp;informace o
chybě):</p>

<pre>
42
42
66
strconv.ParseInt: parsing "42": invalid syntax
strconv.ParseInt: parsing "42x": invalid syntax
&nbsp;
-42
-42
-66
strconv.ParseInt: parsing "-42": invalid syntax
strconv.ParseInt: parsing "-42x": invalid syntax
</pre>

<p>K&nbsp;funkci <strong>ParseInt</strong> existuje i její alternativa
pojmenovaná <strong>ParseUint</strong> určená pro převod celých čísel bez
znaménka, konkrétně se vrací hodnoty typu <strong>uint64</strong>. Opět se
podívejme na jednoduchý <a
href="https://github.com/tisnik/go-fedora/blob/master/article_09/04_string_parsing_uint.go">demonstrační
příklad</a>, ve kterém se tato funkce použije:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "strconv"
)
&nbsp;
func <strong>tryToParseUnsignedInteger</strong>(s string, base int) {
        i, err := strconv.ParseUint(s, base, 32)
        if err == nil {
                fmt.Printf("%d\n", i)
        } else {
                fmt.Printf("%v\n", err)
        }
}
&nbsp;
func <strong>main</strong>() {
        tryToParseUnsignedInteger("42", 10)
        tryToParseUnsignedInteger("42", 0)
        tryToParseUnsignedInteger("42", 16)
        tryToParseUnsignedInteger("42", 2)
        tryToParseUnsignedInteger("42x", 10)
        println()
        tryToParseUnsignedInteger("-42", 10)
        tryToParseUnsignedInteger("-42", 0)
        tryToParseUnsignedInteger("-42", 16)
        tryToParseUnsignedInteger("-42", 2)
        tryToParseUnsignedInteger("-42x", 10)
        println()
}
</pre>

<p>Výsledky získané po spuštění tohtoo příklad</p>
<pre>
42
42
66
strconv.ParseUint: parsing "42": invalid syntax
strconv.ParseUint: parsing "42x": invalid syntax

strconv.ParseUint: parsing "-42": invalid syntax
strconv.ParseUint: parsing "-42": invalid syntax
strconv.ParseUint: parsing "-42": invalid syntax
strconv.ParseUint: parsing "-42": invalid syntax
strconv.ParseUint: parsing "-42x": invalid syntax
</pre>

<p>Třetí funkce určená pro získání celočíselné hodnoty z&nbsp;řetězce se
jmenuje <strong>Atoi</strong>. Její chování se podobá podobně pojmenované
céčkovské funkci <a href="https://linux.die.net/man/3/atoi">atoi(3)</a>:
vstupem je pouze řetězec, protože jak základ číselné soustavy, tak i bitová
šířka výsledku jsou pevně nastavené (základ je odvozen od prefixu čísla
v&nbsp;řetězci, šířka odpovídá typu <strong>int</strong>). Funkce je to tedy
velmi jednoduchá na použití, což je ostatně patrné i při pohledu na dnešní <a
href="https://github.com/tisnik/go-fedora/blob/master/article_09/05_string_parsing_atoi.go">pátý
demonstrační příklad</a>:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "strconv"
)
&nbsp;
func <strong>tryToParseInteger</strong>(s string) {
        i, err := strconv.Atoi(s)
        if err == nil {
                fmt.Printf("%d\n", i)
        } else {
                fmt.Printf("%v\n", err)
        }
}
&nbsp;
func <strong>main</strong>() {
        tryToParseInteger("42")
        tryToParseInteger("42x")
        tryToParseInteger("")
        println()
        tryToParseInteger("-42")
        tryToParseInteger("-42x")
        tryToParseInteger("-")
        println()
}
</pre>

<p>Samozřejmě se opět podíváme na výsledky tohoto příkladu:</p>

<pre>
42
strconv.Atoi: parsing "42x": invalid syntax
strconv.Atoi: parsing "": invalid syntax
&nbsp;
-42
strconv.Atoi: parsing "-42x": invalid syntax
strconv.Atoi: parsing "-": invalid syntax
</pre>

<p>Předposlední funkcí z&nbsp;tabulky uvedené na začátku této kapitoly je
funkce <strong>ParseFloat</strong>, která se snaží v&nbsp;řetězci nalézt
textovou reprezentaci číselné hodnoty s&nbsp;desetinnou tečkou
popř.&nbsp;s&nbsp;desítkovým exponentem. Prvním parametrem této funkce je
vstupní řetězec, druhým parametrem pak určení, zda se má provádět konverze
odpovídající typu <strong>float32</strong> nebo <strong>float64</strong>:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "strconv"
)
&nbsp;
func <strong>tryToParseFloat</strong>(s string) {
        i, err := strconv.ParseFloat(s, 32)
        if err == nil {
                fmt.Printf("%f\n", i)
        } else {
                fmt.Printf("%v\n", err)
        }
}
&nbsp;
func <strong>main</strong>() {
        tryToParseFloat("42")
        tryToParseFloat("42.0")
        tryToParseFloat(".5")
        tryToParseFloat("0.5")
        tryToParseFloat("5e10")
        tryToParseFloat(".5e10")
        tryToParseFloat(".5e-5")
        tryToParseFloat("-.5e-5")
        tryToParseFloat("5E10")
        tryToParseFloat(".5E10")
        tryToParseFloat(".5E-5")
        tryToParseFloat("-.5E-5")
}
</pre>

<p>Po spuštění <a
href="https://github.com/tisnik/go-fedora/blob/master/article_09/06_string_parsing_float.go">předchozího
příkladu</a> se můžeme přesvědčit, že všechny vstupní řetězce skutečně
reprezentují hodnoty odpovídající IEEE 754:</p>

<pre>
42.000000
42.000000
0.500000
0.500000
49999998976.000000
5000000000.000000
0.000005
-0.000005
49999998976.000000
5000000000.000000
0.000005
-0.000005
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že u některých hodnot
muselo dojít k&nbsp;uřezání spodních bitů mantisy, protože provádíme konverzi
do <strong>float32</strong>.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Převod popř.&nbsp;naformátování celočíselné hodnoty na řetězec</h2>

<p>Pro zpětný převod celého čísla na řetězec můžeme v&nbsp;tom nejjednodušším
případě (žádné speciální požadavky na výsledné naformátování) použít funkci
<strong>Itoa</strong>, kterou opět nalezneme v&nbsp;balíčku
<strong>strconv</strong>. Použití této funkce je velmi přímočaré, jak je to
ostatně patrné i při pohledu na <a
href="https://github.com/tisnik/go-fedora/blob/master/article_09/07_string_format_itoa.go">další
demonstrační příklad</a>:</p>

<pre>
package main
&nbsp;
import (
        . "strconv"
)
&nbsp;
func <strong>main</strong>() {
        println(Itoa(42))
        println(Itoa(0))
        println(Itoa(-1))
}
</pre>

<p>Výsledkem jsou skutečně řetězce vypsané na standardní výstup (i když nutno
říci, že stejně by se vypsaly i přímo celočíselné hodnoty):</p>

<pre>
42
0
-1
</pre>

<p>Poněkud více možností nám nabízí funkce <strong>FormatInt</strong>, taktéž
z&nbsp;balíčku <strong>strconv</strong>. V&nbsp;této funkci můžeme specifikovat
základ číselné soustavy použité pro konverzi čísla na řetězec. Podporovány jsou
základy od 2 (klasická binární soustava) až po 36, což je opět omezení dané
tím, že jednotlivé cifry budou reprezentovány znaky 0-9 a poté a-z.
V&nbsp;případě, že budete potřebovat použít velká písmena, postačuje výstup
z&nbsp;funkce <strong>FormatInt</strong> předat do funkce
<strong>ToUpper</strong> z&nbsp;balíčku <strong>strings</strong>. Opět se
podívejme na <a
href="https://github.com/tisnik/go-fedora/blob/master/article_09/08_string_format_int.go">příklad</a>,
který funkci <strong>FormatInt</strong> použije:</p>

<pre>
package main
&nbsp;
import (
        . "strconv"
)
&nbsp;
func <strong>main</strong>() {
        value := int64(0xcafebabe)
        for base := 2; base &lt; 36; base++ {
                println(base, FormatInt(value, base))
        }
}
</pre>

<p>Výsledkem běhu tohoto programu jsou všechny možné reprezentace desítkové
hodnoty 3405691582 (neboli 0xcafebabe šestnáctkově):</p>

<pre>
2 11001010111111101011101010111110
3 22210100102001120021
4 3022333223222332
5 23433324112312
6 1321535442354
7 150252620656
8 31277535276
9 8710361507
10 3405691582
11 1498473547
12 7b06863ba
13 423769627
14 24444d366
15 14decdc07
16 cafebabe
17 851a7gfg
18 5a26a5dg
19 3f781gd7
20 2d45b8j2
21 1ieiebdd
22 180i76ii
23 10032471
24 hjh0inm
25 dnie6d7
26 b0ghb7k
27 8l9b1f7
28 71omia6
29 5l15dnm
30 4k4glmm
31 3ptmepo
32 35ftelu
33 2l0pcr7
34 26whxxg
35 1tti1dr
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Převod hodnoty s&nbsp;plovoucí čárkou na řetězec</h2>

<p>Pro převod hodnot typu <strong>float32</strong> nebo
<strong>float64</strong> na řetězec je možné použít funkci nazvanou
<strong>FormatFloat</strong>. Této funkci se předávají čtyři parametry:</p>

<ol>
<li>převáděná hodnota typu <strong>float64</strong> (užší <strong>float32</strong> je nutné explicitně zkonvertovat)</li>
<li>specifikace formátu: jeden znak 'b', 'e', 'E', 'f', 'g' nebo 'G'</li>
<li>počet číslic za desetinnou tečkou popř.&nbsp;celkový počet číslic mantisy (ovlivňuje šířku výpisu)</li>
<li>bitová šířka 32 nebo 64 bitů, řídí případné zaokrouhlení hodnoty před její konverzí na řetězec</li>
</ol>

<p>Specifikace formátu:</p>

<table>
<tr><th>Znak</th><th>Výsledek</th></tr>
<tr><td>'b'</td><td>-ddddp±ddd (dvojkový exponent)</td></tr>
<tr><td>'e'</td><td>-d.dddde±dd (desítkový exponent)</td></tr>
<tr><td>'E'</td><td>-d.ddddE±dd (desítkový exponent)</td></tr>
<tr><td>'f'</td><td>-ddd.dddd</td></tr>
<tr><td>'g'</td><td>buď 'e' nebo 'f'</td></tr>
<tr><td>'G'</td><td>buď 'E' nebo 'F'</td></tr>
</table>

<p>Funkci <strong>FormatFloat</strong> si samozřejmě opět otestujeme, a to
v&nbsp;následujícím <a
href="https://github.com/tisnik/go-fedora/blob/master/article_09/09_string_format_ftoa.go">demonstračním
příkladu</a>:</p>

<pre>
package main
&nbsp;
import (
        "math"
        . "strconv"
)
&nbsp;
func <strong>main</strong>() {
        value := math.Pi
        println(FormatFloat(value, 'f', 5, 64))
        println(FormatFloat(value, 'f', 10, 64))
        println(FormatFloat(value, 'e', 10, 64))
        println(FormatFloat(value, 'g', 10, 64))
        println(FormatFloat(value, 'b', 10, 64))
&nbsp;
        println()
&nbsp;
        value = 1e20
        println(FormatFloat(value, 'f', 5, 64))
        println(FormatFloat(value, 'f', 10, 64))
        println(FormatFloat(value, 'e', 10, 64))
        println(FormatFloat(value, 'g', 10, 64))
        println(FormatFloat(value, 'b', 10, 64))
&nbsp;
        println()
&nbsp;
        value = 0
        println(FormatFloat(value, 'f', 5, 64))
        println(FormatFloat(value, 'f', 10, 64))
        println(FormatFloat(value, 'e', 10, 64))
        println(FormatFloat(value, 'g', 10, 64))
        println(FormatFloat(value, 'b', 5, 64))
}
</pre>

<p>Výsledkem budou následující řádky vypsané na standardní výstup:</p>

<pre>
3.14159
3.1415926536
3.1415926536e+00
3.141592654
7074237752028440p-51
&nbsp;
100000000000000000000.00000
100000000000000000000.0000000000
1.0000000000e+20
1e+20
6103515625000000p+14
&nbsp;
0.00000
0.0000000000
0.0000000000e+00
0
0p-1074
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Obecné formátování hodnot s&nbsp;jejich uložením do řetězce (<strong>Sprintf</strong>)</h2>

<p>Již mnohokrát jsme se setkali s&nbsp;funkcí <strong>fmt.Printf</strong>,
která slouží pro naformátování hodnot s&nbsp;určením jejich šířky, zarovnání,
umístění znaménka atd. a pro následný výpis těchto hodnot na standardní výstup.
Ovšem jakou funkci máme použít ve chvíli, kdy sice potřebujeme hodnoty
naformátovat, ale potom je například odeslat na webovou stránku, uložit do
souboru atd.? Namísto <strong>fmt.Printf</strong> se v&nbsp;takovém případě
použije funkce <strong>fmt.Sprintf</strong>, což je možná trošku překvapivé,
protože ostatní konverzní funkce nalezneme v&nbsp;balíčku
<strong>strconv</strong> a nikoli <strong>fmt</strong>. Funkce
<strong>fmt.Printf</strong> a <strong>fmt.Sprintf</strong> mají podobné
vlastnosti a stejná pravidla pro formátovací řetězce, takže si dnes bez větších
podrobností pouze ukážeme příklady jejího použití.</p>

<p>Následuje <a
href="https://github.com/tisnik/go-fedora/blob/master/article_09/10_string_format_sprintf.go">demonstrační
příklad ukazující použití funkce <strong>Sprintf</strong>:</a></p>

<pre>
package main
&nbsp;
import (
        . "fmt"
        "math"
)
&nbsp;
func <strong>main</strong>() {
        value := 42
        s := Sprintf("%10d", value)
        println(s)
&nbsp;
        s = Sprintf("%10.5f", math.Pi)
        println(s)
&nbsp;
        s = Sprintf("%10.9f", math.Pi)
        println(s)
&nbsp;
        a := []int{10, 20, 30}
&nbsp;
        s = Sprintf("%v", a)
        println(s)
}
</pre>

<p>Po spuštění tohoto příkladu by se měly zobrazit přesně tyto řádky:</p>

<pre>
        42
   3.14159
3.141592654
[10 20 30]
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Kontejnery implementované ve standardní knihovně</h2>

<p>Se základními datovými strukturami programovacího jazyka Go jsme se již
setkali v&nbsp;předchozích částech tohoto seriálu. Připomeňme si, že Go
podporuje jeden typ lineární kolekce (neboli kontejneru) a tím je pole
(<i>array</i>) tvořící základ pro řezy (<i>slice</i>). Teoreticky je možné do
této skupiny počítat i kanály, které při vhodném použití nahradí frontu
(<i>queue</i>), ovšem další typy kolekcí/kontejnerů přímo v&nbsp;programovacím
jazyku nenalezneme. Některé alespoň základní typy kontejnerů je však možné
najít v&nbsp;základní knihovně jazyka Go. Jedná se o tyto balíčky:</p>

<table>
<tr><th>Balíček</th><th>Implementovaná datová struktura/kontejner</th></tr>
<tr><td><a href="https://golang.org/pkg/container/list/">container/list</a></td><td>obousměrně vázaný seznam</td></tr>
<tr><td><a href="https://golang.org/pkg/container/heap/">container/heap</a></td><td>halda (lze použít například pro implementaci prioritní fronty)</td></tr>
<tr><td><a href="https://golang.org/pkg/container/ring/">container/ring</a></td><td>cyklická fronta</td></tr>
</table>

<p>Do těchto kontejnerů se ukládají prvky typu <strong>interface{}</strong>,
což v&nbsp;programovacím jazyku Go de facto znamená &bdquo;hodnoty neznámého
typu&ldquo;. Pokud z&nbsp;kontejneru nějakou hodnotu přečteme, musí se většinou
explicitně specifikovat, jaký typ prvků očekáváme. K&nbsp;tomuto účelu se
v&nbsp;Go používají takzvané <a
href="https://golang.org/ref/spec#Type_assertions">typové aserce</a>, které se
zapisují následujícím způsobem:</p>

<pre>
i := x.(T)
&nbsp;
i, ok := x.(T)
</pre>

<p>kde se za <strong>T</strong> doplní konkrétní datový typ, například
<strong>int</strong> nebo <strong>string</strong>. Ve druhém případě se do nové
proměnné <strong>ok</strong> zapíše pravdivostní hodnota značící, zda se
operace provedla či nikoli.</p>

<p><div class="rs-tip-major">Poznámka: typové aserce slouží ke kontrole za běhu
programu (<i>runtime</i>). V&nbsp;případě, že konverzi na požadovaný datový typ
není možné provést, vznikne výjimka.</div></p>

<p>Příklad použití, zde konkrétně ukázaný na příkladu obousměrně vázaného
seznamu:</p>

<pre>
l := list.New()
l.PushBack(42)
i := l.Front().Value<strong>.(int)</strong>
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Základní operace se seznamy</h2>

<p>Ukažme si nyní jednoduchý demonstrační příklad, na němž si vysvětlíme
základní operace se seznamy. V&nbsp;tomto příkladu se seznam zkonstruuje
takto:</p>

<pre>
l := list.New()
</pre>

<p>Povšimněte si, že není nutné (a vlastně ani možné) specifikovat typ položek
seznamu!</p>

<pre>
l.PushBack("foo")
l.PushBack("bar")
l.PushBack("baz")
</pre>

<p><div class="rs-tip-major">Poznámka: obě metody
<strong>List.PushBack</strong> a <strong>List.PushFront</strong> mají
v&nbsp;tomto případě stejnou časovou složitost, protože se jedná o obousměrně
vázaný seznam.</div></p>

<p>Dále se podívejme na způsob implementace průchodu všemi prvky seznamu.
Nejprve získáme ukazatel na první prvek s&nbsp;využitím metody
<strong>List.Front</strong> a následně voláme metodu
<strong>Element.Next</strong> (nikoli <strong>List.Next</strong>!) tak dlouho,
až dojdeme na konec seznamu. Datový typ <strong>Element</strong> je definován
jako struktura obalující hodnotu <strong>Value</strong> typu
<strong>interface{}</strong>. A hodnotu tohoto typu můžeme snadno vytisknout
s&nbsp;využitím <strong>fmt.Println</strong>:</p>

<pre>
func <strong>printList</strong>(l *list.List) {
        for e := l.Front(); e != nil; e = e.Next() {
                fmt.Println(e.Value)
        }
}
</pre>

<p>Úplný <a
href="https://github.com/tisnik/go-fedora/blob/master/article_09/11_list.go">zdrojový
kód tohoto příkladu</a> vypadá následovně:</p>

<pre>
package main
&nbsp;
import (
        "container/list"
        "fmt"
)
&nbsp;
func <strong>printList</strong>(l *list.List) {
        for e := l.Front(); e != nil; e = e.Next() {
                fmt.Println(e.Value)
        }
}
&nbsp;
func <strong>main</strong>() {
        l := list.New()
        l.PushBack("foo")
        l.PushBack("bar")
        l.PushBack("baz")
        printList(l)
}
</pre>

<p>Výsledky:</p>

<pre>
foo
bar
baz
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Praktičtější příklad: použití seznamů ve funkci zásobníku pro implementaci RPN</h2>

<p>Obousměrně vázané seznamy je možné využít i ve funkci zásobníku. Stačí se
pouze rozhodnout, který konec seznamu bude sloužit jako vrchol zásobníku
(<i>TOS &ndash; Top of Stack</i>). Pokud zvolíme, že <i>TOS</i> bude ležet na
konci seznamu, můžeme si vytvořit dvě pomocné funkce pro dvě základní operace
se zásobníkem &ndash; <strong>push</strong> a <strong>pop</strong>.
V&nbsp;případě, že zásobník bude obsahovat pouze celá čísla, může implementace
obou zmíněných funkcí vypadat následovně.</p>

<h3>Implementace operace <strong>push</strong></h3>

<pre>
func <strong>push</strong>(l *list.List, number int) {
        l.PushBack(number)
}
</pre>

<h3>Implementace operace <strong>pop</strong></h3>

<pre>
func <strong>pop</strong>(l *list.List) int {
        tos := l.Back()
        l.Remove(tos)
        return tos.Value.(int)
}
</pre>

<p><div class="rs-tip-major">Poznámka: implementace zásobníku s&nbsp;využitím
obousměrně vázaného seznamu nemusí být tím nejlepším řešením s&nbsp;ohledem na
paměťovou a především časovou složitost alokace nových položek.
V&nbsp;navazujících kapitolách bude popsán upravený příklad založený na
knihovně GoDS a datové struktuře <strong>arraylist</strong>, která je pro
implementaci RPN v&nbsp;mnoha směrech lepší.</div></p>

<p>Tento zásobník nyní použijeme pro implementaci jednoduchého kalkulátoru,
který bude pracovat s&nbsp;výrazy zapsanými v&nbsp;obrácené polské notaci
(RPN), kterou jsme se zabývali například v&nbsp;článku <a
href="https://www.root.cz/clanky/programovaci-jazyky-z-vyvojarskeho-pekla-2#k02">Programovací
jazyky z&nbsp;vývojářského pekla++</a>. Samotná implementace vyhodnocení RPN
výrazů je relativně jednoduchá a spočívá v&nbsp;tom, že na zásobník umisťujeme
hodnoty a ve chvíli, kdy se ve výrazu nachází operátor, přečteme ze zásobníku
dvě hodnoty, provedeme příslušnou operaci a na zásobník uložíme výsledek:</p>

<pre>
expression := "1 2 + 2 3 * 8 + *"
terms := strings.Split(expression, " ")
stack := list.New()
&nbsp;
for _, term := range terms {
        switch term {
        case "+":
                operand1 := pop(stack)
                operand2 := pop(stack)
                push(stack, operand1+operand2)
        ...
        ...
        ...
        default:
                number, err := strconv.Atoi(term)
                if err == nil {
                        push(stack, number)
                }
        }
</pre>

<p>Pokud je zapsaný výraz korektní, bude po jeho vyhodnocení na zásobníku
uložena jediná hodnota, a to výsledek celého výrazu:</p>

<pre>
printStack(stack)
</pre>

<p>Následuje výpis <a
href="https://github.com/tisnik/go-fedora/blob/master/article_09/12_list_as_stack.go">úplného
zdrojového kódu</a> tohoto demonstračního příkladu:</p>

<pre>
package main
&nbsp;
import (
        "container/list"
        "fmt"
        "strconv"
        "strings"
)
&nbsp;
type Stack list.List
&nbsp;
func <strong>printStack</strong>(l *list.List) {
        for e := l.Front(); e != nil; e = e.Next() {
                fmt.Println(e.Value)
        }
}
&nbsp;
func <strong>push</strong>(l *list.List, number int) {
        l.PushBack(number)
}
&nbsp;
func <strong>pop</strong>(l *list.List) int {
        tos := l.Back()
        l.Remove(tos)
        return tos.Value.(int)
}
&nbsp;
func <strong>main</strong>() {
        expression := "1 2 + 2 3 * 8 + *"
        terms := strings.Split(expression, " ")
        stack := list.New()

        for _, term := range terms {
                switch term {
                case "+":
                        operand1 := pop(stack)
                        operand2 := pop(stack)
                        push(stack, operand1+operand2)
                case "-":
                        operand1 := pop(stack)
                        operand2 := pop(stack)
                        push(stack, operand2-operand1)
                case "*":
                        operand1 := pop(stack)
                        operand2 := pop(stack)
                        push(stack, operand1*operand2)
                case "/":
                        operand1 := pop(stack)
                        operand2 := pop(stack)
                        push(stack, operand2/operand1)
                default:
                        number, err := strconv.Atoi(term)
                        if err == nil {
                                push(stack, number)
                        }
                }
        }
        printStack(stack)
}
</pre>

<p>Výsledkem by měla být hodnota 42:</p>

<pre>
42
</pre>

<p>Nepatrnou úpravou tohoto programu získáme nástroj, který nejenže daný RPN
výraz vypočítá, ale bude v&nbsp;průběhu výpočtu vypisovat i aktuální obsah
zásobníku. Úprava spočívá v&nbsp;přidání zvýrazněných řádků:</p>

<pre>
package main
&nbsp;
import (
        "container/list"
        "fmt"
        "strconv"
        "strings"
)
&nbsp;
type Stack list.List
&nbsp;
func <strong>printStack</strong>(l *list.List) {
        for e := l.Front(); e != nil; e = e.Next() {
                fmt.Printf("%2d ", e.Value)
        }
        println()
}
&nbsp;
func <strong>push</strong>(l *list.List, number int) {
        l.PushBack(number)
}
&nbsp;
func <strong>pop</strong>(l *list.List) int {
        tos := l.Back()
        l.Remove(tos)
        return tos.Value.(int)
}
&nbsp;
func <strong>main</strong>() {
        expression := "1 2 + 2 3 * 8 + *"
        terms := strings.Split(expression, " ")
        stack := list.New()
&nbsp;
        for _, term := range terms {
                switch term {
                case "+":
                        operand1 := pop(stack)
                        operand2 := pop(stack)
                        push(stack, operand1+operand2)
                        <strong>print("+ :     ")</strong>
                        <strong>printStack(stack)</strong>
                case "-":
                        operand1 := pop(stack)
                        operand2 := pop(stack)
                        push(stack, operand2-operand1)
                        <strong>print("- :     ")</strong>
                        <strong>printStack(stack)</strong>
                case "*":
                        operand1 := pop(stack)
                        operand2 := pop(stack)
                        push(stack, operand1*operand2)
                        <strong>print("* :     ")</strong>
                        <strong>printStack(stack)</strong>
                case "/":
                        operand1 := pop(stack)
                        operand2 := pop(stack)
                        push(stack, operand2/operand1)
                        <strong>print("/ :     ")</strong>
                        <strong>printStack(stack)</strong>
                default:
                        number, err := strconv.Atoi(term)
                        if err == nil {
                                push(stack, number)
                        }
                        <strong>fmt.Printf("%-2d:     ", number)</strong>
                        <strong>printStack(stack)</strong>
                }
        }
        print("Result: ")
        printStack(stack)
}
</pre>

<p>Nyní se na standardní výstup vypisuje stav zásobníku při průběžném
vyhodnocování výrazu. Opět můžeme vidět, že u korektního výrazu se nakonec na
zásobníku objeví jen jediná hodnota:</p>

<pre>
1 :      1 
2 :      1  2 
+ :      3 
2 :      3  2 
3 :      3  2  3 
* :      3  6 
8 :      3  6  8 
+ :      3 14 
* :     42 
Result: 42 
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Externí knihovna GoDS (Go Data Structures)</h2>

<p>Kontejnery (kolekce) nabízené samotným jazykem Go popř.&nbsp;jeho standardní
knihovnou nám v&nbsp;praxi většinou nebudou postačovat, takže bude nutné
sáhnout po externí knihovně. Těch existuje větší množství, ovšem pravděpodobně
nejúplnější sadu kontejnerů nalezneme v&nbsp;knihovně pojmenované <i>GoDS</i>
neboli plným jménem <i>Go Data Structures</i>. Dnes si ukážeme jen základní
možnosti nabízené touto knihovnou, podrobnosti budou uvedeny příště.</p>

<p>Tuto knihovnu nainstalujeme příkazem:</p>

<pre>
$ <strong>go get github.com/emirpasic/gods</strong>
</pre>

<p>Knihovna by se ihned poté měla objevit v&nbsp;adresářové struktuře
odkazované proměnnou <strong>$GOPATH</strong>:</p>

<pre>
.
├── github.com
│   ├── agext
│   │   └── levenshtein
...
...
...
│   └── emirpasic
│       └── gods
│           ├── containers
│           │   ├── containers.go
│           │   ├── containers_test.go
│           │   ├── enumerable.go
│           │   ├── iterator.go
│           │   └── serialization.go
│           ├── examples
│           │   ├── arraylist
│           │   │   └── arraylist.go
...
...
...
│           └── utils
│               ├── comparator.go
│               ├── comparator_test.go
│               ├── sort.go
│               ├── sort_test.go
│               ├── utils.go
│               └── utils_test.go
</pre>

<p>Pro jistotu si ještě vypišme všechny balíčky obsahující
&bdquo;gods&ldquo;:</p>

<pre>
$ <strong>go list ...gods...</strong>
&nbsp;
github.com/emirpasic/gods/containers
github.com/emirpasic/gods/examples/arraylist
github.com/emirpasic/gods/examples/arraystack
...
...
...
github.com/emirpasic/gods/lists
github.com/emirpasic/gods/lists/arraylist
github.com/emirpasic/gods/lists/doublylinkedlist
github.com/emirpasic/gods/lists/singlylinkedlist
github.com/emirpasic/gods/maps
github.com/emirpasic/gods/maps/hashbidimap
github.com/emirpasic/gods/maps/hashmap
github.com/emirpasic/gods/maps/linkedhashmap
github.com/emirpasic/gods/maps/treebidimap
github.com/emirpasic/gods/maps/treemap
github.com/emirpasic/gods/sets
github.com/emirpasic/gods/sets/hashset
github.com/emirpasic/gods/sets/linkedhashset
github.com/emirpasic/gods/sets/treeset
github.com/emirpasic/gods/stacks
github.com/emirpasic/gods/stacks/arraystack
github.com/emirpasic/gods/stacks/linkedliststack
github.com/emirpasic/gods/trees
github.com/emirpasic/gods/trees/avltree
github.com/emirpasic/gods/trees/binaryheap
github.com/emirpasic/gods/trees/btree
github.com/emirpasic/gods/trees/redblacktree
github.com/emirpasic/gods/utils
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Datová struktura <strong>arraylist</strong>, jednosměrně a obousměrně vázané seznamy</h2>

<p>Seznamy popsané rozhraním <strong>List</strong> existují v&nbsp;knihovně
GoDS ve třech implementacích:</p>

<ol>
<li><strong>ArrayList</strong>: seznam postavený nad polem, které se může realokovat</li>
<li><strong>SinglyLinkedList</strong>: lineárně jednosměrně vázaný seznam</li>
<li><strong>DoublyLinkedList</strong>: obousměrně vázaný seznam</li>
</ol>

<p>U všech seznamů máme k&nbsp;dispozici iterátor
(<strong>List.Iterator</strong>), který se používá takto:</p>

<pre>
iterator := list.Iterator()
for iterator.Next() {
        index, value := iterator.Index(), iterator.Value()
        fmt.Printf("item #%d == %s\n", index, value)
}
</pre>

<p><div class="rs-tip-major">Poznámka: samozřejmě pokud nepotřebujeme znát
index (pořadí) prvku, můžeme vynechat volání
<strong>iterator.Index()</strong>.</div></p>

<p>Použití seznamů všech tří typů je snadné, pouze nesmíme zapomenout na
případnou <i>typovou aserci</i>. <a
href="https://github.com/tisnik/go-fedora/blob/master/article_09/13_gods_arraylist.go">Příklad
použití</a> operací <strong>Add</strong>, <strong>Remove</strong> a
<strong>Swap</strong>:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "github.com/emirpasic/gods/lists/arraylist"
)
&nbsp;
func <strong>printList</strong>(list *arraylist.List) {
        iterator := list.Iterator()
        for iterator.Next() {
                index, value := iterator.Index(), iterator.Value()
                fmt.Printf("item #%d == %s\n", index, value)
        }
        fmt.Println()
}
&nbsp;
func <strong>main</strong>() {
        list := arraylist.New()
        list.Add("a")
        list.Add("c", "b")
&nbsp;
        printList(list)
&nbsp;
        list.Swap(0, 1)
        list.Swap(1, 2)
        printList(list)
&nbsp;
        list.Remove(2)
        printList(list)
&nbsp;
        list.Remove(1)
        printList(list)
}
</pre>

<p>Výsledek po spuštění příkladu:</p>

<pre>
item #0 == a
item #1 == c
item #2 == b
&nbsp;
item #0 == c
item #1 == b
item #2 == a
&nbsp;
item #0 == c
item #1 == b
&nbsp;
item #0 == c
</pre>

<p>Prakticky stejným způsobem můžeme napsat program používající <a
href="https://github.com/tisnik/go-fedora/blob/master/article_09/14_gods_singlylinkedlist.go">jednosměrně
vázaný seznam</a>:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        sll "github.com/emirpasic/gods/lists/singlylinkedlist"
)
&nbsp;
func <strong>printList</strong>(list *sll.List) {
        iterator := list.Iterator()
        for iterator.Next() {
                index, value := iterator.Index(), iterator.Value()
                fmt.Printf("item #%d == %s\n", index, value)
        }
        fmt.Println()
}
&nbsp;
func <strong>main</strong>() {
        list := sll.New()
        list.Add("a")
        list.Add("c", "b")
&nbsp;
        printList(list)
&nbsp;
        list.Swap(0, 1)
        list.Swap(1, 2)
        printList(list)
&nbsp;
        list.Remove(2)
        printList(list)
&nbsp;
        list.Remove(1)
        printList(list)
}
</pre>

<p>Výsledek činnosti tohoto programu je odlišný:</p>

<pre>
item #0 == a
item #1 == c
item #2 == b
&nbsp;
item #0 == c
item #1 == b
item #2 == a
&nbsp;
item #0 == c
item #1 == b
&nbsp;
item #0 == c
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Implementace zásobníků, přepis a vylepšení příkladu s&nbsp;implementací RPN</h2>

<p>První variantu RPN kalkulačky, s&nbsp;níž jsme se seznámili <a
href="#k13">ve třinácté kapitole</a> můžeme <a
href="https://github.com/tisnik/go-fedora/blob/master/article_09/15_gods_stack_RPN.go">snadno
přepsat</a> s&nbsp;využitím kontejneru nazvaného <strong>arraystack</strong>,
což je implementace zásobníku realizovaná nad polem (které se v&nbsp;případě
potřeby realokuje). Povšimněte si triku u příkazu <strong>import</strong>,
v&nbsp;níž se na <strong>arraystack</strong> budeme odkazovat přes obecnější
alias <strong>stack</strong>:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        stack "github.com/emirpasic/gods/stacks/arraystack"
        "strconv"
        "strings"
)
&nbsp;
func <strong>printStack</strong>(s *stack.Stack) {
        it := s.Iterator()
        for it.Next() {
                value := it.Value()
                fmt.Printf("%3d ", value)
        }
        println()
}
&nbsp;
func <strong>main</strong>() {
        expression := "1 2 + 2 3 * 8 + *"
        terms := strings.Split(expression, " ")
        stack := stack.New()
&nbsp;
        for _, term := range terms {
                switch term {
                case "+":
                        operand1, _ := stack.Pop()
                        operand2, _ := stack.Pop()
                        stack.Push(operand1.(int) + operand2.(int))
                        print("+ :\t")
                        printStack(stack)
                case "-":
                        operand1, _ := stack.Pop()
                        operand2, _ := stack.Pop()
                        stack.Push(operand2.(int) - operand1.(int))
                        print("- :\t")
                        printStack(stack)
                case "*":
                        operand1, _ := stack.Pop()
                        operand2, _ := stack.Pop()
                        stack.Push(operand1.(int) * operand2.(int))
                        print("* :\t")
                        printStack(stack)
                case "/":
                        operand1, _ := stack.Pop()
                        operand2, _ := stack.Pop()
                        stack.Push(operand2.(int) / operand1.(int))
                        print("/ :\t")
                        printStack(stack)
                default:
                        number, err := strconv.Atoi(term)
                        if err == nil {
                                stack.Push(number)
                        }
                        fmt.Printf("%-2d:\t", number)
                        printStack(stack)
                }
        }
        print("Result: ")
        printStack(stack)
}
</pre>

<p>Při spuštění tohoto příkladu se bude postupně vypisovat obsah zásobníku
operandů:</p>

<pre>
1 :       1 
2 :       2   1 
+ :       3 
2 :       2   3 
3 :       3   2   3 
* :       6   3 
8 :       8   6   3 
+ :      14   3 
* :      42 
Result:  42 
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Množiny, implementace Eratosthenova síta</h2>

<p>Další často používanou datovou strukturou jsou množiny přestavované
rozhraním <strong>Set</strong>. Pro toto rozhraní existují tři
implementace:</p>

<ol>
<li><strong>HashSet</strong>: založeno na hešovacích tabulkách</li>
<li><strong>TreeSet</strong>: založeno na RB-stromech</li>
<li><strong>LinkedHashSet</strong>: zachovává pořadí prvků</li>
</ol>

<p>Jako příklad praktičtějšího použití množin jsem vybral známý algoritmus pro
hledání prvočísel s&nbsp;využitím <a
href="https://cs.wikipedia.org/wiki/Eratosthenovo_s%C3%ADto">Eratosthenova
síta</a>. Samozřejmě existuje mnoho více či méně optimalizovaných implementací
tohoto algoritmu; některé jsou zmíněny na stránce <a
href="https://rosettacode.org/wiki/Sieve_of_Eratosthenes">Rosetta Code</a>. My
si ukážeme tu nejprimitivnější implementaci spočívající v&nbsp;postupném
odstraňování celočíselných násobků prvočísel z&nbsp;množiny, která původně
obsahovala všechna celá čísla od 2 do 1000.</p>

<p><div class="rs-tip-major">Poznámka: z&nbsp;hlediska paměťové složitosti by
bylo lepší použít bitový vektor implementovaný například balíčkem <a
href="https://godoc.org/github.com/golang-collections/go-datastructures/bitarray">bitarray</a>.
Zde se nám ale jedná pouze o ukázání základních  operací
s&nbsp;množinami.</p></div></p>

<p>Následuje <a
href="https://github.com/tisnik/go-fedora/blob/master/article_09/16_gods_set.go">výpis
zdrojového kódu</a> tohoto demonstračního příkladu:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "github.com/emirpasic/gods/sets/linkedhashset"
)
&nbsp;
const maxPrime = 1000
&nbsp;
func <strong>printSet</strong>(set *linkedhashset.Set) {
        iterator := set.Iterator()
        for iterator.Next() {
                index, value := iterator.Index(), iterator.Value()
                fmt.Printf("%3d ", value)
                if index%10 == 9 {
                        fmt.Println()
                }
        }
        fmt.Println()
}
&nbsp;
func <strong>main</strong>() {
        primes := linkedhashset.New()
        for n := 2; n &lt; maxPrime; n++ {
                primes.Add(n)
        }
&nbsp;
        for n := 2; n &lt; maxPrime/2; n++ {
                if primes.Contains(n) {
                        for k := 2 * n; k &lt; maxPrime; k += n {
                                primes.Remove(k)
                        }
                }
        }
        printSet(primes)
}
</pre>

<p>Tento příklad by měl po svém spuštění vypsat všechna prvočísla nalezená
v&nbsp;intervalu 0 až 1000:</p>

<pre>
  2   3   5   7  11  13  17  19  23  29 
 31  37  41  43  47  53  59  61  67  71 
 73  79  83  89  97 101 103 107 109 113 
127 131 137 139 149 151 157 163 167 173 
179 181 191 193 197 199 211 223 227 229 
233 239 241 251 257 263 269 271 277 281 
283 293 307 311 313 317 331 337 347 349 
353 359 367 373 379 383 389 397 401 409 
419 421 431 433 439 443 449 457 461 463 
467 479 487 491 499 503 509 521 523 541 
547 557 563 569 571 577 587 593 599 601 
607 613 617 619 631 641 643 647 653 659 
661 673 677 683 691 701 709 719 727 733 
739 743 751 757 761 769 773 787 797 809 
811 821 823 827 829 839 853 857 859 863 
877 881 883 887 907 911 919 929 937 941 
947 953 967 971 977 983 991 997 
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Stromy, struktura Red-Black tree</h2>

<p>Jako malá reklama na další pokračování tohoto seriálu bude sloužit příklad,
v&nbsp;němž je použita datová struktura pojmenovaná červeno-černý strom neboli
Red-Black Tree, popř.&nbsp;RB-Tree. V&nbsp;příkladu vložíme do stromu několik
dvojic klíč-hodnota a pokaždé si necháme vypsat strukturu stromu:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        rbt "github.com/emirpasic/gods/trees/redblacktree"
)
&nbsp;
func <strong>main</strong>() {
        tree := rbt.NewWithIntComparator()
        fmt.Println(tree)
&nbsp;
        tree.Put(1, "G")
        fmt.Println(tree)
&nbsp;
        tree.Put(2, "a")
        tree.Put(3, "b")
        fmt.Println(tree)
&nbsp;
        tree.Put(4, "a")
        tree.Put(5, "b")
        fmt.Println(tree)
&nbsp;
        tree.Put(6, "a")
        tree.Put(7, "b")
        fmt.Println(tree)
&nbsp;
        tree.Put(8, "a")
        tree.Put(9, "b")
        fmt.Println(tree)
}
</pre>

<p>Po spuštění příkladu se bude postupně vykreslovat tvar stromu, přičemž kořen
je zde umístěn v&nbsp;levém sloupci (stromy se ovšem v&nbsp;informatice obecně
kreslí s&nbsp;kořenem nahoře :-):</p>

<pre>
RedBlackTree
&nbsp;
RedBlackTree
└── 1
&nbsp;
RedBlackTree
│   ┌── 3
└── 2
    └── 1
&nbsp;
RedBlackTree
│       ┌── 5
│   ┌── 4
│   │   └── 3
└── 2
    └── 1
&nbsp;
RedBlackTree
│           ┌── 7
│       ┌── 6
│       │   └── 5
│   ┌── 4
│   │   └── 3
└── 2
    └── 1
&nbsp;
RedBlackTree
│           ┌── 9
│       ┌── 8
│       │   └── 7
│   ┌── 6
│   │   └── 5
└── 4
    │   ┌── 3
    └── 2
        └── 1
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
doslova několik kilobajtů), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_levenshtein.go</td><td>výpočet Levenštejnovy vzdálenosti dvou řetězců</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_09/01_levenshtein.go">https://github.com/tisnik/go-fedora/blob/master/article_09/01_levenshtein.go</a></td></tr>
<tr><td> 2</td><td>02_string_parsing_bool.go</td><td>použití funkce <strong>ParseBool</strong></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_09/02_string_parsing_bool.go">https://github.com/tisnik/go-fedora/blob/master/article_09/02_string_parsing_bool.go</a></td></tr>
<tr><td> 3</td><td>03_string_parsing_int.go</td><td>použití funkce <strong>ParseInt</strong></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_09/03_string_parsing_int.go">https://github.com/tisnik/go-fedora/blob/master/article_09/03_string_parsing_int.go</a></td></tr>
<tr><td> 4</td><td>04_string_parsing_uint.go</td><td>použití funkce <strong>ParseUint</strong></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_09/04_string_parsing_uint.go">https://github.com/tisnik/go-fedora/blob/master/article_09/04_string_parsing_uint.go</a></td></tr>
<tr><td> 5</td><td>05_string_parsing_atoi.go</td><td>použití funkce <strong>Atoi</strong></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_09/05_string_parsing_atoi.go">https://github.com/tisnik/go-fedora/blob/master/article_09/05_string_parsing_atoi.go</a></td></tr>
<tr><td> 6</td><td>06_string_parsing_float.go</td><td>použití funkce <strong>ParseFloat</strong></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_09/06_string_parsing_float.go">https://github.com/tisnik/go-fedora/blob/master/article_09/06_string_parsing_float.go</a></td></tr>
<tr><td> 7</td><td>07_string_format_itoa.go</td><td>převod celého čísla na řetězec</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_09/07_string_format_itoa.go">https://github.com/tisnik/go-fedora/blob/master/article_09/07_string_format_itoa.go</a></td></tr>
<tr><td> 8</td><td>08_string_format_int.go</td><td>naformátování celého čísla</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_09/08_string_format_int.go">https://github.com/tisnik/go-fedora/blob/master/article_09/08_string_format_int.go</a></td></tr>
<tr><td> 9</td><td>09_string_format_ftoa.go</td><td>naformátování čísla s&nbsp;plovoucí řádovou čárkou</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_09/09_string_format_ftoa.go">https://github.com/tisnik/go-fedora/blob/master/article_09/09_string_format_ftoa.go</a></td></tr>
<tr><td>10</td><td>10_string_format_sprintf.go</td><td>univerzální formátovací funkce <strong>Sprintf</strong></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_09/10_string_format_sprintf.go">https://github.com/tisnik/go-fedora/blob/master/article_09/10_string_format_sprintf.go</a></td></tr>
<tr><td>11</td><td>11_list.go</td><td>základní kontejner: seznam</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_09/11_list.go">https://github.com/tisnik/go-fedora/blob/master/article_09/11_list.go</a></td></tr>
<tr><td>12</td><td>12_list_as_stack.go</td><td>použití seznamu ve funkci zásobníku</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_09/12_list_as_stack.go">https://github.com/tisnik/go-fedora/blob/master/article_09/12_list_as_stack.go</a></td></tr>
<tr><td>13</td><td>12B_print_stack_content.go</td><td>vylepšení předchozího příkladu: RPN</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_09/12B_print_stack_content.go">https://github.com/tisnik/go-fedora/blob/master/article_09/12B_print_stack_content.go</a></td></tr>
<tr><td>14</td><td>13_gods_arraylist.go</td><td>GoDS: seznam implementovaný polem</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_09/13_gods_arraylist.go">https://github.com/tisnik/go-fedora/blob/master/article_09/13_gods_arraylist.go</a></td></tr>
<tr><td>15</td><td>14_gods_singlylinkedlist.go</td><td>GoDS: jednosměrně vázaný seznam</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_09/14_gods_singlylinkedlist.go">https://github.com/tisnik/go-fedora/blob/master/article_09/14_gods_singlylinkedlist.go</a></td></tr>
<tr><td>16</td><td>15_gods_stack_RPN.go</td><td>RPN kalkulačka, třetí verze</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_09/15_gods_stack_RPN.go">https://github.com/tisnik/go-fedora/blob/master/article_09/15_gods_stack_RPN.go</a></td></tr>
<tr><td>17</td><td>15B_gods_stack_RPN.go</td><td>RPN kalkulačka, čtvrtá verze</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_09/15B_gods_stack_RPN.go">https://github.com/tisnik/go-fedora/blob/master/article_09/15B_gods_stack_RPN.go</a></td></tr>
<tr><td>18</td><td>16_gods_set.go</td><td>GoDS: množiny, Eratosthenovo síto</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_09/16_gods_set.go">https://github.com/tisnik/go-fedora/blob/master/article_09/16_gods_set.go</a></td></tr>
<tr><td>19</td><td>17_gods_rb-tree.go</td><td>GoDS: RB-stromy</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_09/17_gods_rb-tree.go">https://github.com/tisnik/go-fedora/blob/master/article_09/17_gods_rb-tree.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Select waits on a group of channels<br />
<a href="https://yourbasic.org/golang/select-explained/">https://yourbasic.org/golang/select-explained/</a>
</li>

<li>Rob Pike: Simplicity is Complicated (video)<br />
<a href="http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893">http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893</a>
</li>

<li>Algorithms to Go<br />
<a href="https://yourbasic.org/">https://yourbasic.org/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů: vlastní filtry a lexery<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/</a>
</li>

<li>Go Defer Simplified with Practical Visuals<br />
<a href="https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff">https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff</a>
</li>

<li>5 More Gotchas of Defer in Go — Part II<br />
<a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa">https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa</a>
</li>

<li>The Go Blog: Defer, Panic, and Recover<br />
<a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a>
</li>

<li>The defer keyword in Swift 2: try/finally done right<br />
<a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer">https://www.hackingwithswift.com/new-syntax-swift-2-defer</a>
</li>

<li>Swift Defer Statement<br />
<a href="https://andybargh.com/swift-defer-statement/">https://andybargh.com/swift-defer-statement/</a>
</li>

<li>Modulo operation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Modulo_operation">https://en.wikipedia.org/wiki/Modulo_operation</a>
</li>

<li>Node.js vs Golang: Battle of the Next-Gen Languages<br />
<a href="https://www.hostingadvice.com/blog/nodejs-vs-golang/">https://www.hostingadvice.com/blog/nodejs-vs-golang/</a>
</li>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go<br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>JavaScript vs. Golang for IoT: Is Gopher Winning?<br />
<a href="https://www.iotforall.com/javascript-vs-golang-iot/">https://www.iotforall.com/javascript-vs-golang-iot/</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

<li>Printf Format Strings<br />
<a href="https://www.cprogramming.com/tutorial/printf-format-strings.html">https://www.cprogramming.com/tutorial/printf-format-strings.html</a>
</li>

<li>Java: String.format<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-</a>
</li>

<li>Java: format string syntax<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a>
</li>

<li>Selectors<br />
<a href="https://golang.org/ref/spec#Selectors">https://golang.org/ref/spec#Selectors</a>
</li>

<li>Calling Go code from Python code<br />
<a href="http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/">http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/</a>
</li>

<li>Go Data Structures: Interfaces <br />
<a href="https://research.swtch.com/interfaces">https://research.swtch.com/interfaces</a>
</li>

<li>How to use interfaces in Go<br />
<a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go</a>
</li>

<li>Interfaces in Go (part I)<br />
<a href="https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c">https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c</a>
</li>

<li>Part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>What about Trait support in Golang?<br />
<a href="https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/">https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/</a>
</li>

<li>Don't Get Bitten by Pointer vs Non-Pointer Method Receivers in Golang<br />
<a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/">https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/</a>
</li>

<li>Control Flow<br />
<a href="https://en.wikipedia.org/wiki/Control_flow">https://en.wikipedia.org/wiki/Control_flow</a>
</li>

<li>Structured programming<br />
<a href="https://en.wikipedia.org/wiki/Structured_programming">https://en.wikipedia.org/wiki/Structured_programming</a>
</li>

<li>Control Structures<br />
<a href="https://www.golang-book.com/books/intro/5">https://www.golang-book.com/books/intro/5</a>
</li>

<li>Control structures - Go if else statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html">http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html</a>
</li>

<li>Control structures - Go switch case statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html</a>
</li>

<li>Control structures - Go for loop, break, continue, range<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html</a>
</li>

<li>Single Function Exit Point<br />
<a href="http://wiki.c2.com/?SingleFunctionExitPoint">http://wiki.c2.com/?SingleFunctionExitPoint</a>
</li>

<li>Entry point<br />
<a href="https://en.wikipedia.org/wiki/Entry_point">https://en.wikipedia.org/wiki/Entry_point</a>
</li>

<li>Why does Go have a GOTO statement?!<br />
<a href="https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/">https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/</a>
</li>

<li>Effective Go<br />
<a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a>
</li>

<li>GoClipse: an Eclipse IDE for the Go programming language<br />
<a href="http://goclipse.github.io/">http://goclipse.github.io/</a>
</li>

<li>GoClipse Installation<br />
<a href="https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation">https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

