<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Využití TinyGo při programování Raspberry Pi Pico (2. část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Využití TinyGo při programování Raspberry Pi Pico (2. část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Využití TinyGo při programování Raspberry Pi Pico (2. část)</a></p>
<p><a href="#k02">2. Využití dalších kanálů analogově-digitálního převodníku</a></p>
<p><a href="#k03">3. Přečtení a zobrazení teploty změřené senzorem na čipu</a></p>
<p><a href="#k04">4. Zabránění častému &bdquo;přeskakování&ldquo; teploty</a></p>
<p><a href="#k05">5. Korektní zobrazení desetinné tečky</a></p>
<p><a href="#k06">6. Řízení maticového displeje</a></p>
<p><a href="#k07">*** 7. Zapojení maticového displeje</a></p>
<p><a href="#k08">*** 8. Softwarové řízení posuvných registrů přes GPIO</a></p>
<p><a href="#k09">*** 9. Základní tvar SW smyčky pro obnovu informací na maticovém displeji</a></p>
<p><a href="#k10">*** 10. Demonstrační příklad: vyplnění celé plochy rozsvícenými pixely</a></p>
<p><a href="#k11">*** 11. Vykreslení šachovnicového vzorku</a></p>
<p><a href="#k12">12. Otestování, zda je časování sloupců při ovládání displeje korektní</a></p>
<p><a href="#k13">13. Otestování časování řádků</a></p>
<p><a href="#k14">*** 14. Vykreslení celé bitmapy 32&times;8 pixelů</a></p>
<p><a href="#k15">*** 15. Scrolling obrazu s&nbsp;využitím potenciometru</a></p>
<p><a href="#k16">*** 16. Raspberry Pi Pico připojené ve funkci terminálu</a></p>
<p><a href="#k17">17. Sériové rozhraní SPI</a></p>
<p><a href="#k18">18. Sériová sběrnice I<sup>2</sup>C</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Využití TinyGo při programování Raspberry Pi Pico (2. část)</h2>

<p>Na <a
href="https://www.root.cz/clanky/vyuziti-tinygo-pri-programovani-raspberry-pi-pico-od-gpio-az-k-pwm/">předchozí
článek</a> o překladači TinyGo použitém pro tvorbu aplikací pro Raspberry Pi
Pico dnes navážeme. Ukážeme si, jakým způsobem je možné přečíst teplotu
změřenou interním senzorem připojeným na pátý kanál analogově-digitálního
převodníku. Dále se budeme zabývat tím, jak lze čistě softwarově ovládat
maticový displej s&nbsp;rozlišením 32&times;8 pixelů, přičemž každý pixel je
tvořen LED. Dále se zmíníme o připojení Raspberry Pi Pico k&nbsp;počítači
v&nbsp;režimu terminálu, což mj.&nbsp;umožňuje spouštět programy, které
používají standardní vstupní a výstupní proudy (<i>input stream</i> a <i>output
stream</i>). A v&nbsp;závěrečné části článku si popíšeme způsob práce se
sériovými sběrnicemi a rozhraními. Raspberry Pi Pico totiž podporuje jak
rozhraní SPI, tak i sběrnici I<sup>2</sup>C. Sériový způsob přenosu dat je
podporován mnoha periferními zařízeními, například řadiči LCD atd.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Využití dalších kanálů analogově-digitálního převodníku</h2>

<p>Již v&nbsp;úvodním článku jsme si řekli, že mikrořadiče RP2040 i RP2350 jsou
mj.&nbsp;vybaveny i analogově-digitálním převodníkem. Typicky se jedná o čtyři
(vstupní) kanály s&nbsp;rozlišením dvanácti bitů, ovšem RP2350 v&nbsp;pouzdře
QFN-80EP nabízí celých osm kanálů (a současně i osmnáct GPIO). I když má
analogově-digitální převodník rozlišení dvanácti bitů, prakticky všechna
programová rozhraní vrací šestnáctibitové hodnoty, což znamená, že spodní čtyři
bity přečtených výsledků je možné ignorovat. Navíc je možné u každého ze vstupů
do analogově-digitálního převodníku zvolit, zda budou použity nebo zda se má
příslušný pin použít pro jiné účely (tedy například jako GPIO, SCL apod.).</p>

<p>To se ovšem týká pouze prvních tří kanálů ADC0, ADC1 a ADC2, protože čtvrtý
kanál se používá pro čtení úrovně referenčního napětí (není vyveden na piny
RPi). Pátý kanál čte hodnoty získané teplotním senzorem (a není tedy vyveden na
piny RPi). Popis pinů naleznete na adrese <a
href="https://www.raspberrypi.com/documentation/microcontrollers/pico-series.html#pico-2-family">https://www.raspberrypi.com/documentation/microcontrollers/pico-series.html#pico-2-family</a>.</p>

<p>A právě pátý kanál ADC nás bude zajímat, protože nám umožní zjistit aktuální
teplotu čipu. V&nbsp;případě, že používáme TinyGo a knihovny, které jsou jeho
součástí, není nutné provádět ruční převod přečtené hodnoty na teplotu, protože
je k&nbsp;dispozici pro tento účel určená funkce, která přečte hodnotu
z&nbsp;ADC a provede konverzi automaticky:</p>

<pre>
<i>// ReadTemperature does a one-shot sample of the internal temperature sensor and returns a milli-celsius reading.</i>
func <strong>ReadTemperature</strong>() (millicelsius int32) {
    if rp.ADC.CS.Get()&amp;rp.ADC_CS_EN == 0 {
        InitADC()
    }
    thermChan, _ := ADC{Pin: thermADC}.GetADCChannel()
    <i>// Enable temperature sensor bias source</i>
    rp.ADC.CS.SetBits(rp.ADC_CS_TS_EN)

    <i>// T = 27 - (ADC_voltage - 0.706)/0.001721</i>
    <i>// 1/0.001721 ≈ 581</i>
    return int32(((int64(27000) &lt;&lt; 16) - ((int64(thermChan.getVoltage()) - (int64(706) &lt;&lt; 16)) * 581)) &gt;&gt; 16)
}
</pre>

<p>Jak je z&nbsp;dokumentačního řetězce patrné, je výsledek reprezentován
v&nbsp;tisícinách stupně Celsia.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě se nejedná o metodu
ke struktuře <strong>machine.Pin</strong>, ale skutečně o jednoduchou funkci,
která neakceptuje žádné parametry.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Přečtení a zobrazení teploty změřené senzorem na čipu</h2>

<p>Přečtení teploty změřené senzorem a převedené do číslicové podoby
analogově-digitálním převodníkem je velmi jednoduché, takže snadno můžeme
realizovat programovou smyčku, která teplotu přečte a zobrazí ji na displeji.
K&nbsp;zobrazení lze použít funkci pojmenovanou <strong>displayNumber</strong>,
kterou jsme si popsali v&nbsp;předchozím článku. Ovšem vzhledem k&nbsp;tomu, že
se (teoreticky) vrací teplota v rozsahu od 0&deg;C až 65,536&deg;C, ale displej
má pouze čtyři cifry, nejprve vrácenou teplotu podělíme deseti. Ostatně to je
více než dostačující; není zapotřebí zobrazovat setiny a tisíciny stupně
Celsia:</p>

<pre>
for {
    temperature := machine.ReadTemperature()
    temperature /= 10
    displayNumber(int(temperature))
}
</pre>

<p>Výsledek bude vypadat následovně:</p>

*** image ***

<p>Ukažme si ještě úplný zdrojový kód tohoto demonstračního příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
    "machine"
    "time"
)
&nbsp;
const SleepAmount = time.Millisecond * 1
&nbsp;
var controls [4]machine.Pin
var pins [8]machine.Pin
&nbsp;
var digits [][]bool = [][]bool{
    {true, true, true, true, true, true, false, false},
    {false, true, true, false, false, false, false, false},
    {true, true, false, true, true, false, true, false},
    {true, true, true, true, false, false, true, false},
    {false, true, true, false, false, true, true, false},
    {true, false, true, true, false, true, true, false},
    {true, false, true, true, true, true, true, false},
    {true, true, true, false, false, false, false, false},
    {true, true, true, true, true, true, true, false},
    {true, true, true, true, false, true, true, false},
}
&nbsp;
func <strong>init</strong>() {
    controls[0] = machine.GP5
    controls[1] = machine.GP6
    controls[2] = machine.GP7
    controls[3] = machine.GP8
    for _, control := range controls {
        control.Configure(machine.PinConfig{Mode: machine.PinOutput})
    }
&nbsp;
    pins[0] = machine.GP11
    pins[1] = machine.GP9
    pins[2] = machine.GP13
    pins[3] = machine.GP15
    pins[4] = machine.GP16
    pins[5] = machine.GP10
    pins[6] = machine.GP12
    pins[7] = machine.GP14
&nbsp;
    for _, pin := range pins {
        pin.Configure(machine.PinConfig{Mode: machine.PinOutput})
    }
}
&nbsp;
func <strong>displaySegments</strong>(bits []bool) {
    for i := range bits {
        bit := bits[i]
        pin := pins[i]
        if bit {
            pin.High()
        } else {
            pin.Low()
        }
    }
}
&nbsp;
func <strong>displayNumber</strong>(number int) {
    x := number
    for i := range 4 {
        digit := x % 10
        x /= 10
        bits := digits[digit]
        control := controls[3-i]
        control.High()
        displaySegments(bits)
        time.Sleep(SleepAmount)
        control.Low()
    }
}
&nbsp;
func <strong>main</strong>() {
    for {
        temperature := machine.ReadTemperature()
        temperature /= 10
        displayNumber(int(temperature))
    }
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zabránění častému &bdquo;přeskakování&ldquo; teploty</h2>

<p><a href="#k03">V&nbsp;předchozím</a> demonstračním příkladu se teplota
z&nbsp;analogově-digitálního převodníku četla velmi často a ihned poté byla
zobrazena na displeji. Ovšem kvůli různým vlivům se minimálně poslední dvě
číslice (desetiny a setiny stupně Celsia) velmi často měnily, takže vlastně
nebylo možné teplotu z&nbsp;displeje ani přečíst. Řešení tohoto problému je
snadné &ndash; měření teploty se provede s&nbsp;relativně malou frekvencí
(postačuje i jednou za několik sekund) a poté se stejné číslice opakovaně
zobrazí na displeji (obnovu jeho obsahu provádíme programově). Nejjednodušší
forma řešení může vypadat:</p>

<pre>
for {
    temperature := machine.ReadTemperature()
    temperature /= 10
    for range 1000 {
        displayNumber(int(temperature))
    }
}
</pre>

<p>Nyní je výsledkem zobrazení teploty, které se ovšem mění s&nbsp;mnohem menší
frekvencí a číslice lze tedy snadno přečíst:</p>

*** image ***

<p>Následuje výpis upraveného zdrojového kódu demonstračního příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
    "machine"
    "time"
)
&nbsp;
const SleepAmount = time.Millisecond * 1
&nbsp;
var controls [4]machine.Pin
var pins [8]machine.Pin
&nbsp;
var digits [][]bool = [][]bool{
    {true, true, true, true, true, true, false, false},
    {false, true, true, false, false, false, false, false},
    {true, true, false, true, true, false, true, false},
    {true, true, true, true, false, false, true, false},
    {false, true, true, false, false, true, true, false},
    {true, false, true, true, false, true, true, false},
    {true, false, true, true, true, true, true, false},
    {true, true, true, false, false, false, false, false},
    {true, true, true, true, true, true, true, false},
    {true, true, true, true, false, true, true, false},
}
&nbsp;
func <strong>init</strong>() {
    controls[0] = machine.GP5
    controls[1] = machine.GP6
    controls[2] = machine.GP7
    controls[3] = machine.GP8
    for _, control := range controls {
        control.Configure(machine.PinConfig{Mode: machine.PinOutput})
    }
&nbsp;
    pins[0] = machine.GP11
    pins[1] = machine.GP9
    pins[2] = machine.GP13
    pins[3] = machine.GP15
    pins[4] = machine.GP16
    pins[5] = machine.GP10
    pins[6] = machine.GP12
    pins[7] = machine.GP14
&nbsp;
    for _, pin := range pins {
        pin.Configure(machine.PinConfig{Mode: machine.PinOutput})
    }
}
&nbsp;
func <strong>displaySegments</strong>(bits []bool) {
    for i := range bits {
        bit := bits[i]
        pin := pins[i]
        if bit {
            pin.High()
        } else {
            pin.Low()
        }
    }
}
&nbsp;
func <strong>displayNumber</strong>(number int) {
    x := number
    for i := range 4 {
        digit := x % 10
        x /= 10
        bits := digits[digit]
        control := controls[3-i]
        control.High()
        displaySegments(bits)
        time.Sleep(SleepAmount)
        control.Low()
    }
}
&nbsp;
func <strong>main</strong>() {
    for {
        temperature := machine.ReadTemperature()
        temperature /= 10
        for range 1000 {
            displayNumber(int(temperature))
        }
    }
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Korektní zobrazení desetinné tečky</h2>

<p>Každá cifra na sedmisegmentovém displeji ve skutečnosti ještě obsahuje jednu
LED určenou pro zobrazení desetinné tečky. Toho pochopitelně můžeme využít,
protože například hodnota 2050 zobrazená na displeji je poněkud zavádějící.
Ovšem když zobrazíme 20.50, bude již zřejmé, že se jedná o skutečnou teplotu.
Existuje mnoho možností úpravy existující funkce pro zobrazení celočíselné
hodnoty na displeji; nejjednodušší je však předat do této funkce index
desetinné tečky, tj.&nbsp;vlastně index číslice, za kterou bude tečka
zobrazena. Pokud tento index bude ležet mimo rozsah 0..3, tečka zobrazena
nebude. Jedno z&nbsp;možných řešení může vypadat následovně. Nevýhodou tohoto
řešení je nutnost kopie všech osmi příznaků segmentů (nebo naopak modifikace
původního globálního pole, což je možná ještě horší):</p>

<pre>
func <strong>displayNumber</strong>(number int, dp int) {
    x := number
    for i := range 4 {
        digit := x % 10
        x /= 10
        bits := make([]bool, 8)
        copy(bits, digits[digit])
&nbsp;
        if i == dp {
            bits[7] = true
        }
&nbsp;
        control := controls[3-i]
        control.High()
        displaySegments(bits)
        time.Sleep(SleepAmount)
        control.Low()
    }
}
</pre>

<p>Volání funkce <strong>displayNumber</strong> bude v&nbsp;našem případě
vypadat následovně. Zobrazujeme tisíciny stupně Celsia vydělené deseti, takže
vlastně setiny. Tudíž musí být tečka zobrazena před posledními dvěma
číslicemi:</p>

<pre>
    for {
        temperature := machine.ReadTemperature()
        temperature /= 10
        for range 1000 {
            displayNumber(int(temperature), 2)
        }
    }
</pre>

<p>Výsledek získaný po spuštění tohoto příkladu na reálné vývojové desce:</p>

<p>Opět si pro úplnost ukážeme zdrojový kód tohoto demonstračního příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
    "machine"
    "time"
)
&nbsp;
const SleepAmount = time.Millisecond * 1
&nbsp;
var controls [4]machine.Pin
var pins [8]machine.Pin
&nbsp;
var digits [][]bool = [][]bool{
    {true, true, true, true, true, true, false, false},
    {false, true, true, false, false, false, false, false},
    {true, true, false, true, true, false, true, false},
    {true, true, true, true, false, false, true, false},
    {false, true, true, false, false, true, true, false},
    {true, false, true, true, false, true, true, false},
    {true, false, true, true, true, true, true, false},
    {true, true, true, false, false, false, false, false},
    {true, true, true, true, true, true, true, false},
    {true, true, true, true, false, true, true, false},
}
&nbsp;
func <strong>init</strong>() {
    controls[0] = machine.GP5
    controls[1] = machine.GP6
    controls[2] = machine.GP7
    controls[3] = machine.GP8
    for _, control := range controls {
        control.Configure(machine.PinConfig{Mode: machine.PinOutput})
    }
&nbsp;
    pins[0] = machine.GP11
    pins[1] = machine.GP9
    pins[2] = machine.GP13
    pins[3] = machine.GP15
    pins[4] = machine.GP16
    pins[5] = machine.GP10
    pins[6] = machine.GP12
    pins[7] = machine.GP14
&nbsp;
    for _, pin := range pins {
        pin.Configure(machine.PinConfig{Mode: machine.PinOutput})
    }
}
&nbsp;
func <strong>displaySegments</strong>(bits []bool) {
    for i := range bits {
        bit := bits[i]
        pin := pins[i]
        if bit {
            pin.High()
        } else {
            pin.Low()
        }
    }
}
&nbsp;
func <strong>displayNumber</strong>(number int, dp int) {
    x := number
    for i := range 4 {
        digit := x % 10
        x /= 10
        bits := make([]bool, 8)
        copy(bits, digits[digit])
&nbsp;
        if i == dp {
            bits[7] = true
        }
&nbsp;
        control := controls[3-i]
        control.High()
        displaySegments(bits)
        time.Sleep(SleepAmount)
        control.Low()
    }
}
&nbsp;
func <strong>main</strong>() {
    for {
        temperature := machine.ReadTemperature()
        temperature /= 10
        for range 1000 {
            displayNumber(int(temperature), 2)
        }
    }
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Řízení maticového displeje</h2>

<p>Prozatím jsme si ukázali tři možnosti zobrazení informací na vývojové
desce:</p>

<ol>

<li>Přímé řízení LED připojené na GPIO. Lze tak vizuálně zobrazit binární
hodnotu ano/ne, ok/chyba atd.</li>

<li>Řízení LED přes PWM (pulsní šířkovou modulaci). Již se nejedná o binární
hodnotu, ale o rozsah intenzity od &bdquo;nesvítí&ldquo; po &bdquo;plný
svit&ldquo;.</li>

<li>Řízení čtyřmístného sedmisegmentového displeje, což nám umožní zobrazit
například dekadickou hodnotu 0 až 9999, hexadecimální hodnotu 0000 až FFFF, ale
i některá <a
href="https://en.wikipedia.org/wiki/Seven-segment_display_character_representations">další
písmena či znaky</a>.</li>

</ol>

<p>To ovšem stále nemusí být pro mnoho účelů dostačující a proto je vývojová
deska vybavena i maticovým displejem, resp.&nbsp;přesněji řečeno čtveřicí
maticových displejů, které dohromady tvoří rastr 32&times;8 pixelů. Každý pixel
je realizován jednou LED a podle způsobu řízení je možné zajistit jak zobrazení
čistě <a href="https://en.wikipedia.org/wiki/Binary_image">binárních
obrázků</a>, tak i obrázků ve stupních ... zelené.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zapojení maticového displeje</h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. Softwarové řízení posuvných registrů přes GPIO</h2>

<pre>
rowsLatch := machine.GP19
rowsData := machine.GP18
rowsClock := machine.GP17

colsLatch := machine.GP22
colsData := machine.GP21
colsClock := machine.GP20

rowsLatch.Configure(machine.PinConfig{Mode: machine.PinOutput})
rowsData.Configure(machine.PinConfig{Mode: machine.PinOutput})
rowsClock.Configure(machine.PinConfig{Mode: machine.PinOutput})

colsLatch.Configure(machine.PinConfig{Mode: machine.PinOutput})
colsData.Configure(machine.PinConfig{Mode: machine.PinOutput})
colsClock.Configure(machine.PinConfig{Mode: machine.PinOutput})
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Základní tvar SW smyčky pro obnovu informací na maticovém displeji</h2>

<pre>
for {
    colsData.Low()
    colsClock.High()
    colsData.High()

    for range 32 {
        // zde se bude řešit nasouvání pixelů ve sloupci
        rowsLatch.High()
        time.Sleep(1 * time.Millisecond)
        rowsLatch.Low()

        colsClock.High()
        time.Sleep(1 * time.Millisecond)
        colsClock.Low()

        colsLatch.High()
        time.Sleep(1 * time.Millisecond)
        colsLatch.Low()
    }
    time.Sleep(10 * time.Millisecond)
}
</pre>

<pre>
for {
    colsData.Low()
    colsClock.High()
    colsData.High()

    for range 32 {
        for range 8 {
            rowsData.Set(true)
            rowsClock.Low()
            time.Sleep(1 * time.Millisecond)
            rowsClock.High()
        }
        rowsLatch.High()
        time.Sleep(1 * time.Millisecond)
        rowsLatch.Low()

        colsClock.High()
        time.Sleep(1 * time.Millisecond)
        colsClock.Low()

        colsLatch.High()
        time.Sleep(1 * time.Millisecond)
        colsLatch.Low()
    }
    time.Sleep(10 * time.Millisecond)
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Demonstrační příklad: vyplnění celé plochy rozsvícenými pixely</h2>

<pre>
package <strong>main</strong>

import (
    "machine"
    "time"
)

func <strong>main</strong>() {
    rowsLatch := machine.GP19
    rowsData := machine.GP18
    rowsClock := machine.GP17

    colsLatch := machine.GP22
    colsData := machine.GP21
    colsClock := machine.GP20

    rowsLatch.Configure(machine.PinConfig{Mode: machine.PinOutput})
    rowsData.Configure(machine.PinConfig{Mode: machine.PinOutput})
    rowsClock.Configure(machine.PinConfig{Mode: machine.PinOutput})

    colsLatch.Configure(machine.PinConfig{Mode: machine.PinOutput})
    colsData.Configure(machine.PinConfig{Mode: machine.PinOutput})
    colsClock.Configure(machine.PinConfig{Mode: machine.PinOutput})

    for {
        colsData.Low()
        colsClock.High()
        colsData.High()

        for range 32 {
            for range 8 {
                rowsData.Set(true)
                rowsClock.Low()
                time.Sleep(1 * time.Millisecond)
                rowsClock.High()
            }
            rowsLatch.High()
            time.Sleep(1 * time.Millisecond)
            rowsLatch.Low()

            colsClock.High()
            time.Sleep(1 * time.Millisecond)
            colsClock.Low()

            colsLatch.High()
            time.Sleep(1 * time.Millisecond)
            colsLatch.Low()
        }
        time.Sleep(10 * time.Millisecond)
    }
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vykreslení šachovnicového vzorku</h2>

<pre>
package <strong>main</strong>

import (
    "machine"
    "time"
)

func <strong>main</strong>() {
    rowsLatch := machine.GP19
    rowsData := machine.GP18
    rowsClock := machine.GP17

    colsLatch := machine.GP22
    colsData := machine.GP21
    colsClock := machine.GP20

    rowsLatch.Configure(machine.PinConfig{Mode: machine.PinOutput})
    rowsData.Configure(machine.PinConfig{Mode: machine.PinOutput})
    rowsClock.Configure(machine.PinConfig{Mode: machine.PinOutput})

    colsLatch.Configure(machine.PinConfig{Mode: machine.PinOutput})
    colsData.Configure(machine.PinConfig{Mode: machine.PinOutput})
    colsClock.Configure(machine.PinConfig{Mode: machine.PinOutput})

    for {
        colsData.Low()
        colsClock.High()
        colsData.High()

        for x := range 32 {
            for y := range 8 {
                value := (x+y)%2 == 0
                rowsData.Set(value)

                rowsClock.Low()
                time.Sleep(1 * time.Microsecond)
                rowsClock.High()

                time.Sleep(10 * time.Microsecond)
            }
            rowsLatch.High()
            time.Sleep(1 * time.Microsecond)
            rowsLatch.Low()

            colsClock.High()
            time.Sleep(1 * time.Microsecond)
            colsClock.Low()

            colsLatch.High()
            time.Sleep(1 * time.Microsecond)
            colsLatch.Low()
        }
        time.Sleep(10 * time.Microsecond)
    }
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Otestování, zda je časování sloupců při ovládání displeje korektní</h2>

<p>V&nbsp;dalším demonstračním příkladu si ověříme, jestli je vůbec časování a
synchronizace obsluhy obou sad posuvných registrů korektní. Začneme tím, že
necháme rozsvícený pouze první sloupec diod, zatímco ostatních 31 sloupců bude
zhasnutých:</p>

<pre>
for x := range 32 {
    for range 8 {
        value := x == 0
        rowsData.Set(value)
&nbsp;
        <i>// nasunutí hodnoty do sloupce</i>
    }
    <i>// přenos obsahu sloupcového záchytného registru na displej</i>
&nbsp;
    <i>// posun bitového vzorku v řádkovém záchytném registru</i>
    <i>// přenos obsahu řádkového záchytného registru na displej</i>
}
</pre>

<p>V&nbsp;případě, že je náš ovládací program napsán nekorektně, například
pokud provádí posuny &bdquo;off-by-one&ldquo; (což byl největší problém při
ladění kódu), bude zobrazen odlišný sloupec, nebude rozsvícený žádný sloupec
nebo bude docházet k&nbsp;různému posunu.</p>

<p>V&nbsp;praxi, tj.&nbsp;po překladu programu a jeho přenosu do Raspberry Pi
Pico, bychom měli uvidět tento vzorek:</p>

*** image ***

<p>Následuje výpis celého zdrojového kódu takto upraveného demonstračního
příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
    "machine"
    "time"
)
&nbsp;
func <strong>main</strong>() {
    rowsLatch := machine.GP19
    rowsData := machine.GP18
    rowsClock := machine.GP17
&nbsp;
    colsLatch := machine.GP22
    colsData := machine.GP21
    colsClock := machine.GP20
&nbsp;
    rowsLatch.Configure(machine.PinConfig{Mode: machine.PinOutput})
    rowsData.Configure(machine.PinConfig{Mode: machine.PinOutput})
    rowsClock.Configure(machine.PinConfig{Mode: machine.PinOutput})
&nbsp;
    colsLatch.Configure(machine.PinConfig{Mode: machine.PinOutput})
    colsData.Configure(machine.PinConfig{Mode: machine.PinOutput})
    colsClock.Configure(machine.PinConfig{Mode: machine.PinOutput})
&nbsp;
    for {
        colsData.Low()
        colsClock.High()
        colsData.High()
&nbsp;
        for x := range 32 {
            for range 8 {
                value := x == 0
                rowsData.Set(value)
&nbsp;
                rowsClock.Low()
                time.Sleep(1 * time.Microsecond)
                rowsClock.High()
&nbsp;
                time.Sleep(10 * time.Microsecond)
            }
            rowsLatch.High()
            time.Sleep(1 * time.Microsecond)
            rowsLatch.Low()
&nbsp;
            colsClock.High()
            time.Sleep(1 * time.Microsecond)
            colsClock.Low()
&nbsp;
            colsLatch.High()
            time.Sleep(1 * time.Microsecond)
            colsLatch.Low()
        }
        time.Sleep(10 * time.Microsecond)
    }
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Otestování časování řádků</h2>

<p>Ještě nám zbývá ověření časování řádků (což není zcela přesné, spíše bychom
mohli říci, že se jedná o časování nasunování pixelů do aktivního sloupce). Pro
tento účel si necháme rozsvítit celou plochu displeje, s&nbsp;výjimkou
trojúhelníku v&nbsp;jeho levé horní části:</p>

<pre>
for x := range 32 {
    for range 8 {
        value := y &lt; x
        rowsData.Set(value)
&nbsp;
        <i>// nasunutí hodnoty do sloupce</i>
    }
    <i>// přenos obsahu sloupcového záchytného registru na displej</i>
&nbsp;
    <i>// posun bitového vzorku v řádkovém záchytném registru</i>
    <i>// přenos obsahu řádkového záchytného registru na displej</i>
}
</pre>

<p>Vzorek zobrazený na maticovém displeji by měl vypadat takto:</p>

*** image ***

<p>Opět si ukážeme celý zdrojový kód takto upraveného demonstračního
příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
    "machine"
    "time"
)
&nbsp;
func <strong>main</strong>() {
    rowsLatch := machine.GP19
    rowsData := machine.GP18
    rowsClock := machine.GP17
&nbsp;
    colsLatch := machine.GP22
    colsData := machine.GP21
    colsClock := machine.GP20
&nbsp;
    rowsLatch.Configure(machine.PinConfig{Mode: machine.PinOutput})
    rowsData.Configure(machine.PinConfig{Mode: machine.PinOutput})
    rowsClock.Configure(machine.PinConfig{Mode: machine.PinOutput})
&nbsp;
    colsLatch.Configure(machine.PinConfig{Mode: machine.PinOutput})
    colsData.Configure(machine.PinConfig{Mode: machine.PinOutput})
    colsClock.Configure(machine.PinConfig{Mode: machine.PinOutput})
&nbsp;
    for {
        colsData.Low()
        colsClock.High()
        colsData.High()
&nbsp;
        for x := range 32 {
            for y := range 8 {
                value := y &lt; x
                rowsData.Set(value)
&nbsp;
                rowsClock.Low()
                time.Sleep(1 * time.Microsecond)
                rowsClock.High()
&nbsp;
                time.Sleep(10 * time.Microsecond)
            }
            rowsLatch.High()
            time.Sleep(1 * time.Microsecond)
            rowsLatch.Low()
&nbsp;
            colsClock.High()
            time.Sleep(1 * time.Microsecond)
            colsClock.Low()
&nbsp;
            colsLatch.High()
            time.Sleep(1 * time.Microsecond)
            colsLatch.Low()
        }
        time.Sleep(10 * time.Microsecond)
    }
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<pre>
var raster []string = []string{
    //
    "***** * *   * *   *             ",
    "  *   * **  *  * *              ",
    "  *   * * * *   *   ****   **** ",
    "  *   * *  **   *  *    * *    *",
    "  *   * *   *   *  *      *    *",
    "                   *   ** *    *",
    "                   *    * *    *",
    "                    ****   **** ",
}
</pre>

<pre>
for x := range 32 {
    for y := range 8 {
        pixel := raster[7-y][x]
        value := pixel != ' '
        rowsData.Set(value)
                ...
                ...
                ...
    }
        ...
        ...
        ...
}
</pre>

<pre>
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Scrolling obrazu s&nbsp;využitím potenciometru</h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. Raspberry Pi Pico připojené ve funkci terminálu</h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. Sériové rozhraní SPI</h2>

<p>Sběrnice resp.&nbsp;přesněji řečeno rozhraní <i>SPI</i> (<i>Serial
Peripheral Interface</i>) představuje jednu z&nbsp;forem sériových externích
sběrnic sloužících pro vzájemné propojení dvou či více komunikujících uzlů,
přičemž jeden uzel obvykle vystupuje v&nbsp;roli takzvaného řadiče sběrnice
(<i>master</i>), ostatní uzly pracují v&nbsp;režimu <i>slave</i>. Uzel, který
pracuje jako <i>master</i>, obsahuje generátor hodinového signálu, který je
rozveden do všech ostatních uzlů, čímž je umožněn zcela synchronní (navíc ještě
obousměrný) přenos dat. Hodinový signál je rozváděn vodičem označovaným
symbolem <i>SCK</i>.</p>

<p>Kromě vodiče s&nbsp;hodinovým signálem jsou uzly propojeny dvojicí vodičů
označovaných většinou symboly <i>MISO</i> (<i>Master In, Slave Out</i>) a
<i>MOSI</i> (<i>Master Out, Slave In</i>), pomocí nichž se obousměrně (full
duplex) přenáší data.  Posledním signálem, který se u této sběrnice používá, je
signál <i>SSEL</i> (<i>Slave Select</i>), jenž slouží &ndash; jak již jeho
název napovídá &ndash; k&nbsp;výběru některého uzlu pracujícího v&nbsp;režimu
<i>slave</i>. Všechny čtyři signály &ndash; <i>SCK</i>, <i>MISO</i>,
<i>MOSI</i> i <i>SSEL</i>, pro svoji funkci vyžadují pouze jednosměrné porty,
což přispívá k&nbsp;jednoduché a především levné implementaci této
sběrnice.</p>

<p>Raspberry Pi Pico nabízí dvojici na sobě nezávislých SPI rozhraní, přičemž
pro každé SPI může být rezervováno několik pinů: <strong>MOSI</strong>,
<strong>MISO</strong>, <strong>SCLK</strong> (nebo <strong>SCK</strong>) a
výstupní piny pro výběr obvodu <strong>CSn</strong> (jeden z&nbsp;těchto pinů
je propojen na druhé straně s&nbsp;výběrovým pinem SSEL). Konkrétně se jedná o
následující piny:</p>

<table>
<tr><th>Rozhraní</th><th>MISO</th><th>MOSI</th><th>SCLK</th><th>CSn</th></tr>
<tr><td>SPI0</td><td>GP0/GP4/GP16</td><td>GP3/GP7/GP19</td><td>GP2/GP6/GP18</td><td>GP1/GP5/GP17</td></tr>
<tr><td>SPI1</td><td>GP8/GP12</td><td>GP11/GP15</td><td>GP10/GP14</td><td>GP9/GP13</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: s&nbsp;praktickým příkladem použití SPI
z&nbsp;TinyGo se seznámíme v&nbsp;navazujícím článku.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Sériová sběrnice I<sup>2</sup>C</h2>

<p>Další sériovou sběrnicí, kterou si dnes a především v&nbsp;navazující části
tohoto seriálu popíšeme, je sběrnice označovaná poněkud neobvykle symbolem
<i>I<sup>2</sup>C</i>, což je zkratka z&nbsp;celého názvu <i>Inter-Integrated
Circuit</i>. V&nbsp;určitých ohledech se jedná o sběrnici podobnou rozhraní
<i>SPI</i> (existence hodinového signálu, jediný uzel typu <i>master</i>),
ovšem některé vlastnosti těchto sběrnic jsou odlišné. Zatímco u sběrnice
<i>SPI</i> byl umožněn obousměrný přenos dat díky použití dvojice vodičů
<i>MISO</i> a <i>MOSI</i>, je sběrnice <i>I<sup>2</sup>C</i> vybavena
&bdquo;pouze&ldquo; jedním datovým vodičem <i>SDA</i>, z&nbsp;čehož vyplývá, že
se data přenáší poloduplexně (a ušetří se jak piny, tak i vodiče). Také to
znamená poněkud složitější interní strukturu všech připojených zařízení,
protože příslušné piny musí být možné přepínat ze vstupního režimu na režim
výstupní.</p>

<p>Navíc zde není použit výběr zařízení typu <i>slave</i> pomocí zvláštních
signálů, protože každému uzlu je přiřazena jednoznačná adresa &ndash; kromě
elektrických charakteristik je totiž přesně stanoven i komunikační protokol,
což je další rozdíl oproti výše popsanému rozhraní <i>SPI</i>. Obecně je možné
říci, že <i>I<sup>2</sup>C</i> je sice poněkud složitější, ale zato
flexibilnější sběrnice, která se velmi často používá i pro komunikaci na delší
vzdálenosti (řádově metry, viz například <i>DDC</i> u monitorů), než tomu je u
sběrnice <i>SPI</i>. V&nbsp;navazující části seriálu si řekneme, jakým způsobem
komunikace probíhá a jak se vlastně jednotlivá zařízení adresují.</p>

<p>Pro I<sup>2</sup>C se na Raspberry Pi Pico mohou použít dvojice pinů
<strong>SDA</strong> a <strong>SCL</strong>. Současně mohou být nakonfigurovány
dvě sběrnice I<sup>2</sup>C0 a I<sup>2</sup>C1, což znamená čtveřici obsazených
GPIO:</p>

<table>
<tr><th>Sběrnice</th><th>SDA</th><th>SCL</th></tr>
<tr><td>I<sup>2</sup>C0</td><td>GP0/GP4/GP8/GP12/GP16/GP20</td><td>GP1/GP5/GP9/GP13/GP17/GP21</td></tr>
<tr><td>I<sup>2</sup>C1</td><td>GP2/GP6/GP10/GP14/GP18/GP26</td><td>GP3/GP7/GP11/GP15/GP19/GP27</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: s&nbsp;praktickým příkladem použití
I<sup>2</sup>C z&nbsp;TinyGo se opět seznámíme v&nbsp;navazujícím
článku.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech <a
href="https://www.root.cz/clanky/vyuziti-tinygo-pri-programovani-raspberry-pi-pico-od-gpio-az-k-pwm/">minule</a>
i dnes použitých demonstračních příkladů byly uloženy do Git repositáře, který
je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář, můžete namísto toho použít odkazy na jednotlivé demonstrační
příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>blink.go</td><td>blikání LED připojenou ke zvolenému GPIO</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/blink.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/blink.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>button1.go</td><td>čtení tlačítka připojeného ke zvolenému GPIO, základní varianta</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/button1.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/button1.go</a></td></tr>
<tr><td> 3</td><td>button2.go</td><td>čtení tlačítka připojeného ke zvolenému GPIO, pojmenované konstanty s&nbsp;GPIO</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/button2.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/button2.go</a></td></tr>
<tr><td> 4</td><td>button3.go</td><td>čtení tlačítka připojeného ke zvolenému GPIO, vylepšení vizualizace stisku tlačítka</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/button3.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/button3.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>7segments1.go</td><td>ovládání sedmisegmentového displeje, základní varianta</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/7segments1.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/7segments1.go</a></td></tr>
<tr><td> 6</td><td>7segments2.go</td><td>ovládání sedmisegmentového displeje s&nbsp;více číslicemi</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/7segments2.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/7segments2.go</a></td></tr>
<tr><td> 7</td><td>7segments3.go</td><td>rozsvícení libovolné kombinace segmentů</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/7segments3.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/7segments3.go</a></td></tr>
<tr><td> 8</td><td>7segments4.go</td><td>tisk hodnoty 0 až 9999  na čtyřmístném sedmisegmentovém displeji</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/7segments4.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/7segments4.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>adc1.go</td><td>analogově digitální převodník: čtení stavu potenciometru s&nbsp;tiskem hodnoty odpovídající jeho natočení, základní varianta</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/adc1.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/adc1.go</a></td></tr>
<tr><td>10</td><td>adc2.go</td><td>čtení stavu potenciometru, varianta méně závislá na šumu ADC</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/adc2.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/adc2.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>pwm1.go</td><td>pulsně šířková modulace: příklad bez detekce chyb</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/pwm1.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/pwm1.go</a></td></tr>
<tr><td>12</td><td>pwm2.go</td><td>pulsně šířková modulace: příklad s&nbsp;detekcí chyb (vizualizováno přes LED)</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/pwm2.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/pwm2.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>temperature1.go</td><td>změření teploty senzorem na čipu</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/temperature1.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/temperature1.go</a></td></tr>
<tr><td>14</td><td>temperature2.go</td><td>menší frekvence měření teploty</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/temperature2.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/temperature2.go</a></td></tr>
<tr><td>15</td><td>temperature3.go</td><td>úprava pro zobrazení desetinné tečky</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/temperature3.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/temperature3.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>matrix1.go</td><td>ovládání maticového LED displeje: pomalé časování signálů</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/matrix1.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/matrix1.go</a></td></tr>
<tr><td>17</td><td>matrix2.go</td><td>zobrazení šachovnicového vzorku</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/matrix2.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/matrix2.go</a></td></tr>
<tr><td>18</td><td>matrix3.go</td><td>test korektního načasování pro zobrazení prvního sloupce</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/matrix3.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/matrix3.go</a></td></tr>
<tr><td>19</td><td>matrix4.go</td><td>test korektního načasování pro zobrazení řádků</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/matrix4.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/matrix4.go</a></td></tr>
<tr><td>20</td><td>matrix5.go</td><td>zobrazení rastrového obrázku na maticovém LED displeji</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/matrix5.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/matrix5.go</a></td></tr>
<tr><td>21</td><td>matrix6.go</td><td>skrolování informace na maticovém LED displeji pomocí potenciometru</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/matrix6.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/matrix6.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>terminal1.go</td><td>výpis informací na terminál</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/terminal1.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/terminal1.go</a></td></tr>
<tr><td>23</td><td>terminal2.go</td><td>přečtení informací z&nbsp;terminálu</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/terminal2.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/terminal2.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>TinyGo - A Go Compiler For Small Places<br />
<a href="https://tinygo.org/">https://tinygo.org/</a>
</li>

<li>Getting started<br />
<a href="https://tinygo.org/getting-started/">https://tinygo.org/getting-started/</a>
</li>

<li>Go.dev (klasická varianta překladače jazyka Go)<br />
<a href="https://go.dev/">https://go.dev/</a>
</li>

<li>gccgo<br />
<a href="https://gcc.gnu.org/onlinedocs/gccgo/">https://gcc.gnu.org/onlinedocs/gccgo/</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://go.dev/doc/install/gccgo">https://go.dev/doc/install/gccgo</a>
</li>

<li>Awesome Go<br />
<a href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go</a>
</li>

<li>TinyGo: Inline assembly<br />
<a href="https://tinygo.org/docs/concepts/compiler-internals/inline-assembly/">https://tinygo.org/docs/concepts/compiler-internals/inline-assembly/</a>
</li>

<li>Getting Started with TinyGo: Bringing Go to Microcontrollers and WebAssembly<br />
<a href="https://dev.to/ekwoster/getting-started-with-tinygo-bringing-go-to-microcontrollers-and-webassembly-2pp0">https://dev.to/ekwoster/getting-started-with-tinygo-bringing-go-to-microcontrollers-and-webassembly-2pp0</a>
</li>

<li>Optimizing Go code with GCCGO for improved performance<br />
<a href="https://dev.to/parmcoder/optimizing-go-code-with-gccgo-for-improved-performance-2d3d">https://dev.to/parmcoder/optimizing-go-code-with-gccgo-for-improved-performance-2d3d</a>
</li>

<li>The Untold Power of TinyGo: How to Run Go on Microcontrollers and Supercharge Embedded Development<br />
<a href="https://dev.to/ekwoster/the-untold-power-of-tinygo-how-to-run-go-on-microcontrollers-and-supercharge-embedded-development-2g7d">https://dev.to/ekwoster/the-untold-power-of-tinygo-how-to-run-go-on-microcontrollers-and-supercharge-embedded-development-2g7d</a>
</li>

<li>From Arduino to Mars: Why You Should Be Using TinyGo for Embedded Web Development<br />
<a href="https://dev.to/ekwoster/from-arduino-to-mars-why-you-should-be-using-tinygo-for-embedded-web-development-54od">https://dev.to/ekwoster/from-arduino-to-mars-why-you-should-be-using-tinygo-for-embedded-web-development-54od</a>
</li>

<li>Optimizing binaries<br />
<a href="https://tinygo.org/docs/guides/optimizing-binaries/">https://tinygo.org/docs/guides/optimizing-binaries/</a>
</li>

<li>Why TinyGo Might Be the Future of Embedded WebAssembly &amp; How To Get Started Today<br />
<a href="https://ekwoster.dev/post/-why-tinygo-might-be-the-future-of-embedded-webassembly-how-to-get-started-today/">https://ekwoster.dev/post/-why-tinygo-might-be-the-future-of-embedded-webassembly-how-to-get-started-today/</a>
</li>

<li>TinyGo na GitHubu<br />
<a href="https://github.com/tinygo-org/tinygo">https://github.com/tinygo-org/tinygo</a>
</li>

<li>Compile Go directly to WebAssembly components with TinyGo and WASI P2<br />
<a href="https://wasmcloud.com/blog/compile-go-directly-to-webassembly-components-with-tinygo-and-wasi-p2/">https://wasmcloud.com/blog/compile-go-directly-to-webassembly-components-with-tinygo-and-wasi-p2/</a>
</li>

<li>Do you use gccgo?<br />
<a href="https://www.reddit.com/r/golang/comments/j1g1z6/do_you_use_gccgo/">https://www.reddit.com/r/golang/comments/j1g1z6/do_you_use_gccgo/</a>
</li>

<li>Go v/s TinyGo: Which one is the best for you?<br />
<a href="https://blog.nonstopio.com/go-v-s-tinygo-which-one-is-the-best-for-you-73cac3c7849e">https://blog.nonstopio.com/go-v-s-tinygo-which-one-is-the-best-for-you-73cac3c7849e</a>
</li>

<li>Go Wiki: GccgoCrossCompilation<br />
<a href="https://go.dev/wiki/GccgoCrossCompilation">https://go.dev/wiki/GccgoCrossCompilation</a>
</li>

<li>Oficiální stránky Gccgo<br />
<a href="https://gcc.gnu.org/onlinedocs/gccgo/index.html">https://gcc.gnu.org/onlinedocs/gccgo/index.html</a>
</li>

<li>What are the primary differences between 'gc' and 'gccgo'?<br />
<a href="https://stackoverflow.com/questions/25811445/what-are-the-primary-differences-between-gc-and-gccgo">https://stackoverflow.com/questions/25811445/what-are-the-primary-differences-between-gc-and-gccgo</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://go.dev/doc/install/gccgo">https://go.dev/doc/install/gccgo</a>
</li>

<li>Go (Arch Linux)<br />
<a href="https://wiki.archlinux.org/title/Talk:Go">https://wiki.archlinux.org/title/Talk:Go</a>
</li>

<li>Why are binaries built with gccgo smaller (among other differences?)<br />
<a href="https://stackoverflow.com/questions/27067112/why-are-binaries-built-with-gccgo-smaller-among-other-differences">https://stackoverflow.com/questions/27067112/why-are-binaries-built-with-gccgo-smaller-among-other-differences</a>
</li>

<li>Why Everyone Is Sleeping On TinyGo: Run Go on Microcontrollers and the Web (WASM) Today!<br />
<a href="https://ekwoster.dev/post/-why-everyone-is-sleeping-on-tinygo-run-go-on-microcontrollers-and-the-web-wasm-today/">https://ekwoster.dev/post/-why-everyone-is-sleeping-on-tinygo-run-go-on-microcontrollers-and-the-web-wasm-today/</a>
</li>

<li>Go (Golang) GOOS and GOARCH<br />
<a href="https://gist.github.com/asukakenji/f15ba7e588ac42795f421b48b8aede63">https://gist.github.com/asukakenji/f15ba7e588ac42795f421b48b8aede63</a>
</li>

<li>Externí sériové sběrnice SPI a I²C<br />
<a href="https://www.root.cz/clanky/externi-seriove-sbernice-spi-a-i2c/">https://www.root.cz/clanky/externi-seriove-sbernice-spi-a-i2c/</a>
</li>

<li>Sedmisegmentový displej (Wikipedie)<br />
<a href="https://cs.wikipedia.org/wiki/Sedmisegmentov%C3%BD_displej">https://cs.wikipedia.org/wiki/Sedmisegmentov%C3%BD_displej</a>
</li>

<li>A/D převodník (Wikipedie)<br />
<a href="https://cs.wikipedia.org/wiki/A/D_p%C5%99evodn%C3%ADk">https://cs.wikipedia.org/wiki/A/D_p%C5%99evodn%C3%ADk</a>
</li>

<li>D/A převodník (Wikipedie)<br />
<a href="https://cs.wikipedia.org/wiki/D/A_p%C5%99evodn%C3%ADk">https://cs.wikipedia.org/wiki/D/A_p%C5%99evodn%C3%ADk</a>
</li>

<li>Pulzně šířková modulace<br />
<a href="https://cs.wikipedia.org/wiki/Pulzn%C4%9B_%C5%A1%C3%AD%C5%99kov%C3%A1_modulace">https://cs.wikipedia.org/wiki/Pulzn%C4%9B_%C5%A1%C3%AD%C5%99kov%C3%A1_modulace</a>
</li>

<li>TinyGo: Using PWM<br />
<a href="https://tinygo.org/docs/tutorials/pwm/">https://tinygo.org/docs/tutorials/pwm/</a>
</li>

<li>General-purpose input/output<br />
<a href="https://en.wikipedia.org/wiki/General-purpose_input/output">https://en.wikipedia.org/wiki/General-purpose_input/output</a>
</li>

<li>KWM-20881AGBLUCKYLIGHT-Display LED<br />
<a href="https://www.tme.eu/en/details/kwm-20881agb/led-displays-matrix/luckylight/">https://www.tme.eu/en/details/kwm-20881agb/led-displays-matrix/luckylight/</a>
</li>

<li>ESP-32 - LED Matrix<br />
<a href="https://esp32io.com/tutorials/esp32-led-matrix">https://esp32io.com/tutorials/esp32-led-matrix</a>
</li>

<li>Seven-segment display character representations<br />
<a href="https://en.wikipedia.org/wiki/Seven-segment_display_character_representations">https://en.wikipedia.org/wiki/Seven-segment_display_character_representations</a>
</li>

<li>Binary image<br />
<a href="https://en.wikipedia.org/wiki/Binary_image">https://en.wikipedia.org/wiki/Binary_image</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2026</small></p>
</body>
</html>

