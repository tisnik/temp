<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Go v roli skriptovacího programovacího jazyka</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Go v roli skriptovacího programovacího jazyka</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Go v&nbsp;roli skriptovacího programovacího jazyka</a></p>
<p><a href="#k02">2. Skriptovací jazyky v&nbsp;současnosti</a></p>
<p><a href="#k03">3. Projekt <i>Gore</i></a></p>
<p><a href="#k04">4. Instalace projektu <i>Gore</i> a spuštění interaktivní smyčky REPL</a></p>
<p><a href="#k05">5. První kroky s&nbsp;interpretrem Gore</a></p>
<p><a href="#k06">6. Speciální pseudopříkazy používané v&nbsp;REPL projektu Gore</a></p>
<p><a href="#k07">7. Získání typu výrazu a omezené možnosti této techniky</a></p>
<p><a href="#k08">8. Automatický import balíčků</a></p>
<p><a href="#k09">*** 9. Způsob generování zdrojových kódů interpretrem Gore</a></p>
<p><a href="#k10">*** 10. Interpet <i>Yaegi</i></a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. Interpret <i>Gomacro</i></a></p>
<p><a href="#k15">15. Instalace <i>Gomacra</i> s&nbsp;jeho spuštěním</a></p>
<p><a href="#k16">*** 16. Interní příkazy interpretru <i>Gomacro</i></a></p>
<p><a href="#k17">17. Inspektor v&nbsp;interpretru <i>Gomacro</i></a></p>
<p><a href="#k18">*** 18. Který interpret si vybrat?</a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Go v&nbsp;roli skriptovacího programovacího jazyka</h2>

<p>Pro čtenáře <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">seriálu o
programovacím jazyce Go</a> pravděpodobně nebude tvrzení, že Go je překládaný
(kompilovaný) programovací jazyk, žádným překvapením. Zdrojové kódy psané
v&nbsp;jazyce Go se skutečně před svým spuštěním nejdříve překládají, a to buď
do nativního kódu zvolené platformy (x86, x86-64, ARM 32bit, Aarch64, RISC-V
atd.), nebo do bajtkódu WebAssembly. Alternativně je možné použít
transpřekladač (transpiler) <i>GopherJS</i>, který dokáže zdrojové kódy psané
v&nbsp;jazyce Go transformovat do JavaScriptu. Touto technologií jsme se
zabývali v&nbsp;[<a
href="https://www.root.cz/clanky/gopherjs-transprekladac-z-jazyka-go-do-javascriptu/">1</a>],
[<a
href="https://www.root.cz/clanky/technologie-webassembly-a-gopherjs-predavani-argumentu-mezi-go-a-javascriptem/">2</a>]
a [<a
href="https://www.root.cz/clanky/technologie-webassembly-a-gopherjs-predavani-argumentu-mezi-go-a-javascriptem-dokonceni/">3</a>].</p>

<p>Výhody překladače, resp.&nbsp;přesněji řečeno překladače programovacího
jazyka se silným typovým systémem, jsou pravděpodobně většině vývojářů zřejmé
&ndash; vyšší rychlost běhu aplikací, obecně menší paměťové nároky procesů, na
cílovém počítači nemusí být nainstalován žádný interpret a v&nbsp;neposlední
řadě je poměrně velká část chyb (bohužel spíše těch triviálních) objevena již
překladačem. Navíc je programovací jazyk Go známý tím, že jeho překladač je
velmi rychlý &ndash; mnohdy tak rychlý, že je fáze překladu prakticky
&bdquo;neviditelná&ldquo; (v&nbsp;závislosti na velikosti projektu se může
jednat například o 200 ms atd. &ndash; což je z&nbsp;pohledu lidského vývojáře
prakticky okamžitě a cyklus <i>edit-compile-run</i> se tak de facto zkracuje na
<i>edit-run</i>). Ostatně příkaz <strong>go run</strong> se skrytím procesu
překladu a následným odstraněním spustitelného souboru snaží tvářit jako
interpretovaný jazyk.</p>

<p>Nicméně existují oblasti, v&nbsp;nichž se prosadil dosti odlišný způsob
vývoje, který je založen na přímé interakci (resp.&nbsp;dialogu) mezi
uživatelem a počítačem. V&nbsp;tom nejjednodušším případě se jedná o systémy
vybavené interaktivní smyčkou REPL (<i>Read Eval Print Loop</i>), jejichž
poněkud primitivní podobu si někteří mohou pamatovat z&nbsp;dob osmibitových
mikropočítačů a interpretrů jazyka BASIC. Nicméně klasický REPL najdeme
například i v&nbsp;Pythonu a dalších moderních skriptovacích jazycích (pro
Python navíc existují různá jeho rozšíření, například v&nbsp;podobě
<i>IPythonu</i>). V&nbsp;současnosti se mnohdy původní REPL nahrazuje spíše
rozhraním ve stylu diáře (<i>notebooku</i>). Příkladem je projekt <a
href="https://www.root.cz/clanky/jupyter-notebook-nastroj-pro-programatory-vyzkumniky-i-lektory/">Jupyter
Notebook</a>, který v&nbsp;současnosti podporuje velké množství skriptovacích
jazyků.</p>

<p>Go jakožto překládaný jazyk do této kategorie nepatří, ovšem i přesto
vzniklo hned několik projektů, které se snaží o využití Go jakožto
interaktivního skriptovacího jazyka. A právě některé z&nbsp;těchto projektů si
představíme v&nbsp;dnešním článku.</p>

<p><div class="rs-tip-major">Poznámka: už na tomto místě je vhodné upozornit na
to, že některé dále zmíněné projekty se stále nachází ve fázi vývoje a není tak
praktické na nich postavit aplikace určené do produkčního nasazení. Na druhou
stranu například integrace jazyka Go do <i>Jupyter Notebooku</i> je již dosti
stabilní a užitečná i v&nbsp;praxi.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Skriptovací jazyky v&nbsp;současnosti</h2>

<p>V&nbsp;současnosti se v&nbsp;praxi používá poměrně velké množství různých
skriptovacích jazyků. A nutno dodat, že se v&nbsp;některých případech jedná o
velmi populární jazyky, o čemž se ostatně můžeme snadno přesvědčit například na
stránkách <a href="https://www.tiobe.com/tiobe-index/">indexu Tiobe</a> nebo je
to ještě více patrné na stránce <a href="https://pypl.github.io/PYPL.html">PYPL
PopularitY of Programming Language</a>. V&nbsp;tabulce zobrazené pod tímto
odstavcem jsou vypsány některé populární (či v&nbsp;minulosti populární &ndash;
příkladem je <i>ActionScript</i>) skriptovací jazyky. Ty jsou seřazeny podle
svého jména, ovšem nechybí zde ani Python, JavaScript či jazyk R (ten je ovšem
používán spíše mimo profesionální IT komunitu; můžeme ho pokládat za doménově
specifický jazyk):</p>

<table>
<tr><th>Skriptovací jazyk</th></tr>
<tr><td>AppleScript</td></tr>
<tr><td>AWK</td></tr>
<tr><td>BeanShell</td></tr>
<tr><td>Bash</td></tr>
<tr><td>Ch</td></tr>
<tr><td>ActionScript</td></tr>
<tr><td>JavaScript</td></tr>
<tr><td>Game Maker Language</td></tr>
<tr><td>Julia</td></tr>
<tr><td>Groovy</td></tr>
<tr><td>Korn shell</td></tr>
<tr><td>Lua</td></tr>
<tr><td>Perl</td></tr>
<tr><td>PHP</td></tr>
<tr><td>PowerShell</td></tr>
<tr><td>Python</td></tr>
<tr><td>R</td></tr>
<tr><td>Rebol</td></tr>
<tr><td>Rexx</td></tr>
<tr><td>S-lang</td></tr>
<tr><td>Tcl</td></tr>
<tr><td>VBScript</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: na tomto místě je vhodné doplnit, že pro
některé výše zmíněné skriptovací jazyky existují i (plnohodnotné) překladače.
Takový programovací jazyk je tedy možné použít podle přání a potřeb vývojáře
jak pro tvorbu přímo spouštěných skriptů, tak i pro překlad do nativního kódu.
Příkladem takového programovacího jazyka je <i>Julia</i>, kterému jsme se již
na stránkách Roota věnovali <a
href="https://www.root.cz/serialy/programovaci-jazyk-julia/">v&nbsp;samostatném
seriálu</a>.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Projekt <i>Gore</i></h2>

<p>Prvním interpretrem programovacího jazyka Go, se kterým se dnes seznámíme,
je interpret nazvaný <strong>Gore</strong>. S&nbsp;tímto projektem jsme se již
<a href="https://www.root.cz/serialy/programovaci-jazyk-go/">v&nbsp;seriálu o
programovacím jazyce Go</a> jednou setkali. Připomeňme si, že tento projekt
nabízí (z&nbsp;pohledu uživatele &ndash; programátora) interpret plnohodnotného
jazyka Go, který je navíc vybaven interaktivní smyčkou REPL. Ta nabízí základní
editační příkazy, historii zadaných příkazů, hledání v&nbsp;historii příkazů
atd.  &ndash; tedy dnes již standardní a očekávané vlastnosti.</p>

<p>Díky využití projektu <strong>gocode</strong> nabízí interaktivní smyčka
REPL i automatické doplňování příkazů, což je samozřejmě velmi užitečná
technologie (a opět &ndash; dnes již očekávaná jako standard). Projekt
<i>Gore</i> je dostupný na adrese <a
href="https://github.com/x-motemen/gore">https://github.com/x-motemen/gore</a>.
Interně je řešen vlastně dosti triviálním způsobem: používá totiž příkaz
<strong>go run</strong> pro překlad a spuštění zadávaného kódu po zápisu
každého příkazu nebo bloku. Díky rychlosti překladače jazyka Go je sice toto
zdržení nepatrné a pravděpodobně si ho v&nbsp;případě menších skriptů ani
nevšimnete, nicméně se nejedná o standardní chování, které se od interpretrů
očekává a taktéž se některé příkazy a knihovní funkce mohou chovat
&bdquo;divně&ldquo;, protože se ztrácí kontext. Například se může jednat o
přečtení času, vygenerování náhodného čísla, přístup do databáze atd.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instalace projektu <i>Gore</i> a spuštění interaktivní smyčky REPL</h2>

<p>Ještě před samotnou instalací projektu <i>Gore</i> je nutné nainstalovat
nástroj <strong>gocode</strong>, o němž jsme se zmínili již <a
href="#k03">v&nbsp;předchozí kapitole</a>. Je dosti pravděpodobné, že pokud
vyvíjíte programy v&nbsp;jazyce Go, máte již <strong>gocode</strong>
nainstalován, což lze velmi snadno otestovat:</p>

<pre>
$ <strong>whereis gocode</strong>
&nbsp;
gocode: /home/ptisnovs/go/bin/gocode
</pre>

<p>V&nbsp;případě, že <strong>gocode</strong> nainstalován není, použijte
následující příkaz, který nainstaluje jeho poslední dostupnou verzi:</p>

<pre>
$ <strong>go install github.com/mdempsky/gocode@latest</strong>
&nbsp;
go: downloading github.com/mdempsky/gocode v0.0.0-20200405233807-4acdcbdea79d
go: finding module for package golang.org/x/tools/go/gcexportdata
go: downloading golang.org/x/tools v0.28.0
go: found golang.org/x/tools/go/gcexportdata in golang.org/x/tools v0.28.0
</pre>

<p>Ověříme si, že <strong>gocode</strong> lze spustit</p>

<pre>
$ <strong>gocode -help</strong>
&nbsp;
Usage: gocode [-s] [-f=<format>] [-in=<path>] [-sock=<type>] [-addr=<addr>]
       <command> [<args>]
&nbsp;
Flags:
  -addr string
        address for tcp socket (default "127.0.0.1:37373")
  -builtin
        propose completions for built-in functions and types
  -cache
        use the cache importer
  -debug
        enable server-side debug mode
  -f string
        output format (vim | emacs | sexp | nice | csv | json) (default "nice")
  -fallback-to-source
        if importing a package fails, fallback to the source importer
  -ignore-case
        do case-insensitive matching
  -in string
        use this file instead of stdin input
  -s    run a server instead of a client
  -sock string
        socket type (unix | tcp | none) (default "unix")
  -source
        use source importer
  -unimported-packages
        propose completions for standard library packages not explicitly imported
&nbsp;
Commands:
  autocomplete [<path>] <offset>     main autocompletion command
  exit                               terminate the gocode daemon
</pre>

<p>Ve druhém kroku již nainstalujeme samotný projekt <strong>Gore</strong>;
opět jeho poslední verzi:</p>

<pre>
$ <strong>go install github.com/x-motemen/gore/cmd/gore@latest</strong>
&nbsp;
go: downloading github.com/x-motemen/gore v0.5.7
go: downloading github.com/peterh/liner v1.2.2
go: downloading golang.org/x/tools v0.13.0
go: downloading github.com/motemen/go-quickfix v0.0.0-20230925231438-5cf0001766ff
go: downloading golang.org/x/text v0.13.0
go: downloading github.com/mattn/go-runewidth v0.0.15
go: downloading golang.org/x/sys v0.12.0
go: downloading golang.org/x/mod v0.12.0
go: downloading github.com/rivo/uniseg v0.4.4
</pre>

<p>Ověříme, že je příkaz <strong>gore</strong> dostupný z&nbsp;shellu:</p>

<pre>
$ <strong>whereis gore</strong>
&nbsp;
gore: /home/ptisnovs/go/bin/gore
</pre>

<p><div class="rs-tip-major">Poznámka: mělo by tomu tak být, protože
v&nbsp;opačném případě (špatně nastavená <strong>$PATH</strong>) nebudou
správně pracovat ani další nástroje pro jazyk Go.</p></div></p>

<p>Nakonec <strong>gore</strong> spustíme, resp.&nbsp;si necháme zobrazit
nápovědu:</p>

<pre>
$ <strong>gore --help</strong>
&nbsp;
gore - A Go REPL
&nbsp;
Version: 0.5.7 (rev: HEAD/go1.22.1)
&nbsp;
Synopsis:
    % gore
&nbsp;
Options:
  -autoimport
        formats and adjusts imports automatically
  -context string
        import packages, functions, variables and constants from external golang source files
  -pkg string
        the package where the session will be run inside
  -version
        print gore version
</pre>

<p>Samotný interpret se spouští bez přepínačů:</p>

<pre>
$ <strong>gore</strong>
&nbsp;
:gore version 0.5.7  :help for help
</pre>

<p>Po spuštění interpretru by se měla zobrazit jednořádková nápověda (viz
předchozí výpis) a <strong>gore</strong> očekává uživatelské příkazy. Například
si můžeme zobrazit jeho krátkou nápovědu zadáním <strong>:help</strong> (včetně
dvojtečky na začátku):</p>

<pre>
gore&gt; <strong>:help</strong>
&nbsp;
    :import &lt;package&gt;     import a package
    :type &lt;expr&gt;          print the type of expression
    :print                print current source
    :write [&lt;file&gt;]       write out current source
    :clear                clear the codes
    :doc &lt;expr or pkg&gt;    show documentation
    :help                 show this help
    :quit                 quit the session
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. První kroky s&nbsp;interpretrem Gore</h2>

<p>V&nbsp;projektu Gore je možné, ostatně podobně jako v&nbsp;klasických
interpretrech, zadávat jednotlivé příkazy, které se ihned vykonají a vypíše se
jejich návratová hodnota. Pokud se jedná o běžné výrazy, je to snadné, což si
můžeme ukázat na několika příkladech:</p>

<pre>
gore&gt; <strong>1+2</strong>
3
&nbsp;
gore&gt; <strong>nil</strong>
nil
&nbsp;
gore&gt; <strong>"foo" + "bar"</strong>
"foobar"
&nbsp;
gore&gt; <strong>"foobar"[2:6]</strong>
"obar"
</pre>

<p>Pracovat je možné i s&nbsp;proměnnými, u kterých se dá s&nbsp;výhodou využít
speciální operátor pro jejich deklaraci s&nbsp;přiřazením a s&nbsp;odvozením
datového typu:</p>

<pre>
gore&gt; <strong>x:=6</strong>
6
&nbsp;
gore&gt; <strong>y:=7</strong>
7
&nbsp;
gore&gt; <strong>x*y</strong>
42
&nbsp;
gore&gt; <strong>x&lt;y</strong>
true
</pre>

<p>Samotné výrazy jsou vždy pouze vyhodnoceny a poté interpretr
&bdquo;zapomene&ldquo;, že byly vyhodnocovány. Naproti tomu deklarace
proměnných se stává součástí interně vytvářeného programu (zdrojového kódu).
Ten si můžeme zobrazit pseudopříkazem <strong>:print</strong>:</p>

<pre>
gore&gt; <strong>:print</strong>
&nbsp;
package main
&nbsp;
import "github.com/k0kubun/pp/v3"
&nbsp;
func __gore_p(xs ...any) {
    for _, x := range xs {
        pp.Println(x)
    }
}
func main() { x := 6; y := 7 }
</pre>

<p>Povšimněte si, že se v&nbsp;postupně doplňované funkci <strong>main</strong>
skutečně nachází deklarace proměnných. A interpret Gore nás odstíní od chyb
typu &bdquo;proměnná X je deklarovaná, ale nepoužívá se&ldquo; (což je dobrá
detekce pro překladač, ale nikoli pro interaktivní interpret).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Speciální pseudopříkazy používané v&nbsp;REPL projektu Gore</h2>

<p>S&nbsp;takzvanými pseudopříkazy jsme se již částečně setkali
v&nbsp;předchozích dvou kapitolách. Tyto pseudopříkazy začínají znakem
dvojtečky a můžeme je použít například pro získání dokumentace. Následující
pseudopříkaz například vypíše dokumentaci k&nbsp;zabudované funkci
<strong>println</strong>:</p>

<pre>
gore&gt; <strong>:doc println</strong>
&nbsp;
func println(args ...Type)
    The println built-in function formats its arguments in an
    implementation-specific way and writes the result to standard error. Spaces
    are always added between arguments and a newline is appended. Println is
    useful for bootstrapping and debugging; it is not guaranteed to stay in the
    language.
</pre>

<p>Dalším často používaným pseudopříkazem je příkaz <strong>:import</strong>,
který je v&nbsp;Gore možné použít kdykoli, nikoli jen na začátku balíčku (pojem
balíček je ovšem v&nbsp;rámci REPLu poněkud mlhavý):</p>

<pre>
gore&gt; <strong>:import fmt</strong>
</pre>

<p>Ihned po importu balíčku je možné získat nápovědu k&nbsp;jeho funkcím,
konstantám, typům a metodám:</p>

<pre>
gore&gt; <strong>:doc fmt.Println</strong>
&nbsp;
func Println(a ...interface{}) (n int, err error)
    Println formats using the default formats for its operands and writes to
    standard output. Spaces are always added between operands and a newline is
    appended. It returns the number of bytes written and any write error
    encountered.
</pre>

<p>Totéž například platí i pro další standardní balíček <strong>time</strong> a
jeho funkci <strong>Sleep</strong>:</p>

<pre>
gore&gt; :import time
gore&gt; :doc time.Sleep
func Sleep(d Duration)
    Sleep pauses the current goroutine for at least the duration d. A negative
    or zero duration causes Sleep to return immediately.
</pre>

<p>Velmi užitečný je i pseudopříkaz <strong>:write jméno_souboru</strong>,
který zapíše zapsané definice do specifikovaného souboru, který by měl být
později přeložitelný překladačem jazyka Go (viz též seznam demonstračních
příkladů, které vznikly právě tímto způsobem).</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Získání typu výrazu a omezené možnosti této techniky</h2>

<p>Pseudopříkazem <strong>:type</strong> můžeme zjistit typ výrazu
resp.&nbsp;přesněji řečeno typ vypočtené hodnoty. Jedná se o operaci, ke které
se interpretry velmi dobře hodí (možná ještě lépe než debuggery):</p>

<pre>
gore&gt; <strong>:type 42</strong>
int
</pre>

<p>Nemusíme zjišťovat jen typ konstanty (konstantního výrazu), ale i výrazů
poněkud složitějších:</p>

<pre>
gore&gt; <strong>:type 6*7</strong>
int
</pre>

<p>Pravdivostní výraz:</p>

<pre>
gore&gt; <strong>:type 1==2</strong>
bool
</pre>

<p>Totéž platí i pro řetězce:</p>

<pre>
gore&gt; <strong>:type "foo"</strong>
string
</pre>

<p>Řezy</p>

<pre>
gore&gt; <strong>:type []int{1,2,3}</strong>
[]int
</pre>

<p>Pole (mimochodem lze takto velmi dobře pochopit rozdíl mezi řezy a
poli):</p>

<pre>
gore&gt; <strong>:type [...]int{1,2,3}</strong>
[3]int
</pre>

<p>Ovšem pozor je nutné si dát na to, abychom nezjišťovali typy proměnných (i
když by to bylo velmi užitečné). V&nbsp;tomto ohledu je projekt Gore dosti
omezený:</p>

<pre>
gore&gt; <strong>x:=6*7</strong>
42
</pre>

<p>Pokus o zjištění typu proměnné <strong>x</strong> skončí s&nbsp;chybou:</p>

<pre>
gore&gt; <strong>:type x</strong>
panic: file not found for pos = 1 (gore_session.go:1:1) [recovered]
        panic: file not found for pos = 1 (gore_session.go:1:1)
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Automatický import balíčků</h2>

<p>V&nbsp;interpretru <i>Gore</i> pochopitelně můžeme přímo volat libovolnou
funkci z&nbsp;implicitního balíčku. Takové funkce totiž není zapotřebí
importovat. Pro úplnost &ndash; jedná se o následující funkce (jejich seznam
lze nalézt například ve specifikaci jazyka Go, ale většinu pravděpodobně dobře
znáte a používáte):</p>

<pre>
append cap clear close complex copy delete imag len
make max min new panic print println real recover
</pre>

<p>To v&nbsp;praxi znamená, že si například můžeme nechat vypsat výsledek
nějakého výrazu funkcí <strong>println</strong>:</p>

<pre>
gore&gt; <strong>println(6*7)</strong>
42
</pre>

<p>Popř.&nbsp;si můžeme vypsat obsah proměnné:</p>

<pre>
gore&gt; <strong>x:=10</strong>
10
gore&gt; <strong>println(x)</strong>
10
</pre>

<p>Vypisovat hodnoty pochopitelně můžeme i z&nbsp;programové smyčky (spustí se
automaticky po zápisu uzavírací závorky a odeslání řádku klávesou
<strong>Enter</strong>):</p>

<pre>
gore&gt; <strong>for i := range 10 {</strong>
.....     <strong>println(i)</strong>
..... <strong>}</strong>
0
1
2
3
4
5
6
7
8
9
</pre>

<p>Ovšem co se stane ve chvíli, kdy například budeme chtít namísto funkce
<strong>println</strong> zavolat například <strong>fmt.Println</strong> nebo
<strong>fmt.Printf</strong>? Můžeme si to vyzkoušet:</p>

<pre>
gore&gt; <strong>fmt.Println("foo")</strong>
undefined: fmt
</pre>

<p>Interpret v&nbsp;tomto případě (korektně) napsal, že nezná identifikátor
<strong>fmt</strong>.</p>

<p>Import balíčku můžeme kdykoli provést pseudopříkazem
<strong>:import</strong>, například takto:</p>

<pre>
gore&gt; <strong>:import fmt</strong>
gore&gt; <strong>fmt.Printf("%5.3f", 1/3.)</strong>
0.3335
nil
</pre>

<p><div class="rs-tip-major">Poznámka: užitečné je, že import lze provést
skutečně kdykoli, na rozdíl od překládaného Go, v&nbsp;němž se importované
balíčky definují na začátku a nelze je poté měnit (což dává pro staticky
překládaný jazyk smysl).</div></p>

<p>Ovšem interpret Gore nám dokáže práci ještě více zjednodušit, a to
v&nbsp;případě, že povolíme takzvaný automatický import balíčků. K&nbsp;tomuto
účelu je nutné použít přepínač <strong>--autoimport</strong>:</p>

<pre>
$ <strong>gore --autoimport</strong>
</pre>

<p>Můžeme si to velmi snadno otestovat spuštěním nové seance interpretru:</p>

<pre>
gore version 0.5.7  :help for help
gore&gt; <strong>x:=6*7</strong>
42
&nbsp;
gore&gt; <strong>fmt.Println(x)</strong>
42
3
nil
</pre>

<p>Poslední volání vypsalo tři hodnoty:</p>

<pre>
42
3
nil
</pre>

<p>První hodnota byla vypsána přímo volanou funkcí a je v&nbsp;okně interpretru
zvýrazněna odlišnou barvou. A další dvě hodnoty označují počet zapsaných bajtů
a případnou chybu &ndash; viz hlavičku této funkce:</p>

<pre>
func Println(a ...any) (n int, err error)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Způsob generování zdrojových kódů interpretrem Gore</h2>

<p></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>

<p></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

<pre>
$ go install github.com/traefik/yaegi/cmd/yaegi@latest
&nbsp;
go: downloading github.com/traefik/yaegi v0.16.1
</pre>

<pre>
$ yaegi --help
Yaegi is a Go interpreter.

Usage:

    yaegi [command] [arguments]

The commands are:

    extract     generate a wrapper file from a source package
    help        print usage information
    run         execute a Go program from source
    test        execute test functions in a Go package
    version     print version

Use "yaegi help <command>" for more information about a command.

If no command is given or if the first argument is not a command, then
the run command is assumed.
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. Interpret <i>Gomacro</i></h2>




<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Který interpret si vybrat?</h2>

<p></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>yaegi<br />
<a href="https://github.com/traefik/yaegi">https://github.com/traefik/yaegi</a>
</li>

<li>gore<br />
<a href="https://github.com/x-motemen/gore">https://github.com/x-motemen/gore</a>
</li>

<li>gomacro<br />
<a href="https://github.com/cosmos72/gomacro">https://github.com/cosmos72/gomacro</a>
</li>

<li>Stránky jazyka Go<br />
<a href="https://go.dev/">https://go.dev/</a>
</li>

<li>Package names<br />
<a href="https://go.dev/blog/package-names">https://go.dev/blog/package-names</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://go.dev/ref/spec">https://go.dev/ref/spec</a>
</li>

<li>GoDoc: dokumentace k balíčkům<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go: the Good, the Bad and the Ugly (dnes již v některých ohledech zastaralé)<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Interpreter (computing)<br />
<a href="https://en.wikipedia.org/wiki/Interpreter_(computing)">https://en.wikipedia.org/wiki/Interpreter_(computing)</a>
</li>

<li>Scripting language<br />
<a href="https://en.wikipedia.org/wiki/Scripting_language">https://en.wikipedia.org/wiki/Scripting_language</a>
</li>

<li>Scripting languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Scripting_languages">https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Scripting_languages</a>
</li>

<li>PYPL PopularitY of Programming Language<br />
<a href="https://pypl.github.io/PYPL.html">https://pypl.github.io/PYPL.html</a>
</li>

<li>Tiobe index<br />
<a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a>
</li>

<li>GopherJS: transpřekladač z jazyka Go do JavaScriptu<br />
<a href="https://www.root.cz/clanky/gopherjs-transprekladac-z-jazyka-go-do-javascriptu/">https://www.root.cz/clanky/gopherjs-transprekladac-z-jazyka-go-do-javascriptu/</a>
</li>

<li>Technologie WebAssembly a GopherJS: předávání argumentů mezi Go a JavaScriptem<br />
<a href="https://www.root.cz/clanky/technologie-webassembly-a-gopherjs-predavani-argumentu-mezi-go-a-javascriptem/">https://www.root.cz/clanky/technologie-webassembly-a-gopherjs-predavani-argumentu-mezi-go-a-javascriptem/</a>
</li>

<li>Technologie WebAssembly a GopherJS: předávání argumentů mezi Go a JavaScriptem (dokončení)<br />
<a href="https://www.root.cz/clanky/technologie-webassembly-a-gopherjs-predavani-argumentu-mezi-go-a-javascriptem-dokonceni/">https://www.root.cz/clanky/technologie-webassembly-a-gopherjs-predavani-argumentu-mezi-go-a-javascriptem-dokonceni/</a>
</li>

<li>Gophernotes<br />
<a href="https://github.com/gopherdata/gophernotes">https://github.com/gopherdata/gophernotes</a>
</li>

<li>Jupyter Notebook – nástroj pro programátory, výzkumníky i lektory <br />
<a href="https://www.root.cz/clanky/jupyter-notebook-nastroj-pro-programatory-vyzkumniky-i-lektory/">https://www.root.cz/clanky/jupyter-notebook-nastroj-pro-programatory-vyzkumniky-i-lektory/</a>
</li>

<li>Difference Between Compiler and Interpreter<br />
<a href="https://www.geeksforgeeks.org/difference-between-compiler-and-interpreter/">https://www.geeksforgeeks.org/difference-between-compiler-and-interpreter/</a>
</li>

<li>What are the best interpreted programming languages?<br />
<a href="https://www.slant.co/topics/15913/~interpreted-programming-languages">https://www.slant.co/topics/15913/~interpreted-programming-languages</a>
</li>

<li>Top 13 Scripting Languages You Should Pay Attention To<br />
<a href="https://kinsta.com/blog/scripting-languages/">https://kinsta.com/blog/scripting-languages/</a>
</li>

<li>Go Interpreter<br />
<a href="https://github.com/go-interpreter/">https://github.com/go-interpreter/</a>
</li>

<li>Compiler vs Interpreter: A Detailed Comparison<br />
<a href="https://www.theknowledgeacademy.com/blog/compiler-vs-interpreter/">https://www.theknowledgeacademy.com/blog/compiler-vs-interpreter/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

