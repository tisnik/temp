<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Podpora programovacího paradigmatu založeného na tocích (dat) knihovnou glow</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Podpora programovacího paradigmatu založeného na tocích (dat) knihovnou glow</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Podpora programovacího paradigmatu založeného na tocích (dat) knihovnou <i>glow</i></a></p>
<p><a href="#k02">2. Krátké zopakování: programovací paradigma založené na tocích (dat)</a></p>
<p><a href="#k03">3. Knihovna <strong>glow</strong></a></p>
<p><a href="#k04">4. Instalace knihovny <strong>glow</strong></a></p>
<p><a href="#k05">5. Ukázka toku <i>Reduce&rarr;Map</i> (nejjednodušší možný praktický příklad)</a></p>
<p><a href="#k06">6. Realizace celého příkladu; výsledek výpočtu</a></p>
<p><a href="#k07">7. Ukázka toku <i>Reduce&rarr;Map</i>, využití anonymních funkcí</a></p>
<p><a href="#k08">8. Nepatrně složitější graf toku: <i>Map&rarr;Reduce&rarr;Map</i></a></p>
<p><a href="#k09">9. Metoda <strong>Partition</strong></a></p>
<p><a href="#k10">*** 10. Využití operace <i>Partition</i> zajišťující distribuci vstupních dat</a></p>
<p><a href="#k11">*** 11. Import takzvaného <i>driveru</i>; podpora pro vizualizaci grafu toku</a></p>
<p><a href="#k12">*** 12. Bezproblémové použití odlišných typů dat v&nbsp;jednotlivých hranách grafu toku</a></p>
<p><a href="#k13">*** 13. Vliv parametru předaného operaci <i>Partition</i> na průběh výpočtu</a></p>
<p><a href="#k14">*** 14. Načtení a zpracování dat uložených v&nbsp;textovém souboru</a></p>
<p><a href="#k15">*** 15. Použití uživatelsky definovaných datových typů v&nbsp;celém řetězci</a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. Zpracování dat větším množstvím počítačů v&nbsp;clusteru</a></p>
<p><a href="#k18">*** 18. Závěrečné zhodnocení</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Podpora programovacího paradigmatu založeného na tocích (dat) knihovnou <i>glow</i></h2>

<p>V&nbsp;dnešním článku, jenž nepřímo navazuje na článek <a
href="https://www.root.cz/clanky/programovaci-paradigma-zalozene-na-tocich-dat-a-knihovna-goflow/">Programovací
paradigma založené na tocích (dat) a knihovna goflow</a>, si popíšeme knihovnu
nazvanou <i>glow</i>. Jedná se o knihovnu podporující <i>FBP</i> neboli
<i>Flow-Based Programming</i> v&nbsp;programovacím jazyku Go. Toto paradigma se
poněkud odlišuje od dnes již klasického paradigmatu <i>dataflow</i> a zcela se
odlišuje od imperativního programování. Některé společné vlastnosti ale i
rozdíly mezi jednotlivými paradigmaty jsou shrnuty v&nbsp;následující
tabulce:</p>

<table>
<tr><th>Vlastnost</th><th>Flow-based</th><th>Dataflow</th><th>Imperativní</th></tr>
<tr><td>Základní myšlenka</td><td>data proudí mezi komponentami, které data transformují specifikovanými operacemi</td><td>data proudí mezi komponentami, které data transformují specifikovanými operacemi</td><td>operace jsou spouštěny nad daty v&nbsp;určitém přesně uvedeném pořadí a za určitých podmínek</td></tr>
<tr><td>Programovací model</td><td>graf s&nbsp;propojenými komponentami</td><td>graf s&nbsp;propojenými komponentami</td><td>sekvence instrukcí popisujících jednotlivé operace i jejich návaznost</td></tr>
<tr><td>Vizualizace modelu</td><td>graf toku dat</td><td>graf toku dat</td><td>vývojový diagram</td></tr>
<tr><td>Reprezentace modelu</td><td>vizuální (graf) + zdrojový kód komponent</td><td>typicky vizuální</td><td>prakticky vždy formou zdrojového kódu</td></tr>
<tr><td>Paralelizace</td><td>implicitní<br />(všechny operace mohou běžet paralelně)</td><td>implicitní nebo explicitní</td><td>explicitní<br />(paralelní běh musí být korektně popsán a naprogramován)</td></tr>
<tr><td>Model řízení</td><td>aktivní<br />(komponenty si řídí svůj životní cyklus)</td><td>reaktivní<br />(komponenty jsou aktivovány externími událostmi)</td><td>aktivní<br />(komponenty si řídí svůj životní cyklus)</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Krátké zopakování: programovací paradigma založené na tocích (dat)</h2>

<p><i>&bdquo;The real world is asynchronous: don't try to force everything into
a synchronous framework derived from the architecture of early
computers.&ldquo;<br />
J. Paul Morrison, inventor/discoverer of Flow-Based Programming</i></p>

<p>Zopakujme si nyní v&nbsp;krátkosti základní informace o programovacím
paradigmatu založenému na tocích dat, které se v&nbsp;angličtině označuje
zkratkou <i>FBP</i> znamenající <i>Flow-based programming</i>. Jedná se o
paradigma, v&nbsp;němž se aplikace definují jako sítě procesů &ndash;
&bdquo;černé skříňky&ldquo; &ndash;, které si mezi sebou posílají data
předáváním zpráv předem definovanými cestami (tedy nikoli &bdquo;náhodně&ldquo;
či libovolně, jako je tomu například v&nbsp;klasickém OOP). Tyto procesy neboli
černé skříňky lze prakticky libovolně propojovat a vytvářet tak různé aplikace,
aniž by bylo nutné je (tedy ony <i>procesy</i>) interně nějakým způsobem
modifikovat. FBP je tedy paradigma, které zcela přirozeně vede k&nbsp;tvorbě
více či méně samostatně pracujících komponent.</p>

<p>V&nbsp;FBP se upouští od klasického (řekněme von Neumannovského) pohledu na
aplikace jako na sekvenční proces. Namísto toho se aplikace modelují jako síť
asynchronně běžících procesů, které si předávají data přes <i>buffery</i>
(resp.&nbsp;přes <i>fronty</i>). Každý proces v&nbsp;FBP provádí činnost ve
chvíli, kdy dostává vstupní data a díky oddělení procesů a jejich nezávislosti
na ostatních procesech vlastně zcela zadarmo získáme plnou podporu pro
paralelní (a samozřejmě i souběžný) běh aplikace jako celku &ndash; o to bez
nutnosti explicitní práce s&nbsp;mutexy či s&nbsp;dalšími synchronizačními
mechanismy.</p>

<p><div class="rs-tip-major">Poznámka: každé programovací paradigma (kromě
původního nestrukturovaného programování) vývojářům nabízí vyšší úrovně
abstrakce, ovšem současně je i nutí se něčeho vzdát. V&nbsp;FBP se konkrétně
vzdáváme explicitního řízení/určení pořadí provádění operací pro všechny
vstupní události. To pochopitelně znamená, že FBP nemusí být výhodné pro
všechny typy aplikací.</div></p>

<p>Základními stavebními prvky při návrhu aplikace při použití paradigmatu FBP
jsou <i>komponenty</i>. Interně se typicky jedná o třídy, struktury+metody
(Go), uzávěry (<i>closure</i>) či někdy o obyčejné funkce popř.&nbsp;o funkce
se statickými proměnnými (pokud tento koncept daný programovací jazyk vůbec
podporuje). Instance <i>komponent</i> umístěné do grafu/sítě se nazývají
<i>procesy</i>. Z&nbsp;jedné komponenty lze pochopitelně odvodit větší množství
procesů.</p>

<p>Jednotlivé procesy spolu nekomunikují přímo (voláním), ale příjmem dat na
vstupních portech popř.&nbsp;posíláním dat na porty výstupní. Jednotlivá
spojení (<i>connection</i>) mohou obsahovat buffery resp.&nbsp;přesněji řečeno
fronty (<i>FIFO</i>, <i>queue</i>), typicky s&nbsp;předem nastavenou kapacitou
(tedy maximálním počtem v&nbsp;dané chvíli čekajících zpráv). Některá propojení
mohou mít kapacitu nastavenou na nulu; zde na sebe budou procesy čekat a
navzájem se tak do jisté míry synchronizovat &ndash; posílání či příjem dat
tedy může být blokující operací.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Knihovna <strong>glow</strong></h2>

<p>Knihovna <i>glow</i>, kterou se budeme v&nbsp;dnešním článku zabývat, celý
koncept nepatrně upravuje, a to takovým způsobem, že komponentami jsou běžné
anonymní nebo pojmenované funkce (popř.&nbsp;uzávěry &ndash; <i>closures</i>),
namísto portů se přímo pracuje s&nbsp;parametry funkcí (vstupní porty) a
návratovými hodnotami funkcí (výstupní porty). Navíc <i>glow</i>, na rozdíl od
mnoha dalších podobně koncipovaných knihoven, umožňuje automatické odvození
typů předávaných dat na základě typů parametrů a návratových hodnot. Výsledné
programy tedy vypadají dosti odlišně od klasických <i>FBP</i> programů, jak
ostatně uvidíme v&nbsp;navazujících kapitolách.</p>

<p><div class="rs-tip-major">Poznámka: knihovna <i>Glow</i> může být použita
pro zpracování dat na jediném počítači v&nbsp;rámci jediného procesu
(s&nbsp;mnoha gorutinami), ovšem taktéž je možné spustit souběžné (a paralelní)
zpracování na větším množství počítačů zapojených do clusteru.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instalace knihovny <strong>glow</strong></h2>

<p>Instalace této knihovny je jednoduchá. Postačuje si příkazem:</p>

<pre>
$ <strong>go mod init glow-test-1</strong>
</pre>

<p>vytvořit nový projektový soubor, který by měl vypadat následovně:</p>

<pre>
module glow-test-1
&nbsp;  
go 1.18
</pre>

<p>Dále ve stejném adresáři vytvoříme kostru programu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "flag"
        "fmt"
&nbsp;
        "github.com/chrislusf/glow/flow"
)
&nbsp;
func <strong>main</strong>() {
        flag.Parse()
&nbsp;
        flow.New()
}

</pre>

<p>Po zadání příkazu:</p>

<pre>
$ <strong>go get .</strong>
</pre>

<p>by se měly nainstalovat všechny potřebné balíčky:</p>

<pre>
go: downloading github.com/chrislusf/glow v0.0.0-20181102060906-4c40a2717eee
go: downloading github.com/psilva261/timsort v1.0.0
go: added github.com/chrislusf/glow v0.0.0-20181102060906-4c40a2717eee
go: added github.com/psilva261/timsort v1.0.0
</pre>

<p>A projektový soubor by se měl změnit do podoby:</p>

<pre>
module glow-test-1
&nbsp;  
go 1.18
&nbsp;  
require (
        github.com/chrislusf/glow v0.0.0-20181102060906-4c40a2717eee // indirect
        github.com/psilva261/timsort v1.0.0 // indirect
)
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;dalších demonstračních příkladech
bude projektový soubor obsahovat ještě další dvě závislosti:</div></p>

<pre>
module glow-test-1
&nbsp;  
go 1.18
&nbsp;  
require (
        github.com/chrislusf/glow v0.0.0-20181102060906-4c40a2717eee // indirect
        github.com/golang/protobuf v1.5.2 // indirect
        github.com/psilva261/timsort v1.0.0 // indirect
        google.golang.org/protobuf v1.26.0 // indirect
)
</pre>

<p><div class="rs-tip-major">Poznámka: tento projekt naleznete na adrese <a href="https://github.com/tisnik/go-root/tree/master/article_A0/glow-test-0/">https://github.com/tisnik/go-root/tree/master/article_A0/glow-test-0/</a>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Ukázka toku <i>Reduce&rarr;Map</i> (nejjednodušší možný praktický příklad)</h2>

<p>Ukažme si nyní nějaký reálněji pojatý příklad, v&nbsp;němž využijeme alespoň
základní možnosti nabízené knihovnou <i>Glow</i>. Naprogramujeme (jinými slovy
vytvoříme graf) následující operace:</p>

<ol>
<li>Vstupem bude sekvence celočíselných hodnot od 1 do 10.</li>
<li>Prvky z&nbsp;této sekvence budou postupně sečteny.</li>
<li>Výsledek součtu bude vypsán na standardní výstup.</li>
</ol>

<p>Graf tedy bude obsahovat trojici uzlů. Prvním z&nbsp;těchto uzlů je sekvence
celočíselných hodnot od 1 do 10. Ta se v&nbsp;knihovně <i>Glow</i> tvoří
metodou <strong>Slice</strong>:</p>

<pre>
Slice([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})
</pre>

<p>V&nbsp;dalším uzlu je tato sekvence postupně <i>redukována</i> operací
<strong>Reduce</strong>. Ta nejprve zpracuje první dvě hodnoty a vypočítá
mezivýsledek. Tento postupně akumulovaný mezivýsledek je použit společně
s&nbsp;dalším prvkem ve vstupní sekvenci pro další výpočet atd. atd. až je celá
vstupní sekvence (resp.&nbsp;v&nbsp;našem případě řez) zredukován na jedinou
výslednou hodnotu:</p>

<pre>
Reduce(sum)
</pre>

<p>A konečně v&nbsp;posledním uzlu je výsledek součtu vypsán na standardní
výstup:</p>

<pre>
Map(printSum)
</pre>

<p>Sestrojení celého grafu bude vypadat následovně &ndash; povšimněte si, že za
<strong>New</strong> se volají metody objektu představujícího celý graf:</p>

<pre>
flow.
        New().
        Slice([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}).
        Reduce(sum).
        Map(printSum)
</pre>

<p>Graf můžeme nejen vytvořit, ale i &bdquo;spustit&ldquo;, a to zavoláním
metody <strong>Run</strong>:</p>

<pre>
flow.
        New().
        Slice([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}).
        Reduce(sum).
        Map(printSum).Run()
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Realizace celého příkladu; výsledek výpočtu</h2>

<p>V&nbsp;definici grafu jsme použili dvojici funkcí <strong>sum</strong> a
<strong>printSum</strong>. Tyto dvě funkce samozřejmě musíme implementovat, a
to konkrétně následujícím způsobem:</p>

<pre>
func <strong>sum</strong>(x int, y int) int {
        return x + y
}
&nbsp;
func <strong>printSum</strong>(x int) {
        fmt.Println("Sum:", x)
}
</pre>

<p>Povšimněte si, že se jedná o jedinou část celého programu
(resp.&nbsp;definice grafu), v&nbsp;níž pracujeme s&nbsp;datovými typy.
Kontrolu datových typů, tedy zda jsou funkci <strong>sum</strong> skutečně
předána celá čísla a návratová hodnota této funkce odpovídá typu parametru
funkce <strong>printSum</strong>, automaticky provádí knihovně <i>Glow</i>.</p>

<p>Úplný zdrojový kód tohoto demonstračního příkladu vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "flag"
        "fmt"
&nbsp;
        "github.com/chrislusf/glow/flow"
)
&nbsp;
func <strong>sum</strong>(x int, y int) int {
        return x + y
}
&nbsp;
func <strong>printSum</strong>(x int) {
        fmt.Println("Sum:", x)
}
&nbsp;
func <strong>main</strong>() {
        flag.Parse()
&nbsp;
        flow.
                New().
                Slice([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}).
                Reduce(sum).
                Map(printSum).Run()
}
</pre>

<p>Po překladu a spuštění tohoto demonstračního příkladu by se měl na
standardní výstup vypsat výsledek součtu všech prvků ze vstupního řezu:</p>

<pre>
$ <strong>go run main.go</strong>
&nbsp;
Sum: 55
</pre>

<p><div class="rs-tip-major">Poznámka: tento projekt naleznete na adrese <a
href="https://github.com/tisnik/go-root/tree/master/article_A0/glow-test-1/">https://github.com/tisnik/go-root/tree/master/article_A0/glow-test-1/</a>.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Ukázka toku <i>Reduce&rarr;Map</i>, využití anonymních funkcí</h2>

<p>Mnohdy je programový kód, který se v&nbsp;rámci jednotlivých uzlů grafu
spouští, velmi krátký. To je ostatně i náš případ, protože těla funkcí
<strong>sum</strong> a <strong>printSum</strong> obsahují jediný příkaz.
V&nbsp;takovém případě může být výhodnější namísto pojmenovaných funkcí použít
funkce anonymní, jejichž těla budou zapsána přímo v&nbsp;definici grafu:</p>

<pre>
New().
Slice([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}).
Reduce(func(x int, y int) int {
        return x + y
}).
Map(func(x int) {
        println("sum:", x)
})
</pre>

<p>Podívejme se nyní na kód takto upraveného příkladu, v&nbsp;němž jsou opět
knihovnou <i>Glow</i> kontrolovány datové typy parametrů funkcí i návratových
hodnot (tedy vstupů a výstupů uzlů grafu):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "flag"

        "github.com/chrislusf/glow/flow"
)
&nbsp;
func <strong>main</strong>() {
        flag.Parse()
&nbsp;
        flow.
                New().
                Slice([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}).
                Reduce(func(x int, y int) int {
                        return x + y
                }).
                Map(func(x int) {
                        println("sum:", x)
                }).
                Run()
}
</pre>

<p>Výsledek získaný po překladu a spuštění by měl být totožný s&nbsp;předchozím
příkladem, o čemž se můžeme velmi snadno přesvědčit:</p>

<pre>
$ <strong>go run main.go</strong>
&nbsp;
sum: 55
</pre>

<p><div class="rs-tip-major">Poznámka: tento projekt naleznete na adrese <a
href="https://github.com/tisnik/go-root/tree/master/article_A0/glow-test-2/">https://github.com/tisnik/go-root/tree/master/article_A0/glow-test-2/</a>.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Nepatrně složitější graf toku: <i>Map&rarr;Reduce&rarr;Map</i></h2>

<p>Velká síla a potenciální užitečnost FBP (a vlastně i knihovny <i>Glow</i>)
spočívá v&nbsp;tom, že funkce vyššího řádu <strong>Map</strong> může být
aplikována souběžně (a v&nbsp;ideálním případě i paralelně) na velký počet
vstupních prvků. Tuto vlastnost jsme prozatím nevyužili, protože se
v&nbsp;<strong>Map</strong> pouze vytiskla jediná hodnota na standardní výstup.
Ovšem nic nám nebrání v&nbsp;tom upravit si původní příklad tak, že se všechny
prvky ze vstupního řezu souběžně zdvojnásobí, tj.&nbsp;interně vlastně vznikne
nový řez dále zpracovaný operací <strong>Reduce</strong>. Nová podoba definice
grafu bude vypadat následovně (první funkce <strong>Map</strong> je aplikována
paralelně):</p>

<pre>
Slice([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}).
Map(func(value int) int {
        return value * 2
}).
Reduce(func(x int, y int) int {
        return x + y
}).
Map(func(x int) {
        println("sum:", x)
}).
</pre>

<p>Podívejme se nyní na takto upravený kód demonstračního příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "flag"
&nbsp;
        "github.com/chrislusf/glow/flow"
)
&nbsp;
func <strong>main</strong>() {
        flag.Parse()
&nbsp;
        flow.
                New().
                Slice([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}).
                Map(func(value int) int {
                        return value * 2
                }).
                Reduce(func(x int, y int) int {
                        return x + y
                }).
                Map(func(x int) {
                        println("sum:", x)
                }).
                Run()
}
</pre>

<p>V&nbsp;případě, že přeložíme a spustíme tento demonstrační příklad, měla by
být výsledkem hodnota 110 a nikoli 55. Je to logické, protože se nesčítají
hodnoty z&nbsp;číselné řady 1, 2, 3, ... 10, ale z&nbsp;řady 2, 4, 6, ...
20:</p>

<pre>
$ <strong>go run main.go</strong>
&nbsp;
sum: 110
</pre>

<p><div class="rs-tip-major">Poznámka: tento projekt naleznete na adrese <a
href="https://github.com/tisnik/go-root/tree/master/article_A0/glow-test-3/">https://github.com/tisnik/go-root/tree/master/article_A0/glow-test-3/</a>.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Metoda <strong>Partition</strong></h2>

<p>Operace <strong>Map</strong>, s&nbsp;níž jsme se setkali v&nbsp;předchozích
kapitolách, může být na vstupní data aplikována paralelně. Nejdříve je ovšem
nutné tato vstupní data vhodným způsobem rozdělit do více skupin a následně
každou skupinu skutečně paralelně zpracovat. K&nbsp;tomuto účelu slouží metoda
<strong>Partition</strong>, které se předá počet oddílů, do kterých se vstupní
data rozdělí. Pokud například zadáme <strong>Partition(3)</strong>, budou
vstupní data rozdělena do tří oddílů atd.</p>

<p>Jak jsou však vstupní data rozdělena? Existují dvě možnosti &ndash; buď se
rozdělí na základě <i>klíče</i> nebo na základě hešovacího kódu. Rozdělení
podle klíče se provádí ve chvíli, kdy prvky ve vstupních datech mají podobu
struktury, řezu nebo pole (tedy ne, že prvky jsou uloženy v&nbsp;řezu či poli,
ale skutečně je každý prvek řezem či polem). V&nbsp;tomto případě je klíčem
první prvek ve struktuře/prvku poli. Pokud vstupní prvky mají odlišný datový
typ (typicky celé číslo, řetězec apod.), vypočítá se hešovací hodnota těchto
prvků a na základě této hodnoty se prvky rozdělí do oddílů.</p>

<p><div class="rs-tip-major">Poznámka: to ovšem znamená, že rozdělením prvků do
oddílů se ztratí původní pořadí prvků. Pro mnohé výpočty nehraje pořadí žádnou
roli (výpočet sumy), ovšem později si ukážeme příklad, kde má pořadí svůj
význam a změní výsledek.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Využití operace <i>Partition</i> zajišťující distribuci vstupních dat</h2>

<pre>
New().
Slice([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}).
Partition(3).
Map(func(value int) int {
        return value * 2
}).
Reduce(func(x int, y int) int {
        return x + y
}).
Map(func(x int) {
        println("sum:", x)
}).
</pre>

<p></p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "flag"
&nbsp;
        "github.com/chrislusf/glow/flow"
)
&nbsp;
func <strong>main</strong>() {
        flag.Parse()
&nbsp;
        flow.
                New().
                Slice([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}).
                Partition(3).
                Map(func(value int) int {
                        return value * 2
                }).
                Reduce(func(x int, y int) int {
                        return x + y
                }).
                Map(func(x int) {
                        println("sum:", x)
                }).
                Run()
}
</pre>

<p></p>

<pre>
$ <strong>go run main.go</strong>
&nbsp;
sum: 110
</pre>

<p><div class="rs-tip-major">Poznámka: tento projekt naleznete na adrese <a
href="https://github.com/tisnik/go-root/tree/master/article_A0/glow-test-4/">https://github.com/tisnik/go-root/tree/master/article_A0/glow-test-4/</a>.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Import takzvaného <i>driveru</i>; podpora pro vizualizaci grafu toku</h2>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "flag"
&nbsp;
        _ "github.com/chrislusf/glow/driver"
        "github.com/chrislusf/glow/flow"
)
&nbsp;
func <strong>main</strong>() {
        flag.Parse()
&nbsp;
        flow.
                New().
                Slice([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}).
                Partition(3).
                Map(func(value int) int {
                        return value * 2
                }).
                Reduce(func(x int, y int) int {
                        return x + y
                }).
                Map(func(x int) {
                        println("sum:", x)
                }).
                Run()
}
</pre>

<pre>
$ <strong>go build main.go </strong>
</pre>

<pre>
$ <strong>./glow-test-5 --help</strong>
</pre>

<pre>
Usage of ./main:
  -ca.file string
        A PEM eoncoded CA's certificate file
  -cert.file string
        A PEM eoncoded certificate file
  -glow
        start in driver mode
  -glow.agent.address string
        agent hostname:port
  -glow.channel.bufferSize int
        channel buffer size for reading inputs
  -glow.dataCenter string
        preferred data center name
  -glow.driver.host string
        driver runs on this host address. Required in 2-way SSL mode.
  -glow.driver.port int
        driver listens on this port to copy files to agents. Required to specify and open this port.
  -glow.exe.hash string
        hash of executable binary file
  -glow.flow.bid float
        total bid price in a flow to compete for resources (default 100)
  -glow.flow.id int
        flow id (default -1)
  -glow.flow.plot
        print out task group flow in graphviz dot format
  -glow.flow.stat
        show flow details at the end of execution
  -glow.leader string
        leader server (default "localhost:8930")
  -glow.module string
        a name to group related jobs together on agent
  -glow.rack string
        preferred rack name
  -glow.related.files string
        ':' separated list of files
  -glow.request.id uint
        request id received from agent
  -glow.task.memoryMB int
        request one task memory size in MB (default 64)
  -glow.task.name string
        name of first task in the task group
  -glow.taskGroup.id int
        task group id (default -1)
  -glow.taskGroup.inputs string
        comma and @ seperated input locations
  -key.file string
</pre>

<pre>
$ <strong>./glow-test-5 --glow --glow.flow.plot &gt; plot.gv</strong>
</pre>

<pre>
$ <strong>dot -Tpng plot.gv &gt; plot.png</strong>
</pre>

*** image ***
<p><i>Obrázek 1: Vizualizace grafu popsaného v&nbsp;pátém demonstračním
příkladu.</i></p>

<p><div class="rs-tip-major">Poznámka: tento projekt naleznete na adrese <a
href="https://github.com/tisnik/go-root/tree/master/article_A0/glow-test-5/">https://github.com/tisnik/go-root/tree/master/article_A0/glow-test-5/</a>.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Bezproblémové použití odlišných typů dat v&nbsp;jednotlivých hranách grafu toku</h2>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "flag"
        "strconv"
&nbsp;
        _ "github.com/chrislusf/glow/driver"
        "github.com/chrislusf/glow/flow"
)
&nbsp;
func <strong>main</strong>() {
        flag.Parse()
&nbsp;
        flow.
                New().
                Slice([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}).
                Partition(3).
                Map(func(value int) string {
                        return strconv.Itoa(value)
                }).
                Reduce(func(x string, y string) string {
                        return x + "," + y
                }).
                Map(func(x string) {
                        println("joined:", x)
                }).
                Run()
}
</pre>

*** image ***
<p><i>Obrázek 2: Vizualizace grafu popsaného v&nbsp;šestém demonstračním
příkladu.</i></p>

<p><div class="rs-tip-major">Poznámka: tento projekt naleznete na adrese <a
href="https://github.com/tisnik/go-root/tree/master/article_A0/glow-test-6/">https://github.com/tisnik/go-root/tree/master/article_A0/glow-test-6/</a>.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Vliv parametru předaného operaci <i>Partition</i> na průběh výpočtu</h2>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "flag"
        "strconv"
&nbsp;
        _ "github.com/chrislusf/glow/driver"
        "github.com/chrislusf/glow/flow"
)
&nbsp;
func <strong>newRangeSlice</strong>(sliceLength int) []int {
        result := make([]int, sliceLength)
        for i := 0; i &lt; sliceLength; i++ {
                result[i] = i + 1
        }
        return result
}
&nbsp;
func <strong>compute</strong>(sliceLength int, partitions int) {
        flow.
                New().
                Slice(newRangeSlice(sliceLength)).
                Partition(partitions).
                Map(func(value int) string {
                        return strconv.Itoa(value)
                }).
                Reduce(func(x string, y string) string {
                        return x + "," + y
                }).
                Map(func(x string) {
                        println("joined:", x)
                }).
                Run()
}
&nbsp;
func <strong>main</strong>() {
        flag.Parse()
&nbsp;
        compute(24, 1)
        compute(24, 2)
        compute(24, 3)
        compute(24, 4)
        compute(24, 12)
}
</pre>

<pre>
joined: 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24
joined: 1,3,5,7,9,11,13,15,17,19,21,23,2,4,6,8,10,12,14,16,18,20,22,24
joined: 3,6,9,12,15,18,21,24,1,4,7,10,13,16,19,22,2,5,8,11,14,17,20,23
joined: 4,8,12,16,20,24,1,5,9,13,17,21,2,6,10,14,18,22,3,7,11,15,19,23
joined: 12,24,1,13,2,14,3,15,4,16,5,17,6,18,7,19,8,20,9,21,10,22,11,23
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Načtení a zpracování dat uložených v&nbsp;textovém souboru</h2>

<p></p>

<pre>
package <strong>main</strong>

import (
        "flag"
        "strconv"

        _ "github.com/chrislusf/glow/driver"
        "github.com/chrislusf/glow/flow"
)

func <strong>main</strong>() {
        flag.Parse()

        flow.
                New().
                TextFile("data.txt", 1).
                Map(func(line string) int {
                        value, _ := strconv.Atoi(line)
                        return value
                }).
                Reduce(func(x int, y int) int {
                        return x + y
                }).
                Map(func(x int) {
                        println("sum:", x)
                }).
                Run()
}
</pre>

<p></p>

*** image ***
<p><i>Obrázek 3: Vizualizace grafu popsaného v&nbsp;osmém demonstračním
příkladu.</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<pre>
1983 Ken Thompson
1983 Dennis Ritchie
1988 Ivan Sutherland
1979 Kenneth Iverson
1989 William Kahan
1977 John Backus
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Použití uživatelsky definovaných datových typů v&nbsp;celém řetězci</h2>

<p></p>

<pre>
type <strong>Recipient</strong> struct {
        Year    int
        Name    string
        Surname string
}
</pre>

<pre>
TextFile("data.txt", 1).
Map(func(line string) []string {
        return strings.Fields(line)
}).
Map(func(input []string) Recipient {
        year, _ := strconv.Atoi(input[0])
        return Recipient{
                year,
                input[1],
                input[2]}
}).
Map(func(recipient Recipient) {
        fmt.Printf("%4d  %-12s  %-12s\n", recipient.Year, recipient.Name, recipient.Surname)
}).
</pre>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "flag"
        "fmt"
        "strconv"
        "strings"
&nbsp;
        _ "github.com/chrislusf/glow/driver"
        "github.com/chrislusf/glow/flow"
)
&nbsp;
type <strong>Recipient</strong> struct {
        Year    int
        Name    string
        Surname string
}
&nbsp;
func <strong>main</strong>() {
        flag.Parse()
&nbsp;
        flow.
                New().
                TextFile("data.txt", 1).
                Map(func(line string) []string {
                        return strings.Fields(line)
                }).
                Map(func(input []string) Recipient {
                        year, _ := strconv.Atoi(input[0])
                        return Recipient{
                                year,
                                input[1],
                                input[2]}
                }).
                Map(func(recipient Recipient) {
                        fmt.Printf("%4d  %-12s  %-12s\n", recipient.Year, recipient.Name, recipient.Surname)
                }).
                Run()
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "flag"
        "fmt"
        "strconv"
        "strings"
&nbsp;
        _ "github.com/chrislusf/glow/driver"
        "github.com/chrislusf/glow/flow"
)
&nbsp;
type <strong>Recipient</strong> struct {
        Year    int
        Name    string
        Surname string
}
&nbsp;
func <strong>main</strong>() {
        flag.Parse()
&nbsp;
        flow.
                New().
                TextFile("data.txt", 1).
                Map(func(line string) []string {
                        return strings.Fields(line)
                }).
                Map(func(input []string) Recipient {
                        year, _ := strconv.Atoi(input[0])
                        return Recipient{
                                year,
                                input[1],
                                input[2]}
                }).
                Sort(func(recipient1 Recipient, recipient2 Recipient) bool {
                        return recipient1.Year &lt; recipient2.Year
                }).
                Map(func(recipient Recipient) {
                        fmt.Printf("%4d  %-12s  %-12s\n", recipient.Year, recipient.Name, recipient.Surname)
                }).
                Run()
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "flag"
        "fmt"
        "strconv"
        "strings"
&nbsp;
        _ "github.com/chrislusf/glow/driver"
        "github.com/chrislusf/glow/flow"
)
&nbsp;
type <strong>Recipient</strong> struct {
        year    int
        name    string
        surname string
}
&nbsp;
func <strong>main</strong>() {
        flag.Parse()
&nbsp;
        flow.
                New().
                TextFile("data.txt", 1).
                Map(func(line string) []string {
                        return strings.Fields(line)
                }).
                Map(func(input []string) Recipient {
                        year, _ := strconv.Atoi(input[0])
                        return Recipient{
                                year,
                                input[1],
                                input[2]}
                }).
                Map(func(recipient Recipient) []Recipient {
                        var x []Recipient = []Recipient{recipient}
                        return x
                }).
                Reduce(func(recipients []Recipient, recipient []Recipient) []Recipient {
                        x := append(recipients, recipient...)
                        return x
                }).
                Map(func(recipients []Recipient) {
                        fmt.Println(" #  Year  First name    Surname")
                        for i, recipient := range recipients {
                                fmt.Printf("%2d  %4d  %-12s  %-12s\n", i, recipient.year, recipient.name, recipient.surname)
                        }
                }).
                Run()
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Zpracování dat větším množstvím počítačů v&nbsp;clusteru</h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Závěrečné zhodnocení</h2>

<p></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem &ndash;
alespoň prozatím &ndash; velmi malý, dnes má přibližně stovku kilobajtů),
můžete namísto toho použít odkazy na jednotlivé demonstrační příklady, které
naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad/soubor</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>glow-test-0/main.go</td><td>kostra projektu pro stažení všech závislých balíčků</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-0/main.go">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-0/main.go</a></td></tr>
<tr><td> 2</td><td>glow-test-0/go.mod</td><td>projektový soubor</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-0/go.mod">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-0/go.mod</a></td></tr>
<tr><td> 3</td><td>glow-test-0/go.sum</td><td>seznam přímých i nepřímých závislostí tohoto projektu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-0/go.sum">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-0/go.sum</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>glow-test-1/main.go</td><td>ukázka toku <i>Reduce&rarr;Map</i> (nejjednodušší možný příklad)</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-1/main.go">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-1/main.go</a></td></tr>
<tr><td> 5</td><td>glow-test-1/go.mod</td><td>projektový soubor</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-1/go.mod">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-1/go.mod</a></td></tr>
<tr><td> 6</td><td>glow-test-1/go.sum</td><td>seznam přímých i nepřímých závislostí tohoto projektu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-1/go.sum">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-1/go.sum</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>glow-test-2/main.go</td><td>ukázka toku <i>Reduce&rarr;Map</i>, využití anonymních funkcí</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-2/main.go">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-2/main.go</a></td></tr>
<tr><td> 8</td><td>glow-test-2/go.mod</td><td>projektový soubor</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-2/go.mod">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-2/go.mod</a></td></tr>
<tr><td> 9</td><td>glow-test-2/go.sum</td><td>seznam přímých i nepřímých závislostí tohoto projektu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-2/go.sum">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-2/go.sum</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>glow-test-3/main.go</td><td>tok <i>Map&rarr;Reduce&rarr;Map</i></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-3/main.go">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-3/main.go</a></td></tr>
<tr><td>11</td><td>glow-test-3/go.mod</td><td>projektový soubor</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-3/go.mod">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-3/go.mod</a></td></tr>
<tr><td>12</td><td>glow-test-3/go.sum</td><td>seznam přímých i nepřímých závislostí tohoto projektu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-3/go.sum">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-3/go.sum</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>glow-test-4/main.go</td><td>operace <i>Partition</i> zajišťující distribuci vstupních dat</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-4/main.go">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-4/main.go</a></td></tr>
<tr><td>14</td><td>glow-test-4/go.mod</td><td>projektový soubor</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-4/go.mod">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-4/go.mod</a></td></tr>
<tr><td>15</td><td>glow-test-4/go.sum</td><td>seznam přímých i nepřímých závislostí tohoto projektu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-4/go.sum">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-4/go.sum</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>glow-test-5/main.go</td><td>import driveru; podpora pro vizualizaci grafu toku</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-5/main.go">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-5/main.go</a></td></tr>
<tr><td>17</td><td>glow-test-5/go.mod</td><td>projektový soubor</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-5/go.mod">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-5/go.mod</a></td></tr>
<tr><td>18</td><td>glow-test-5/go.sum</td><td>seznam přímých i nepřímých závislostí tohoto projektu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-5/go.sum">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-5/go.sum</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>glow-test-6/main.go</td><td>bezproblémové použití odlišných typů dat v&nbsp;jednotlivých hranách grafu toku</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-6/main.go">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-6/main.go</a></td></tr>
<tr><td>20</td><td>glow-test-6/go.mod</td><td>projektový soubor</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-6/go.mod">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-6/go.mod</a></td></tr>
<tr><td>21</td><td>glow-test-6/go.sum</td><td>seznam přímých i nepřímých závislostí tohoto projektu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-6/go.sum">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-6/go.sum</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>glow-test-7/main.go</td><td>vliv počtu segmentů na průběh výpočtu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-7/main.go">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-7/main.go</a></td></tr>
<tr><td>23</td><td>glow-test-7/go.mod</td><td>projektový soubor</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-7/go.mod">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-7/go.mod</a></td></tr>
<tr><td>24</td><td>glow-test-7/go.sum</td><td>seznam přímých i nepřímých závislostí tohoto projektu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-7/go.sum">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-7/go.sum</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>glow-test-8/main.go</td><td>načítání dat ze souborů</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-8/main.go">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-8/main.go</a></td></tr>
<tr><td>26</td><td>glow-test-8/go.mod</td><td>projektový soubor</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-8/go.mod">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-8/go.mod</a></td></tr>
<tr><td>27</td><td>glow-test-8/go.sum</td><td>seznam přímých i nepřímých závislostí tohoto projektu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-8/go.sum">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-8/go.sum</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>28</td><td>glow-test-9/main.go</td><td>zpracování strukturovaných dat</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-9/main.go">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-8/main.go</a></td></tr>
<tr><td>29</td><td>glow-test-9/go.mod</td><td>projektový soubor</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-9/go.mod">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-8/go.mod</a></td></tr>
<tr><td>30</td><td>glow-test-9/go.sum</td><td>seznam přímých i nepřímých závislostí tohoto projektu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-9/go.sum">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-8/go.sum</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>31</td><td>glow-test-A/main.go</td><td>řazení (strukturovaných) dat</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-A/main.go">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-8/main.go</a></td></tr>
<tr><td>32</td><td>glow-test-A/go.mod</td><td>projektový soubor</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-A/go.mod">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-8/go.mod</a></td></tr>
<tr><td>33</td><td>glow-test-A/go.sum</td><td>seznam přímých i nepřímých závislostí tohoto projektu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-A/go.sum">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-8/go.sum</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>34</td><td>glow-test-B/main.go</td><td><i>map-reduce</i> a řezy v&nbsp;jazyce Go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-B/main.go">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-8/main.go</a></td></tr>
<tr><td>35</td><td>glow-test-B/go.mod</td><td>projektový soubor</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-B/go.mod">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-8/go.mod</a></td></tr>
<tr><td>36</td><td>glow-test-B/go.sum</td><td>seznam přímých i nepřímých závislostí tohoto projektu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-B/go.sum">https://github.com/tisnik/go-root/blob/master/article_A0/glow-test-8/go.sum</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>glow<br />
<a href="https://github.com/chrislusf/glow">https://github.com/chrislusf/glow</a>
</li>

<li>Glow - wiki<br />
<a href="https://github.com/chrislusf/glow/wiki#glow-apis">https://github.com/chrislusf/glow/wiki#glow-apis</a>
</li>

<li>Gleam<br />
<a href="https://github.com/chrislusf/gleam">https://github.com/chrislusf/gleam</a>
</li>

<li>Get into the flow<br />
<a href="https://appliedgo.net/flow/">https://appliedgo.net/flow/</a>
</li>

<li>Flow-based and dataflow programming library for Go programming language<br />
<a href="https://github.com/trustmaster/goflow">https://github.com/trustmaster/goflow</a>
</li>

<li>Flow-based programming (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Flow-based_programming">https://en.wikipedia.org/wiki/Flow-based_programming</a>
</li>

<li>FlowBasedProgramming (Python wiki)<br />
<a href="https://wiki.python.org/moin/FlowBasedProgramming">https://wiki.python.org/moin/FlowBasedProgramming</a>
</li>

<li>Flow Based Programming<br />
<a href="https://github.com/flowbased/flowbased.org/wiki">https://github.com/flowbased/flowbased.org/wiki</a>
</li>

<li>Concepts<br />
<a href="https://github.com/flowbased/flowbased.org/wiki/Concepts">https://github.com/flowbased/flowbased.org/wiki/Concepts</a>
</li>

<li>Circular buffer<br />
<a href="https://en.wikipedia.org/wiki/Circular_buffer">https://en.wikipedia.org/wiki/Circular_buffer</a>
</li>

<li>Circular Buffers in Linux kernel<br />
<a href="https://www.kernel.org/doc/html/latest/core-api/circular-buffers.html">https://www.kernel.org/doc/html/latest/core-api/circular-buffers.html</a>
</li>

<li>Flow-based Programming<br />
<a href="https://jpaulm.github.io/fbp/">https://jpaulm.github.io/fbp/</a>
</li>

<li>DrawFBP<br />
<a href="https://github.com/jpaulm/drawfbp">https://github.com/jpaulm/drawfbp</a>
</li>

<li>Panta Rhei<br />
<a href="https://blogs.bu.edu/marsh-vocation/2016/09/29/panta-rhei/">https://blogs.bu.edu/marsh-vocation/2016/09/29/panta-rhei/</a>
</li>

<li>Hérakleitos<br />
<a href="https://cs.wikipedia.org/wiki/H%C3%A9rakleitos">https://cs.wikipedia.org/wiki/H%C3%A9rakleitos</a>
</li>

<li>FlowBasedProgramming (Wiki)<br />
<a href="https://www.jpaulmorrison.com/cgi-bin/wiki.pl">https://www.jpaulmorrison.com/cgi-bin/wiki.pl</a>
</li>

<li>FBP Network Protocol<br />
<a href="https://flowbased.github.io/fbp-protocol/">https://flowbased.github.io/fbp-protocol/</a>
</li>

<li>Flow-based programming specification wiki<br />
<a href="https://flow-based.org/">https://flow-based.org/</a>
</li>

<li>Flow Based Programming<br />
<a href="http://wiki.c2.com/?FlowBasedProgramming">http://wiki.c2.com/?FlowBasedProgramming</a>
</li>

<li>FlowBasedProgramming<br />
<a href="http://www.jpaulmorrison.com/cgi-bin/wiki.pl">http://www.jpaulmorrison.com/cgi-bin/wiki.pl</a>
</li>

<li>BrokerageApplication<br />
<a href="http://www.jpaulmorrison.com/cgi-bin/wiki.pl?BrokerageApplication">http://www.jpaulmorrison.com/cgi-bin/wiki.pl?BrokerageApplication</a>
</li>

<li>What the Hell Is Flow-Based Programming?<br />
<a href="https://medium.com/bitspark/what-the-hell-is-flow-based-programming-d9e88a6a7265">https://medium.com/bitspark/what-the-hell-is-flow-based-programming-d9e88a6a7265</a>
</li>

<li>Flow-based visual scripting for Python<br />
<a href="https://ryven.org/">https://ryven.org/</a>
</li>

<li>PyFlow<br />
<a href="https://github.com/gangtao/pyflow">https://github.com/gangtao/pyflow</a>
</li>

<li>Flow-based Programming<br />
<a href="https://pypi.org/project/flowpipe/">https://pypi.org/project/flowpipe/</a>
</li>

<li>The state of Flow-based Programming<br />
<a href="https://blog.kodigy.com/post/state-of-flow-based-programming/">https://blog.kodigy.com/post/state-of-flow-based-programming/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>
