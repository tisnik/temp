<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Datové typy v programovacím jazyku Go</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Datové typy v programovacím jazyku Go</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části seriálu o programovacím jazyku Go se seznámíme především s typovým systémem tohoto jazyka. Kromě jednoduchých datových typů si samozřejmě popíšeme i složené datové typy, především pole, řetězce, řezy a struktury (záznamy).</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Datové typy v&nbsp;programovacím jazyku Go</a></p>
<p><a href="#k02">*** 2. Celočíselné datové typy</a></p>
<p><a href="#k03">*** 3. Konverze mezi hodnotami různých typů</a></p>
<p><a href="#k04">*** 4. Tisk a formátování celočíselných hodnot</a></p>
<p><a href="#k05">*** 5. Podmnožiny reálných čísel a komplexní čísla</a></p>
<p><a href="#k06">*** 6. Pravdivostní hodnoty</a></p>
<p><a href="#k07">*** 7. Řetězce</a></p>
<p><a href="#k08">*** 8. Deklarace lokálních proměnných, implicitní hodnoty proměnných</a></p>
<p><a href="#k09">*** 9. Konstanty</a></p>
<p><a href="#k10">*** 10. Ukazatele a jejich význam v&nbsp;jazyku Go</a></p>
<p><a href="#k11">*** 11. Struktury (záznamy)</a></p>
<p><a href="#k12">*** 12. Základní operace se strukturami</a></p>
<p><a href="#k13">*** 13. Pole</a></p>
<p><a href="#k14">*** 14. Základní operace s&nbsp;poli</a></p>
<p><a href="#k15">*** 15. Řezy (slices), jejich význam a rozdílné vlastnosti oproti polím</a></p>
<p><a href="#k16">*** 16. Základní operace s&nbsp;řezy</a></p>
<p><a href="#k17">*** 17. Pokročilejší operace s&nbsp;řezy</a></p>
<p><a href="#k18">*** 18. Speciální hodnota <strong>nil</strong> a její specifický význam v&nbsp;jazyku Go</a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Datové typy v&nbsp;programovacím jazyku Go</h2>

<p>V&nbsp;dnešním článku se seznámíme s&nbsp;typovým systémem programovacího jazyka Go. Připomeňme si, že Go používá statický typový systém, což konkrétně znamená, že typ proměnné, parametru funkce, návratové hodnoty funkce atd. musí být známý již v&nbsp;době překladu (<i>compile time</i>) a není ho tedy nutné vyhodnocovat a kontrolovat v&nbsp;čase běhu programu (<i>runtime</i>). Datové typy, které jazyk Go programátorům nabízí, je možné rozdělit podle několika kritérií. Základní dělení je na jednoduché datové typy (typicky se hodnoty těchto typů dají uložit do jediného registru mikroprocesoru), složené datové typy a některé zvláštní typy (zde ukazatel, funkce, rozhraní a taktéž kanál). Jednoduché datové typy se někdy dělí na ordinální a neordinální. Celá hierarchie typového systému jazyka Go je zobrazena pod tímto odstavcem:</p>

<ul>
    <li>Jednoduché datové typy
        <ul>
            <li>Ordinální
                <ul>
                    <li>Pravdivostní typ (<i>boolean</i>)</li>
                    <li>Celočíselné typy (<i>integer</i>)</li>
                </ul>
                </li>
                <li>Neordinální
                <ul>
                    <li>Hodnoty s&nbsp;plovoucí řádovou čárkou (<i>float</i>)</li>
                    <li>Komplexní čísla (<i>complex</i>)</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>Složené datové typy
        <ul>
            <li>Řetězce (<i>string</i>)</li>
            <li>Pole (<i>array</i>)</li>
            <li>Řezy (<i>slice</i>)</li>
            <li>Záznamy (<i>struct</i>)</li>
            <li>Mapa (<i>map</i>)</li>
        </ul>
    </li>
    <li>Zvláštní datové typy
        <ul>
            <li>Ukazatel (<i>pointer</i>)</li>
            <li>Funkce (<i>function</i>)</li>
            <li>Rozhraní (<i>interface</i>)</li>
            <li>Kanál (<i>channel</i>)</li>
        </ul>
    </li>
</ul>

<p><div class="rs-tip-major">Poznámka: v&nbsp;Go je samozřejmě podporována deklarace vlastních datových typů, což je velmi důležité téma, kterému se budeme věnovat příště.</div></p>

<p><div class="rs-tip-major">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</div></p>


<p><a name="k02"></a></p>
<h2 id="k02">2. Celočíselné datové typy</h2>

<p>Programovací jazyk Go je navržen takovým způsobem, aby ho bylo možné efektivně provozovat na mainstreamových mikroprocesorových architekturách, což konkrétně znamená x86 (32bit), x86-64 (64bit), ARM32 (velká rodina několika 32bitových architektur) a neoficiálně taktéž AArch64 (64bit). Z&nbsp;tohoto důvodu v&nbsp;Go nalezneme takové celočíselné datové typy, které jsou na zmíněných architekturách zpracovávány. To je poměrně značně odlišná strategie, než kterou se vydal programovací jazyk C, v&nbsp;němž se formát a šířka celočíselných datových typů odvozuje použité architektury (například různé mikrořadiče či DSP používají mnohdy zcela odlišné formáty, ostatně podobně, jako tomu bylo na minipočítačích PDP atd.). V&nbsp;následující tabulce jsou vypsány všechny celočíselné datové typy poskytované jazykem Go 1.x. Každý celočíselný datový typ je jednoznačně určen jediným klíčovým slovem; nenajdeme zde tedy modifikátory <strong>signed</strong>, <strong>unsigned</strong>, <strong>short</strong>, <strong>long</strong> atd.:</p>

<table>
<tr><th>Označení</th><th>Rozsah hodnot</th><th>Stručný popis</th></tr>
<tr><td>int8 </td><td>-128 až 127</td><td>osmibitové celé číslo se znaménkem</td></tr>
<tr><td>int16</td><td>-32768 až 32767</td><td>16bitové celé číslo se znaménkem</td></tr>
<tr><td>int32</td><td>-2147483648 až 2147483647</td><td>32bitové celé číslo se znaménkem</td></tr>
<tr><td>int64</td><td>-9223372036854775808 až 9223372036854775807</td><td>64bitové celé číslo se znaménkem</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>uint8 </td><td>0 až 255</td><td>osmibitové celé číslo bez znaménka</td></tr>
<tr><td>uint16</td><td>0 až 65535</td><td>16bitové celé číslo bez znaménka</td></tr>
<tr><td>uint32</td><td>0 až 4294967295</td><td>32bitové celé číslo bez znaménka</td></tr>
<tr><td>uint64</td><td>0 až 18446744073709551615</td><td>64bitové celé číslo bez znaménka</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>int </td><td>různý</td><td>odpovídá buď int32 nebo int64</td></tr>
<tr><td>uint</td><td>různý</td><td>odpovídá buď uint32 nebo uint64</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>byte</td><td>0 až 255</td><td>alias pro uint8</td></tr>
<tr><td>rune</td><td>-2147483648 až 2147483647</td><td>alias pro int32</td></tr>
<tr><td>uintptr</td><td>různý</td><td>používáno pro uložení adresy (ukazatele)</td></tr>
</table>

<p><div class="rs-tip-major">Povšimněte si, že v&nbsp;předchozí tabulce byl u většiny celočíselných datových typů přesně uveden rozsah hodnot. Je tomu tak z&nbsp;toho důvodu, že specifikace jazyka Go určuje přesnou bitovou šířku typů a taktéž to, že celočíselné hodnoty se znaménkem mají být reprezentovány ve dvojkovém doplňku. To je poměrně velký rozdíl oproti programovacímu jazyku C, v&nbsp;jehož specifikaci se u základního typu <i>int</i> a jeho variant (<i>short</i>, <i>long</i>, <i>long long</i>) naschvál tyto informace neuvádí, protože céčko je provozováno i na mnohdy obskurních architekturách.</div></p>

<p>Dále stojí za povšimnutí existence takzvaných <i>aliasů</i>, které se používají ve dvou významech. První aliasy <i>int</i> a <i>unint</i> odpovídají buď 32bitové nebo 64bitové šířce celočíselného datového typu v&nbsp;závislosti na architektuře (zde se alespoň do jisté míry přibližujeme k&nbsp;céčku); ovšem zajímavější jsou aliasy <i>byte</i> (vždy osmibitová hodnota bez znaménka) a <i>rune</i> (reprezentace znaku v&nbsp;Unicode). Poslední alias <i>uintptr
</i> reprezentuje datový typ pro uložení ukazatele (pointeru) a je tedy opět závislý na konkrétní architektuře.</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a int8 = -10
        var b int16 = -1000
        var c int32 = -10000
        var d int32 = -1000000
&nbsp;
        var r1 rune = 'a'
        var r2 rune = '\x40'
        var r3 rune = '\n'
        var r4 rune = '\u03BB'
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
        fmt.Println(c)
        fmt.Println(d)
&nbsp;
        fmt.Println(r1)
        fmt.Println(r2)
        fmt.Println(r3)
        fmt.Println(r4)
}
</pre>

<pre>
-10
-1000
-10000
-1000000
97
64
10
955
</pre>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a int8 = -1000
        var b int16 = -100000
        var c int32 = -10000000000
        var d int32 = -10000000000000000
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
        fmt.Println(c)
        fmt.Println(d)
}
</pre>

<pre>
./02_integer_signed_types_checks.go:13:15: constant -1000 overflows int8
./02_integer_signed_types_checks.go:14:16: constant -100000 overflows int16
./02_integer_signed_types_checks.go:15:16: constant -10000000000 overflows int32
./02_integer_signed_types_checks.go:16:16: constant -10000000000000000 overflows int32
</pre>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a uint8 = 10
        var b uint16 = 1000
        var c uint32 = 10000
        var d uint32 = 1000000
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
        fmt.Println(c)
        fmt.Println(d)
}
</pre>

<pre>
10
1000
10000
1000000
</pre>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a uint8 = 10
        var b uint8 = 010
        var c uint8 = 0x10
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
        fmt.Println(c)
&nbsp;
        var d int8 = -10
        var e int8 = -010
        var f int8 = -0x10
&nbsp;
        fmt.Println(d)
        fmt.Println(e)
        fmt.Println(f)
}
</pre>

<pre>
10
8
16
-10
-8
-16
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Konverze mezi hodnotami různých typů</h2>

<p>V&nbsp;mnoha programovacích jazycích nalezneme různá více či méně složitá pravidla, která se týkají konverzí mezi hodnotami odlišných datových typů. V&nbsp;Go se používají poměrně silná pravidla týkající se konverzí. Tato pravidla například neumožní ani implicitní převody mezi typy <strong>uint8</strong> a <strong>uint16</strong></p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a uint8 = 255
        var b uint16 = a
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
}
</pre>

<p></p>

<pre>
./05_improper_conversion.go:14:6: cannot use a (type uint8) as type uint16 in assignment
</pre>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a uint16 = 255
        var b uint8 = a
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
}
</pre>

<pre>
./06_improper_conversion.go:14:6: cannot use a (type uint16) as type uint8 in assignment
</pre>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a int8 = 100
        var b uint8 = a
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
&nbsp;
        var c uint8 = 100
        var d int8 = c
&nbsp;
        fmt.Println(c)
        fmt.Println(d)
}
</pre>

<pre>
./07_improper_conversion_int_uint.go:14:6: cannot use a (type int8) as type uint8 in assignment
./07_improper_conversion_int_uint.go:20:6: cannot use c (type uint8) as type int8 in assignment
</pre>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a int8 = -10
        var signed_int int32 = -100000
        var unsigned_int uint32 = 100000
        var e float32 = 1e4
        var f float64 = 1.5e30
&nbsp;
        var x int32 = int32(a)
        var y int32 = int32(e)
        var z float32 = float32(f)
&nbsp;
        fmt.Println(x)
        fmt.Println(y)
        fmt.Println(z)
&nbsp;
        var b2 uint8 = uint8(signed_int)
        var b3 uint8 = uint8(unsigned_int)
&nbsp;
        fmt.Println(b2)
        fmt.Println(b3)
}
</pre>

<pre>
-10
10000
1.5e+30
96
160
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Tisk a formátování celočíselných hodnot</h2>

<p>Pro tisk a popř.&nbsp;i základní naformátování celočíselných hodnot na standardním výstupu slouží funkce <strong>fmt.Println</strong>. Tato funkce jako první parametr akceptuje takzvaný formátovací řetězec, jehož obsah je do jisté míry podobný, jako je tomu v&nbsp;céčkovské standardní funkci <a href="">printf</a>, popř.&nbsp;javovské metodě <a href="">String.format</a>. Pro celočíselné datové typy se používá především </p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a uint8 = 20
        var b uint16 = 2000
        var c uint32 = 20000
        var d uint32 = 2000000
&nbsp;
        fmt.Println("%d")
        fmt.Printf("%d\n", a)
        fmt.Printf("%d\n", b)
        fmt.Printf("%d\n", c)
        fmt.Printf("%d\n", d)
&nbsp;
        fmt.Println("\n%5d")
        fmt.Printf("%5d\n", a)
        fmt.Printf("%5d\n", b)
        fmt.Printf("%5d\n", c)
        fmt.Printf("%5d\n", d)
&nbsp;
        fmt.Println("\n%05d")
        fmt.Printf("%05d\n", a)
        fmt.Printf("%05d\n", b)
        fmt.Printf("%05d\n", c)
        fmt.Printf("%05d\n", d)
&nbsp;
        fmt.Println("\n%-5d")
        fmt.Printf("%-5d\n", a)
        fmt.Printf("%-5d\n", b)
        fmt.Printf("%-5d\n", c)
        fmt.Printf("%-5d\n", d)
&nbsp;
        fmt.Println("\n%+5d")
        fmt.Printf("%+5d\n", a)
        fmt.Printf("%+5d\n", b)
        fmt.Printf("%+5d\n", c)
        fmt.Printf("%+5d\n", d)
&nbsp;
        fmt.Println("\n%x")
        fmt.Printf("%x\n", a)
        fmt.Printf("%x\n", b)
        fmt.Printf("%x\n", c)
        fmt.Printf("%x\n", d)
&nbsp;
        fmt.Println("\n%X")
        fmt.Printf("%X\n", a)
        fmt.Printf("%X\n", b)
        fmt.Printf("%X\n", c)
        fmt.Printf("%X\n", d)
&nbsp;
        fmt.Println("\n%b")
        fmt.Printf("%b\n", a)
        fmt.Printf("%b\n", b)
        fmt.Printf("%b\n", c)
        fmt.Printf("%b\n", d)
}
</pre>

<pre>
%d
20
2000
20000
2000000

%5d
   20
 2000
20000
2000000

%05d
00020
02000
20000
2000000

%-5d
20   
2000 
20000
2000000

%+5d
  +20
+2000
+20000
+2000000

%x
14
7d0
4e20
1e8480

%X
14
7D0
4E20
1E8480

%b
10100
11111010000
100111000100000
111101000010010000000
</pre>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a int8 = -10
        var b int16 = -1000
        var c int32 = -10000
        var d int32 = -1000000
&nbsp;
        var r1 rune = 'a'
        var r2 rune = '\x40'
        var r3 rune = '\n'
        var r4 rune = '\u03BB'
&nbsp;
        fmt.Println("%d")
        fmt.Printf("%d\n", a)
        fmt.Printf("%d\n", b)
        fmt.Printf("%d\n", c)
        fmt.Printf("%d\n", d)
&nbsp;
        fmt.Println("\n%5d")
        fmt.Printf("%5d\n", a)
        fmt.Printf("%5d\n", b)
        fmt.Printf("%5d\n", c)
        fmt.Printf("%5d\n", d)
&nbsp;
        fmt.Println("\n%05d")
        fmt.Printf("%05d\n", a)
        fmt.Printf("%05d\n", b)
        fmt.Printf("%05d\n", c)
        fmt.Printf("%05d\n", d)
&nbsp;
        fmt.Println("\n%-5d")
        fmt.Printf("%-5d\n", a)
        fmt.Printf("%-5d\n", b)
        fmt.Printf("%-5d\n", c)
        fmt.Printf("%-5d\n", d)
&nbsp;
        fmt.Println("\n%+5d")
        fmt.Printf("%+5d\n", a)
        fmt.Printf("%+5d\n", b)
        fmt.Printf("%+5d\n", c)
        fmt.Printf("%+5d\n", d)
&nbsp;
        fmt.Println("\n%x")
        fmt.Printf("%x\n", a)
        fmt.Printf("%x\n", b)
        fmt.Printf("%x\n", c)
        fmt.Printf("%x\n", d)
&nbsp;
        fmt.Println("\n%X")
        fmt.Printf("%X\n", a)
        fmt.Printf("%X\n", b)
        fmt.Printf("%X\n", c)
        fmt.Printf("%X\n", d)
&nbsp;
        fmt.Println("\n%b")
        fmt.Printf("%b\n", a)
        fmt.Printf("%b\n", b)
        fmt.Printf("%b\n", c)
        fmt.Printf("%b\n", d)
&nbsp;
        fmt.Println("%c")
        fmt.Printf("%c\n", r1)
        fmt.Printf("%c\n", r2)
        fmt.Printf("%c\n", r3)
        fmt.Printf("%c\n", r4)
}
</pre>

<pre>
%d
-10
-1000
-10000
-1000000

%5d
  -10
-1000
-10000
-1000000

%05d
-0010
-1000
-10000
-1000000

%-5d
-10  
-1000
-10000
-1000000

%+5d
  -10
-1000
-10000
-1000000

%x
-a
-3e8
-2710
-f4240

%X
-A
-3E8
-2710
-F4240

%b
-1010
-1111101000
-10011100010000
-11110100001001000000
%c
a
@


λ
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Podmnožiny reálných čísel a komplexní čísla</h2>

<p>V&nbsp;programovacím jazyku Go samozřejmě nalezneme i datové typy určené pro uložení podmnožiny reálných čísel. Podobně, jako je tomu v&nbsp;prakticky všech moderních programovacích jazycích, jsou tyto datové typy odvozeny od formátů numerických hodnot specifikovaných <a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/?ic=serial-box&icc=text-title#k02">v&nbsp;normě IEEE 754</a> (ať již v&nbsp;její základní variantě, či novější verzi). K&nbsp;dispozici jsou tedy dva základní typy: čísla s&nbsp;jednoduchou přesností a čísla s&nbsp;přesností dvojitou. V&nbsp;mnoha programovacích jazycích se jména těchto typů odvozují skutečně od zmíněné normy IEEE 754, ovšem v&nbsp;Go (a podobně i v&nbsp;Rustu, i když Rust používá ještě kratší jména) jsou zvolena odlišná označení, konkrétně <strong>float32</strong> a <strong>float64</strong>. Kromě toho najdeme v&nbsp;jazyku Go i typy <strong>complex64</strong> a <strong>complex128</strong> pro reprezentaci komplexních čísel. Interně se jedná o dvojici <strong>float32+float32</strong> nebo <strong>float64+float64</strong>:</p>

<table>
<tr><th>Označení</th><th>Rozsah hodnot</th><th>Stručný popis</th></tr>
<tr><td>float32</td><td>-3,4&times;10<sup>38</sup> až 3,4&times;10<sup>38</sup></td><td>číslo s&nbsp;jednoduchou přesností podle IEEE 754</td></tr>
<tr><td>float64</td><td>-1,7&times;10<sup>308</sup> až 1,7&times;10<sup>308</sup></td><td>číslo s&nbsp;dvojitou přesností podle IEEE 754</td></tr>
<tr><td>complex64</td><td>&pm; rozsah float32 + i &pm; rozsah float32</td><td>dvojice hodnot s&nbsp;jednoduchou přesností</td></tr>
<tr><td>complex128</td><td>&pm; rozsah float64 + i &pm; rozsah float64</td><td>dvojice hodnot s&nbsp;dvojitou přesností</td></tr>
</table>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a float32 = -1.5
        var b float32 = 1.5
        var c float32 = 1e30
        var d float32 = 1e-30
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
        fmt.Println(c)
        fmt.Println(d)
&nbsp;
        var e float64 = -1.5
        var f float64 = 1.5
        var g float64 = 1e300
        var h float64 = 1e-300
&nbsp;
        fmt.Println(e)
        fmt.Println(f)
        fmt.Println(g)
        fmt.Println(h)
}
</pre>

<pre>
package main
&nbsp;
func main() {
        var c float32 = 1e300
        var d float32 = -1e300
&nbsp;
        var g float64 = 1e3000
        var h float64 = -1e3000
}
</pre>

<p>Podívejme se nyní, jakým způsobem se zapisují hodnoty typu <strong>complex64</strong> nebo <strong>complex128</strong>. Používá se zápis, který pravděpodobně znáte z&nbsp;matematiky: za druhé číslo se připojuje označení imaginární jednotky. Ta je v&nbsp;Go zapisována znakem <strong>i</strong> (matematický způsob) a nikoli <strong>j</strong> (elektro, taktéž Python). Nutno říci, že zápis s&nbsp;&bdquo;i&ldquo; je z&nbsp;typografického hlediska hezčí :-). V&nbsp;dalším programu si povšimněte, že můžeme zapsat pouze imaginární část čísla, ovšem před &bdquo;i&ldquo; musí být vždy alespoň jedna číslice (jinak by došlo k&nbsp;chybě popř.&nbsp;k&nbsp;přiřazení hodnoty proměnné <strong>i</strong>, pokud náhodou existuje):</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a complex64 = -1.5 + 0i
        var b complex64 = 1.5 + 1000i
        var c complex64 = 1e30 + 1e30i
        var d complex64 = 1i
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
        fmt.Println(c)
        fmt.Println(d)
&nbsp;
        var e complex128 = -1.5 + 0i
        var f complex128 = 1.5 + 1000i
        var g complex128 = 1e300 + 1e300i
&nbsp;
        fmt.Println(e)
        fmt.Println(f)
        fmt.Println(g)
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Pravdivostní hodnoty</h2>

<p>V&nbsp;programovacím jazyku Go je samozřejmě možné pracovat i s&nbsp;pravdivostními hodnotami, které jsou reprezentovány pravdivostním typem (<i>boolean</i>). Tento datový typ používá pouze dvě hodnoty, které jsou pojmenovány klasicky <strong>true</strong> a <strong>false</strong> (pro Pythonisty: s&nbsp;malými písmeny na začátku). Příklad základního použití tohoto datového typu je velmi jednoduchý:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a bool = true
        var b bool = false
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
}
</pre>

<p>Na tomto místě je vhodné upozornit na fakt, že v&nbsp;programovacím jazyce Go není možné provést automatický a implicitní převod mezi celočíselným typem a pravdivostní hodnotou. Podobně nelze provést převod mezi řetězcem (polem atd.) a pravdivostní hodnotou, na rozdíl od některých jiných programovacích jazyků (příkladem může být Python s&nbsp;několika hodnotami, které se vyhodnotí jako <strong>false</strong>, kdežto všechny ostatní hodnoty mohou být v&nbsp;logických výrazech považovány za <strong>true</strong>). Vyzkoušejme si tuto vlastnost jazyka Go na dalším příkladu:</p>

<pre>
package main
&nbsp;
import "fmt"

func main() {
        var a bool = true
        var b bool = false
        var c bool = 0
        var d bool = ""

        fmt.Println(a)
        fmt.Println(b)
        fmt.Println(c)
        fmt.Println(d)
}
</pre>

<p>Při pokusu o překlad tohoto zdrojového kódu se zobrazí chybová hlášení o nemožnosti provedení konverze:</p>

<pre>
</pre>


<p><a name="k07"></a></p>
<h2 id="k07">7. Řetězce</h2>

<p>Naprostá většina moderních programovacích jazyků podporuje práci s&nbsp;řetězci, přesněji řečeno řetězce jsou plnohodnotným datovým typem (výjimkou je vlastně jen klasické céčko, které rozpoznává jen řetězcové literály). Nejinak je tomu i v&nbsp;jazyce Go, v&nbsp;němž nalezneme datový typ <strong>string</strong>. Interně se s&nbsp;řetězcem pracuje stejně, jako s&nbsp;řezem (<i>slice</i>) pole bajtů (s&nbsp;pojmem řez se seznámíme v&nbsp;dalších kapitolách). A právě z&nbsp;tohoto způsobu práce s&nbsp;řetězci vychází i jejich základní vlastnosti, které mohou některé programátory překvapit a je dobré je znát:</p>

<ol>
<li>V&nbsp;první řadě jsou řetězce neměnitelné (<i>immutable</i>).</li>
<li>Dále je u řetězců známá jejich délka, ovšem udávaná v&nbsp;bajtech, nikoli ve znacích.</li>
<li>Při přístupu k&nbsp;jednotlivým prvkům řetězce pomocí operátoru indexování [] získáme jednotlivé bajty, nikoli znaky.</li>
<li>A za čtvrté: v&nbsp;řetězci je skutečně možné mít uloženy libovolné kombinace bajtů. Teprve až ve chvíli, kdy budeme chtít pracovat s&nbsp;jednotlivými znaky, budou se jednotlivé sekvence bajtů transformovat do Unicode (k&nbsp;tomu je ovšem nutné použít buď jednu z&nbsp;forem smyčky <strong>for</strong> nebo knihovní funkce).</p></li>
</ol>

<p>I když jsou řetězce interně reprezentovány jako sekvence bajtů, můžeme ve zdrojovém kódu používat řetězcové literály obsahující znaky z&nbsp;Unicode. Z&nbsp;předchozího článku již víme, že zdrojové kódy psané v&nbsp;Go jsou uloženy v&nbsp;UTF-8, takže by to nemělo představovat žádný problém. Povšimněte si, že samozřejmě můžeme použít prázdný řetězec a v&nbsp;řetězci mohou být umístěny řídicí znaky zapisované stejně, jako v&nbsp;C/C++, Javě atd. atd:</p>

<pre>
package main

import "fmt"

func main() {
        var s1 string = "www.root.cz"
        var s2 string = ""
        var s3 string = "Hello\nworld!\n"
        var s4 string = "шщэюя"

        fmt.Println(s1)
        fmt.Println(s2)
        fmt.Println(s3)
        fmt.Println(s4)
}
</pre>

<p>V&nbsp;některých situacích může být výhodné zapsat řetězec v&nbsp;přesně takové podobě, jak má být uložen v&nbsp;paměti; tj.&nbsp;budeme potřebovat zrušit význam řídicích znaků "\n" atd. I to je možné, protože programovací jazyk Go podporuje takzvané &bdquo;raw&ldquo; řetězce, které se nezapisují do uvozovek, ale do zpětných apostrofů (<i>backtick</i>). Díky tomuto způsobu zápisu řetězce se vyhneme nutnosti zdvojování zpětného lomítka a podobných triků:</p>

<pre>
package main

import "fmt"

func main() {
        var s1 string = "Hello\nworld!\n"
        var s2 string = `Hello\nworld!\n`

        fmt.Println(s1)
        fmt.Println(s2)
}
</pre>

<pre>
package main

import "fmt"

func main() {
        var s string = "Hello\nworld!\nžluťoučký kůň"

        for i := 0; i &lt; len(s); i++ {
                fmt.Printf("%02x ", s[i])
        }
}
</pre>

<pre>
48 65 6c 6c 6f 0a 77 6f 72 6c 64 21 0a c5 be 6c 75 c5 a5 6f 75 c4 8d 6b c3 bd 20 6b c5 af c5 88
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Deklarace lokálních proměnných, implicitní hodnoty proměnných</h2>

<p>S&nbsp;deklaracemi proměnných jsme se již setkali v&nbsp;první části tohoto seriálu, takže si jen krátce zopakujme, že lokální proměnné je nutné deklarovat a popř.&nbsp;i inicializovat. Deklarace lokálních proměnných různých typů může vypadat následovně:</p>

<pre>
</pre>

<p>Společně s&nbsp;deklaracemi proměnných je umožněno provést i jejich inicializaci:</p>

<pre>
</pre>

<p>Vzhledem k&nbsp;tomu, že překladač pozná, jakého typu je <i>hodnota</i> přiřazovaná do proměnné, může být explicitní specifikace jejího typu poněkud nadbytečné. Pro zkrácený zápis deklarace proměnné s&nbsp;její inicializací je v&nbsp;programovacím jazyku Go vytvořen operátor :=, který se používá následujícím způsobem (opět ho známe z&nbsp;předchozího článku):</p>

<pre>
</pre>

<pre>
package main

import "fmt"

func main() {
        var i1 int8
        var i2 int32
        var u1 uint8
        var u2 uint32

        var f1 float32
        var f2 float64
        var c1 complex64
        var c2 complex128

        var s string

        fmt.Println(i1)
        fmt.Println(i2)
        fmt.Println(u1)
        fmt.Println(u2)

        fmt.Println(f1)
        fmt.Println(f2)
        fmt.Println(c1)
        fmt.Println(c2)

        fmt.Println(s)
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Konstanty</h2>

<p>V&nbsp;reálných zdrojových kódech se kromě proměnných používají taktéž konstanty.</p>

<pre>
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Ukazatele a jejich význam v&nbsp;jazyku Go</h2>

<pre>
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Struktury (záznamy)</h2>

<pre>
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Základní operace se strukturami</h2>

<pre>
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Pole</h2>

<p>Na tomto místě je vhodné upozornit na to, že pole jsou v&nbsp;programovacím jazyku Go plnohodnotnými datovými typy s&nbsp;vlastní sémantikou a dokonce i vlastními metadaty (na rozdíl od jazyka C, v&nbsp;němž je práce se skutečnými poli v&nbsp;mnoha případech omezena typovým systémem).</p>

<pre>
</pre>

Pole ve skutečnosti nejsou příliš flexibilním datovým typem



<p><a name="k14"></a></p>
<h2 id="k14">14. Základní operace s&nbsp;poli</h2>

<pre>
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Řezy (slices), jejich význam a rozdílné vlastnosti oproti polím</h2>

<p>Jak jsme si již řekli v&nbsp;předchozích kapitolách, nemusí být klasické pole dostatečně flexibilní datovou strukturou, která by plně vyhovovala potřebám vytvářené aplikace popř.&nbsp;implementovaného algoritmu. Pro dosažení větší flexibility byl do programovacího jazyka Go přidán další datový typ nazývaný <i>řez</i> neboli <i>slice</i>. Interně se jedná o referenci na automaticky vytvořené pole nebo na pole, které je explicitně &bdquo;nasalámováno&ldquo; operací, s&nbsp;níž se seznámíme v&nbsp;navazující kapitole. Každý řez je v&nbsp;operační paměti uložen ve formě trojice hodnot:</p>

<ol>
<li>Ukazatele (reference) na pole s&nbsp;daty, ke kterým přes řez přistupujeme.</li>
<li>Délky řezu, tj.&nbsp;počtu prvků.</li>
<li>Kapacity řezu (do jaké míry může řez narůstat v&nbsp;důsledku přidávání dalších prvků).</li>
</ol>

<p>Tato interní struktura řezů s&nbsp;sebou přináší několik zajímavých důsledků. Je totiž možné, aby existovalo větší množství řezů ukazujících na obecně různé prvky jediného pole. Pokud nyní změníme prvek v&nbsp;jednom řezu, znamená to, že se vlastně modifikuje obsah původního pole a i ostatní řezy nový prvek uvidí.</p>


nejjednodušší konstrukce
var slice_to_int []int
var s = []int{3, 5, 7, 9, 11, 13, 17}

<pre>
</pre>
Řezy (slice) vektoru
https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05

Vytvoření „řezu“ z pole
https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06



<p><a name="k16"></a></p>
<h2 id="k16">16. Základní operace s&nbsp;řezy</h2>

<p>Datový typ řez (<i>slice</i>), s&nbsp;nímž jsme se setkali v&nbsp;předchozí kapitole, získal svůj název kvůli následující operaci provedené s&nbsp;polem:</p>

<pre>
a[low:high]
</pre>

<p>Výsledkem předchozího <i>výrazu</i> je nový (obecně zúžený) pohled na pole, který se nazývá řez.</p>

a := [6]string{"C", "C++", "Java", "Python", "Go", "Rust"}

slice1 := a[1:4]
slice2 := a[:3]
slice3 := a[2:]
slice4 := a[:]

fmt.Println("Array a = ", a)
fmt.Println("slice1 = ", slice1)
fmt.Println("slice2 = ", slice2)
fmt.Println("slice3 = ", slice3)
fmt.Println("slice4 = ", slice4)


<pre>
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Pokročilejší operace s&nbsp;řezy</h2>


<pre>
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Speciální hodnota <strong>nil</strong> a její specifický význam v&nbsp;jazyku Go</h2>


<pre>
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
doslova několik kilobajtů), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td> 2</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td> 3</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td> 4</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td> 5</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td> 6</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td> 7</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td> 8</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td> 9</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td>10</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td>11</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td>12</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td>13</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td>14</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td>15</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td>16</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td>17</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td>18</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td>19</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td>20</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td>21</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td>22</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td>23</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
<tr><td>24</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/">https://github.com/tisnik/go-root/blob/master/article_02/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go <br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

<!--
2018-11-0x: 0 hod
2018-11-0x: 0 hod
2018-11-0x: 0 hod
2018-11-0x: 0 hod
2018-11-0x: 0 hod
2018-11-0x: 0 hod
publikace:  0 hod
-----------------
            0 hod
-->
