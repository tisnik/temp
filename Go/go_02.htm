<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Datové typy v programovacím jazyku Go</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Datové typy v programovacím jazyku Go</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části seriálu o programovacím jazyku Go se seznámíme s typovým systémem tohoto jazyka. Kromě jednoduchých datových typů si samozřejmě popíšeme i složené datové typy, především pole, řetězce, řezy a struktury (záznamy).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Datové typy v&nbsp;programovacím jazyku Go</a></p>
<p><a href="#k02">2. Celočíselné datové typy</a></p>
<p><a href="#k03">3. Konverze mezi hodnotami různých typů</a></p>
<p><a href="#k04">4. Tisk a formátování celočíselných hodnot</a></p>
<p><a href="#k05">5. Podmnožiny reálných čísel a komplexní čísla</a></p>
<p><a href="#k06">6. Pravdivostní hodnoty</a></p>
<p><a href="#k07">7. Řetězce</a></p>
<p><a href="#k08">8. Deklarace lokálních proměnných</a></p>
<p><a href="#k09">9. Implicitní hodnoty proměnných</a></p>
<p><a href="#k10">10. Pole</a></p>
<p><a href="#k11">11. Kopie polí</a></p>
<p><a href="#k12">12. Řezy (slices), jejich význam a rozdílné vlastnosti oproti polím</a></p>
<p><a href="#k13">13. Základní operace s&nbsp;řezy</a></p>
<p><a href="#k14">14. Pokročilejší operace s&nbsp;řezy</a></p>
<p><a href="#k15">15. Vytvoření řezu z&nbsp;jiného řezu</a></p>
<p><a href="#k16">16. Datové typy popsané příště</a></p>
<p><a href="#k17">17. Speciální hodnota <strong>nil</strong> a její specifický význam v&nbsp;jazyku Go</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Datové typy v&nbsp;programovacím jazyku Go</h2>

<p>V&nbsp;dnešním článku se seznámíme s&nbsp;typovým systémem programovacího
jazyka Go. Připomeňme si, že Go používá statický typový systém, což konkrétně
znamená, že typ proměnné, parametru funkce, návratové hodnoty funkce atd. musí
být známý již v&nbsp;době překladu (<i>compile time</i>) a není ho tedy nutné
vyhodnocovat a kontrolovat v&nbsp;čase běhu programu (<i>runtime</i>). Datové
typy, které programovací jazyk Go vývojářům nabízí, je možné rozdělit podle
několika kritérií. Základní dělení je na jednoduché či primitivní datové typy
(typicky se hodnoty těchto typů dají uložit do jediného registru
mikroprocesoru), složené datové typy a některé zvláštní typy (zde se konkrétně
jedná o ukazatel, funkci, rozhraní a taktéž kanál). Jednoduché datové typy se
někdy dále dělí na <i>ordinální</i> a <i>neordinální</i>. Celá hierarchie
typového systému jazyka Go je zobrazena pod tímto odstavcem:</p>

<ul>
    <li>Jednoduché datové typy
        <ul>
            <li>Ordinální
                <ul>
                    <li><a href="#k06">Pravdivostní typ</a> (<i>boolean</i>)</li>
                    <li><a href="#k02">Celočíselné typy</a> (<i>integer</i>)</li>
                </ul>
                </li>
                <li>Neordinální
                <ul>
                    <li><a href="#k05">Hodnoty s&nbsp;plovoucí řádovou čárkou</a> (<i>float</i>)</li>
                    <li><a href="#k05">Komplexní čísla</a> (<i>complex</i>)</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>Složené datové typy
        <ul>
            <li><a href="#k07">Řetězce</a> (<i>string</i>)</li>
            <li><a href="#k10">Pole</a> (<i>array</i>)</li>
            <li><a href="#k12">Řezy</a> (<i>slice</i>)</li>
            <li>Záznamy (<i>struct</i>)</li>
            <li>Mapy (<i>map</i>)</li>
        </ul>
    </li>
    <li>Zvláštní datové typy
        <ul>
            <li>Ukazatel (<i>pointer</i>)</li>
            <li>Funkce (<i>function</i>)</li>
            <li>Rozhraní (<i>interface</i>)</li>
            <li>Kanál (<i>channel</i>)</li>
        </ul>
    </li>
</ul>

<p><div class="rs-tip-major">Poznámka: v&nbsp;Go je samozřejmě podporována
deklarace vlastních datových typů, což je velmi důležité téma, kterému se
budeme věnovat příště.</div></p>

<p><div class="rs-tip-major">Pro doplnění se můžete podívat, jak vypadá <a
href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">základ
typového systému Rustu </a>.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Celočíselné datové typy</h2>

<p>Programovací jazyk Go je navržen takovým způsobem, aby ho bylo možné
efektivně provozovat na mainstreamových mikroprocesorových architekturách, což
konkrétně znamená především architektury x86 (32bit), x86-64 (64bit), ARM32
(velká rodina několika 32bitových architektur) a neoficiálně taktéž AArch64
(64bit). Z&nbsp;tohoto důvodu v&nbsp;Go nalezneme takové celočíselné datové
typy, které jsou na zmíněných architekturách nativně zpracovávány. To je
poměrně značně odlišná strategie, než kterou se kdysi vydal programovací jazyk
C, v&nbsp;němž se formát a šířka celočíselných datových typů odvozuje od
použité architektury (například různé mikrořadiče či <a
href="https://www.root.cz/clanky/digitalni-signalove-procesory-rady-tms320/">DSP</a>
používají mnohdy zcela odlišné formáty, ostatně podobně, jako tomu bylo na
minipočítačích PDP atd.).</p>

<p>V&nbsp;následující tabulce jsou vypsány všechny celočíselné datové typy
poskytované jazykem Go 1.x. Každý celočíselný datový typ je jednoznačně určen
jediným klíčovým slovem; nenajdeme zde tedy modifikátory
<strong>signed</strong>, <strong>unsigned</strong>, <strong>short</strong>,
<strong>long</strong> atd.:</p>

<table>
<tr><th>Označení</th><th>Rozsah hodnot</th><th>Stručný popis</th></tr>
<tr><td>int8 </td><td>-128 až 127</td><td>osmibitové celé číslo se znaménkem</td></tr>
<tr><td>int16</td><td>-32768 až 32767</td><td>16bitové celé číslo se znaménkem</td></tr>
<tr><td>int32</td><td>-2147483648 až 2147483647</td><td>32bitové celé číslo se znaménkem</td></tr>
<tr><td>int64</td><td>-9223372036854775808 až 9223372036854775807</td><td>64bitové celé číslo se znaménkem</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>uint8 </td><td>0 až 255</td><td>osmibitové celé číslo bez znaménka</td></tr>
<tr><td>uint16</td><td>0 až 65535</td><td>16bitové celé číslo bez znaménka</td></tr>
<tr><td>uint32</td><td>0 až 4294967295</td><td>32bitové celé číslo bez znaménka</td></tr>
<tr><td>uint64</td><td>0 až 18446744073709551615</td><td>64bitové celé číslo bez znaménka</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>int </td><td>různý</td><td>odpovídá buď typu int32 nebo int64</td></tr>
<tr><td>uint</td><td>různý</td><td>odpovídá buď typu uint32 nebo uint64</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>byte</td><td>0 až 255</td><td>alias pro typ uint8</td></tr>
<tr><td>rune</td><td>-2147483648 až 2147483647</td><td>alias pro typ int32</td></tr>
<tr><td>uintptr</td><td>různý</td><td>používáno pro uložení adresy (ukazatele)</td></tr>
</table>

<p><div class="rs-tip-major">Povšimněte si, že v&nbsp;předchozí tabulce byl u
většiny celočíselných datových typů přesně uveden rozsah hodnot. Je tomu tak
z&nbsp;toho důvodu, že specifikace jazyka Go určuje přesnou bitovou šířku typů
a taktéž to, že celočíselné hodnoty se znaménkem mají být reprezentovány ve
dvojkovém doplňku. To je poměrně velký rozdíl oproti již zmíněnému
programovacímu jazyku C, v&nbsp;jehož specifikaci se u základního typu
<i>int</i> a jeho variant (<i>short</i>, <i>long</i>, <i>long long</i>)
naschvál všechny tyto informace neuvádí, protože céčko je provozováno i na
mnohdy obskurních architekturách (například se může použít jedničkový doplněk
atd.).</div></p>

<p>Dále stojí za povšimnutí existence takzvaných <i>aliasů</i>, které se
používají ve třech  významech. První aliasy <i>int</i> a <i>unint</i>
odpovídají buď 32bitové nebo 64bitové šířce celočíselného datového typu
v&nbsp;závislosti na architektuře (zde se alespoň do jisté míry přibližujeme
k&nbsp;céčku); ovšem zajímavější jsou aliasy <i>byte</i> (vždy osmibitová
hodnota bez znaménka) a <i>rune</i> (reprezentace znaku v&nbsp;Unicode).
Poslední alias <i>uintptr </i> reprezentuje datový typ určený pro uložení
ukazatele (pointeru) a je tedy opět závislý na konkrétní architektuře.</p>

<p>Ukažme si nyní <a
href="https://github.com/tisnik/go-root/blob/master/article_02/01_integer_signed_types.go">příklad
definice proměnných</a> s&nbsp;uvedením typu a současně i s&nbsp;jejich
inicializací:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        <strong>var a int8 = -10</strong>
        <strong>var b int16 = -1000</strong>
        <strong>var c int32 = -10000</strong>
        <strong>var d int32 = -1000000</strong>
&nbsp;
        <strong>var r1 rune = 'a'</strong>
        <strong>var r2 rune = '\x40'</strong>
        <strong>var r3 rune = '\n'</strong>
        <strong>var r4 rune = '\u03BB'</strong>
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
        fmt.Println(c)
        fmt.Println(d)
&nbsp;
        fmt.Println(r1)
        fmt.Println(r2)
        fmt.Println(r3)
        fmt.Println(r4)
}
</pre>

<p>Výsledek po překladu a spuštění:</p>

<pre>
-10
-1000
-10000
-1000000
97
64
10
955
</pre>

<p>Překladač jazyka Go striktně hlídá, zda se přiřazovaná hodnota skutečně
vejde do proměnné daného typu:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a int8 = <strong>-1000</strong>
        var b int16 = <strong>-100000</strong>
        var c int32 = <strong>-10000000000</strong>
        var d int32 = <strong>-10000000000000000</strong>
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
        fmt.Println(c)
        fmt.Println(d)
}
</pre>

<p>Při pokusu o překlad <a
href="https://github.com/tisnik/go-root/blob/master/article_02/02_integer_signed_types_checks.go">předchozího
příkladu</a> získáme pouze čtveřici chybových hlášení:</p>

<pre>
./02_integer_signed_types_checks.go:13:15: constant -1000 overflows int8
./02_integer_signed_types_checks.go:14:16: constant -100000 overflows int16
./02_integer_signed_types_checks.go:15:16: constant -10000000000 overflows int32
./02_integer_signed_types_checks.go:16:16: constant -10000000000000000 overflows int32
</pre>

<p>Ve <a
href="https://github.com/tisnik/go-root/blob/master/article_02/03_integer_unsigned_types.go">třetím
příkladu</a> vytvoříme čtyři lokální proměnné nesoucí informace o hodnotách bez
znaménka:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        <strong>var a uint8 = 10</strong>
        <strong>var b uint16 = 1000</strong>
        <strong>var c uint32 = 10000</strong>
        <strong>var d uint32 = 1000000</strong>
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
        fmt.Println(c)
        fmt.Println(d)
}
</pre>

<p>Výsledek po překladu a spuštění:</p>

<pre>
10
1000
10000
1000000
</pre>

<p>Celočíselné konstanty je možné zapisovat v&nbsp;desítkové soustavě,
v&nbsp;soustavě osmičkové (prefixem je zde nula) nebo v&nbsp;soustavě
šestnáctkové (prefixem je 0x). Způsob použití různých číselných soustav je
ukázán ve <a
href="https://github.com/tisnik/go-root/blob/master/article_02/04_integer_constants.go">čtvrtém
demonstračním příkladu</a>:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a uint8 = <strong>10</strong>
        var b uint8 = <strong>010</strong>
        var c uint8 = <strong>0x10</strong>
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
        fmt.Println(c)
&nbsp;
        var d int8 = <strong>-10</strong>
        var e int8 = <strong>-010</strong>
        var f int8 = <strong>-0x10</strong>
&nbsp;
        fmt.Println(d)
        fmt.Println(e)
        fmt.Println(f)
}
</pre>

<p>Výsledek po překladu a spuštění:</p>

<pre>
10
8
16
-10
-8
-16
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Konverze mezi hodnotami různých typů</h2>

<p>V&nbsp;mnoha programovacích jazycích nalezneme různá více či méně složitá
pravidla, která se týkají konverzí mezi hodnotami odlišných datových typů.
V&nbsp;jazyce Go se podobná pravidla používají taktéž a nutno říci, že jsou
poměrně silná. Tato pravidla například neumožní ani implicitní převody mezi
typy <strong>uint8</strong> a <strong>uint16</strong>, což si můžeme ukázat na
<a
href="https://github.com/tisnik/go-root/blob/master/article_02/05_improper_conversion.go">pátém
demonstračním příkladu</a>:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a uint8 = 255
        var b <strong>uint16 = a</strong>
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
}
</pre>

<p>Teoreticky by měla být konverze mezi osmibitovým číslem bez znaménka na
16bitové číslo (taktéž bez znaménka) bezproblémová. Přesto překladač jazyka Go
tuto implicitní konverzi nepovolí, protože se řídí filozofií, že <a
href="https://golang.org/doc/faq#conversions">explicitní přetypování je
z&nbsp;dlouhodobého hlediska výhodnější, než sada implicitních
pravidel</a>:</p>

<pre>
./05_improper_conversion.go:14:6: cannot use a (type uint8) as type uint16 in assignment
</pre>

<p>Podobně je tomu <a
href="https://github.com/tisnik/go-root/blob/master/article_02/06_improper_conversion.go">i
při opačné konverzí</a>, kde samozřejmě dochází ke ztrátě informace:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a uint16 = 255
        var b uint8 = a
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
}
</pre>

<p>Výsledek pokusu o překlad:</p>

<pre>
./06_improper_conversion.go:14:6: cannot use a (type uint16) as type uint8 in assignment
</pre>

<p>Taktéž implicitní převody mezi celočíselnými typy se stejnou bitovou šířkou,
ovšem s&nbsp;odlišným rozsahem (se znaménkem, bez znaménka), nejsou povoleny,
což si vyzkoušíme <a
href="https://github.com/tisnik/go-root/blob/master/article_02/07_improper_conversion_int_uint.go">v&nbsp;sedmém
demonstračním příkladu</a>:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a <strong>int8 = 100</strong>
        var b <strong>uint8 = a</strong>
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
&nbsp;
        var c <strong>uint8 = 100</strong>
        var d <strong>int8 = c</strong>
&nbsp;
        fmt.Println(c)
        fmt.Println(d)
}
</pre>

<p>Výsledek pokusu o překlad tohoto příkladu:</p>

<pre>
./07_improper_conversion_int_uint.go:14:6: cannot use a (type int8) as type uint8 in assignment
./07_improper_conversion_int_uint.go:20:6: cannot use c (type uint8) as type int8 in assignment
</pre>

<p>Naprostou většinu konverzí je nutné ve zdrojových kódech zapisovat
explicitně tak, jak je to ukázáno <a
href="https://github.com/tisnik/go-root/blob/master/article_02/08_explicit_conversions.go">v&nbsp;dalším
demonstračním příkladu</a>.  Povšimněte si, že se zde nepoužívá klasické
přetypování, ale zápis konverze vypadá jako volání běžné funkce:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a int8 = -10
        var signed_int int32 = -100000
        var unsigned_int uint32 = 100000
        var e float32 = 1e4
        var f float64 = 1.5e30
&nbsp;
        var x int32 = <strong>int32(a)</strong>
        var y int32 = <strong>int32(e)</strong>
        var z float32 = <strong>float32(f)</strong>
&nbsp;
        fmt.Println(x)
        fmt.Println(y)
        fmt.Println(z)
&nbsp;
        var b2 uint8 = <strong>uint8(signed_int)</strong>
        var b3 uint8 = <strong>uint8(unsigned_int)</strong>
&nbsp;
        fmt.Println(b2)
        fmt.Println(b3)
}
</pre>

<p>Tento příklad již půjde bez problémů přeložit i spustit:</p>

<pre>
-10
10000
1.5e+30
96
160
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Tisk a formátování celočíselných hodnot</h2>

<p>Pro tisk a popř.&nbsp;i základní naformátování celočíselných hodnot na
standardním či na chybovém výstupu slouží funkce <strong>fmt.Println</strong>.
Tato funkce jako první parametr akceptuje takzvaný <i>formátovací řetězec</i>,
jehož obsah je do jisté míry podobný, jako je tomu v&nbsp;céčkovské standardní
funkci <a
href="https://www.cprogramming.com/tutorial/printf-format-strings.html">printf</a>,
popř.&nbsp;javovské metodě <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">String.format</a>.
Pro celočíselné datové typy se používá především použití dekadické soustavy
(%d), šestnáctkové soustavy (%x), určení šířky/počtu cifer (%5d), specifikace
doplnění nul zleva (%05d), změna zarovnání (%-5d) a vynucení tisku znaménka
(%+5d). Podívejme se na následující příklad s&nbsp;několika možnostmi
formátování:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a uint8 = 20
        var b uint16 = 2000
        var c uint32 = 20000
        var d uint32 = 2000000
&nbsp;
        fmt.Println("%d")
        fmt.Printf("%d\n", a)
        fmt.Printf("%d\n", b)
        fmt.Printf("%d\n", c)
        fmt.Printf("%d\n", d)
&nbsp;
        fmt.Println("\n%5d")
        fmt.Printf("%5d\n", a)
        fmt.Printf("%5d\n", b)
        fmt.Printf("%5d\n", c)
        fmt.Printf("%5d\n", d)
&nbsp;
        fmt.Println("\n%05d")
        fmt.Printf("%05d\n", a)
        fmt.Printf("%05d\n", b)
        fmt.Printf("%05d\n", c)
        fmt.Printf("%05d\n", d)
&nbsp;
        fmt.Println("\n%-5d")
        fmt.Printf("%-5d\n", a)
        fmt.Printf("%-5d\n", b)
        fmt.Printf("%-5d\n", c)
        fmt.Printf("%-5d\n", d)
&nbsp;
        fmt.Println("\n%+5d")
        fmt.Printf("%+5d\n", a)
        fmt.Printf("%+5d\n", b)
        fmt.Printf("%+5d\n", c)
        fmt.Printf("%+5d\n", d)
&nbsp;
        fmt.Println("\n%x")
        fmt.Printf("%x\n", a)
        fmt.Printf("%x\n", b)
        fmt.Printf("%x\n", c)
        fmt.Printf("%x\n", d)
&nbsp;
        fmt.Println("\n%X")
        fmt.Printf("%X\n", a)
        fmt.Printf("%X\n", b)
        fmt.Printf("%X\n", c)
        fmt.Printf("%X\n", d)
&nbsp;
        fmt.Println("\n%b")
        fmt.Printf("%b\n", a)
        fmt.Printf("%b\n", b)
        fmt.Printf("%b\n", c)
        fmt.Printf("%b\n", d)
}
</pre>

<p>Výsledky ukazují vliv, jaký má formátovací řetězec na výsledný tvar čísla na
standardním výstupu:</p>

<pre>
%d
20
2000
20000
2000000
&nbsp;
%5d
   20
 2000
20000
2000000
&nbsp;
%05d
00020
02000
20000
2000000
&nbsp;
%-5d
20   
2000 
20000
2000000
&nbsp;
%+5d
  +20
+2000
+20000
+2000000
&nbsp;
%x
14
7d0
4e20
1e8480
&nbsp;
%X
14
7D0
4E20
1E8480
&nbsp;
%b
10100
11111010000
100111000100000
111101000010010000000
</pre>

<p>U záporných čísel se vždy bude vypisovat znaménko, nehledě na použití %+..
ve formátovacím řetězci:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a int8 = -10
        var b int16 = -1000
        var c int32 = -10000
        var d int32 = -1000000
&nbsp;
        var r1 rune = 'a'
        var r2 rune = '\x40'
        var r3 rune = '\n'
        var r4 rune = '\u03BB'
&nbsp;
        fmt.Println("%d")
        fmt.Printf("%d\n", a)
        fmt.Printf("%d\n", b)
        fmt.Printf("%d\n", c)
        fmt.Printf("%d\n", d)
&nbsp;
        fmt.Println("\n%5d")
        fmt.Printf("%5d\n", a)
        fmt.Printf("%5d\n", b)
        fmt.Printf("%5d\n", c)
        fmt.Printf("%5d\n", d)
&nbsp;
        fmt.Println("\n%05d")
        fmt.Printf("%05d\n", a)
        fmt.Printf("%05d\n", b)
        fmt.Printf("%05d\n", c)
        fmt.Printf("%05d\n", d)
&nbsp;
        fmt.Println("\n%-5d")
        fmt.Printf("%-5d\n", a)
        fmt.Printf("%-5d\n", b)
        fmt.Printf("%-5d\n", c)
        fmt.Printf("%-5d\n", d)
&nbsp;
        fmt.Println("\n%+5d")
        fmt.Printf("%+5d\n", a)
        fmt.Printf("%+5d\n", b)
        fmt.Printf("%+5d\n", c)
        fmt.Printf("%+5d\n", d)
&nbsp;
        fmt.Println("\n%x")
        fmt.Printf("%x\n", a)
        fmt.Printf("%x\n", b)
        fmt.Printf("%x\n", c)
        fmt.Printf("%x\n", d)
&nbsp;
        fmt.Println("\n%X")
        fmt.Printf("%X\n", a)
        fmt.Printf("%X\n", b)
        fmt.Printf("%X\n", c)
        fmt.Printf("%X\n", d)
&nbsp;
        fmt.Println("\n%b")
        fmt.Printf("%b\n", a)
        fmt.Printf("%b\n", b)
        fmt.Printf("%b\n", c)
        fmt.Printf("%b\n", d)
&nbsp;
        fmt.Println("%c")
        fmt.Printf("%c\n", r1)
        fmt.Printf("%c\n", r2)
        fmt.Printf("%c\n", r3)
        fmt.Printf("%c\n", r4)
}
</pre>

<p>Výsledky:</p>

<pre>
%d
-10
-1000
-10000
-1000000
&nbsp;
%5d
  -10
-1000
-10000
-1000000
&nbsp;
%05d
-0010
-1000
-10000
-1000000
&nbsp;
%-5d
-10  
-1000
-10000
-1000000
&nbsp;
%+5d
  -10
-1000
-10000
-1000000
&nbsp;
%x
-a
-3e8
-2710
-f4240
&nbsp;
%X
-A
-3E8
-2710
-F4240
&nbsp;
%b
-1010
-1111101000
-10011100010000
-11110100001001000000
%c
a
@


λ
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si především způsobu výpisu
znaků při použití %c.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Podmnožiny reálných čísel a komplexní čísla</h2>

<p>V&nbsp;programovacím jazyku Go samozřejmě nalezneme i datové typy určené pro
uložení podmnožiny reálných čísel. Podobně, jako je tomu v&nbsp;prakticky všech
moderních programovacích jazycích, jsou tyto datové typy odvozeny od formátů
numerických hodnot specifikovaných <a
href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni#k02">v&nbsp;normě
IEEE 754</a> (ať již v&nbsp;její základní variantě, či novější verzi).
K&nbsp;dispozici jsou tedy dva základní typy: čísla s&nbsp;jednoduchou
přesností (<i>single</i>) a čísla s&nbsp;přesností dvojitou
(<i>double</i>).</p>

<p>V&nbsp;mnoha programovacích jazycích se jména těchto typů odvozují skutečně
od zmíněné normy IEEE 754, ovšem v&nbsp;Go (a podobně i v&nbsp;Rustu, i když
Rust používá ještě kratší jména) jsou zvolena odlišná označení, konkrétně
<strong>float32</strong> a <strong>float64</strong>. Kromě toho najdeme
v&nbsp;jazyku Go i typy pojmenované <strong>complex64</strong> a
<strong>complex128</strong> pro reprezentaci komplexních čísel. Interně se
jedná o dvojici <strong>float32+float32</strong> nebo
<strong>float64+float64</strong>:</p>

<table>
<tr><th>Označení</th><th>Rozsah hodnot</th><th>Stručný popis</th></tr>
<tr><td>float32</td><td>-3,4&times;10<sup>38</sup> až 3,4&times;10<sup>38</sup></td><td>číslo s&nbsp;jednoduchou přesností podle IEEE 754</td></tr>
<tr><td>float64</td><td>-1,7&times;10<sup>308</sup> až 1,7&times;10<sup>308</sup></td><td>číslo s&nbsp;dvojitou přesností podle IEEE 754</td></tr>
<tr><td>complex64</td><td>&pm; rozsah float32 + i &pm; rozsah float32</td><td>dvojice hodnot s&nbsp;jednoduchou přesností</td></tr>
<tr><td>complex128</td><td>&pm; rozsah float64 + i &pm; rozsah float64</td><td>dvojice hodnot s&nbsp;dvojitou přesností</td></tr>
</table>

<p>Nejdříve se podívejme na různé způsoby deklarací proměnných typu
<strong>float32</strong> a <strong>float64</strong>:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a float32 = -1.5
        var b float32 = 1.5
        var c float32 = 1e30
        var d float32 = 1e-30
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
        fmt.Println(c)
        fmt.Println(d)
&nbsp;
        var e float64 = -1.5
        var f float64 = 1.5
        var g float64 = 1e300
        var h float64 = 1e-300
&nbsp;
        fmt.Println(e)
        fmt.Println(f)
        fmt.Println(g)
        fmt.Println(h)
}
</pre>

<p>Překladač jazyka Go opět kontroluje, zda se nesnažíme používat příliš velké
konstanty, které neodpovídají povolenému rozsahu:</p>

<pre>
package main
&nbsp;
func main() {
        var c float32 = 1e300
        var d float32 = -1e300
&nbsp;
        var g float64 = 1e3000
        var h float64 = -1e3000
}
</pre>

<p>Výsledky kontroly překladačem:</p>

<pre>
./12_fp_types_checks.go:11:18: constant 1e+300 overflows float32
./12_fp_types_checks.go:12:18: constant -1e+300 overflows float32
./12_fp_types_checks.go:14:18: constant 1e+3000 overflows float64
./12_fp_types_checks.go:15:18: constant -1e+3000 overflows float64
</pre>

<p>Vyzkoušejme se nyní, jakým způsobem se zapisují hodnoty typu
<strong>complex64</strong> nebo <strong>complex128</strong>. V&nbsp;jazyce Go
se používá zápis, který pravděpodobně znáte z&nbsp;matematiky: za druhé číslo
se připojuje označení imaginární jednotky. Ta je v&nbsp;Go zapisována znakem
<strong>i</strong> (matematický způsob) a nikoli <strong>j</strong> (používáno
v&nbsp;elektro oborech, taktéž v&nbsp;Pythonu). Nutno říci, že zápis
s&nbsp;&bdquo;i&ldquo; je z&nbsp;typografického hlediska hezčí :-).
V&nbsp;dalším programu si povšimněte, že můžeme zapsat pouze imaginární část
čísla, ovšem před &bdquo;i&ldquo; musí být vždy alespoň jedna číslice (jinak by
došlo k&nbsp;chybě popř.&nbsp;k&nbsp;přiřazení hodnoty proměnné
<strong>i</strong>, pokud náhodou existuje):</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a complex64 = -1.5 + 0i
        var b complex64 = 1.5 + 1000i
        var c complex64 = 1e30 + 1e30i
        var d complex64 = 1i
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
        fmt.Println(c)
        fmt.Println(d)
&nbsp;
        var e complex128 = -1.5 + 0i
        var f complex128 = 1.5 + 1000i
        var g complex128 = 1e300 + 1e300i
&nbsp;
        fmt.Println(e)
        fmt.Println(f)
        fmt.Println(g)
}
</pre>

<p>Zajímavý je způsob zobrazení hodnot komplexních čísel &ndash; celá hodnota
je umístěna do závorek:</p>

<pre>
(-1.5+0i)
(1.5+1000i)
(1e+30+1e+30i)
(0+1i)
(-1.5+0i)
(1.5+1000i)
(1e+300+1e+300i)
</pre>

<p><div class="rs-tip-major">Poznámka: pozor na poněkud matoucí výstup
<strong>(1e+300+1e+300i)</strong>, protože prostřední znak + spojuje reálnou a
imaginární složku, zatímco ostatní dva znaky + se vztahují
k&nbsp;exponentu.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Pravdivostní hodnoty</h2>

<p>V&nbsp;programovacím jazyku Go je samozřejmě možné pracovat i
s&nbsp;pravdivostními hodnotami, které jsou reprezentovány pravdivostním typem
(<i>bool</i>, <i>boolean</i>). Tento datový typ používá pouze dvě hodnoty,
které jsou pojmenovány klasicky <strong>true</strong> a <strong>false</strong>
(pro Pythonisty: s&nbsp;malými písmeny na začátku). <a
href="https://github.com/tisnik/go-root/blob/master/article_02/14_boolean_type.go">Příklad
základního použití</a> tohoto datového typu je velmi jednoduchý:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a bool = true
        var b bool = false
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
}
</pre>

<p>Na tomto místě je vhodné upozornit na fakt, že v&nbsp;programovacím jazyce
Go <i>není možné</i> provést automatický a implicitní převod mezi celočíselným
typem a pravdivostní hodnotou. Podobně nelze provést převod mezi řetězcem
(polem atd.) a pravdivostní hodnotou, na rozdíl od některých jiných
programovacích jazyků (příkladem může být Python s&nbsp;několika hodnotami,
které se vyhodnotí jako <strong>false</strong>, kdežto všechny ostatní hodnoty
mohou být v&nbsp;logických výrazech považovány za <strong>true</strong>).
Vyzkoušejme si tuto vlastnost jazyka Go na <a
href="https://github.com/tisnik/go-root/blob/master/article_02/15_boolean_type_checks.go">dalším
demonstračním příkladu</a>:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a bool = true
        var b bool = false
        var c bool = 0
        var d bool = ""
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
        fmt.Println(c)
        fmt.Println(d)
}
</pre>

<p>Při pokusu o překlad tohoto zdrojového kódu se zobrazí chybová hlášení o
nemožnosti provedení konverze:</p>

<pre>
./15_boolean_type_checks.go:15:6: cannot use 0 (type int) as type bool in assignment
./15_boolean_type_checks.go:16:15: cannot use "" (type string) as type bool in assignment
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Řetězce</h2>

<p>Naprostá většina moderních programovacích jazyků podporuje práci
s&nbsp;řetězci, přesněji řečeno řetězce jsou plnohodnotným datovým typem
(výjimkou je vlastně jen klasické céčko, které rozpoznává jen řetězcové
literály). Nejinak je tomu i v&nbsp;programovacím jazyce Go, v&nbsp;němž
nalezneme datový typ <strong>string</strong>. Interně se s&nbsp;řetězcem
pracuje stejně, jako s&nbsp;řezem (<i>slice</i>) pole bajtů (s&nbsp;pojmem řez
se seznámíme v&nbsp;dalších kapitolách). A právě z&nbsp;tohoto způsobu práce
s&nbsp;řetězci vychází i jejich základní vlastnosti, které mohou některé
programátory překvapit a je dobré je znát:</p>

<ol>

<li>V&nbsp;první řadě jsou řetězce neměnitelné (<i>immutable</i>).</li>

<li>Dále je u řetězců známá jejich délka, ovšem udávaná v&nbsp;bajtech, nikoli
ve znacích.</li>

<li>Při přístupu k&nbsp;jednotlivým prvkům řetězce pomocí operátoru indexování
[] získáme jednotlivé bajty, nikoli znaky!</li>

<li>A za čtvrté: v&nbsp;řetězci je skutečně možné mít uloženy libovolné
kombinace bajtů. Teprve až ve chvíli, kdy budeme chtít pracovat
s&nbsp;jednotlivými znaky, budou se jednotlivé sekvence bajtů transformovat do
Unicode (k&nbsp;tomu je ovšem nutné použít buď jednu z&nbsp;forem smyčky
<strong>for</strong> nebo knihovní funkce).</p></li>

</ol>

<p>I když jsou řetězce interně reprezentovány jako sekvence bajtů, můžeme ve
zdrojovém kódu používat řetězcové literály obsahující znaky z&nbsp;Unicode.
Z&nbsp;předchozího článku již víme, že zdrojové kódy psané v&nbsp;Go jsou
uloženy v&nbsp;UTF-8, takže by to nemělo představovat žádný problém. Povšimněte
si, že samozřejmě můžeme použít prázdný řetězec a v&nbsp;řetězci mohou být
umístěny řídicí znaky zapisované stejně, jako v&nbsp;C/C++, Javě atd. atd:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var s1 string = "www.root.cz"
        var s2 string = ""
        var s3 string = "Hello\nworld!\n"
        var s4 string = "шщэюя"
&nbsp;
        fmt.Println(s1)
        fmt.Println(s2)
        fmt.Println(s3)
        fmt.Println(s4)
}
</pre>

<p>V&nbsp;některých situacích může být výhodné zapsat řetězec v&nbsp;přesně
takové podobě, jak má být uložen v&nbsp;paměti; tj.&nbsp;budeme potřebovat
zrušit význam řídicích znaků "\n" atd. I to je možné, protože programovací
jazyk Go podporuje takzvané &bdquo;raw&ldquo; (surové) řetězce, které se
nezapisují do uvozovek, ale do zpětných apostrofů (<i>backtick</i>). Díky
tomuto způsobu zápisu řetězce se vyhneme nutnosti zdvojování zpětného lomítka a
podobných triků:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var s1 string = "Hello\nworld!\n"
        var s2 string = `Hello\nworld!\n`
&nbsp;
        fmt.Println(s1)
        fmt.Println(s2)
}
</pre>

<p>Nakonec si ještě ukážeme &ndash; prozatím bez hlubší analýzy &ndash; jak
vlastně vypadá pole bajtů vytvořené z&nbsp;řetězcového literálu, který obsahuje
různé znaky z&nbsp;Unicode:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var s string = "Hello\nworld!\nžluťoučký kůň"
&nbsp;
        for i := 0; i &lt; len(s); i++ {
                fmt.Printf("%02x ", s[i])
        }
&nbsp;
}
</pre>

<p>Po spuštění tohoto příkladu by se na standardním výstupu měly objevit tyto
hodnoty:</p>

<pre>
48 65 6c 6c 6f 0a 77 6f 72 6c 64 21 0a c5 be 6c 75 c5 a5 6f 75 c4 8d 6b c3 bd 20 6b c5 af c5 88
</pre>

<p>Příště si ukážeme užitečnější příklad, v&nbsp;němž se budeme řetězci zabývat
podrobněji.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Deklarace lokálních proměnných</h2>

<p>S&nbsp;deklaracemi proměnných jsme se již setkali v&nbsp;první části tohoto
seriálu, takže si jen krátce zopakujme, že lokální proměnné je nutné deklarovat
a popř.&nbsp;je můžeme i inicializovat. Při zápisu můžeme použít zkrácený zápis
&ndash; vzhledem k&nbsp;tomu, že překladač pozná, jakého typu je <i>hodnota</i>
přiřazovaná do proměnné, může být explicitní specifikace jejího typu poněkud
nadbytečné. Pro zkrácený zápis deklarace proměnné s&nbsp;její inicializací je
v&nbsp;programovacím jazyku Go vytvořen operátor :=, který se používá
následujícím způsobem (opět ho známe z&nbsp;předchozího článku):</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        a := 10
        fmt.Println(a)
        b := "hello"
        fmt.Println(b)
        c := true
        fmt.Println(c)
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Implicitní hodnoty proměnných</h2>

<p>Dále je ve specifikaci jazyka Go přesně určeno, jaké hodnoty budou mít
neinicializované proměnné. U číselných hodnot je to nula (reprezentovaná různým
způsobem), u řetězců prázdný řetězec atd. Toto chování platí i pro lokální
proměnné:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var i1 int8
        var i2 int32
        var u1 uint8
        var u2 uint32
&nbsp;
        var f1 float32
        var f2 float64
        var c1 complex64
        var c2 complex128
&nbsp;
        var s string
&nbsp;
        fmt.Println(i1)
        fmt.Println(i2)
        fmt.Println(u1)
        fmt.Println(u2)
&nbsp;
        fmt.Println(f1)
        fmt.Println(f2)
        fmt.Println(c1)
        fmt.Println(c2)
&nbsp;
        fmt.Println(s)
}
</pre>

<p>Tento příklad půjde bez problémů přeložit a spustit s&nbsp;těmito výsledky
(včetně prázdného řádku na konci):</p>

<pre>
0
0
0
0
0
0
(0+0i)
(0+0i)
&nbsp;
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Pole</h2>

<p>V&nbsp;programovacím jazyce Go se, podobně jako v&nbsp;mnoha dalších
programovacích jazycích, setkáme s&nbsp;poli (<i>array</i>). Pole jsou
homogenní, což znamená, že prvky pole mají vždy stejný a již v&nbsp;čase
překladu známý typ. Pole mají současně (minimálně v&nbsp;Go) neměnnou délku,
kterou je nutné specifikovat při vytváření pole. Současně jsou pole
plnohodnotnými datovými typy s&nbsp;vlastní sémantikou a dokonce i vlastními
metadaty, na rozdíl od jazyka C, v&nbsp;němž je práce se skutečnými poli
v&nbsp;mnoha případech omezena typovým systémem.</p>

<p>Podívejme se nejdříve na způsob definice pole bez jeho přímé inicializace.
Prvky pole budou mít v&nbsp;takovém případě nulovou hodnotu:</p>

<pre>
var a1 [10]byte
</pre>

<p>Pole ovšem můžeme současně inicializovat:</p>

<pre>
a3 := [10]int32{1,10,2,9,3,8,4,7,5,6}
</pre>

<p>&bdquo;Čtení&ldquo; datového typu je zde provedeno přímočaře zleva doprava:
&bdquo;pole deseti prvků typu int32 s&nbsp;hodnotami 1,10 ...&ldquo;</p>

<p>Vytvořit můžeme i vícerozměrná pole:</p>

<pre>
var matice [10][10]float32
</pre>

<p>Pro zjištění délky pole použijeme funkci <strong>len</strong>,
tj.&nbsp;například:</p>

<pre>
x := len(a1)
</pre>

<p>A pro přístup k&nbsp;prvkům se používají klasické hranaté závorky, přičemž
první prvek má nulový index:</p>

<pre>
for i:= 0; i &lt; len(a1); i++ {
        a[i] = i*2;
}
</pre>

<p>Podívejme se nyní na úplný příklad, v&nbsp;němž se deklaruje a použije
několik polí:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a1 [10]byte
        var a2 [10]int32
        a3 := [10]int32{1,10,2,9,3,8,4,7,5,6}
&nbsp;
        fmt.Printf("Delka pole 1: %d\n", len(a1))
        fmt.Printf("Delka pole 2: %d\n", len(a2))
        fmt.Printf("Delka pole 3: %d\n", len(a3))
&nbsp;
&nbsp;
        var a[10]int
&nbsp;
        fmt.Printf("Pole pred upravou: %v\n", a)
&nbsp;
        for i:= 0; i &lt; len(a1); i++ {
                a[i] = i*2;
        }
&nbsp;
        fmt.Printf("Pole po uprave:    %v\n", a)
&nbsp;
        var matice [10][10]float32
        fmt.Printf("Matice:    %v\n", matice)
}
</pre>

<p><div class="rs-tip-major">Pole ve skutečnosti nejsou příliš flexibilním
datovým typem, mj.&nbsp;i z&nbsp;toho důvodu, že typová informace o poli
v&nbsp;sobě zahrnuje i délku pole (počet prvků). Tím pádem je složité vytvářet
například funkce akceptující jako svůj parametr pole (až na speciální případy
typu transformační matice atd.). Ovšem to v&nbsp;praxi příliš nevadí, protože
pole většinou slouží jako základ pro jiný typ &ndash; řez
(<i>slice</i>).</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Kopie polí</h2>

<p>Zajímavé bude zjistit, co se stane v&nbsp;případě, že v&nbsp;programu
vytvoříme novou proměnnou a přiřadíme jí pole:</p>

<pre>
a2 := a1
</pre>

<p>V&nbsp;tomto případě se sémantika odlišuje podle použitého jazyka:</p>

<ol>
<li>V&nbsp;Go se provede skutečná kopie pole, takže výsledkem budou dvě na sobě nezávislá pole.</li>
<li>V&nbsp;Javě (například) se jen přiřadí reference, takže dvě proměnné budou ukazovat na stejné pole.</li>
</ol>

<p>Chování Go si můžeme velmi snadno otestovat na následujícím příkladu,
v&nbsp;němž nejprve vytvoříme kopii pole a posléze původní pole změníme:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a1[10]int
&nbsp;
        <strong>a2 := a1</strong>
&nbsp;
        fmt.Printf("Pole 1: %v\n", a1)
        fmt.Printf("Pole 2: %v\n", a2)
&nbsp;
        for i:= 0; i &lt;len(a1); i++ {
                a1[i] = i*2;
        }
&nbsp;
        fmt.Printf("Pole 1: %v\n", a1)
        fmt.Printf("Pole 2: %v\n", a2)
}
</pre>

<p>Výsledek odpovídá předchozímu popisu &ndash; pole jsou odlišná:</p>

<pre>
Pole 1: [0 0 0 0 0 0 0 0 0 0]
Pole 2: [0 0 0 0 0 0 0 0 0 0]
Pole 1: [0 2 4 6 8 10 12 14 16 18]
Pole 2: [0 0 0 0 0 0 0 0 0 0]
</pre>

<p>Přibližně syntakticky (ne sémanticky!) ekvivalentní program v&nbsp;Javě by
mohl vypadat takto:</p>

<pre>
import java.util.Arrays;
&nbsp;
public class Test {
    public static void main(String[] args) {
        int[] a1 = new int[10];
        int[] a2 = a1;
&nbsp;
        for (int i=0; i&lt;a1.length; i++) {
            a1[i] = i*2;
        }
&nbsp;
        System.out.println(Arrays.toString(a1));
        System.out.println(Arrays.toString(a2));
    }
}
</pre>

<p>Po překladu a spuštění se ovšem vypíšou dva stejné řádky &ndash; to znamená,
že v&nbsp;programové smyčce jsme měnili prvky pole sdíleného mezi proměnnými
<strong>a1</strong> a <strong>a2</strong>:</p>

<pre>
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
</pre>

<p><div class="rs-tip-major">Poznámka: sice to nebylo primárním cílem
porovnání, ale povšimněte si, že Javovská varianta je více
&bdquo;ukecanější&ldquo;</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Řezy (slices), jejich význam a rozdílné vlastnosti oproti polím</h2>

<p>Jak jsme si již řekli v&nbsp;předchozích kapitolách, nemusí být klasické
pole dostatečně flexibilní datovou strukturou, která by plně vyhovovala
potřebám vytvářené aplikace popř.&nbsp;implementovaného algoritmu. Pro dosažení
větší flexibility byl do programovacího jazyka Go přidán další datový typ
nazývaný <i>řez</i> neboli <i>slice</i>. Interně se jedná o referenci na
automaticky vytvořené pole nebo na pole, které je explicitně
&bdquo;nasalámováno&ldquo; operací, s&nbsp;níž se seznámíme v&nbsp;navazující
kapitole. Každý řez je v&nbsp;operační paměti uložen ve formě trojice hodnot
(jde o záznam &ndash; struct či record):</p>

<ol>
<li>Ukazatele (reference) na zvolený prvek pole s&nbsp;daty, ke kterým přes řez přistupujeme.</li>
<li>Délky řezu, tj.&nbsp;počtu prvků.</li>
<li>Kapacity řezu (do jaké míry může řez narůstat v&nbsp;důsledku přidávání dalších prvků).</li>
</ol>

<p>Tato interní struktura řezů s&nbsp;sebou přináší několik zajímavých
důsledků. Je totiž možné, aby existovalo větší množství řezů ukazujících na
obecně různé prvky jediného pole. Pokud nyní změníme prvek v&nbsp;jednom řezu,
znamená to, že se vlastně modifikuje obsah původního pole a i ostatní řezy nový
prvek uvidí. Co je však užitečnější &ndash; s&nbsp;řezy jako s&nbsp;datovým
typem se velmi snadno pracuje; řezy mohou být předávány do funkcí, vráceny
z&nbsp;funkcí atd.</p>

<p><div class="rs-tip-major">Poznámka: s&nbsp;řezy, i když měly poněkud jiné
chování, jsme se seznámili například při popisu programovacího jazyka Rust. Viz
<a
href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">řezy
vektoru</a> a <a
href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">řezy
pole</a>.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Základní operace s&nbsp;řezy</h2>

<p>Datový typ řez (<i>slice</i>), s&nbsp;nímž jsme se setkali v&nbsp;předchozí
kapitole, získal svůj název kvůli následující operaci provedené
s&nbsp;polem:</p>

<pre>
a[index1:index2]
</pre>

<p>Výsledkem předchozího <i>výrazu</i> je nový (obecně zúžený) pohled na pole,
který se nazývá řez.</p>

<p>Jednoduchým příkladem může získání několika řezů z&nbsp;pole šesti
řetězců:</p>

<pre>
a := [6]string{"C", "C++", "Java", "Python", "Go", "Rust"}
</pre>

<p>Zkusme si vytvořit různé řezy a zobrazit si jejich výsledek:</p>

<pre>
slice1 := a[1:4]
slice2 := a[:3]
slice3 := a[2:]
slice4 := a[:]
&nbsp;
fmt.Println("Array a =", a)
fmt.Println("slice1 =", slice1)
fmt.Println("slice2 =", slice2)
fmt.Println("slice3 =", slice3)
fmt.Println("slice4 =", slice4)
</pre>

<p>Výstup bude vypadat následovně:</p>

<pre>
Array a = [C C++ Java Python Go Rust]
slice1 = [C++ Java Python]
slice2 = [C C++ Java]
slice3 = [Java Python Go Rust]
slice4 = [C C++ Java Python Go Rust]
</pre>

<p>U řezů máme k&nbsp;dispozici již zmíněnou délku a kapacitu:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a1 [100]byte
        var a2 [100]int32
&nbsp;
        fmt.Printf("Delka pole 1: %d\n", len(a1))
        fmt.Printf("Delka pole 2: %d\n", len(a2))
&nbsp;
        var slice1 []byte = a1[10:20]
        fmt.Printf("Delka rezu 1:    %d\n", len(slice1))
        fmt.Printf("Kapacita rezu 1: %d\n", cap(slice1))
&nbsp;
        var slice2 = a1[20:30]
        fmt.Printf("Delka rezu 2:    %d\n", len(slice2))
        fmt.Printf("Kapacita rezu 2: %d\n", cap(slice2))
&nbsp;
        slice3 := a1[30:40]
        fmt.Printf("Delka rezu 3:    %d\n", len(slice3))
        fmt.Printf("Kapacita rezu 3: %d\n", cap(slice3))
}
</pre>

<p>Důležité je, že kapacita je počítána takovým způsobem, že dosahuje až do
konce pole, tj.&nbsp;je obecně větší, než délka řezu. To je užitečné pro mnoho
operací, které budou popsány příště:</p>

<pre>
Delka pole 1: 100
Delka pole 2: 100
Delka rezu 1:    10
Kapacita rezu 1: 90
Delka rezu 2:    10
Kapacita rezu 2: 80
Delka rezu 3:    10
Kapacita rezu 3: 70
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Pokročilejší operace s&nbsp;řezy</h2>

<p>Vzhledem k&nbsp;tomu, že řez je pouhým &bdquo;pohledem&ldquo; na pole,
znamená to, že modifikace prvků pole bude viditelná i při přístupu
k&nbsp;prvkům řezu a naopak. Toto chování je ukázáno na dalším příkladu,
v&nbsp;němž se nejdříve prvky modifikují přes pole a posléze přes řez:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a[10]int
        
        slice := a[:]
        
        fmt.Printf("Pole před modifikací: %v\n", a)
        fmt.Printf("Řez před modifikací:  %v\n", slice)
&nbsp;
        for i:= 0; i &lt; len(a); i++ {
                a[i] = i*2;
        }
&nbsp;
        fmt.Printf("Pole po modifikací:   %v\n", a)
        fmt.Printf("Řez po modifikaci:    %v\n", slice)
&nbsp;
        for i:= 0; i &lt; len(slice); i++ {
                slice[i] = 42;
        }
&nbsp;
        fmt.Printf("Pole po modifikací:   %v\n", a)
        fmt.Printf("Řez po modifikaci:    %v\n", slice)
}
</pre>

<p>Výsledek by nás už neměl překvapit:</p>

<pre>
Pole před modifikací: [0 0 0 0 0 0 0 0 0 0]
Řez před modifikací:  [0 0 0 0 0 0 0 0 0 0]
&nbsp;
Pole po modifikací:   [0 2 4 6 8 10 12 14 16 18]
Řez po modifikaci:    [0 2 4 6 8 10 12 14 16 18]
&nbsp;
Pole po modifikací:   [42 42 42 42 42 42 42 42 42 42]
Řez po modifikaci:    [42 42 42 42 42 42 42 42 42 42]
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Vytvoření řezu z&nbsp;jiného řezu</h2>

<p>V&nbsp;praxi se taktéž můžeme setkat s&nbsp;tím, že se vytvoří řez
z&nbsp;jiného řezu. Modifikace prvků provedená ve druhém řezu se samozřejmě
přímo &bdquo;propisuje&ldquo; jak do původního řezu, tak i do pole,
z&nbsp;něhož byl původní řez vytvořen. V&nbsp;dalším příkladu takto
modifikujeme prvky přes řez <strong>slice2</strong>:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a[10]int
&nbsp;
        slice1 := a[4:9]
        slice2 := slice1[3:]
&nbsp;
        fmt.Printf("Pole:            %v\n", a)
        fmt.Printf("Delka pole:      %d\n\n", len(a))
&nbsp;
        fmt.Printf("Rez 1:           %v\n", slice1)
        fmt.Printf("Delka rezu 1:    %d\n", len(slice1))
        fmt.Printf("Kapacita rezu 1: %d\n\n", cap(slice1))
&nbsp;
        fmt.Printf("Rez 2:           %v\n", slice2)
        fmt.Printf("Delka rezu 2:    %d\n", len(slice2))
        fmt.Printf("Kapacita rezu 2: %d\n\n", cap(slice2))
&nbsp;
        slice2[0] = 99
        slice2[1] = 99
&nbsp;
        fmt.Printf("Pole:            %v\n", a)
        fmt.Printf("Rez 1:           %v\n", slice1)
        fmt.Printf("Rez 2:           %v\n", slice2)
}
</pre>

<p>Výsledek zobrazený po spuštění příkladu by měl vypadat následovně:</p>

<pre>
Pole:            [0 0 0 0 0 0 0 0 0 0]
Delka pole:      10
&nbsp;
Rez 1:           [0 0 0 0 0]
Delka rezu 1:    5
Kapacita rezu 1: 6
&nbsp;
Rez 2:           [0 0]
Delka rezu 2:    2
Kapacita rezu 2: 3
&nbsp;
Pole:            [0 0 0 0 0 0 0 99 99 0]
Rez 1:           [0 0 0 99 99]
Rez 2:           [99 99]
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Datové typy popsané příště</h2>

<p>V&nbsp;navazujícím článku téma datových typů v&nbsp;jazyce Go dokončíme.
Zabývat se budeme především ukazateli, záznamy (<i>record, struct</i>), mapami,
ale i rozhraními (<i>interface</i>) a do jisté míry i kanály
(<i>channel</i>).</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Speciální hodnota <strong>nil</strong> a její specifický význam v&nbsp;jazyku Go</h2>

<p>V&nbsp;jazyce Go se na několika místech můžeme setkat se speciální hodnotou
<strong>nil</strong>. Tato hodnota se používá pro reprezentaci neinicializované
hodnoty. Proto má <strong>nil</strong> význam především u těch datových typů,
kde je nutné neinicializovanou hodnotu odlišit od ostatních hodnot. Příkladem
mohou být ukazatele, rozhraní (popíšeme si je příště), mapy popř.&nbsp;řezy
(prázdný řez je odlišný od řezu neinicializovaného). <strong>nil</strong> se
naopak nepoužívá u číselných typů, řetězců ani u pravdivostních hodnot, protože
v&nbsp;tomto případě je vždy proměnná inicializována &ndash; na nulu u
číselných typů, na prázdný řetězec u řetězců a na hodnotu
<strong>false</strong> u pravdivostních hodnot:</p>

<table>
<tr><th>Typ</th><th>Výchozí hodnota</th></tr>
<tr><td>všechny numerické typy</td><td>0, 0.0, 0.0+0.0i atd.</td></tr>
<tr><td>řetězce</td><td>""</td></tr>
<tr><td>pole</td><td>prvky rekurzivně inicializované dle této tabulky</td></tr>
<tr><td>ukazatel</td><td>nil</td></tr>
<tr><td>řez</td><td>nil</td></tr>
<tr><td>kanál</td><td>nil</td></tr>
<tr><td>mapa</td><td>nil</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: práce s&nbsp;<strong>nil</strong> ovšem
není tak přímočará, jak by se mohlo na první pohled zdát. Podrobnosti si
uvedeme příště při popisu rozhraní.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
doslova několik kilobajtů), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_integer_signed_types.go</td><td>celočíselné typy se znaménkem</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/01_integer_signed_types.go">https://github.com/tisnik/go-root/blob/master/article_02/01_integer_signed_types.go</a></td></tr>
<tr><td> 2</td><td>02_integer_signed_types_checks.go</td><td>kontrola rozsahu hodnot</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/02_integer_signed_types_checks.go">https://github.com/tisnik/go-root/blob/master/article_02/02_integer_signed_types_checks.go</a></td></tr>
<tr><td> 3</td><td>03_integer_unsigned_types.go</td><td>celočíselné typy bez znaménka</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/03_integer_unsigned_types.go">https://github.com/tisnik/go-root/blob/master/article_02/03_integer_unsigned_types.go</a></td></tr>
<tr><td> 4</td><td>04_integer_constants.go</td><td>číselné soustavy</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/04_integer_constants.go">https://github.com/tisnik/go-root/blob/master/article_02/04_integer_constants.go</a></td></tr>
<tr><td> 5</td><td>05_improper_conversion.go</td><td>zakázaná implicitní konverze</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/05_improper_conversion.go">https://github.com/tisnik/go-root/blob/master/article_02/05_improper_conversion.go</a></td></tr>
<tr><td> 6</td><td>06_improper_conversion.go</td><td>zakázaná implicitní konverze</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/06_improper_conversion.go">https://github.com/tisnik/go-root/blob/master/article_02/06_improper_conversion.go</a></td></tr>
<tr><td> 7</td><td>07_improper_conversion_int_uint.go</td><td>zakázaná implicitní konverze</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/07_improper_conversion_int_uint.go">https://github.com/tisnik/go-root/blob/master/article_02/07_improper_conversion_int_uint.go</a></td></tr>
<tr><td> 8</td><td>08_explicit_conversions.go</td><td>explicitní konverze</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/08_explicit_conversions.go">https://github.com/tisnik/go-root/blob/master/article_02/08_explicit_conversions.go</a></td></tr>
<tr><td> 9</td><td>09_formatting_output.go</td><td>formátování výstupu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/09_formatting_output.go">https://github.com/tisnik/go-root/blob/master/article_02/09_formatting_output.go</a></td></tr>
<tr><td>10</td><td>10_formatting_output.go</td><td>formátování výstupu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/10_formatting_output.go">https://github.com/tisnik/go-root/blob/master/article_02/10_formatting_output.go</a></td></tr>
<tr><td>11</td><td>11_fp_types.go</td><td>typy s&nbsp;plovoucí řádovou čárkou</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/11_fp_types.go">https://github.com/tisnik/go-root/blob/master/article_02/11_fp_types.go</a></td></tr>
<tr><td>12</td><td>12_fp_types_checks.go</td><td>kontrola rozsahu hodnot</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/12_fp_types_checks.go">https://github.com/tisnik/go-root/blob/master/article_02/12_fp_types_checks.go</a></td></tr>
<tr><td>13</td><td>13_complex_types.go</td><td>komplexní čísla</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/13_complex_types.go">https://github.com/tisnik/go-root/blob/master/article_02/13_complex_types.go</a></td></tr>
<tr><td>14</td><td>14_boolean_type.go</td><td>pravdivostní hodnoty</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/14_boolean_type.go">https://github.com/tisnik/go-root/blob/master/article_02/14_boolean_type.go</a></td></tr>
<tr><td>15</td><td>15_boolean_type_checks.go</td><td>nekorektní konverze</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/15_boolean_type_checks.go">https://github.com/tisnik/go-root/blob/master/article_02/15_boolean_type_checks.go</a></td></tr>
<tr><td>16</td><td>16_string_type.go</td><td>datový typ řetězec</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/16_string_type.go">https://github.com/tisnik/go-root/blob/master/article_02/16_string_type.go</a></td></tr>
<tr><td>17</td><td>17_raw_strings.go</td><td>surové řetězce</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/17_raw_strings.go">https://github.com/tisnik/go-root/blob/master/article_02/17_raw_strings.go</a></td></tr>
<tr><td>18</td><td>18_string_content.go</td><td>výpis bajtů reprezentujících řetězec</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/18_string_content.go">https://github.com/tisnik/go-root/blob/master/article_02/18_string_content.go</a></td></tr>
<tr><td>19</td><td>19_local_variables.go</td><td>lokální proměnné</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/19_local_variables.go">https://github.com/tisnik/go-root/blob/master/article_02/19_local_variables.go</a></td></tr>
<tr><td>20</td><td>20_arrays.go</td><td>pole</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/20_arrays.go">https://github.com/tisnik/go-root/blob/master/article_02/20_arrays.go</a></td></tr>
<tr><td>21</td><td>21_array_copy.go</td>kopie polí<td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/21_array_copy.go">https://github.com/tisnik/go-root/blob/master/article_02/21_array_copy.go</a></td></tr>
<tr><td>22</td><td>22_slices.go</td><td>řezy polí</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/22_slices.go">https://github.com/tisnik/go-root/blob/master/article_02/22_slices.go</a></td></tr>
<tr><td>23</td><td>23_slice_copy.go</td><td>propisování hodnot mezi polem a řezem</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/23_slice_copy.go">https://github.com/tisnik/go-root/blob/master/article_02/23_slice_copy.go</a></td></tr>
<tr><td>24</td><td>24_slice_from_slice.go</td><td>vytvoření řezu z jiného řezu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_02/24_slice_from_slice.go">https://github.com/tisnik/go-root/blob/master/article_02/24_slice_from_slice.go</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na Internetu</h2>

<ol>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go <br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

<li>Printf Format Strings<br />
<a href="https://www.cprogramming.com/tutorial/printf-format-strings.html">https://www.cprogramming.com/tutorial/printf-format-strings.html</a>
</li>

<li>Java: String.format<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-</a>
</li>

<li>Java: format string syntax<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

<!--
2018-11-10: 1 hod
2018-11-11: 1 hod
2018-11-12: 1 hod
2018-11-13: 1 hod
2018-11-14: 1 hod
2018-11-15: 1 hod
publikace:  1 hod
-----------------
            1 hod
-->
