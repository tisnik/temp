<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Datové struktury s líným vyhodnocováním v programovacím jazyce Go</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Datové struktury s líným vyhodnocováním v programovacím jazyce Go</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešní části seriálu o programovacím jazyku Go se seznámíme s balíčkem umožňujícím práci s takzvanými proudy (stream), což jsou ve skutečnosti zobecněné líně vyhodnocované sekvence zpopularizované v programovacím jazyku Clojure.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Datové struktury s&nbsp;líným vyhodnocováním v&nbsp;programovacím jazyce Go</a></p>
<p><a href="#k02">2. Sekvence a lazy sekvence v&nbsp;programovacím jazyku Clojure</a></p>
<p><a href="#k03">3. Líně vyhodnocované proudy v&nbsp;Go &ndash; knihovna Koazee</a></p>
<p><a href="#k04">4. Vytvoření proudu z&nbsp;řezu</a></p>
<p><a href="#k05">5. Proud vytvořený ze sekvence uživatelem definovaných struktur</a></p>
<p><a href="#k06">6. Problémy, které mohou nastat při vytváření proudu z&nbsp;pole</a></p>
<p><a href="#k07">7. Základní vlastnosti proudů</a></p>
<p><a href="#k08">8. Test, zda proud obsahuje zadaný prvek</a></p>
<p><a href="#k09">9. Získání indexu nalezeného prvku</a></p>
<p><a href="#k10">10. Získání nového proudu pomocí řezu (metoda <strong>Take</strong>)</a></p>
<p><a href="#k11">11. Metody pro přidání a ubrání prvku z&nbsp;proudu</a></p>
<p><a href="#k12">12. Funkce vyššího řádu a jejich použití při zpracování proudů</a></p>
<p><a href="#k13">13. Výběr prvků na základě zadaného kritéria: metoda <strong>Filter</strong></a></p>
<p><a href="#k14">14. Aplikace funkce na každý prvek proudu: metoda <strong>Map</strong></a></p>
<p><a href="#k15">15. Zavolání specifikované callback funkce pro každý prvek proudu: metoda <strong>ForEach</strong></a></p>
<p><a href="#k16">16. Seřazení prvků na základě jejich porovnání: metoda <strong>Sort</strong></a></p>
<p><a href="#k17">17. Kombinace více operací na proud: <strong>Filter</strong>&rarr;<strong>Map</strong>&rarr;<strong>ForEach</strong></a></p>
<p><a href="#k18">18. Použití metody <strong>Reduce</strong> pro zpracování všech prvků proudu</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Datové struktury s&nbsp;líným vyhodnocováním v&nbsp;programovacím jazyce Go</h2>

<p>V&nbsp;seriálu o programovacím jazyce <a
href="https://www.root.cz/n/clojure/">Clojure</a>, který na serveru <a
href="https://www.root.cz">Root</a> vycházel, jsme se již mnohokrát setkali
s&nbsp;pojmem <i>sekvence</i>, popř.&nbsp;<i>nekonečné sekvence</i> nebo
dokonce <i>lazy sekvence</i>. Jedná se o datovou abstrakci, která je sice velmi
jednoduchá na pochopení, ale o to užitečnější v&nbsp;praxi &ndash; ostatně
velká část standardní knihovny programovacího jazyka Clojure je na sekvencích
založena. Pro ty programátory, kteří programovací jazyk Clojure znají a
současně používají i Python, je určena minimalisticky pojatá knihovna nazvaná
<a href="https://github.com/bfontaine/clj">clj</a>, kterou jsme si již taktéž
popsali <a
href="https://www.root.cz/clanky/knihovny-pro-zpracovani-posloupnosti-sekvenci-v-pythonu/#k03">v&nbsp;samostatném
článku</a>. Ovšem jak je tomu v&nbsp;jazyku Go? Tento programovací jazyk ve své
základní knihovně žádný podobný koncept (alespoň prozatím) nenabízí, ovšem
existuje jeden balíček, který implementuje mechanismus podobný <i>lazy
sekvencím</i>. Tento balíček, který se jmenuje <strong>Koazee</strong>, si dnes
popíšeme a ukážeme si jeho možnosti a omezení na několika demonstračních
příkladech.</p> 

<p>Předností všech líně vyhodnocovaných typů je fakt, že se operace aplikované
například na dlouhou sekvenci údajů aplikují až ve chvíli, kdy je to nezbytně
nutné, tj.&nbsp;když nějaká jiná část programu nutně potřebuje použít výslednou
hodnotu. Ovšem v&nbsp;praxi se ukazuje, že mnohdy nepotřebujeme znát všechny
výsledné hodnoty, takže líné vyhodnocování může vést k&nbsp;úsporám strojového
času. Představte si například systém, v&nbsp;němž je zdrojem dat dlouhé XML
generované například nějakým B2B nástrojem. Pokud potřebujeme z&nbsp;tohoto XML
získat jen jediný údaj (například na základě <i>xpath</i>), asi není nejlepším
řešením celé XML parsovat, vytvořit DOM a poté procházet obsahem získané datové
struktury a v&nbsp;ní hledat požadovaný prvek. Lepší bude využít
&bdquo;proudový&ldquo; přístup a nechat obsah XML zpracovávat postupně. A právě
podobný koncept je využíván i línými sekvencemi v&nbsp;jazyku Clojure a líně
vyhodnocovanými proudy v&nbsp;případě kombinace Go+Koazee.</p>

<p><div class="rs-tip-major">Poznámka: abychom pochopili, jaké funkce nalezneme
v&nbsp;knihovně <strong>Koazee</strong>, popíšeme si nejprve ve stručnosti
sekvence a lazy sekvence tak, jak jsou implementovány přímo
v&nbsp;programovacím jazyce Clojure. Posléze se podíváme na to, do jaké míry
byl úspěšný převod tohoto konceptu do programovacího jazyka Go. Jazyky Clojure
a Go jsou totiž v&nbsp;mnoha ohledech diametrálně odlišné &ndash; Go je
v&nbsp;tomto porovnání nízkoúrovňový jazyk se všemi z&nbsp;toho plynoucími
důsledky (nižší míra abstrakce atd.).</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Sekvence a lazy sekvence v&nbsp;programovacím jazyku Clojure</h2>

<p>Mnoho funkcí a maker, které nalezneme ve <a
href="https://clojuredocs.org/core-library">standardní knihovně</a> <a
href="https://clojure.org/">programovacího jazyka Clojure</a> souvisí
s&nbsp;takzvanými <i>sekvencemi</i>. Tímto termínem se označuje programové
rozhraní, které svými základními možnostmi zhruba odpovídá iterátorům známým
z&nbsp;programovacího jazyka Java. V&nbsp;Clojure existuje velké množství
funkcí, které dokážou pracovat se sekvencemi, ať již se jedná o běžné sekvence
(jejichž prvky jsou přímo uloženy v&nbsp;operační paměti), nebo takzvané
<i>líné sekvence</i> (<i>lazy sekvence</i>), které nové prvky vytváří či
zjišťují až při konkrétním přístupu na tyto prvky. Mezi tyto funkce patří
například <strong>sort</strong>, <strong>sort-by</strong>,
<strong>take</strong> či <strong>flatten</strong>. Díky tomu, že všechny
standardní <i>kolekce</i> (seznamy, vektory, ...) jsou současně i sekvencemi,
lze tyto funkce aplikovat i na kolekce, ovšem ve skutečnosti jsou sekvencemi i
další typy objektů, zejména pak I/O proudy (tímto směrem se posunuly i
standardní knihovny Javy), řetězce (což jsou sekvence znaků) atd.</p>

<p><div class="rs-tip-major">Poznámka: i funkce, které zdánlivě mění sekvenci,
tj.&nbsp;přidávají do ní prvky, mažou prvky, řadí prvky atd., ve skutečnosti
původní sekvenci nijak nemodifikují a vrátí namísto toho sekvenci novou.
Základní myšlenka jazyka Clojure &ndash; prakticky všechny hodnoty jsou
neměnitelné &ndash; je tak rozšířena i na sekvence. Neměnitelnost
(<i>immutability</i>) se zde vztahuje k&nbsp;&bdquo;tvaru&ldquo; sekvence,
protože je možné, aby samotné prvky sekvence měnitelné byly (i když se
s&nbsp;měnitelnými prvky v&nbsp;praxi setkáme jen velmi zřídka).</div></p>

<p>Naprostý základ pro práci se sekvencemi tvoří trojice funkcí nazvaných
<strong>first</strong>, <strong>rest</strong> a <strong>next</strong>. Funkce
<strong>first</strong> vrací první prvek v&nbsp;sekvenci, popř.&nbsp;speciální
hodnotu <strong>nil</strong> v&nbsp;případě, že je sekvence prázdná. Funkce
<strong>rest</strong> i <strong>next</strong> vrací zbylé prvky
v&nbsp;sekvenci, ovšem liší se tím, jaká hodnota se vrátí ve chvíli, kdy již
v&nbsp;sekvenci nezbyly žádné prvky (kromě prvního). V&nbsp;tomto případě vrátí
<strong>rest</strong> prázdnou sekvenci (například prázdný seznam), zatímco
funkce <strong>next</strong> vrátí již zmíněnou speciální hodnotu
<strong>nil</strong>. U běžných sekvencí, například seznamů, jsou tyto funkce
implementovány přímočaře, ovšem v&nbsp;případě <i>lazy sekvencí</i> se prvky
vrácené pomocí funkce <strong>first</strong> vyhodnocují až za běhu, například
pomocí nějaké generátorové funkce. Tímto způsobem je možné pracovat i
s&nbsp;nekonečnými sekvencemi, u nichž už z&nbsp;principu nelze dopředu znát
celkový počet prvků atd.</p>

<p>Velmi dobrým příkladem lazy sekvence je funkce <strong>range</strong>, která
dokonce existuje v&nbsp;několika podobách, jež se od sebe z&nbsp;hlediska
programátora-uživatele liší především různým počtem parametrů. Pokud se této
funkci nepředá žádný parametr, vrátí funkce <strong>range</strong> sekvenci
celých čísel od nuly do nekonečna. Zde je patrné, proč se musí jednat o lazy
sekvenci &ndash; nekonečnou řadu celých čísel by samozřejmě v&nbsp;případě
normální sekvence nebylo možné uložit do operační paměti. Pokud se funkci
<strong>range</strong> předá pouze jediný parametr (kterým musí být celé číslo
&ndash; je kontrolováno v&nbsp;runtime), je vrácena sekvence celých čísel od 0
do zadané hodnoty-1. Opět se jedná o nefalšovanou lazy sekvenci, takže se
nemusíte bát používat i velké <strong>n</strong>. Dále již následují
v&nbsp;podstatě jen kosmetické úpravy &ndash; volání funkce
<strong>range</strong> se dvěma parametry <strong>m</strong>,
<strong>n</strong> vytvoří sekvenci celých čísel od <strong>m</strong> do
<strong>n-1</strong> a pokud je použit ještě třetí parametr, určuje se jím
krok, který může být i záporný.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Líně vyhodnocované proudy v&nbsp;Go &ndash; knihovna Koazee</h2>

<p>Po krátké odbočce se vraťme k&nbsp;programovacímu jazyku Go. Tento jazyk je
z&nbsp;velké části založen na odlišných paradigmatech, než jazyk Clojure, takže
nebude příliš překvapující zjištění, že standardní datové typy (včetně řezů,
polí a map) jsou vyhodnocovány ihned po aplikování nějaké operace. Nicméně
existují knihovny, které koncept líného vyhodnocování dokážou v&nbsp;runtime
aplikovat. Mezi tyto knihovny patří i knihovna nazvaná <strong>Koazee</strong>,
jejíž zdrojové kódy naleznete na GitHubu na adrese <a
href="https://github.com/wesovilabs/koazee">https://github.com/wesovilabs/koazee</a>
a která pracuje s&nbsp;<i>proudy</i>.</p>

<p>Nicméně i přes některé rozdíly mezi proudy a líně vyhodnocovanými sekvencemi
je základní myšlenka stejná &ndash; umožnit aplikaci různých transformací na
sekvenci dat, ideálně takovým způsobem, aby se transformace aplikovala až
tehdy, kdy (pokud vůbec) bude výsledek vyžadován. V&nbsp;mnoha algoritmech
totiž například hledáme určitý transformovaný prvek v&nbsp;sekvenci/proudu a po
jeho nalezení algoritmus končí. Nemá tedy význam aplikovat transformace na
všechny prvky, tedy i ty, které se již dále nebudou nijak využívat (a takových
algoritmů je překvapivě velké množství, ostatně se s&nbsp;nimi setkáváme každý
den například u služeb poskytujících video a audio streamy).</p>

<p><div class="rs-tip-major">Poznámka: knihovna <i>Koazee</i> v&nbsp;současné
podobě nepodporuje práci s&nbsp;nekonečnými sekvencemi, takže tento velmi
užitečný mechanismus nebudeme v&nbsp;Go moci použít.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vytvoření proudu z&nbsp;řezu</h2>

<p>Nejprve si pochopitelně ukážeme, jakým způsobem se proud (<i>stream</i>)
vytvoří. Existují dokonce dvě varianty konstrukce proudu, které se však interně
chovají odlišně. V&nbsp;první variantě je použit konstruktor
<strong>New</strong> z&nbsp;balíčku
<strong>github.com/wesovilabs/koazee/stream</strong>:</p>

<pre>
values := []int{1, 2, 3, 4, 5}
stream1 := stream.<strong>New</strong>(values)
</pre>

<p>Druhá varianta je založena na funkci <strong>StreamOf</strong>, která ovšem
pochází z&nbsp;odlišného balíčku se jménem
<strong>github.com/wesovilabs/koazee</strong>:</p>

<pre>
values := []int{1, 2, 3, 4, 5}
stream := koazee.<strong>StreamOf</strong>(values)
</pre>

<p>Další důležitou operací je získání dat z&nbsp;proudu, protože prvky
v&nbsp;proudu mohou být podrobeny mnoha transformacím popsaných v&nbsp;dalším
textu. Pro přečtení se použije metoda <strong>Out()</strong> vracející instanci
datového typu <strong>Option</strong>:</p>

<pre>
func (s Stream) <strong>Out</strong>() *Output
</pre>

<p>Samotný obsah proudu, tedy jednotlivé prvky, se přečtou metodou
<strong>Val()</strong>, která je definována pro typ
<strong>Option</strong>:</p>

<pre>
func (o Output) <strong>Val</strong>() interface{}
</pre>

<p>Příklad použití:</p>

<pre>
words := []string{"one", "two", "three", "four", "five"}
stream = koazee.StreamOf(words)
fmt.Printf("stream:   %v\n", <strong>stream.Out().Val()</strong>)
</pre>

<p>Nyní si ukážeme, jakým způsobem se oba typy konstruktorů používají. Nejprve
vytvoříme proud z&nbsp;řezu (alternativně z&nbsp;pole, což je ovšem potenciálně
problematické) a následně z&nbsp;proudu opět přečteme jednotlivé prvky, takže
se vlastně provede zpětná konverze na nějaký základní datový typ programovacího
jazyka Go.</p>

<p>V&nbsp;prvním demonstračním příkladu je pro vytvoření proudu použit
konstruktor <strong>New</strong>. V&nbsp;příkladu jsou vytvořeny dva proudy,
přičemž jeden z&nbsp;nich obsahuje sekvenci celých čísel a druhý sekvenci
řetězců (výhodou je, že oba tyto datové typy jsou neměnitelné &ndash;
<i>immutable</i>):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee/stream"
)
&nbsp;
func <strong>main</strong>() {
        values := []int{1, 2, 3, 4, 5}
        fmt.Printf("input:   %v\n", values)
&nbsp;
        stream1 := stream.New(values)
        fmt.Printf("stream:   %v\n", stream1.Out().Val())
&nbsp;
        fmt.Println()
&nbsp;
        words := []string{"one", "two", "three", "four", "five"}
        fmt.Printf("words:    %v\n", words)
&nbsp;
        stream2 := stream.New(words)
        fmt.Printf("stream:   %v\n", stream2.Out().Val())
&nbsp;
        fmt.Println()
&nbsp;
        anything := []interface{}{"one", 1, 1.0, 1 + 1i}
        fmt.Printf("anything: %v\n", anything)
&nbsp;
        stream3 := stream.New(anything)
        fmt.Printf("stream:   %v\n", stream3.Out().Val())
}
</pre>

<p>Po překladu spuštění tohoto demonstračního příkladu získáme následující
informace o původním řezu i o datech získaných z&nbsp;proudu:</p>

<pre>
input:   [1 2 3 4 5]
stream:   [1 2 3 4 5]
&nbsp;
words:    [one two three four five]
stream:   [one two three four five]
&nbsp;
anything: [one 1 1 (1+1i)]
stream:   [one 1 1 (1+1i)]
</pre>

<p>Druhý demonstrační příklad se do značné míry podobá příkladu prvnímu, ovšem
pro vytvoření proudu je využita funkce <strong>StreamOf</strong> a nikoli
konstruktor <strong>New</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
func <strong>main</strong>() {
        values := []int{1, 2, 3, 4, 5}
        fmt.Printf("input:    %v\n", values)
&nbsp;
        stream := koazee.StreamOf(values)
        fmt.Printf("stream:   %v\n", stream.Out().Val())
&nbsp;
        fmt.Println()
&nbsp;
        words := []string{"one", "two", "three", "four", "five"}
        fmt.Printf("words:    %v\n", words)
&nbsp;
        stream = koazee.StreamOf(words)
        fmt.Printf("stream:   %v\n", stream.Out().Val())
&nbsp;
        fmt.Println()
&nbsp;
        anything := []interface{}{"one", 1, 1.0, 1 + 1i}
        fmt.Printf("anything: %v\n", anything)
&nbsp;
        stream3 := koazee.StreamOf(anything)
        fmt.Printf("stream:   %v\n", stream3.Out().Val())
}
</pre>

<p>Po spuštění tohoto příkladu se vypíšou stejné zprávy, jako u příkladu
prvního:</p>

<pre>
input:    [1 2 3 4 5]
stream:   [1 2 3 4 5]
&nbsp;
words:    [one two three four five]
stream:   [one two three four five]
&nbsp;
anything: [one 1 1 (1+1i)]
stream:   [one 1 1 (1+1i)]
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Proud vytvořený ze sekvence uživatelem definovaných struktur</h2>

<p>Proud je samozřejmě možné vytvořit z&nbsp;prakticky libovolných hodnot. Může
se tedy jednat i o hodnoty uživatelských datových typů. V&nbsp;dalším
demonstračním příkladu jsou použity hodnoty uživatelského datového typu
<strong>User:</strong></p>

<pre>
type User struct {
        id      uint32
        name    string
        surname string
}
</pre>

<p>Proud je vytvořen funkcí <strong>StreamOf</strong>, s&nbsp;níž jsme se již
seznámili v&nbsp;předchozích kapitolách:</p>

<pre>
stream := koazee.StreamOf(users)
</pre>

<p>Získání prvků z&nbsp;takového proudu je naprosto stejné, jako u proudů,
jejichž prvky byla celá čísla popř.&nbsp;řetězce:</p>

<pre>
fmt.Printf("stream: %v\n", stream.Out().Val())
</pre>

<p>Podívejme se nyní na úplný zdrojový kód tohoto příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
type User struct {
        id      uint32
        name    string
        surname string
}
&nbsp;
func <strong>main</strong>() {
        var users = []User{
                User{
                        id:      1,
                        name:    "Pepek",
                        surname: "Vyskoč"},
                User{
                        id:      2,
                        name:    "Pepek",
                        surname: "Vyskoč"},
                User{
                        id:      3,
                        name:    "Josef",
                        surname: "Vyskočil"},
        }
        fmt.Println(users)
&nbsp;
        fmt.Printf("input:  %v\n", users)
&nbsp;
        stream := koazee.StreamOf(users)
        fmt.Printf("stream: %v\n", stream.Out().Val())
}
</pre>

<p>Po jeho spuštění by se měla zobrazit jak zdrojová data, tak i obsah
proudu:</p>

<pre>
[{1 Pepek Vyskoč} {2 Pepek Vyskoč} {3 Josef Vyskočil}]
input:  [{1 Pepek Vyskoč} {2 Pepek Vyskoč} {3 Josef Vyskočil}]
stream: [{1 Pepek Vyskoč} {2 Pepek Vyskoč} {3 Josef Vyskočil}]
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Problémy, které mohou nastat při vytváření proudu z&nbsp;pole</h2>

<p>Při konstrukci proudů mohou nastat problémy. Týká se to především situace,
kdy se snažíme proud vytvořit z&nbsp;pole, například z&nbsp;pole uživatelských
struktur (i když na typů prvků pole tolik nezáleží):</p>

<pre>
var users = <strong>[3]</strong>User{
        User{
                id:      1,
                name:    "Pepek",
                surname: "Vyskoč"},
        User{
                id:      2,
                name:    "Pepek",
                surname: "Vyskoč"},
        User{
                id:      3,
                name:    "Josef",
                surname: "Vyskočil"},
}
</pre>

<p>Povšimněte si, že skutečně pracujeme s&nbsp;polem, u kterého je explicitně
zadán počet prvků. Pokud bychom počet prvků vynechali, jednalo by se o řez.</p>

<p>Nyní se můžeme pokusit vytvořit proud pomocí funkce
<strong>StreamOf</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
type <strong>User</strong> struct {
        id      uint32
        name    string
        surname string
}
&nbsp;
func <strong>main</strong>() {
        var users = [3]User{
                User{
                        id:      1,
                        name:    "Pepek",
                        surname: "Vyskoč"},
                User{
                        id:      2,
                        name:    "Pepek",
                        surname: "Vyskoč"},
                User{
                        id:      3,
                        name:    "Josef",
                        surname: "Vyskočil"},
        }
        fmt.Println(users)
&nbsp;
        fmt.Printf("input:  %v\n", users)
&nbsp;
        stream := koazee.StreamOf(users)
        fmt.Printf("stream: %v\n", stream.Out().Val())
}
</pre>

<p>Výsledek nás ovšem příliš nepotěší, protože proud bude prázdný!</p>

<pre>
[{1 Pepek Vyskoč} {2 Pepek Vyskoč} {3 Josef Vyskočil}]
input:  [{1 Pepek Vyskoč} {2 Pepek Vyskoč} {3 Josef Vyskočil}]
stream: <strong>&lt;nil&gt;</strong>
</pre>

<p>Další příklad je prakticky stejný, jako příklad předchozí, ovšem proud
z&nbsp;pole vytvoříme konstruktorem <strong>New</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee/stream"
)
&nbsp;
type <strong>User</strong> struct {
        id      uint32
        name    string
        surname string
}
&nbsp;
func <strong>main</strong>() {
        var users = [3]User{
                User{
                        id:      1,
                        name:    "Pepek",
                        surname: "Vyskoč"},
                User{
                        id:      2,
                        name:    "Pepek",
                        surname: "Vyskoč"},
                User{
                        id:      3,
                        name:    "Josef",
                        surname: "Vyskočil"},
        }
        fmt.Println(users)
&nbsp;
        fmt.Printf("input:  %v\n", users)
&nbsp;
        stream := stream.New(users)
        fmt.Printf("stream: %v\n", stream.Out().Val())
}
</pre>

<p>Takto vytvořený proud již bude obsahovat všechny očekávané prvky:</p>

<pre>
[{1 Pepek Vyskoč} {2 Pepek Vyskoč} {3 Josef Vyskočil}]
input:  [{1 Pepek Vyskoč} {2 Pepek Vyskoč} {3 Josef Vyskočil}]
stream: [{1 Pepek Vyskoč} {2 Pepek Vyskoč} {3 Josef Vyskočil}]
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Základní vlastnosti proudů</h2>

<p>Nyní si již můžeme ukázat několik základních metod používaných pro práci
s&nbsp;proudy. Mezi základní metody patří metoda pro zjištění počtu prvků
v&nbsp;proudu a dále trojice metod umožňujících přístup k&nbsp;jednotlivým
prvkům:</p>

<table>
<tr><th>#</th><th>Metoda</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>Count</td><td>vrací počet prvků v&nbsp;proudu</td></tr>
<tr><td>2</td><td>First</td><td>vrací první prvek z&nbsp;proudu</td></tr>
<tr><td>3</td><td>Last</td><td>vrací poslední prvek z&nbsp;proudu</td></tr>
<tr><td>4</td><td>At</td><td>vrací n-tý prvek z&nbsp;proudu (indexuje se od nuly), popř.&nbsp;<strong>nil</strong></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: v&nbsp;Go nelze přetěžovat operátory,
takže je skutečně nutné použít metodu <strong>At</strong> a nikoli operátor
indexování [].</div></p>

<p>Tyto metody si můžeme velmi snadno otestovat:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
func <strong>main</strong>() {
        values := []int{1, 2, 3, 4, 5}
        fmt.Printf("input:\t%v\n", values)
&nbsp;
        stream := koazee.StreamOf(values)
&nbsp;
        cnt, _ := stream.Count()
        fmt.Printf("count:\t%d\n", cnt)
&nbsp;
        first := stream.First().Val()
        fmt.Printf("first:\t%d\n", first)
&nbsp;
        second := stream.At(1).Val()
        fmt.Printf("second:\t%d\n", second)
&nbsp;
        last := stream.Last().Val()
        fmt.Printf("last:\t%d\n", last)
&nbsp;
        unknown := stream.At(10).Val()
        fmt.Printf("unknown:\t%v\n", unknown)
}
</pre>

<p>Výsledky běhu tohoto demonstračního příkladu by neměly být překvapující:</p>

<pre>
input:  [1 2 3 4 5]
count:  5
first:  1
second: 2
last:   5
unknown:        &lt;nil&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jakým způsobem jsme
informováni o tom, že prvek s&nbsp;daným indexem neexistuje &ndash; vrátí se
hodnota <strong>nil</strong>. To obecně není příliš dobré řešení, protože pro
rozlišení mezi neexistujícím prvkem a skutečnou hodnotou <strong>nil</strong>
bude nutné všude používat i metodu <strong>Count</strong>. Podobný koncept je
mimochodem použit i v&nbsp;programovacím jazyce Lua při přístupu k&nbsp;prvkům
tabulky.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Test, zda proud obsahuje zadaný prvek</h2>

<p>Poměrně často je nutné zjistit, jestli proud obsahuje určitý prvek.
K&nbsp;tomuto účelu lze použít metodu <strong>Contains</strong>:</p>

<pre>
func (s Stream) <strong>Contains</strong>(element interface{}) (bool, *errors.Error)
</pre>

<p>Vidíme, že tato metoda vrací dvě hodnoty: informaci o tom, zda byl prvek
s&nbsp;danou hodnotou v&nbsp;proudu nalezen a taktéž informaci o chybě, která
může při vyhledávání prvku nastat. Proč vlastně může dojít k&nbsp;chybě u tak
jednoduché operace, jakou je nalezení prvku v&nbsp;proudu? Celý problém spočívá
v&nbsp;typovém systému programovacího jazyka Go, který neumožňuje, aby se
překladači oznámil typ prvků uložených v&nbsp;proudu. Proto se předpokládá, že
prvky jsou typu <strong>interface{}</strong> a kontrola, zda typ hledaného
prvku odpovídá typům prvků v&nbsp;proudu se provádí programově, tedy až
v&nbsp;<i>runtime</i>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
func <strong>main</strong>() {
        values := []int{1, 2, 3, 4, 5}
        fmt.Printf("input: %v\n", values)
&nbsp;
        stream := koazee.StreamOf(values)
&nbsp;
        p1, _ := stream.Contains(2)
        fmt.Printf("contains 2? %v\n", p1)
&nbsp;
        p2, _ := stream.Contains(42)
        fmt.Printf("contains 42? %v\n", p2)
&nbsp;
        fmt.Println()
&nbsp;
        words := []string{"one", "two", "three", "four", "five"}
        fmt.Printf("words: %v\n", words)
&nbsp;
        stream = koazee.StreamOf(words)
&nbsp;
        p3, _ := stream.Contains("one")
        fmt.Printf("contains 'one'? %v\n", p3)
&nbsp;
        p4, e1 := stream.Contains("ten")
        fmt.Printf("contains 'ten'? %v\n", p4)
        fmt.Printf("error %v\n", e1)
&nbsp;
        p4, e2 := stream.Contains(42)
        fmt.Printf("contains 42? %v\n", p4)
        fmt.Printf("error %v\n", e2)
}
</pre>

<p>Povšimněte si především posledních dvou řádků výstupu. Jedná se o výsledek
snahy o vyhledání prvku jiného typu, než je počet prvků uložených
v&nbsp;proudu:</p>

<pre>
input: [1 2 3 4 5]
contains 2? true
contains 42? false
&nbsp;
words: [one two three four five]
contains 'one'? true
contains 'ten'? false
error &lt;nil&gt;
contains 42? false
error [contains:err.invalid-argument] The Stream contains elements of type string and the passed argument has type int
</pre>

<p>V&nbsp;dalším demonstračním příkladu je ukázáno, že je možné vyhledávat i
prvky, jejichž hodnoty mají složitější datové typy, zde konkrétně datový typ
<strong>User</strong>, který již známe z&nbsp;předchozích kapitol:</p>

<pre>
type <strong>User</strong> struct {
        id      uint32
        name    string
        surname string
}
</pre>

<p>Následuje výpis úplného zdrojového kódu tohoto demonstračního příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
type <strong>User</strong> struct {
        id      uint32
        name    string
        surname string
}
&nbsp;
func <strong>main</strong>() {
        var users = []User{
                User{
                        id:      1,
                        name:    "Pepek",
                        surname: "Vyskoč"},
                User{
                        id:      2,
                        name:    "Pepek",
                        surname: "Vyskoč"},
                User{
                        id:      3,
                        name:    "Josef",
                        surname: "Vyskočil"},
        }
        fmt.Println(users)
&nbsp;
        stream := koazee.StreamOf(users)
&nbsp;
        p1, _ := stream.Contains(User{3, "Josef", "Vyskočil"})
        fmt.Printf("contains? %v\n", p1)
&nbsp;
        p2, _ := stream.Contains(User{4, "Josef", "Vyskočil"})
        fmt.Printf("contains? %v\n", p2)
}
</pre>

<p>Výsledek činnosti tohoto demonstračního příkladu by měl vypadat
následovně:</p>

<pre>
[{1 Pepek Vyskoč} {2 Pepek Vyskoč} {3 Josef Vyskočil}]
contains? true
contains? false
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Získání indexu nalezeného prvku</h2>

<p>Mnohdy se pochopitelně nespokojíme pouze s&nbsp;oznámením, že proud obsahuje
či naopak neobsahuje hledaný prvek. V&nbsp;případě, že takový prvek budeme
chtít získat, je nutné použít metodu <strong>IndexOf</strong> či
<strong>LastIndexOf</strong>, která vrátí index prvního resp.&nbsp;posledního
prvku v&nbsp;proudu, který odpovídá prvku hledanému. I tyto metody vrací dvě
hodnoty, a to jak hledaný index, tak i informaci o případné chybě, která může
nastat:</p>

<pre>
func (s Stream) <strong>IndexOf</strong>(element interface{}) (int, *errors.Error)
</pre>

<p>a:</p>

<pre>
func (s Stream) <strong>LastIndexOf</strong>(element interface{}) (int, *errors.Error)
</pre>

<p>Ve chvíli, kdy není prvek nalezen, ale současně nedojde k&nbsp;žádné běhové
chybě, je vrácena hodnota -1 neboli <strong>InvalidIndex</strong>.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;případě, že budete potřebovat
nalézt všechny určité prvky, může být vhodnější použít buď dále popsanou funkci
vyššího řádu <strong>Filter</strong> popř.&nbsp;je možné použít metodu
<strong>IndexesOf</strong> vracející řez s&nbsp;indexy:</div></p>

<pre>
func (s Stream) <strong>IndexesOf</strong>(element interface{}) ([]int, *errors.Error)
</pre>

<p>V&nbsp;dalším demonstračním příkladu je ukázáno použití metod
<strong>IndexOf</strong> i <strong>LastIndexOf</strong> pro proud s&nbsp;celými
čísly a řetězci:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
func <strong>main</strong>() {
        values := []int{1, 2, 3, 4, 5, 1}
        fmt.Printf("input: %v\n", values)
&nbsp;
        stream := koazee.StreamOf(values)
&nbsp;
        i1, _ := stream.IndexOf(1)
        fmt.Printf("index of 1: %v\n", i1)
&nbsp;
        i2, _ := stream.LastIndexOf(1)
        fmt.Printf("last index of 1: %v\n", i2)
&nbsp;
        i3, _ := stream.IndexOf(42)
        fmt.Printf("index of 42: %v\n", i3)
&nbsp;
        fmt.Println()
&nbsp;
        words := []string{"one", "two", "three", "four", "five"}
        fmt.Printf("words: %v\n", words)
&nbsp;
        stream = koazee.StreamOf(words)
&nbsp;
        i4, _ := stream.IndexOf("one")
        fmt.Printf("index of 'one': %v\n", i4)
&nbsp;
        i5, _ := stream.LastIndexOf("two")
        fmt.Printf("last index of 'one': %v\n", i5)
&nbsp;
        i6, e6 := stream.IndexOf("foobar")
        fmt.Printf("index of 'foobar': %v\n", i6)
        fmt.Printf("error: %v\n", e6)
&nbsp;
        fmt.Println()
&nbsp;
        i7, e7 := stream.IndexOf(42)
        fmt.Printf("index of 42: %v\n", i7)
        fmt.Printf("error: %v\n", e7)
}
</pre>

<p>Opět si ukažme výsledky získané spuštěním tohoto demonstračního
příkladu:</p>

<pre>
input: [1 2 3 4 5 1]
index of 1: 0
last index of 1: 5
index of 42: -1
&nbsp;
words: [one two three four five]
index of 'one': 0
last index of 'one': 1
index of 'foobar': -1
error: &lt;nil&gt;
&nbsp;
index of 42: -1
error: [indexOf:err.invalid-argument] The Stream indexOf elements of type string and the passed argument has type int
</pre>

<p>Podobně jako u metody <strong>Contains</strong> je možné i v&nbsp;případě
metod <strong>IndexOf</strong> a <strong>LastIndexOf</strong> prvky vyhledávat
v&nbsp;proudu obsahujícím hodnoty uživatelsky definovaných datových typů:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
type User struct {
        id      uint32
        name    string
        surname string
}
&nbsp;
func <strong>main</strong>() {
        var users = []User{
                User{
                        id:      1,
                        name:    "Pepek",
                        surname: "Vyskoč"},
                User{
                        id:      2,
                        name:    "Pepek",
                        surname: "Vyskoč"},
                User{
                        id:      3,
                        name:    "Josef",
                        surname: "Vyskočil"},
        }
        fmt.Println(users)
&nbsp;
        stream := koazee.StreamOf(users)
&nbsp;
        i1, _ := stream.IndexOf(User{3, "Josef", "Vyskočil"})
        fmt.Printf("index of #1: %v\n", i1)
&nbsp;
        i2, _ := stream.LastIndexOf(User{3, "Josef", "Vyskočil"})
        fmt.Printf("last index of #1: %v\n", i2)
&nbsp;
        i3, _ := stream.IndexOf(User{})
        fmt.Printf("index of #2: %v\n", i3)
}
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
[{1 Pepek Vyskoč} {2 Pepek Vyskoč} {3 Josef Vyskočil}]
index of #1: 2
last index of #1: 2
index of #2: -1
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Získání nového proudu pomocí řezu (metoda <strong>Take</strong>)</h2>

<p>Přímo v&nbsp;programovacím jazyku Go existuje operátor <i>slice</i> sloužící
k&nbsp;získání nového řezu z&nbsp;pole popř.&nbsp;z&nbsp;jiného řezu.
Připomeňme si, že se tento operátor zapisuje podobným způsobem, jako
indexování, ovšem používají se zde dva indexy oddělené dvojtečkou:</p>

<pre>
var a1 [100]byte
var a2 [100]int32
&nbsp;
fmt.Printf("Delka pole 1: %d\n", len(a1))
fmt.Printf("Delka pole 2: %d\n", len(a2))
&nbsp;
var slice1 []byte = a1[10:20]
fmt.Printf("Delka rezu 1:    %d\n", len(slice1))
fmt.Printf("Kapacita rezu 1: %d\n", cap(slice1))
&nbsp;
var slice2 = a1[20:30]
fmt.Printf("Delka rezu 2:    %d\n", len(slice2))
fmt.Printf("Kapacita rezu 2: %d\n", cap(slice2))
&nbsp;
slice3 := a1[30:40]
fmt.Printf("Delka rezu 3:    %d\n", len(slice3))
fmt.Printf("Kapacita rezu 3: %d\n", cap(slice3))
</pre>

<p>Podobnou operaci nalezneme i při práci s&nbsp;proudy, ovšem s&nbsp;tím
podstatným rozdílem, že se v&nbsp;případě proudů tato operace musí aplikovat
zavoláním metody <strong>Take</strong>. Je tomu tak z&nbsp;toho důvodu, že
jazyk Go nepodporuje (a pravděpodobně ani nikdy podporovat nebude) přetěžování
operátorů. Samotná hlavička metody <strong>Take</strong> vypadá následovně:</p>

<pre>
func (s Stream) <strong>Take</strong>(firstIndex, lastIndex int) Stream
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že výsledkem volání této
metody je nový proud. To je důležité, neboť nám to umožňuje zřetězení
&bdquo;proudových&ldquo; operací ve stylu, který byl poprvé použit ve
funkcionálních programovacích jazycích a později se rozšířil i do jazyků
mainstreamových.</div></p>

<p>V&nbsp;dalším demonstračním příkladu je ukázáno, jakým způsobem se metoda
<strong>Take</strong> používá. Zajímat nás bude především případ, kdy by měl
být výsledkem prázdný proud:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
func <strong>main</strong>() {
        values := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
        fmt.Printf("input: %v\n", values)
&nbsp;
        stream := koazee.StreamOf(values)
        fmt.Printf("stream:   %v\n", stream.Out().Val())
&nbsp;
        stream2 := stream.Take(3, 6)
        fmt.Printf("stream2:  %v\n", stream2.Out().Val())
&nbsp;
        stream3 := stream.Take(3, 4)
        fmt.Printf("stream3:  %v\n", stream3.Out().Val())
&nbsp;
        stream4 := stream.Take(3, 3)
        fmt.Printf("stream4:  %v\n", stream4.Out().Val())
&nbsp;
        stream5 := stream.Take(4, 3)
        fmt.Printf("stream5:  %v\n", stream5.Out().Val())
&nbsp;
        stream6 := stream.Take(4, 100)
        fmt.Printf("stream6:  %v\n", stream6.Out().Val())
}
</pre>

<p>Po spuštění tohoto demonstračního příkladu získáme tyto řádky:</p>

<pre>
input: [1 2 3 4 5 6 7 8 9 10]
stream:   [1 2 3 4 5 6 7 8 9 10]
stream2:  [4 5 6 7]
stream3:  [4 5]
stream4:  [4]
stream5:  &lt;nil&gt;
stream6:  &lt;nil&gt;
</pre>

<p>První tři výsledky jsou předvídatelné, ovšem zajímavější je další dvojice
řádků. Z&nbsp;ní vyplývá, že prázdný proud vrací hodnotu <strong>nil</strong> a
nikoli například prázdný řez.</p>

<p><div class="rs-tip-major">Poznámka: problémy mohou nastat ve chvíli, kdy
proud obsahuje například ukazatele. Změna hodnoty, na kterou ukazatel směřuje,
se pochopitelně projeví v&nbsp;obou proudech.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Metody pro přidání a ubrání prvku z&nbsp;proudu</h2>

<p>V&nbsp;dalším textu si ve stručnosti popíšeme ty operace, které slouží pro
přidání prvků do proudu, popř.&nbsp;pro jejich odebrání. Ovšem na tomto místě
si musíme uvědomit, že aplikací těchto operací vznikne nový proud, který ovšem
interně může sdílet data s&nbsp;proudem originálním (typicky v&nbsp;případě, že
proud obsahuje ukazatele na prvky umístěné v&nbsp;jiné oblasti operační
paměti). Dále popsané operace tedy původní proud žádným způsobem
nemodifikují.</p>

<table>
<tr><th>#</th><th>Operace</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>Add</td><td>přidání dalšího prvku na konec proudu</td></tr>
<tr><td>2</td><td>Drop</td><td>odebrání určeného prvku</td></tr>
</table>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
func <strong>main</strong>() {
        values := []int{1, 2, 3, 4, 5}
        fmt.Printf("input: %v\n", values)
&nbsp;
        stream1 := koazee.StreamOf(values)
        stream2 := stream1.Add(6)
        stream3 := stream1.Drop(3)
        stream4 := stream1.Drop(10)
&nbsp;
        fmt.Printf("stream1:  %v\n", stream1.Out().Val())
        fmt.Printf("stream2:  %v\n", stream2.Out().Val())
        fmt.Printf("stream3:  %v\n", stream3.Out().Val())
        fmt.Printf("stream4:  %v\n", stream4.Out().Val())
}
</pre>

<p>Výsledek běhu tohoto demonstračního příkladu ukazuje, že vznikly čtyři
proudy &ndash; původní proud, proud s&nbsp;prvkem přidaným na konec, proud
s&nbsp;odebraným prvkem a proud obsahující stejné prvky, jako proud první
(protože jsme se snažili o odebrání neexistujícího prvku):</p>

<pre>
input: [1 2 3 4 5]
stream1:  [1 2 3 4 5]
stream2:  [1 2 3 4 5 6]
stream3:  [1 2 4 5]
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Funkce vyššího řádu a jejich použití při zpracování proudů</h2>

<p>Další skupina operací je velmi důležitá. Jedná se o takzvané <i>funkce
vyššího řádu</i>, tj.&nbsp;o funkce (zde konkrétně metody, to je ovšem
v&nbsp;Go jen syntaktický cukr), které jako své parametry akceptují jiné funkce
popř.&nbsp;dokonce vrací (nové) funkce jako svoji návratovou hodnotu. Mezi dvě
základní funkce vyššího řádu, které nalezneme prakticky ve všech jazycích, jež
tento koncept nějakým způsobem podporují, patří funkce nazvané
<strong>map</strong> a taktéž <strong>filter</strong> a
<strong>reduce</strong>. Funkce <strong>map</strong> postupně aplikuje jí
předanou funkci na jednotlivé prvky nějaké sekvence a vytváří tak sekvenci
novou (modifikovanou). Funkce <strong>filter</strong> slouží pro výběr hodnot
na základě nějakého kritéria a funkce <strong>reduce</strong> pro postupné
zpracování celé sekvence/proudu s&nbsp;akumulací výsledků. A přesně trojici
<strong>Map</strong>, <strong>Filter</strong> a <strong>Reduce</strong>
(v&nbsp;Go ovšem psané s&nbsp;velkými písmeny) najdeme i v&nbsp;knihovně
Koazee:</p> 

<table>
<tr><th>#</th><th>Operace</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>Filter</td><td>výběr prvků z&nbsp;proudu na základě zadaného kritéria</td></tr>
<tr><td>2</td><td>Map</td><td>aplikace nějaké funkce na všechny prvky proudu</td></tr>
<tr><td>3</td><td>Reduce</td><td>zpracování všech prvků proudu s&nbsp;akumulací výsledku</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>ForEach</td><td>zavolání funkce pro každý prvek proudu</td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Výběr prvků na základě zadaného kritéria: metoda <strong>Filter</strong></h2>

<p>Funkce vyššího řádu <strong>Filter</strong> odstraní z&nbsp;proudu ty prvky,
které neodpovídají zadanému kritériu (nebo opačně &ndash; vybere ty prvky,
které kritériu odpovídají). Výsledkem aplikace této funkce na proud bude nový
proud s&nbsp;obecně menším množstvím prvků:</p>

<pre>
func (s Stream) <strong>Filter</strong>(fn interface{}) Stream
</pre>

<p>Ukázka použití této funkce bude jednoduchá &ndash; budeme postupně vybírat
prvky dělitelné dvěma popř.&nbsp;dělitelné třemi:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
func <strong>evenValue</strong>(x int) bool {
        return x%2 == 0
}
&nbsp;
func <strong>divisibleByThree</strong>(x int) bool {
        return x%3 == 0
}
&nbsp;
func <strong>main</strong>() {
        values := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
        fmt.Printf("input: %v\n", values)
&nbsp;
        stream1 := koazee.StreamOf(values)
        stream2 := stream1.<strong>Filter</strong>(evenValue).Do()
        stream3 := stream1.<strong>Filter</strong>(divisibleByThree).Do()
&nbsp;
        fmt.Printf("stream1:  %v\n", stream1.Out().Val())
        fmt.Printf("stream2:  %v\n", stream2.Out().Val())
        fmt.Printf("stream3:  %v\n", stream3.Out().Val())
}
</pre>

<p>Výsledky:</p>

<pre>
input: [1 2 3 4 5 6 7 8 9 10]
stream1:  [1 2 3 4 5 6 7 8 9 10]
stream2:  [2 4 6 8 10]
stream3:  [3 6 9]
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si použití metody
<strong>Do</strong>, která zajistí vyhodnocení, prvků, protože jinak by
k&nbsp;vyhodnocení kvůli &bdquo;lenosti&ldquo; operací nedošlo.</div></p>

<p>Nic nám ovšem nebrání použít anonymní funkce, což je častější řešení:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
func <strong>main</strong>() {
        values := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
        fmt.Printf("input: %v\n", values)
&nbsp;
        stream1 := koazee.StreamOf(values)
        stream2 := stream1.Filter(func(x int) bool { return x%2 == 0 }).Do()
        stream3 := stream1.Filter(func(x int) bool { return x%3 == 0 }).Do()
&nbsp;
        fmt.Printf("stream1:  %v\n", stream1.Out().Val())
        fmt.Printf("stream2:  %v\n", stream2.Out().Val())
        fmt.Printf("stream3:  %v\n", stream3.Out().Val())
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Aplikace funkce na každý prvek proudu: metoda <strong>Map</strong></h2>

<p>Pravděpodobně nejdůležitější a současně i velmi snadno pochopitelnou metodou
určenou pro zpracování proudů &bdquo;funkcionálním&ldquo; způsobem je metoda
nazvaná <strong>Map</strong>. Tato metoda zpracovává všechny prvky vstupního
proudu a vytváří výsledný proud. Důležité je, že původní proud zůstane
nezměněn. Metoda <strong>Map</strong> při konstrukci výsledného proudu zavolá
pro každý prvek vstupního proudu uživatelem specifikovanou funkci, jejíž
návratový kód následně použije. Metoda <strong>Map</strong> tedy potřebuje dva
údaje: vstupní proud (příjemce metody) a funkci, kterou má na jednotlivé prvky
této kolekce aplikovat. Tato funkce může být anonymní či neanonymní
(pojmenovaná):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
func <strong>doubleValue</strong>(x int) int {
        return x * 2
}
&nbsp;
func <strong>negate</strong>(x int) int {
        return -x
}
&nbsp;
func <strong>main</strong>() {
        values := []int{1, 2, 3, 4, 5}
        fmt.Printf("input: %v\n", values)
&nbsp;
        stream1 := koazee.StreamOf(values)
        stream2 := stream1.Map(doubleValue).Do()
        stream3 := stream1.Map(doubleValue).Map(negate).Do()
&nbsp;
        fmt.Printf("stream1:  %v\n", stream1.Out().Val())
        fmt.Printf("stream2:  %v\n", stream2.Out().Val())
        fmt.Printf("stream3:  %v\n", stream3.Out().Val())
}
</pre>

<p>Výsledek běhu tohoto příkladu:</p>

<pre>
input: [1 2 3 4 5]
stream1:  [1 2 3 4 5]
stream2:  [2 4 6 8 10]
stream3:  [-2 -4 -6 -8 -10]
</pre>

<p>Pochopitelně i zde můžeme použít anonymní funkce:</p>

<pre>
package <strong>mai</strong>n
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
func <strong>main</strong>() {
        values := []int{1, 2, 3, 4, 5}
        fmt.Printf("input: %v\n", values)
&nbsp;
        stream1 := koazee.StreamOf(values)
        stream2 := stream1.Map(func(x int) int { return x * 2 }).Do()
        stream3 := stream1.Map(func(x int) int { return x * 2 }).Map(func(x int) int { return -x }).Do()
&nbsp;
        fmt.Printf("stream1:  %v\n", stream1.Out().Val())
        fmt.Printf("stream2:  %v\n", stream2.Out().Val())
        fmt.Printf("stream3:  %v\n", stream3.Out().Val())
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Zavolání specifikované callback funkce pro každý prvek proudu: metoda <strong>ForEach</strong></h2>

<p>V&nbsp;případě, že budeme potřebovat pro každý prvek proudu zavolat určitou
funkci (pro výpis atd.), která ovšem nebude použita pro vytvoření proudu
nového, použijeme namísto metody <strong>Map</strong> spíše metodu nazvanou
<strong>ForEach</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
func <strong>printInt</strong>(x int) {
        fmt.Printf("%d\t", x)
}
&nbsp;
func <strong>main</strong>() {
        values1 := []int{1, 2, 3, 4, 5}
        fmt.Printf("input #1: %v\n", values1)
&nbsp;
        stream1 := koazee.StreamOf(values1)
        stream1.ForEach(printInt)
&nbsp;
        fmt.Println()
&nbsp;
        values2 := []int{1, 2, 3, 4, 5}
        fmt.Printf("input #2: %v\n", values2)
&nbsp;
        stream2 := koazee.StreamOf(values2)
        stream2.ForEach(printInt).Do()
}
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
input #1: [1 2 3 4 5]
&nbsp;
input #2: [1 2 3 4 5]
1       2       3       4       5
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že v&nbsp;prvním případě
jsme explicitně nezavolali metodu <strong>Do</strong>, takže se
&bdquo;líný&ldquo; proud nevyhodnotil. To přesně odpovídá očekávanému chování
líných datových struktur, ovšem v&nbsp;případě <strong>ForEach</strong> nás to
může překvapit.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Seřazení prvků na základě jejich porovnání: metoda <strong>Sort</strong></h2>

<p>Další užitečnou metodou, kterou v&nbsp;knihovně Koazee nalezneme, je metoda
nazvaná <strong>Sort</strong>. Ta pochopitelně slouží k&nbsp;seřazení prvků
proudu, a to na základě výsledků funkce, která se volá pro dvojici prvků.
Rozhoduje znaménko výsledku &ndash; záporná hodnota značí relaci &bdquo;je
menší&ldquo;, kladná hodnota &bdquo;je větší&ldquo;, nula pak
&bdquo;rovnost&ldquo;. Ukažme si tedy seřazení proudu s&nbsp;celými čísly
vzestupně a posléze sestupně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
func <strong>compare</strong>1(x, y int) int {
        return x - y
}
&nbsp;
func <strong>compare</strong>2(x, y int) int {
        return y - x
}
&nbsp;
func <strong>main</strong>() {
        values := []int{100, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -1}
        fmt.Printf("input: %v\n", values)
&nbsp;
        stream1 := koazee.StreamOf(values)
        fmt.Printf("stream1:  %v\n", stream1.Out().Val())
&nbsp;
        stream1.Sort(compare1).Do()
        fmt.Printf("stream1:  %v\n", stream1.Out().Val())
&nbsp;
        stream1.Sort(compare2).Do()
        fmt.Printf("stream1:  %v\n", stream1.Out().Val())
}
</pre>

<p>Výsledky:</p>

<pre>
input: [100 1 2 3 4 5 6 7 8 9 10 -1]
stream1:  [100 1 2 3 4 5 6 7 8 9 10 -1]
stream1:  [-1 1 2 3 4 5 6 7 8 9 10 100]
stream1:  [100 10 9 8 7 6 5 4 3 2 1 -1]
</pre>

<p><div class="rs-tip-major">Poznámka: ze zdrojového kódu je patrné, že tato
metoda ve skutečnosti seřazuje prvky v&nbsp;původním proudu, na rozdíl od
ostatních zde popisovaných funkcí.</div></p>

<p>Opět je možné použít anonymní funkce zkracující zápis:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
func <strong>main</strong>() {
        values := []int{100, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -1}
        fmt.Printf("input: %v\n", values)
&nbsp;
        stream1 := koazee.StreamOf(values)
        fmt.Printf("stream1:  %v\n", stream1.Out().Val())
&nbsp;
        stream1.Sort(func(x, y int) int { return x - y }).Do()
        fmt.Printf("stream1:  %v\n", stream1.Out().Val())
&nbsp;
        stream1.Sort(func(x, y int) int { return y - x }).Do()
        fmt.Printf("stream1:  %v\n", stream1.Out().Val())
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Kombinace více operací na proud: <strong>Filter</strong>&rarr;<strong>Map</strong>&rarr;<strong>ForEach</strong></h2>

<p>Vzhledem k&nbsp;tomu, že metody <strong>Filter</strong> a
<strong>Map</strong> vrací jako svůj výsledek nový proud, je snadné takové
operace zřetězit, což se v&nbsp;jiných programovacích jazycích pomalu stává
standardem (ovšem s&nbsp;několika komplikacemi, které se týkají ladění).
Podívejme se na typický příklad zřetězení:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
func <strong>printInt</strong>(x int) {
        fmt.Printf("%d\n", x)
}
&nbsp;
func <strong>doubleValue</strong>(x int) int {
        return x * 2
}
&nbsp;
func <strong>negate</strong>(x int) int {
        return -x
}
&nbsp;
func <strong>evenValue</strong>(x int) bool {
        return x%2 == 0
}
&nbsp;
func <strong>divisibleBy</strong>3(x int) bool {
        return x%3 == 0
}
&nbsp;
func <strong>main</strong>() {
        values1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
        fmt.Printf("input #1: %v\n", values1)
&nbsp;
        stream1 := koazee.StreamOf(values1).
                Filter(evenValue).
                Filter(divisibleBy3).
                Map(negate).
                Map(doubleValue)
        stream1.ForEach(printInt).Do()
}
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
input #1: [1 2 3 4 5 6 7 8 9 10 11 12]
-12
-24
</pre>

<p>Musíme si však dát pozor na to, aby v&nbsp;průběhu zřetězení nedošlo ke
vzniku prázdného proudu, protože ten je (což IMHO není dobře) reprezentován
hodnotou <strong>nil</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
func <strong>printInt</strong>(x int) {
        fmt.Printf("%d\n", x)
}
&nbsp;
func <strong>doubleValue</strong>(x int) int {
        return x * 2
}
&nbsp;
func <strong>negate</strong>(x int) int {
        return -x
}
&nbsp;
func <strong>evenValue</strong>(x int) bool {
        return x%2 == 0
}
&nbsp;
func <strong>divisibleBy</strong>3(x int) bool {
        return x%3 == 0
}
&nbsp;
func <strong>main</strong>() {
        values1 := []int{1, 2, 3}
        fmt.Printf("input #1: %v\n", values1)
&nbsp;
        stream1 := koazee.StreamOf(values1).
                Filter(evenValue).
                Filter(divisibleBy3).
                Map(negate).
                Map(doubleValue)
        stream1.ForEach(printInt).Do()
}
</pre>

<p>Tento příklad po svém spuštění zhavaruje, protože dvojí filtrace vrátí
<strong>nil</strong>:</p>

<pre>
input #1: [1 2 3]
panic: reflect: slice index out of range

goroutine 1 [running]:
reflect.Value.Index(0x652d60, 0xc00000a100, 0x97, 0x0, 0x655e80, 0x182, 0xc00000a100)
        /opt/go/src/reflect/value.go:924 +0x20a
github.com/wesovilabs/koazee/internal/maps.(*Map).validate(0xc000045528, 0x1, 0x0)
        /home/tester/go/src/github.com/wesovilabs/koazee/internal/maps/map.go:91 +0x58b
github.com/wesovilabs/koazee/internal/maps.(*Map).Run(0xc000045528, 0xc000014118, 0xc000014118, 0x652d60, 0xc00000a100)
        /home/tester/go/src/github.com/wesovilabs/koazee/internal/maps/map.go:21 +0x66
github.com/wesovilabs/koazee/stream.(*streamMap).run(0xc00000e210, 0x652d60, 0xc00000a100, 0x652d60, 0xc00000a100, 0x97, 0x6ed880, 0x655e80, 0x0, 0x0, ...)
        /home/tester/go/src/github.com/wesovilabs/koazee/stream/map.go:13 +0xf8
github.com/wesovilabs/koazee/stream.Stream.run(0x652d60, 0xc00000a100, 0x652d60, 0xc00000a100, 0x97, 0x6ed880, 0x655e80, 0x0, 0x0, 0xc00009e020, ...)
        /home/tester/go/src/github.com/wesovilabs/koazee/stream/stream.go:162 +0x9c
github.com/wesovilabs/koazee/stream.Stream.run(0x652d60, 0xc00000a100, 0x652d60, 0xc00000a100, 0x97, 0x6ed880, 0x655e80, 0x0, 0x0, 0xc00009e020, ...)
        /home/tester/go/src/github.com/wesovilabs/koazee/stream/stream.go:167 +0x140
github.com/wesovilabs/koazee/stream.Stream.run(0x652d60, 0xc00000a0e0, 0x652d60, 0xc00000a0e0, 0x97, 0x6ed880, 0x655e80, 0x1, 0x0, 0xc00009e010, ...)
        /home/tester/go/src/github.com/wesovilabs/koazee/stream/stream.go:167 +0x140
github.com/wesovilabs/koazee/stream.Stream.Do(0x652d60, 0xc00000a0a0, 0x652d60, 0xc00000a0a0, 0x97, 0x6ed880, 0x655e80, 0x3, 0x0, 0xc00009e000, ...)
        /home/tester/go/src/github.com/wesovilabs/koazee/stream/do.go:5 +0x77
main.main()
        /home/tester/go-root/article_28/19_combinations_error.go:37 +0x668
exit status 2
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Použití metody <strong>Reduce</strong> pro zpracování všech prvků proudu</h2>

<p>Posledními dvěma funkcemi vyššího řádu, které nesmějí chybět
v&nbsp;repertoáru žádné funkcionálně zaměřené knihovny, je dvojice funkcí
pojmenovaná <strong>reduce</strong> a <strong>reduceRight</strong> (někdy se
setkáme s&nbsp;názvy <strong>foldl</strong> a <strong>foldr</strong> atd.).
Názvy těchto funkcí naznačují jejich účel &ndash; dochází k&nbsp;postupné
redukci prvků uložených v&nbsp;kolekci či v&nbsp;poli, a to (postupnou)
aplikací zvolené uživatelské funkce na jednotlivé prvky a po krocích počítaný
mezivýsledek. Mezi <strong>reduce</strong> a <strong>reduceRight</strong> je
rozdíl v&nbsp;tom, ze které strany původní kolekce dochází ke kýžené
redukci.</p>

<p>V&nbsp;knihovně Koazee nalezneme jen metodu <strong>Reduce</strong>:</p>

<pre>
func (s Stream) <strong>Reduce</strong>(fn interface{}) Output
</pre>

<p>Akumulátor je na začátku naplněn na <i>nulovou hodnotu</i> daného datového
typu (a toto chování se nedá změnit). V&nbsp;dalším příkladu je vypočten součet
všech prvků v&nbsp;proudu pomocí funkce <strong>add</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
func <strong>add</strong>(x, y int) int {
        return x + y
}
&nbsp;
func <strong>main</strong>() {
        values1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
        fmt.Printf("input #1: %v\n", values1)
&nbsp;
        sum := koazee.StreamOf(values1).Reduce(add)
        fmt.Printf("sum: %d\n", sum.Val())
}
</pre>

<p>Výsledky:</p>

<pre>
input #1: [1 2 3 4 5 6 7 8 9 10]
sum: 55
</pre>

<p>Alternativa s&nbsp;anonymní funkcí:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
func <strong>main() {</strong>
        values1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
        fmt.Printf("input #1: %v\n", values1)
&nbsp;
        sum := koazee.StreamOf(values1).Reduce(func(x, y int) int { return x + y })
        fmt.Printf("sum: %d\n", sum.Val())
}
</pre>

<p>V&nbsp;dnešním posledním příkladu se postupně vypočítá maximální hodnota
v&nbsp;proudu celých kladných čísel. Pro zajímavost funkce <strong>max</strong>
vypisuje i své parametry:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/wesovilabs/koazee"
)
&nbsp;
func <strong>max</strong>(x, y int) int {
        fmt.Printf("%d %d\n", x, y)
        if x &gt; y {
                return x
        } else {
                return y
        }
}
&nbsp;
func <strong>main</strong>() {
        values1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
        fmt.Printf("input #1: %v\n", values1)
&nbsp;
        maxVal := koazee.StreamOf(values1).Reduce(max)
        fmt.Printf("max value: %d\n", maxVal.Int())
}
</pre>

<p>Výsledky:</p>

<pre>
input #1: [1 2 3 4 5 6 7 8 9 10]
0 1
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
max value: 10
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně dva megabajty), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_new_stream.go</td><td>vytvoření nového proudu konstruktorem <strong>New</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/01_new_stream.go">https://github.com/tisnik/go-root/blob/master/article_28/01_new_stream.go</a></td></tr>
<tr><td> 2</td><td>02_to_stream.go</td><td>vytvoření nového proudu funkcí <strong>StreamOf</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/02_to_stream.go">https://github.com/tisnik/go-root/blob/master/article_28/02_to_stream.go</a></td></tr>
<tr><td> 3</td><td>03_user_structs_to_stream.go</td><td>proud a uživatelské datové typy</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/03_user_structs_to_stream.go">https://github.com/tisnik/go-root/blob/master/article_28/03_user_structs_to_stream.go</a></td></tr>
<tr><td> 4</td><td>04_from_array.go</td><td>vytvoření nového proudu z&nbsp;pole</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/04_from_array.go">https://github.com/tisnik/go-root/blob/master/article_28/04_from_array.go</a></td></tr>
<tr><td> 5</td><td>05_new_stream_from_array.go</td><td>vytvoření nového proudu z&nbsp;pole</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/05_new_stream_from_array.go">https://github.com/tisnik/go-root/blob/master/article_28/05_new_stream_from_array.go</a></td></tr>
<tr><td> 6</td><td>06_basic_attributes.go</td><td>základní atributy proudu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/06_basic_attributes.go">https://github.com/tisnik/go-root/blob/master/article_28/06_basic_attributes.go</a></td></tr>
<tr><td> 7</td><td>07_contains.go</td><td>metoda <strong>Contains</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/07_contains.go">https://github.com/tisnik/go-root/blob/master/article_28/07_contains.go</a></td></tr>
<tr><td> 8</td><td>08_index_of.go</td><td>metody <strong>IndexOf</strong> a <strong>LastIndexOf</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/08_index_of.go">https://github.com/tisnik/go-root/blob/master/article_28/08_index_of.go</a></td></tr>
<tr><td> 9</td><td>09_contains_user_structs.go</td><td>metoda <strong>Contains</strong> a uživatelské datové typy</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/09_contains_user_structs.go">https://github.com/tisnik/go-root/blob/master/article_28/09_contains_user_structs.go</a></td></tr>
<tr><td>10</td><td>10_index_of_user_struct.go</td><td>metoda <strong>IndexOf</strong> a uživatelské datové typy</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/10_index_of_user_struct.go">https://github.com/tisnik/go-root/blob/master/article_28/10_index_of_user_struct.go</a></td></tr>
<tr><td>11</td><td>11_take.go</td><td>získání nového proudu metodou <strong>Take</strong><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/11_take.go">https://github.com/tisnik/go-root/blob/master/article_28/11_take.go</a></td></tr>
<tr><td>12</td><td>12_add_drop.go</td><td>metody <strong>Add</strong> a <strong>Drop</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/12_add_drop.go">https://github.com/tisnik/go-root/blob/master/article_28/12_add_drop.go</a></td></tr>
<tr><td>13</td><td>13_filter.go</td><td>filtrace prvků metodou <strong>Filter</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/13_filter.go">https://github.com/tisnik/go-root/blob/master/article_28/13_filter.go</a></td></tr>
<tr><td>14</td><td>14_map.go</td><td>aplikace funkce na všechny prvky metodou <strong>Map</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/14_map.go">https://github.com/tisnik/go-root/blob/master/article_28/14_map.go</a></td></tr>
<tr><td>15</td><td>15_for_each.go</td><td>zavolání funkce na všechny prvky metodou <strong>Map</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/15_for_each.go">https://github.com/tisnik/go-root/blob/master/article_28/15_for_each.go</a></td></tr>
<tr><td>16</td><td>16_sort.go</td><td>seřazení prvků proudu metodou <strong>Sort</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/16_sort.go">https://github.com/tisnik/go-root/blob/master/article_28/16_sort.go</a></td></tr>
<tr><td>17</td><td>17_reverse.go</td><td>otočení prvků proudu metodou <strong>Sort</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/17_reverse.go">https://github.com/tisnik/go-root/blob/master/article_28/17_reverse.go</a></td></tr>
<tr><td>18</td><td>18_combinations.go</td><td>kombinace &bdquo;proudových&ldquo; operací v&nbsp;pipeline</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/18_combinations.go">https://github.com/tisnik/go-root/blob/master/article_28/18_combinations.go</a></td></tr>
<tr><td>19</td><td>19_combinations_error.go</td><td>kombinace &bdquo;proudových&ldquo; operací v&nbsp;pipeline</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/19_combinations_error.go">https://github.com/tisnik/go-root/blob/master/article_28/19_combinations_error.go</a></td></tr>
<tr><td>20</td><td>20_reduce.go</td><td>součet všech prvků proudu metodou <strong>Reduce</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/20_reduce.go">https://github.com/tisnik/go-root/blob/master/article_28/20_reduce.go</a></td></tr>
<tr><td>21</td><td>21_max_value.go</td><td>získání maximální hodnoty v&nbsp;proudu metodou <strong>Reduce</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_28/21_max_value.go">https://github.com/tisnik/go-root/blob/master/article_28/21_max_value.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>A StreamLike, Immutable, Lazy Loading and smart Golang Library to deal with slices<br />
<a href="https://github.com/wesovilabs/koazee">https://github.com/wesovilabs/koazee</a>
</li>

<li>Funkce vyššího řádu v knihovně Underscore<br />
<a href="https://www.root.cz/clanky/funkce-vyssiho-radu-v-knihovne-underscore/">https://www.root.cz/clanky/funkce-vyssiho-radu-v-knihovne-underscore/</a>
</li>

<li>Delve: a debugger for the Go programming language.<br />
<a href="https://github.com/go-delve/delve">https://github.com/go-delve/delve</a>
</li>

<li>Příkazy debuggeru Delve<br />
<a href="https://github.com/go-delve/delve/tree/master/Documentation/cli">https://github.com/go-delve/delve/tree/master/Documentation/cli</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (2. část)<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v&nbsp;editorech Emacs a Vim<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Debugging Go Code with GDB<br />
<a href="https://golang.org/doc/gdb">https://golang.org/doc/gdb</a>
</li>

<li>Debugging Go (golang) programs with gdb <br />
<a href="https://thornydev.blogspot.com/2014/01/debugging-go-golang-programs-with-gdb.html">https://thornydev.blogspot.com/2014/01/debugging-go-golang-programs-with-gdb.html</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>GDB - Supported Languages<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>13 Linux Debuggers for C++ Reviewed<br />
<a href="http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817">http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817</a>
</li>

<li>Go is on a Trajectory to Become the Next Enterprise Programming Language<br />
<a href="https://hackernoon.com/go-is-on-a-trajectory-to-become-the-next-enterprise-programming-language-3b75d70544e">https://hackernoon.com/go-is-on-a-trajectory-to-become-the-next-enterprise-programming-language-3b75d70544e</a>
</li>

<li>Go Proverbs: Simple, Poetic, Pithy<br />
<a href="https://go-proverbs.github.io/">https://go-proverbs.github.io/</a>
</li>

<li>Handling Sparse Files on Linux<br />
<a href="https://www.systutorials.com/136652/handling-sparse-files-on-linux/">https://www.systutorials.com/136652/handling-sparse-files-on-linux/</a>
</li>

<li>Gzip (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Gzip">https://en.wikipedia.org/wiki/Gzip</a>
</li>

<li>Deflate<br />
<a href="https://en.wikipedia.org/wiki/DEFLATE">https://en.wikipedia.org/wiki/DEFLATE</a>
</li>

<li>10 tools written in Go that every developer needs to know<br />
<a href="https://gustavohenrique.net/en/2019/01/10-tools-written-in-go-that-every-dev-needs-to-know/">https://gustavohenrique.net/en/2019/01/10-tools-written-in-go-that-every-dev-needs-to-know/</a>
</li>

<li>Hexadecimální prohlížeče a editory s textovým uživatelským rozhraním<br />
<a href="https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/">https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/</a>
</li>

<li>Hex dump<br />
<a href="https://en.wikipedia.org/wiki/Hex_dump">https://en.wikipedia.org/wiki/Hex_dump</a>
</li>

<li>Rozhraní io.ByteReader<br />
<a href="https://golang.org/pkg/io/#ByteReader">https://golang.org/pkg/io/#ByteReader</a>
</li>

<li>Rozhraní io.RuneReader<br />
<a href="https://golang.org/pkg/io/#RuneReader">https://golang.org/pkg/io/#RuneReader</a>
</li>

<li>Rozhraní io.ByteScanner<br />
<a href="https://golang.org/pkg/io/#ByteScanner">https://golang.org/pkg/io/#ByteScanner</a>
</li>

<li>Rozhraní io.RuneScanner<br />
<a href="https://golang.org/pkg/io/#RuneScanner">https://golang.org/pkg/io/#RuneScanner</a>
</li>

<li>Rozhraní io.Closer<br />
<a href="https://golang.org/pkg/io/#Closer">https://golang.org/pkg/io/#Closer</a>
</li>

<li>Rozhraní io.Reader<br />
<a href="https://golang.org/pkg/io/#Reader">https://golang.org/pkg/io/#Reader</a>
</li>

<li>Rozhraní io.Writer<br />
<a href="https://golang.org/pkg/io/#Writer">https://golang.org/pkg/io/#Writer</a>
</li>

<li>Typ Strings.Reader<br />
<a href="https://golang.org/pkg/strings/#Reader">https://golang.org/pkg/strings/#Reader</a>
</li>

<li>VACUUM (SQL)<br />
<a href="https://www.sqlite.org/lang_vacuum.html">https://www.sqlite.org/lang_vacuum.html</a>
</li>

<li>VACUUM (Postgres)<br />
<a href="https://www.postgresql.org/docs/8.4/sql-vacuum.html">https://www.postgresql.org/docs/8.4/sql-vacuum.html</a>
</li>

<li>go-cron<br />
<a href="https://github.com/rk/go-cron">https://github.com/rk/go-cron</a>
</li>

<li>gocron<br />
<a href="https://github.com/jasonlvhit/gocron">https://github.com/jasonlvhit/gocron</a>
</li>

<li>clockwork<br />
<a href="https://github.com/whiteShtef/clockwork">https://github.com/whiteShtef/clockwork</a>
</li>

<li>clockwerk<br />
<a href="https://github.com/onatm/clockwerk">https://github.com/onatm/clockwerk</a>
</li>

<li>JobRunner<br />
<a href="https://github.com/bamzi/jobrunner">https://github.com/bamzi/jobrunner</a>
</li>

<li>Rethinking Cron<br />
<a href="https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/">https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/</a>
</li>

<li>In the Beginning was the Command Line<br />
<a href="https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html">https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html</a>
</li>

<li>repl.it (REPL pro různé jazyky)<br />
<a href="https://repl.it/languages">https://repl.it/languages</a>
</li>

<li>GOCUI - Go Console User Interface (celé uživatelské prostředí, nejenom input box)<br />
<a href="https://github.com/jroimartin/gocui">https://github.com/jroimartin/gocui</a>
</li>

<li>Read–eval–print loop<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>go-prompt<br />
<a href="https://github.com/c-bata/go-prompt">https://github.com/c-bata/go-prompt</a>
</li>

<li>readline<br />
<a href="https://github.com/chzyer/readline">https://github.com/chzyer/readline</a>
</li>

<li>A pure golang implementation for GNU-Readline kind library<br />
<a href="https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/">https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/</a>
</li>

<li>go-readline<br />
<a href="https://github.com/fiorix/go-readline">https://github.com/fiorix/go-readline</a>
</li>

<li>4 Python libraries for building great command-line user interfaces<br />
<a href="https://opensource.com/article/17/5/4-practical-python-libraries">https://opensource.com/article/17/5/4-practical-python-libraries</a>
</li>

<li>prompt_toolkit 2.0.3 na PyPi<br />
<a href="https://pypi.org/project/prompt_toolkit/">https://pypi.org/project/prompt_toolkit/</a>
</li>

<li>python-prompt-toolkit na GitHubu<br />
<a href="https://github.com/jonathanslenders/python-prompt-toolkit">https://github.com/jonathanslenders/python-prompt-toolkit</a>
</li>

<li>The GNU Readline Library<br />
<a href="https://tiswww.case.edu/php/chet/readline/rltop.html">https://tiswww.case.edu/php/chet/readline/rltop.html</a>
</li>

<li>GNU Readline (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Readline">https://en.wikipedia.org/wiki/GNU_Readline</a>
</li>

<li>readline — GNU readline interface (Python 3.x)<br />
<a href="https://docs.python.org/3/library/readline.html">https://docs.python.org/3/library/readline.html</a>
</li>

<li>readline — GNU readline interface (Python 2.x)<br />
<a href="https://docs.python.org/2/library/readline.html">https://docs.python.org/2/library/readline.html</a>
</li>

<li>GNU Readline Library - command line editing<br />
<a href="https://tiswww.cwru.edu/php/chet/readline/readline.html">https://tiswww.cwru.edu/php/chet/readline/readline.html</a>
</li>

<li>gnureadline 6.3.8 na PyPi<br />
<a href="https://pypi.org/project/gnureadline/">https://pypi.org/project/gnureadline/</a>
</li>

<li>Editline Library (libedit)<br />
<a href="http://thrysoee.dk/editline/">http://thrysoee.dk/editline/</a>
</li>

<li>Comparing Python Command-Line Parsing Libraries – Argparse, Docopt, and Click<br />
<a href="https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/">https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/</a>
</li>

<li>libedit or editline<br />
<a href="http://www.cs.utah.edu/~bigler/code/libedit.html">http://www.cs.utah.edu/~bigler/code/libedit.html</a>
</li>

<li>WinEditLine<br />
<a href="http://mingweditline.sourceforge.net/">http://mingweditline.sourceforge.net/</a>
</li>

<li>rlcompleter — Completion function for GNU readline<br />
<a href="https://docs.python.org/3/library/rlcompleter.html">https://docs.python.org/3/library/rlcompleter.html</a>
</li>

<li>rlwrap na GitHubu<br />
<a href="https://github.com/hanslub42/rlwrap">https://github.com/hanslub42/rlwrap</a>
</li>

<li>rlwrap(1) - Linux man page<br />
<a href="https://linux.die.net/man/1/rlwrap">https://linux.die.net/man/1/rlwrap</a>
</li>

<li>readline(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/readline">https://linux.die.net/man/3/readline</a>
</li>

<li>history(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/history">https://linux.die.net/man/3/history</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>oglematchers</i><br />
<a href="https://godoc.org/github.com/jacobsa/oglematchers">https://godoc.org/github.com/jacobsa/oglematchers</a>
</li>

<li>Balíček <i>oglematchers</i><br />
<a href="https://github.com/jacobsa/oglematchers">https://github.com/jacobsa/oglematchers</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>ogletest</i><br />
<a href="https://godoc.org/github.com/jacobsa/ogletest">https://godoc.org/github.com/jacobsa/ogletest</a>
</li>

<li>Balíček <i>ogletest</i><br />
<a href="https://github.com/jacobsa/ogletest">https://github.com/jacobsa/ogletest</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>assert</i><br />
<a href="https://godoc.org/github.com/stretchr/testify/assert">https://godoc.org/github.com/stretchr/testify/assert</a>
</li>

<li>Testify - Thou Shalt Write Tests<br />
<a href="https://github.com/stretchr/testify/">https://github.com/stretchr/testify/</a>
</li>

<li>package testing<br />
<a href="https://golang.org/pkg/testing/">https://golang.org/pkg/testing/</a>
</li>

<li>Golang basics - writing unit tests<br />
<a href="https://blog.alexellis.io/golang-writing-unit-tests/">https://blog.alexellis.io/golang-writing-unit-tests/</a>
</li>

<li>An Introduction to Programming in Go / Testing<br />
<a href="https://www.golang-book.com/books/intro/12">https://www.golang-book.com/books/intro/12</a>
</li>

<li>An Introduction to Testing in Go<br />
<a href="https://tutorialedge.net/golang/intro-testing-in-go/">https://tutorialedge.net/golang/intro-testing-in-go/</a>
</li>

<li>Advanced Go Testing Tutorial<br />
<a href="https://tutorialedge.net/golang/advanced-go-testing-tutorial/">https://tutorialedge.net/golang/advanced-go-testing-tutorial/</a>
</li>

<li>GoConvey<br />
<a href="http://goconvey.co/">http://goconvey.co/</a>
</li>

<li>Testing Techniques<br />
<a href="https://talks.golang.org/2014/testing.slide">https://talks.golang.org/2014/testing.slide</a>
</li>

<li>5 simple tips and tricks for writing unit tests in #golang<br />
<a href="https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742">https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742</a>
</li>

<li>Afinní transformace<br />
<a href="https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic">https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic</a>
</li>

<li>package gg<br />
<a href="https://godoc.org/github.com/fogleman/gg">https://godoc.org/github.com/fogleman/gg</a>
</li>

<li>Generate an animated GIF with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/">http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/</a>
</li>

<li>Generate an image programmatically with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/">http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/</a>
</li>

<li>The Go image package<br />
<a href="https://blog.golang.org/go-image-package">https://blog.golang.org/go-image-package</a>
</li>

<li>Balíček draw2D: 2D rendering for different output (raster, pdf, svg)<br />
<a href="https://github.com/llgcode/draw2d">https://github.com/llgcode/draw2d</a>
</li>

<li>Draw a rectangle in Golang?<br />
<a href="https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang">https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang</a>
</li>

<li>YAML<br />
<a href="https://yaml.org/">https://yaml.org/</a>
</li>

<li>edn<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Smile<br />
<a href="https://github.com/FasterXML/smile-format-specification">https://github.com/FasterXML/smile-format-specification</a>
</li>

<li>Protocol-Buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>Marshalling (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
</li>

<li>Unmarshalling<br />
<a href="https://en.wikipedia.org/wiki/Unmarshalling">https://en.wikipedia.org/wiki/Unmarshalling</a>
</li>

<li>Introducing JSON<br />
<a href="http://json.org/">http://json.org/</a>
</li>

<li>Package json<br />
<a href="https://golang.org/pkg/encoding/json/">https://golang.org/pkg/encoding/json/</a>
</li>

<li>The Go Blog: JSON and Go<br />
<a href="https://blog.golang.org/json-and-go">https://blog.golang.org/json-and-go</a>
</li>

<li>Go by Example: JSON<br />
<a href="https://gobyexample.com/json">https://gobyexample.com/json</a>
</li>

<li>Writing Web Applications<br />
<a href="https://golang.org/doc/articles/wiki/">https://golang.org/doc/articles/wiki/</a>
</li>

<li>Golang Web Apps<br />
<a href="https://www.reinbach.com/blog/golang-webapps-1/">https://www.reinbach.com/blog/golang-webapps-1/</a>
</li>

<li>Build web application with Golang<br />
<a href="https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details">https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details</a>
</li>

<li>Golang Templates - Golang Web Pages<br />
<a href="https://www.youtube.com/watch?v=TkNIETmF-RU">https://www.youtube.com/watch?v=TkNIETmF-RU</a>
</li>

<li>Simple Golang HTTPS/TLS Examples<br />
<a href="https://github.com/denji/golang-tls">https://github.com/denji/golang-tls</a>
</li>

<li>Playing with images in HTTP response in golang<br />
<a href="https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang">https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang</a>
</li>

<li>MIME Types List<br />
<a href="https://www.freeformatter.com/mime-types-list.html">https://www.freeformatter.com/mime-types-list.html</a>
</li>

<li>Go Mutex Tutorial<br />
<a href="https://tutorialedge.net/golang/go-mutex-tutorial/">https://tutorialedge.net/golang/go-mutex-tutorial/</a>
</li>

<li>Creating A Simple Web Server With Golang<br />
<a href="https://tutorialedge.net/golang/creating-simple-web-server-with-golang/">https://tutorialedge.net/golang/creating-simple-web-server-with-golang/</a>
</li>

<li>Building a Web Server in Go<br />
<a href="https://thenewstack.io/building-a-web-server-in-go/">https://thenewstack.io/building-a-web-server-in-go/</a>
</li>

<li>How big is the pipe buffer?<br />
<a href="https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer">https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer</a>
</li>

<li>How to turn off buffering of stdout in C<br />
<a href="https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c">https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c</a>
</li>

<li>setbuf(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/setbuf">https://linux.die.net/man/3/setbuf</a>
</li>

<li>setvbuf(3) - Linux man page (stejný obsah jako předchozí stránka)<br />
<a href="https://linux.die.net/man/3/setvbuf">https://linux.die.net/man/3/setvbuf</a>
</li>

<li>Select waits on a group of channels<br />
<a href="https://yourbasic.org/golang/select-explained/">https://yourbasic.org/golang/select-explained/</a>
</li>

<li>Rob Pike: Simplicity is Complicated (video)<br />
<a href="http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893">http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893</a>
</li>

<li>Algorithms to Go<br />
<a href="https://yourbasic.org/">https://yourbasic.org/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů: vlastní filtry a lexery<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/</a>
</li>

<li>Go Defer Simplified with Practical Visuals<br />
<a href="https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff">https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff</a>
</li>

<li>5 More Gotchas of Defer in Go — Part II<br />
<a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa">https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa</a>
</li>

<li>The Go Blog: Defer, Panic, and Recover<br />
<a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a>
</li>

<li>The defer keyword in Swift 2: try/finally done right<br />
<a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer">https://www.hackingwithswift.com/new-syntax-swift-2-defer</a>
</li>

<li>Swift Defer Statement<br />
<a href="https://andybargh.com/swift-defer-statement/">https://andybargh.com/swift-defer-statement/</a>
</li>

<li>Modulo operation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Modulo_operation">https://en.wikipedia.org/wiki/Modulo_operation</a>
</li>

<li>Node.js vs Golang: Battle of the Next-Gen Languages<br />
<a href="https://www.hostingadvice.com/blog/nodejs-vs-golang/">https://www.hostingadvice.com/blog/nodejs-vs-golang/</a>
</li>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go<br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>JavaScript vs. Golang for IoT: Is Gopher Winning?<br />
<a href="https://www.iotforall.com/javascript-vs-golang-iot/">https://www.iotforall.com/javascript-vs-golang-iot/</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

<li>Printf Format Strings<br />
<a href="https://www.cprogramming.com/tutorial/printf-format-strings.html">https://www.cprogramming.com/tutorial/printf-format-strings.html</a>
</li>

<li>Java: String.format<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-</a>
</li>

<li>Java: format string syntax<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a>
</li>

<li>Selectors<br />
<a href="https://golang.org/ref/spec#Selectors">https://golang.org/ref/spec#Selectors</a>
</li>

<li>Calling Go code from Python code<br />
<a href="http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/">http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/</a>
</li>

<li>Go Data Structures: Interfaces <br />
<a href="https://research.swtch.com/interfaces">https://research.swtch.com/interfaces</a>
</li>

<li>How to use interfaces in Go<br />
<a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go</a>
</li>

<li>Interfaces in Go (part I)<br />
<a href="https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c">https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c</a>
</li>

<li>Part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>What about Trait support in Golang?<br />
<a href="https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/">https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/</a>
</li>

<li>Don't Get Bitten by Pointer vs Non-Pointer Method Receivers in Golang<br />
<a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/">https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/</a>
</li>

<li>Control Flow<br />
<a href="https://en.wikipedia.org/wiki/Control_flow">https://en.wikipedia.org/wiki/Control_flow</a>
</li>

<li>Structured programming<br />
<a href="https://en.wikipedia.org/wiki/Structured_programming">https://en.wikipedia.org/wiki/Structured_programming</a>
</li>

<li>Control Structures<br />
<a href="https://www.golang-book.com/books/intro/5">https://www.golang-book.com/books/intro/5</a>
</li>

<li>Control structures - Go if else statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html">http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html</a>
</li>

<li>Control structures - Go switch case statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html</a>
</li>

<li>Control structures - Go for loop, break, continue, range<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html</a>
</li>

<li>Goroutine IDs<br />
<a href="https://blog.sgmansfield.com/2015/12/goroutine-ids/">https://blog.sgmansfield.com/2015/12/goroutine-ids/</a>
</li>

<li>Different ways to pass channels as arguments in function in go (golang)<br />
<a href="https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang">https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang</a>
</li>

<li>justforfunc #22: using the Go execution tracer<br />
<a href="https://www.youtube.com/watch?v=ySy3sR1LFCQ">https://www.youtube.com/watch?v=ySy3sR1LFCQ</a>
</li>

<li>Single Function Exit Point<br />
<a href="http://wiki.c2.com/?SingleFunctionExitPoint">http://wiki.c2.com/?SingleFunctionExitPoint</a>
</li>

<li>Entry point<br />
<a href="https://en.wikipedia.org/wiki/Entry_point">https://en.wikipedia.org/wiki/Entry_point</a>
</li>

<li>Why does Go have a GOTO statement?!<br />
<a href="https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/">https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/</a>
</li>

<li>Effective Go<br />
<a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a>
</li>

<li>GoClipse: an Eclipse IDE for the Go programming language<br />
<a href="http://goclipse.github.io/">http://goclipse.github.io/</a>
</li>

<li>GoClipse Installation<br />
<a href="https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation">https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation</a>
</li>

<li>The zero value of a slice is not nil<br />
<a href="https://stackoverflow.com/questions/30806931/the-zero-value-of-a-slice-is-not-nil">https://stackoverflow.com/questions/30806931/the-zero-value-of-a-slice-is-not-nil</a>
</li>

<li>Go-tcha: When nil != nil<br />
<a href="https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic">https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic</a>
</li>

<li>Nils in Go<br />
<a href="https://www.doxsey.net/blog/nils-in-go">https://www.doxsey.net/blog/nils-in-go</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

