<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Využití TinyGo při programování Raspberry Pi Pico</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Využití TinyGo při programování Raspberry Pi Pico</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Jednou z užitečných vlastností překladače TinyGo je podpora mnoha cílových platforem. Mezi ty patří i Raspberry Pi Pico. Dnes si ukážeme, jak lze s využitím TinyGo naprogramovat ovládání GPIO, analogově-digitálního převodníku či použít pulsní šířkovou modulaci.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Využití TinyGo při programování Raspberry Pi Pico</a></p>
<p><a href="#k02">*** 2. Hardware, na kterém otestujeme možnosti TinyGo</a></p>
<p><a href="#k03">3. Základy práce s&nbsp;GPIO a dalšími periferními zařízeními: modul <strong>machine</strong></a></p>
<p><a href="#k04">4. Klasický školní příklad: blikání LED připojenou na zvolený GPIO pin</a></p>
<p><a href="#k05">5. Překlad demonstračního příkladu pro Raspberry Pi Pico</a></p>
<p><a href="#k06">6. Kopie programu do RPi Pica s&nbsp;jeho spuštěním</a></p>
<p><a href="#k07">7. Čtení stavu tlačítka přes GPIO</a></p>
<p><a href="#k08">8. Zjednodušení zápisu programu s&nbsp;využitím GPIO pojmenovaných v&nbsp;modulu <strong>machine</strong></a></p>
<p><a href="#k09">9. Přímá specifikace hodnoty na výstupním GPIO</a></p>
<p><a href="#k10">10. Ovládání sedmisegmentového displeje (jedna číslice)</a></p>
<p><a href="#k11">11. Řízení zobrazení na sedmisegmentovém displeji s&nbsp;více číslicemi</a></p>
<p><a href="#k12">*** 12. Zobrazení numerické hodnoty 0-9999 na čtveřici sedmisegmentových displejů</a></p>
<p><a href="#k13">13. Analogově-digitální převodník (ADC)</a></p>
<p><a href="#k14">14. Čtení hodnot z&nbsp;analogově-digitálního převodníku</a></p>
<p><a href="#k15">15. ADC a čtení hodnoty potenciometru</a></p>
<p><a href="#k16">16. Pulsně šířková modulace</a></p>
<p><a href="#k17">*** 17. Ovládání jasu diody přes PWM</a></p>
<p><a href="#k18">*** 18. Kontroly prováděné při konfiguraci PWM</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Využití TinyGo při programování Raspberry Pi Pico</h2>

<p>V&nbsp;článku <a
href="https://www.root.cz/clanky/tinygo-alternativni-prekladac-a-runtime-system-programovaciho-jazyka-go/">TinyGo:
alternativní překladač a runtime systém programovacího jazyka Go</a> jsme se
seznámili s&nbsp;alternativním překladačem <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">jazyka Go</a>
nazvaným <i>TinyGo</i>. Jednou z&nbsp;velmi užitečných vlastností, kterou
TinyGo nabízí, je podpora poměrně velkého množství cílových platforem, mezi něž
patří i populární Raspberry Pi Pico (založené buď na čipu RP2040 nebo nověji i
na RP2035). V&nbsp;dnešním článku si ukážeme, jakým způsobem je možné
s&nbsp;využitím TinyGo naprogramovat ovládání GPIO (tedy obecně použitelných
vstupně-výstupních pinů), kterými je Raspberry Pi Pico vybaveno, jak se čtou
hodnoty z&nbsp;analogově-digitálního převodníku, zmíníme se i o způsobu použití
pulsně šířkové modulace (PWM) atd. Všechny dále uvedené demonstrační příklady
jsou přitom otestovány na reálném hardware, konkrétně na vývojové desce, jejímž
ústředním prvkem je právě Raspberry Pi Pico.</p>

<p>Pokud již máte TinyGo nainstalováno, je zjištění, jaké platformy (kombinace
základní desky a CPU nebo MCU) jsou podporovány, velmi snadné. Postačuje pouze
zadat příkaz:</p>

<pre>
$ <strong>tinygo targets</strong>
</pre>

<p>V&nbsp;případě TinyGo verze 0.40.1 (kterou v&nbsp;dnešním článku použiji) by
se měl vypsat tento seznam:</p>

<pre>
adafruit-esp32-feather-v2
ae-rp2040
arduino
arduino-leonardo
arduino-mega1280
arduino-mega2560
arduino-mkr1000
arduino-mkrwifi1010
arduino-nano
arduino-nano-new
arduino-nano33
arduino-zero
atmega1284p
atsame54-xpro
attiny1616
badger2040
badger2040-w
bluemicro840
bluepill
bluepill-clone
btt-skr-pico
challenger-rp2040
circuitplay-bluefruit
circuitplay-express
clue
clue-alpha
cortex-m-qemu
d1mini
digispark
elecrow-rp2040
elecrow-rp2350
esp-c3-32s-kit
esp32
esp32-c3-devkit-rust-1
esp32-coreboard-v2
esp32-mini32
esp32c3
esp32c3-12f
esp32c3-supermini
esp32s3
esp8266
feather-m0
feather-m0-express
feather-m4
feather-m4-can
feather-nrf52840
feather-nrf52840-sense
feather-rp2040
feather-stm32f405
gameboy-advance
gemma-m0
gnse
gobadge
gopher-arcade
gopher-badge
gopherbot
gopherbot2
grandcentral-m4
hifive1b
hw-651
hw-651-s110v8
itsybitsy-m0
itsybitsy-m4
itsybitsy-nrf52840
kb2040
lgt92
lorae5
m5paper
m5stack
m5stack-core2
m5stamp-c3
m5stick-c
macropad-rp2040
maixbit
makerfabs-esp32c3spi35
matrixportal-m4
mch2022
mdbt50qrx-uf2
metro-m4-airlift
metro-rp2350
microbit
microbit-s110v8
microbit-v2
microbit-v2-s113v7
microbit-v2-s140v7
mksnanov3
nano-33-ble
nano-33-ble-s140v6-uf2
nano-33-ble-s140v7
nano-33-ble-s140v7-uf2
nano-rp2040
nicenano
nodemcu
nrf52840-mdk
nrf52840-mdk-usb-dongle
nrf52840-s140v6-uf2
nrf52840-s140v6-uf2-generic
nrf52840-s140v7-uf2
nucleo-f103rb
nucleo-f722ze
nucleo-l031k6
nucleo-l432kc
nucleo-l476rg
nucleo-l552ze
nucleo-wl55jc
p1am-100
particle-3rd-gen
particle-argon
particle-boron
particle-xenon
pca10031
pca10040
pca10040-s132v6
pca10056
pca10056-s140v6-uf2
pca10056-s140v7
pca10059
pca10059-s140v7
pga2350
pico
pico-plus2
pico-w
pico2
pico2-ice
pico2-w
pinetime
pybadge
pygamer
pyportal
qtpy
qtpy-esp32c3
qtpy-rp2040
rak4631
reelboard
reelboard-s140v7
riscv-qemu
rp2040
rp2350
rp2350b
simavr
stm32f469disco
stm32f4disco
stm32f4disco-1
stm32l0x1
swan
teensy36
teensy40
teensy41
thingplus-rp2040
thumby
tiny2350
tkey
trinket-m0
trinkey-qt2040
tufty2040
wasi
wasip1
wasip2
wasm
wasm-unknown
waveshare-rp2040-tiny
waveshare-rp2040-zero
wioterminal
x9pro
xiao
xiao-ble
xiao-esp32c3
xiao-esp32s3
xiao-rp2040
</pre>

<p><div class="rs-tip-major">Poznámka: samotnou verzi TinyGo opět získáme
jednoduše:</div></p>

<pre>
$ <strong>tinygo version</strong>
tinygo version 0.40.1 linux/amd64 (using go version go1.24.10 and LLVM version 20.1.1)
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Hardware, na kterém otestujeme možnosti TinyGo</h2>

<table>
<tr><th>Označení</th><th>Vydáno</th><th>Mikrořadič</th><th>Wifi</th><th>RAM</th><th>Flash</th></tr>
<tr><td>Raspberry Pi Pico    </td><td>2021</td><td>RP2040</td><td>ne </td><td>264kB</td><td>2MB</td></tr>
<tr><td>Raspberry Pi Pico W  </td><td>2022</td><td>RP2040</td><td>ano</td><td>264kB</td><td>2MB</td></tr>
<tr><td>Raspberry Pi Pico 2  </td><td>2024</td><td>RP2350</td><td>ne </td><td>520kB</td><td>4MB</td></tr>
<tr><td>Raspberry Pi Pico 2 W</td><td>2024</td><td>RP2350</td><td>ano</td><td>520kB</td><td>4MB</td></tr>
</table>

<p>Již z&nbsp;tabulky uvedené před tímto odstavcem je zřejmé, že modely Pi Pico
(bez číslovky) a Pi Pico 2 se od sebe v&nbsp;několika ohledech odlišují, což je
do značné míry způsobeno použitím odlišných mikrořadičů. Rozdílů je však ještě
větší množství a vzhledem k&nbsp;tomu, že se dotýkají i problematiky probírané
v&nbsp;dnešním článku (PIO), si tyto rozdíly taktéž vypíšeme. Zajímat nás budou
především údaje o PIO:</p>

<table>
<tr><th>Čip</th><th>RP2040</th><th>RP2350</th><th>Poznámka</th></tr>
<tr><td>Jádra</td><td>2&times;ARM Cortex-M0+</td><td>2&times;ARM Cortex-M33 + 2&times;Hazard3 RISC-V</td><td>volba jader při bootu</td></tr>
<tr><td>FPU</td><td>ne</td><td>ano (ARM)</td><td>pouze jednoduchá přesnost</td></tr>
<tr><td>Frekvence</td><td>133 MHz</td><td>150 MHz</td><td>&nbsp;</td></tr>
<tr><td>(S)RAM</td><td>264 kB</td><td>510 kB</td><td>&nbsp;</td></tr>
<tr><td>OTP paměť</td><td>&times;</td><td>8 kB</td><td>používáno například pro klíče při bootu atd.</td></tr>
<tr><td>DMA</td><td>12 kanálů</td><td>16 kanálů</td><td>přímý přístup do paměti</td></tr>
<tr><td>IRQ pro DMA</td><td>2</td><td>4</td><td>HW přerušení používaná při DMA</td></tr>
<tr><td>PIO</td><td>2 (8 stavových strojů)</td><td>3 (12 stavových strojů)</td><td>bude popsáno dále</td></tr>
<tr><td>PWM</td><td>16</td><td>24</td><td>pulsní šířková modulace</td></tr>
<tr><td>ADC</td><td>4 kanály, 12bitů</td><td>4 kanály, 12 bitů (popř.&nbsp;8 kanálů)</td><td>analogově-digiální převodník</td></tr>
<tr><td>DAC</td><td>&times;</td><td>&times;</td><td>digitálně-analogový převodník</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Základy práce s&nbsp;GPIO a dalšími periferními zařízeními: modul <strong>machine</strong></h2>

<p>V&nbsp;TinyGo nalezneme mj.&nbsp;i modul nazvaný <strong>machine</strong>.
V&nbsp;tomto modulu je definován datový typ <strong>Pin</strong>, jenž je
odvozený od standardního typu <strong>uint8</strong>. Ovšem důležitější je
fakt, že jsou pro typ <strong>Pin</strong> předepsány i metody určené pro čtení
stavu vstupního pinu, nastavení úrovně výstupního pinu atd. A taktéž zde
nalezneme typ určený pro konfiguraci pinů (tedy nastavení, zda je pin vstupní,
výstupní, zda se má jednat o výstup PWM, vstup z&nbsp;A/D převodníku atd.):</p>

<pre>
<i>// PinMode sets the direction and pull mode of the pin. For example, PinOutput</i>
<i>// sets the pin as an output and PinInputPullup sets the pin as an input with a</i>
<i>// pull-up.</i>
type PinMode uint8
&nbsp;
type PinConfig struct {
        Mode PinMode
}
&nbsp;
<i>// Pin is a single pin on a chip, which may be connected to other hardware</i>
<i>// devices. It can either be used directly as GPIO pin or it can be used in</i>
<i>// other peripherals like ADC, I2C, etc.</i>
type Pin uint8
&nbsp;
<i>// NoPin explicitly indicates "not a pin". Use this pin if you want to leave one</i>
<i>// of the pins in a peripheral unconfigured (if supported by the hardware).</i>
const NoPin = Pin(0xff)
&nbsp;
<i>// High sets this GPIO pin to high, assuming it has been configured as an output</i>
<i>// pin. It is hardware dependent (and often undefined) what happens if you set a</i>
<i>// pin to high that is not configured as an output pin.</i>
func (p Pin) High() {
        p.Set(true)
}
&nbsp;
<i>// Low sets this GPIO pin to low, assuming it has been configured as an output</i>
<i>// pin. It is hardware dependent (and often undefined) what happens if you set a</i>
<i>// pin to low that is not configured as an output pin.</i>
func (p Pin) Low() {
        p.Set(false)
}
&nbsp;
type ADC struct {
        Pin Pin
}
</pre>

<p><div class="rs-tip-major">Poznámka: V&nbsp;tomto zdrojovém kódu jsou
definice jen dvou metod <strong>High</strong> a <strong>Low</strong>, ovšem
později se seznámíme i s&nbsp;dalšími metodami datového typu
<strong>Pin</strong>.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Klasický školní příklad: blikání LED připojenou na zvolený GPIO pin</h2>

<p>Úvodní pokusy s&nbsp;jednodeskovými mikropočítači (ať již postavenými na
osmibitových nebo 32bitových mikrořadičích) jsou většinou založeny na připojení
LED k&nbsp;mikropočítači a programovém ovládání této LED. Jelikož se
v&nbsp;této oblasti jedná o obdobu známého &bdquo;Hello world&ldquo;, vytvoříme
naprosto stejný příklad, ovšem naprogramovaný v&nbsp;jazyce Go a přeložený
s&nbsp;využitím TinyGo.</p>

<p>Nejprve v&nbsp;programu nadefinujeme konstantu s&nbsp;číslem GPIO pinu, na
který je LED (se sériovým odporem) připojena. V&nbsp;mém případě se jedná o
GPIO číslo 2:</p>

<pre>
const OutputPin = 2
</pre>

<p>Dále vytvoříme datovou strukturu typu <strong>machine.Pin</strong>, která je
odvozena (jak jsme si řekli <a href="#k03">v&nbsp;předchozí kapitole</a>) od
základního datového typu <strong>uint8</strong>, ke kterému byly přidány nové
metody:</p>

<pre>
led := machine.Pin(OutputPin)
</pre>

<p>Nesmíme zapomenout na explicitní přepnutí zvoleného GPIO do výstupního
režimu, což se provádí metodou <strong>Configure</strong>:</p>

<pre>
led.Configure(machine.PinConfig{Mode: machine.PinOutput})
</pre>

<p>Nyní je již možné LED programově ovládat, a to posláním logické jedničky
nebo naopak logické nuly na příslušný GPIO:</p>

<pre>
led.High()
</pre>

<p>Nastavení logické nuly:</p>

<pre>
led.Low()
</pre>

<p>Přepínáním logické úrovně v&nbsp;určitých časových intervalech dosáhneme
blikání LED. Pro specifikaci intervalu můžeme využít standardní knihovnu
<strong>time</strong> (TinyGo se v&nbsp;tomto ohledu neliší od standardního
Go):</p>

<pre>
const SleepAmount = time.Millisecond * 200
&nbsp;
for {
    led.High()
    time.Sleep(SleepAmount)
    led.Low()
    time.Sleep(SleepAmount)
}
</pre>

<p>Úplný zdrojový kód takto navrženého demonstračního příkladu vypadá
následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
    "machine"
    "time"
)
&nbsp;
const OutputPin = 2
const SleepAmount = time.Millisecond * 200
&nbsp;
func <strong>main</strong>() {
    led := machine.Pin(OutputPin)
    led.Configure(machine.PinConfig{Mode: machine.PinOutput})
&nbsp;
    for {
        led.High()
        time.Sleep(SleepAmount)
        led.Low()
        time.Sleep(SleepAmount)
    }
}
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;MicroPythonu je tento program
sice mnohem kratší (pokud spočteme počet řádků zdrojového kódu), ale vyžaduje
vlastní MicroPython, který zabírá poměrně velkou část Flash i RAM na Pi
Picu.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Překlad demonstračního příkladu pro Raspberry Pi Pico</h2>

<p>Překlad demonstračního příkladu <a href="#k04">z&nbsp;předchozí kapitoly</a>
lze v&nbsp;tom nejjednodušším případě provést následujícím příkazem:</p>

<pre>
$ <strong>tinygo build -o blink.uf2 -target=pico blink.go</strong>
</pre>

<p>Výsledkem je binární soubor s&nbsp;formátem UF2, jehož velikost dosahuje
téměř 20kB:</p>

<pre>
$ <strong>ls -l</strong>
&nbsp;
total 191320
-rw-r--r--. 1 ptisnovs ptisnovs       303 Dec 30 15:34 blink.go
-rwxr-xr-x. 1 ptisnovs ptisnovs     19968 Dec 30 15:34 blink.uf2
</pre>

<p>Velikost výsledného souboru však můžeme s&nbsp;využitím několika přepínačů
zmenšit na rozumnější velikost. Z&nbsp;runtime necháme odstranit například
plánovač pro gorutiny a odstraníme i ladicí symboly:</p>

<pre>
$ <strong>tinygo build -no-debug -nobounds -scheduler=none -o blink.uf2 -target=pico blink.go</strong>
</pre>

<p>Nyní bude velikost výsledného souboru menší &ndash; cca třináct
kilobajtů:</p>

<pre>
$ <strong>ls -l</strong>
&nbsp;
total 191316
-rw-r--r--. 1 ptisnovs ptisnovs       303 Dec 30 15:34 blink.go
-rwxr-xr-x. 1 ptisnovs ptisnovs     13312 Dec 30 15:40 blink.uf2
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Kopie programu do RPi Pica s&nbsp;jeho spuštěním</h2>

<p>Výsledný soubor vzniklý překladem běžným způsobem nahrajeme do Raspberry Pi
Pico. Při zapojování Pico k&nbsp;počítači přes USB je nutné podržet tlačítko
<strong>Bootsel</strong>. Pico se k&nbsp;počítači připojí v&nbsp;režimu <i>mass
storage device</i>, tedy chová se jako flash disk. Toto chování si můžeme
ověřit například příkazem <strong>dmesg</strong>:</p>

<pre>
[2661401.124131] usb 3-1: new full-speed USB device number 61 using xhci_hcd
[2661401.249236] usb 3-1: New USB device found, idVendor=2e8a, idProduct=0003, bcdDevice= 1.00
[2661401.249263] usb 3-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3
[2661401.249272] usb 3-1: Product: RP2 Boot
[2661401.249279] usb 3-1: Manufacturer: Raspberry Pi
[2661401.249284] usb 3-1: SerialNumber: E0C9125B0D9B
[2661401.253896] usb-storage 3-1:1.0: USB Mass Storage device detected
[2661401.254513] scsi host0: usb-storage 3-1:1.0
[2661402.292170] scsi 0:0:0:0: Direct-Access     RPI      RP2              3    PQ: 0 ANSI: 2
[2661402.293215] sd 0:0:0:0: Attached scsi generic sg0 type 0
[2661402.295776] sd 0:0:0:0: [sda] 262144 512-byte logical blocks: (134 MB/128 MiB)
[2661402.296607] sd 0:0:0:0: [sda] Write Protect is off
[2661402.296615] sd 0:0:0:0: [sda] Mode Sense: 03 00 00 00
[2661402.297239] sd 0:0:0:0: [sda] No Caching mode page found
[2661402.297247] sd 0:0:0:0: [sda] Assuming drive cache: write through
[2661402.338588]  sda: sda1
[2661402.339371] sd 0:0:0:0: [sda] Attached SCSI removable disk
</pre>

<p>Nyní postačuje soubor <strong>blink.uf2</strong> zkopírovat na připojený
disk. Ihned poté dojde k&nbsp;odpojení Pica od počítače s&nbsp;novým
připojením, ovšem nikoli v&nbsp;režimu mass storage device. A současně dojde ke
spuštění našeho programu &ndash; LED začne blikat:</p>

<pre>
[2399478.090936] usb 3-1: new full-speed USB device number 106 using xhci_hcd
[2399478.216206] usb 3-1: New USB device found, idVendor=2e8a, idProduct=000a, bcdDevice= 1.00
[2399478.216224] usb 3-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3
[2399478.216230] usb 3-1: Product: Pico
[2399478.216235] usb 3-1: Manufacturer: Raspberry Pi
[2399478.220389] cdc_acm 3-1:1.0: ttyACM0: USB ACM device
</pre>

<p><div class="rs-tip-major">Poznámka: k&nbsp;Picu se nyní můžeme připojit
například přes <strong>minicom</strong>, což je pochopitelně téma, kterému se
budeme taktéž věnovat.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Čtení stavu tlačítka přes GPIO</h2>

<p>Prozatím umíme ovládat logickou úroveň na GPIO, které je přepnuté do
výstupního režimu. Ovšem už z&nbsp;významu zkratky GPIO (<i>General-Purpose
Input/Output</i>) je zřejmé, že piny je možné programově přepnout do vstupního
režimu, které umožňují například čtení stavu tlačítka (stisknuto/pušteno).
Příslušná metoda, která zjistí úroveň logické hodnoty přivedené na pin, se
jmenuje <strong>Get</strong> a nalezneme ji v&nbsp;souboru
<strong>machine_rp2.go</strong>:</p>

<pre>
//go:build rp2040 || rp2350

// Get reads the pin value.
func (p Pin) Get() bool {
        return p.get()
}
</pre>

<p>V&nbsp;dalším demonstračním příkladu budeme tlačítkem (pochopitelně nepřímo)
ovládat LED, takže nás nemusí trápit zákmity, ke kterým nutně při stisku
dochází (ovšem pokud bychom například zjišťovali počet stisků atd., byly by
zákmity velkým problémem, který se dá řešit buď na HW nebo SW úrovni).
Nakonfigurujeme GPIO číslo 0, kam je tlačítko fyzicky připojena, do vstupního
režimu:</p>

<pre>
const OutputPin = 2
&nbsp;
button := machine.Pin(InputPin)
button.Configure(machine.PinConfig{Mode: machine.PinInput})
</pre>

<p>Následně budeme číst stav tlačítka a pokud je stisknuto, rozsvítíme LED:</p>

<pre>
for {
    pressed := button.Get()
    if pressed {
        led.High()
    } else {
        led.Low()
    }
}
</pre>

<p>Celý zdrojový kód dnešního druhého demonstračního příkladu vypadá
následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
    "machine"
)
&nbsp;
const InputPin = 0
const OutputPin = 2
&nbsp;
func <strong>main</strong>() {
    led := machine.Pin(OutputPin)
    led.Configure(machine.PinConfig{Mode: machine.PinOutput})
&nbsp;
    button := machine.Pin(InputPin)
    button.Configure(machine.PinConfig{Mode: machine.PinInput})
&nbsp;
    for {
        pressed := button.Get()
        if pressed {
            led.High()
        } else {
            <i>// pokud vynecháme, LED se pouze rozsvítí</i>
            led.Low()
        }
    }
}
</pre>

<p><div class="rs-tip-major">Poznámka: pochopitelně je možné tento program dále
modifikovat, například naprogramovat zhasnutí LED jiným tlačítkem nebo
automaticky po uplynutí určitého časového intervalu.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zjednodušení zápisu programu s&nbsp;využitím GPIO pojmenovaných v&nbsp;modulu <strong>machine</strong></h2>

<p>Ve skutečnosti není nutné na základě čísel GPIO explicitně konstruovat
struktury typu <strong>machine.Pin</strong> tak, jako tomu bylo
v&nbsp;předchozím demonstračním příkladu:</p>

<pre>
const InputPin = 0
const OutputPin = 2
&nbsp;
led := machine.Pin(OutputPin)
button := machine.Pin(InputPin)
</pre>

<p>Jednodušší je použít již předpřipravené struktury definované v&nbsp;modulu
<strong>machine</strong> (interně se opět jedná o hodnoty typu
<strong>uint8</strong>, ovšem doplněné o možnost volání metod). Předchozí
demonstrační příklad se tak zkrátí do následující podoby:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
    "machine"
)
&nbsp;
const InputPin = machine.GP0
const OutputPin = machine.GP2
&nbsp;
func <strong>main</strong>() {
    led := OutputPin
    led.Configure(machine.PinConfig{Mode: machine.PinOutput})
&nbsp;
    button := InputPin
    button.Configure(machine.PinConfig{Mode: machine.PinInput})
&nbsp;
    for {
        pressed := button.Get()
        if pressed {
            led.High()
        } else {
            led.Low()
        }
    }
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Přímá specifikace hodnoty na výstupním GPIO</h2>

<p>Ve zdrojovém kódu <strong>machine_rp2.go</strong>, který je součástí modulu
<strong>machine</strong>, nalezneme mj.&nbsp;i metodu nazvanou
<strong>Set</strong>, opět definovanou pro příjemce (<i>receiver</i>)
<strong>Pin</strong>. Definice této metody vypadá následovně:</p>

<pre>
// Set drives the pin high if value is true else drives it low.
func (p Pin) Set(value bool) {
        if p == NoPin {
                return
        }
        if value {
                p.set()
        } else {
                p.clr()
        }
}
</pre>

<p><div class="rs-tip-major">Poznámka: je zajímavé, že metody
<strong>High</strong> a <strong>Low</strong> volají právě metodu
<strong>Set</strong>, ve které se opět provádí rozeskok.</div></p>

<p>Díky tomu je možné přímo nastavit hodnotu výstupního GPIO na základě předané
pravdivostní hodnoty &ndash; není tedy nutné na základě podmínky volat buď
<strong>pin.High</strong> nebo naopak <strong>pin.Low</strong>. To nám umožní
zkrácení demonstračního příkladu pro detekci stisku a uvolnění tlačítka do této
podoby:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "machine"
)
&nbsp;
const InputPin = machine.GP0
const OutputPin = machine.GP2
&nbsp;
func <strong>main</strong>() {
        led := OutputPin
        led.Configure(machine.PinConfig{Mode: machine.PinOutput})
&nbsp;
        button := InputPin
        button.Configure(machine.PinConfig{Mode: machine.PinInput})
&nbsp;
        for {
                pressed := button.Get()
                led.Set(pressed)
        }
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Ovládání sedmisegmentového displeje (jedna číslice)</h2>

<p>Nyní, když již víme, jakým způsobem se ovládají jednotlivé GPIO piny, se
pokusíme o řízení sedmisegmentového displeje, resp.&nbsp;přesněji řečeno jedné
číslice reprezentované sedmi segmenty a desetinné tečky. Na vývojové desce je
sedmisegmentový displej zapojen následujícím způsobem:</p>

*** image ***

<p>Toto zapojení umožňuje nastavit individuálně jakýkoli segment (nebo tečku)
jedné číslice nebo skupiny číslic, a to pomocí signálů A, B, C, D, E, F, G a DP
(takto se většinou označují jednotlivé segmenty a desetinná tečka, viz
například <a
href="https://en.wikipedia.org/wiki/Seven-segment_display#/media/File:7_Segment_Display_with_Labeled_Segments.svg">toto
schéma</a>). Výše uvedené signály jsou vytvářeny na GPIO 11, 9, 13, 15, 16, 10,
12 a 14:</p>

<pre>
var pins [8]machine.Pin
&nbsp;
pins[0] = machine.GP11
pins[1] = machine.GP9
pins[2] = machine.GP13
pins[3] = machine.GP15
pins[4] = machine.GP16
pins[5] = machine.GP10
pins[6] = machine.GP12
pins[7] = machine.GP14
</pre>

<p>Tyto piny musí být pochopitelně přepnuty do výstupního režimu:</p>

<pre>
for _, pin := range pins {
    pin.Configure(machine.PinConfig{Mode: machine.PinOutput})
}
</pre>

<p>To, která číslice nebo které číslice budou rozsvíceny, se řídí signály DIG1,
DIG2, DIG3 a DIG4, které odpovídají GPIO 5, 6, 7 a 8. Prozatím si necháme
rozsvítit jedinou číslici, takže nám bude stačit nastavit GPIO 5 na logickou
jedničku (povolení dané číslice):</p>

<pre>
c1 := machine.GP5
c1.Configure(machine.PinConfig{Mode: machine.PinOutput})
c1.High()
</pre>

<p>Řízení segmentů je zajištěno funkcí <strong>display4Segments</strong>, které
se předává řez pravdivostních hodnot (ovšem snadno si můžete provést úpravu pro
předání celočíselné hodnoty 0 až 255):</p>

<pre>
func <strong>displaySegments</strong>(bits []bool) {
    for i := range bits {
        bit := bits[i]
        pin := pins[i]
        if bit {
            pin.High()
        } else {
            pin.Low()
        }
    }
}
</pre>

<p><div class="rs-tip-major">Poznámka: samozřejmě lze volat
<strong>pin.Set()</strong>, což již ponechávám na laskavém čtenáři.</div></p>

<p>Následující demonstrační příklad by měl rozsvítit všechny segmenty první
číslice a současně i její desetinou tečku:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
    "machine"
)
&nbsp;
var pins [8]machine.Pin
&nbsp;
func <strong>displaySegments</strong>(bits []bool) {
    for i := range bits {
        bit := bits[i]
        pin := pins[i]
        if bit {
            pin.High()
        } else {
            pin.Low()
        }
    }
}
&nbsp;
func <strong>main</strong>() {
    c1 := machine.GP5
    c1.Configure(machine.PinConfig{Mode: machine.PinOutput})
    c1.High()
&nbsp;
    pins[0] = machine.GP11
    pins[1] = machine.GP9
    pins[2] = machine.GP13
    pins[3] = machine.GP15
    pins[4] = machine.GP16
    pins[5] = machine.GP10
    pins[6] = machine.GP12
    pins[7] = machine.GP14
&nbsp;
    for _, pin := range pins {
        pin.Configure(machine.PinConfig{Mode: machine.PinOutput})
    }
&nbsp;
    displaySegments([]bool{true, true, true, true, true, true, true, true})
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Řízení zobrazení na sedmisegmentovém displeji s&nbsp;více číslicemi</h2>

<p>Jak jsme si již řekli <a href="#k10">v&nbsp;předchozí kapitole</a>, můžeme
přes GPIO 5, 6, 7 a 8 řídit, které číslice mají být zobrazeny a které nikoli.
V&nbsp;jeden okamžik může být rozsvícena jakákoli kombinace číslic, ovšem vždy
se bude jednat o shodné segmenty (tedy například můžeme zobrazit čtyři dvojky
atd.). Nejprve nastavíme všechny čtyři GPIO (5-8) do výstupního režimu:</p>

<pre>
var controls [4]machine.Pin
&nbsp;
controls[0] = machine.GP5
controls[1] = machine.GP6
controls[2] = machine.GP7
controls[3] = machine.GP8
for _, control := range controls {
    control.Configure(machine.PinConfig{Mode: machine.PinOutput})
}
</pre>

<p>Pokud budeme chtít zobrazit jen první a třetí číslici, musíme příslušné GPIO
nastavit na hodnotu logické jedničky:</p>

<pre>
controls[0].High()
controls[2].High()
</pre>

<p>Samotná logika zapnutí či vypnutí jednotlivých segmentů a desetinné tečky
zůstává stále stejná (je zcela nezávislá na GPIO 5-8):</p>

<pre>
var pins [8]machine.Pin
&nbsp;
pins[0] = machine.GP11
pins[1] = machine.GP9
pins[2] = machine.GP13
pins[3] = machine.GP15
pins[4] = machine.GP16
pins[5] = machine.GP10
pins[6] = machine.GP12
pins[7] = machine.GP14
&nbsp;
for _, pin := range pins {
    pin.Configure(machine.PinConfig{Mode: machine.PinOutput})
}
</pre>

<p>Ukažme si nyní celý zdrojový kód demonstračního příkladu, který zobrazí
dvojici osmiček (další dvě místa budou zhasnuta):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
    "machine"
    "time"
)
&nbsp;
const SleepAmount = time.Millisecond * 200
&nbsp;
var controls [4]machine.Pin
var pins [8]machine.Pin
&nbsp;
func <strong>displaySegments</strong>(bits []bool) {
    for i := range bits {
        bit := bits[i]
        pin := pins[i]
        if bit {
            pin.High()
        } else {
            pin.Low()
        }
    }
}
&nbsp;
func <strong>main</strong>() {
    controls[0] = machine.GP5
    controls[1] = machine.GP6
    controls[2] = machine.GP7
    controls[3] = machine.GP8
    for _, control := range controls {
        control.Configure(machine.PinConfig{Mode: machine.PinOutput})
    }
&nbsp;
    controls[0].High()
    controls[2].High()
&nbsp;
    pins[0] = machine.GP11
    pins[1] = machine.GP9
    pins[2] = machine.GP13
    pins[3] = machine.GP15
    pins[4] = machine.GP16
    pins[5] = machine.GP10
    pins[6] = machine.GP12
    pins[7] = machine.GP14
&nbsp;
    for _, pin := range pins {
        pin.Configure(machine.PinConfig{Mode: machine.PinOutput})
    }
&nbsp;
    displaySegments([]bool{true, true, true, true, true, true, true, true})
}
</pre>

<p>Nyní ovšem nastává otázka &ndash; jak zobrazit <i>rozdílné</i> (libovolné)
čtyři číslice? Zde se musí použít starodávný trik: v&nbsp;daný okamžik je
zobrazena jen jediná číslice (vybraná jedním GPIO 5-8). Ovšem zobrazení
jednotlivých číslic je prováděno tak rychle, že vlivem setrvačnosti oka vidíme
současně všechny čtyři číslice. Ovšem například při focení displeje nebo při
analýze videa by bylo patrné, že jsou rozsvíceny vždy jen segmenty jediné
číslice.</p>

<p>Následující funkce zobrazí každou číslici na dobu minimálně jedné
milisekundy. Poté celá číslice zhasne a přejde se na číslici další:</p>

<pre>
const SleepAmount = time.Millisecond * 1
&nbsp;
func <strong>display4Segments</strong>(bits [][]bool) {
    for {
        for i := range bits {
            control := controls[i]
            control.High()
            displaySegments(bits[i])
            time.Sleep(SleepAmount)
            control.Low()
        }
    }
}
</pre>

<p>Následuje úplný zdrojový kód takto upraveného demonstračního příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
    "machine"
    "time"
)
&nbsp;
const SleepAmount = time.Millisecond * 1
&nbsp;
var controls [4]machine.Pin
var pins [8]machine.Pin
&nbsp;
func <strong>init</strong>() {
    controls[0] = machine.GP5
    controls[1] = machine.GP6
    controls[2] = machine.GP7
    controls[3] = machine.GP8
    for _, control := range controls {
        control.Configure(machine.PinConfig{Mode: machine.PinOutput})
    }
&nbsp;
    pins[0] = machine.GP11
    pins[1] = machine.GP9
    pins[2] = machine.GP13
    pins[3] = machine.GP15
    pins[4] = machine.GP16
    pins[5] = machine.GP10
    pins[6] = machine.GP12
    pins[7] = machine.GP14
&nbsp;
    for _, pin := range pins {
        pin.Configure(machine.PinConfig{Mode: machine.PinOutput})
    }
}
&nbsp;
func <strong>displaySegments</strong>(bits []bool) {
    for i := range bits {
        bit := bits[i]
        pin := pins[i]
        if bit {
            pin.High()
        } else {
            pin.Low()
        }
    }
}
&nbsp;
func <strong>display4Segments</strong>(bits [][]bool) {
    for {
        for i := range bits {
            control := controls[i]
            control.High()
            displaySegments(bits[i])
            time.Sleep(SleepAmount)
            control.Low()
        }
    }
}
&nbsp;
func <strong>main</strong>() {
    display4Segments([][]bool{
        {false, true, true, false, false, false, false, false},
        {true, true, false, true, true, false, true, false},
        {true, true, true, true, false, false, true, false},
        {false, true, true, false, false, true, true, false}})
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Zobrazení numerické hodnoty 0-9999 na čtveřici sedmisegmentových displejů</h2>

<pre>
package <strong>main</strong>
&nbsp;
import (
    "machine"
    "time"
)
&nbsp;
const SleepAmount = time.Millisecond * 1
&nbsp;
var controls [4]machine.Pin
var pins [8]machine.Pin
&nbsp;
var digits [][]bool = [][]bool{
    {true, true, true, true, true, true, false, false},
    {false, true, true, false, false, false, false, false},
    {true, true, false, true, true, false, true, false},
    {true, true, true, true, false, false, true, false},
    {false, true, true, false, false, true, true, false},
    {true, false, true, true, false, true, true, false},
    {true, false, true, true, true, true, true, false},
    {true, true, true, false, false, false, false, false},
    {true, true, true, true, true, true, true, false},
    {true, true, true, true, false, true, true, false},
}
&nbsp;
func <strong>init</strong>() {
    controls[0] = machine.GP5
    controls[1] = machine.GP6
    controls[2] = machine.GP7
    controls[3] = machine.GP8
    for _, control := range controls {
        control.Configure(machine.PinConfig{Mode: machine.PinOutput})
    }
&nbsp;
    pins[0] = machine.GP11
    pins[1] = machine.GP9
    pins[2] = machine.GP13
    pins[3] = machine.GP15
    pins[4] = machine.GP16
    pins[5] = machine.GP10
    pins[6] = machine.GP12
    pins[7] = machine.GP14
&nbsp;
    for _, pin := range pins {
        pin.Configure(machine.PinConfig{Mode: machine.PinOutput})
    }
}
&nbsp;
func <strong>displaySegments</strong>(bits []bool) {
    for i := range bits {
        bit := bits[i]
        pin := pins[i]
        if bit {
            pin.High()
        } else {
            pin.Low()
        }
    }
}
&nbsp;
func <strong>displayNumber</strong>(number int) {
    for {
        x := number
        for i := range 4 {
            digit := x % 10
            x /= 10
            bits := digits[digit]
            control := controls[3-i]
            control.High()
            displaySegments(bits)
            time.Sleep(SleepAmount)
            control.Low()
        }
    }
}
&nbsp;
func <strong>main</strong>() {
    displayNumber(1234)
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Analogově-digitální převodník (ADC)</h2>

<p>Čipy RP2040 i RP2350 jsou mj.&nbsp;vybaveny i analogově-digitálním
převodníkem. Typicky se jedná o čtyři (vstupní) kanály s&nbsp;rozlišením
dvanácti bitů, ovšem RP2350 v&nbsp;pouzdře QFN-80EP nabízí celých osm kanálů (a
současně i osmnáct GPIO). I když má analogově-digitální převodník rozlišení
dvanácti bitů, prakticky všechna programová rozhraní vrací šestnáctibitové
hodnoty, což znamená, že spodní čtyři bity přečtených výsledků je možné
ignorovat. Navíc je možné u každého ze vstupů do analogově-digitálního
převodníku zvolit, zda budou použity nebo zda se má příslušný pin použít pro
jiné účely (GPIO, SCL). To se týká prvních tří kanálů ADC0, ADC1 a ADC2,
protože čtvrtý kanál se používá pro čtení hodnoty získané teplotním senzorem (a
není tedy vyveden). Popis pinů naleznete na adrese <a
href="https://www.raspberrypi.com/documentation/microcontrollers/pico-series.html#pico-2-family">https://www.raspberrypi.com/documentation/microcontrollers/pico-series.html#pico-2-family</a>.</p>

<p>Na použité vývojové desce je nainstalován i potenciometr, který je připojený
k&nbsp;ADC2, což odpovídá GPIO číslo 28:</p>

*** image ***
<p><i>Obrázek: Schéma připojení potenciometru k&nbsp;ADC2.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Čtení hodnot z&nbsp;analogově-digitálního převodníku (ADC)</h2>

<p>V&nbsp;dalším demonstračním příkladu je ukázán postup použitý pro čtení
hodnot z&nbsp;analogově-digitálního převodníku s&nbsp;následným zobrazením
výsledné hodnoty na čtveřici sedmisegmentových displejů. Nejprve je nutné ADC
nakonfigurovat. Víme již, že budeme používat kanál číslo 2 (ADC2).
Inicializujeme tedy subsystém ADC a nakonfigurujeme příslušný pin:</p>

<pre>
machine.InitADC()
&nbsp;
adc2 := machine.ADC{Pin: machine.ADC2}
&nbsp;
adc2.Configure(machine.ADCConfig{})
</pre>

<p>Samotné přečtení hodnoty je snadné. Jedná se o šestnáctibitovou hodnotu,
ovšem čtyři nejnižší bity je možné ignorovat (stejně budou nulové):</p>

<pre>
value := adc2.Get()
</pre>

<p>Zobrazit ovšem můžeme jen hodnoty v&nbsp;rozsahu 0 až 9999, takže přečtenou
hodnotu podělíme sedmi (nebo je možné použít bitový posun do rozsahu 0 až
8191). Výsledek tohoto výpočtu je již možné přímo zobrazit:</p>

<pre>
value /= 7
displayNumber(int(value))
</pre>

<p>Ukažme si nyní celý zdrojový kód tohoto demonstračního příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
    "machine"
    "time"
)
&nbsp;
const SleepAmount = time.Millisecond * 1
&nbsp;
var controls [4]machine.Pin
var pins [8]machine.Pin
&nbsp;
var digits [][]bool = [][]bool{
    {true, true, true, true, true, true, false, false},
    {false, true, true, false, false, false, false, false},
    {true, true, false, true, true, false, true, false},
    {true, true, true, true, false, false, true, false},
    {false, true, true, false, false, true, true, false},
    {true, false, true, true, false, true, true, false},
    {true, false, true, true, true, true, true, false},
    {true, true, true, false, false, false, false, false},
    {true, true, true, true, true, true, true, false},
    {true, true, true, true, false, true, true, false},
}
&nbsp;
func <strong>init</strong>() {
    controls[0] = machine.GP5
    controls[1] = machine.GP6
    controls[2] = machine.GP7
    controls[3] = machine.GP8
    for _, control := range controls {
        control.Configure(machine.PinConfig{Mode: machine.PinOutput})
    }
&nbsp;
    pins[0] = machine.GP11
    pins[1] = machine.GP9
    pins[2] = machine.GP13
    pins[3] = machine.GP15
    pins[4] = machine.GP16
    pins[5] = machine.GP10
    pins[6] = machine.GP12
    pins[7] = machine.GP14
&nbsp;
    for _, pin := range pins {
        pin.Configure(machine.PinConfig{Mode: machine.PinOutput})
    }
}
&nbsp;
func <strong>displaySegments</strong>(bits []bool) {
    for i := range bits {
        bit := bits[i]
        pin := pins[i]
        if bit {
            pin.High()
        } else {
            pin.Low()
        }
    }
}
&nbsp;
func <strong>displayNumber</strong>(number int) {
    x := number
    for i := range 4 {
        digit := x % 10
        x /= 10
        bits := digits[digit]
        control := controls[3-i]
        control.High()
        displaySegments(bits)
        time.Sleep(SleepAmount)
        control.Low()
    }
}
&nbsp;
func <strong>main</strong>() {
    machine.InitADC()
    adc0 := machine.ADC{Pin: machine.ADC0}
    adc1 := machine.ADC{Pin: machine.ADC1}
    adc2 := machine.ADC{Pin: machine.ADC2}
&nbsp;
    adc0.Configure(machine.ADCConfig{})
    adc1.Configure(machine.ADCConfig{})
    adc2.Configure(machine.ADCConfig{})
&nbsp;
    for {
        value := adc2.Get()
        value /= 7
        displayNumber(int(value))
    }
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. ADC a čtení hodnoty potenciometru</h2>

<p>I když se nebude potenciometrem otáčet, budeme při opakovaném čtení dostávat
odlišné hodnoty. Aby čísla na displeji neposkakovala, je možné nejprve změřit
větší množství hodnot a poté spočítat jejich průměr. Například můžeme postupně
přečíst 100 hodnot (s&nbsp;případným zpožděním &ndash; nutné nastavit) a
podělit výsledek hodnotou 700 (tedy 7&times;100). Teprve tato hodnota se
zobrazí na displeji:</p>

<pre>
var value int32 = 0
for range 100 {
    value += int32(adc2.Get())
}
value /= 700
</pre>

<p>Takto upravený příklad bude vypadat následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
    "machine"
    "time"
)
&nbsp;
const SleepAmount = time.Millisecond * 1
&nbsp;
var controls [4]machine.Pin
var pins [8]machine.Pin
&nbsp;
var digits [][]bool = [][]bool{
    {true, true, true, true, true, true, false, false},
    {false, true, true, false, false, false, false, false},
    {true, true, false, true, true, false, true, false},
    {true, true, true, true, false, false, true, false},
    {false, true, true, false, false, true, true, false},
    {true, false, true, true, false, true, true, false},
    {true, false, true, true, true, true, true, false},
    {true, true, true, false, false, false, false, false},
    {true, true, true, true, true, true, true, false},
    {true, true, true, true, false, true, true, false},
}
&nbsp;
func <strong>init</strong>() {
    controls[0] = machine.GP5
    controls[1] = machine.GP6
    controls[2] = machine.GP7
    controls[3] = machine.GP8
    for _, control := range controls {
        control.Configure(machine.PinConfig{Mode: machine.PinOutput})
    }
&nbsp;
    pins[0] = machine.GP11
    pins[1] = machine.GP9
    pins[2] = machine.GP13
    pins[3] = machine.GP15
    pins[4] = machine.GP16
    pins[5] = machine.GP10
    pins[6] = machine.GP12
    pins[7] = machine.GP14
&nbsp;
    for _, pin := range pins {
        pin.Configure(machine.PinConfig{Mode: machine.PinOutput})
    }
}
&nbsp;
func <strong>displaySegments</strong>(bits []bool) {
    for i := range bits {
        bit := bits[i]
        pin := pins[i]
        if bit {
            pin.High()
        } else {
            pin.Low()
        }
    }
}
&nbsp;
func <strong>displayNumber</strong>(number int) {
    x := number
    for i := range 4 {
        digit := x % 10
        x /= 10
        bits := digits[digit]
        control := controls[3-i]
        control.High()
        displaySegments(bits)
        time.Sleep(SleepAmount)
        control.Low()
    }
}
&nbsp;
func <strong>main</strong>() {
    machine.InitADC()
    adc0 := machine.ADC{Pin: machine.ADC0}
    adc1 := machine.ADC{Pin: machine.ADC1}
    adc2 := machine.ADC{Pin: machine.ADC2}
&nbsp;
    adc0.Configure(machine.ADCConfig{})
    adc1.Configure(machine.ADCConfig{})
    adc2.Configure(machine.ADCConfig{})
&nbsp;
    for {
        var value int32 = 0
        for range 100 {
            value += int32(adc2.Get())
        }
        value /= 700
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Pulsně šířková modulace (PWM)</h2>

<p>Čipy RP2040 i RP2035 jsou vybaveny obvody, které umožňují realizovat
programovatelnou pulsně šířkovou modulaci neboli PWM. Tu lze použít
k&nbsp;mnoha účelům, například pro generování zvuků (bez nutnosti připojení
digitálně-analogového převodníku), ovládání jasu LED, podsvícení připojeného
LCD či VFD (samozřejmě záleží na typu) apod. Pomocí PWM lze řídit vybrané GPIO,
přičemž u RP2040 lze takto řídit 16 GPIO a u RP2035 dokonce 24 GPIO.</p>

<img src="https://i.iinfo.cz/images/131/pc-16-7.webp" class="image-1139215" width="450" height="450" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 8: Pulsní šířková modulace sinusové vlny (červená barva), která
je porovnávána s&nbsp;referenčním trojúhelníkovým signálem (modrá barva).
Výsledný binární signál je zobrazen žlutou barvou.</i></p>

<p>Na obrázcích uvedených v&nbsp;této kapitole je naznačen jeden ze způsobů
převodu analogového signálu (popř.&nbsp;i signálu navzorkovaného) na signál
binární (dvoustavový) pomocí pulsní šířkové modulace. Princip je jednoduchý
&ndash; původní analogový signál je kontinuálně porovnáván
s&nbsp;trojúhelníkovým signálem o vyšší frekvenci, jehož amplituda je shodná
s&nbsp;amplitudou (resp.&nbsp;maximální absolutní hodnotou) původního
analogového signálu. V&nbsp;případě, že je aktuální hodnota původního
modulovaného signálu vyšší, než je hodnota trojúhelníkového referenčního
signálu, je na výstupu vysoká úroveň (většinou kladné napětí), v&nbsp;opačném
případě nízká úroveň (záporné napětí o stejné absolutní hodnotě).</p>

<img src="https://i.iinfo.cz/images/131/pc-16-8.webp" class="image-1139218" width="450" height="450" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 9: Pulsní šířková modulace &ndash; frekvence referenčního
trojúhelníkového signálu je dvojnásobná oproti signálu zobrazeném na čtvrtém
obrázku, výstup by však stále nebyl (při přehrání na reproduktoru) dostatečně
kvalitní.</i></p>

<p>Pokud je pulsní šířková modulace implementována v&nbsp;elektronickém obvodu
(my ovšem budeme vše řídit čistě programově), jsou oba signály porovnávány
pomocí operačního zesilovače, na nějž je zapojený Schmittův klopný obvod, který
zajistí kolmost hran výsledného binárního signálu. Programová implementace je
založena na výpočtu referenčního signálu v&nbsp;diskrétních krocích a jeho
jednoduchém porovnání s&nbsp;původními vzorky.</p>

<img src="https://i.iinfo.cz/images/131/pc-16-9.webp" class="image-1139221" width="450" height="450" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 10: Pulsní šířková modulace &ndash; frekvence referenčního
trojúhelníkového signálu je dvojnásobná oproti signálu zobrazeném na pátém
obrázku.</i></p>

<p>Aby byl výsledek <i>PWM</i> dostatečně kvalitní, je nutné, aby frekvence
trojúhelníkového referenčního signálu byla mnohonásobně vyšší, než frekvence
signálu vstupního. V&nbsp;případě, že se například pomocí PWM převádí
navzorkovaný (digitální) zvuk s&nbsp;určitou vzorkovací frekvencí, je vhodné,
aby frekvence referenčního signálu byla minimálně 10&times; vyšší než frekvence
vzorkovací, což ovšem klade vyšší nároky na přesnost časování při přehrávání
zvuku (tato situace zhruba odpovídá šestému obrázku). Pokud byl například
původní zvuk navzorkován s&nbsp;frekvencí 22 kHz, což odpovídá spíše menší
kvalitě (ztrácí se vyšší slyšitelné frekvence), tak by se měla PWM provádět
s&nbsp;frekvencí 220 kHz.</p>

<img src="https://i.iinfo.cz/images/131/pc-16-10.webp" class="image-1139224" width="450" height="450" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 11: Na tomto grafu je frekvence referenční trojúhelníkové
vlny cca 10&times; vyšší, než frekvence převáděného signálu, což je již pro
mnoho aplikací dostatečné.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Ovládání jasu diody přes PWM</h2>

<pre>
package <strong>main</strong>

import (
    "machine"
    "time"
)

func <strong>main</strong>() {
    pwm0 := machine.PWM0
    pwmPin := machine.GP0
    pwmPin.Configure(machine.PinConfig{Mode: machine.PinPWM})

    pwm0.Configure(machine.PWMConfig{
        Period: 1e9 / 500,
    })

    channel, _ := pwm0.Channel(pwmPin)

    for {
        for divider := 1; divider &lt;= 10; divider++ {
            pwm0.Set(channel, pwm0.Top()/uint32(divider))
            time.Sleep(100 * time.Millisecond)
        }
        for divider := 10; divider &gt;= 1; divider-- {
            pwm0.Set(channel, pwm0.Top()/uint32(divider))
            time.Sleep(100 * time.Millisecond)
        }
    }
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Kontroly prováděné při konfiguraci PWM</h2>

<pre>
package <strong>main</strong>

import (
    "machine"
    "time"
)

func <strong>main</strong>() {
    pwm0 := machine.PWM0
    pwmPin := machine.GP0
    pwmPin.Configure(machine.PinConfig{Mode: machine.PinPWM})

    led := machine.GP2
    led.Configure(machine.PinConfig{Mode: machine.PinOutput})
    led.Low()

    err := pwm0.Configure(machine.PWMConfig{
        Period: 1e9 / 500,
    })
    if err != nil {
        return
    }

    channel, err := pwm0.Channel(pwmPin)
    if err != nil {
        return
    }
    led.High()

    for {
        for divider := 1; divider &lt;= 10; divider++ {
            pwm0.Set(channel, pwm0.Top()/uint32(divider))
            time.Sleep(100 * time.Millisecond)
        }
        for divider := 10; divider &gt;= 1; divider-- {
            pwm0.Set(channel, pwm0.Top()/uint32(divider))
            time.Sleep(100 * time.Millisecond)
        }
    }
}
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář, můžete namísto toho použít odkazy na jednotlivé příklady, které
naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>blink.go</td><td>blikání LED připojenou ke zvolenému GPIO</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/blink.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/blink.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>button1.go</td><td>čtení tlačítka připojeného ke zvolenému GPIO, základní varianta</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/button1.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/button1.go</a></td></tr>
<tr><td> 3</td><td>button2.go</td><td>čtení tlačítka připojeného ke zvolenému GPIO, pojmenované konstanty s&nbsp;GPIO</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/button2.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/button2.go</a></td></tr>
<tr><td> 4</td><td>button3.go</td><td>čtení tlačítka připojeného ke zvolenému GPIO, vylepšení vizualizace stisku tlačítka</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/button3.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/button3.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>7segments1.go</td><td>ovládání sedmisegmentového displeje, základní varianta</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/7segments1.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/7segments1.go</a></td></tr>
<tr><td> 6</td><td>7segments2.go</td><td>ovládání sedmisegmentového displeje s&nbsp;více číslicemi</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/7segments2.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/7segments2.go</a></td></tr>
<tr><td> 7</td><td>7segments3.go</td><td>rozsvícení libovolné kombinace segmentů</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/7segments3.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/7segments3.go</a></td></tr>
<tr><td> 8</td><td>7segments4.go</td><td>tisk hodnoty 0 až 9999  na čtyřmístném sedmisegmentovém displeji</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/7segments4.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/7segments4.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>adc1.go</td><td>analogově digitální převodník: čtení stavu potenciometru s&nbsp;tiskem hodnoty odpovídající jeho natočení, základní varianta</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/adc1.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/adc1.go</a></td></tr>
<tr><td>10</td><td>adc2.go</td><td>čtení stavu potenciometru, varianta méně závislá na šumu ADC</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/adc2.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/adc2.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>pwm1.go</td><td>pulsně šířková modulace: příklad bez detekce chyb</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/pwm1.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/pwm1.go</a></td></tr>
<tr><td>12</td><td>pwm2.go</td><td>pulsně šířková modulace: příklad s&nbsp;detekcí chyb (vizualizováno přes LED)</td><td><a href="https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/pwm2.go">https://github.com/tisnik/go-root/blob/master/tinygo-rp2040/pwm2.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>TinyGo - A Go Compiler For Small Places<br />
<a href="https://tinygo.org/">https://tinygo.org/</a>
</li>

<li>Getting started<br />
<a href="https://tinygo.org/getting-started/">https://tinygo.org/getting-started/</a>
</li>

<li>Go.dev (klasická varianta překladače jazyka Go)<br />
<a href="https://go.dev/">https://go.dev/</a>
</li>

<li>gccgo<br />
<a href="https://gcc.gnu.org/onlinedocs/gccgo/">https://gcc.gnu.org/onlinedocs/gccgo/</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://go.dev/doc/install/gccgo">https://go.dev/doc/install/gccgo</a>
</li>

<li>Awesome Go<br />
<a href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go</a>
</li>

<li>TinyGo: Inline assembly<br />
<a href="https://tinygo.org/docs/concepts/compiler-internals/inline-assembly/">https://tinygo.org/docs/concepts/compiler-internals/inline-assembly/</a>
</li>

<li>Getting Started with TinyGo: Bringing Go to Microcontrollers and WebAssembly<br />
<a href="https://dev.to/ekwoster/getting-started-with-tinygo-bringing-go-to-microcontrollers-and-webassembly-2pp0">https://dev.to/ekwoster/getting-started-with-tinygo-bringing-go-to-microcontrollers-and-webassembly-2pp0</a>
</li>

<li>Optimizing Go code with GCCGO for improved performance<br />
<a href="https://dev.to/parmcoder/optimizing-go-code-with-gccgo-for-improved-performance-2d3d">https://dev.to/parmcoder/optimizing-go-code-with-gccgo-for-improved-performance-2d3d</a>
</li>

<li>The Untold Power of TinyGo: How to Run Go on Microcontrollers and Supercharge Embedded Development<br />
<a href="https://dev.to/ekwoster/the-untold-power-of-tinygo-how-to-run-go-on-microcontrollers-and-supercharge-embedded-development-2g7d">https://dev.to/ekwoster/the-untold-power-of-tinygo-how-to-run-go-on-microcontrollers-and-supercharge-embedded-development-2g7d</a>
</li>

<li>From Arduino to Mars: Why You Should Be Using TinyGo for Embedded Web Development<br />
<a href="https://dev.to/ekwoster/from-arduino-to-mars-why-you-should-be-using-tinygo-for-embedded-web-development-54od">https://dev.to/ekwoster/from-arduino-to-mars-why-you-should-be-using-tinygo-for-embedded-web-development-54od</a>
</li>

<li>Optimizing binaries<br />
<a href="https://tinygo.org/docs/guides/optimizing-binaries/">https://tinygo.org/docs/guides/optimizing-binaries/</a>
</li>

<li>Why TinyGo Might Be the Future of Embedded WebAssembly &amp; How To Get Started Today<br />
<a href="https://ekwoster.dev/post/-why-tinygo-might-be-the-future-of-embedded-webassembly-how-to-get-started-today/">https://ekwoster.dev/post/-why-tinygo-might-be-the-future-of-embedded-webassembly-how-to-get-started-today/</a>
</li>

<li>TinyGo na GitHubu<br />
<a href="https://github.com/tinygo-org/tinygo">https://github.com/tinygo-org/tinygo</a>
</li>

<li>Compile Go directly to WebAssembly components with TinyGo and WASI P2<br />
<a href="https://wasmcloud.com/blog/compile-go-directly-to-webassembly-components-with-tinygo-and-wasi-p2/">https://wasmcloud.com/blog/compile-go-directly-to-webassembly-components-with-tinygo-and-wasi-p2/</a>
</li>

<li>Do you use gccgo?<br />
<a href="https://www.reddit.com/r/golang/comments/j1g1z6/do_you_use_gccgo/">https://www.reddit.com/r/golang/comments/j1g1z6/do_you_use_gccgo/</a>
</li>

<li>Go v/s TinyGo: Which one is the best for you?<br />
<a href="https://blog.nonstopio.com/go-v-s-tinygo-which-one-is-the-best-for-you-73cac3c7849e">https://blog.nonstopio.com/go-v-s-tinygo-which-one-is-the-best-for-you-73cac3c7849e</a>
</li>

<li>Go Wiki: GccgoCrossCompilation<br />
<a href="https://go.dev/wiki/GccgoCrossCompilation">https://go.dev/wiki/GccgoCrossCompilation</a>
</li>

<li>Oficiální stránky Gccgo<br />
<a href="https://gcc.gnu.org/onlinedocs/gccgo/index.html">https://gcc.gnu.org/onlinedocs/gccgo/index.html</a>
</li>

<li>What are the primary differences between 'gc' and 'gccgo'?<br />
<a href="https://stackoverflow.com/questions/25811445/what-are-the-primary-differences-between-gc-and-gccgo">https://stackoverflow.com/questions/25811445/what-are-the-primary-differences-between-gc-and-gccgo</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://go.dev/doc/install/gccgo">https://go.dev/doc/install/gccgo</a>
</li>

<li>Go (Arch Linux)<br />
<a href="https://wiki.archlinux.org/title/Talk:Go">https://wiki.archlinux.org/title/Talk:Go</a>
</li>

<li>Why are binaries built with gccgo smaller (among other differences?)<br />
<a href="https://stackoverflow.com/questions/27067112/why-are-binaries-built-with-gccgo-smaller-among-other-differences">https://stackoverflow.com/questions/27067112/why-are-binaries-built-with-gccgo-smaller-among-other-differences</a>
</li>

<li>Why Everyone Is Sleeping On TinyGo: Run Go on Microcontrollers and the Web (WASM) Today!<br />
<a href="https://ekwoster.dev/post/-why-everyone-is-sleeping-on-tinygo-run-go-on-microcontrollers-and-the-web-wasm-today/">https://ekwoster.dev/post/-why-everyone-is-sleeping-on-tinygo-run-go-on-microcontrollers-and-the-web-wasm-today/</a>
</li>

<li>Go (Golang) GOOS and GOARCH<br />
<a href="https://gist.github.com/asukakenji/f15ba7e588ac42795f421b48b8aede63">https://gist.github.com/asukakenji/f15ba7e588ac42795f421b48b8aede63</a>
</li>

<li>Externí sériové sběrnice SPI a I²C<br />
<a href="https://www.root.cz/clanky/externi-seriove-sbernice-spi-a-i2c/">https://www.root.cz/clanky/externi-seriove-sbernice-spi-a-i2c/</a>
</li>

<li>Sedmisegmentový displej (Wikipedie)<br />
<a href="https://cs.wikipedia.org/wiki/Sedmisegmentov%C3%BD_displej">https://cs.wikipedia.org/wiki/Sedmisegmentov%C3%BD_displej</a>
</li>

<li>A/D převodník (Wikipedie)<br />
<a href="https://cs.wikipedia.org/wiki/A/D_p%C5%99evodn%C3%ADk">https://cs.wikipedia.org/wiki/A/D_p%C5%99evodn%C3%ADk</a>
</li>

<li>D/A převodník (Wikipedie)<br />
<a href="https://cs.wikipedia.org/wiki/D/A_p%C5%99evodn%C3%ADk">https://cs.wikipedia.org/wiki/D/A_p%C5%99evodn%C3%ADk</a>
</li>

<li>Pulzně šířková modulace<br />
<a href="https://cs.wikipedia.org/wiki/Pulzn%C4%9B_%C5%A1%C3%AD%C5%99kov%C3%A1_modulace">https://cs.wikipedia.org/wiki/Pulzn%C4%9B_%C5%A1%C3%AD%C5%99kov%C3%A1_modulace</a>
</li>

<li>TinyGo: Using PWM<br />
<a href="https://tinygo.org/docs/tutorials/pwm/">https://tinygo.org/docs/tutorials/pwm/</a>
</li>

<li>General-purpose input/output<br />
<a href="https://en.wikipedia.org/wiki/General-purpose_input/output">https://en.wikipedia.org/wiki/General-purpose_input/output</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

