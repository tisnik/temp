<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Go a počítačová grafika</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Go a počítačová grafika</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve čtrnácté části seriálu o programovacím jazyku Go si popíšeme balíčky ze základní knihovny určené pro práci s rastrovou grafikou. V první řadě se samozřejmě jedná o zpracování rastrových obrázků společně s možností jejich exportu a importu, k dispozici jsou ovšem i rastrové operace.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Programovací jazyk Go a počítačová grafika</a></p>
<p><a href="#k02">*** 2. Základní rozhraní pro rastrovou grafiku: <strong></strong></a></p>
<p><a href="#k03">*** 3. Inicializace prázdného rastrového obrázku s&nbsp;jeho uložením na disk</a></p>
<p><a href="#k04">*** 4. Vyplnění všech pixelů rastrového obrázku konstantní barvou</a></p>
<p><a href="#k05">*** 5. Alfa kanál: rozdíl mezi formátu RGBA a NRGBA</a></p>
<p><a href="#k06">*** 6. Interní struktura záznamu s&nbsp;rastrovým obrázkem</a></p>
<p><a href="#k07">*** 7. Přímý přístup k&nbsp;poli s&nbsp;pixely rastrového obrázku</a></p>
<p><a href="#k08">*** 8. Třetí varianta využívající řez polem</a></p>
<p><a href="#k09">*** 9. Struktury <strong>Point</strong> a <strong>Rectangle</strong></a></p>
<p><a href="#k10">*** 10. Operace, které jsou strukturami <strong>Point</strong> a <strong>Rectangle</strong> podporovány</a></p>
<p><a href="#k11">*** 11. Barvové prostory RGBA a NRGBA</a></p>
<p><a href="#k12">*** 12. Barvový prostor CMYK</a></p>
<p><a href="#k13">*** 13. Rastrové obrázky s&nbsp;barvovou paletou</a></p>
<p><a href="#k14">*** 14. Balíček <strong>image/draw</strong></a></p>
<p><a href="#k15">*** 15. Základní operace prováděné s&nbsp;dvojicí rastrových obrázků</a></p>
<p><a href="#k16">*** 16. Trik &ndash; vyplnění obrázku konstantní barvou s&nbsp;využitím obrazových operací</a></p>
<p><a href="#k17">*** 17. Vykreslení šachovnice</a></p>
<p><a href="#k18">*** 18. Vykreslení složitějších tvarů do rastrových obrázků</a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Go a počítačová grafika</h2>

<p>Programovací jazyk Go se sice primárně (minimálně v&nbsp;současnosti)
používá pro tvorbu síťových aplikací popř.&nbsp;utilit a služeb, v&nbsp;nichž
je možné využít možností poskytovaných gorutinami a kanály, ovšem můžeme ho
poměrně elegantně využít i při tvorbě (renderingu) a úpravách rastrových
obrázků. Jazyk Go již ve své základní knihovně obsahuje balíček nazvaný
<strong>image</strong>, který je možné pro tyto účely využít. Navíc mají
vývojáři k&nbsp;dispozici i podbalíčky určené pro kódování a dekódování
rastrových obrázků z/do formátů GIF (<i>Graphics Interchange Format</i>), PNG
(<i>Portable Network Graphics</i>) a JPEG (<i>Joint Photographic Experts
Group</i>, přesněji však JFIF, <i>JPEG File Interchange Format</i>),
tj.&nbsp;přesně těch formátů, které jsou používány na webu.</p>

<p>Podrobnější informace o rastrových formátech GIF, PNG a JPEG již byly (nutno
dodat, že v&nbsp;dosti dávné minulosti :-) na Rootu zveřejněny:</p>

<ol>

<li>Případ GIF<br />
<a href="https://www.root.cz/clanky/pripad-gif/">https://www.root.cz/clanky/pripad-gif/</a>
</li>

<li>Pravda a mýty o GIFu<br />
<a href="https://www.root.cz/clanky/pravda-a-myty-o-gifu/">https://www.root.cz/clanky/pravda-a-myty-o-gifu/</a>
</li>

<li>Anatomie grafického formátu GIF<br />
<a href="https://www.root.cz/clanky/anatomie-grafickeho-formatu-gif/">https://www.root.cz/clanky/anatomie-grafickeho-formatu-gif/</a>
</li>

<li>GIF: animace a konkurence<br />
<a href="https://www.root.cz/clanky/gif-animace-a-konkurence/">https://www.root.cz/clanky/gif-animace-a-konkurence/</a>
</li>

<li>PNG is Not GIF<br />
<a href="https://www.root.cz/clanky/png-is-not-gif/">https://www.root.cz/clanky/png-is-not-gif/</a>
</li>

<li>Anatomie grafického formátu PNG<br />
<a href="https://www.root.cz/clanky/anatomie-grafickeho-formatu-png/">https://www.root.cz/clanky/anatomie-grafickeho-formatu-png/</a>
</li>

<li>PNG - bity, byty, chunky<br />
<a href="https://www.root.cz/clanky/png-bity-byty-chunky/">https://www.root.cz/clanky/png-bity-byty-chunky/</a>
</li>

<li>Řádkové filtry v PNG<br />
<a href="https://www.root.cz/clanky/radkove-filtry-v-png/">https://www.root.cz/clanky/radkove-filtry-v-png/</a>
</li>

<li>Nepovinné chunky v PNG a kontrola pomocí CRC<br />
<a href="https://www.root.cz/clanky/nepovinne-chunky-v-png-a-kontrola-pomoci-crc/">https://www.root.cz/clanky/nepovinne-chunky-v-png-a-kontrola-pomoci-crc/</a>
</li>

<li>Finišujeme s PNG - Textové metainformace a kalibrační data<br />
<a href="https://www.root.cz/clanky/finisujeme-s-png-textove-metainformace-a-kalibracni-data/">https://www.root.cz/clanky/finisujeme-s-png-textove-metainformace-a-kalibracni-data/</a>
</li>

<li>JPEG - král rastrových grafických formátů?<br />
<a href="https://www.root.cz/clanky/jpeg-kral-rastrovych-grafickych-formatu/">https://www.root.cz/clanky/jpeg-kral-rastrovych-grafickych-formatu/</a>
</li>

<li>Ztrátová komprese obrazových dat pomocí JPEG<br />
<a href="https://www.root.cz/clanky/ztratova-komprese-obrazovych-dat-pomoci-jpeg/">https://www.root.cz/clanky/ztratova-komprese-obrazovych-dat-pomoci-jpeg/</a>
</li>

<li>Programujeme JPEG: transformace a podvzorkování barev<br />
<a href="https://www.root.cz/clanky/programujeme-jpeg-transformace-a-podvzorkovani-barev/">https://www.root.cz/clanky/programujeme-jpeg-transformace-a-podvzorkovani-barev/</a>
</li>

<li>Programujeme JPEG: diskrétní kosinová transformace (DCT)<br />
<a href="https://www.root.cz/clanky/programujeme-jpeg-diskretni-kosinova-transformace-dct/">https://www.root.cz/clanky/programujeme-jpeg-diskretni-kosinova-transformace-dct/</a>
</li>

<li>Programujeme JPEG: Kvantizace DCT koeficientů<br />
<a href="https://www.root.cz/clanky/programujeme-jpeg-kvantizace-dct-koeficientu/">https://www.root.cz/clanky/programujeme-jpeg-kvantizace-dct-koeficientu/</a>
</li>

<li>Programujeme JPEG: Huffmanovo kódování kvantovaných DCT složek<br />
<a href="https://www.root.cz/clanky/programujeme-jpeg-huffmanovo-kodovani-kvantovanych-dct-slozek/">https://www.root.cz/clanky/programujeme-jpeg-huffmanovo-kodovani-kvantovanych-dct-slozek/</a>
</li>

<li>Programujeme JPEG: Interní struktura souborů typu JFIF/JPEG<br />
<a href="https://www.root.cz/clanky/programujeme-jpeg-interni-struktura-souboru-typu-jfifjpeg/">https://www.root.cz/clanky/programujeme-jpeg-interni-struktura-souboru-typu-jfifjpeg/</a>
</li>

<li>Programujeme JPEG: Načtení informací ze souborů typu JFIF/JPEG<br />
<a href="https://www.root.cz/clanky/programujeme-jpeg-nacteni-informaci-ze-souboru-typu-jfifjpeg/">https://www.root.cz/clanky/programujeme-jpeg-nacteni-informaci-ze-souboru-typu-jfifjpeg/</a>
</li>

<li>Programujeme JPEG: Progresivní JPEG a informace EXIF<br />
<a href="https://www.root.cz/clanky/programujeme-jpeg-progresivni-jpeg-a-informace-exif/">https://www.root.cz/clanky/programujeme-jpeg-progresivni-jpeg-a-informace-exif/</a>
</li>

</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Inicializace prázdného rastrového obrázku s&nbsp;jeho uložením na disk</h2>

<p>V&nbsp;demonstračních příkladech popsaných v&nbsp;navazujících kapitolách
budeme používat takové reprezentace rastrových obrázků, které jsou plně
kompatibilní se základní knihovnou (přesněji řečeno s&nbsp;balíčky základní
knihovny) programovacího jazyka Go. Při použití této knihovny může být samotný
rastrový obrázek reprezentován různými datovými strukturami, například
<strong>RGBA</strong>, <strong>NRGBA</strong>, <strong>CMYK</strong>,
<strong>Gray</strong> atd. &ndash; podle toho, jaký barvový model je použit.
Ovšem nezávisle na tom, o jakou konkrétní datovou strukturu (a tím pádem o jaký
barvový model) se jedná, bude vždy implementováno rozhraní nazvané
<strong>Image</strong>, pro nějž jsou v&nbsp;balíčku <strong>image</strong>
předepsány pouhé tři metody:</p>

<pre>
type <strong>Image</strong> interface {
        ColorModel() color.Model
        Bounds() Rectangle
        At(x, y int) color.Color
}
</pre>

<p>První z&nbsp;těchto metod vrací barvový model použitý pro reprezentaci barev
jednotlivých pixelů v&nbsp;obrázku. Druhá metoda vrací obdélník
(<i>rectangle</i>), kterým se určují okraje (meze) obrázku, přičemž je nutné
upozornit na to, že levý horní roh obdélníku obecně nemusí začínat na
souřadnicích [0, 0], což se týká například jednotlivých snímků použitých
v&nbsp;grafickém formátu GIF ve chvíli, kdy jsou použity animace (jednotlivé
rozdílové snímky jsou obecně menší, než celý obrázek). A konečně poslední
metoda vrací barvu pixelu na souřadnicích [x, y]. Tato metoda je pochopitelně
velmi pomalá, zejména v&nbsp;porovnání s&nbsp;přímým přístupem k&nbsp;polím
bajtů s&nbsp;obsahem jednotlivých pixelů, ovšem na druhou stranu je tato metoda
zcela univerzální a programátor se nemusí zabývat tím, jakým způsobem je
vlastně bitmapa obrázku interně reprezentována.</p>

<p><div class="rs-tip-major">Poznámka: podrobnější informace o tomto rozhraní
získáte, jak je ostatně v&nbsp;ekosystému programovacího jazyka Go obvyklé,
příkazem <strong>godoc</strong>. Syntaxe tohoto příkazu je
následující:</div></p>

<pre>
$ <strong>godoc image Image</strong>
</pre>

<p>Dalším důležitým rozhraním, s&nbsp;nímž se velmi často setkáme, je rozhraní
nazvané <strong>Color</strong>, které je deklarováno v&nbsp;balíčku
<strong>image/color</strong>. Toto rozhraní předepisuje jedinou metodu
<strong>RGBA</strong>, která vrací barvu ve formátu čtveřice R (<i>red</i>), G
(<i>green</i>), B (<i>blue</i>) a A (<i>alpha</i>, průhlednost):</p>

<pre>
type <strong>Color</strong> interface {
        RGBA() (r, g, b, a uint32)
}
</pre>

<p>Zajímavé je, že všechny tři barvové složky i průhlednost jsou vráceny jako
hodnoty typu <strong>uint32</strong>, i když se v&nbsp;běžných rastrových
formátech každá složka ukládá do jediného bajtu. Je tomu tak z&nbsp;toho
důvodu, že barvové složky jsou vynásobeny hodnotou alfa (průhledností) a jejich
hodnoty tedy leží v&nbsp;rozsahu 0 až 65025. Pokud se na dva obrázky aplikují
rastrové operace popsané ve druhé části článku, je zaručeno, že díky rozsahu
datového typu <strong>uint32</strong> (0 až 2<sup>32</sup>-1) nikdy nedojde
k&nbsp;přetečení hodnot barvových složek.</p>

<p><div class="rs-tip-major">Poznámka: rozhraní <strong>Color</strong> vždy
předepisuje metodu <strong>RGBA</strong>, a to nezávisle na tom, jaký barvový
model je použit pro uložení samotného obrázku. Interně tedy bude docházet
k&nbsp;přepočtům barev pixelů (což není vždy zcela přesná operace).</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Inicializace prázdného rastrového obrázku s&nbsp;jeho uložením na disk</h2>

<p>V&nbsp;praktické části článku se nejprve podívejme na způsob inicializace
prázdného rastrového obrázku. Rozlišení obrázku, přesněji řečeno počet
obrazových řádků a počet pixelů na každém obrazovém řádku, bude pro
jednoduchost uloženo v&nbsp;konstantách se jmény <strong>width</strong> a
<strong>height</strong>:</p>

<pre>
const width = 256
const height = 256
</pre>

<p>Dále budeme muset vytvořit a inicializovat datovou strukturu typu
<strong>Rectangle</strong>, v&nbsp;níž bude uložen obdélník určující rozměry
obrázku i jeho umístění v&nbsp;rámci roviny. Pro jednoduchost bude levý horní
roh obdélníku ležet na souřadnicích [<i>0, 0</i>] a pravý dolní roh na
souřadnicích [<i>width, heigh</i>]. Struktura typu <strong>Rectangle</strong>
sice obsahuje dva prvky typu <strong>Point</strong>, takže je inicializace
takové struktury relativně složitá, ovšem namísto toho můžeme použít pomocnou
funkci <strong>Rect()</strong>, které se předají čtyři celočíselné hodnoty
&ndash; souřadnice levého horního rohu a souřadnice pravého dolního rohu.
Inicializace obdélníku tedy bude vypadat takto:</p>

<pre>
r := image.Rect(0, 0, width, height))
</pre>

<p><div class="rs-tip-major">Poznámka: datová struktura
<strong>Rectangle</strong> bude podrobněji popsána <a href="#k08">v&nbsp;osmé
kapitole</a>.</div></p>

<p>Nyní již máme připraveno vše potřebné pro vytvoření prázdného obrázku,
resp.&nbsp;přesněji řečeno takového obrázku, v&nbsp;němž budou jednotlivé
pixely obsahovat barvu (<i>0, 0, 0, 0</i>), protože kromě barvových složek R,
G, B musíme správně nastavit i průhlednost, neboli alfa kanál. Prázdný obrázek
vytvoříme jednoduše:</p>

<pre>
img := image.NewRGBA(r)
</pre>

<p>Prozatím sice neumíme obrázek přímo zobrazit na displeji, ale dokážeme ho
velmi snadno uložit například do souboru typu PNG. Nejprve otevřeme soubor
pojmenovaný &bdquo;01.png&ldquo; pro zápis a poté využijeme možnosti
poskytované balíčkem <strong>image/png</strong> pro zakódování obrázku do
formátu PNG::</p>

<pre>
outfile, err := os.Create("01.png")
if err != nil {
        panic(err)
}
defer outfile.Close()
png.Encode(outfile, img)
</pre>

<p>To je vše &ndash; úplný zdrojový kód dnešního prvního demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/go-fedora/blob/master/article_14/01_empty_image.go">https://github.com/tisnik/go-fedora/blob/master/article_14/01_empty_image.go</a>:</p>

<pre>
package main
&nbsp;
import (
        "image"
        "image/png"
        "os"
)
&nbsp;
const width = 256
const height = 256
&nbsp;
func <strong>main</strong>() {
        img := image.NewRGBA(image.Rect(0, 0, width, height))
&nbsp;
        outfile, err := os.Create("01.png")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()
        png.Encode(outfile, img)
}
</pre>

<p>Povšimněte si, že obrázek obsahuje bitmapu o rozměrech 256&times;256 pixelů,
které jsou průhledné (a mají černou barvu, to však kvůli průhlednosti
nevidíme). To je výchozí chování datového typu <strong>NewRGBA</strong>.</p>

*** image ***
<p><i>Obrázek 1: Výsledek prvního demonstračního příkladu. Všechny pixely jsou ve skutečnosti průhledné &ndash; šachovnice je výsledkem zobrazení bitmapy v&nbsp;prohlížeči obrázků.</i></p>

<p>Alternativně samozřejmě můžeme <a
href="https://github.com/tisnik/go-fedora/blob/master/article_14/02_empty_image_rectangle.go">příklad
přepsat</a> takovým způsobem, aby se datová struktura
<strong>Rectangle</strong> vytvořila přímo &bdquo;konstruktorem&ldquo; struktur
(zápis se složenými závorkami):</p>

<pre>
package main
&nbsp;
import (
        "image"
        "image/png"
        "os"
)
&nbsp;
const width = 256
const height = 256
&nbsp;
func main() {
        rect := image.Rectangle{image.Point{0, 0},
                                image.Point{width, height}}
&nbsp;
        img := image.NewNRGBA(rect)
&nbsp;
        outfile, err := os.Create("02.png")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()
        png.Encode(outfile, img)
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vyplnění všech pixelů rastrového obrázku konstantní barvou</h2>

<p>První manipulací s&nbsp;obsahem rastrového obrázku, s&nbsp;níž se dnes
seznámíme, bude vyplnění všech pixelů bitmapy nějakou barvou. Prozatím budeme
používat barvový model RGBA. Pro tento datový typ existuje metoda určená pro
změnu barvy pixelu. Tato metoda se jmenuje příznačně <strong>SetRGBA</strong> a
její hlavička vypadá následovně:</p>

<pre>
func (p *RGBA) SetRGBA(x, y int, c color.RGBA)
</pre>

<p>Této metodě se předávají tři parametry:</p>

<ol>

<li>x-ová souřadnice pixelu</li>

<li>y-ová souřadnice pixelu</li>

<li>barva pixelu, což je struktura typu <strong>color.RGBA</strong>
(<strong>color</strong> je neúplné jméno balíčku <strong>image/color</strong>),
v&nbsp;němž je každá barvová komponenta reprezentována jediným bajtem (tak, jak
jsme zvyklí z&nbsp;většiny grafických knihoven)</li>

</ol>

<p>Tato struktura je deklarována následujícím způsobem:</p>

<pre>
type <strong>RGBA</strong> struct {
        R, G, B, A uint8
}
</pre>

<p>Strukturu <strong>RGBA</strong> naplníme naprosto stejným způsobem, jako
jakýkoli jiný záznam. Nastavíme přitom čistě zelenou barvu, která bude
neprůhledná (poslední hodnota 255 určuje neprůhlednost pixelů):</p>

<pre>
c := color.RGBA{0, 255, 0, 255}
</pre>

<p>Jakmile máme připravenou barvu pixelů, můžeme jí vyplnit všechny pixely
tvořící rastrový obrázek:</p>

<pre>
for x := 0; x &lt; width; x++ {
        for y := 0; y &lt; height; y++ {
                img.SetRGBA(x, y, c)
        }
}
</pre>

<p><div class="rs-tip-major">Poznámka: tento program bude poměrně pomalý, což
sice u obrázku s&nbsp;rozlišením 256&times;256 pixelů nebude příliš patrné, ale
u obrázků s&nbsp;větším rozlišením je většinou lepší použít nízkoúrovňový
přístup popsaný v&nbsp;dalších kapitolách.</div></p>

<p><a
href="https://github.com/tisnik/go-fedora/blob/master/article_14/03_filled_image_setrgba.go">Úplný
zdrojový kód tohoto příkladu</a> vypadá následovně:</p>

<pre>
package main
&nbsp;
import (
        "image"
        "image/color"
        "image/png"
        "os"
)
&nbsp;
const width = 256
const height = 256
&nbsp;
func <strong>main</strong>() {
        img := image.NewRGBA(image.Rect(0, 0, width, height))
&nbsp;
        outfile, err := os.Create("03.png")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()
&nbsp;
        c := color.RGBA{0, 255, 0, 255}
        for x := 0; x &lt; width; x++ {
                for y := 0; y &lt; height; y++ {
                        img.SetRGBA(x, y, c)
                }
        }
        png.Encode(outfile, img)
}
</pre>

*** image ***
<p><i>Obrázek 2: Výsledek běhu demonstračního příkladu, v&nbsp;němž jsou pixely
vybarveny metodou <strong>SetRGBA</strong>.</i></p>

<p>I tento příklad je možné nepatrně modifikovat, a to takovým způsobem, že se
namísto metody <strong>SetRGBA</strong>, která je přímo navázána na barvový
prostor RGBA, použije univerzální metoda <strong>Set</strong>, jíž se opět
předají souřadnice pixelu a jeho barva. Výsledkem je <a
href="https://github.com/tisnik/go-fedora/blob/master/article_14/04_filled_image_set.go">program</a>,
v&nbsp;němž je změna barvového prostoru přeci jen snazší:</p>

<pre>
package main
&nbsp;
import (
        "image"
        "image/color"
        "image/png"
        "os"
)
&nbsp;
const width = 256
const height = 256
&nbsp;
func <strong>main</strong>() {
        img := image.NewRGBA(image.Rect(0, 0, width, height))
&nbsp;
        outfile, err := os.Create("04.png")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()
&nbsp;
        c := color.RGBA{0, 255, 0, 255}
        for x := 0; x &lt; width; x++ {
                for y := 0; y &lt; height; y++ {
                        img.Set(x, y, c)
                }
        }
        png.Encode(outfile, img)
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Alfa kanál: rozdíl mezi formátu RGBA a NRGBA</h2>

<p>Nyní si vyzkoušejme zdrojový kód předchozích příkladů nepatrně upravit, a to
takovým způsobem, že barva všech pixelů sice bude stále čistě zelená, ovšem
průhlednost se bude měnit v&nbsp;horizontálním směru od 0 (zcela průhledná) do
255 (zcela neprůhledná). Barva tedy bude vytvářena uvnitř vnější programové
smyčky:</p>

<pre>
for x := 0; x &lt; width; x++ {
        alpha := byte(x)
        c := color.RGBA{0, 255, 0, alpha}
        for y := 0; y &lt; height; y++ {
                img.SetRGBA(x, y, c)
        }
}
</pre>

<p>Opět si samozřejmě ukážeme, jak byla tato změna zakomponována do <a
href="https://github.com/tisnik/go-fedora/blob/master/article_14/05_filled_image_alpha.go">úplného
demonstračního příkladu</a>:</p>

<pre>
package main
&nbsp;
import (
        "image"
        "image/color"
        "image/png"
        "os"
)
&nbsp;
const width = 256
const height = 256
&nbsp;
func <strong>main</strong>() {
        img := image.NewRGBA(image.Rect(0, 0, width, height))
&nbsp;
        outfile, err := os.Create("05.png")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()
&nbsp;
        for x := 0; x &lt; width; x++ {
                alpha := byte(x)
                c := color.RGBA{0, 255, 0, alpha}
                for y := 0; y &lt; height; y++ {
                        img.SetRGBA(x, y, c)
                }
        }
        png.Encode(outfile, img)
}
</pre>

<p></p>

*** image ***
<p><i>Obrázek 3: Výsledek činnosti předchozího příkladu. Povšimněte si, že
průhlednost &ndash; oproti očekávání &ndash; neroste lineárně od levého okraje
k&nbsp;okraji pravému.</i></p>

<p></p>

<pre>
package main
&nbsp;
import (
        "image"
        "image/color"
        "image/png"
        "os"
)
&nbsp;
const width = 256
const height = 256
&nbsp;
func <strong>main</strong>() {
        img := image.NewNRGBA(image.Rect(0, 0, width, height))
&nbsp;
        outfile, err := os.Create("06.png")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()
&nbsp;
        for x := 0; x &lt; width; x++ {
                alpha := byte(x)
                c := color.NRGBA{0, 255, 0, alpha}
                for y := 0; y &lt; height; y++ {
                        img.SetNRGBA(x, y, c)
                }
        }
        png.Encode(outfile, img)
}
</pre>

*** image ***
<p><i>Obrázek 4: Upravený příklad využívající barvový model NRGBA již dává
korektní výsledky.</i></p>

<pre>
package main
&nbsp;
import (
        "image"
        "image/color"
        "image/png"
        "os"
)
&nbsp;
const width = 256
const height = 256
&nbsp;
func <strong>main</strong>() {
        img := image.NewNRGBA(image.Rect(0, 0, width, height))
&nbsp;
        outfile, err := os.Create("07.png")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()
&nbsp;
        for x := 0; x &lt; width; x++ {
                alpha := byte(x)
                c := color.NRGBA{0, 255, 0, alpha}
                for y := 0; y &lt; height; y++ {
                        img.Set(x, y, c)
                }
        }
        png.Encode(outfile, img)
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Interní struktura záznamu s&nbsp;rastrovým obrázkem</h2>

<p></p>

<pre>
type <strong>RGBA</strong> struct {
        Pix []uint8
        Stride int
        Rect Rectangle
}
</pre>

<p></p>

<pre>
type <strong>NRGBA</strong> struct {
        Pix []uint8
        Stride int
        Rect Rectangle
</pre>

<p></p>

<pre>
type <strong>RGBA64</strong> struct {
        Pix []uint8
        Stride int
        Rect Rectangle
}
</pre>

<p></p>

<pre>
package main
&nbsp;
import (
        "image"
)
&nbsp;
const width = 256
const height = 256
&nbsp;
func <strong>main</strong>() {
        img := image.NewNRGBA(image.Rect(0, 0, width, height))
        println("Stride: ", img.Stride)
        println("[]byte: ", len(img.Pix))
        r := img.Rect
        println("Rectangle:")
        println("    point 1: ", r.Min.X, r.Min.Y)
        println("    point 2: ", r.Max.X, r.Max.Y)
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Přímý přístup k&nbsp;poli s&nbsp;pixely rastrového obrázku</h2>

<p></p>

<pre>
package main
&nbsp;
import (
        "image"
        "image/png"
        "os"
)
&nbsp;
const width = 256
const height = 256
&nbsp;
func <strong>main</strong>() {
        img := image.NewNRGBA(image.Rect(0, 0, width, height))
&nbsp;
        outfile, err := os.Create("06.png")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()
&nbsp;
        for y := 0; y &lt; height; y++ {
                index := img.Stride * y
                for x := 0; x &lt; width; x++ {
                        img.Pix[index] = 0
                        index++
                        img.Pix[index] = 0
                        index++
                        img.Pix[index] = 255
                        index++
                        img.Pix[index] = byte(x)
                        index++
                }
        }
        png.Encode(outfile, img)
}
</pre>

*** image ***
<p><i>Obrázek 5: </i></p>

<p></p>

<pre>
package main
&nbsp;
import (
        "image"
        "image/png"
        "os"
)
&nbsp;
const width = 256
const height = 256
&nbsp;
func <strong>main</strong>() {
        img := image.NewNRGBA(image.Rect(0, 0, width, height))
&nbsp;
        outfile, err := os.Create("07.png")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()
&nbsp;
        for y := 0; y &lt; height; y++ {
                index := img.PixOffset(0, y)
                for x := 0; x &lt; width; x++ {
                        img.Pix[index] = 0
                        index++
                        img.Pix[index] = 0
                        index++
                        img.Pix[index] = 255
                        index++
                        img.Pix[index] = byte(x)
                        index++
                }
        }
        png.Encode(outfile, img)
}
</pre>

*** image ***
<p><i>Obrázek 6: </i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Třetí varianta využívající řez polem</h2>

<p></p>

<pre>
package main
&nbsp;
import (
        "image"
        "image/png"
        "os"
)
&nbsp;
const width = 256
const height = 256
&nbsp;
func <strong>main</strong>() {
        img := image.NewNRGBA(image.Rect(0, 0, width, height))
&nbsp;
        outfile, err := os.Create("08.png")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()
&nbsp;
        for y := 0; y &lt; height; y++ {
                scanline := img.Pix[img.Stride*y:]
                i := 0
                for x := 0; x &lt; width; x++ {
                        scanline[i] = 0
                        i++
                        scanline[i] = byte(y)
                        i++
                        scanline[i] = 255
                        i++
                        scanline[i] = byte(x)
                        i++
                }
        }
        png.Encode(outfile, img)
}
</pre>

*** image ***
<p><i>Obrázek 7: </i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Struktury <strong>Point</strong> a <strong>Rectangle</strong></h2>

<p></p>

<pre>
type <strong>Point</strong> struct {
        X, Y int
}
</pre>

<p></p>

<pre>
type <strong>Rectangle</strong> struct {
        Min, Max Point
}
</pre>

<p></p>

<pre>
package main
&nbsp;
import (
        "image"
)
&nbsp;
func <strong>main</strong>() {
        point1 := image.Pt(10, 10)
        point2 := image.Point{10, 10}
&nbsp;
        rectangle1 := image.Rect(0, 0, 320, 240)
        rectangle2 := image.Rectangle{image.Point{0, 0}, image.Point{320, 240}}
&nbsp;
        println(point1.String())
        println(point2.String())
&nbsp;
        println(rectangle1.String())
        println(rectangle2.String())
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Operace, které jsou strukturami <strong>Point</strong> a <strong>Rectangle</strong> podporovány</h2>

<p></p>

<pre>
package main
&nbsp;
import (
        "image"
)
&nbsp;
func <strong>main</strong>() {
        point1 := image.Pt(10, 10)
        point2 := image.Pt(1000, 10)
&nbsp;
        rectangle1 := image.Rect(0, 0, 200, 200)
        rectangle2 := image.Rect(100, 100, 300, 300)
        rectangle3 := image.Rect(300, 300, 400, 400)
&nbsp;
        println(point1.In(rectangle1))
        println(point2.In(rectangle1))
&nbsp;
        println(rectangle1.Union(rectangle2).String())
        println(rectangle1.Intersect(rectangle2).String())
&nbsp;
        println(rectangle1.Overlaps(rectangle2))
        println(rectangle1.Overlaps(rectangle3))
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Barvové prostory RGBA a NRGBA</h2>

<p></p>

<pre>
package main
&nbsp;
import (
        "image"
        "image/color"
        "image/png"
        "os"
)
&nbsp;
const width = 512
const height = 512
&nbsp;
func <strong>main</strong>() {
        img := image.NewNRGBA(image.Rect(0, 0, width, height))
&nbsp;
        outfile, err := os.Create("10.png")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()
&nbsp;
        for x := 0; x &lt; 256; x++ {
                for y := 0; y &lt; 256; y++ {
                        c := color.NRGBA{0, byte(x), byte(y), 255}
                        img.SetNRGBA(x, y, c)
&nbsp;
                        c = color.NRGBA{85, byte(x), byte(y), 255}
                        img.SetNRGBA(x+256, y, c)
&nbsp;
                        c = color.NRGBA{170, byte(x), byte(y), 255}
                        img.SetNRGBA(x, y+256, c)
&nbsp;
                        c = color.NRGBA{255, byte(x), byte(y), 255}
                        img.SetNRGBA(x+256, y+256, c)
                }
        }
        png.Encode(outfile, img)
}
</pre>

*** image ***
<p><i>Obrázek 8: </i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Barvový prostor CMYK</h2>

<p>V&nbsp;předchozích demonstračních příkladech jsme používali barvový prostor RGBA popř.&nbsp;NRGBA. Tento barvový prostor je v&nbsp;praxi používán velmi často, mj.&nbsp;i proto, že jednotlivé barvové složky R, G, B přímo odpovídají způsobům zobrazení pixelů na displejích (hodnoty barvových složek se sčítají). Ovšem při přípravě barevných obrázků pro tisk je prostor RGBA či NRGBA nevýhodný, neboť barevný soutisk je prováděn zcela odlišnou technikou &ndash; odečítám barev od barvy papíru (každá natištěná barva funguje jako filtr určité části barvového spektra). Z&nbsp;tohoto důvodu se při přípravě grafiky pro tisk používá barvový model CMY () a tiskárny (většinou) obsahují tonery či inkousty právě těchto barev. Z&nbsp;praktických důvodů jsou tyto tři barvy doplněny ještě o barvu černou &ndash; vede to jak k&nbsp;ušetření barev při tisku textů a obrázků v&nbsp;odstínech šedi, tak i k&nbsp;možnosti tisku skutečně černou barvou. Výsledkem je barvový model či barvový prostor CMYK ().</p>

<p>I s&nbsp;tímto barvovým prostorem je možné v&nbsp;programovacím jazyku Go pracovat a prakticky stejným způsobem, jako tomu bylo u modelů RGBA a NRGBA. Obrázek s&nbsp;barvami pixelů reprezentovaných v&nbsp;modelu CMYK je představován strukturou/záznamem se jménem <strong>CMYK</strong>:</p>

<pre>
type <strong>CMYK</strong> struct {
        Pix []uint8
        Stride int
        Rect Rectangle
}
</pre>

<p>Pro vytvoření nového obrázku, který odpovídá tomuto barvovému modelu, je možné použít konstruktor <strong>NewCMYK()</strong>, který akceptuje stejné parametry jako nám již známé konstruktory <strong>NewRGBA()</strong> a <strong>NewNRGBA()</strong>:</p>

<pre>
img := image.NewCMYK(image.Rect(0, 0, width, height))
</pre>

<p>Barva v&nbsp;barvovém modelu CMYK je reprezentována strukturou <strong>color.CMYK</strong>, kterou je možné nastavit zcela běžným způsobem:</p>

<pre>
c := color.CMYK{c, m, y, k}
</pre>

<p>Další práce s&nbsp;obrázkem, například jeho vyplnění pixely s&nbsp;různou barvou, je již prakticky stejné, jako ve všech předchozích příkladech. V&nbsp;dalším úryvku kódu vyplníme obrázek o rozlišení 512&times;512 pixelů čtyřmi podoblastmi, v&nbsp;nichž každé bude jiný barvový přechod (<i>gradient</i>); to vše vypočtené v&nbsp;barvovém prostoru CMYK:</p>

<pre>
for x := 0; x &lt; 256; x++ {
        for y := 0; y &lt; 256; y++ {
                c := color.CMYK{byte(x), 0, 0, 0}
                img.SetCMYK(x, y, c)
&nbsp;
                c = color.CMYK{0, byte(x), 0, 0}
                img.SetCMYK(x+256, y, c)
&nbsp;
                c = color.CMYK{0, 0, byte(x), 0}
                img.SetCMYK(x, y+256, c)
&nbsp;
                c = color.CMYK{0, 0, 0, byte(x)}
                img.SetCMYK(x+256, y+256, c)
        }
}
</pre>

<pre>
package main
&nbsp;
import (
        "image"
        "image/color"
        "image/png"
        "os"
)
&nbsp;
const width = 512
const height = 512
&nbsp;
func <strong>main</strong>() {
        img := image.NewCMYK(image.Rect(0, 0, width, height))
&nbsp;
        outfile, err := os.Create("11.png")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()
&nbsp;
        for x := 0; x &lt; 256; x++ {
                for y := 0; y &lt; 256; y++ {
                        c := color.CMYK{byte(x), 0, 0, 0}
                        img.SetCMYK(x, y, c)
&nbsp;
                        c = color.CMYK{0, byte(x), 0, 0}
                        img.SetCMYK(x+256, y, c)
&nbsp;
                        c = color.CMYK{0, 0, byte(x), 0}
                        img.SetCMYK(x, y+256, c)
&nbsp;
                        c = color.CMYK{0, 0, 0, byte(x)}
                        img.SetCMYK(x+256, y+256, c)
                }
        }
        png.Encode(outfile, img)
}
</pre>

*** image ***
<p><i>Obrázek 9: </i></p>

<p></p>

<pre>
package main
&nbsp;
import (
        "image"
        "image/color"
        "image/png"
        "os"
)
&nbsp;
const width = 512
const height = 512
&nbsp;
func <strong>main</strong>() {
        img := image.NewCMYK(image.Rect(0, 0, width, height))
&nbsp;
        outfile, err := os.Create("12.png")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()
&nbsp;
        for x := 0; x &lt; 256; x++ {
                for y := 0; y &lt; 256; y++ {
                        c := color.CMYK{byte(x), 0, 0, 127}
                        img.SetCMYK(x, y, c)
&nbsp;
                        c = color.CMYK{0, byte(x), 0, 127}
                        img.SetCMYK(x+256, y, c)
&nbsp;
                        c = color.CMYK{0, 0, byte(x), 127}
                        img.SetCMYK(x, y+256, c)
&nbsp;
                        c = color.CMYK{0, byte(y), 0, byte(x)}
                        img.SetCMYK(x+256, y+256, c)
                }
        }
        png.Encode(outfile, img)
}
</pre>

*** image ***
<p><i>Obrázek 10: </i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Rastrové obrázky s&nbsp;barvovou paletou</h2>

<p></p>

<pre>
var MyPalette = []color.Color{
    color.RGBA{0x00, 0x00, 0x00, 0xff},
    color.RGBA{0x00, 0x00, 0x44, 0xff},
    color.RGBA{0x00, 0x00, 0x88, 0xff},
    ...
    ...
    ...
}
</pre>

<p></p>

<pre>
type Palette []Color
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Balíček <strong>image/draw</strong></h2>

<p>Dalším balíčkem, s&nbsp;nímž se dnes alespoň ve stručnosti seznámíme, se jmenuje <strong>image/draw</strong>. Název tohoto balíčku může být možná poněkud matoucí, protože v&nbsp;něm ve skutečnosti nenajdeme funkce pro kreslení nějakých geometrických tvarů či textů do rastrových obrázků. Balíček <strong>image/draw</strong> totiž obsahuje implementaci operací prováděných mezi dvěma obrázky &ndash; tyto operace se někdy nazývají <i>kompozice</i>, protože se zdrojový (<i>source</i>) obrázek pixel po pixelu aplikuje na obrázek cílový (<i>target</i>).</p>

<pre>
type <strong>Drawer</strong> interface {
    Draw(dst Image, r image.Rectangle, src image.Image, sp image.Point)
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Základní operace prováděné s&nbsp;dvojicí rastrových obrázků</h2>

<p></p>

<table>
<tr><th>#</th><th></th><th></th><th></th></tr>
<tr><td>1</td><td></td><td></td><td></td></tr>
<tr><td>2</td><td></td><td></td><td></td></tr>
<tr><td>3</td><td></td><td></td><td></td></tr>
<tr><td>4</td><td></td><td></td><td></td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Trik &ndash; vyplnění obrázku konstantní barvou s&nbsp;využitím obrazových operací</h2>

<p></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Vykreslení šachovnice</h2>

<p></p>

<pre>
package main
&nbsp;
import (
        "image"
        "image/color"
        "image/draw"
        "image/png"
        "os"
)
&nbsp;
const width = 256
const height = 256
&nbsp;
func main() {
        img := image.NewCMYK(image.Rect(0, 0, width, height))
&nbsp;
        outfile, err := os.Create("17.png")
        if err != nil {
                panic(err)
        }
        defer outfile.Close()
&nbsp;
        palette := make(map[int]color.RGBA, 2)
&nbsp;
        palette[0] = color.RGBA{150, 205, 50, 255}
        palette[1] = color.RGBA{0, 100, 0, 255}
&nbsp;
        index_color := 0
        board_size := 8
        hor_block := int(width / board_size)
        ver_block := int(height / board_size)
&nbsp;
        x_from := 0
        x_to := hor_block
        for x := 0; x &lt; board_size; x++ {
                y_from := 0
                y_to := ver_block
                for y := 0; y &lt; board_size; y++ {
                        r := image.Rect(x_from, y_from, x_to, y_to)
                        draw.Draw(img, r, &amp;image.Uniform{palette[index_color]}, image.ZP, draw.Src)
                        y_from = y_to
                        y_to += ver_block
                        index_color = 1 - index_color
                }
                x_from = x_to
                x_to += hor_block
                index_color = 1 - index_color
        }
        png.Encode(outfile, img)
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Vykreslení složitějších tvarů do rastrových obrázků</h2>

<p></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně jeden megabajt), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_empty_image.go</td><td>vytvoření rastrového obrázku s&nbsp;výchozími hodnotami pixelů (zcela průhledné černé pixely)</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/01_empty_image.go">https://github.com/tisnik/go-fedora/blob/master/article_14/01_empty_image.go</a></td></tr>
<tr><td> 2</td><td>02_empty_image_rectangle.go</td><td>alternativní způsob vytvoření obdélníku pro určení rozměrů obrázku</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/02_empty_image_rectangle.go">https://github.com/tisnik/go-fedora/blob/master/article_14/02_empty_image_rectangle.go</a></td></tr>
<tr><td> 3</td><td>03_filled_image_setrgba.go</td><td>rastrový obrázek vyplněný konstantní barvou, použití metody SetRGBA</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/03_filled_image_setrgba.go">https://github.com/tisnik/go-fedora/blob/master/article_14/03_filled_image_setrgba.go</a></td></tr>
<tr><td> 4</td><td>04_filled_image_set.go</td><td>rastrový obrázek vyplněný konstantní barvou, použití metody Set</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/04_filled_image_set.go">https://github.com/tisnik/go-fedora/blob/master/article_14/04_filled_image_set.go</a></td></tr>

<tr><td> 5</td><td>05_filled_image_alpha.go</td><td>obrázek, v&nbsp;němž mají pixely různou průhlednost (nekorektní varianta)</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/05_filled_image_alpha.go">https://github.com/tisnik/go-fedora/blob/master/article_14/05_filled_image_alpha.go</a></td></tr>
<tr><td> 6</td><td>06_filled_image_alpha_correct.go</td><td>korektní varianta předchozího příkladu</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/06_filled_image_alpha_correct.go">https://github.com/tisnik/go-fedora/blob/master/article_14/06_filled_image_alpha_correct.go</a></td></tr>
<tr><td> 7</td><td>07_filled_image_alpha_correct.go</td><td>vylepšená varianta předchozího příkladu</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/07_filled_image_alpha_correct.go">https://github.com/tisnik/go-fedora/blob/master/article_14/07_filled_image_alpha_correct.go</a></td></tr>
<tr><td> 8</td><td>08_image_internals.go</td><td>interní struktura záznamu s&nbsp;informacemi o obrázku</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/08_image_internals.go">https://github.com/tisnik/go-fedora/blob/master/article_14/08_image_internals.go</a></td></tr>
<tr><td> 9</td><td>09_raw_pixels.go</td><td>přímý přístup k&nbsp;jednotlivým pixelům; první varianta</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/09_raw_pixels.go">https://github.com/tisnik/go-fedora/blob/master/article_14/09_raw_pixels.go</a></td></tr>
<tr><td>10</td><td>10_raw_pixels2.go</td><td>přímý přístup k&nbsp;jednotlivým pixelům; druhá varianta</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/10_raw_pixels2.go">https://github.com/tisnik/go-fedora/blob/master/article_14/10_raw_pixels2.go</a></td></tr>
<tr><td>11</td><td>11_raw_pixels3.go</td><td>přímý přístup k&nbsp;jednotlivým pixelům; třetí varianta</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/11_raw_pixels3.go">https://github.com/tisnik/go-fedora/blob/master/article_14/11_raw_pixels3.go</a></td></tr>
<tr><td>12</td><td>12_point_rectangle.go</td><td>datové struktury <strong>Point</strong> a <strong>Rectangle</strong></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/12_point_rectangle.go">https://github.com/tisnik/go-fedora/blob/master/article_14/12_point_rectangle.go</a></td></tr>
<tr><td>13</td><td>13_point_rectangle_operations.go</td><td>základní operace s&nbsp;obdélníky a body</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/13_point_rectangle_operations.go">https://github.com/tisnik/go-fedora/blob/master/article_14/13_point_rectangle_operations.go</a></td></tr>
<tr><td>14</td><td>14_rgba_images.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/14_rgba_images.go">https://github.com/tisnik/go-fedora/blob/master/article_14/14_rgba_images.go</a></td></tr>
<tr><td>15</td><td>15_cmyk_images.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/15_cmyk_images.go">https://github.com/tisnik/go-fedora/blob/master/article_14/15_cmyk_images.go</a></td></tr>
<tr><td>16</td><td>16_cmyk_images.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/16_cmyk_images.go">https://github.com/tisnik/go-fedora/blob/master/article_14/16_cmyk_images.go</a></td></tr>
<tr><td>17</td><td>17_chessboard.go</td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_14/17_chessboard.go">https://github.com/tisnik/go-fedora/blob/master/article_14/17_chessboard.go</a></td></tr>
<tr><td>18</td><td></td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_16/">https://github.com/tisnik/go-fedora/blob/master/article_16/</a></td></tr>
<tr><td>19</td><td></td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_16/">https://github.com/tisnik/go-fedora/blob/master/article_16/</a></td></tr>
<tr><td>20</td><td></td><td></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_16/">https://github.com/tisnik/go-fedora/blob/master/article_16/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Go image package<br />
<a href="https://blog.golang.org/go-image-package">https://blog.golang.org/go-image-package</a>
</li>

<li>Balíček draw2D: 2D rendering for different output (raster, pdf, svg)<br />
<a href="https://github.com/llgcode/draw2d">https://github.com/llgcode/draw2d</a>
</li>

<li>Draw a rectangle in Golang?<br />
<a href="https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang">https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang</a>
</li>

<li>YAML<br />
<a href="https://yaml.org/">https://yaml.org/</a>
</li>

<li>edn<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Smile<br />
<a href="https://github.com/FasterXML/smile-format-specification">https://github.com/FasterXML/smile-format-specification</a>
</li>

<li>Protocol-Buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>Marshalling (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
</li>

<li>Unmarshalling<br />
<a href="https://en.wikipedia.org/wiki/Unmarshalling">https://en.wikipedia.org/wiki/Unmarshalling</a>
</li>

<li>Introducing JSON<br />
<a href="http://json.org/">http://json.org/</a>
</li>

<li>Package json<br />
<a href="https://golang.org/pkg/encoding/json/">https://golang.org/pkg/encoding/json/</a>
</li>

<li>The Go Blog: JSON and Go<br />
<a href="https://blog.golang.org/json-and-go">https://blog.golang.org/json-and-go</a>
</li>

<li>Go by Example: JSON<br />
<a href="https://gobyexample.com/json">https://gobyexample.com/json</a>
</li>

<li>Writing Web Applications<br />
<a href="https://golang.org/doc/articles/wiki/">https://golang.org/doc/articles/wiki/</a>
</li>

<li>Golang Web Apps<br />
<a href="https://www.reinbach.com/blog/golang-webapps-1/">https://www.reinbach.com/blog/golang-webapps-1/</a>
</li>

<li>Build web application with Golang<br />
<a href="https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details">https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details</a>
</li>

<li>Golang Templates - Golang Web Pages<br />
<a href="https://www.youtube.com/watch?v=TkNIETmF-RU">https://www.youtube.com/watch?v=TkNIETmF-RU</a>
</li>

<li>Simple Golang HTTPS/TLS Examples<br />
<a href="https://github.com/denji/golang-tls">https://github.com/denji/golang-tls</a>
</li>

<li>Playing with images in HTTP response in golang<br />
<a href="https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang">https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang</a>
</li>

<li>MIME Types List<br />
<a href="https://www.freeformatter.com/mime-types-list.html">https://www.freeformatter.com/mime-types-list.html</a>
</li>

<li>Go Mutex Tutorial<br />
<a href="https://tutorialedge.net/golang/go-mutex-tutorial/">https://tutorialedge.net/golang/go-mutex-tutorial/</a>
</li>

<li>Creating A Simple Web Server With Golang<br />
<a href="https://tutorialedge.net/golang/creating-simple-web-server-with-golang/">https://tutorialedge.net/golang/creating-simple-web-server-with-golang/</a>
</li>

<li>Building a Web Server in Go<br />
<a href="https://thenewstack.io/building-a-web-server-in-go/">https://thenewstack.io/building-a-web-server-in-go/</a>
</li>

<li>How big is the pipe buffer?<br />
<a href="https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer">https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer</a>
</li>

<li>How to turn off buffering of stdout in C<br />
<a href="https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c">https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c</a>
</li>

<li>setbuf(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/setbuf">https://linux.die.net/man/3/setbuf</a>
</li>

<li>setvbuf(3) - Linux man page (stejný obsah jako předchozí stránka)<br />
<a href="https://linux.die.net/man/3/setvbuf">https://linux.die.net/man/3/setvbuf</a>
</li>

<li>Select waits on a group of channels<br />
<a href="https://yourbasic.org/golang/select-explained/">https://yourbasic.org/golang/select-explained/</a>
</li>

<li>Rob Pike: Simplicity is Complicated (video)<br />
<a href="http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893">http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893</a>
</li>

<li>Algorithms to Go<br />
<a href="https://yourbasic.org/">https://yourbasic.org/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů: vlastní filtry a lexery<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/</a>
</li>

<li>Go Defer Simplified with Practical Visuals<br />
<a href="https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff">https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff</a>
</li>

<li>5 More Gotchas of Defer in Go — Part II<br />
<a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa">https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa</a>
</li>

<li>The Go Blog: Defer, Panic, and Recover<br />
<a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a>
</li>

<li>The defer keyword in Swift 2: try/finally done right<br />
<a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer">https://www.hackingwithswift.com/new-syntax-swift-2-defer</a>
</li>

<li>Swift Defer Statement<br />
<a href="https://andybargh.com/swift-defer-statement/">https://andybargh.com/swift-defer-statement/</a>
</li>

<li>Modulo operation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Modulo_operation">https://en.wikipedia.org/wiki/Modulo_operation</a>
</li>

<li>Node.js vs Golang: Battle of the Next-Gen Languages<br />
<a href="https://www.hostingadvice.com/blog/nodejs-vs-golang/">https://www.hostingadvice.com/blog/nodejs-vs-golang/</a>
</li>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go<br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>JavaScript vs. Golang for IoT: Is Gopher Winning?<br />
<a href="https://www.iotforall.com/javascript-vs-golang-iot/">https://www.iotforall.com/javascript-vs-golang-iot/</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

<li>Printf Format Strings<br />
<a href="https://www.cprogramming.com/tutorial/printf-format-strings.html">https://www.cprogramming.com/tutorial/printf-format-strings.html</a>
</li>

<li>Java: String.format<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-</a>
</li>

<li>Java: format string syntax<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a>
</li>

<li>Selectors<br />
<a href="https://golang.org/ref/spec#Selectors">https://golang.org/ref/spec#Selectors</a>
</li>

<li>Calling Go code from Python code<br />
<a href="http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/">http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/</a>
</li>

<li>Go Data Structures: Interfaces <br />
<a href="https://research.swtch.com/interfaces">https://research.swtch.com/interfaces</a>
</li>

<li>How to use interfaces in Go<br />
<a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go</a>
</li>

<li>Interfaces in Go (part I)<br />
<a href="https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c">https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c</a>
</li>

<li>Part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>What about Trait support in Golang?<br />
<a href="https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/">https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/</a>
</li>

<li>Don't Get Bitten by Pointer vs Non-Pointer Method Receivers in Golang<br />
<a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/">https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/</a>
</li>

<li>Control Flow<br />
<a href="https://en.wikipedia.org/wiki/Control_flow">https://en.wikipedia.org/wiki/Control_flow</a>
</li>

<li>Structured programming<br />
<a href="https://en.wikipedia.org/wiki/Structured_programming">https://en.wikipedia.org/wiki/Structured_programming</a>
</li>

<li>Control Structures<br />
<a href="https://www.golang-book.com/books/intro/5">https://www.golang-book.com/books/intro/5</a>
</li>

<li>Control structures - Go if else statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html">http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html</a>
</li>

<li>Control structures - Go switch case statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html</a>
</li>

<li>Control structures - Go for loop, break, continue, range<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html</a>
</li>

<li>Single Function Exit Point<br />
<a href="http://wiki.c2.com/?SingleFunctionExitPoint">http://wiki.c2.com/?SingleFunctionExitPoint</a>
</li>

<li>Entry point<br />
<a href="https://en.wikipedia.org/wiki/Entry_point">https://en.wikipedia.org/wiki/Entry_point</a>
</li>

<li>Why does Go have a GOTO statement?!<br />
<a href="https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/">https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/</a>
</li>

<li>Effective Go<br />
<a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a>
</li>

<li>GoClipse: an Eclipse IDE for the Go programming language<br />
<a href="http://goclipse.github.io/">http://goclipse.github.io/</a>
</li>

<li>GoClipse Installation<br />
<a href="https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation">https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

