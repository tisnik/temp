<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Číselné hodnoty s neomezeným rozsahem a přesností v programovacím jazyku Go (2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Číselné hodnoty s neomezeným rozsahem a přesností v programovacím jazyku Go (2)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Posledním datovým typem ze standardního balíčku big je typ nazvaný big.Float. Tento datový typ umožňuje programátorům práci s číselnými hodnotami, které mohou mít prakticky neomezený rozsah i neomezenou (a navíc konfigurovatelnou) přesnost.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Práce s&nbsp;hodnotami typu <strong>big.Float</strong></a></p>
<p><a href="#k02">2. Konstrukce hodnoty typu <strong>big.Float</strong>, základní aritmetické operace a zobrazení hodnoty</a></p>
<p><a href="#k03">3. Zvýšení počtu cifer zobrazených za desetinnou čárkou (tečkou)</a></p>
<p><a href="#k04">4. Zobrazení velkých hodnot bez použití exponentu</a></p>
<p><a href="#k05">5. Zobrazení malých hodnot bez použití exponentu</a></p>
<p><a href="#k06">6. Zobrazení numerických hodnot ve tvaru s&nbsp;exponentem</a></p>
<p><a href="#k07">7. Výpis hodnoty s&nbsp;využitím mantisy zapsané v&nbsp;hexadecimálním kódu</a></p>
<p><a href="#k08">8. Výpočet hodnoty &pi; podruhé</a></p>
<p><a href="#k09">9. Převody mezi typem <strong>big.Float</strong> a zlomky</a></p>
<p><a href="#k10">10. Převod mezi typem <strong>big.Float</strong> a typy <strong>float64</strong> a <strong>float32</strong></a></p>
<p><a href="#k11">11. Přesnost hodnot typu <strong>big.Float</strong></a></p>
<p><a href="#k12">12. Výpočty, jejichž výsledek je roven kladnému nebo zápornému nekonečnu</a></p>
<p><a href="#k13">13. Povolené operace s&nbsp;nekonečny</a></p>
<p><a href="#k14">*** 14. Zakázané operace s&nbsp;nekonečny</a></p>
<p><a href="#k15">*** 15. Zachycení nepovolené operace s&nbsp;nekonečny</a></p>
<p><a href="#k16">*** 16. Další možnosti</a></p>
<p><a href="#k17">17. Příloha: &bdquo;numerická věž&ldquo; ve vysokoúrovňových programovacích jazycích</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Práce s&nbsp;hodnotami typu <strong>big.Float</strong></h2>

<p>Na <a
href="https://www.root.cz/clanky/ciselne-hodnoty-s-neomezenym-rozsahem-a-presnosti-v-programovacim-jazyku-go-1/">úvodní
článek</a> o datových typech nabízejících programátorům v&nbsp;Go možnost
uložení numerických hodnot s&nbsp;neomezeným rozsahem a/nebo přesností dnes
navážeme. Zatímco minule jsme se zabývali datovým typem
<strong>big.Int</strong> určeným pro reprezentaci celých čísel
s&nbsp;neomezenou přesností i typem <strong>big.Rat</strong> představujících
zlomky (opět prakticky bez omezení hodnoty čitatele a jmenovatele), dnes se
budeme věnovat poslednímu typu z&nbsp;knihovny <strong>big</strong>. Tento typ
se jmenuje <strong>big.Float</strong> a nabízí programátorům možnost práce
s&nbsp;hodnotami, které mají jak prakticky neomezený rozsah, tak i volitelnou
(a opět prakticky neomezenou) přesnost. Navíc je možné v&nbsp;tomto datovém
typu zachytit i hodnoty &infin; a -&infin;, s&nbsp;nimiž je možné dále pracovat
(pochopitelně jen do té míry, jak nám to povoluje matematika).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Konstrukce hodnoty typu <strong>big.Float</strong>, základní aritmetické operace a zobrazení hodnoty</h2>

<p>I když se interní reprezentace hodnot typu <strong>big.Float</strong>
odlišuje od interní reprezentace celých čísel a zlomků, tedy hodnot typu
<strong>big.Int</strong> či <strong>big.Rat</strong>, jsou základní operace
prakticky totožné, takže popis bude oproti předchozímu článku stručnější.
Nejprve si ukážeme, jak lze převést hodnotu primitivního typu
<strong>float64</strong> na <strong>big.Float</strong>, provést aritmetickou
operaci součtu a následně vytisknout výsledek. Konkrétní parametry metody
<strong>Text</strong> budou uvedeny později:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        x := <strong>big.NewFloat(1)</strong>
        y := <strong>big.NewFloat(0.1)</strong>
&nbsp;
        for i := 0; i &lt; 20; i++ {
                <strong>x.Add(x, y)</strong>
                fmt.Println(<strong>x.Text('f', 10)</strong>)
        }
}
</pre>

<p>Výsledkem činnosti tohoto demonstračního příkladu by měla být sekvence
hodnot vytištěná na konzoli, přičemž počet desetinných míst (cifer) bude roven
deseti:</p>

<pre>
1.1000000000
1.2000000000
1.3000000000
1.4000000000
1.5000000000
1.6000000000
1.7000000000
1.8000000000
1.9000000000
2.0000000000
2.1000000000
2.2000000000
2.3000000000
2.4000000000
2.5000000000
2.6000000000
2.7000000000
2.8000000000
2.9000000000
3.0000000000
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zvýšení počtu cifer zobrazených za desetinnou čárkou (tečkou)</h2>

<p>Vzhledem k&nbsp;tomu, že hodnoty typu <strong>big.Float</strong> mohou mít
prakticky neomezenou přesnost, asi nebude větším překvapením, že je možné
zvýšit počet cifer zobrazených za desetinnou čárkou (přesněji řečeno tečkou)
při převodu numerické hodnoty na řetězec metodou <strong>Text</strong>. Počet
cifer je uvedený jako druhý parametr této metody, což je ukázáno na dalším
demonstračním příkladu, v&nbsp;němž počet cifer nastavíme na osmdesát (což je u
typů <strong>float32</strong> či <strong>float64</strong> utopie &ndash; tyto
cifry už nenesou žádnou informaci):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        x := big.NewFloat(1.0)
        y := big.NewFloat(0.5)
&nbsp;
        for i := 1; i &lt; 82; i++ {
                fmt.Println(x.Text('f', 80))
                x.Mul(x, y)
        }
}
</pre>

<p>Výsledek je kvůli jeho délce zkrácený:</p>

<pre>
1.00000000000000000000000000000000000000000000000000000000000000000000000000000000
0.50000000000000000000000000000000000000000000000000000000000000000000000000000000
0.25000000000000000000000000000000000000000000000000000000000000000000000000000000
0.12500000000000000000000000000000000000000000000000000000000000000000000000000000
0.06250000000000000000000000000000000000000000000000000000000000000000000000000000
0.03125000000000000000000000000000000000000000000000000000000000000000000000000000
...
...
...
0.00000000000000000000000661744490042422139897126953655970282852649688720703125000
0.00000000000000000000000330872245021211069948563476827985141426324844360351562500
0.00000000000000000000000165436122510605534974281738413992570713162422180175781250
0.00000000000000000000000082718061255302767487140869206996285356581211090087890625
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zobrazení velkých hodnot bez použití exponentu</h2>

<p>Konkrétní způsob zobrazení numerické hodnoty závisí v&nbsp;první řadě na
prvním parametru metody <strong>Text</strong>, kterým se udává formát
numerických hodnot. Dostupné jsou následující formáty:</p>

<table>
<tr><th>Formát</th><th>Způsob zobrazení</th><th>Příklad</th></tr>
<tr><td>f</td><td>bez exponentu</td><td>-ddddd.dddd</td></tr>
<tr><td>e</td><td>s&nbsp;desítkovým exponentem (minimálně jedna cifra exponentu)</td><td>-d.dddde±dd</td></tr>
<tr><td>E</td><td>s&nbsp;desítkovým exponentem (minimálně jedna cifra exponentu)</td><td>-d.ddddE±dd</td></tr>
<tr><td>g</td><td>formát &bdquo;f&ldquo; nebo &bdquo;e&ldquo; podle konkrétní hodnoty</td><td>viz výše (ovšem udává se počet všech cifer)</td></tr>
<tr><td>G</td><td>formát &bdquo;F&ldquo; nebo &bdquo;E&ldquo; podle konkrétní hodnoty</td><td>viz výše (ovšem udává se počet všech cifer)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>x</td><td>hexadecimální mantisa, exponent bude mocninou dvojky</td><td>-0xd.dddddp±dd</td></tr>
<tr><td>p</td><td>hexadecimální mantisa, exponent bude mocninou dvojky</td><td>-0x.dddp±dd</td></tr>
<tr><td>b</td><td>desítková mantisa, exponent bude mocninou dvojky</td><td>-ddddddp±dd</td></tr>
</table>

<p>Vyzkoušejme si nyní použití formátu &bdquo;f&ldquo; (tedy hodnota je
zobrazená bez exponentu) v&nbsp;případě, že počet cifer za desetinnou
čárkou/tečkou je nulový:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        x := big.NewFloat(1)
        y := big.NewFloat(99)
&nbsp;
        for i := 0; i &lt; 40; i++ {
                x.Mul(x, y)
                fmt.Println(x.Text('f', 0))
        }
}
</pre>

<p>Výsledek (nyní nezkrácený) by měl v&nbsp;tomto případě vypadat
následovně:</p>

<pre>
99
9801
970299
96059601
9509900499
941480149401
93206534790699
9227446944279200
913517247483640832
90438207500880445440
8953382542587163836416
886384871716129238679552
87752102299896794226622464
8687458127689782216118763520
860058354641288373425059921920
85145777109487544324743816544256
8429431933839266852120840818917376
834513761450087363019731019944165376
82616862383558650267118944281560088576
8179069375972306130881718374652897656832
809727868221258357732174542905062205685760
80163058953904576641772755194238486550937600
7936142836436553721360802878344310916894425088
785678140807218793061707480391498750838483976192
77782135939914659864071933241904922766697872490496
7700431458051551752311463790804452893403788372606976
762342714347103590248135020666744013851798541879476224
75471928720363251946671106106388406871738329470443978752
7471720943315961528937081328671280708838571980543808765952
739700373388280233178668298783375180554490387289514891542528
73230336965439745493168643020861442160752121787685016908595200
7249803359578534449866267867987232271459539633506022851029762048
717730532598274941228294902879697277151875910759039675026529845248
71055322727229220491106662433579045148537325278934513439342013186048
7034476949995693163852959145337513235593607391744650747094042283081728
696413218049573594104027678936525501515173615926845935206266864536649728
68944908586907783168146445598460077406778525061023478292239216455863762944
6825545950103870797284771000488139744374229755763313827230611096619962073088
675729049060283181613245576645491150479693176020803826018379604257898045112320
66897175856968030043197640124285497432582076754008063827611983920792316420292608
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zobrazení malých hodnot bez použití exponentu</h2>

<p>Formát zobrazení hodnot &bdquo;f&ldquo; dokáže adaptivně řešit situaci, kdy
zobrazovaná hodnota obsahuje velký počet cifer před desetinnou tečkou/čárkou,
což jsme ostatně mohli vidět <a href="#k04">v&nbsp;předchozí kapitole</a>.
Ovšem jak je tomu v&nbsp;případě malých hodnot, přesněji řečeno hodnot blízkých
nule? V&nbsp;tomto případě není formát &bdquo;f&ldquo; flexibilní, protože
zobrazí jen tolik desetinných cifer, aby to odpovídalo druhému parametru
(dokonce ani nepomůže tento parametr nastavit na nulu tak, jak je tomu
v&nbsp;některých jiných knihovnách).</p>

<p>Toto chování si můžeme velmi snadno otestovat:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        x := big.NewFloat(1)
        y := big.NewFloat(1 / 99.0)
&nbsp;
        for i := 0; i &lt; 30; i++ {
                x.Mul(x, y)
                fmt.Println(x.Text('f', 50))
        }
}
</pre>

<p>Povšimněte si, že v&nbsp;posledních řádcích se sice zobrazuje nula, i když
interně se stále jedná o nenulovou hodnotu:</p>

<pre>
0.01010101010101010186870151841276310733519494533539
0.00010203040506070810337999749117798842235060874373
0.00000103061015212836478327669553767265142596443184
0.00000001041020355685217041371556028579378749832074
0.00000000010515357128133506708648264691105295338958
0.00000000000106215728567005135200201172774860398766
0.00000000000001072886147141466139615915720313629145
0.00000000000000010837233809509759571190792398804885
0.00000000000000000109467008176866265687314861272268
0.00000000000000000001105727355321881591655694310982
0.00000000000000000000011168963185069513140340290478
0.00000000000000000000000112817809950197109106624877
0.00000000000000000000000001139573837880778953785515
0.00000000000000000000000000011510846847280595447488
0.00000000000000000000000000000116271180275561578139
0.00000000000000000000000000000001174456366419813980
0.00000000000000000000000000000000011863195620402162
0.00000000000000000000000000000000000119830258791941
0.00000000000000000000000000000000000001210406654464
0.00000000000000000000000000000000000000012226329843
0.00000000000000000000000000000000000000000123498281
0.00000000000000000000000000000000000000000001247457
0.00000000000000000000000000000000000000000000012601
0.00000000000000000000000000000000000000000000000127
0.00000000000000000000000000000000000000000000000001
0.00000000000000000000000000000000000000000000000000
0.00000000000000000000000000000000000000000000000000
0.00000000000000000000000000000000000000000000000000
0.00000000000000000000000000000000000000000000000000
0.00000000000000000000000000000000000000000000000000
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Zobrazení numerických hodnot ve tvaru s&nbsp;exponentem</h2>

<p>Hodnoty datového typu <strong>big.Float</strong> je možné zobrazit i ve
tvaru, v&nbsp;němž se kromě mantisy použije i exponent. Pro tento účel se
používá formát &bdquo;e&ldquo;. Prozatím ovšem není k&nbsp;dispozici
&bdquo;inženýrská&ldquo; notace, v&nbsp;níž je exponent omezen na kladné a
záporné násobky trojky (a tedy lze exponent &bdquo;číst&ldquo; formou předpon
kilo, mega, ... mili, mikro). Exponent může mít jakoukoli hodnotu a druhým
parametrem metody <strong>Text</strong> se určuje počet cifer za desetinou
čárkou/tečkou. Předchozí dva demonstrační příklady si nyní upravíme tak, aby
používaly formát &bdquo;e&ldquo;. Nejdříve příklad s&nbsp;(poměrně) velkými
hodnotami:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        x := big.NewFloat(1)
        y := big.NewFloat(99)
&nbsp;
        for i := 0; i &lt; 60; i++ {
                x.Mul(x, y)
                fmt.Println(x.Text('e', 10))
        }
}
</pre>

<p>Výsledek bude vypadat následovně. Mimochodem si povšimněte, že nelze takto
snadno omezit celkovou šířku sloupce, protože exponent může bez problémů
překročit možnosti dvouciferných hodnot:</p>

<pre>
9.9000000000e+01
9.8010000000e+03
9.7029900000e+05
9.6059601000e+07
9.5099004990e+09
9.4148014940e+11
9.3206534791e+13
9.2274469443e+15
9.1351724748e+17
9.0438207501e+19
8.9533825426e+21
8.8638487172e+23
8.7752102300e+25
8.6874581277e+27
8.6005835464e+29
8.5145777109e+31
8.4294319338e+33
8.3451376145e+35
8.2616862384e+37
8.1790693760e+39
8.0972786822e+41
8.0163058954e+43
7.9361428364e+45
7.8567814081e+47
7.7782135940e+49
7.7004314581e+51
7.6234271435e+53
7.5471928720e+55
7.4717209433e+57
7.3970037339e+59
7.3230336965e+61
7.2498033596e+63
7.1773053260e+65
7.1055322727e+67
7.0344769500e+69
6.9641321805e+71
6.8944908587e+73
6.8255459501e+75
6.7572904906e+77
6.6897175857e+79
...
...
...
6.1729014094e+95
6.1111723953e+97
6.0500606714e+99
5.9895600647e+101
5.9296644640e+103
5.8703678194e+105
5.8116641412e+107
5.7535474998e+109
5.6960120248e+111
5.6390519045e+113
5.5826613855e+115
5.5268347716e+117
5.4715664239e+119
</pre>

<p>Podobný demonstrační příklad, ale upravený naopak pro velmi malé
hodnoty:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        x := big.NewFloat(1)
        y := big.NewFloat(1 / 99.0)
&nbsp;
        for i := 0; i &lt; 30; i++ {
                x.Mul(x, y)
                fmt.Println(x.Text('e', 50))
        }
}
</pre>

<p>Výsledek zobrazený na ploše terminálu:</p>

<pre>
1.01010101010101018687015184127631073351949453353882e-02
1.02030405060708103379997491177988422350608743727207e-04
1.03061015212836478327669553767265142596443183720112e-06
1.04102035568521704137155602857937874983207393597695e-08
1.05153571281335067086482646911052953389575925768895e-10
1.06215728567005135200201172774860398765640889795492e-12
1.07288614714146613961591572031362914498280741737446e-14
1.08372338095097595711907923988048848980467063669603e-16
1.09467008176866265687314861272267768275942672214472e-18
1.10572735532188159165569431098221261470511653137192e-20
1.11689631850695131403402904782766569004062642114308e-22
1.12817809950197109106624876927407880129500670696404e-24
1.13957383788077895378551491936699546789480855019861e-26
1.15108468472805954474884831669452610195845846835442e-28
1.16271180275561578138574437875301650648307831152748e-30
1.17445636641981398002962852135635944637689815387324e-32
1.18631956204021618895988628179697254388923229872658e-34
1.19830258791941031043953905422304809202567728322527e-36
1.21040665446405094517715640383304949986194361712221e-38
1.22263298430712221421998208845701468241634598727641e-40
1.23498281243143670392733257136953536731326930847497e-42
1.24745738629438053667535332723086755429005166172476e-44
1.26005796595391992455606458322901570918635686054018e-46
1.27278582419587884672086711467371926627233132926519e-48
1.28564224666250410857860323594852539901536777432393e-50
1.29862853198232756224292774640884031731177810970770e-52
1.31174599190134118563999093717256689123717650994598e-54
1.32499595141549631862017541936709472932642748898189e-56
1.33837974890454192356802427082629490266114944105221e-58
1.35189873626721417307818973576258972473012190788000e-60
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Výpis hodnoty s&nbsp;využitím mantisy zapsané v&nbsp;hexadecimálním kódu</h2>

<p>V&nbsp;některých oblastech (ale například i v&nbsp;céčku) se můžeme setkat
s&nbsp;tím, že mantisa je zapsána v&nbsp;hexadecimálním kódu; typicky tak, že
před <i>šestnáctkovou</i> tečkou je uvedena jednička (normalizace) a za
mantisou je zapsán exponent ve formě mocniny čísla 2. Předností tohoto formátu
je fakt, že překladač může číslo načíst a interně reprezentovat s&nbsp;předem
známou přesností; ostatně i zdrojový kód používající tyto konstanty je velmi
dobře přenositelný. Tento de facto standardní formát lze využít i společně
s&nbsp;hodnotami <strong>big.Float</strong>, pokud se při tisku těchto hodnot
použije formát &bdquo;x&ldquo;:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        x := big.NewFloat(1)
        y := big.NewFloat(1 / 99.0)
&nbsp;
        for i := 0; i &lt; 30; i++ {
                x.Mul(x, y)
                fmt.Println(x.Text('x', 50))
        }
}
</pre>

<p>Ve výsledném výpisu je patrný jak prefix 0x, tak i fakt, že před
šestnáctkovou tečkou je zapsána jednička a exponent je uvozen znakem
&bdquo;p&ldquo; a nikoli &bdquo;e&ldquo;:</p>

<pre>
0x1.4afd6a052bf5b0000000000000000000000000000000000000p-07
0x1.abf250300f7690000000000000000000000000000000000000p-14
0x1.14a6fd8916ed00000000000000000000000000000000000000p-20
0x1.65b11e6e03c870000000000000000000000000000000000000p-27
0x1.ce786567741550000000000000000000000000000000000000p-34
0x1.2af87f9d625110000000000000000000000000000000000000p-40
0x1.828c47e7ee4f00000000000000000000000000000000000000p-47
0x1.f3c77969ee4c50000000000000000000000000000000000000p-54
0x1.4316eed01dee20000000000000000000000000000000000000p-60
0x1.a1bb6350501250000000000000000000000000000000000000p-67
0x1.0e0c889b5a8d30000000000000000000000000000000000000p-73
0x1.5d277a51e970c0000000000000000000000000000000000000p-80
0x1.c36e844ae03f10000000000000000000000000000000000000p-87
0x1.23d5aadb1242a0000000000000000000000000000000000000p-93
0x1.795251449e12f0000000000000000000000000000000000000p-100
0x1.e7d99f6079a190000000000000000000000000000000000000p-107
0x1.3b60b9c76b1320000000000000000000000000000000000000p-113
0x1.97c2e0af161390000000000000000000000000000000000000p-120
0x1.079a6d0c56ad00000000000000000000000000000000000000p-126
0x1.54d2015af15bd0000000000000000000000000000000000000p-133
0x1.b8a816706930f0000000000000000000000000000000000000p-140
0x1.1cde70c4ca7790000000000000000000000000000000000000p-146
0x1.7050bb2cfb6eb0000000000000000000000000000000000000p-153
0x1.dc34a999d5e480000000000000000000000000000000000000p-160
0x1.33d9a3f1abe3f0000000000000000000000000000000000000p-166
0x1.8e074aeae36a00000000000000000000000000000000000000p-173
0x1.014fb44f716630000000000000000000000000000000000000p-179
0x1.4caf74c3ce1790000000000000000000000000000000000000p-186
0x1.ae237fb22c1430000000000000000000000000000000000000p-193
0x1.1611c6ea21aad0000000000000000000000000000000000000p-199
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Výpočet hodnoty &pi; podruhé</h2>

<p>Minule jsme si ukázali výpočet konstanty &pi; založený na dnes již
nepoužívané nekonečné řady prvků, které se nesčítají, ale násobí. Jedná se o
takzvaný <i>Wallis product</i>, což je forma řady, která vypadá následovně:</p>

<p><img src="https://i.iinfo.cz/images/52/wallis-product-2.png" class="image-1088080" alt="&#160;" title="Autor: NA, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="577" height="99" /></p>

<p>Následující výpočet byl upraven takovým způsobem, že se v&nbsp;něm společně
používají všechny tři datové typy z&nbsp;balíčku <strong>big</strong>, tedy jak
<strong>big.Int</strong> a <strong>big.Rat</strong>, tak i dnes popisovaný typ
<strong>big.Float</strong>. &bdquo;Velká celá čísla&ldquo; zde vystupují
v&nbsp;roli počitadla smyčky, zlomky pro výpočet jednoho členu řady a čísla
s&nbsp;plovoucí řádovou čárkou pro akumulaci výsledků:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        result := big.NewFloat(2.0)
&nbsp;
        one := big.NewInt(1)
        limit := big.NewInt(200)
&nbsp;
        for n := big.NewInt(1); n.Cmp(limit) &lt;= 0; n.Add(n, one) {
                m := big.NewInt(4)
                m.Mul(m, n)
                m.Mul(m, n)
                mn := big.NewInt(0)
                mn.Sub(m, one)
&nbsp;
                var item big.Rat
                item.SetFrac(m, mn)
&nbsp;
                var itemFloat big.Float
                itemFloat.SetRat(&amp;item)
&nbsp;
                result.Mul(result, &amp;itemFloat)
&nbsp;
                fmt.Println(result.Text('f', 50))
        }
}
</pre>

<p>Pro úplnost se podívejme na vypočtené výsledky:</p>

<pre>
2.66666666666666651863693004997912794351577758789062
2.84444444444444410891037477995269000530242919921875
2.92571428571428526765885180793702602386474609375000
2.97215419501133748525489863823167979717254638671875
3.00217595455690666739201333257369697093963623046875
3.02317019200136050116611841076519340276718139648438
...
...
...
3.13757784361778702120204798120539635419845581054688
3.13759826218207127368486908380873501300811767578125
3.13761847410761740562179511471185833215713500976562
3.13763848251544885670227813534438610076904296875000
3.13765829046405153590626468940172344446182250976562
3.13767790095093257463076952262781560420989990234375
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jak pomalu výsledek
konverguje ke konstantě &pi;.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Převody mezi typem <strong>big.Float</strong> a zlomky</h2>

<p>Hodnotu typu <strong>big.Float</strong> můžeme zavoláním metody
<strong>big.Float.Rat</strong> převést na zlomek, tj.&nbsp;přesněji řečeno na
hodnotu typu <strong>big.Rat</strong>, o němž jsme se zmínili v&nbsp;předchozím
článku. Kromě vlastního zlomku se vrátí i příznak určující, zda zlomek
reprezentuje přesně původní hodnotu nebo se jedná o aproximaci. Tento příznak
může mít tři hodnoty s&nbsp;jasným významem &ndash; <strong>Below</strong>,
<strong>Exact</strong> a <strong>Above</strong>. Vyzkoušejme si nyní, jak
převod na zlomky vypadá:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        x := big.NewFloat(2.0)
        y := big.NewFloat(0.1)
&nbsp;
        for i := 0; i &lt; 10; i++ {
                var ratio big.Rat
                <strong>_, accuracy := x.Rat(&amp;ratio)</strong>
                fmt.Println(accuracy, ratio.String())
&nbsp;
                x.Mul(x, y)
        }
}
</pre>

<p>Podle očekávání budou zlomky v&nbsp;mnoha případech obsahovat poměrně velké
hodnoty v&nbsp;čitateli a jmenovateli, což je způsobeno snahou interního
algoritmu o přesné vyjádření původní hodnoty s&nbsp;plovoucí řádovou
čárkou:</p>

<pre>
Exact 2/1
Exact 3602879701896397/18014398509481984
Exact 1441151880758559/72057594037927936
Exact 4611686018427389/2305843009213693952
Exact 7378697629483823/36893488147419103232
Exact 5902958103587059/295147905179352825856
Exact 4722366482869647/2361183241434822606848
Exact 1888946593147859/9444732965739290427392
Exact 6044629098073149/302231454903657293676544
Exact 4835703278458519/2417851639229258349412352
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Převod mezi typem <strong>big.Float</strong> a typy <strong>float64</strong> a <strong>float32</strong></h2>

<p>Pokusit se můžeme i o převod hodnoty s&nbsp;prakticky neomezenou přesností a
rozsahem na primitivní datový typ <strong>float64</strong> či
<strong>float32</strong>. Při tomto typu převodu pochopitelně obecně dojde ke
ztrátě přesnosti a navíc může být výsledkem kladné či záporné nekonečno ve
chvíli, kdy převáděná hodnota přesahuje rozsah obou zmíněných primitivních
datových typů (pro velmi malá čísla bude naopak výsledkem kladná nebo záporná
nula). Ostatně si to můžeme snadno ukázat na demonstračních příkladech. Začneme
převodem na typ <strong>float64</strong>, přičemž získáme jak převedenou
hodnotu, tak i již zmíněný příznak o přesnosti převedené hodnoty:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        x := big.NewFloat(2.0)
        y := big.NewFloat(0.1)
&nbsp;
        for i := 0; i &lt; 20; i++ {
                <strong>value, accuracy := x.Float64()</strong>
                fmt.Println(accuracy, value)
&nbsp;
                x.Mul(x, y)
        }
}
</pre>

<p>Převedené hodnoty vypsané na standardní výstup:</p>

<pre>
Exact 2
Exact 0.2
Exact 0.020000000000000004
Exact 0.0020000000000000005
Exact 0.00020000000000000006
Exact 2.000000000000001e-05
Exact 2.0000000000000008e-06
Exact 2.000000000000001e-07
Exact 2.000000000000001e-08
Exact 2.000000000000001e-09
Exact 2.000000000000001e-10
Exact 2.0000000000000012e-11
Exact 2.000000000000001e-12
Exact 2.0000000000000013e-13
Exact 2.0000000000000016e-14
Exact 2.0000000000000017e-15
Exact 2.000000000000002e-16
Exact 2.000000000000002e-17
Exact 2.000000000000002e-18
Exact 2.000000000000002e-19
</pre>

<p>Mnohem zajímavější je převod na typ <strong>float32</strong>, kdy již
pravidelně dochází ke ztrátě přesnosti a vrácená hodnota je pod či nad
převáděnou hodnotou:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        x := big.NewFloat(2.0)
        y := big.NewFloat(0.1)
&nbsp;
        for i := 0; i &lt; 20; i++ {
                <strong>value, accuracy := x.Float32()</strong>
                fmt.Println(accuracy, value)
&nbsp;
                x.Mul(x, y)
        }
}
</pre>

<p>Výsledky:</p>

<pre>
Exact 2
Above 0.2
Below 0.02
Above 0.002
Below 0.0002
Below 2e-05
Below 2e-06
Above 2e-07
Below 2e-08
Below 2e-09
Above 2e-10
Below 2e-11
Below 2e-12
Below 2e-13
Below 2e-14
Above 2e-15
Above 2e-16
Below 2e-17
Above 2e-18
Below 2e-19
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Přesnost hodnot typu <strong>big.Float</strong></h2>

<p>Přesnost (<i>precision</i>) hodnot typu <strong>big.Float</strong> je možné
řídit. Pro tento účel existuje metoda nazvaná <strong>SetPrec</strong>, které
se předává <i>počet bitů</i> mantisy. Existuje teoretický maximální možný počet
bitů mantisy, který je roven konstantě:</p>

<pre>
MaxPrec = math.MaxUint32
</pre>

<p>V&nbsp;praxi však bude maximální prakticky použitelný počet bitů mantisy
menší.</p>

<p>Při změně přesnosti, přesněji při snižování počtu bitů mantisy, se provádí
zaokrouhlování podle nastavené konfigurace (viz další text). Ukažme si nyní,
jak se bude postupně měnit přesnost zaznamenané hodnoty &pi;
(resp.&nbsp;přiblížení k&nbsp;této hodnotě), pokud budeme počet bitů mantisy
snižovat od 35 bitů k&nbsp;jednomu bitu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        result := big.NewFloat(2.0)
&nbsp;
        one := big.NewInt(1)
        limit := big.NewInt(10000)
&nbsp;
        for n := big.NewInt(1); n.Cmp(limit) &lt;= 0; n.Add(n, one) {
                m := big.NewInt(4)
                m.Mul(m, n)
                m.Mul(m, n)
                mn := big.NewInt(0)
                mn.Sub(m, one)
&nbsp;
                var item big.Rat
                item.SetFrac(m, mn)
&nbsp;
                var itemFloat big.Float
                itemFloat.SetRat(&amp;item)
&nbsp;
                result.Mul(result, &amp;itemFloat)
&nbsp;
        }
&nbsp;
        for precision := uint(35); precision != 0; precision-- {
                <strong>result.SetPrec(precision)</strong>
                fmt.Println(result.Text('f', 31))
        }
}
</pre>

<p>Výsledky:</p>

<pre>
3.1415141186444088816642761230469
3.1415141187608242034912109375000
3.1415141187608242034912109375000
3.1415141187608242034912109375000
3.1415141187608242034912109375000
3.1415141187608242034912109375000
3.1415141224861145019531250000000
3.1415141224861145019531250000000
3.1415141224861145019531250000000
3.1415141224861145019531250000000
3.1415140628814697265625000000000
3.1415140628814697265625000000000
3.1415138244628906250000000000000
3.1415138244628906250000000000000
3.1415138244628906250000000000000
3.1415138244628906250000000000000
3.1415100097656250000000000000000
3.1415100097656250000000000000000
3.1415100097656250000000000000000
3.1414794921875000000000000000000
3.1414794921875000000000000000000
3.1416015625000000000000000000000
3.1416015625000000000000000000000
3.1416015625000000000000000000000
3.1406250000000000000000000000000
3.1406250000000000000000000000000
3.1406250000000000000000000000000
3.1406250000000000000000000000000
3.1250000000000000000000000000000
3.1250000000000000000000000000000
3.1250000000000000000000000000000
3.0000000000000000000000000000000
3.0000000000000000000000000000000
3.0000000000000000000000000000000
4.0000000000000000000000000000000
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;posledním kroku má mantisa
skutečně pouze jediný bit.</div></p>

<p>Počet bitů mantisy můžeme snížit až na 0, takže se zachová jen znaménko a
normalizovaný bit mantisy (rozlišují se hodnoty 0, nekonečno apod., nic
víc):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        result := big.NewFloat(2.0)
&nbsp;
        one := big.NewInt(1)
        limit := big.NewInt(200)
&nbsp;
        for n := big.NewInt(1); n.Cmp(limit) &lt;= 0; n.Add(n, one) {
                m := big.NewInt(4)
                m.Mul(m, n)
                m.Mul(m, n)
                mn := big.NewInt(0)
                mn.Sub(m, one)
&nbsp;
                var item big.Rat
                item.SetFrac(m, mn)
&nbsp;
                var itemFloat big.Float
                itemFloat.SetRat(&amp;item)
&nbsp;
                result.Mul(result, &amp;itemFloat)
&nbsp;
        }
&nbsp;
        <strong>result.SetPrec(0)</strong>
        fmt.Println(result.Text('f', 31))
}
</pre>

<p>Nyní bude výsledek podle předpokladů vypadat takto:</p>

<pre>
0.0000000000000000000000000000000
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Výpočty, jejichž výsledek je roven kladnému nebo zápornému nekonečnu</h2>

<p>U datového typu <strong>big.Float</strong> může nastat situace, kdy je
výsledek nějakého výpočtu roven kladnému nebo zápornému nekonečnu. Jedná se o
zcela legální hodnoty (na rozdíl od zlomků popisovaných minule) a mnoho operací
s&nbsp;nekonečny je zcela legální. Příkladem výpočtu, jehož výsledkem je
nekonečno, je podíl dvou hodnot, jenž je realizovaný metodou
<strong>Quo</strong>.</p>

<p>Pokusme se například provést výpočet 1,0/0, jehož výsledkem by mělo být
kladné nekonečno. Navíc metodou <strong>IsInf</strong> otestujeme, zda je
hodnota nekonečná či nikoli (tato metoda je tedy klasickým
<i>predikátem</i>):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        x := big.NewFloat(1.0)
        y := big.NewFloat(0.0)
&nbsp;
        var result big.Float
        <strong>result.Quo(x, y)</strong>
&nbsp;
        fmt.Println(result.Text('f', 31))
&nbsp;
        fmt.Println()
&nbsp;
        fmt.Println(<strong>x.IsInf()</strong>)
        fmt.Println(<strong>y.IsInf()</strong>)
        fmt.Println(<strong>result.IsInf()</strong>)
}
</pre>

<p>Výsledek:</p>

<pre>
+Inf
&nbsp;
false
false
true
</pre>

<p>Podobně můžeme získat záporné nekonečno:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        x := big.NewFloat(-1.0)
        y := big.NewFloat(0.0)
&nbsp;
        var result big.Float
        <strong>result.Quo(x, y)</strong>
&nbsp;
        fmt.Println(result.Text('f', 31))
&nbsp;
        fmt.Println()
&nbsp;
        fmt.Println(<strong>x.IsInf()</strong>)
        fmt.Println(<strong>y.IsInf()</strong>)
        fmt.Println(<strong>result.IsInf()</strong>)
}
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
-Inf
&nbsp;
false
false
true
</pre>

<p><div class="rs-tip-major">Poznámka: to vlastně znamená, že predikát
<strong>IsInf()</strong> vrací pravdivostní hodnotu <strong>True</strong> jak
pro kladné, tak i pro záporné nekonečno.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Povolené operace s&nbsp;nekonečny</h2>

<p>S&nbsp;hodnotami &infin; a -&infin; je možné provádět některé aritmetické a
popř.&nbsp;relační operace. Nejprve si ukažme ty operace, které jsou zcela
legální a jejich provedením získáme korektní výsledek. K&nbsp;nekonečnům je
možné přičíst jakoukoli hodnotu popř.&nbsp;jakoukoli hodnotu odečíst (až na
jednu výjimku popsanou níže). Taktéž je možné nekonečno vynásobit nějakou
nenulovou hodnotou, přičemž znaménko této hodnoty určuje, zda výsledkem bude
kladné nebo záporné nekonečno. Podívejme se na příklad, který některé tyto
operace obsahuje:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        x := big.NewFloat(1.0)
        y := big.NewFloat(-1.0)
        z := big.NewFloat(0.0)
&nbsp;
        var positiveInfinity big.Float
        positiveInfinity.Quo(x, z)
        fmt.Println(positiveInfinity.Text('f', 31))
&nbsp;
        var negativeInfinity big.Float
        negativeInfinity.Quo(y, z)
        fmt.Println(negativeInfinity.Text('f', 31))
&nbsp;
        var infMultiplyBy1 big.Float
        infMultiplyBy1.Mul(&amp;positiveInfinity, x)
        fmt.Println(infMultiplyBy1.Text('f', 31))
&nbsp;
        var infMultiplyByMinus1 big.Float
        infMultiplyByMinus1.Mul(&amp;positiveInfinity, y)
        fmt.Println(infMultiplyByMinus1.Text('f', 31))
&nbsp;
        var infMultiplyByNegativeInf big.Float
        infMultiplyByNegativeInf.Mul(&amp;positiveInfinity, &amp;negativeInfinity)
        fmt.Println(infMultiplyByNegativeInf.Text('f', 31))
}
</pre>

<p>V&nbsp;tomto příkladu provádíme operace:</p>

<ul>
<li>&infin;&times;1 = &infin;</li>
<li>&infin;&times;-1 = -&infin;</li>
<li>&infin;&times;-&infin; = -&infin;</li>
</ul>

<p>Otestujme, zda vypočtené výsledky skutečně odpovídají očekávání:</p>

<pre>
+Inf
-Inf
+Inf
-Inf
-Inf
</pre>

<p>První dva řádky jsou výpisy vypočtených nekonečen, další tři řádky pak
výsledky všech tří výše uvedených výrazů.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Zakázané operace s&nbsp;nekonečny</h2>

<p>Některé aritmetické operace s&nbsp;kladným či záporným nekonečnem však není možné provést a při snaze o výpočet takové </p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        x := big.NewFloat(1.0)
        y := big.NewFloat(-1.0)
        z := big.NewFloat(0.0)
&nbsp;
        var positiveInfinity big.Float
        positiveInfinity.Quo(x, z)
        fmt.Println(positiveInfinity.Text('f', 31))
&nbsp;
        var negativeInfinity big.Float
        negativeInfinity.Quo(y, z)
        fmt.Println(negativeInfinity.Text('f', 31))
&nbsp;
        var added big.Float
        added.Add(&amp;positiveInfinity, &amp;negativeInfinity)
        fmt.Println(added.Text('f', 31))
}
</pre>

<pre>
+Inf
-Inf
panic: addition of infinities with opposite signs

goroutine 1 [running]:
math/big.(*Float).Add(0x4ce2f8?, 0xc000012018?, 0xc00007ce60?)
        /opt/go/src/math/big/float.go:1490 +0x185
main.main()
        /home/ptisnovs/src/go-root/article_A9/17_inf_operations.go:22 +0x25a
exit status 2
</pre>

<pre>
package <strong>main</strong>

import (
        "fmt"
        "math/big"
)

func <strong>main</strong>() {
        x := big.NewFloat(1.0)
        y := big.NewFloat(-1.0)
        z := big.NewFloat(0.0)

        var positiveInfinity big.Float
        positiveInfinity.Quo(x, z)
        fmt.Println(positiveInfinity.Text('f', 31))

        var negativeInfinity big.Float
        negativeInfinity.Quo(y, z)
        fmt.Println(negativeInfinity.Text('f', 31))

        var infMultiplyBy0 big.Float
        infMultiplyBy0.Mul(&positiveInfinity, z)
        fmt.Println(infMultiplyBy0.Text('f', 31))
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Zachycení nepovolené operace s&nbsp;nekonečny</h2>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "log"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        x := big.NewFloat(1.0)
        y := big.NewFloat(-1.0)
        z := big.NewFloat(0.0)
&nbsp;
        var positiveInfinity big.Float
        positiveInfinity.Quo(x, z)
        fmt.Println(positiveInfinity.Text('f', 31))
&nbsp;
        var negativeInfinity big.Float
        negativeInfinity.Quo(y, z)
        fmt.Println(negativeInfinity.Text('f', 31))
&nbsp;
        defer func() {
                if <strong>recover()</strong> != nil {
                        log.Fatal("Improper operation")
                }
        }()
&nbsp;
        var infMultiplyBy0 big.Float
        infMultiplyBy0.Mul(&amp;positiveInfinity, z)
        fmt.Println(infMultiplyBy0.Text('f', 31))
}
</pre>

<p></p>

<pre>
+Inf
-Inf
2023/04/25 17:32:21 Improper operation
exit status 1
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Další možnosti</h2>

<p><a href="https://pkg.go.dev/github.com/shopspring/decimal">Decimal</a> <a href="https://gitlab.com/amfiremage/gosit/-/tree/master">Gosit</a></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Příloha: &bdquo;numerická věž&ldquo; ve vysokoúrovňových programovacích jazycích</h2>

<p>S&nbsp;takzvanou &bdquo;numerickou věží&ldquo; jsme se již na tomto serveru
setkali při popisu možností mnoha existujících dialektů programovacího jazyka
Scheme. Připomeňme si ve stručnosti, že se jedná o hierarchii datových typů
reprezentujících různé typy čísel. Na vrcholu této hierarchie typicky stojí
obecný typ <strong>number</strong>, pod ním leží komplexní čísla, dále čísla
reálná, čísla racionální (zlomky) a nakonec čísla celá:</p>

<table>
<tr><th>#</th><th>Typ</th><th>Význam</th></tr>
<tr><td>1</td><td>number</td><td>libovolná obecná čísla</td></tr>
<tr><td>2</td><td>complex</td><td>komplexní čísla</td></tr>
<tr><td>3</td><td>real</td><td>reálná čísla</td></tr>
<tr><td>4</td><td>rational</td><td>zlomky (racionální čísla)</td></tr>
<tr><td>5</td><td>integer</td><td>celá čísla</td></tr>
</table>

<p>Převody mezi numerickými typy jsou ve Scheme a od něho odvozených jazycích
prováděny automaticky na základě vyhodnocovaného výrazu. Například
v&nbsp;následujícím výrazu bylo nutné vyhodnotit výsledek jako komplexní číslo,
protože jsme se snažili vypočítat druhou odmocninu ze záporného čísla:</p>

<pre>
<strong>(sqrt (/ 3.14159 (- (expt 2 32))))</strong>
&nbsp;
0+2.704548801180264e-05i
</pre>

<p>Výše uvedená numerická věž může být rozšířena o další typy, což je případ
programovacího jazyka <i>Kawa</i>, jenž tento koncept rozšiřuje o numerický typ
<i>kvaternion</i> a taktéž (což je asi nejzajímavější a poměrně unikátní) o typ
<i>quantity</i>, tedy o dvojice hodnota+jednotka:</p>

<table>
<tr><th>Typ</th><th>Význam</th></tr>
<tr><td>number</td><td>libovolná obecná čísla</td></tr>
<tr><td>quantity</td><td>numerická hodnota i s&nbsp;uvedenou jednotkou (viz další text)</td></tr>
<tr><td>quaternion</td><td>kvaterniony</td></tr>
<tr><td>complex</td><td>komplexní čísla</td></tr>
<tr><td>real</td><td>reálná čísla</td></tr>
<tr><td>rational</td><td>zlomky (racionální čísla)</td></tr>
<tr><td>integer</td><td>celá čísla</td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech <a
href="https://www.root.cz/clanky/ciselne-hodnoty-s-neomezenym-rozsahem-a-presnosti-v-programovacim-jazyku-go-1/">minule</a>
i dnes použitých demonstračních příkladů naprogramovaných v&nbsp;jazyku Go byly
uloženy do Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář, můžete namísto toho
použít odkazy na jednotlivé demonstrační příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad/soubor</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_bigint_construction.go</td><td>konstrukce instance datového typu <strong>big.Int</strong> a tisk uložené hodnoty</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/01_bigint_construction.go">https://github.com/tisnik/go-root/blob/master/article_A8/01_bigint_construction.go</a></td></tr>
<tr><td> 2</td><td>02_bigint_add.go</td><td>aritmetická operace součtu a datový typ <strong>big.Int</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/02_bigint_add.go">https://github.com/tisnik/go-root/blob/master/article_A8/02_bigint_add.go</a></td></tr>
<tr><td> 3</td><td>03_bigint_large_numbers.go</td><td>aritmetická operace součinu a datový typ <strong>big.Int</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/03_bigint_large_numbers.go">https://github.com/tisnik/go-root/blob/master/article_A8/03_bigint_large_numbers.go</a></td></tr>
<tr><td> 4</td><td>04_factorial.go</td><td>výpočet faktoriálu s&nbsp;využitím datového typu <strong>big.Int</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/04_factorial.go">https://github.com/tisnik/go-root/blob/master/article_A8/04_factorial.go</a></td></tr>
<tr><td> 5</td><td>04_factorial_B.go</td><td>zjednodušený výpočet faktoriálu s&nbsp;využitím datového typu <strong>big.Int</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/04_factorial_B.go">https://github.com/tisnik/go-root/blob/master/article_A8/04_factorial_B.go</a></td></tr>
<tr><td> 6</td><td>05_bigint_print_base.go</td><td>převod hodnoty typu <strong>big.Int</strong> na text s&nbsp;volitelnou bází</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/05_bigint_print_base.go">https://github.com/tisnik/go-root/blob/master/article_A8/05_bigint_print_base.go</a></td></tr>
<tr><td> 7</td><td>06_bigint_as_bytes.go</td><td>zobrazení interní struktury hodnot typu <strong>big.Int</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/06_bigint_as_bytes.go">https://github.com/tisnik/go-root/blob/master/article_A8/06_bigint_as_bytes.go</a></td></tr>
<tr><td> 8</td><td>07_bigint_change_raw.go</td><td>modifikace interní struktury hodnot typu <strong>big.Int</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/07_bigint_change_raw.go">https://github.com/tisnik/go-root/blob/master/article_A8/07_bigint_change_raw.go</a></td></tr>
<tr><td> 9</td><td>08_bigint_change_raw.go</td><td>nastavení jednotlivých bajtů hodnoty typu <strong>big.Int</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/08_bigint_change_raw.go">https://github.com/tisnik/go-root/blob/master/article_A8/08_bigint_change_raw.go</a></td></tr>
<tr><td>10</td><td>09_bigint_from_string.go</td><td>konstrukce hodnoty <strong>big.Int</strong> z&nbsp;řetězce</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/09_bigint_from_string.go">https://github.com/tisnik/go-root/blob/master/article_A8/09_bigint_from_string.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>10_rationals_construction.go</td><td>konstrukce zlomku &ndash; hodnoty <strong>big.Rat</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/10_rationals_construction.go">https://github.com/tisnik/go-root/blob/master/article_A8/10_rationals_construction.go</a></td></tr>
<tr><td>12</td><td>11_rationals_add.go</td><td>součet dvou zlomků</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/11_rationals_add.go">https://github.com/tisnik/go-root/blob/master/article_A8/11_rationals_add.go</a></td></tr>
<tr><td>13</td><td>12_rationals_mul.go</td><td>operace součinu zlomků a vliv na přesnost a rozsah hodnoty</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/12_rationals_mul.go">https://github.com/tisnik/go-root/blob/master/article_A8/12_rationals_mul.go</a></td></tr>
<tr><td>14</td><td>13_rational_to_int.go</td><td>převod zlomku na celočíselného čitatele a jmenovatele</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/13_rational_to_int.go">https://github.com/tisnik/go-root/blob/master/article_A8/13_rational_to_int.go</a></td></tr>
<tr><td>15</td><td>14_rationals_to_float.go</td><td>převod zlomku na hodnotu s&nbsp;plovoucí řádovou čárkou</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/14_rationals_to_float.go">https://github.com/tisnik/go-root/blob/master/article_A8/14_rationals_to_float.go</a></td></tr>
<tr><td>16</td><td>15_pi_wallis_product.go</td><td>výpočet hodnoty &pi; (naivní varianta)</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/15_pi_wallis_product.go">https://github.com/tisnik/go-root/blob/master/article_A8/15_pi_wallis_product.go</a></td></tr>
<tr><td>17</td><td>16_pi_wallis_product_limits.go</td><td>limity naivní varianty výpočtu hodnoty &pi;</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/16_pi_wallis_product_limits.go">https://github.com/tisnik/go-root/blob/master/article_A8/16_pi_wallis_product_limits.go</a></td></tr>
<tr><td>18</td><td>17_pi_better_wallis_product.go</td><td>vylepšená varianta výpočtu hodnoty &pi;</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/17_pi_better_wallis_product.go">https://github.com/tisnik/go-root/blob/master/article_A8/17_pi_better_wallis_product.go</a></td></tr>
<tr><td>19</td><td>18_rationals_div_zero.go</td><td>konstrukce zlomku s&nbsp;nulovým jmenovatelem</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/18_rationals_div_zero.go">https://github.com/tisnik/go-root/blob/master/article_A8/18_rationals_div_zero.go</a></td></tr>
<tr><td>20</td><td>19_rationals_div_zero.go</td><td>operace, která vytvoří zlomek s&nbsp;nulovým jmenovatelem</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/19_rationals_div_zero.go">https://github.com/tisnik/go-root/blob/master/article_A8/19_rationals_div_zero.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>01_bigfloat_construction.go</td><td>konstrukce hodnoty typu <strong>big.Float</strong>, základní aritmetické operace a zobrazení hodnoty</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A9/01_bigfloat_construction.go">https://github.com/tisnik/go-root/blob/master/article_A9/01_bigfloat_construction.go</a></td></tr>
<tr><td>22</td><td>02_bigfloat_add.go</td><td>zvýšení počtu cifer zobrazených za desetinnou čárkou (tečkou)</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A9/02_bigfloat_add.go">https://github.com/tisnik/go-root/blob/master/article_A9/02_bigfloat_add.go</a></td></tr>
<tr><td>23</td><td>03_bigfloat_large_numbers.go</td><td>zobrazení velkých hodnot bez použití exponentu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A9/03_bigfloat_large_numbers.go">https://github.com/tisnik/go-root/blob/master/article_A9/03_bigfloat_large_numbers.go</a></td></tr>
<tr><td>24</td><td>04_bigfloat_small_numbers.go</td><td>zobrazení malých hodnot bez použití exponentu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A9/04_bigfloat_small_numbers.go">https://github.com/tisnik/go-root/blob/master/article_A9/04_bigfloat_small_numbers.go</a></td></tr>
<tr><td>25</td><td>05_bigfloat_exp_format.go</td><td>zobrazení numerických hodnot ve tvaru s&nbsp;exponentem</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A9/05_bigfloat_exp_format.go">https://github.com/tisnik/go-root/blob/master/article_A9/05_bigfloat_exp_format.go</a></td></tr>
<tr><td>26</td><td>06_bigfloat_exp_format.go</td><td>zobrazení numerických hodnot ve tvaru s&nbsp;exponentem</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A9/06_bigfloat_exp_format.go">https://github.com/tisnik/go-root/blob/master/article_A9/06_bigfloat_exp_format.go</a></td></tr>
<tr><td>27</td><td>07_hexa_mantissa.go</td><td>výpis hodnoty s&nbsp;využitím mantisy zapsané v&nbsp;hexadecimálním kódu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A9/07_hexa_mantissa.go">https://github.com/tisnik/go-root/blob/master/article_A9/07_hexa_mantissa.go</a></td></tr>
<tr><td>28</td><td>08_pi_wallis_product.go</td><td>výpočet hodnoty &pi; podruhé</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A9/08_pi_wallis_product.go">https://github.com/tisnik/go-root/blob/master/article_A9/08_pi_wallis_product.go</a></td></tr>
<tr><td>29</td><td>09_bigfloat_to_rat.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A9/09_bigfloat_to_rat.go">https://github.com/tisnik/go-root/blob/master/article_A9/09_bigfloat_to_rat.go</a></td></tr>
<tr><td>30</td><td>10_bigfloat_to_float64.go</td><td>převody mezi typem <strong>big.Float</strong> a zlomky</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A9/10_bigfloat_to_float64.go">https://github.com/tisnik/go-root/blob/master/article_A9/10_bigfloat_to_float64.go</a></td></tr>
<tr><td>31</td><td>11_bigfloat_to_float32.go</td><td>převod mezi typem <strong>big.Float</strong> a typy <strong>float64</strong> a <strong>float32</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A9/11_bigfloat_to_float32.go">https://github.com/tisnik/go-root/blob/master/article_A9/11_bigfloat_to_float32.go</a></td></tr>
<tr><td>32</td><td>12_precision.go</td><td>přesnost hodnot typu <strong>big.Float</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A9/12_precision.go">https://github.com/tisnik/go-root/blob/master/article_A9/12_precision.go</a></td></tr>
<tr><td>33</td><td>13_precision_B.go</td><td>přesnost hodnot typu <strong>big.Float</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A9/13_precision_B.go">https://github.com/tisnik/go-root/blob/master/article_A9/13_precision_B.go</a></td></tr>
<tr><td>34</td><td>14_positive_infinity.go</td><td>výsledek podílu 1/0</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A9/14_positive_infinity.go">https://github.com/tisnik/go-root/blob/master/article_A9/14_positive_infinity.go</a></td></tr>
<tr><td>35</td><td>15_negative_infinity.go</td><td>výsledek podílu -1/0</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A9/15_negative_infinity.go">https://github.com/tisnik/go-root/blob/master/article_A9/15_negative_infinity.go</a></td></tr>
<tr><td>36</td><td>16_inf_operations.go</td><td>povolené operace s&nbsp;nekonečny</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A9/16_inf_operations.go">https://github.com/tisnik/go-root/blob/master/article_A9/16_inf_operations.go</a></td></tr>
<tr><td>37</td><td>17_inf_operations.go</td><td>nepovolené operace s&nbsp;nekonečny: -&infin;+&infin;</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A9/17_inf_operations.go">https://github.com/tisnik/go-root/blob/master/article_A9/17_inf_operations.go</a></td></tr>
<tr><td>38</td><td>18_inf_operations.go</td><td>nepovolené operace s&nbsp;nekonečny: &infin;&times;0</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A9/18_inf_operations.go">https://github.com/tisnik/go-root/blob/master/article_A9/18_inf_operations.go</a></td></tr>
<tr><td>39</td><td>19_catch_panic.go</td><td>zachycení nepovolené operace s&nbsp;nekonečny</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A9/19_catch_panic.go">https://github.com/tisnik/go-root/blob/master/article_A9/19_catch_panic.go</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na Internetu</h2>

<ol>

<li>Balíček <strong>big</strong> pro jazyk Go<br />
<a href="https://pkg.go.dev/math/big">https://pkg.go.dev/math/big</a>
</li>

<li>Zdrojové kódu pro balíček <strong>big</strong><br />
<a href="https://cs.opensource.google/go/go/+/master:src/math/big/">https://cs.opensource.google/go/go/+/master:src/math/big/</a>
</li>

<li>Arbitrary-precision arithmetic<br />
<a href="https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic">https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic</a>
</li>

<li>Floating-point error mitigation<br />
<a href="https://en.wikipedia.org/wiki/Floating-point_error_mitigation">https://en.wikipedia.org/wiki/Floating-point_error_mitigation</a>
</li>

<li>Beating Floating Point at its Own Game: Posit Arithmetic<br />
<a href="http://www.johngustafson.net/pdfs/BeatingFloatingPoint.pdf">http://www.johngustafson.net/pdfs/BeatingFloatingPoint.pdf</a>
</li>

<li>Unum (number format)<br />
<a href="https://en.wikipedia.org/wiki/Unum_(number_format)">https://en.wikipedia.org/wiki/Unum_(number_format)</a>
</li>

<li>The GNU MPFR Library<br />
<a href="https://www.mpfr.org/">https://www.mpfr.org/</a>
</li>

<li>GMP: Arithmetic without limitations<br />
<a href="https://gmplib.org/">https://gmplib.org/</a>
</li>

<li>GNU MP 6.2.1 manual<br />
<a href="https://gmplib.org/manual/index">https://gmplib.org/manual/index</a>
</li>

<li>Anatomy of a posit number<br />
<a href="https://www.johndcook.com/blog/2018/04/11/anatomy-of-a-posit-number/">https://www.johndcook.com/blog/2018/04/11/anatomy-of-a-posit-number/</a>
</li>

<li>Better floating point: posits in plain language<br />
<a href="http://loyc.net/2019/unum-posits.html">http://loyc.net/2019/unum-posits.html</a>
</li>

<li>Posits, a New Kind of Number, Improves the Math of AI: The first posit-based processor core gave a ten-thousandfold accuracy boost<br />
<a href="https://spectrum.ieee.org/floating-point-numbers-posits-processor">https://spectrum.ieee.org/floating-point-numbers-posits-processor</a>
</li>

<li>Posit Standard Document (2022)<br />
<a href="https://posithub.org/khub_widget">https://posithub.org/khub_widget</a>
</li>

<li>Standard for Posit™ Arithmetic (2022)<br />
<a href="https://posithub.org/docs/posit_standard-2.pdf">https://posithub.org/docs/posit_standard-2.pdf</a>
</li>

<li>Posit Calculator<br />
<a href="https://posithub.org/widget/calculator/">https://posithub.org/widget/calculator/</a>
</li>

<li>SoftPosit<br />
<a href="https://gitlab.com/cerlane/SoftPosit">https://gitlab.com/cerlane/SoftPosit</a>
</li>

<li>PySigmoid<br />
<a href="https://github.com/mightymercado/PySigmoid">https://github.com/mightymercado/PySigmoid</a>
</li>

<li>sgpositpy<br />
<a href="https://github.com/xman/sgpositpy">https://github.com/xman/sgpositpy</a>
</li>

<li>SoftPosit.jl<br />
<a href="https://github.com/milankl/SoftPosit.jl">https://github.com/milankl/SoftPosit.jl</a>
</li>

<li>SigmoidNumbers.jl<br />
<a href="https://github.com/MohHizzani/SigmoidNumbers.jl">https://github.com/MohHizzani/SigmoidNumbers.jl</a>
</li>

<li>How many digits can float8, float16, float32, float64, and float128 contain?<br />
<a href="https://stackoverflow.com/questions/56514892/how-many-digits-can-float8-float16-float32-float64-and-float128-contain">https://stackoverflow.com/questions/56514892/how-many-digits-can-float8-float16-float32-float64-and-float128-contain</a>
</li>

<li>15. Floating Point Arithmetic: Issues and Limitations (Python documentation)<br />
<a href="https://docs.python.org/3/tutorial/floatingpoint.html">https://docs.python.org/3/tutorial/floatingpoint.html</a>
</li>

<li>Number limits, overflow, and roundoff<br />
<a href="https://www.khanacademy.org/computing/computers-and-internet/xcae6f4a7ff015e7d:digital-information/xcae6f4a7ff015e7d:limitations-of-storing-numbers/a/number-limits-overflow-and-roundoff">https://www.khanacademy.org/computing/computers-and-internet/xcae6f4a7ff015e7d:digital-information/xcae6f4a7ff015e7d:limitations-of-storing-numbers/a/number-limits-overflow-and-roundoff</a>
</li>

<li>The upper and lower limits of IEEE-754 standard<br />
<a href="https://math.stackexchange.com/questions/2607697/the-upper-and-lower-limits-of-ieee-754-standard">https://math.stackexchange.com/questions/2607697/the-upper-and-lower-limits-of-ieee-754-standard</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>
