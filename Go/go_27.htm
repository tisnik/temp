<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Skriptovací jazyk Lua v aplikacích naprogramovaných v Go</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Skriptovací jazyk Lua v aplikacích naprogramovaných v Go</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešní části seriálu o programovacím jazyku Go se seznámíme s tím, jakým způsobem je možné aplikace naprogramované v Go ovládat (skriptovat) s využitím skriptovacího jazyka Lua, který je pro tyto účely, tj. pro vestavění do jiných aplikací, poměrně často používán.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Využití jazyka Lua v&nbsp;aplikacích naprogramovaných v&nbsp;Go</a></p>
<p><a href="#k02">2. Programovací jazyk Lua &bdquo;vestavitelný&ldquo; do dalších aplikací</a></p>
<p><a href="#k03">3. Vestavění jazyka Lua do vlastních aplikací naprogramovaných v&nbsp;Go</a></p>
<p><a href="#k04">4. Načtení a spuštění Lua skriptu uloženého v&nbsp;řetězci</a></p>
<p><a href="#k05">5. Víceřádkové řetězce v&nbsp;jazyku Go</a></p>
<p><a href="#k06">6. Načtení a spuštění skriptů uložených v&nbsp;samostatných souborech</a></p>
<p><a href="#k07">7. Inicializace několika virtuálních strojů jazyka Lua</a></p>
<p><a href="#k08">8. Gorutiny a virtuální stroje jazyka Lua</a></p>
<p><a href="#k09">9. Volání funkce vytvořené v&nbsp;jazyku Lua z&nbsp;Go</a></p>
<p><a href="#k10">10. Předání parametrů do funkce naprogramované v&nbsp;jazyku Lua</a></p>
<p><a href="#k11">11. Zpracování návratové hodnoty</a></p>
<p><a href="#k12">12. Konverze návratových hodnot na typy kompatibilní s&nbsp;jazykem Go</a></p>
<p><a href="#k13">13. Datový typ <strong>boolean</strong> v&nbsp;programovacím jazyce Lua</a></p>
<p><a href="#k14">14. Datový typ <strong>nil</strong> v&nbsp;programovacím jazyce Lua</a></p>
<p><a href="#k15">15. Zpracování většího množství návratových hodnot ze skriptu naprogramovaného v&nbsp;jazyce Lua</a></p>
<p><a href="#k16">16. Volání funkcí naprogramovaných v&nbsp;Go z&nbsp;Lua skriptu</a></p>
<p><a href="#k17">17. Registrace funkce, která se má z&nbsp;Lua skriptů zavolat</a></p>
<p><a href="#k18">18. Zpracování parametrů a návratových hodnot</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Využití jazyka Lua v&nbsp;aplikacích naprogramovaných v&nbsp;Go</h2>

<p>Programovací jazyk <i>Lua</i>, jemuž jsme se věnovali <a
href="https://www.root.cz/serialy/programovaci-jazyk-lua/">v&nbsp;samostatném
seriálu</a>, patří do poměrně rozsáhlé a stále častěji používané skupiny
vysokoúrovňových skriptovacích jazyků, do níž můžeme zařadit například dnes
velmi populární <i>Python</i>, jazyk <i>Perl</i>, <i>Ruby</i>,
<i>JavaScript</i> popř.&nbsp;<i>TypeScript</i> či dnes již poněkud méně
populární skriptovací jazyk <i>Tcl</i>. Tyto programovací jazyky nabízí
vývojářům jednoduchou práci se strukturovanými daty (většinou je použita nějaká
forma asociativního pole), dynamicky typované proměnné, automatickou správu
paměti (<i>garbage collector</i>) a mnohé další vysokoúrovňové techniky
zjednodušující a především do značné míry zrychlující vývoj, ať již prototypů,
či výsledných aplikací. Jazyk <i>Lua</i> má navíc velmi jednoduchou &ndash; a
pro mnoho vývojářů důvěrně známou &ndash; syntaxi inspirovanou <i>Modulou</i> a
<i>Pascalem</i>, zatímco sémantika jazyka se v&nbsp;mnohém podobá spíše
moderním verzím <i>JavaScriptu</i> a <i>Pythonu</i>.</p>

<p>Někteří programátoři si jazyk <i>Lua</i> oblíbili právě kvůli jeho syntaxi,
která zbytečně nepřináší žádné nové prvky (snad jen zápis relačního operátoru
nerovnosti pomocí <strong>~=</strong> je přinejmenším podivný a neobvyklý;
někoho zpočátku může mást i indexování prvků od jedničky). Naopak se snaží
programátorům ulehčit život, například možností zápisu vícenásobného přiřazení,
přístupu k&nbsp;položkám asociativního pole jak pomocí &bdquo;tečkové&ldquo;
notace, tak i s&nbsp;využitím hranatých závorek apod. Jednoduše použitelná
syntaxe a současně i velká vyjadřovací schopnost jazyka <i>Lua</i> by však
pravděpodobně ve velké konkurenci v&nbsp;žádném případě nedostačovala pro jeho
masovější rozšíření. Důvodem, proč jsou některé hry, například <i>Escape from
Monkey Island</i>, <i>Grim Fandango</i>, <i>Fish Fillets</i>, <i>Neverwinter
Nights</i> či <i>MDK2</i> z&nbsp;menší či větší části naprogramované právě
v&nbsp;<i>Lue</i>, spočívá v&nbsp;tom, že kombinace nízkoúrovňového a
skriptovacího jazyka umožňuje soustředit se při vývoji na podstatné věci
&ndash; herní engine vytvořit co nejefektivnější s&nbsp;využitím všech možností
nízkoúrovňového jazyka a naopak herní scénář a logiku hry naskriptovat
s&nbsp;co největším urychlením cyklu oprava&ndash;překlad&ndash;spuštění.</p>

<p>V&nbsp;mnoha případech se také využívá další užitečné vlastnosti jazyka
<i>Lua</i> &ndash; celý překladač i interpret vygenerovaného bajtkódu
(popř.&nbsp;pouze interpret &ndash; všechny pojmy jsou vysvětleny dále) je
možné velmi snadno zabudovat do jiné aplikace, přičemž se výsledná velikost
spustitelného souboru této aplikace zvětší o cca 70 kB (popř.&nbsp;lze volat
dynamickou knihovnu o řádově stejné velikosti), což není mnoho, když si
uvědomíme, že dostáváme k&nbsp;dispozici plnohodnotný vysokoúrovňový
programovací jazyk (ostatně <i>Lua</i> se díky své malé velikosti používá i pro
&bdquo;pouhé&ldquo; zpracování konfiguračních souborů, které díky tomu mohou
obsahovat různé konstanty, výrazy, podmínky atd.). Mnozí programátoři, mezi
jinými i John Walker (jeden z&nbsp;vývojářů <i>AutoCADu</i>) se netají tím, že
právě zabudování programovacího (skriptovacího) jazyka do jejich aplikací mělo
velký význam pro jejich úspěch, protože to umožnilo mnoha dalším vývojářům
rozšiřovat funkčnost původní aplikace a tím zvýšit její atraktivitu pro
další uživatele.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Programovací jazyk Lua &bdquo;vestavitelný&ldquo; do dalších aplikací</h2>

<p>Jeden z&nbsp;dalších důvodů relativně velké oblíbenosti programovacího
jazyka <i>Lua</i> mezi vývojáři spočívá v&nbsp;tom, že její překladač i
interpret je velmi snadno &bdquo;vestavitelný&ldquo; do dalších aplikací, což
znamená, že do prakticky libovolného programu je možné zabudovat buď
plnohodnotný překladač tohoto jazyka, nebo pouze tu část, která se stará o běh
přeloženého bajtkódu (častěji se však setkáme s&nbsp;prvním způsobem
integrace). V&nbsp;některých typech aplikací, například počítačových hrách,
totiž nemusí být nutné překládat nové zdrojové kódy, ale pouze spouštět bajtkód
přeložený přímo výrobcem hry; další aplikace naopak mohou těžit z&nbsp;toho, že
jsou uživatelsky skriptovatelné (viz většina moderních &bdquo;Office&ldquo;,
mnohé programy typu CAD, grafické a textové editory a mnoho dalších programů).
Samozřejmě se nejedná o unikátní vlastnost, protože i mnoho interpretů dalších
programovacích jazyků lze vestavět do jiných aplikací &ndash; v&nbsp;poslední
době se stává populární především <i>JavaScript</i> vedle již zavedeného
<i>Pythonu</i> (LibreOffice a samozřejmě i OpenOffice.org, GIMP), <i>Scheme</i>
(opět GIMP), <i>Lispu</i> (výše zmíněný AutoCAD, Emacs) či <i>Visual Basicu</i>
(MS Office a další aplikace podporující VBA neboli <i>Visual Basic for
Applications</i>).</p>

<p>Ovšem v&nbsp;případě programovacího jazyka <i>Lua</i> je její vestavění do
aplikace skutečně snadné &ndash; z&nbsp;pohledu programátora (především pokud
programuje v&nbsp;céčku či C++), který ve své aplikaci potřebuje použít nějaký
skriptovací jazyk, se jedná o pouhých několik programových řádků
s&nbsp;následným slinkováním s&nbsp;objektovým kódem uloženým v&nbsp;archivu
<strong>liblua.a</strong>. Vložením celého překladače a interpretu jazyka
<i>Lua</i> včetně jeho podpůrného běhového prostředí (základní funkce, garbage
collector aj.) se zvětší velikost výsledného spustitelného souboru o již
zmíněných 70 kB, což není nijak závratná hodnota, především při porovnání
velikostí interpretů dalších programovacích jazyků. <i>Lua</i> se právě
z&nbsp;tohoto důvodu dokonce používá i na mikrořadičích s&nbsp;poměrně malou
operační pamětí a pamětí ROM (v&nbsp;jedné z&nbsp;aplikací využívajících
<i>Lua</i> byl použit mikrořadič s&nbsp;64 kB RAM a 256 kB EEPROM).
V&nbsp;tomto případě se většinou využívá pouze ta část interpretu, která se
stará o běh přeloženého bajtkódu, v&nbsp;některých situacích se také mění
základní numerický datový typ na šestnáctibitové či třicetidvoubitové hodnoty
namísto hodnot uložených ve formátu plovoucí tečky (viz soubor
<i>luaconf.h</i>, především definice <i>LUA_NUMBER</i>).</p>

<p>Vestavěný interpret programovacího jazyka <i>Lua</i> do jisté míry řeší
taktéž otázku bezpečnosti skriptů, aby se zabránilo šíření makrovirů, které
byly tak &bdquo;populární&ldquo; mezi uživateli jednoho nejmenovaného
rozšířeného kancelářského balíku. Problém bezpečnosti je řešen především
prakticky úplnou izolací běhového prostředí skriptů od ostatního systému. Pouze
přímo programátor aplikace, která má obsahovat překladač a interpret
<i>Lua</i>, může (explicitně zapsaným importem příslušné knihovny) skriptům
povolit například možnost práce se soubory, spouštění dalších programů přes
volání <i>os.execute()</i> apod. Bez importu těchto knihoven je skriptu
povoleno se svým okolím komunikovat pouze pomocí volání zaregistrovaných
funkcí. Pro předávání parametrů se navíc používá zvláštní zásobník, ne
standardní zásobníkové rámce (na klasický zásobníkový rámec se ukládá pouze
jeden ukazatel), takže skripty vlastně ani nemají možnost manipulovat se
zásobníkem procesu pod kterým běží (tím se eliminují útoky typu <i>stack
overflow</i>). Interpret provádí i základní kontrolu korektnosti předaného
bajtkódu.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vestavění jazyka Lua do vlastních aplikací naprogramovaných v&nbsp;Go</h2>

<p>Vzhledem k&nbsp;tomu, že interpret skriptovacího jazyka Lua je navržen
takovým způsobem, aby byl poměrně snadno implementovatelný, asi nebude větším
překvapením, že jeho zdrojové kódy byly portovány i do programovacího jazyka
Go. To znamená, že se jedná o novou &bdquo;go-nativní&ldquo; implementaci
interpretru Luy, která nevyžaduje, aby se z&nbsp;runtime jazyka Go volaly
funkce z&nbsp;původní céčkovské knihovny. Touto problematikou jsme se sice
prozatím do všech podrobností nezabývali, ovšem ve stručnosti lze říct, že
kooperace mezi runtime jazyka Go a nativními céčkovými knihovnami může
v&nbsp;praxi způsobovat problémy a není z&nbsp;pohledu programátorů zcela
transparentní. Samotné vložení interpretru jazyka Lua do aplikace psané
v&nbsp;Go je ovšem velmi snadné &ndash; programátor jen musí naimportovat
příslušný balíček, inicializovat virtuální stroj jazyka Lua a spustit nějaký
skript, jenž může být reprezentován řetězcem nebo může být načten ze souboru.
Skript poté může volat <i>předem vybrané</i> funkce naprogramované
v&nbsp;jazyku Go a naopak &ndash; z&nbsp;Go lze volat libovolnou funkci
z&nbsp;Lua skriptu.</p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti existuje hned několik
projektů, které programátorům používajícím jazyk Go zpřístupňují interpret
skriptovacího jazyka Lua. Jedná se o projekty <a
href="https://github.com/yuin/gopher-lua">Gopher-Lua</a>, <a
href="https://github.com/Shopify/go-lua">go-lua</a> a taktéž <a
href="https://github.com/aarzilli/golua">golua</a> (interface k&nbsp;původnímu
céčkovému interpretru). Rozšířením dnešní knihovny je <a
href="https://github.com/alexeyco/binder">Binder</a>.</div></p>

<p>Dnes se budeme zabývat projektem nazvaným <strong>Gopher-Lua</strong>. Ten
se instaluje velmi snadno &ndash; stejně jako jakýkoli jiný balíček určený pro
Go:</p>

<pre>
$ <strong>go get github.com/yuin/gopher-lua</strong>
</pre>

<p>Výsledkem bude běžný balíček, nikoli spustitelný binární soubor &ndash;
<strong>Gopher-Lua</strong> předpokládá, že se jazyk Lua skutečně bude vkládat
(<i>embed</i>) do jiných aplikací.</p>

<p><div class="rs-tip-major">Poznámka: počítejte s&nbsp;tím, že Lua
implementovaná v&nbsp;Go není v&nbsp;žádném případě pojata tak minimalisticky,
jako je tomu u původní céčkové varianty. Výsledný binární soubor po přidání
balíčku <strong>Gopher-Lua</strong> naroste o cca 1,7 MB (před případným
<strong>strip</strong>-em), což je již velké číslo. Samotný přeložený balíček
<strong>gopher-lua.a</strong> má na 64bitovém systému velikost 2043996
bajtů.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Načtení a spuštění Lua skriptu uloženého v&nbsp;řetězci</h2>

<p>V&nbsp;této kapitole si ukážeme, jakým způsobem se vlastně přímo
z&nbsp;aplikace naprogramované v&nbsp;Go inicializuje virtuální stroj
skriptovacího jazyka Lua a jak se v&nbsp;něm spustí nějaký skript.</p>

<p><div class="rs-tip-major">Poznámka: pod pojmem &bdquo;virtuální stroj&ldquo;
si nepředstavujte nějaký obrovský a &bdquo;všemocný&ldquo; nástroj typu JRE,
protože v&nbsp;případě jazyka Lua se jedná o poměrně minimalistický
projekt.</div></p>

<p>V&nbsp;aplikaci, která chce uživatelům nabídnout možnosti skriptování
s&nbsp;využitím jazyka Lua, je nejprve nutné naimportovat balíček
s&nbsp;implementací interpretru a VM Luy:</p>

<pre>
import "github.com/yuin/gopher-lua"
</pre>

<p>Jednotlivé instance VM (může jich být totiž větší množství) se inicializují
zavoláním funkce <strong></strong>. Výsledkem je struktura, přes kterou se
s&nbsp;vytvořeným virtuálním strojem komunikuje:</p>

<pre>
luaVM := lua.NewState()
</pre>

<p>Inicializovaný virtuální stroj by se měl před ukončením aplikace korektně
zastavit a uvolnit všechny své prostředky. V&nbsp;Go je možné tento požadavek
splnit velmi snadno s&nbsp;využitím konstrukce <strong>defer</strong>:</p>

<pre>
defer luaVM.Close()
</pre>

<p>A nakonec můžeme spustit libovolný skript či jeho část. V&nbsp;tom
nejjednodušším případě je skript reprezentován řetězcem a při pokusu o jeho
spuštění můžeme zjistit, zda nedošlo k&nbsp;nějaké chybě:</p>

<pre>
err := luaVM.DoString(`print("Hello from Lua")`)
if err != nil {
        log.Fatal(err)
}
</pre>

<p>Úplný <a
href="https://github.com/tisnik/go-root/blob/master/article_27/01_do_string_1.go">zdrojový
kód dnešního prvního demonstračního příkladu</a>, který po svém spuštění
provede inicializaci virtuálního stroje jazyka Lua a spustí v&nbsp;něm
jednořádkový skript, vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/yuin/gopher-lua"
        "log"
)
&nbsp;
func <strong>main</strong>() {
        luaVM := lua.NewState()
&nbsp;
        defer luaVM.Close()
&nbsp;
        err := luaVM.DoString(`print("Hello from Lua")`)
        if err != nil {
                log.Fatal(err)
        }
}
</pre>

<p>Po spuštění tohoto demonstračního příkladu se vypíše jediný řádek textu:</p>

<pre>
Hello from Lua
</pre>

<p><a
href="https://github.com/tisnik/go-root/blob/master/article_27/02_do_string_2.go">Další
demonstrační příklady</a> nepatrně vylepšíme tím, že se při inicializaci i
deinicializaci virtuálního stroje jazyka Lua budou vypisovat zprávy do logu
s&nbsp;využitím standardního balíčku <strong>log</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/yuin/gopher-lua"
        "log"
)
&nbsp;
func <strong>main</strong>() {
        luaVM := lua.NewState()
        log.Println("Lua VM has been initialized")
&nbsp;
        defer func() {
                luaVM.Close()
                log.Println("Lua VM has been closed")
        }()
&nbsp;
        err := luaVM.DoString(`print("Hello from Lua!")`)
        if err != nil {
                log.Fatal(err)
        }
}
</pre>

<p>Výsledek může vypadat například takto:</p>

<pre>
2019/05/24 20:50:43 Lua VM has been initialized
Hello from Lua!
2019/05/24 20:50:43 Lua VM has been closed
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Víceřádkové řetězce v&nbsp;jazyku Go</h2>

<p>Již v&nbsp;prvních dvou demonstračních příkladech jsme se mohli setkat
s&nbsp;tím, že skripty zapsané v&nbsp;jazyku Lua byly reprezentovány řetězcem,
ovšem tento řetězec nebyl uzavřen do běžných uvozovek "", ale do zpětných
apostrofů ``. Jedná se o takzvaný &bdquo;raw string literal&ldquo;, což je
konstanta typu řetězec, který je při kompilaci načten přesně v&nbsp;takové
formě, jak je zapsán, tj.&nbsp;bez interpretace speciálních znaků začínajících
zpětným lomítkem atd. V&nbsp;těchto řetězcích je taktéž možné použít konce
řádků, což není u běžných řetězců povoleno (minimálně nikoli
v&nbsp;programovacím jazyku Go). Naproti tomu pokud je řetězec uzavřen do
běžných uvozovek "", jedná se o takzvaný &bdquo;interpreted string
literal&ldquo;, v&nbsp;němž jsou speciálně interpretována zpětná lomítka, za
nimiž je možné zapsat kód speciálního znaku (<strong>\n</strong> je konec
řádku, <strong>\t</strong> znak Tab, <strong>\xnn</strong> ASCII kód znaku,
<strong>\unnn</strong> a <strong>\Unnnnnnnn</strong> Unicode znak atd.).
V&nbsp;těchto řetězcích se nesmí použít konec řádku, což je ovšem dosti
nevýhodné pro zápis kódu v&nbsp;jiném programovacím jazyce do řetězce.</p>

<p>Právě z&nbsp;tohoto důvodu jsme v&nbsp;demonstračních příkladech použili
řetězce zapsané do zpětných apostrofů. A díky tomu, že v&nbsp;raw řetězcích je
možné použít i konce řádků, můžeme do nich bez problémů zapsat i složitější
několikařádkové skripty, například:</p>

<pre>
const Script = `
for i = 1,10 do
    print("Hello from Lua!", i)
end`
</pre>

<p><div class="rs-tip-major">Poznámka: pochopitelně je nutné dát pozor na to,
aby se ve skriptech nevyskytoval zpětný apostrof, což však není v&nbsp;jazyku
Lua příliš často.</div></p>

<p><a
href="https://github.com/tisnik/go-root/blob/master/article_27/02B_do_string_3.go">Úplný
demonstrační příklad</a>, v&nbsp;němž je použit několikařádkový Lua skript,
může vypadat následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/yuin/gopher-lua"
        "log"
)
&nbsp;
const Script = `
for i = 1,10 do
    print("Hello from Lua!", i)
end`
&nbsp;
func <strong>main</strong>() {
        luaVM := lua.NewState()
        log.Println("Lua VM has been initialized")
&nbsp;
        defer func() {
                luaVM.Close()
                log.Println("Lua VM has been closed")
        }()
&nbsp;
        log.Println("Starting the following Lua script:")
        log.Println(Script)
&nbsp;
        err := luaVM.DoString(Script)
        if err != nil {
                log.Fatal(err)
        }
}
</pre>

<p>Po spuštění tohoto příkladu by se na standardním výstupu měly objevit
informace o inicializaci virtuálního stroje jazyka Lua a následně i výsledek
spuštěného skriptu (celkem deset řádků):</p>

<pre>
2019/05/24 20:50:54 Lua VM has been initialized
2019/05/24 20:50:54 Starting the following Lua script:
2019/05/24 20:50:54 
for i = 1,10 do
    print("Hello from Lua!", i)
end
Hello from Lua! 1
Hello from Lua! 2
Hello from Lua! 3
Hello from Lua! 4
Hello from Lua! 5
Hello from Lua! 6
Hello from Lua! 7
Hello from Lua! 8
Hello from Lua! 9
Hello from Lua! 10
2019/05/24 20:50:54 Lua VM has been closed
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Načtení a spuštění skriptů uložených v&nbsp;samostatných souborech</h2>

<p>Spuštění skriptů reprezentovaných řetězci jazyka Go se v&nbsp;praxi
pravděpodobně nebude příliš často používat. Mnohem častěji se setkáme
s&nbsp;požadavkem, aby se spustily skripty uložené v&nbsp;externích souborech.
I tuto možnost nám pochopitelně interpret programovacího jazyka Go nabízí, což
si ukážeme na <a
href="https://github.com/tisnik/go-root/blob/master/article_27/03_do_file.go">dalším
demonstračním příkladu</a>. V&nbsp;tomto příkladu je použita metoda
<strong></strong> pro načtení a spuštění Lua skriptu přečteného
z&nbsp;externího souboru:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/yuin/gopher-lua"
        "log"
)
&nbsp;
const LuaSource = "hello.lua"
&nbsp;
func <strong>main</strong>() {
        luaVM := lua.NewState()
        log.Println("Lua VM has been initialized")
&nbsp;
        defer func() {
                luaVM.Close()
                log.Println("Lua VM has been closed")
        }()
&nbsp;
        err := luaVM.DoFile(LuaSource)
        if err != nil {
                log.Fatal(err)
        }
}
</pre>

<p>Samotný skript <strong>hello.lua</strong> je až triviálně jednoduchý:</p>

<pre>
for i = 1,10 do
    print("Hello #", i)
end
</pre>

<p>Výsledek spuštění předchozího demonstračního příkladu:</p>

<pre>
2019/05/26 20:31:58 Lua VM has been initialized
Hello # 1
Hello # 2
Hello # 3
Hello # 4
Hello # 5
Hello # 6
Hello # 7
Hello # 8
Hello # 9
Hello # 10
2019/05/26 20:31:58 Lua VM has been closed
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Inicializace několika virtuálních strojů jazyka Lua</h2>

<p>Každý virtuální stroj získaný zavoláním funkce
<strong>lua.NewState()</strong> poskytuje skriptům vzájemnou izolaci. To
například znamená, že jednotlivé skripty nebudou mít přístup ke svým globálním
proměnným (a to proměnným jakéhokoli typu, tedy i k&nbsp;funkcím). Toto chování
si pochopitelně můžeme velmi snadno otestovat, a to tak, že vytvoříme dva
virtuální stroje a spustíme v&nbsp;nich různé skripty. Nejdříve se podívejme na
<a
href="https://github.com/tisnik/go-root/blob/master/article_27/04_two_vms.go">úplný
zdrojový kód demonstračního příkladu</a></p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/yuin/gopher-lua"
        "log"
)
&nbsp;
const LuaSource1 = "v1.lua"
const LuaSource2 = "v2.lua"
const LuaSource3 = "v3.lua"
&nbsp;
func <strong>main</strong>() {
        luaVM1 := lua.NewState()
        log.Println("Lua VM1 has been initialized")
&nbsp;
        luaVM2 := lua.NewState()
        log.Println("Lua VM2 has been initialized")
&nbsp;
        defer func() {
                luaVM1.Close()
                log.Println("Lua VM1 has been closed")
        }()
&nbsp;
        defer func() {
                luaVM2.Close()
                log.Println("Lua VM2 has been closed")
        }()
&nbsp;
        err := luaVM1.DoFile(LuaSource1)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        err = luaVM2.DoFile(LuaSource2)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        err = luaVM1.DoFile(LuaSource3)
        if err != nil {
                log.Fatal(err)
        }
}
</pre>

<p>Vidíme, že z&nbsp;prvního virtuálního stroje se volá skript
<strong>v1.lua</strong> a <strong>v3.lua</strong>, zatímco ze druhého stroje
pouze skript <strong>v2.lua</strong>. Interně jsou tyto skripty prakticky
totožné:</p>

<pre>
print("v1.lua, x=", x)
x = 10
print("v1.lua, x=", x)
</pre>

<pre>
print("v2.lua, x=", x)
x = 10
print("v2.lua, x=", x)
</pre>

<pre>
print("v3.lua, x=", x)
x = 10
print("v3.lua, x=", x)
</pre>

<p>Vidíme, že všechny tři skripty se nejdříve pokusí vypsat hodnotu globální
proměnné <strong>x</strong>, následně tuto hodnotu změní a znovu ji vypíšou.
Pokud budou skripty zcela izolované, měla by se vždy vypsat speciální hodnota
<strong>nil</strong> a teprve poté hodnota 10. Pokud jsou naopak všechny
skripty sdílené v&nbsp;jediné VM, vypíše se hodnota <strong>nil</strong> pouze
jedenkrát. A konečně v&nbsp;případě, že jsou skripty spouštěné v&nbsp;různých
VM navzájem izolované, měla by se hodnota <strong>nil</strong> vypsat dvakrát.
Podívejme se tedy na skutečný výsledek běhu tohoto příkladu:</p>

<pre>
2019/05/26 20:43:31 Lua VM1 has been initialized
2019/05/26 20:43:31 Lua VM2 has been initialized
v1.lua, x=      nil
v1.lua, x=      10
v2.lua, x=      nil
v2.lua, x=      10
v3.lua, x=      10
v3.lua, x=      10
2019/05/26 20:43:31 Lua VM2 has been closed
2019/05/26 20:43:31 Lua VM1 has been closed
</pre>

<p>Z&nbsp;výsledků je patrné, že skripty <strong>v1.lua</strong> a
<strong>v3.lua</strong> sdílí prostor se svými globálními proměnnými. To je
v&nbsp;pořádku, neboť běží v&nbsp;rámci jedné VM.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Gorutiny a virtuální stroje jazyka Lua</h2>

<p>Interní stav VM implementovaný v&nbsp;projektu <strong>Gopher-Lua</strong>
není zcela zabezpečen proti problémům, které vzniknou, pokud by se spustilo
více skriptů v&nbsp;několika gorutinách v&nbsp;jediném VM. Nic nám však
pochopitelně nebrání vytvořit si několik gorutin, v&nbsp;každé gorutině
inicializovat vlastní VM a v&nbsp;něm potom spustit Lua skripty s&nbsp;tím, že
případná komunikace bude provedena s&nbsp;využitím kanálů. V&nbsp;dalším
demonstračním příkladu je ukázáno, jakým způsobem se paralelně spustí dva Lua
skripty, každý ve své vlastní VM:</p>

<pre>
for i = 1,10 do
    print("Hello from VM1", i)
end
</pre>

<pre>
for i = 1,10 do
    print("Hello from VM2", i)
end
</pre>

<p>Samotné spuštění gorutin se nijak nevymyká informacím, které známe
z&nbsp;předchozích částí tohoto seriálu. Jen pochopitelně nesmíme zapomenout
počkat na dokončení všech vytvořených gorutin, a to s&nbsp;využitím kanálů
&ndash; každá gorutina na konci zapíše do příslušného kanálu jednu hodnotu, na
kterou čekáme v&nbsp;hlavní gorutině:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/yuin/gopher-lua"
        "log"
)
&nbsp;
const LuaSource1 = "l1.lua"
const LuaSource2 = "l2.lua"
&nbsp;
func callLuaVM1(c chan bool) {
        defer func() { c &lt;- true }()
&nbsp;
        luaVM1 := lua.NewState()
        log.Println("Lua VM1 has been initialized")
&nbsp;
        defer func() {
                luaVM1.Close()
                log.Println("Lua VM1 has been closed")
        }()
&nbsp;
        err := luaVM1.DoFile(LuaSource1)
        if err != nil {
                log.Fatal(err)
        }
}
&nbsp;
func callLuaVM2(c chan bool) {
        defer func() { c &lt;- true }()
&nbsp;
        luaVM2 := lua.NewState()
        log.Println("Lua VM2 has been initialized")
&nbsp;
        defer func() {
                luaVM2.Close()
                log.Println("Lua VM2 has been closed")
        }()
&nbsp;
        err := luaVM2.DoFile(LuaSource2)
        if err != nil {
                log.Fatal(err)
        }
}
&nbsp;
func <strong>main</strong>() {
        c1 := make(chan bool)
        c2 := make(chan bool)
&nbsp;
        go callLuaVM1(c1)
        go callLuaVM2(c2)
&nbsp;
        &lt;-c1
        &lt;-c2
}
</pre>

<p>Výpis ze skriptů se kvůli nezavolání funkce <strong>flush()</strong> po
každém volání <strong>print()</strong> navzájem pomíchá:</p>

<pre>
2019/05/26 20:53:14 Lua VM1 has been initialized
2019/05/26 20:53:14 Lua VM2 has been initialized
Hello from VM2  Hello from VM1  1
Hello from VM1  2
Hello from VM1  3
1
Hello from VM1  4
Hello from VM1  5
Hello from VM1  6
Hello from VM1Hello from VM2            7
Hello from VM1  8
Hello from VM1  9
Hello from VM1  10
2019/05/26 20:53:14 Lua VM1 has been closed
2
Hello from VM2  3
Hello from VM2  4
Hello from VM2  5
Hello from VM2  6
Hello from VM2  7
Hello from VM2  8
Hello from VM2  9
Hello from VM2  10
2019/05/26 20:53:14 Lua VM2 has been closed
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Volání funkce vytvořené v&nbsp;jazyku Lua z&nbsp;Go</h2>

<p>Tím hlavním důvodem, proč se do aplikací naprogramovaných v&nbsp;jazyku Go
vkládá interpret skriptovacího jazyka Lua, je možnost kooperace mezi oběma
částmi aplikace &ndash; tj.&nbsp;mezi nativní částí vytvořenou přímo v&nbsp;Go
a skripty napsanými v&nbsp;jazyce Lua. Kooperace přitom může být
obousměrná:</p>

<ol>

<li>Z&nbsp;aplikace napsané v&nbsp;Go je umožněno volat funkce naprogramované
(naskriptované) v&nbsp;jazyku Lua. To se samozřejmě týká i možnosti předávání
parametrů a zpracování návratové hodnoty či návratových hodnot.</li>

<li>A naopak, ze skriptu napsaného v&nbsp;jazyce Lua lze volat zvolené
(registrované) funkce naprogramované v&nbsp;Go.</li>

</ol>

<p>Nejdříve si ukážeme tu nejjednodušší variantu, tj.&nbsp;zavolání funkce
naskriptované v&nbsp;jazyce Lua. Celý Lua skript, v&nbsp;němž je funkce
definována, vypadá takto:</p>

<pre>
function <strong>hello</strong>()
    print("Hello from Lua")
end
</pre>

<p>Samotné zavolání funkce <strong>hello</strong> je zpočátku komplikované,
protože je nutné nastavit jak jméno funkce, tak i počet a typ předávaných
parametrů i typ a počet návratových hodnot. V&nbsp;našem případě je funkce
volána bez parametrů a nemá žádné návratové hodnoty, takže ji můžeme zavolat
takto:</p>

<pre>
err = luaVM.CallByParam(lua.P{
        Fn:   luaVM.GetGlobal("hello"),
        NRet: 0,
})
</pre>

<p>Úplný zdrojový kód příkladu, který po svém spuštění zavolá Lua funkci,
naleznete na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_27/06_call_lua.go">https://github.com/tisnik/go-root/blob/master/article_27/06_call_lua.go</a>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/yuin/gopher-lua"
        "log"
)
&nbsp;
const LuaSource = "function.lua"
&nbsp;
func <strong>main</strong>() {
        luaVM := lua.NewState()
        log.Println("Lua VM has been initialized")
&nbsp;
        defer func() {
                luaVM.Close()
                log.Println("Lua VM has been closed")
        }()
&nbsp;
        err := luaVM.DoFile(LuaSource)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        err = luaVM.CallByParam(lua.P{
                Fn:   luaVM.GetGlobal("hello"),
                NRet: 0,
        })
&nbsp;
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
}
</pre>

<p>Spuštění příkladu:</p>

<pre>
2019/05/26 20:37:26 Lua VM has been initialized
Hello from Lua
2019/05/26 20:37:26 Lua VM has been closed
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Předání parametrů do funkce naprogramované v&nbsp;jazyku Lua</h2>

<p>Nyní se podívejme, jak se vlastně předávají parametry z&nbsp;aplikace psané
v&nbsp;Go do funkce/funkcí naprogramovaných ve skriptovacím jazyku Lua. Samotný
skript naprogramovaný v&nbsp;Lue používá dynamicky typované proměnné:</p>

<pre>
function <strong>hello</strong>(a, b)
    print("Hello from Lua")
    print("1st parameter", a)
    print("2nd parameter", b)
end
</pre>

<p>V&nbsp;aplikaci psané v&nbsp;Go je nutné zajistit převod z&nbsp;datového
typu Go na datový typ, který je zpracovatelný virtuálním strojem jazyka Lua.
Pokud se bude jednat o numerické hodnoty, použijeme toto volání:</p>

<pre>
err = luaVM.CallByParam(lua.P{
        Fn:   luaVM.GetGlobal("hello"),
        NRet: 0,
}, lua.LNumber(1), lua.LNumber(2))
</pre>

<p>Povšimněte si, že jsme dvě celočíselné hodnoty typu <strong>int</strong>
museli převést na objekty typu <strong>LNumber</strong> stejně pojmenovanou
funkcí.</p>

<p>Podívejme se nyní na úplný kód příkladu, který zavolá výše vypsanou funkci
<strong>hello()</strong> a předá ji dvě numerické hodnoty 1 a 2:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/yuin/gopher-lua"
        "log"
)
&nbsp;
const LuaSource = "function_params.lua"
&nbsp;
func <strong>main</strong>() {
        luaVM := lua.NewState()
        log.Println("Lua VM has been initialized")
&nbsp;
        defer func() {
                luaVM.Close()
                log.Println("Lua VM has been closed")
        }()
&nbsp;
        err := luaVM.DoFile(LuaSource)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        err = luaVM.CallByParam(lua.P{
                Fn:   luaVM.GetGlobal("hello"),
                NRet: 0,
        }, lua.LNumber(1), lua.LNumber(2))
&nbsp;
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
}
</pre>

<p>Výsledek po spuštění:</p>

<pre>
2019/05/26 21:09:08 Lua VM has been initialized
Hello from Lua
1st parameter   1
2nd parameter   2
2019/05/26 21:09:08 Lua VM has been closed
</pre>

<p>Naprosto stejné funkci <strong>hello()</strong> je ovšem možné předat například i dva řetězce:</p>

<pre>
err = luaVM.CallByParam(lua.P{
        Fn:   luaVM.GetGlobal("hello"),
        NRet: 0,
}, lua.LString("foo"), lua.LString("bar"))
</pre>

<p>Příklad se jen nepatrně upraví:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/yuin/gopher-lua"
        "log"
)
&nbsp;
const LuaSource = "function_params.lua"
&nbsp;
func <strong>main</strong>() {
        luaVM := lua.NewState()
        log.Println("Lua VM has been initialized")
&nbsp;
        defer func() {
                luaVM.Close()
                log.Println("Lua VM has been closed")
        }()
&nbsp;
        err := luaVM.DoFile(LuaSource)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        err = luaVM.CallByParam(lua.P{
                Fn:   luaVM.GetGlobal("hello"),
                NRet: 0,
        }, lua.LString("foo"), lua.LString("bar"))
&nbsp;
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
}
</pre>

<p>Výsledek po spuštění:</p>

<pre>
2019/05/26 21:09:25 Lua VM has been initialized
Hello from Lua
1st parameter   foo
2nd parameter   bar
2019/05/26 21:09:25 Lua VM has been closed
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Zpracování návratové hodnoty</h2>

<p>Podívejme se nyní na další velmi jednoduchou funkci naprogramovanou ve
skriptovacím jazyce Lua. Tato funkce akceptuje dva parametry, vypíše je na svůj
standardní výstup a nakonec vrátí jejich součet:</p>

<pre>
function <strong>add</strong>(a, b)
    print("1st parameter", a)
    print("2nd parameter", b)
    return a+b
end
</pre>

<p>Jakým způsobem je ovšem možné přečíst návratovou hodnotu této funkce a nějak
ji zpracovat? Pro předávání návratových hodnot (může jich být totiž více
&ndash; v&nbsp;tomto ohledu není Go prvním jazykem s&nbsp;podobným přístupem)
se používá zásobník, z&nbsp;něhož je možné hodnoty načítat metodou
<strong>Get()</strong> a odstraňovat metodou <strong>Pop()</strong>. Výsledkem
je speciální hodnota typu <strong>LValue</strong> s&nbsp;metodami
<strong>String()</strong> a <strong>Type()</strong>:</p>

<pre>
ret := luaVM.Get(-1)
luaVM.Pop(1)
println("Type", ret.Type())
println("Value", ret.String())
</pre>

<p>Při volání funkce nesmíme zapomenout zadat počet návratových hodnot:</p>

<pre>
err = luaVM.CallByParam(lua.P{
        Fn:      luaVM.GetGlobal("add"),
        <strong>NRet:    1,</strong>
        Protect: true,
}, lua.LNumber(1), lua.LNumber(2))
</pre>

<p>Podívejme se nyní na příklad, který zavolá Lua funkci určenou pro součet
dvou numerických hodnot:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/yuin/gopher-lua"
        "log"
)
&nbsp;
const LuaSource = "add.lua"
&nbsp;
func <strong>main</strong>() {
        luaVM := lua.NewState()
        log.Println("Lua VM has been initialized")
&nbsp;
        defer func() {
                luaVM.Close()
                log.Println("Lua VM has been closed")
        }()
&nbsp;
        err := luaVM.DoFile(LuaSource)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        err = luaVM.CallByParam(lua.P{
                Fn:      luaVM.GetGlobal("add"),
                NRet:    1,
                Protect: true,
        }, lua.LNumber(1), lua.LNumber(2))
&nbsp;
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        ret := luaVM.Get(-1)
        luaVM.Pop(1)
        println("Type", ret.Type())
        println("Value", ret.String())
}
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
2019/05/26 21:22:25 Lua VM has been initialized
1st parameter   1
2nd parameter   2
Type 2
Value 3
2019/05/26 21:22:25 Lua VM has been closed
</pre>

<p>Podobně můžeme zavolat Lua funkci, která spojí dva řetězce:</p>

<pre>
function <strong>concatenate</strong>(a, b)
    print("1st parameter", a)
    print("2nd parameter", b)
    return a..b
end
</pre>

<p>Příklad se upraví jen nepatrně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/yuin/gopher-lua"
        "log"
)
&nbsp;
const LuaSource = "concatenate.lua"
&nbsp;
func <strong>main</strong>() {
        luaVM := lua.NewState()
        log.Println("Lua VM has been initialized")
&nbsp;
        defer func() {
                luaVM.Close()
                log.Println("Lua VM has been closed")
        }()
&nbsp;
        err := luaVM.DoFile(LuaSource)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        err = luaVM.CallByParam(lua.P{
                Fn:      luaVM.GetGlobal("concatenate"),
                NRet:    1,
                Protect: true,
        }, lua.LString("foo"), lua.LString("bar"))
&nbsp;
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        ret := luaVM.Get(-1)
        luaVM.Pop(1)
        println("Type", ret.Type())
        println("Value", ret.String())
}
</pre>

<p>A výsledky budou pochopitelně odlišné:</p>

<pre>
2019/05/26 21:23:09 Lua VM has been initialized
1st parameter   foo
2nd parameter   bar
Type 3
Value foobar
2019/05/26 21:23:09 Lua VM has been closed
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Konverze návratových hodnot na typy kompatibilní s&nbsp;jazykem Go</h2>

<p>Typový systém programovacího jazyka Go se v&nbsp;několika ohledech odlišuje
od typového systému skriptovacího jazyka Lua. Proto asi nebude velkým
překvapením, že datové typy a hodnoty se musí explicitně konvertovat. Při
posílání parametrů funkcím do jazyka Lua se používají konverzní funkce zmíněné
v&nbsp;předchozích kapitolách. Ovšem například při čtení návratové hodnoty
(návratových hodnot) z&nbsp;Lua funkce se musí konverze provést složitějším
způsobem, a to pochopitelně z&nbsp;toho důvodu, že Go je staticky a silně
typovaný jazyk, tj.&nbsp;v&nbsp;tomto ohledu stojí na opačné straně než
dynamicky typovaný jazyk Lua. Podívejme se nyní, jak je možné konverzi provést,
zde konkrétně pro funkci vracející číslo (v&nbsp;Lua typu <i>double</i>,
v&nbsp;Go pochopitelně <i>float64</i>):</p>

<pre>
if number, ok := ret.(lua.LNumber); ok {
        println("Value", float64(number))
}
</pre>

<p>Konverzi si vyzkoušíme na funkci, která sečte své parametry a vrátí výsledek
tohoto součtu:</p>

<pre>
function <strong>add</strong>(a, b)
    print("1st parameter", a)
    print("2nd parameter", b)
    return a+b
end
</pre>

<p>Zavolání této Lua funkce se zpracováním výsledků může vypadat
následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/yuin/gopher-lua"
        "log"
)
&nbsp;
const LuaSource = "add.lua"
&nbsp;
func <strong>main</strong>() {
        luaVM := lua.NewState()
        log.Println("Lua VM has been initialized")
&nbsp;
        defer func() {
                luaVM.Close()
                log.Println("Lua VM has been closed")
        }()
&nbsp;
        err := luaVM.DoFile(LuaSource)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        err = luaVM.CallByParam(lua.P{
                Fn:      luaVM.GetGlobal("add"),
                NRet:    1,
                Protect: true,
        }, lua.LNumber(1), lua.LNumber(2))
&nbsp;
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        ret := luaVM.Get(-1)
        luaVM.Pop(1)
        println("Type", ret.Type())
        if number, ok := ret.(lua.LNumber); ok {
                println("Value", float64(number))
        }
}
</pre>

<p>Výsledek po spuštění:</p>

<pre>
2019/05/27 19:50:30 Lua VM has been initialized
1st parameter   1
2nd parameter   2
Type 2
Value +3.000000e+000
2019/05/27 19:50:30 Lua VM has been closed
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Datový typ <strong>boolean</strong> v&nbsp;programovacím jazyce Lua</h2>

<p>Pro Lua funkce, které vrací pravdivostní hodnoty <strong>true</strong> a
<strong>false</strong> se návratové hodnoty konvertují tímto postupem:</p>

<pre>
println("Result", ret == lua.LTrue)
println("Result", ret == lua.LFalse)
</pre>

<p><div class="rs-tip-major">Poznámka: existují sice i jiné možnosti, ovšem
postup ukázaný v&nbsp;předchozím odstavci je idiomatický a měl by se takto
používat. Předností tohoto postupu je fakt, že se současně provádí konverze i
test, zda je možné konverzi provést (protože obecně nemůžeme vědět, jaký typ se
vlastně v&nbsp;dynamicky typovaném jazyce v&nbsp;daný okamžik vrátí).</div></p>

<p>Ukažme si výše popsaný postup na praktickém příkladu, konkrétně na
následující Lua funkci sloužící pro porovnání hodnot, kterou budeme volat
s&nbsp;různými parametry:</p>

<pre>
function <strong>compare</strong>(a, b)
    print("1st parameter", a)
    print("2nd parameter", b)
    return a==b
end
</pre>

<p>V&nbsp;programovacím jazyku Go by se volání této funkce a zpracování její
návratové hodnoty mohlo realizovat například následujícím způsobem:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/yuin/gopher-lua"
        "log"
)
&nbsp;
const LuaSource = "compare.lua"
&nbsp;
func compareNumbers(a int, b int) {
        luaVM := lua.NewState()
        log.Println("Lua VM has been initialized")
&nbsp;
        defer func() {
                luaVM.Close()
                log.Println("Lua VM has been closed")
        }()
&nbsp;
        err := luaVM.DoFile(LuaSource)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        err = luaVM.CallByParam(lua.P{
                Fn:      luaVM.GetGlobal("compare"),
                NRet:    1,
                Protect: true,
        }, lua.LNumber(a), lua.LNumber(b))
&nbsp;
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        ret := luaVM.Get(-1)
        luaVM.Pop(1)
        println("Type", ret.Type())
        println("Value", ret.String())
        println("Result", ret == lua.LTrue)
}
&nbsp;
func <strong>main</strong>() {
        compareNumbers(1, 2)
        compareNumbers(1, 1)
}
</pre>

<p>Výsledky, které získáme po spuštění tohoto demonstračního příkladu:</p>

<pre>
2019/05/27 19:52:08 Lua VM has been initialized
1st parameter   1
2nd parameter   2
Type 1
Value false
Result false
2019/05/27 19:52:08 Lua VM has been closed
2019/05/27 19:52:08 Lua VM has been initialized
1st parameter   1
2nd parameter   1
Type 1
Value true
Result true
2019/05/27 19:52:08 Lua VM has been closed
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Datový typ <strong>nil</strong> v&nbsp;programovacím jazyce Lua</h2>

<p>Podobně je nutné správně pracovat s&nbsp;hodnotou a současně i datovým typem
<strong>nil</strong>. Konverze a test, zda Lua funkce vrátila tuto hodnotu,
může vypadat takto:</p>

<pre>
println("is nil?", ret == lua.LNil)
</pre>

<p>Opět si chování otestujme, tentokrát na velmi primitivní Lua funkci, která
za všech okolností vrátí hodnotu <strong>nil</strong>:</p>

<pre>
function <strong>return_nil</strong>()
    return <strong>nil</strong>
end
</pre>

<p>Samozřejmě si opět ukážeme úplný zdrojový kód příkladu, který tuto funkci
zavolá a zobrazí její návratovou hodnotu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/yuin/gopher-lua"
        "log"
)
&nbsp;
const LuaSource = "return_nil.lua"
&nbsp;
func <strong>main</strong>() {
        luaVM := lua.NewState()
        log.Println("Lua VM has been initialized")
&nbsp;
        defer func() {
                luaVM.Close()
                log.Println("Lua VM has been closed")
        }()
&nbsp;
        err := luaVM.DoFile(LuaSource)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        err = luaVM.CallByParam(lua.P{
                Fn:      luaVM.GetGlobal("return_nil"),
                NRet:    1,
                Protect: true,
        })
&nbsp;
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        ret := luaVM.Get(-1)
        luaVM.Pop(1)
        println("Type", ret.Type())
        println("Value", ret.String())
        println("is nil?", ret == lua.LNil)
}
</pre>

<p>Výsledek:</p>

<pre>
2019/05/27 19:53:50 Lua VM has been initialized
Type 0
Value nil
is nil? true
2019/05/27 19:53:50 Lua VM has been closed
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Zpracování většího množství návratových hodnot ze skriptu naprogramovaného v&nbsp;jazyce Lua</h2>

<p>V&nbsp;programovacích jazycích Go a Lua je možné vracet větší množství
návratových hodnot. Ukažme si nyní, jak se tyto hodnoty zpracují ve chvíli, kdy
budeme mít Lua funkci vracející své parametry, ovšem v&nbsp;opačném pořadí:</p>

<pre>
function <strong>swap</strong>(a, b)
    print("1st parameter", a)
    print("2nd parameter", b)
    return b, a
end
</pre>

<p>Návratové hodnoty můžeme získat ze zásobníku, pochopitelně v&nbsp;opačném
pořadí (jde o zásobník). Taktéž nesmíme zapomenout na odstranění těchto hodnot
ze zásobníku, aby došlo k&nbsp;jeho vyvážení:</p>

<pre>
ret1 := luaVM.Get(-2)
ret2 := luaVM.Get(-1)
luaVM.Pop(2)
</pre>

<p>Následuje výpis zdrojového kódu demonstračního příkladu, který výše uvedenou
funkci <strong>swap()</strong> zavolá a zpracuje její výsledky:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/yuin/gopher-lua"
        "log"
)
&nbsp;
const LuaSource = "swap.lua"
&nbsp;
func <strong>main</strong>() {
        luaVM := lua.NewState()
        log.Println("Lua VM has been initialized")
&nbsp;
        defer func() {
                luaVM.Close()
                log.Println("Lua VM has been closed")
        }()
&nbsp;
        err := luaVM.DoFile(LuaSource)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        err = luaVM.CallByParam(lua.P{
                Fn:      luaVM.GetGlobal("swap"),
                NRet:    2,
                Protect: true,
        }, lua.LNumber(1), lua.LNumber(2))
&nbsp;
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        ret1 := luaVM.Get(-2)
        ret2 := luaVM.Get(-1)
        luaVM.Pop(2)
        println("Type", ret1.Type())
        println("Type", ret2.Type())
        if number, ok := ret1.(lua.LNumber); ok {
                println("Value #1", float64(number))
        }
        if number, ok := ret2.(lua.LNumber); ok {
                println("Value #2", float64(number))
        }
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Volání funkcí naprogramovaných v&nbsp;Go z&nbsp;Lua skriptu</h2>

<p>V&nbsp;předchozím textu jsme se dozvěděli, jakým způsobem je možné
z&nbsp;programovacího jazyka Go zavolat libovolnou funkci naprogramovanou ve
skriptovacím jazyce Lua, jak se volané funkci předávají hodnoty a pochopitelně
i to, jak se zpracovává případná návratová hodnota (hodnoty). Ovšem pro úplnou
integraci Go+Lua je nutné zajistit i opačný způsob volání, tj.&nbsp;volání Go
funkce z&nbsp;Lua skriptu. Můžeme si nejprve vyzkoušet, co se stane, pokud se
pokusíme takovou funkci přímo zavolat bez toho, abychom ji jakýmkoli způsobem
registrovali.</p>

<p>Samotný Lua skript, který zavolá (resp.&nbsp;pokusí se zavolat) funkci
naprogramovanou v&nbsp;jazyce Go, vypadá takto:</p>

<pre>
function <strong>call_go</strong>()
    print("Hello from Lua!")
    hello()
end
</pre>

<p>Funkci vytvořenou v&nbsp;jazyku Lua se můžeme pokusit zavolat v&nbsp;této
aplikaci:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/yuin/gopher-lua"
        "log"
)
&nbsp;
const LuaSource = "go_from_lua.lua"
&nbsp;
func hello(L *lua.LState) int {
        log.Println("Hello from Go!")
        return 0
}
&nbsp;
func <strong>main</strong>() {
        luaVM := lua.NewState()
        log.Println("Lua VM has been initialized")
&nbsp;
        defer func() {
                luaVM.Close()
                log.Println("Lua VM has been closed")
        }()
&nbsp;
        err := luaVM.DoFile(LuaSource)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        err = luaVM.CallByParam(lua.P{
                Fn:      luaVM.GetGlobal("call_go"),
                NRet:    0,
                Protect: true,
        })
&nbsp;
        if err != nil {
                log.Fatal(err)
        }
}
</pre>

<p>Při pokusu o spuštění tohoto příkladu se zobrazí následující chybové
hlášení:</p>

<pre>
2019/05/27 19:59:41 Lua VM has been initialized
Hello from Lua!
2019/05/27 19:59:41 go_from_lua.lua:3: attempt to call a non-function object
stack traceback:
        go_from_lua.lua:3: in main chunk
        [G]: ?
exit status 1
</pre>

<p>Je tomu tak z&nbsp;toho prostého důvodu, že virtuální stroj skriptovacího
jazyka Lua nemá žádnou informaci o tom, jak funkci zavolat &ndash; vůbec ji ve
svém kontextu nezná.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Registrace funkce, která se má z&nbsp;Lua skriptů zavolat</h2>

<p>Aby bylo možné Go funkci zavolat ze skriptu vytvořeného v&nbsp;jazyce Lua,
je nutné takovou funkci nejprve korektně napsat. Tato funkce musí mít
hlavičku:</p>

<pre>
func <strong>foobar</strong>(L *lua.LState) int {
}
</pre>

<p>Dále je nutné tuto funkci zaregistrovat, a to pod jménem, jakým bude volána
z&nbsp;Lua skriptu:</p>

<pre>
luaVM.SetGlobal("hello", luaVM.NewFunction(Hello))
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se funkce v&nbsp;Go
může jmenovat odlišně, než je tomu v&nbsp;jazyce Lua. To je oboustranně výhodné
řešení, protože není nutné dělat kompromisy při pojmenovávání funkcí
(v&nbsp;tomto ohledu je Go striktnější) a taktéž se nemusíme obávat, že dojde
k&nbsp;přemazání nějaké jiné funkce v&nbsp;kontextu jazyka Lua z&nbsp;důvodu
použití stejného jména (vše má pod kontrolou vývojář, který si může ohlídat jak
zdrojové kódy Go, tak i skripty napsané v&nbsp;jazyku Lua).</div></p>

<p>Následně je již možné realizovat následující sekvenci volání:</p>

<ol>

<li>Funkce <strong>main</strong> naprogramovaná v&nbsp;Go volá funkci s&nbsp;Lua skriptu.</li>

<li>Z&nbsp;Lua skriptu se zavolá funkce <strong></strong> naprogramovaná
v&nbsp;jazyku Go.</li>

</ol>

<p>Vše je ukázáno v&nbsp;dalším (již předposledním) demonstračním příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/yuin/gopher-lua"
        "log"
)
&nbsp;
const LuaSource = "go_from_lua.lua"
&nbsp;
func <strong>Hello</strong>(L *lua.LState) int {
        log.Println("Hello from Go!")
        return 0
}
&nbsp;
func <strong>main</strong>() {
        luaVM := lua.NewState()
        log.Println("Lua VM has been initialized")
&nbsp;
        defer func() {
                luaVM.Close()
                log.Println("Lua VM has been closed")
        }()
&nbsp;
        err := luaVM.DoFile(LuaSource)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        luaVM.SetGlobal("hello", luaVM.NewFunction(Hello))
&nbsp;
        err = luaVM.CallByParam(lua.P{
                Fn:      luaVM.GetGlobal("call_go"),
                NRet:    0,
                Protect: true,
        })
&nbsp;
        if err != nil {
                log.Fatal(err)
        }
}
</pre>

<p>S výsledky:</p>

<pre>
2019/05/27 20:02:51 Lua VM has been initialized
Hello from Lua!
2019/05/27 20:02:51 Hello from Go!
2019/05/27 20:02:51 Lua VM has been closed
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Zpracování parametrů a návratových hodnot</h2>

<p>V&nbsp;dnešním posledním demonstračním příkladu si ukážeme, jak se ve funkci
vytvořené v&nbsp;jazyce Go zpracují parametry předané z&nbsp;Lua skriptu.
Připomeňme si, že funkce v&nbsp;Go volaná z&nbsp;Lua musí mít tuto
hlavičku:</p>

<pre>
func <strong>foobar</strong>(L *lua.LState) int {
}
</pre>

<p>Všechny parametry předané z&nbsp;Lua skriptu jsou přenášeny přes zásobník,
z&nbsp;něhož je musíme explicitně načíst, a to například následujícím
způsobem:</p>

<pre>
a := L.ToInt(1)
b := L.ToInt(2)
</pre>

<p>Výsledek se ukládá zpět na zásobník metodou <strong>Push()</strong>:</p>

<pre>
L.Push(lua.LNumber(a + b))
</pre>

<p>Následuje výpis úplného zdrojového kódu příkladu, který toto dvojí volání
realizuje:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/yuin/gopher-lua"
        "log"
)
&nbsp;
const LuaSource = "go_from_lua_add.lua"
&nbsp;
func <strong>compute</strong>(L *lua.LState) int {
        log.Println("called from Lua")
        a := L.ToInt(1)
        b := L.ToInt(2)
        log.Printf("1st parameter %d\n", a)
        log.Printf("2nd parameter %d\n", b)
        L.Push(lua.LNumber(a + b))
        return 1
}
&nbsp;
func <strong>main</strong>() {
        luaVM := lua.NewState()
        log.Println("Lua VM has been initialized")
&nbsp;
        defer func() {
                luaVM.Close()
                log.Println("Lua VM has been closed")
        }()
&nbsp;
        err := luaVM.DoFile(LuaSource)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        luaVM.SetGlobal("compute", luaVM.NewFunction(compute))
&nbsp;
        err = luaVM.CallByParam(lua.P{
                Fn:      luaVM.GetGlobal("add"),
                NRet:    1,
                Protect: true,
        }, lua.LNumber(1), lua.LNumber(2))
&nbsp;
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        ret := luaVM.Get(-1)
        luaVM.Pop(1)
        println("Type", ret.Type())
        println("Value", ret.String())
}
</pre>

<p>Po spuštění tohoto příkladu by se měly vypsat následující informace o
zavolání Lua funkce (a o jejích parametrech) i o zavolání funkce
<strong>compute</strong> naprogramované v&nbsp;jazyku Go:</p>

<pre>
2019/05/27 19:55:13 Lua VM has been initialized
1st parameter   1
2nd parameter   2
2019/05/27 19:55:13 called from Lua
2019/05/27 19:55:13 1st parameter 1
2019/05/27 19:55:13 2nd parameter 2
Type 2
Value 3
2019/05/27 19:55:13 Lua VM has been closed
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně dva megabajty), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_do_string_1.go</td><td>spuštění Lua skriptu uloženého v&nbsp;řetězci aplikace naprogramované v&nbsp;Go<td><a href="https://github.com/tisnik/go-root/blob/master/article_27/01_do_string_1.go">https://github.com/tisnik/go-root/blob/master/article_27/01_do_string_1.go</a></td></tr>
<tr><td> 2</td><td>02_do_string_2.go</td><td>vylepšení předchozího příkladu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/02_do_string_2.go">https://github.com/tisnik/go-root/blob/master/article_27/02_do_string_2.go</a></td></tr>
<tr><td> 3</td><td>02B_do_string_3.go</td><td>víceřádkový skript naprogramovaný v&nbsp;jazyce Lua</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/02B_do_string_3.go">https://github.com/tisnik/go-root/blob/master/article_27/02B_do_string_3.go</a></td></tr>
<tr><td> 4</td><td>03_do_file.go</td><td>spuštění Lua skriptu načteného z&nbsp;externího zdrojového souboru</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/03_do_file.go">https://github.com/tisnik/go-root/blob/master/article_27/03_do_file.go</a></td></tr>
<tr><td> 5</td><td>04_two_vms.go</td><td>použití dvou na sobě nezávislých virtuálních strojů jazyka Lua</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/04_two_vms.go">https://github.com/tisnik/go-root/blob/master/article_27/04_two_vms.go</a></td></tr>
<tr><td> 6</td><td>05_two_vms_in_goroutines.go</td><td>dva virtuální stroje jazyka Lua, každý spuštěný v&nbsp;samostatné gorutině</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/05_two_vms_in_goroutines.go">https://github.com/tisnik/go-root/blob/master/article_27/05_two_vms_in_goroutines.go</a></td></tr>
<tr><td> 7</td><td>06_call_lua.go</td><td>zavolání funkce jazyka Lua z&nbsp;aplikace psané v&nbsp;Go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/06_call_lua.go">https://github.com/tisnik/go-root/blob/master/article_27/06_call_lua.go</a></td></tr>

<tr><td> 8</td><td>07_call_lua_parameters.go</td><td>zavolání funkce jazyka Lua z&nbsp;aplikace psané v&nbsp;Go s&nbsp;předáním parametrů</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/07_call_lua_parameters.go">https://github.com/tisnik/go-root/blob/master/article_27/07_call_lua_parameters.go</a></td></tr>
<tr><td> 9</td><td>08_call_lua_parameters.go</td><td>zavolání funkce jazyka Lua z&nbsp;aplikace psané v&nbsp;Go s&nbsp;předáním parametrů</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/08_call_lua_parameters.go">https://github.com/tisnik/go-root/blob/master/article_27/08_call_lua_parameters.go</a></td></tr>
<tr><td>10</td><td>09_call_lua_return_value.go</td><td>zpracování návratové hodnoty funkce naprogramované v&nbsp;Lua</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/09_call_lua_return_value.go">https://github.com/tisnik/go-root/blob/master/article_27/09_call_lua_return_value.go</a></td></tr>
<tr><td>11</td><td>10_different_data_types.go</td><td>zpracování odlišných typů hodnot, zde konkrétně řetězců</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/10_different_data_types.go">https://github.com/tisnik/go-root/blob/master/article_27/10_different_data_types.go</a></td></tr>
<tr><td>12</td><td>11_conversion.go</td><td>konverze typů ve směru Lua&rarr;Go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/11_conversion.go">https://github.com/tisnik/go-root/blob/master/article_27/11_conversion.go</a></td></tr>
<tr><td>13</td><td>12_boolean.go</td><td>zpracování hodnot typu <strong>boolean</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/12_boolean.go">https://github.com/tisnik/go-root/blob/master/article_27/12_boolean.go</a></td></tr>
<tr><td>14</td><td>13_nil.go</td><td>zpracování hodnoty <strong>nil</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/13_nil.go">https://github.com/tisnik/go-root/blob/master/article_27/13_nil.go</a></td></tr>
<tr><td>15</td><td>14_two_return_values.go</td><td>funkce vracející dvě hodnoty</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/14_two_return_values.go">https://github.com/tisnik/go-root/blob/master/article_27/14_two_return_values.go</a></td></tr>
<tr><td>16</td><td>15_go_from_lua.go</td><td>nekorektní volání Go funkce z&nbsp;Lua skriptu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/15_go_from_lua.go">https://github.com/tisnik/go-root/blob/master/article_27/15_go_from_lua.go</a></td></tr>
<tr><td>17</td><td>16_go_from_lua_correct.go</td><td>korektní volání Go funkce z&nbsp;Lua skriptu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/16_go_from_lua_correct.go">https://github.com/tisnik/go-root/blob/master/article_27/16_go_from_lua_correct.go</a></td></tr>
<tr><td>18</td><td>17_go_from_lua_calc.go</td><td>volání Go funkce z&nbsp;Lua skriptu s&nbsp;předáváním parametrů a návratové hodnoty</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/17_go_from_lua_calc.go">https://github.com/tisnik/go-root/blob/master/article_27/17_go_from_lua_calc.go</a></td></tr>
</table>

<p>Skripty naprogramované v&nbsp;jazyku Lua, které jsou demonstračními příklady
používány:</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Cesta</th></tr>
<tr><td> 1</td><td>add.lua</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/add.lua">https://github.com/tisnik/go-root/blob/master/article_27/add.lua</a></td></tr>
<tr><td> 2</td><td>function.lua</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/function.lua">https://github.com/tisnik/go-root/blob/master/article_27/function.lua</a></td></tr>
<tr><td> 3</td><td>function_params.lua</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/function_params.lua">https://github.com/tisnik/go-root/blob/master/article_27/function_params.lua</a></td></tr>
<tr><td> 4</td><td>hello.lua</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/hello.lua">https://github.com/tisnik/go-root/blob/master/article_27/hello.lua</a></td></tr>
<tr><td> 5</td><td>l1.lua</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/l1.lua">https://github.com/tisnik/go-root/blob/master/article_27/l1.lua</a></td></tr>
<tr><td> 6</td><td>l2.lua</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/l2.lua">https://github.com/tisnik/go-root/blob/master/article_27/l2.lua</a></td></tr>
<tr><td> 7</td><td>v1.lua</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/v1.lua">https://github.com/tisnik/go-root/blob/master/article_27/v1.lua</a></td></tr>
<tr><td> 8</td><td>v2.lua</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/v2.lua">https://github.com/tisnik/go-root/blob/master/article_27/v2.lua</a></td></tr>
<tr><td> 9</td><td>v3.lua</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/v3.lua">https://github.com/tisnik/go-root/blob/master/article_27/v3.lua</a></td></tr>
<tr><td>10</td><td>compare.lua</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/compare.lua">https://github.com/tisnik/go-root/blob/master/article_27/compare.lua</a></td></tr>
<tr><td>11</td><td>concatenate.lua</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/concatenate.lua">https://github.com/tisnik/go-root/blob/master/article_27/concatenate.lua</a></td></tr>
<tr><td>12</td><td>go_from_lua_add.lua</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/go_from_lua_add.lua">https://github.com/tisnik/go-root/blob/master/article_27/go_from_lua_add.lua</a></td></tr>
<tr><td>13</td><td>go_from_lua.lua</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/go_from_lua.lua">https://github.com/tisnik/go-root/blob/master/article_27/go_from_lua.lua</a></td></tr>
<tr><td>14</td><td>return_nil.lua</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/return_nil.lua">https://github.com/tisnik/go-root/blob/master/article_27/return_nil.lua</a></td></tr>
<tr><td>15</td><td>swap.lua</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_27/swap.lua">https://github.com/tisnik/go-root/blob/master/article_27/swap.lua</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Delve: a debugger for the Go programming language.<br />
<a href="https://github.com/go-delve/delve">https://github.com/go-delve/delve</a>
</li>

<li>Příkazy debuggeru Delve<br />
<a href="https://github.com/go-delve/delve/tree/master/Documentation/cli">https://github.com/go-delve/delve/tree/master/Documentation/cli</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (2. část)<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v&nbsp;editorech Emacs a Vim<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Debugging Go Code with GDB<br />
<a href="https://golang.org/doc/gdb">https://golang.org/doc/gdb</a>
</li>

<li>Debugging Go (golang) programs with gdb <br />
<a href="https://thornydev.blogspot.com/2014/01/debugging-go-golang-programs-with-gdb.html">https://thornydev.blogspot.com/2014/01/debugging-go-golang-programs-with-gdb.html</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>GDB - Supported Languages<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>13 Linux Debuggers for C++ Reviewed<br />
<a href="http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817">http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817</a>
</li>

<li>Go is on a Trajectory to Become the Next Enterprise Programming Language<br />
<a href="https://hackernoon.com/go-is-on-a-trajectory-to-become-the-next-enterprise-programming-language-3b75d70544e">https://hackernoon.com/go-is-on-a-trajectory-to-become-the-next-enterprise-programming-language-3b75d70544e</a>
</li>

<li>Go Proverbs: Simple, Poetic, Pithy<br />
<a href="https://go-proverbs.github.io/">https://go-proverbs.github.io/</a>
</li>

<li>Handling Sparse Files on Linux<br />
<a href="https://www.systutorials.com/136652/handling-sparse-files-on-linux/">https://www.systutorials.com/136652/handling-sparse-files-on-linux/</a>
</li>

<li>Gzip (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Gzip">https://en.wikipedia.org/wiki/Gzip</a>
</li>

<li>Deflate<br />
<a href="https://en.wikipedia.org/wiki/DEFLATE">https://en.wikipedia.org/wiki/DEFLATE</a>
</li>

<li>10 tools written in Go that every developer needs to know<br />
<a href="https://gustavohenrique.net/en/2019/01/10-tools-written-in-go-that-every-dev-needs-to-know/">https://gustavohenrique.net/en/2019/01/10-tools-written-in-go-that-every-dev-needs-to-know/</a>
</li>

<li>Hexadecimální prohlížeče a editory s textovým uživatelským rozhraním<br />
<a href="https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/">https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/</a>
</li>

<li>Hex dump<br />
<a href="https://en.wikipedia.org/wiki/Hex_dump">https://en.wikipedia.org/wiki/Hex_dump</a>
</li>

<li>Rozhraní io.ByteReader<br />
<a href="https://golang.org/pkg/io/#ByteReader">https://golang.org/pkg/io/#ByteReader</a>
</li>

<li>Rozhraní io.RuneReader<br />
<a href="https://golang.org/pkg/io/#RuneReader">https://golang.org/pkg/io/#RuneReader</a>
</li>

<li>Rozhraní io.ByteScanner<br />
<a href="https://golang.org/pkg/io/#ByteScanner">https://golang.org/pkg/io/#ByteScanner</a>
</li>

<li>Rozhraní io.RuneScanner<br />
<a href="https://golang.org/pkg/io/#RuneScanner">https://golang.org/pkg/io/#RuneScanner</a>
</li>

<li>Rozhraní io.Closer<br />
<a href="https://golang.org/pkg/io/#Closer">https://golang.org/pkg/io/#Closer</a>
</li>

<li>Rozhraní io.Reader<br />
<a href="https://golang.org/pkg/io/#Reader">https://golang.org/pkg/io/#Reader</a>
</li>

<li>Rozhraní io.Writer<br />
<a href="https://golang.org/pkg/io/#Writer">https://golang.org/pkg/io/#Writer</a>
</li>

<li>Typ Strings.Reader<br />
<a href="https://golang.org/pkg/strings/#Reader">https://golang.org/pkg/strings/#Reader</a>
</li>

<li>VACUUM (SQL)<br />
<a href="https://www.sqlite.org/lang_vacuum.html">https://www.sqlite.org/lang_vacuum.html</a>
</li>

<li>VACUUM (Postgres)<br />
<a href="https://www.postgresql.org/docs/8.4/sql-vacuum.html">https://www.postgresql.org/docs/8.4/sql-vacuum.html</a>
</li>

<li>go-cron<br />
<a href="https://github.com/rk/go-cron">https://github.com/rk/go-cron</a>
</li>

<li>gocron<br />
<a href="https://github.com/jasonlvhit/gocron">https://github.com/jasonlvhit/gocron</a>
</li>

<li>clockwork<br />
<a href="https://github.com/whiteShtef/clockwork">https://github.com/whiteShtef/clockwork</a>
</li>

<li>clockwerk<br />
<a href="https://github.com/onatm/clockwerk">https://github.com/onatm/clockwerk</a>
</li>

<li>JobRunner<br />
<a href="https://github.com/bamzi/jobrunner">https://github.com/bamzi/jobrunner</a>
</li>

<li>Rethinking Cron<br />
<a href="https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/">https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/</a>
</li>

<li>In the Beginning was the Command Line<br />
<a href="https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html">https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html</a>
</li>

<li>repl.it (REPL pro různé jazyky)<br />
<a href="https://repl.it/languages">https://repl.it/languages</a>
</li>

<li>GOCUI - Go Console User Interface (celé uživatelské prostředí, nejenom input box)<br />
<a href="https://github.com/jroimartin/gocui">https://github.com/jroimartin/gocui</a>
</li>

<li>Read–eval–print loop<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>go-prompt<br />
<a href="https://github.com/c-bata/go-prompt">https://github.com/c-bata/go-prompt</a>
</li>

<li>readline<br />
<a href="https://github.com/chzyer/readline">https://github.com/chzyer/readline</a>
</li>

<li>A pure golang implementation for GNU-Readline kind library<br />
<a href="https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/">https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/</a>
</li>

<li>go-readline<br />
<a href="https://github.com/fiorix/go-readline">https://github.com/fiorix/go-readline</a>
</li>

<li>4 Python libraries for building great command-line user interfaces<br />
<a href="https://opensource.com/article/17/5/4-practical-python-libraries">https://opensource.com/article/17/5/4-practical-python-libraries</a>
</li>

<li>prompt_toolkit 2.0.3 na PyPi<br />
<a href="https://pypi.org/project/prompt_toolkit/">https://pypi.org/project/prompt_toolkit/</a>
</li>

<li>python-prompt-toolkit na GitHubu<br />
<a href="https://github.com/jonathanslenders/python-prompt-toolkit">https://github.com/jonathanslenders/python-prompt-toolkit</a>
</li>

<li>The GNU Readline Library<br />
<a href="https://tiswww.case.edu/php/chet/readline/rltop.html">https://tiswww.case.edu/php/chet/readline/rltop.html</a>
</li>

<li>GNU Readline (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Readline">https://en.wikipedia.org/wiki/GNU_Readline</a>
</li>

<li>readline — GNU readline interface (Python 3.x)<br />
<a href="https://docs.python.org/3/library/readline.html">https://docs.python.org/3/library/readline.html</a>
</li>

<li>readline — GNU readline interface (Python 2.x)<br />
<a href="https://docs.python.org/2/library/readline.html">https://docs.python.org/2/library/readline.html</a>
</li>

<li>GNU Readline Library - command line editing<br />
<a href="https://tiswww.cwru.edu/php/chet/readline/readline.html">https://tiswww.cwru.edu/php/chet/readline/readline.html</a>
</li>

<li>gnureadline 6.3.8 na PyPi<br />
<a href="https://pypi.org/project/gnureadline/">https://pypi.org/project/gnureadline/</a>
</li>

<li>Editline Library (libedit)<br />
<a href="http://thrysoee.dk/editline/">http://thrysoee.dk/editline/</a>
</li>

<li>Comparing Python Command-Line Parsing Libraries – Argparse, Docopt, and Click<br />
<a href="https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/">https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/</a>
</li>

<li>libedit or editline<br />
<a href="http://www.cs.utah.edu/~bigler/code/libedit.html">http://www.cs.utah.edu/~bigler/code/libedit.html</a>
</li>

<li>WinEditLine<br />
<a href="http://mingweditline.sourceforge.net/">http://mingweditline.sourceforge.net/</a>
</li>

<li>rlcompleter — Completion function for GNU readline<br />
<a href="https://docs.python.org/3/library/rlcompleter.html">https://docs.python.org/3/library/rlcompleter.html</a>
</li>

<li>rlwrap na GitHubu<br />
<a href="https://github.com/hanslub42/rlwrap">https://github.com/hanslub42/rlwrap</a>
</li>

<li>rlwrap(1) - Linux man page<br />
<a href="https://linux.die.net/man/1/rlwrap">https://linux.die.net/man/1/rlwrap</a>
</li>

<li>readline(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/readline">https://linux.die.net/man/3/readline</a>
</li>

<li>history(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/history">https://linux.die.net/man/3/history</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>oglematchers</i><br />
<a href="https://godoc.org/github.com/jacobsa/oglematchers">https://godoc.org/github.com/jacobsa/oglematchers</a>
</li>

<li>Balíček <i>oglematchers</i><br />
<a href="https://github.com/jacobsa/oglematchers">https://github.com/jacobsa/oglematchers</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>ogletest</i><br />
<a href="https://godoc.org/github.com/jacobsa/ogletest">https://godoc.org/github.com/jacobsa/ogletest</a>
</li>

<li>Balíček <i>ogletest</i><br />
<a href="https://github.com/jacobsa/ogletest">https://github.com/jacobsa/ogletest</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>assert</i><br />
<a href="https://godoc.org/github.com/stretchr/testify/assert">https://godoc.org/github.com/stretchr/testify/assert</a>
</li>

<li>Testify - Thou Shalt Write Tests<br />
<a href="https://github.com/stretchr/testify/">https://github.com/stretchr/testify/</a>
</li>

<li>package testing<br />
<a href="https://golang.org/pkg/testing/">https://golang.org/pkg/testing/</a>
</li>

<li>Golang basics - writing unit tests<br />
<a href="https://blog.alexellis.io/golang-writing-unit-tests/">https://blog.alexellis.io/golang-writing-unit-tests/</a>
</li>

<li>An Introduction to Programming in Go / Testing<br />
<a href="https://www.golang-book.com/books/intro/12">https://www.golang-book.com/books/intro/12</a>
</li>

<li>An Introduction to Testing in Go<br />
<a href="https://tutorialedge.net/golang/intro-testing-in-go/">https://tutorialedge.net/golang/intro-testing-in-go/</a>
</li>

<li>Advanced Go Testing Tutorial<br />
<a href="https://tutorialedge.net/golang/advanced-go-testing-tutorial/">https://tutorialedge.net/golang/advanced-go-testing-tutorial/</a>
</li>

<li>GoConvey<br />
<a href="http://goconvey.co/">http://goconvey.co/</a>
</li>

<li>Testing Techniques<br />
<a href="https://talks.golang.org/2014/testing.slide">https://talks.golang.org/2014/testing.slide</a>
</li>

<li>5 simple tips and tricks for writing unit tests in #golang<br />
<a href="https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742">https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742</a>
</li>

<li>Afinní transformace<br />
<a href="https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic">https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic</a>
</li>

<li>package gg<br />
<a href="https://godoc.org/github.com/fogleman/gg">https://godoc.org/github.com/fogleman/gg</a>
</li>

<li>Generate an animated GIF with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/">http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/</a>
</li>

<li>Generate an image programmatically with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/">http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/</a>
</li>

<li>The Go image package<br />
<a href="https://blog.golang.org/go-image-package">https://blog.golang.org/go-image-package</a>
</li>

<li>Balíček draw2D: 2D rendering for different output (raster, pdf, svg)<br />
<a href="https://github.com/llgcode/draw2d">https://github.com/llgcode/draw2d</a>
</li>

<li>Draw a rectangle in Golang?<br />
<a href="https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang">https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang</a>
</li>

<li>YAML<br />
<a href="https://yaml.org/">https://yaml.org/</a>
</li>

<li>edn<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Smile<br />
<a href="https://github.com/FasterXML/smile-format-specification">https://github.com/FasterXML/smile-format-specification</a>
</li>

<li>Protocol-Buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>Marshalling (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
</li>

<li>Unmarshalling<br />
<a href="https://en.wikipedia.org/wiki/Unmarshalling">https://en.wikipedia.org/wiki/Unmarshalling</a>
</li>

<li>Introducing JSON<br />
<a href="http://json.org/">http://json.org/</a>
</li>

<li>Package json<br />
<a href="https://golang.org/pkg/encoding/json/">https://golang.org/pkg/encoding/json/</a>
</li>

<li>The Go Blog: JSON and Go<br />
<a href="https://blog.golang.org/json-and-go">https://blog.golang.org/json-and-go</a>
</li>

<li>Go by Example: JSON<br />
<a href="https://gobyexample.com/json">https://gobyexample.com/json</a>
</li>

<li>Writing Web Applications<br />
<a href="https://golang.org/doc/articles/wiki/">https://golang.org/doc/articles/wiki/</a>
</li>

<li>Golang Web Apps<br />
<a href="https://www.reinbach.com/blog/golang-webapps-1/">https://www.reinbach.com/blog/golang-webapps-1/</a>
</li>

<li>Build web application with Golang<br />
<a href="https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details">https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details</a>
</li>

<li>Golang Templates - Golang Web Pages<br />
<a href="https://www.youtube.com/watch?v=TkNIETmF-RU">https://www.youtube.com/watch?v=TkNIETmF-RU</a>
</li>

<li>Simple Golang HTTPS/TLS Examples<br />
<a href="https://github.com/denji/golang-tls">https://github.com/denji/golang-tls</a>
</li>

<li>Playing with images in HTTP response in golang<br />
<a href="https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang">https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang</a>
</li>

<li>MIME Types List<br />
<a href="https://www.freeformatter.com/mime-types-list.html">https://www.freeformatter.com/mime-types-list.html</a>
</li>

<li>Go Mutex Tutorial<br />
<a href="https://tutorialedge.net/golang/go-mutex-tutorial/">https://tutorialedge.net/golang/go-mutex-tutorial/</a>
</li>

<li>Creating A Simple Web Server With Golang<br />
<a href="https://tutorialedge.net/golang/creating-simple-web-server-with-golang/">https://tutorialedge.net/golang/creating-simple-web-server-with-golang/</a>
</li>

<li>Building a Web Server in Go<br />
<a href="https://thenewstack.io/building-a-web-server-in-go/">https://thenewstack.io/building-a-web-server-in-go/</a>
</li>

<li>How big is the pipe buffer?<br />
<a href="https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer">https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer</a>
</li>

<li>How to turn off buffering of stdout in C<br />
<a href="https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c">https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c</a>
</li>

<li>setbuf(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/setbuf">https://linux.die.net/man/3/setbuf</a>
</li>

<li>setvbuf(3) - Linux man page (stejný obsah jako předchozí stránka)<br />
<a href="https://linux.die.net/man/3/setvbuf">https://linux.die.net/man/3/setvbuf</a>
</li>

<li>Select waits on a group of channels<br />
<a href="https://yourbasic.org/golang/select-explained/">https://yourbasic.org/golang/select-explained/</a>
</li>

<li>Rob Pike: Simplicity is Complicated (video)<br />
<a href="http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893">http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893</a>
</li>

<li>Algorithms to Go<br />
<a href="https://yourbasic.org/">https://yourbasic.org/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů: vlastní filtry a lexery<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/</a>
</li>

<li>Go Defer Simplified with Practical Visuals<br />
<a href="https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff">https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff</a>
</li>

<li>5 More Gotchas of Defer in Go — Part II<br />
<a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa">https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa</a>
</li>

<li>The Go Blog: Defer, Panic, and Recover<br />
<a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a>
</li>

<li>The defer keyword in Swift 2: try/finally done right<br />
<a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer">https://www.hackingwithswift.com/new-syntax-swift-2-defer</a>
</li>

<li>Swift Defer Statement<br />
<a href="https://andybargh.com/swift-defer-statement/">https://andybargh.com/swift-defer-statement/</a>
</li>

<li>Modulo operation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Modulo_operation">https://en.wikipedia.org/wiki/Modulo_operation</a>
</li>

<li>Node.js vs Golang: Battle of the Next-Gen Languages<br />
<a href="https://www.hostingadvice.com/blog/nodejs-vs-golang/">https://www.hostingadvice.com/blog/nodejs-vs-golang/</a>
</li>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go<br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>JavaScript vs. Golang for IoT: Is Gopher Winning?<br />
<a href="https://www.iotforall.com/javascript-vs-golang-iot/">https://www.iotforall.com/javascript-vs-golang-iot/</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

<li>Printf Format Strings<br />
<a href="https://www.cprogramming.com/tutorial/printf-format-strings.html">https://www.cprogramming.com/tutorial/printf-format-strings.html</a>
</li>

<li>Java: String.format<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-</a>
</li>

<li>Java: format string syntax<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a>
</li>

<li>Selectors<br />
<a href="https://golang.org/ref/spec#Selectors">https://golang.org/ref/spec#Selectors</a>
</li>

<li>Calling Go code from Python code<br />
<a href="http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/">http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/</a>
</li>

<li>Go Data Structures: Interfaces <br />
<a href="https://research.swtch.com/interfaces">https://research.swtch.com/interfaces</a>
</li>

<li>How to use interfaces in Go<br />
<a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go</a>
</li>

<li>Interfaces in Go (part I)<br />
<a href="https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c">https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c</a>
</li>

<li>Part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>What about Trait support in Golang?<br />
<a href="https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/">https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/</a>
</li>

<li>Don't Get Bitten by Pointer vs Non-Pointer Method Receivers in Golang<br />
<a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/">https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/</a>
</li>

<li>Control Flow<br />
<a href="https://en.wikipedia.org/wiki/Control_flow">https://en.wikipedia.org/wiki/Control_flow</a>
</li>

<li>Structured programming<br />
<a href="https://en.wikipedia.org/wiki/Structured_programming">https://en.wikipedia.org/wiki/Structured_programming</a>
</li>

<li>Control Structures<br />
<a href="https://www.golang-book.com/books/intro/5">https://www.golang-book.com/books/intro/5</a>
</li>

<li>Control structures - Go if else statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html">http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html</a>
</li>

<li>Control structures - Go switch case statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html</a>
</li>

<li>Control structures - Go for loop, break, continue, range<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html</a>
</li>

<li>Different ways to pass channels as arguments in function in go (golang)<br />
<a href="https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang">https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang</a>
</li>

<li>justforfunc #22: using the Go execution tracer<br />
<a href="https://www.youtube.com/watch?v=ySy3sR1LFCQ">https://www.youtube.com/watch?v=ySy3sR1LFCQ</a>
</li>

<li>Single Function Exit Point<br />
<a href="http://wiki.c2.com/?SingleFunctionExitPoint">http://wiki.c2.com/?SingleFunctionExitPoint</a>
</li>

<li>Entry point<br />
<a href="https://en.wikipedia.org/wiki/Entry_point">https://en.wikipedia.org/wiki/Entry_point</a>
</li>

<li>Why does Go have a GOTO statement?!<br />
<a href="https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/">https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/</a>
</li>

<li>Effective Go<br />
<a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a>
</li>

<li>GoClipse: an Eclipse IDE for the Go programming language<br />
<a href="http://goclipse.github.io/">http://goclipse.github.io/</a>
</li>

<li>GoClipse Installation<br />
<a href="https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation">https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation</a>
</li>

<li>The zero value of a slice is not nil<br />
<a href="https://stackoverflow.com/questions/30806931/the-zero-value-of-a-slice-is-not-nil">https://stackoverflow.com/questions/30806931/the-zero-value-of-a-slice-is-not-nil</a>
</li>

<li>Go-tcha: When nil != nil<br />
<a href="https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic">https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic</a>
</li>

<li>Nils in Go<br />
<a href="https://www.doxsey.net/blog/nils-in-go">https://www.doxsey.net/blog/nils-in-go</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

