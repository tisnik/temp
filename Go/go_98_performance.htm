<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Základní optimalizace v Go aneb pomáháme překladači</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Základní optimalizace v Go aneb pomáháme překladači</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku o programovacím jazyku Go se seznámíme se základními optimalizacemi, které je v některých případech vhodné či nutné provádět na úrovni zdrojového kódu. Některé dále zmíněné optimalizace jsou (zdánlivě) triviální, na druhou stranu ovšem opomíjené. A další optimalizace jsou naopak neintuitivní.</p>




<h2>Obsah</h2>

<p><a href="#k01">1. Základní optimalizace v&nbsp;Go aneb pomáháme překladači</a></p>
<p><a href="#k02">2. Prázdné mapy vs. mapy s&nbsp;předběžnou alokací prvků</a></p>
<p><a href="#k03">3. Benchmark: naplnění prázdné mapy a předalokované mapy</a></p>
<p><a href="#k04">4. Odlišné použití map: mapy s&nbsp;prvky typu <strong>int</strong></a></p>
<p><a href="#k05">5. Mapy, jejichž klíče mají velikost 100 bajtů</a></p>
<p><a href="#k06">*** 6. Výsledky benchmarků, výsledky činnosti profileru</a></p>
<p><a href="#k07">7. Mapa použitá ve funkci množiny</a></p>
<p><a href="#k08">*** 8. Výsledky benchmarků a profileru</a></p>
<p><a href="#k09">*** 9. Předávání datových struktur do funkcí a metod hodnotou či odkazem?</a></p>
<p><a href="#k10">10. Syntaxe pro předávání struktur do funkcí a metod hodnotou a odkazem</a></p>
<p><a href="#k11">*** 11. Benchmark zjišťující rozdíly v&nbsp;rychlosti volání funkcí a metod s&nbsp;využitím hodnoty a reference na předávanou strukturu</a></p>
<p><a href="#k12">*** 12. Výsledky benchmarku i profileru</a></p>
<p><a href="#k13">*** 13. Mapy vs. řezy při implementaci jednoduché paměťové cache</a></p>
<p><a href="#k14">*** 14. Výsledky benchmarků</a></p>
<p><a href="#k15">*** 15. Grafické porovnání výsledků</a></p>
<p><a href="#k16">*** 16. Mapy vs. řezy při implementaci množiny</a></p>
<p><a href="#k17">*** 17. Výsledky benchmarku</a></p>
<p><a href="#k18">*** 18. Závěrečné zhodnocení &ndash; triviální a přitom mnohdy důležité optimalizace</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Základní optimalizace v&nbsp;Go aneb pomáháme překladači</h2>

<p><a
href="https://www.root.cz/clanky/go-minimalisticky-a-prekvapive-vykonny-programovaci-jazyk/">Programovací
jazyk Go</a> je v&nbsp;současnosti mezi vývojáři <a
href="https://www.tiobe.com/tiobe-index/">poměrně oblíben</a>, a to mj.&nbsp;i
díky jeho velmi rychlému překladači a linkeru, který dokáže v&nbsp;několika
sekundách přeložit i velmi rozsáhlé aplikace. Rychlost překladače je do určité
míry umožněna syntaxí samotného programovacího jazyka Go, ovšem na druhou
stranu je nutné si přiznat, že se překladač příliš nezdržuje optimalizacemi,
což je mnohdy patrné z&nbsp;vygenerovaného strojového kódu i výsledného výkonu
aplikací (pokud porovnáváme s&nbsp;C, Rustem atd., nikoli například
s&nbsp;Pythonem :-). V&nbsp;dnešním článku se seznámíme se základními
optimalizacemi, které je v některých případech nutné provádět na úrovni
zdrojového kódu. Některé dále zmíněné optimalizace jsou (alespoň zdánlivě)
triviální, na druhou stranu ovšem opomíjené. A další optimalizace jsou naopak
neintuitivní a vlastně jdou i proti &bdquo;zdravému rozumu&ldquo;. Podrobnosti
si řekneme v&nbsp;navazujících kapitolách.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Prázdné mapy vs. mapy s&nbsp;předběžnou alokací prvků</h2>

<p>Mapy jsou jedním z&nbsp;nejčastěji používaných kontejnerů, a to i
v&nbsp;programovacím jazyku Go. Připomeňme si, že v&nbsp;Go je možné použít
jako klíč prakticky jakýkoli datový typ, což užitečnost map ještě zvyšuje.</p>

<p>Existuje poměrně velké množství způsobů implementace map, přesněji řečeno
způsobů ukládání dvojic klíč-hodnota do paměti s&nbsp;možností jejich
pozdějšího přečtení. Jednotlivé implementace se od sebe odlišují svými
základními vlastnostmi, například tím, zda jsou prvky v&nbsp;mapě setříděny na
základě svého klíče, zda je naopak zachováno pořadí prvků podle pořadí jejich
vkládání do mapy či zda jsou prvky obecně neuspořádány. Liší se i časové
složitosti základních operací &ndash; tedy operace pro vložení prvku do mapy a
operace pro získání prvku na základě jeho klíče. Navíc v&nbsp;některých
případech vyžadujeme specifické chování mapy, například možnost mapování
nejenom v&nbsp;jednom směru (tedy klasické klíč&rarr;hodnota), ale i ve směru
opačném (hodnota&rarr;klíč). Toto chování realizují mapy, v&nbsp;jejichž jméně
se objevuje zkratka &bdquo;bidi&ldquo; (neboli <i>bi-directional</i>).</p>

<p>V&nbsp;rámci tohoto článku se zaměříme na základní implementaci map, která
je nedílnou součástí samotného programovacího jazyka Go.</p>

<p><div class="rs-tip-major">Poznámka: tak jako v&nbsp;jiných jazycích platí,
že klíče použité v&nbsp;jedné mapě musí být unikátní; hodnoty však mohou být
naprosto libovolné.</div></p>

<p>Ukažme si nyní způsob deklarace proměnné pojmenované <strong>m1</strong>,
která je typu mapa celé číslo:řetězec:</p>

<pre>
var m1 map[int]string
</pre>

<p>Samozřejmě můžeme vytvořit i jinou mapu, konkrétně mapu s&nbsp;klíči typu
<strong>string</strong> a hodnotami typu <strong>User</strong></p>

<pre>
var m2 map[string]User
</pre>

<p><a
href="https://github.com/tisnik/go-fedora/blob/master/article_03/15_uninitialized_map.go">V&nbsp;dalším
příkladu</a> vytvoříme proměnnou typu mapa a posléze se do ní pokusíme zapsat
novou dvojici s&nbsp;klíčem rovným nule a hodnotou &bdquo;nula&ldquo;:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var m1 map[int]string
        fmt.Println(m1)
&nbsp;
        m1[0] = "nula"
}
</pre>

<p>Při pokusu o spuštění tohoto příkladu ovšem dojde k&nbsp;běhové chybě, která
vypadá takto:</p>

<pre>
map[]
<strong>panic: assignment to entry in nil map</strong>
&nbsp;
goroutine 1 [running]:
main.main()
        /home/tester/go-root/article_03/15_uninitialized_map.go:16 +0x76
exit status 2
</pre>

<p>Co to znamená? Předchozí proměnná byla sice deklarována korektně, ovšem
uplatnila se zde již dříve popsaná pravidla pro inicializaci hodnoty proměnné.
Zde se konkrétně vytvořila mapa a byla jí přiřazena speciální hodnota
<strong>nil</strong> &ndash; proto se nazývá <strong>nil-mapou</strong>. Pokud
budeme skutečně chtít mapu použít (naplnit ji dvojicemi klíč-hodnota), musíme
při inicializaci zavolat <a
href="https://golang.org/pkg/builtin/#make">vestavěnou funkci make</a>.</p>

<p>Korektní inicializace mapy je ukázána na <a
href="https://github.com/tisnik/go-fedora/blob/master/article_03/16_initialized_map.go">dalším
příkladu</a>:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var m1 map[int]string = make(map[int]string)
        fmt.Println(m1)
&nbsp;
        m1[0] = "nula"
        m1[1] = "jedna"
        m1[2] = "dva"
        m1[3] = "tri"
        m1[4] = "ctyri"
        m1[5] = "pet"
        m1[6] = "sest"
&nbsp;
        fmt.Println(m1)
}
</pre>

<p>Po spuštění tohoto příkladu se nejdříve vypíše prázdná mapa a posléze mapa
naplněná šesti dvojicemi:</p>

<pre>
map[]
map[6:sest 0:nula 1:jedna 2:dva 3:tri 4:ctyri 5:pet]
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že dvojice jsou vypsány
v&nbsp;jiném pořadí, než jak byly vkládány do mapy. To je výchozí a očekávané
chování této datové struktury.</div></p>

<p>Z&nbsp;hlediska výkonu aplikace je důležitý taktéž fakt, že do vestavěné
funkce <strong>make</strong> je možné ve druhém parametru předat očekávanou
kapacitu mapy. To povede k&nbsp;prealokaci paměti pro prvky, ovšem současně se
<i>ne</i>jedná o maximální kapacitu (mapa může mít více prvků, než je její
prvotní kapacita):</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var m1 map[int]string = make(map[int]string, 6)
        fmt.Println(m1)
&nbsp;
        m1[0] = "nula"
        m1[1] = "jedna"
        m1[2] = "dva"
        m1[3] = "tri"
        m1[4] = "ctyri"
        m1[5] = "pet"
        m1[6] = "sest"
&nbsp;
        fmt.Println(m1)
}
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Benchmark: naplnění prázdné mapy a předalokované mapy</h2>

<p>Na tomto místě je dobré se na chvíli zastavit a zjistit, zda má vůbec smysl
se snažit o předalokaci mapy, tj.&nbsp;o zjištění či odhad počtu prvků, které
budou do mapy vloženy. Pro tento účel vznikl jednoduchý benchmark, který je
vypsán pod tímto odstavcem. V&nbsp;benchmarku se do mapy s&nbsp;klíči typu <a
href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>
ukládají časová razítka &ndash; pro každé UUID jedno razítko. První benchmark
využívá předalokovanou mapu, druhý prázdnou mapu (která však není
nil-mapou):</p>

<pre>
package main
&nbsp;
import (
        "testing"
        "time"

        "github.com/google/uuid"
)
&nbsp;
type UUID string
&nbsp;
func <strong>BenchmarkInsertIntoPreallocatedMapUUIDKey</strong>(b *testing.B) {
        m := make(map[UUID]time.Time, b.N)
        t := time.Now()
&nbsp;
        for i := 0; i &lt; b.N; i++ {
                b.StopTimer()
                id := UUID(uuid.New().String())
                b.StartTimer()
                <u>m[id] = t</u>
        }
}
&nbsp;
func <strong>BenchmarkInsertIntoEmptyMapUUIDKey</strong>(b *testing.B) {
        m := map[UUID]time.Time{}
        t := time.Now()
&nbsp;
        for i := 0; i &lt; b.N; i++ {
                b.StopTimer()
                id := UUID(uuid.New().String())
                b.StartTimer()
                <u>m[id] = t</u>
        }
}
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto benchmarku naleznete
na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_98/maps/map1_test.go">https://github.com/tisnik/go-root/blob/master/article_98/maps/map1_test.go</a>.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Odlišné použití map: mapy s&nbsp;prvky typu <strong>int</strong></h2>

<p>Chování map do značné míry závisí na typu klíčů i typu hodnot. Proto si
v&nbsp;této kapitole ukažme podobný benchmark, jaký byl uveden <a
href="#k03">v&nbsp;předchozí kapitole</a>, nyní ovšem upravený do podoby, kdy
klíče jsou typu <strong>int</strong> a hodnoty jsou taktéž typu
<strong>int</strong>. Výsledná mapa tedy bude i přes velký počet uložených
hodnot, obecně menší, než mapa z&nbsp;předchozího textu. Úprava benchmarku
vypadá následovně:</p>

<pre>
package main
&nbsp;
import (
        "testing"
)
&nbsp;
func <strong>BenchmarkInsertIntoPreallocatedMapIntKeyIntValue</strong>(b *testing.B) {
        m := make(map[int]int, b.N)
&nbsp;
        for i := 0; i &lt; b.N; i++ {
                m[i] = i
        }
}
&nbsp;
func <strong>BenchmarkInsertIntoEmptyMapIntKeyIntValue</strong>(b *testing.B) {
        m := map[int]int{}
&nbsp;
        for i := 0; i &lt; b.N; i++ {
                m[i] = i
        }
}
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto benchmarku naleznete
na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_98/maps/map2_test.go">https://github.com/tisnik/go-root/blob/master/article_98/maps/map2_test.go</a>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Mapy, jejichž klíče mají velikost 100 bajtů</h2>

<p>V&nbsp;pořadí již třetí benchmark je zaměřen na test vkládání prvků do mapy,
jejichž prvky jsou poměrně velké &ndash; mají totiž velikost nepatrně
přesahující 100 bajtů. Pro tento účel je klíč definován v&nbsp;datové struktuře
nazvané jednoduše <strong>key</strong>:</p>

<pre>
package main
&nbsp;
import (
        "testing"
)
&nbsp;
type key struct {
        ID      int
        payload [100]byte
}
&nbsp;
type value struct{}
&nbsp;
func <strong>BenchmarkInsertIntoPreallocatedMapCompoundKey</strong>(b *testing.B) {
        m := make(map[key]value, b.N)
&nbsp;
        for i := 0; i &lt; b.N; i++ {
                k := key{
                        ID: i,
                }
                m[k] = value{}
        }
}
&nbsp;
func <strong>BenchmarkInsertIntoEmptyMapCompoundKey</strong>(b *testing.B) {
        m := map[key]value{}
&nbsp;
        for i := 0; i &lt; b.N; i++ {
                k := key{
                        ID: i,
                }
                m[k] = value{}
        }
}
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto benchmarku naleznete
na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_98/maps/map4_test.go">https://github.com/tisnik/go-root/blob/master/article_98/maps/map4_test.go</a>.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Výsledky benchmarků, výsledky činnosti profileru</h2>

<p>Podívejme se nyní na výsledky všech tří benchmarků popsaných
v&nbsp;předchozí trojici kapitol. Benchmarky jsou spouštěny s&nbsp;využitím
standardních nástrojů programovacího jazyka Go:</p>

<pre>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Mapa použitá ve funkci množiny</h2>

<p>Programovací jazyk Go neobsahuje podporu pro práci s&nbsp;množinami.
Z&nbsp;tohoto důvodu je nutné při požadavku existence této datové struktury
použít odlišné techniky. Poměrně často se pro tyto účely používají mapy,
jejichž hodnoty jsou prázdnými strukturami. Vzhledem k&nbsp;tomu, že prázdné
struktury mají nulovou velikost, je jejich použití z&nbsp;hlediska obsazení
paměti efektivnější, než použití (například) pravdivostních hodnot. Opět platí,
že pokud bude takto zkonstruovaná množina obsahovat velký počet prvků, je
výhodnější ji předalokovat v&nbsp;těch případech, kdy je počet prvků dopředu
známý či alespoň dobře odhadnutelný. Rozdíl mezi postupným naplňováním původně
prázdné množiny resp.&nbsp;množiny s&nbsp;předalokovanými prvky můžeme zjistit
z&nbsp;následujícího jednoduchého benchmarku:</p>

<pre>
package main
&nbsp;
import (
        "testing"
)
&nbsp;
<u>type emptyValue struct{}</u>
&nbsp;
func <strong>BenchmarkInsertIntoPreallocatedMapIntKeyEmptyValue</strong>(b *testing.B) {
        m := make(map[int]emptyValue, b.N)
&nbsp;
        for i := 0; i &lt; b.N; i++ {
                m[i] = <u>emptyValue{}</u>
        }
}
&nbsp;
func <strong>BenchmarkInsertIntoEmptyMapEmptyValue</strong>(b *testing.B) {
        m := map[int]emptyValue{}
&nbsp;
        for i := 0; i &lt; b.N; i++ {
                m[i] = <u>emptyValue{}</u>
        }
}
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto benchmarku naleznete
na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_98/maps/map3_test.go">https://github.com/tisnik/go-root/blob/master/article_98/maps/map3_test.go</a>.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Výsledky benchmarků a profileru</h2>

<pre>
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Předávání datových struktur do funkcí a metod hodnotou či odkazem?</h2>

<p></p>

<pre>
[logging]
debug = true
log_level = "info"
&nbsp;
[kafka_broker]
enabled = true
address = "kafka:29092" #provide in deployment env or as secret
security_protocol = "PLAINTEXT"
cert_path = "not-set"
sasl_mechanism = "PLAIN"
sasl_username = "not-used"
sasl_password = "not-used"
topic = "platform.notifications.ingress" #provide in deployment env or as secret
timeout = "60s"
likelihood_threshold = 0
impact_threshold = 0
severity_threshold = 0
total_risk_threshold = 3
event_filter = "totalRisk &gt;= totalRiskThreshold"
&nbsp;
[service_log]
client_id = "a-service-id"
client_secret = "a-secret"
token_url = ""
enabled = false
url = "https://api.foo.bar.com/api/v1/logs/"
timeout = "15s"
likelihood_threshold = 0
impact_threshold = 0
severity_threshold = 0
total_risk_threshold = 0
event_filter = "totalRisk &gt;= totalRiskThreshold"
rule_details_uri = "https://ui.foo.bar.com/page/{module}|{error_key}"
&nbsp;
[storage]
db_driver = "postgres"
pg_username = "postgres" #provide in deployment env or as secret
pg_password = "postgres" #provide in deployment env or as secret
pg_host = "localhost" #provide in deployment env or as secret
pg_port = 5432 #provide in deployment env or as secret
pg_db_name = "notification" #provide in deployment env or as secret
pg_params = "sslmode=disable"
log_sql_queries = true
&nbsp;
[dependencies]
content_server = "localhost:8082" #provide in deployment env or as secret
content_endpoint = "/api/v1/content" #provide in deployment env or as secret
template_renderer_server = "localhost:8083" #provide in deployment env or as secret
template_renderer_endpoint = "/v1/rendered_reports" #provide in deployment env or as secret
&nbsp;
[notifications]
insights_advisor_url = "https://console.foo.bar.com/info/{object_id}"
cluster_details_uri = "https://console.foo.bar.com/details/{object_id}#insights"
rule_details_uri = "https://console.foo.bar.com/details/{object_id}/modules/{module}/{error_key}"
<i># valid units are SQL epoch time units: months days hours minutes seconds"</i>
cooldown = "24 hours"
&nbsp;
[metrics]
job_name = "notification_service"
<i># The metrics in Prometheus will be $namespace_$subsystem_$name</i>
namespace = "notification_service"
subsystem = "notification_backend"
gateway_url = "localhost:9091"
gateway_auth_token = ""
retries = 3
<i># Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".</i>
retry_after = "60s"
&nbsp;
[cleaner]
<i># valid units are SQL epoch time units: months days hours minutes seconds"</i>
max_age = "90 days"
&nbsp;
[processing]
filter_allowed_clusters = false
allowed_clusters = []
filter_blocked_clusters = false
blocked_clusters = []
</pre>

<pre>
package conf

import (
        "bytes"
        "fmt"
        "net/url"
        "os"
        "path"
        "path/filepath"
        "strings"
        "time"

        "github.com/BurntSushi/toml"

        "github.com/rs/zerolog/log"
        "github.com/spf13/viper"
)

// Common constants used for logging and error reporting
const (
        filenameAttribute               = "filename"
        parsingConfigurationFileMessage = "parsing configuration file"
        noKafkaConfig                   = "no Kafka configuration available in Clowder, using default one"
        noBrokerConfig                  = "warning: no broker configurations found in clowder config"
        noSaslConfig                    = "warning: SASL configuration is missing"
        noTopicMapping                  = "warning: no kafka mapping found for topic %s"
        noStorage                       = "warning: no storage section in Clowder config"
)

// ConfigStruct is a structure holding the whole notification service
// configuration
type ConfigStruct struct {
        Logging       LoggingConfiguration       `mapstructure:"logging" toml:"logging"`
        Storage       StorageConfiguration       `mapstructure:"storage" toml:"storage"`
        Kafka         KafkaConfiguration         `mapstructure:"kafka_broker" toml:"kafka_broker"`
        ServiceLog    ServiceLogConfiguration    `mapstructure:"service_log" toml:"service_log"`
        Dependencies  DependenciesConfiguration  `mapstructure:"dependencies" toml:"dependencies"`
        Notifications NotificationsConfiguration `mapstructure:"notifications" toml:"notifications"`
        Metrics       MetricsConfiguration       `mapstructure:"metrics" toml:"metrics"`
        Cleaner       CleanerConfiguration       `mapstructure:"cleaner" toml:"cleaner"`
        Processing    ProcessingConfiguration    `mapstructure:"processing" toml:"processing"`
}

// LoggingConfiguration represents configuration for logging in general
type LoggingConfiguration struct {
        // Debug enables pretty colored logging
        Debug bool `mapstructure:"debug" toml:"debug"`

        // LogLevel sets logging level to show. Possible values are:
        // "debug"
        // "info"
        // "warn", "warning"
        // "error"
        // "fatal"
        //
        // logging level won't be changed if value is not one of listed above
        LogLevel string `mapstructure:"log_level" toml:"log_level"`
}

// StorageConfiguration represents configuration of postgresQSL data storage
type StorageConfiguration struct {
        Driver        string `mapstructure:"db_driver"       toml:"db_driver"`
        PGUsername    string `mapstructure:"pg_username"     toml:"pg_username"`
        PGPassword    string `mapstructure:"pg_password"     toml:"pg_password"`
        PGHost        string `mapstructure:"pg_host"         toml:"pg_host"`
        PGPort        int    `mapstructure:"pg_port"         toml:"pg_port"`
        PGDBName      string `mapstructure:"pg_db_name"      toml:"pg_db_name"`
        PGParams      string `mapstructure:"pg_params"       toml:"pg_params"`
        LogSQLQueries bool   `mapstructure:"log_sql_queries" toml:"log_sql_queries"`
}

// DependenciesConfiguration represents configuration of external services and other dependencies
type DependenciesConfiguration struct {
        ContentServiceServer     string `mapstructure:"content_server" toml:"content_server"`
        ContentServiceEndpoint   string `mapstructure:"content_endpoint" toml:"content_endpoint"`
        TemplateRendererServer   string `mapstructure:"template_renderer_server" toml:"template_renderer_server"`
        TemplateRendererEndpoint string `mapstructure:"template_renderer_endpoint" toml:"template_renderer_endpoint"`
        TemplateRendererURL      string
}

// CleanerConfiguration represents configuration for the main cleaner
type CleanerConfiguration struct {
        // MaxAge is specification of max age for records to be cleaned
        MaxAge string `mapstructure:"max_age" toml:"max_age"`
}

// KafkaConfiguration represents configuration of Kafka brokers and topics
type KafkaConfiguration struct {
        Enabled             bool          `mapstructure:"enabled" toml:"enabled"`
        Address             string        `mapstructure:"address" toml:"address"`
        SecurityProtocol    string        `mapstructure:"security_protocol" toml:"security_protocol"`
        CertPath            string        `mapstructure:"cert_path" toml:"cert_path"`
        SaslMechanism       string        `mapstructure:"sasl_mechanism" toml:"sasl_mechanism"`
        SaslUsername        string        `mapstructure:"sasl_username" toml:"sasl_username"`
        SaslPassword        string        `mapstructure:"sasl_password" toml:"sasl_password"`
        Topic               string        `mapstructure:"topic"   toml:"topic"`
        Timeout             time.Duration `mapstructure:"timeout" toml:"timeout"`
        LikelihoodThreshold int           `mapstructure:"likelihood_threshold" toml:"likelihood_threshold"`
        ImpactThreshold     int           `mapstructure:"impact_threshold" toml:"impact_threshold"`
        SeverityThreshold   int           `mapstructure:"severity_threshold" toml:"severity_threshold"`
        TotalRiskThreshold  int           `mapstructure:"total_risk_threshold" toml:"total_risk_threshold"`
        EventFilter         string        `mapstructure:"event_filter" toml:"event_filter"`
}

// ServiceLogConfiguration represents configuration of ServiceLog REST API
type ServiceLogConfiguration struct {
        Enabled             bool          `mapstructure:"enabled" toml:"enabled"`
        ClientID            string        `mapstructure:"client_id" toml:"client_id"`
        ClientSecret        string        `mapstructure:"client_secret" toml:"client_secret"`
        TokenURL            string        `mapstructure:"token_url" toml:"token_url"`
        URL                 string        `mapstructure:"url" toml:"url"`
        Timeout             time.Duration `mapstructure:"timeout" toml:"timeout"`
        LikelihoodThreshold int           `mapstructure:"likelihood_threshold" toml:"likelihood_threshold"`
        ImpactThreshold     int           `mapstructure:"impact_threshold" toml:"impact_threshold"`
        SeverityThreshold   int           `mapstructure:"severity_threshold" toml:"severity_threshold"`
        TotalRiskThreshold  int           `mapstructure:"total_risk_threshold" toml:"total_risk_threshold"`
        EventFilter         string        `mapstructure:"event_filter" toml:"event_filter"`
        RuleDetailsURI      string        `mapstructure:"rule_details_uri" toml:"rule_details_uri"`
}

// NotificationsConfiguration represents the configuration specific to the content of notifications
type NotificationsConfiguration struct {
        InsightsAdvisorURL string `mapstructure:"insights_advisor_url" toml:"insights_advisor_url"`
        ClusterDetailsURI  string `mapstructure:"cluster_details_uri" toml:"cluster_details_uri"`
        RuleDetailsURI     string `mapstructure:"rule_details_uri"    toml:"rule_details_uri"`
        Cooldown           string `mapstructure:"cooldown" toml:"cooldown"`
}

// MetricsConfiguration holds metrics related configuration
type MetricsConfiguration struct {
        Job              string        `mapstructure:"job_name" toml:"job_name"`
        Namespace        string        `mapstructure:"namespace" toml:"namespace"`
        Subsystem        string        `mapstructure:"subsystem" toml:"subsystem"`
        GatewayURL       string        `mapstructure:"gateway_url" toml:"gateway_url"`
        GatewayAuthToken string        `mapstructure:"gateway_auth_token" toml:"gateway_auth_token"`
        Retries          int           `mapstructure:"retries" toml:"retries"`
        RetryAfter       time.Duration `mapstructure:"retry_after" toml:"retry_after"`
}

// ProcessingConfiguration represents configuration for processing subsystem
type ProcessingConfiguration struct {
        FilterAllowedClusters bool     `mapstructure:"filter_allowed_clusters" toml:"filter_allowed_clusters"`
        AllowedClusters       []string `mapstructure:"allowed_clusters" toml:"allowed_clusters"`
        FilterBlockedClusters bool     `mapstructure:"filter_blocked_clusters" toml:"filter_blocked_clusters"`
        BlockedClusters       []string `mapstructure:"blocked_clusters" toml:"blocked_clusters"`
}

// LoadConfiguration loads configuration from defaultConfigFile, file set in
// configFileEnvVariableName or from env
func <strong>LoadConfiguration</strong>(configFileEnvVariableName, defaultConfigFile string) (ConfigStruct, error) {
        var configuration ConfigStruct

        // env. variable holding name of configuration file
        configFile, specified := os.LookupEnv(configFileEnvVariableName)
        if specified {
                log.Info().Str(filenameAttribute, configFile).Msg(parsingConfigurationFileMessage)
                // we need to separate the directory name and filename without
                // extension
                directory, basename := filepath.Split(configFile)
                file := strings.TrimSuffix(basename, filepath.Ext(basename))
                // parse the configuration
                viper.SetConfigName(file)
                viper.AddConfigPath(directory)
        } else {
                log.Info().Str(filenameAttribute, defaultConfigFile).Msg(parsingConfigurationFileMessage)
                // parse the configuration
                viper.SetConfigName(defaultConfigFile)
                viper.AddConfigPath(".")
        }

        // try to read the whole configuration
        err := viper.ReadInConfig()
        if _, isNotFoundError := err.(viper.ConfigFileNotFoundError); !specified && isNotFoundError {
                // If config file is not present (which might be correct in
                // some environment) we need to read configuration from
                // environment variables. The problem is that Viper is not
                // smart enough to understand the structure of config by
                // itself, so we need to read fake config file
                fakeTomlConfigWriter := new(bytes.Buffer)

                err := toml.NewEncoder(fakeTomlConfigWriter).Encode(configuration)
                if err != nil {
                        return configuration, err
                }

                fakeTomlConfig := fakeTomlConfigWriter.String()

                viper.SetConfigType("toml")

                err = viper.ReadConfig(strings.NewReader(fakeTomlConfig))
                if err != nil {
                        return configuration, err
                }
        } else if err != nil {
                // error is processed on caller side
                return configuration, fmt.Errorf("fatal error config file: %s", err)
        }

        // override configuration from env if there's variable in env

        const envPrefix = "CCX_NOTIFICATION_SERVICE_"

        viper.AutomaticEnv()
        viper.SetEnvPrefix(envPrefix)
        viper.SetEnvKeyReplacer(strings.NewReplacer("-", "_", ".", "__"))

        err = viper.Unmarshal(&configuration)
        if err != nil {
                return configuration, err
        }

        configuration.Dependencies.TemplateRendererURL, err = createURL(
                configuration.Dependencies.TemplateRendererServer,
                configuration.Dependencies.TemplateRendererEndpoint)
        if err != nil {
                fmt.Println("error creating content template renderer URL")
                return configuration, err
        }

        // everything's should be ok
        return configuration, nil
}

func <strong>createURL</strong>(server, endpoint string) (string, error) {
        u, err := url.Parse(server)
        if err != nil {
                return "", err
        }
        u.Path = path.Join(u.Path, endpoint)
        return u.String(), nil
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Syntaxe pro předávání struktur do funkcí a metod hodnotou a odkazem</h2>

<p>Zopakujme si, jak vlastně vypadají funkce a metody, do nichž se předává
nějaká datová struktura hodnotou (tedy přes kopii) a odkazem (tedy přes
ukazatel na původní strukturu). Syntaxe všech čtyř variant vypadá
následovně:</p>

<pre>
<i>; funkce s&nbsp;předáním struktury hodnotou</i>
func <strong>GetStorageConfigurationByValue</strong>(configuration ConfigStruct) StorageConfiguration {
        return configuration.Storage
}
&nbsp;
<i>; funkce s&nbsp;předáním struktury referencí</i>
func <strong>GetStorageConfigurationByReference</strong>(configuration *ConfigStruct) StorageConfiguration {
        return configuration.Storage
}
&nbsp;
<i>; metoda s&nbsp;příjemcem předaným hodnotou</i>
func (configuration ConfigStruct) <strong>GetStorageConfigurationByValue</strong>() StorageConfiguration {
        return configuration.Storage
}
&nbsp;
<i>; metoda s&nbsp;příjemcem předaným referencí</i>
func (configuration *ConfigStruct) <strong>GetStorageConfigurationByReference</strong>() StorageConfiguration {
        return configuration.Storage
}
</pre>

<p>Při volání <i>funkcí</i> (nikoli metod) je nutné při předání struktury
odkazem ukazatel na danou strukturu získat operátorem &amp;, který je
v&nbsp;jazyce Go inspirován céčkem a má v&nbsp;obou jazycích podobný
význam:</p>

<pre>
conf.GetStorageConfigurationByValue(<strong>configuration</strong>)
conf.GetStorageConfigurationByReference(<strong>&amp;configuration</strong>)
</pre>

<p>Naproti tomu při volání metod žádný ukazatel získávat nemusíme, protože obě
volání vypadají stejně, a to nezávisle na tom, zda je příjemce předáván
hodnotou nebo odkazem:</p>

<pre>
configuration.GetStorageConfigurationByValue()
configuration.GetStorageConfigurationByReference()
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Benchmark zjišťující rozdíly v&nbsp;rychlosti volání funkcí a metod s&nbsp;využitím hodnoty a reference na předávanou strukturu</h2>

<p></p>

<pre>
package conf_test
&nbsp;
<i>// Benchmark for config module</i>
&nbsp;
import (
        "os"
        "testing"
&nbsp;
        "config-struct/conf"
)
&nbsp;
const (
        configFileEnvVariableName = "SERVICE_CONFIG_FILE"
        defaultConfigFileName     = "./config"
)
&nbsp;
<i>// loadConfiguration function loads configuration prepared to be used by</i>
<i>// benchmarks</i>
func <strong>loadConfiguration</strong>() (conf.ConfigStruct, error) {
        os.Clearenv()
&nbsp;
        err := os.Setenv(configFileEnvVariableName, defaultConfigFileName)
        if err != nil {
                return conf.ConfigStruct{}, err
        }
&nbsp;
        config, err := conf.LoadConfiguration(configFileEnvVariableName, defaultConfigFileName)
        if err != nil {
                return conf.ConfigStruct{}, err
        }
&nbsp;
        return config, nil
}
&nbsp;
func <strong>mustLoadBenchmarkConfiguration</strong>(b *testing.B) conf.ConfigStruct {
        configuration, err := loadConfiguration()
        if err != nil {
                b.Fatal(err)
        }
        return configuration
}
&nbsp;
func <strong>BenchmarkGetStorageConfigurationFunctionByValue</strong>(b *testing.B) {
        b.StopTimer()
        configuration := mustLoadBenchmarkConfiguration(b)
        b.StartTimer()
&nbsp;
        for i := 0; i &lt; b.N; i++ {
                // call benchmarked function
                conf.GetStorageConfigurationByValue(configuration)
        }
&nbsp;
}
&nbsp;
func <strong>BenchmarkGetStorageConfigurationFunctionByReference</strong>(b *testing.B) {
        b.StopTimer()
        configuration := mustLoadBenchmarkConfiguration(b)
        b.StartTimer()
&nbsp;
        for i := 0; i &lt; b.N; i++ {
                // call benchmarked function
                conf.GetStorageConfigurationByReference(&amp;configuration)
        }
&nbsp;
}
&nbsp;
func <strong>BenchmarkGetStorageConfigurationMethodByValue</strong>(b *testing.B) {
        b.StopTimer()
        configuration := mustLoadBenchmarkConfiguration(b)
        b.StartTimer()
&nbsp;
        for i := 0; i &lt; b.N; i++ {
                // call benchmarked function
                configuration.GetStorageConfigurationByValue()
        }
&nbsp;
}
&nbsp;
func <strong>BenchmarkGetStorageConfigurationMethodByReference</strong>(b *testing.B) {
        b.StopTimer()
        configuration := mustLoadBenchmarkConfiguration(b)
        b.StartTimer()
&nbsp;
        for i := 0; i &lt; b.N; i++ {
                // call benchmarked function
                configuration.GetStorageConfigurationByReference()
        }
&nbsp;
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Výsledky benchmarku i profileru</h2>

<p>Podívejme se nyní na výsledky všech čtyř benchmarků, jejichž zdrojové kódy
jsme si ukázali a popsali <a href="#k11">v&nbsp;předchozí kapitole</a>. Celkem
je provedeno 1000000000 volání všech testovaných funkcí a metod:</p>

<pre>
$ <strong>go test -bench=. -benchtime=1000000000x -cpuprofile profile.out -v config-struct/conf</strong>
&nbsp;
goos: linux
goarch: amd64
pkg: config-struct/conf
cpu: Intel(R) Core(TM) i7-8665U CPU @ 1.90GHz
BenchmarkGetStorageConfigurationFunctionByValue
BenchmarkGetStorageConfigurationFunctionByValue-8               1000000000              13.20 ns/op
BenchmarkGetStorageConfigurationFunctionByReference
BenchmarkGetStorageConfigurationFunctionByReference-8           1000000000               0.2405 ns/op
BenchmarkGetStorageConfigurationMethodByValue
BenchmarkGetStorageConfigurationMethodByValue-8                 1000000000              13.24 ns/op
BenchmarkGetStorageConfigurationMethodByReference
BenchmarkGetStorageConfigurationMethodByReference-8             1000000000               0.3596 ns/op
PASS
ok      config-struct/conf      27.166s
</pre>

<p><div class="rs-tip-major">Poznámka: z&nbsp;výsledků benchmarků je patrné, že
volání funkce s&nbsp;předáním reference je přibližně 55&times; rychlejší, než
volání obdobné funkce, které se však předá přímo hodnota struktury. Podobně pro
volání metod je použití reference jako příjemce (<i>receiver</i>) přibližně
36&times; rychlejší, než použití hodnoty jako příjemce. Samozřejmě se liší
<i>sémantika</i> volání, ale obecně je použití reference mnohem rychlejší (a
nebezpečnější kvůli nemožnosti použití modifikátoru <strong>const</strong>).
Pro menší struktury (a naše testovaná struktura je skutečně velká) budou
rozdíly v&nbsp;dosažených časech pochopitelně menší.</div></p>

<p>Profiler, konkrétně profiler zjišťující zatížení mikroprocesoru výpočty, se
spustí následujícím příkazem:</p>

<pre>
$ <strong>go test -bench=. -benchtime=1000000000x -cpuprofile profile.out -v config-struct/conf</strong>
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Mapy vs. řezy při implementaci jednoduché paměťové cache</h2>

<p>Následující benchmark vznikl z&nbsp;toho důvodu, že jsme pro účely jednoho
projektu zjišťovali, jakým způsobem se má implementovat jednoduchá paměťová
cache, konkrétně cache pro prvky, jejichž klíče jsou typu <strong>int</strong>
a hodnoty obsahují UUID a časové razítko (v&nbsp;samotné aplikaci je situace
složitější, neboť se používá komplikovanější datová struktura). Poněkud
neobvyklé ovšem bylo, že počet položek umístěných do paměťové cache je
relativně malý &ndash; většinou v&nbsp;intervalu od 1 do 10 &ndash; a počet
čtení o několik řádů přesahuje počet zápisů.</p>

<p>Vzhledem k&nbsp;tomu, že prvky v&nbsp;cache jsou určeny identifikátorem
(typu <strong>int</strong>), mohlo by se zdát řešení triviální: použít mapu.
Ovšem vzhledem k&nbsp;požadavku na co nejvyšší rychlost nalezení prvků byl
vytvořen benchmark a navíc se kromě implementace cache přes mapu (což je
řešení, které automaticky napadne každého vývojáře) vytvořilo i alternativní
řešení založené na použití běžného řezu s&nbsp;lineárním (!!!) vyhledáváním.
Z&nbsp;teoretického hlediska je to pochopitelně nesmysl, ovšem podívejme se na
chování takové cache pro malý počet uložených prvků. Toto chování je otestováno
v&nbsp;následujícím benchmarku:</p>

<pre>
package main
&nbsp;
import (
        "testing"
        "time"
&nbsp;
        "github.com/google/uuid"
)
&nbsp;
type ID int
&nbsp;
type Payload struct {
        uuid      string
        timestamp time.Time
}
&nbsp;
type IdWithPayload struct {
        id        ID
        uuid      string
        timestamp time.Time
}
&nbsp;
func <strong>genID</strong>(i int) ID {
        return ID(3*i + 1)
}
&nbsp;
func <strong>fillInMap</strong>(b *testing.B, items int) map[ID]Payload {
        b.StopTimer()
&nbsp;
        m := make(map[ID]Payload, items)
&nbsp;
        for i := 0; i &lt; items; i++ {
                id := genID(i)
                payload := Payload{
                        uuid:      uuid.New().String(),
                        timestamp: time.Now(),
                }
                m[id] = payload
        }
&nbsp;
        b.StartTimer()
        return m
}
&nbsp;
func <strong>fillInSlice</strong>(b *testing.B, items int) []IdWithPayload {
        b.StopTimer()
&nbsp;
        s := make([]IdWithPayload, items)
&nbsp;
        for i := 0; i &lt; items; i++ {
                idWithPayload := IdWithPayload{
                        id:        genID(i),
                        uuid:      uuid.New().String(),
                        timestamp: time.Now(),
                }
                s[i] = idWithPayload
        }
&nbsp;
        b.StartTimer()
        return s
}
&nbsp;
func <strong>performBenchmarkFindInMap</strong>(b *testing.B, m map[ID]Payload) {
        items := len(m)
        for i := 0; i &lt; b.N; i++ {
                _, found := m[genID(i%items)]
                if !found {
                        b.Fatal("not found")
                }
        }
}
&nbsp;
func <strong>performBenchmarkFindInSlice</strong>(b *testing.B, s []IdWithPayload) {
        items := len(s)
        for i := 0; i &lt; b.N; i++ {
                found := false
                id := genID(i % items)
                for _, p := range s {
                        if p.id == id {
                                found = true
                                break
                        }
                }
                if !found {
                        b.Fatal("not found")
                }
        }
}
&nbsp;
func <strong>BenchmarkFindInMap1</strong>(b *testing.B) {
        m := fillInMap(b, 1)
        performBenchmarkFindInMap(b, m)
}
&nbsp;
func <strong>BenchmarkFindInSlice1</strong>(b *testing.B) {
        m := fillInSlice(b, 1)
        performBenchmarkFindInSlice(b, m)
}
&nbsp;
func <strong>BenchmarkFindInMap5</strong>(b *testing.B) {
        m := fillInMap(b, 5)
        performBenchmarkFindInMap(b, m)
}
&nbsp;
func <strong>BenchmarkFindInSlice5</strong>(b *testing.B) {
        m := fillInSlice(b, 5)
        performBenchmarkFindInSlice(b, m)
}
&nbsp;
func <strong>BenchmarkFindInMap10</strong>(b *testing.B) {
        m := fillInMap(b, 10)
        performBenchmarkFindInMap(b, m)
}
&nbsp;
func <strong>BenchmarkFindInSlice10</strong>(b *testing.B) {
        m := fillInSlice(b, 10)
        performBenchmarkFindInSlice(b, m)
}
&nbsp;
func <strong>BenchmarkFindInMap20</strong>(b *testing.B) {
        m := fillInMap(b, 20)
        performBenchmarkFindInMap(b, m)
}
&nbsp;
func <strong>BenchmarkFindInSlice20</strong>(b *testing.B) {
        m := fillInSlice(b, 20)
        performBenchmarkFindInSlice(b, m)
}
&nbsp;
func <strong>BenchmarkFindInMap100</strong>(b *testing.B) {
        m := fillInMap(b, 100)
        performBenchmarkFindInMap(b, m)
}
&nbsp;
func <strong>BenchmarkFindInSlice100</strong>(b *testing.B) {
        m := fillInSlice(b, 100)
        performBenchmarkFindInSlice(b, m)
}
&nbsp;
func <strong>BenchmarkFindInMap1000</strong>(b *testing.B) {
        m := fillInMap(b, 1000)
        performBenchmarkFindInMap(b, m)
}
&nbsp;
func <strong>BenchmarkFindInSlice1000</strong>(b *testing.B) {
        m := fillInSlice(b, 1000)
        performBenchmarkFindInSlice(b, m)
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Výsledky benchmarků</h2>

<pre>
$ <strong>go test -bench=. -benchtime=100000000x</strong>
&nbsp;
goos: linux
goarch: amd64
pkg: slice-or-map
cpu: Intel(R) Core(TM) i7-8665U CPU @ 1.90GHz
BenchmarkFindInMap1-8           100000000               12.13 ns/op
BenchmarkFindInSlice1-8         100000000                9.573 ns/op
BenchmarkFindInMap5-8           100000000               13.19 ns/op
BenchmarkFindInSlice5-8         100000000               10.78 ns/op
BenchmarkFindInMap10-8          100000000               15.82 ns/op
BenchmarkFindInSlice10-8        100000000               14.11 ns/op
BenchmarkFindInMap20-8          100000000               15.29 ns/op
BenchmarkFindInSlice20-8        100000000               17.80 ns/op
BenchmarkFindInMap100-8         100000000               17.07 ns/op
BenchmarkFindInSlice100-8       100000000               64.13 ns/op
BenchmarkFindInMap1000-8        100000000               23.96 ns/op
BenchmarkFindInSlice1000-8      100000000              611.9 ns/op
PASS
ok      slice-or-map    82.604s
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;případě, že vás překvapuje, že je
přístup do mapy (relativně) pomalý pro malý počet prvků, postačuje se podívat
na implementaci mapy, konkrétně na funkce <strong>mapaccess1</strong> a
<strong>mapaccess2</strong>. Počet operací, které se při vyhledání prvku
provádí, je skutečně velký v&nbsp;porovnání s&nbsp;triviálním lineárním
průchodem prvky řezu, takže pro počet prvků do cca 20 je (což může znít
paradoxně) mnohdy rychlejší použití řezů.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Grafické porovnání výsledků</h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. Mapy vs. řezy při implementaci množiny</h2>

<pre>
package main
&nbsp;
import (
        "testing"
)
&nbsp;
type ID int
&nbsp;
func <strong>genID</strong>(i int) ID {
        return ID(3*i + 1)
}
&nbsp;
func <strong>fillInMap</strong>(b *testing.B, items int) map[ID]struct{} {
        b.StopTimer()
&nbsp;
        m := make(map[ID]struct{}, items)
&nbsp;
        for i := 0; i &lt; items; i++ {
                id := genID(i)
                m[id] = struct{}{}
        }
&nbsp;
        b.StartTimer()
        return m
}
&nbsp;
func <strong>fillInSlice</strong>(b *testing.B, items int) []ID {
        b.StopTimer()
&nbsp;
        s := make([]ID, items)
&nbsp;
        for i := 0; i &lt; items; i++ {
                id := genID(i)
                s[i] = id
        }
&nbsp;
        b.StartTimer()
        return s
}
&nbsp;
func <strong>performBenchmarkFindInMap</strong>(b *testing.B, m map[ID]struct{}) {
        items := len(m)
        for i := 0; i &lt; b.N; i++ {
                _, found := m[genID(i%items)]
                if !found {
                        b.Fatal("not found")
                }
        }
}
&nbsp;
func <strong>performBenchmarkFindInSlice</strong>(b *testing.B, s []ID) {
        items := len(s)
        for i := 0; i &lt; b.N; i++ {
                found := false
                id := genID(i % items)
                for _, p := range s {
                        if p == id {
                                found = true
                                break
                        }
                }
                if !found {
                        b.Fatal("not found")
                }
        }
}
&nbsp;
func <strong>BenchmarkFindInMap1</strong>(b *testing.B) {
        m := fillInMap(b, 1)
        performBenchmarkFindInMap(b, m)
}
&nbsp;
func <strong>BenchmarkFindInSlice1</strong>(b *testing.B) {
        m := fillInSlice(b, 1)
        performBenchmarkFindInSlice(b, m)
}
&nbsp;
func <strong>BenchmarkFindInMap5</strong>(b *testing.B) {
        m := fillInMap(b, 5)
        performBenchmarkFindInMap(b, m)
}
&nbsp;
func <strong>BenchmarkFindInSlice5</strong>(b *testing.B) {
        m := fillInSlice(b, 5)
        performBenchmarkFindInSlice(b, m)
}
&nbsp;
func <strong>BenchmarkFindInMap10</strong>(b *testing.B) {
        m := fillInMap(b, 10)
        performBenchmarkFindInMap(b, m)
}
&nbsp;
func <strong>BenchmarkFindInSlice10</strong>(b *testing.B) {
        m := fillInSlice(b, 10)
        performBenchmarkFindInSlice(b, m)
}
&nbsp;
func <strong>BenchmarkFindInMap20</strong>(b *testing.B) {
        m := fillInMap(b, 20)
        performBenchmarkFindInMap(b, m)
}
&nbsp;
func <strong>BenchmarkFindInSlice20</strong>(b *testing.B) {
        m := fillInSlice(b, 20)
        performBenchmarkFindInSlice(b, m)
}
&nbsp;
func <strong>BenchmarkFindInMap100</strong>(b *testing.B) {
        m := fillInMap(b, 100)
        performBenchmarkFindInMap(b, m)
}
&nbsp;
func <strong>BenchmarkFindInSlice100</strong>(b *testing.B) {
        m := fillInSlice(b, 100)
        performBenchmarkFindInSlice(b, m)
}
&nbsp;
func <strong>BenchmarkFindInMap1000</strong>(b *testing.B) {
        m := fillInMap(b, 1000)
        performBenchmarkFindInMap(b, m)
}
&nbsp;
func <strong>BenchmarkFindInSlice1000</strong>(b *testing.B) {
        m := fillInSlice(b, 1000)
        performBenchmarkFindInSlice(b, m)
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Výsledky benchmarku</h2>

<pre>
$ <strong>go test -bench=. -benchtime=100000000x</strong>
&nbsp;
goos: linux
goarch: amd64
pkg: sets-slice-or-map
cpu: Intel(R) Core(TM) i7-8665U CPU @ 1.90GHz
BenchmarkFindInMap1-8           100000000               12.01 ns/op
BenchmarkFindInSlice1-8         100000000                7.208 ns/op
BenchmarkFindInMap5-8           100000000               12.61 ns/op
BenchmarkFindInSlice5-8         100000000                8.346 ns/op
BenchmarkFindInMap10-8          100000000               14.57 ns/op
BenchmarkFindInSlice10-8        100000000                9.498 ns/op
BenchmarkFindInMap20-8          100000000               14.28 ns/op
BenchmarkFindInSlice20-8        100000000               11.61 ns/op
BenchmarkFindInMap100-8         100000000               14.63 ns/op
BenchmarkFindInSlice100-8       100000000               35.57 ns/op
BenchmarkFindInMap1000-8        100000000               22.53 ns/op
BenchmarkFindInSlice1000-8      100000000              281.4 ns/op
PASS
ok      sets-slice-or-map       44.437s
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Závěrečné zhodnocení &ndash; triviální a přitom mnohdy důležité optimalizace</h2>

<p>V&nbsp;dnešním článku jsme si ukázali velmi jednoduché optimalizace, které je možné provádět v&nbsp;aplikacích naprogramovaných v&nbsp;jazyku Go. Jak bylo z&nbsp;předchozích kapitol patrné, jedná se o triviální optimalizace, které však mohou být užitečné a důležité. Prakticky vždy je však při výběru algoritmu určeného pro řešení určité úlohy užitečné si napsat benchmarky, spustit je a taktéž spustit profiler. Jen tak lze &bdquo;objevit&ldquo; některé zajímavé odchylky pro určitou velikost úlohy &ndash; viz například benchmark pro cache a benchmark pro implementaci množiny dvěma různými datovými strukturami.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
nového Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně stovku kilobajtů), můžete namísto toho použít odkazy na jednotlivé
demonstrační příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad/soubor</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>maps/map1_test.go</td><td>benchmark pro mapy, jejichž klíče jsou typu UUID a hodnoty jsou časovými razítky</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_98/maps/map1_test.go">https://github.com/tisnik/go-root/blob/master/article_98/maps/map1_test.go</a></td></tr>
<tr><td> 2</td><td>maps/map2_test.go</td><td>benchmark pro mapy, jejichž klíče jsou typu <strong>int</strong> a i hodnoty jsou stejného typu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_98/maps/map2_test.go">https://github.com/tisnik/go-root/blob/master/article_98/maps/map2_test.go</a></td></tr>
<tr><td> 3</td><td>maps/map3_test.go</td><td>benchmark pro mapy, jejichž prvky jsou prázdnými strukturami</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_98/maps/map3_test.go">https://github.com/tisnik/go-root/blob/master/article_98/maps/map3_test.go</a></td></tr>
<tr><td> 4</td><td>maps/map4_test.go</td><td>benchmark pro mapy, jejichž klíče mají velikost 100 bajtů</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_98/maps/map4_test.go">https://github.com/tisnik/go-root/blob/master/article_98/maps/map4_test.go</a></td></tr>
<tr><td> 5</td><td>maps/go.mod</td><td>projektový soubor s&nbsp;definicí modulu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_98/maps/go.mod">https://github.com/tisnik/go-root/blob/master/article_98/maps/go.mod</a></td></tr>
<tr><td> 6</td><td>maps/go.sum</td><td>seznam všech přímých i nepřímých závislostí</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_98/maps/go.sum">https://github.com/tisnik/go-root/blob/master/article_98/maps/go.sum</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>map_or_slice/map_or_slice_test.go</td><td>benchmark porovnávající použití řezů a map pro podobné operace vyhledání hodnoty</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_98/map_or_slice/map_or_slice_test.go">https://github.com/tisnik/go-root/blob/master/article_98/map_or_slice/map_or_slice_test.go</a></td></tr>
<tr><td> 8</td><td>map_or_slice/go.mod</td><td>projektový soubor s&nbsp;definicí modulu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_98/map_or_slice/go.mod">https://github.com/tisnik/go-root/blob/master/article_98/map_or_slice/go.mod</a></td></tr>
<tr><td> 9</td><td>map_or_slice/go.sum</td><td>seznam všech přímých i nepřímých závislostí</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_98/map_or_slice/go.sum">https://github.com/tisnik/go-root/blob/master/article_98/map_or_slice/go.sum</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>sets/map_or_slice_test.go</td><td>benchmark: je lepší použít mapu nebo řez pro implementaci množiny?</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_98/sets/map_or_slice_test.go">https://github.com/tisnik/go-root/blob/master/article_98/sets/map_or_slice_test.go</a></td></tr>
<tr><td>11</td><td>sets/go.mod</td><td>projektový soubor s&nbsp;definicí modulu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_98/sets/go.mod">https://github.com/tisnik/go-root/blob/master/article_98/sets/go.mod</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>parameter_value_reference/main.go</td><td>předávání rozsáhlých parametrů: hlavní program</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_98/parameter_value_reference/main.go">https://github.com/tisnik/go-root/blob/master/article_98/parameter_value_reference/main.go</a></td></tr>
<tr><td>13</td><td>parameter_value_reference/config.toml</td><td>konfigurační soubor, který je načítán programem</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_98/parameter_value_reference/config.toml">https://github.com/tisnik/go-root/blob/master/article_98/parameter_value_reference/config.toml</a></td></tr>
<tr><td>14</td><td>parameter_value_reference/go.mod</td><td>projektový soubor s&nbsp;definicí modulu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_98/parameter_value_reference/go.mod">https://github.com/tisnik/go-root/blob/master/article_98/parameter_value_reference/go.mod</a></td></tr>
<tr><td>15</td><td>parameter_value_reference/go.sum</td><td>seznam všech přímých i nepřímých závislostí</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_98/parameter_value_reference/go.sum">https://github.com/tisnik/go-root/blob/master/article_98/parameter_value_reference/go.sum</a></td></tr>
<tr><td>16</td><td>parameter_value_reference/conf/config.go</td><td>definice datové struktury s&nbsp;načítanou konfigurací</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_98/parameter_value_reference/conf/config.go">https://github.com/tisnik/go-root/blob/master/article_98/parameter_value_reference/conf/config.go</a></td></tr>
<tr><td>17</td><td>parameter_value_reference/conf/config.toml</td><td>konfigurační soubor, který je načítán benchmarkem</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_98/parameter_value_reference/conf/config.toml">https://github.com/tisnik/go-root/blob/master/article_98/parameter_value_reference/conf/config.toml</a></td></tr>
<tr><td>18</td><td>parameter_value_reference/conf/config_benchmark_test.go</td><td>benchmark: předávání velké struktury hodnotou nebo referencí?</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_98/parameter_value_reference/conf/config_benchmark_test.go">https://github.com/tisnik/go-root/blob/master/article_98/parameter_value_reference/conf/config_benchmark_test.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>An Introduction to Benchmarking Your Go Programs<br />
<a href="https://tutorialedge.net/golang/benchmarking-your-go-programs/">https://tutorialedge.net/golang/benchmarking-your-go-programs/</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Go18DS (Go 1.18+ Data Structures)<br />
<a href="https://github.com/daichi-m/go18ds">https://github.com/daichi-m/go18ds</a>
</li>

<li>TreeMap v2<br />
<a href="https://github.com/igrmk/treemap">https://github.com/igrmk/treemap</a>
</li>

<li>Go Data Structures: Binary Search Tree<br />
<a href="https://flaviocopes.com/golang-data-structure-binary-search-tree/">https://flaviocopes.com/golang-data-structure-binary-search-tree/</a>
</li>

<li>Generics in Go<br />
<a href="https://bitfieldconsulting.com/golang/generics">https://bitfieldconsulting.com/golang/generics</a>
</li>

<li>Tutorial: Getting started with generics<br />
<a href="https://go.dev/doc/tutorial/generics">https://go.dev/doc/tutorial/generics</a>
</li>

<li>Gobs of data<br />
<a href="https://blog.golang.org/gobs-of-data">https://blog.golang.org/gobs-of-data</a>
</li>

<li>Performance at Scale: MinIO Pushes Past 1.4 terabits per second with 256 NVMe Drives<br />
<a href="https://blog.min.io/performance-at-scale-minio-pushes-past-1-3-terabits-per-second-with-256-nvme-drives/">https://blog.min.io/performance-at-scale-minio-pushes-past-1-3-terabits-per-second-with-256-nvme-drives/</a>
</li>

<li>Benchmarking MinIO vs. AWS S3 for Apache Spark<br />
<a href="https://blog.min.io/benchmarking-apache-spark-vs-aws-s3/">https://blog.min.io/benchmarking-apache-spark-vs-aws-s3/</a>
</li>

<li>Know Go: Generics (Kniha)<br />
<a href="https://bitfieldconsulting.com/books/generics">https://bitfieldconsulting.com/books/generics</a>
</li>

<li>Go 1.18 Generics based slice package<br />
<a href="https://golangexample.com/go-1-18-generics-based-slice-package/">https://golangexample.com/go-1-18-generics-based-slice-package/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

