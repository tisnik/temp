<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Serializace a deserializace datových struktur v&nbsp;programovacím jazyce Go</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Serializace a deserializace datových struktur v&nbsp;programovacím jazyce Go</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dnešní článek seriálu o programovacím jazyce Go je věnován problematice serializace a deserializace datových struktur za účelem jejich uložení či poslání do jiné služby. Kromě běžných textových formátů typu JSON a XML je k dispozici i několik formátů binárních, jenž mohou být v mnoha situacích lepší volbou.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Serializace a deserializace datových struktur v&nbsp;programovacím jazyce Go</a></p>
<p><a href="#k02">2. Rozhraní s&nbsp;předpisem metod pro serializaci a deserializaci dat</a></p>
<p><a href="#k03">3. Krátké zopakování &ndash; práce s&nbsp;formátem JSON</a></p>
<p><a href="#k04">4. Některá úskalí převodu hodnot do formátu JSON</a></p>
<p><a href="#k05">5. Serializace dat do formátu XML</a></p>
<p><a href="#k06">6. Specifikace jména kořenového uzlu, konfigurace odsazení při formátování XML</a></p>
<p><a href="#k07">7. Struktura XML odlišná od struktury původních serializovaných dat</a></p>
<p><a href="#k08">8. Serializace polí, speciální hodnoty, ukazatele apod.</a></p>
<p><a href="#k09">9. Serializace sekvence struktur</a></p>
<p><a href="#k10">10. Obalení sekvence struktur dalším datovým typem</a></p>
<p><a href="#k11">11. Vylepšení předchozích příkladů</a></p>
<p><a href="#k12">12. Serializace jedné struktury jak do JSONu, tak i do XML &ndash; problematika anotačních řetězců</a></p>
<p><a href="#k13">13. Binární formáty a programovací jazyk Go</a></p>
<p><a href="#k14">14. Formát gob</a></p>
<p><a href="#k15">15. Serializace datové struktury do formátu gob</a></p>
<p><a href="#k16">16. Formát CBOR (Concise Binary Object Representation)</a></p>
<p><a href="#k17">17. Serializace dat do formátu BSON</a></p>
<p><a href="#k18">18. Deserializace dat z&nbsp;formátu BSON</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Serializace a deserializace datových struktur v&nbsp;programovacím jazyce Go</h2>

<p>V&nbsp;dnešní části <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">seriálu o
programovacím jazyku Go</a> se zaměříme na popis způsobů použití různých
formátů určených pro serializaci a deserializaci dat s&nbsp;jejich případným
přenosem do jiné aplikace či služby (přenosem se myslí jak lokální komunikace,
tak i přenos do služby běžící na jiném počítači). Již dříve jsme se ve
stručnosti seznámili s&nbsp;využitím formátu JSON a nepřímo taktéž
s&nbsp;formátem TOML používaným typicky pro konfigurační soubory (a mnohem méně
často pro rozsáhlejší data). V&nbsp;případě JSONu se jedná o poměrně důležitý
formát, protože JSON (a samozřejmě též XML) se v&nbsp;současnosti používá
v&nbsp;mnoha webových službách a i když stále vznikají a jsou postupně
adaptovány další formáty, ať již textové (<a href="https://yaml.org/">YAML</a>,
<a href="https://github.com/edn-format/edn">edn</a>) či binární (<a
href="http://bsonspec.org/">BSON</a>, <a href="http://bjson.org/">B-JSON</a>,
<a href="https://github.com/FasterXML/smile-format-specification">Smile</a>, <a
href="https://developers.google.com/protocol-buffers/">Protocol-Buffers</a>),
<a href="https://github.com/fxamacker/cbor">CBOR</a> atd., je velmi
pravděpodobné, že se JSON bude i nadále poměrně masivně využívat. Nicméně
pochopitelně existují situace, v&nbsp;nichž je vhodné textový a relativně
neúsporný JSON nahradit právě nějakým binárním formátem.</p>

<p>Některé metody serializace a deserializace datových struktur jsou
implementovány přímo ve standardních knihovnách programovacího jazyka Go; další
metody (resp.&nbsp;přesněji řečeno formáty) však již vyžadují instalaci
zvláštní knihovny popř.&nbsp;vlastní implementaci daného formátu. Nejdříve se
zaměříme na ty formáty, které jsou podporovány bez nutnosti instalace dalších
balíčků a posléze si ukážeme i některé přídavné balíčky pro ty nejzajímavější
popř.&nbsp;nejpoužívanější formáty.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Rozhraní s&nbsp;předpisem metod pro serializaci a deserializaci dat</h2>

<p>Základní rozhraní pro serializaci a deserializaci datových struktur jsou
definována ve standardním balíčku <strong>encoding</strong>, jehož dokumentaci
je možné nalézt na adrese <a
href="https://golang.org/pkg/encoding/">https://golang.org/pkg/encoding/</a>.
Každé z&nbsp;rozhraní předepisuje &ndash; jak je ostatně v&nbsp;jazyce Go
zvykem &ndash; pouze jednu metodu. Jakýkoli objekt, který je schopen své
serializace či deserializace může tyto metody obsahovat:</p>

<table>
<tr><th>#</th><th>Rozhraní</th><th>Signatura metody</th></tr>
<tr><td>1</td><td>TextMarshaler</td><td>MarshalText() (text []byte, err error)</td></tr>
<tr><td>2</td><td>TextUnmarshaler</td><td>UnmarshalText(text []byte) error</td></tr>
<tr><td>3</td><td>BinaryMarshaler</td><td>MarshalBinary() (data []byte, err error)</td></tr>
<tr><td>4</td><td>BinaryUnmarshaler</td><td>UnmarshalBinary(data []byte) error</td></tr>
</table>

<p>Typické je, že při serializaci (marshalingu) je výsledkem řez bajtů a nikoli
řetězec (ve smyslu jazyka Go). Podobně při deserialiaci (umarshalingu) je
zdrojem dat parametr typu řez bajtů. Díky tomu jsme odstíněni od problematiky
kódování znaků ve &bdquo;skutečných&ldquo; textových řetězcích.</p>

<p><div class="rs-tip-major">Poznámka: připomeňme si, že v&nbsp;jazyce Go není
zapotřebí rozhraní explicitně <i>implementovat</i> (<i>implement</i>) tak, jak
je tomu například v&nbsp;Javě. Plně postačuje, aby nějaký datový typ obsahoval
příslušnou metodu. Potom říkáme, že tento typ rozhraní <i>vyhovuje</i>
(<i>satisfy</i>).</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Krátké zopakování &ndash; práce s&nbsp;formátem JSON</h2>

<p>Před popisem dalších metod serializace a deserializace datových struktur si
krátce zopakujme, jakým způsobem je ve standardní knihovně programovacího
jazyka Go podporován formát JSON. Tento formát je dnes široce rozšířen a
používá se jak pro ukládání konfigurací, specifikaci schématu v&nbsp;OpenAPI
(vedle YAMLu), uložení konfigurace dashboardu v&nbsp;Grafaně atd., tak &ndash;
a to možná především &ndash; ve webových službách a aplikacích pro přenos
strukturovaných dat. Jedná se o formát, jehož syntaxe a sémantika je odvozená
od JavaScriptu, s&nbsp;čímž je nutné počítat, protože ne všechny knihovny
například umožňují, aby se v&nbsp;klíčích objevovaly pomlčky či jiné
&bdquo;podivné&ldquo; znaky, i když to <a
href="https://www.json.org/json-en.html">teoreticky formát JSON
umožňuje</a>.</p>

<p>Podívejme se na příklad služby vracející dokument reprezentovaný ve formátu
JSON (tuto službu můžete použít pro testování apod.):</p>

<pre>
$ <strong>curl http://httpbin.org/json</strong>
&nbsp;
{
  "slideshow": {
    "author": "Yours Truly", 
    "date": "date of publication", 
    "slides": [
      {
        "title": "Wake up to WonderWidgets!", 
        "type": "all"
      }, 
      {
        "items": [
          "Why &lt;em&gt;WonderWidgets&lt;/em&gt; are great", 
          "Who &lt;em&gt;buys&lt;/em&gt; WonderWidgets"
        ], 
        "title": "Overview", 
        "type": "all"
      }
    ], 
    "title": "Sample Slide Show"
  }
}
</pre>

<p>Formát JSON umožňuje uložení a tím pádem i přenos jediné (nijak
nepojmenované) hodnoty. Podporovány jsou přitom hodnoty, které můžeme zařadit
do šesti kategorií (viz též <a href="http://json.org/value.gif">příslušná část
graficky vyjádřené syntaxe</a> formátu JSON):</p>

<table>
<tr><th>#</th><th>Hodnota</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>string</td><td>řetězec (s&nbsp;plnou podporou Unicode)</td></tr>
<tr><td>2</td><td>number</td><td>celé číslo popř.&nbsp;hodnota typu <i>double</i></td></tr>
<tr><td>3</td><td>object</td><td>ve skutečnosti se jedná o asociativní pole (mapu), viz poznámka <a href="#k01">v&nbsp;úvodní kapitole</a></td></tr>
<tr><td>4</td><td>array</td><td>pole, ovšem v&nbsp;JSONu nemusí mít všechny prvky pole stejný typ</td></tr>
<tr><td>5</td><td><strong>true</strong>, <strong>false</strong></td><td>pravdivostní hodnota</td></tr>
<tr><td>6</td><td><strong>null</strong></td><td>prázdná hodnota</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: díky tomu, že onou jedinou hodnotou může
být pole či objekt, lze ve skutečnosti pracovat i s&nbsp;rozsáhlými a složitě
strukturovanými daty.</div></p>

<p>Pro převod libovolného typu (přesněji řečeno hodnoty libovolného typu) do
JSONu se používá funkce nazvaná <strong>Marshal</strong>, kterou nalezneme
v&nbsp;balíčku <strong>encoding/json</strong>:</p>

<pre>
func <strong>Marshal</strong>(v interface{}) ([]byte, error)
</pre>

<p>Povšimněte si, že tato funkce skutečně akceptuje hodnotu libovolného typu,
protože prázdné rozhraní implementuje (zcela automaticky!) každý datový typ
(s&nbsp;tímto zajímavým konceptem &bdquo;univerzálního datového typu&ldquo; se
ještě několikrát setkáme, zejména v&nbsp;rozhraních mezi Go a dalšími systémy).
Návratovou hodnotou je sekvence bajtů (nikoli řetězec!) a popř.&nbsp;i
struktura reprezentující chybový stav, pokud k&nbsp;chybě skutečně došlo.
V&nbsp;opačném případě se ve druhé návratové hodnotě funkce
<strong>Marshal</strong> vrací <strong>nil</strong>, jak jsme ostatně zvyklí ze
všech podobně koncipovaných funkcí.</p>

<p>V&nbsp;typických zdrojových kódech se tedy setkáme s&nbsp;tímto idiomatickým
zápisem:</p>

<pre>
json_bytes, err := <strong>json.Marshal(a)</strong>
&nbsp;
if err != nil {
        log.Fatal(err)
}
...
...
...
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Některá úskalí převodu hodnot do formátu JSON</h2>

<p>V&nbsp;některých případech, například při přenosu výsledků z&nbsp;různých
simulací, měření, výpočtů apod. je nutné pracovat s&nbsp;celočíselnými
hodnotami popř.&nbsp;s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou. A právě
zde můžeme narazit na různá úskalí, které se týkají speciálních hodnot typu
+Inf, -Inf (kladné a záporné nekonečno) a pochopitelně taktéž NaN (výsledkem
nějaké operace není skutečné číslo, výsledek nelze vyjádřit atd.). Nejprve se
podívejme na serializaci běžných hodnot s&nbsp;plovoucí řádovou čárkou.
Podporován by měl být rozsah i přesnost odpovídající typu <i>double</i>,
resp.&nbsp;v&nbsp;programovacím jazyku Go typu <i>float64</i>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/json"
        "fmt"
)
&nbsp;
func <strong>main</strong>() {
        var a float64 = 0.0
        var b float64 = 1e10
        var c float64 = 1e100
        var d float64 = 2.3e-50
&nbsp;
        var jsonOutput []byte
&nbsp;
        jsonOutput, _ = json.Marshal(a)
        fmt.Println(string(jsonOutput))
&nbsp;
        jsonOutput, _ = json.Marshal(b)
        fmt.Println(string(jsonOutput))
&nbsp;
        jsonOutput, _ = json.Marshal(c)
        fmt.Println(string(jsonOutput))
&nbsp;
        jsonOutput, _ = json.Marshal(d)
        fmt.Println(string(jsonOutput))
}
</pre>

<p>V&nbsp;tomto případě nedochází k&nbsp;chybám (ostatně chybové hodnoty zcela
ignorujeme) a serializace do JSONu vypadá následovně:</p>

<pre>
0
10000000000
1e+100
2.3e-50
</pre>

<p>Ovšem u výše uvedených speciálních hodnot dochází k&nbsp;problémům, což je
zmíněno například na <a
href="https://stackoverflow.com/questions/1423081/json-left-out-infinity-and-nan-json-status-in-ecmascript">Stack
Overflow</a>. Můžeme se o tom přesvědčit nepatrnou úpravou předchozího
příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/json"
        "fmt"
        "math"
)
&nbsp;
func <strong>main</strong>() {
        var a float64 = -0.0
        var b float64 = math.NaN()
        var c float64 = -math.NaN()
        var d float64 = math.Inf(1)
        var e float64 = math.Inf(-1)
&nbsp;
        var jsonOutput []byte
&nbsp;
        jsonOutput, _ = json.Marshal(a)
        fmt.Println(string(jsonOutput))
&nbsp;
        jsonOutput, _ = json.Marshal(b)
        fmt.Println(string(jsonOutput))
&nbsp;
        jsonOutput, _ = json.Marshal(c)
        fmt.Println(string(jsonOutput))
&nbsp;
        jsonOutput, _ = json.Marshal(d)
        fmt.Println(string(jsonOutput))
&nbsp;
        jsonOutput, _ = json.Marshal(e)
        fmt.Println(string(jsonOutput))
}
</pre>

<p>Tentokrát se zdá, že serializace do formátu JSON vrátila pouze prázdné
řetězce:</p>

<pre>
0
&nbsp;
&nbsp;
&nbsp;
&nbsp;
</pre>

<p>Ovšem skutečnost je jiná, protože balíček <strong>encoding/json</strong>
hlídá, které hodnoty lze převést a které nikoli. Musíme ovšem naši aplikaci
naprogramovat korektně, tj.&nbsp;v&nbsp;tomto konkrétním případě reagovat na
všechny chybové stavy:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/json"
        "fmt"
        "math"
)
&nbsp;
func <strong>main</strong>() {
        var a float64 = -0.0
        var b float64 = math.NaN()
        var c float64 = -math.NaN()
        var d float64 = math.Inf(1)
        var e float64 = math.Inf(-1)
&nbsp;
        var jsonOutput []byte
        var err error
&nbsp;
        jsonOutput, err = json.Marshal(a)
        fmt.Println(err, string(jsonOutput))
&nbsp;
        jsonOutput, err = json.Marshal(b)
        fmt.Println(err, string(jsonOutput))
&nbsp;
        jsonOutput, err = json.Marshal(c)
        fmt.Println(err, string(jsonOutput))
&nbsp;
        jsonOutput, err = json.Marshal(d)
        fmt.Println(err, string(jsonOutput))
&nbsp;
        jsonOutput, err = json.Marshal(e)
        fmt.Println(err, string(jsonOutput))
}
</pre>

<p>Nyní již bude po spuštění příkladu patrné, že došlo k&nbsp;chybám při
serializaci speciálních hodnot:</p>

<pre>
<nil> 0
json: unsupported value: NaN 
json: unsupported value: NaN 
json: unsupported value: +Inf 
json: unsupported value: -Inf 
</pre>

<p>Ještě si ukažme, jakým způsobem je možné do JSONu uložit pole s&nbsp;prvky
různých typů, včetně dvojrozměrných polí (což v&nbsp;JSONu není nic jiného, než
pole polí):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/json"
        "fmt"
)
&nbsp;
func <strong>main</strong>() {
        var a1 [10]byte
        var a2 [10]int32
        a3 := [10]int32{1, 10, 2, 9, 3, 8, 4, 7, 5, 6}
        a4 := []string{"www", "root", "cz"}
        a5 := []interface{}{1, "root", 3.1415, true, []int{1, 2, 3, 4}}
        matice := [4][3]float32{
                {1, 2, 3},
                {4, 5, 6},
                {7, 8, 9},
                {0, -1, 0},
        }
&nbsp;
        a1_json, _ := json.Marshal(a1)
        fmt.Println(string(a1_json))
&nbsp;
        a2_json, _ := json.Marshal(a2)
        fmt.Println(string(a2_json))
&nbsp;
        a3_json, _ := json.Marshal(a3)
        fmt.Println(string(a3_json))
&nbsp;
        a4_json, _ := json.Marshal(a4)
        fmt.Println(string(a4_json))
&nbsp;
        a5_json, _ := json.Marshal(a5)
        fmt.Println(string(a5_json))
&nbsp;
        matice_json, _ := json.Marshal(matice)
        fmt.Println(string(matice_json))
}
</pre>

<p>Výsledky budou vypadat následovně:</p>

<pre>
[0,0,0,0,0,0,0,0,0,0]
[0,0,0,0,0,0,0,0,0,0]
[1,10,2,9,3,8,4,7,5,6]
["www","root","cz"]
[1,"root",3.1415,true,[1,2,3,4]]
[[1,2,3],[4,5,6],[7,8,9],[0,-1,0]]
</pre>

<p><div class="rs-tip-major">Poznámka: zajímavé je především pole
(resp.&nbsp;přesněji řečeno řez s&nbsp;pohledem na pole) <strong>a5</strong>,
protože tato datová struktura může obsahovat libovolnou hodnotu programovacího
jazyka Go, a to z&nbsp;toho důvodu, že prázdné rozhraní (bez signatur metod) je
implementováno jakýmkoli datovým typem.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Serializace dat do formátu XML</h2>

<p>Ve druhé části článku si ukážeme způsoby serializace dat (tedy prakticky
libovolné datové struktury) do formátu XML. Zcela nejjednodušší demonstrační
příklad, v&nbsp;němž se pokusíme serializovat hodnoty typu
<strong>User1</strong> a <strong>User2</strong>, bude vypadat následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/xml"
        "fmt"
)
&nbsp;
type <strong>User1</strong> struct {
        id      uint32
        name    string
        surname string
}
&nbsp;
type <strong>User2</strong> struct {
        Id      uint32
        Name    string
        Surname string
}
&nbsp;
func <strong>main</strong>() {
        user1 := User1{
                1,
                "Pepek",
                "Vyskoč"}
&nbsp;
        user2 := User2{
                1,
                "Pepek",
                "Vyskoč"}
&nbsp;
        user1asXML, _ := xml.Marshal(user1)
        fmt.Println(string(user1asXML))
&nbsp;
        fmt.Println()
&nbsp;
        user2asXML, _ := xml.Marshal(user2)
        fmt.Println(string(user2asXML))
}
</pre>

<p>Podívejme se nyní na výsledek běhu tohoto příkladu:</p>

<pre>
&lt;User1&gt;&lt;/User1&gt;
&nbsp;
&lt;User2&gt;&lt;Id&gt;1&lt;/Id&gt;&lt;Name&gt;Pepek&lt;/Name&gt;&lt;Surname&gt;Vyskoč&lt;/Surname&gt;&lt;/User2&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že první XML obsahuje
pouze prázdný kořenový uzel, což je možná na první pohled podivné, neboť datová
struktura evidentně obsahuje trojici prvků. Ovšem jména těchto prvků začínají
malými písmeny a proto jsou považována za lokální.</div></p>

<p>Podobně jako při exportu do JSONu lze i při exportu do formátu XML
specifikovat jména uzlů (v&nbsp;JSONu jména atributů, tedy klíče). Slouží
k&nbsp;tomu speciálně naformátované řetězce přidané k&nbsp;jednotlivým prvkům a
začínající prefixem &bdquo;xml:&ldquo;. Celý příklad si tedy nepatrně upravíme
následujícím způsobem:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/xml"
        "fmt"
)
&nbsp;
type <strong>User1</strong> struct {
        id      uint32 `xml:"id"`
        name    string `xml:"user_name"`
        surname string `xml:"surname"`
}
&nbsp;
type <strong>User2</strong> struct {
        Id      uint32 `xml:"id"`
        Name    string `xml:"user_name"`
        Surname string `xml:"surname"`
}
&nbsp;
func <strong>main</strong>() {
        user1 := User1{
                1,
                "Pepek",
                "Vyskoč"}
&nbsp;
        user2 := User2{
                1,
                "Pepek",
                "Vyskoč"}
&nbsp;
        user1asXML, _ := xml.Marshal(user1)
        fmt.Println(string(user1asXML))
&nbsp;
        fmt.Println()
&nbsp;
        user2asXML, _ := xml.Marshal(user2)
        fmt.Println(string(user2asXML))
}
</pre>

<p>Výsledek běhu takto upraveného příkladu:</p>

<pre>
&lt;User1&gt;&lt;/User1&gt;
&nbsp;
&lt;User2&gt;&lt;id&gt;1&lt;/id&gt;&lt;user_name&gt;Pepek&lt;/user_name&gt;&lt;surname&gt;Vyskoč&lt;/surname&gt;&lt;/User2&gt;
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Specifikace jména kořenového uzlu, konfigurace odsazení při formátování XML</h2>

<p>Na rozdíl od formátu JSON, v&nbsp;němž neexistuje koncept kořenového uzlu
(přenáší se jen hodnota jediného objektu, nikoli i jeho název), je v&nbsp;XML
použit právě kořenový uzel. V&nbsp;předchozích příkladech bylo jméno tohoto
uzlu odvozeno od jména serializované datové struktury (<strong>User1</strong>
nebo <strong>User2</strong>), což ovšem nemusí být ve všech případech
vyhovující. Ovšem relativně snadno je možné tento nedostatek napravit, a to
následujícím způsobem &ndash; použitím nového prvku typu
<strong>xml.Name</strong> se specifikovaným jménem. Upravený a vylepšený
demonstrační příklad vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/xml"
        "fmt"
)
&nbsp;
type <strong>User1</strong> struct {
        XMLName xml.Name `xml:"user"`
        id      uint32   `xml:"id"`
        name    string   `xml:"user_name"`
        surname string   `xml:"surname"`
}
&nbsp;
type <strong>User2</strong> struct {
        XMLName xml.Name `xml:"user"`
        Id      uint32   `xml:"id"`
        Name    string   `xml:"user_name"`
        Surname string   `xml:"surname"`
}
&nbsp;
func <strong>main</strong>() {
        user1 := User1{
                id:      1,
                name:    "Pepek",
                surname: "Vyskoč"}
&nbsp;
        user2 := User2{
                Id:      1,
                Name:    "Pepek",
                Surname: "Vyskoč"}
&nbsp;
        user1asXML, _ := xml.Marshal(user1)
        fmt.Println(string(user1asXML))
&nbsp;
        fmt.Println()
&nbsp;
        user2asXML, _ := xml.Marshal(user2)
        fmt.Println(string(user2asXML))
}
</pre>

<p>Tento příklad si samozřejmě spustíme. Z&nbsp;výsledku je patrné, že se
skutečně změnilo i jméno kořenového uzlu:</p>

<pre>
&lt;user&gt;&lt;/user&gt;
&nbsp;
&lt;user&gt;&lt;id&gt;1&lt;/id&gt;&lt;user_name&gt;Pepek&lt;/user_name&gt;&lt;surname&gt;Vyskoč&lt;/surname&gt;&lt;/user&gt;
</pre>

<p>V&nbsp;některých případech je požadováno, aby výsledné XML bylo korektně
naformátováno, což se hodí zejména při práci s&nbsp;relativně krátkými
konfiguračními soubory atd. Naformátování výsledného XML zajišťuje metoda
nazvaná <strong>MarshalIndent</strong>, které se navíc předá prefix všech řádků
(může se jednat o prázdný řetězec) a libovolná sekvence znaků použitá při
odsazování vnořených uzlů. Zde můžeme použít například čtyři mezery, znak Tab
atd.:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/xml"
        "fmt"
)
&nbsp;
type <strong>User1</strong> struct {
        XMLName xml.Name `xml:"user"`
        id      uint32   `xml:"id"`
        name    string   `xml:"user_name"`
        surname string   `xml:"surname"`
}
&nbsp;
type <strong>User2</strong> struct {
        XMLName xml.Name `xml:"user"`
        Id      uint32   `xml:"id"`
        Name    string   `xml:"user_name"`
        Surname string   `xml:"surname"`
}
&nbsp;
func <strong>main</strong>() {
        user1 := User1{
                id:      1,
                name:    "Pepek",
                surname: "Vyskoč"}
&nbsp;
        user2 := User2{
                Id:      1,
                Name:    "Pepek",
                Surname: "Vyskoč"}
&nbsp;
        user1asXML, _ := xml.MarshalIndent(user1, "", "    ")
        fmt.Println(string(user1asXML))
&nbsp;
        fmt.Println()
&nbsp;
        user2asXML, _ := xml.MarshalIndent(user2, "", "    ")
        fmt.Println(string(user2asXML))
&nbsp;
        fmt.Println()
&nbsp;
        user2asXML, _ = xml.MarshalIndent(user2, "", "\t")
        fmt.Println(string(user2asXML))
&nbsp;
        fmt.Println()
&nbsp;
        user2asXML, _ = xml.MarshalIndent(user2, "\t", "\t")
        fmt.Println(string(user2asXML))
}
</pre>

<p>Zde nás bude zajímat vygenerovaný výsledek, který má tvar:</p>

<pre>
&lt;user&gt;&lt;/user&gt;
&nbsp;
&lt;user&gt;
    &lt;id&gt;1&lt;/id&gt;
    &lt;user_name&gt;Pepek&lt;/user_name&gt;
    &lt;surname&gt;Vyskoč&lt;/surname&gt;
&lt;/user&gt;
&nbsp;
&lt;user&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;user_name&gt;Pepek&lt;/user_name&gt;
        &lt;surname&gt;Vyskoč&lt;/surname&gt;
&lt;/user&gt;
&nbsp;
        &lt;user&gt;
                &lt;id&gt;1&lt;/id&gt;
                &lt;user_name&gt;Pepek&lt;/user_name&gt;
                &lt;surname&gt;Vyskoč&lt;/surname&gt;
        &lt;/user&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si vlivu prefixu
v&nbsp;posledním případě. Tento trik lze použít při ručním spojování více XML
pod jeden kořenový uzel.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Struktura XML odlišná od struktury původních serializovaných dat</h2>

<p>Při serializaci datových struktur do formátu XML je možné zvolit odlišnou
strukturu výsledného souboru. Pokud například namísto následující
struktury:</p>

<pre>
&lt;user&gt;
    &lt;id&gt;1&lt;/id&gt;
    &lt;user_name&gt;Pepek&lt;/user_name&gt;
    &lt;surname&gt;Vyskoč&lt;/surname&gt;
&lt;/user&gt;
</pre>

<p>Budeme požadovat, aby výsledný soubor XML vypadal odlišně &ndash; jméno a
příjmení má být ve zvláštním poduzlu:</p>

<pre>
&lt;user&gt;
    &lt;id&gt;1&lt;/id&gt;
    &lt;name&gt;
        &lt;first&gt;Pepek&lt;/first&gt;
        &lt;last&gt;Vyskoč&lt;/last&gt;
    &lt;/name&gt;
&lt;/user&gt;
</pre>

<p>Tohoto chování lze docílit odlišnou specifikací dekorátoru, který je zapsaný
za každou datovou položkou, která má být serializována:</p>

<pre>
type <strong>User2</strong> struct {
        XMLName xml.Name `xml:"user"`
        Id      uint32   `xml:"id"`
        Name    string   `xml:"name&gt;first"`
        Surname string   `xml:"name&gt;last"`
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si způsobu zápisu &ndash;
určujeme nový uzel &bdquo;name&ldquo;, v&nbsp;němž se mají vytvořit poduzly
&bdquo;first&ldquo; a &bdquo;last&ldquo;.</div></p>

<p>Upravený zdrojový kód tohoto demonstračního příkladu vypadá takto:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/xml"
        "fmt"
)
&nbsp;
type <strong>User1</strong> struct {
        XMLName xml.Name `xml:"user"`
        id      uint32   `xml:"id"`
        name    string   `xml:"name&gt;first"`
        surname string   `xml:"name&gt;last"`
}
&nbsp;
type <strong>User2</strong> struct {
        XMLName xml.Name `xml:"user"`
        Id      uint32   `xml:"id"`
        Name    string   `xml:"name&gt;first"`
        Surname string   `xml:"name&gt;last"`
}
&nbsp;
func <strong>main</strong>() {
        user1 := User1{
                id:      1,
                name:    "Pepek",
                surname: "Vyskoč"}
&nbsp;
        user2 := User2{
                Id:      1,
                Name:    "Pepek",
                Surname: "Vyskoč"}
&nbsp;
        user1asXML, _ := xml.MarshalIndent(user1, "", "    ")
        fmt.Println(string(user1asXML))
&nbsp;
        fmt.Println()
&nbsp;
        user2asXML, _ := xml.MarshalIndent(user2, "", "    ")
        fmt.Println(string(user2asXML))
&nbsp;
        fmt.Println()
&nbsp;
        user2asXML, _ = xml.MarshalIndent(user2, "", "\t")
        fmt.Println(string(user2asXML))
&nbsp;
        fmt.Println()
&nbsp;
        user2asXML, _ = xml.MarshalIndent(user2, "\t", "\t")
        fmt.Println(string(user2asXML))
}
</pre>

<p>Výsledek běhu příkladu (všechny varianty formátování):</p>

<pre>
&lt;user&gt;&lt;/user&gt;
&nbsp;
&lt;user&gt;
    &lt;id&gt;1&lt;/id&gt;
    &lt;name&gt;
        &lt;first&gt;Pepek&lt;/first&gt;
        &lt;last&gt;Vyskoč&lt;/last&gt;
    &lt;/name&gt;
&lt;/user&gt;
&nbsp;
&lt;user&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;name&gt;
                &lt;first&gt;Pepek&lt;/first&gt;
                &lt;last&gt;Vyskoč&lt;/last&gt;
        &lt;/name&gt;
&lt;/user&gt;
&nbsp;
        &lt;user&gt;
                &lt;id&gt;1&lt;/id&gt;
                &lt;name&gt;
                        &lt;first&gt;Pepek&lt;/first&gt;
                        &lt;last&gt;Vyskoč&lt;/last&gt;
                &lt;/name&gt;
        &lt;/user&gt;
</pre>

<p>Pochopitelně je možné určit, které hodnoty mají být uloženy ve formě
pojmenovaných atributů. Podívejme se na následující demonstrační příklad:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/xml"
        "fmt"
)
&nbsp;
type <strong>User1</strong> struct {
        XMLName xml.Name `xml:"user"`
        id      uint32   `xml:"id,attr"`
        name    string   `xml:"name&amp;first,attr"`
        surname string   `xml:"name&amp;last,attr"`
}
&nbsp;
type <strong>User2</strong> struct {
        XMLName xml.Name `xml:"user"`
        Id      uint32   `xml:"id,attr"`
        Name    string   `xml:"name&amp;first"`
        Surname string   `xml:"name&amp;last"`
}
&nbsp;
func <strong>main</strong>() {
        user1 := User1{
                id:      1,
                name:    "Pepek",
                surname: "Vyskoč"}
&nbsp;
        user2 := User2{
                Id:      1,
                Name:    "Pepek",
                Surname: "Vyskoč"}

        user1asXML, _ := xml.MarshalIndent(user1, "", "    ")
        fmt.Println(string(user1asXML))
&nbsp;
        fmt.Println()
&nbsp;
        user2asXML, _ := xml.MarshalIndent(user2, "", "    ")
        fmt.Println(string(user2asXML))
&nbsp;
        fmt.Println()
&nbsp;
        user2asXML, _ = xml.MarshalIndent(user2, "", "\t")
        fmt.Println(string(user2asXML))
&nbsp;
        fmt.Println()
&nbsp;
        user2asXML, _ = xml.MarshalIndent(user2, "\t", "\t")
        fmt.Println(string(user2asXML))
}
</pre>

<p>Výsledek:</p>

<pre>
&lt;user&gt;&lt;/user&gt;
&nbsp;
&lt;user id="1"&gt;
    &lt;name&gt;
        &lt;first&gt;Pepek&lt;/first&gt;
        &lt;last&gt;Vyskoč&lt;/last&gt;
    &lt;/name&gt;
&lt;/user&gt;
&nbsp;
&lt;user id="1"&gt;
        &lt;name&gt;
                &lt;first&gt;Pepek&lt;/first&gt;
                &lt;last&gt;Vyskoč&lt;/last&gt;
        &lt;/name&gt;
&lt;/user&gt;
&nbsp;
        &lt;user id="1"&gt;
                &lt;name&gt;
                        &lt;first&gt;Pepek&lt;/first&gt;
                        &lt;last&gt;Vyskoč&lt;/last&gt;
                &lt;/name&gt;
        &lt;/user&gt;
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Serializace polí, speciální hodnoty, ukazatele apod.</h2>

<p>Pro úplnost se ještě podívejme na způsob serializace polí. Následující
demonstrační příklad vypadá podobně, jako již výše uvedený příklad na
serializaci do formátu JSON, pouze se provede uložení do souboru ve formátu
XML:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/xml"
        "fmt"
)
&nbsp;
func <strong>main</strong>() {
        var a1 [10]byte
        var a2 [10]int32
        a3 := [10]int32{1, 10, 2, 9, 3, 8, 4, 7, 5, 6}
        a4 := []string{"www", "root", "cz"}
        a5 := []interface{}{1, "root", 3.1415, true, []int{1, 2, 3, 4}}
        matice := [4][3]float32{
                {1, 2, 3},
                {4, 5, 6},
                {7, 8, 9},
                {0, -1, 0},
        }
&nbsp;
        a1asXML, _ := xml.Marshal(a1)
        fmt.Println(string(a1asXML))
&nbsp;
        a2asXML, _ := xml.Marshal(a2)
        fmt.Println(string(a2asXML))
&nbsp;
        a3asXML, _ := xml.Marshal(a3)
        fmt.Println(string(a3asXML))
&nbsp;
        a4asXML, _ := xml.Marshal(a4)
        fmt.Println(string(a4asXML))
&nbsp;
        a5asXML, _ := xml.Marshal(a5)
        fmt.Println(string(a5asXML))
&nbsp;
        maticeasXML, _ := xml.Marshal(matice)
        fmt.Println(string(maticeasXML))
}
</pre>

<p>U polí jsme nijak nespecifikovali jména prvků, takže výsledné XML použije
jména použitých datových typů (což je většinou v&nbsp;praxi zcela
nepoužitelné):</p>

<pre>
&lt;int32&gt;0&lt;/int32&gt;&lt;int32&gt;0&lt;/int32&gt;&lt;int32&gt;0&lt;/int32&gt;&lt;int32&gt;0&lt;/int32&gt;&lt;int32&gt;0&lt;/int32&gt;&lt;int32&gt;0&lt;/int32&gt;&lt;int32&gt;0&lt;/int32&gt;&lt;int32&gt;0&lt;/int32&gt;&lt;int32&gt;0&lt;/int32&gt;&lt;int32&gt;0&lt;/int32&gt;
&lt;int32&gt;1&lt;/int32&gt;&lt;int32&gt;10&lt;/int32&gt;&lt;int32&gt;2&lt;/int32&gt;&lt;int32&gt;9&lt;/int32&gt;&lt;int32&gt;3&lt;/int32&gt;&lt;int32&gt;8&lt;/int32&gt;&lt;int32&gt;4&lt;/int32&gt;&lt;int32&gt;7&lt;/int32&gt;&lt;int32&gt;5&lt;/int32&gt;&lt;int32&gt;6&lt;/int32&gt;
&lt;string&gt;www&lt;/string&gt;&lt;string&gt;root&lt;/string&gt;&lt;string&gt;cz&lt;/string&gt;
&lt;int&gt;1&lt;/int&gt;&lt;string&gt;root&lt;/string&gt;&lt;float64&gt;3.1415&lt;/float64&gt;&lt;bool&gt;true&lt;/bool&gt;&lt;int&gt;1&lt;/int&gt;&lt;int&gt;2&lt;/int&gt;&lt;int&gt;3&lt;/int&gt;&lt;int&gt;4&lt;/int&gt;
&lt;float32&gt;1&lt;/float32&gt;&lt;float32&gt;2&lt;/float32&gt;&lt;float32&gt;3&lt;/float32&gt;&lt;float32&gt;4&lt;/float32&gt;&lt;float32&gt;5&lt;/float32&gt;&lt;float32&gt;6&lt;/float32&gt;&lt;float32&gt;7&lt;/float32&gt;&lt;float32&gt;8&lt;/float32&gt;&lt;float32&gt;9&lt;/float32&gt;&lt;float32&gt;0&lt;/float32&gt;&lt;float32&gt;-1&lt;/float32&gt;&lt;float32&gt;0&lt;/float32&gt;
</pre>

<p>Dále se pokusme zjistit, zda a jak vůbec je možné do XML serializovat
speciální numerické hodnoty, s&nbsp;nimiž jsme se již seznámili
v&nbsp;souvislosti s&nbsp;formátem JSON, tedy nekonečna a NaN. Kromě toho nás
bude zajímat práce s&nbsp;ukazateli, protože právě přes ukazatele lze tvořit
složitější datové struktury. Příklad nepatrně upravíme takovým způsobem, aby
obsahoval lineárně vázaný seznam prvků typu <strong>Foobar</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/xml"
        "fmt"
        "math"
)
&nbsp;
type <strong>Foobar</strong> struct {
        XMLName xml.Name `xml:"foobar"`
        Id      uint32   `xml:"id"`
        X       float64  `xml:"x"`
        Y       float64  `xml:"y"`
        Z       float64  `xml:"z"`
        Next    *Foobar  `xml:"foobar"`
}
&nbsp;
func <strong>main</strong>() {
        f := Foobar{
                Id:   42,
                X:    math.NaN(),
                Y:    math.Inf(1),
                Z:    math.Inf(-1),
                Next: nil}
&nbsp;
        g := Foobar{
                Id:   43,
                X:    math.NaN(),
                Y:    math.Inf(1),
                Z:    math.Inf(-1),
                Next: &amp;f}
&nbsp;
        asXML, err := xml.MarshalIndent(g, "", "    ")
        if err != nil {
                fmt.Println(err)
        } else {
                fmt.Println(string(asXML))
        }
}
</pre>

<p>Z&nbsp;výstupu &ndash; serializované struktury <strong>g</strong> &ndash; je
patrné, že z&nbsp;lineárně vázaného seznamu vznikla dvojice vnořených uzlů, což
je ostatně jeden z&nbsp;nejlepších způsobů vizualizace této datové struktury.
Dále můžeme vidět, že speciální numerické hodnoty jsou skutečně podporovány
(záleží jen na kódu pro deserializaci, jak je zpracuje):</p>

<pre>
&lt;foobar&gt;
    &lt;id&gt;43&lt;/id&gt;
    &lt;x&gt;NaN&lt;/x&gt;
    &lt;y&gt;+Inf&lt;/y&gt;
    &lt;z&gt;-Inf&lt;/z&gt;
    &lt;foobar&gt;
        &lt;id&gt;42&lt;/id&gt;
        &lt;x&gt;NaN&lt;/x&gt;
        &lt;y&gt;+Inf&lt;/y&gt;
        &lt;z&gt;-Inf&lt;/z&gt;
    &lt;/foobar&gt;
&lt;/foobar&gt;
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Serializace sekvence struktur</h2>

<p>Velmi často se setkáme s&nbsp;požadavkem na serializaci sekvence nějaké
datové struktury. Představme si například seznam uživatelů. Přímé uložení pole
je problematické, protože výsledek není validním XML:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/xml"
        "fmt"
)
&nbsp;
type <strong>User</strong> struct {
        XMLName xml.Name `xml:"user"`
        Id      uint32   `xml:"id"`
        Name    string   `xml:"user_name"`
        Surname string   `xml:"surname"`
}
&nbsp;
func <strong>main</strong>() {
        var users = [3]User{
                User{
                        Id:      1,
                        Name:    "Pepek",
                        Surname: "Vyskoč"},
                User{
                        Id:      2,
                        Name:    "Pepek",
                        Surname: "Vyskoč"},
                User{
                        Id:      3,
                        Name:    "Josef",
                        Surname: "Vyskočil"},
        }
&nbsp;
        usersAsXML, _ := xml.MarshalIndent(users, "", "    ")
        fmt.Println(string(usersAsXML))
}
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
&lt;user&gt;
    &lt;id&gt;1&lt;/id&gt;
    &lt;user_name&gt;Pepek&lt;/user_name&gt;
    &lt;surname&gt;Vyskoč&lt;/surname&gt;
&lt;/user&gt;
&lt;user&gt;
    &lt;id&gt;2&lt;/id&gt;
    &lt;user_name&gt;Pepek&lt;/user_name&gt;
    &lt;surname&gt;Vyskoč&lt;/surname&gt;
&lt;/user&gt;
&lt;user&gt;
    &lt;id&gt;3&lt;/id&gt;
    &lt;user_name&gt;Josef&lt;/user_name&gt;
    &lt;surname&gt;Vyskočil&lt;/surname&gt;
&lt;/user&gt;
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Obalení sekvence struktur dalším datovým typem</h2>

<p>V&nbsp;takovém případě bývá nejjednodušší obalit celou strukturu jinou
strukturou, která bude obsahovat pouze specifikaci kořenového uzlu a vlastní
sekvenci. Zde je navíc kořenový uzel pojmenován:</p>

<pre>
type <strong>Users</strong> struct {
        XMLName xml.Name `xml:"users"`
        List    []User
}
</pre>

<p>Úplný kód příkladu, v&nbsp;němž serializujeme několik uživatelů do formátu
XML, vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/xml"
        "fmt"
)
&nbsp;
type <strong>User</strong> struct {
        Id      uint32 `xml:"id"`
        Name    string `xml:"user_name"`
        Surname string `xml:"surname"`
}
&nbsp;
type <strong>Users</strong> struct {
        XMLName xml.Name `xml:"users"`
        List    []User
}
&nbsp;
func <strong>main</strong>() {
        var users Users = Users{
                List: []User{
                        User{
                                Id:      1,
                                Name:    "Pepek",
                                Surname: "Vyskoč"},
                        User{
                                Id:      2,
                                Name:    "Pepek",
                                Surname: "Vyskoč"},
                        User{
                                Id:      3,
                                Name:    "Josef",
                                Surname: "Vyskočil"},
                },
        }
&nbsp;
        usersAsXML, _ := xml.MarshalIndent(users, "", "    ")
        fmt.Println(string(usersAsXML))
}
</pre>

<p>Výsledek je již mnohem lepší:</p>

<pre>
&lt;users&gt;
    &lt;List&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;user_name&gt;Pepek&lt;/user_name&gt;
        &lt;surname&gt;Vyskoč&lt;/surname&gt;
    &lt;/List&gt;
    &lt;List&gt;
        &lt;id&gt;2&lt;/id&gt;
        &lt;user_name&gt;Pepek&lt;/user_name&gt;
        &lt;surname&gt;Vyskoč&lt;/surname&gt;
    &lt;/List&gt;
    &lt;List&gt;
        &lt;id&gt;3&lt;/id&gt;
        &lt;user_name&gt;Josef&lt;/user_name&gt;
        &lt;surname&gt;Vyskočil&lt;/surname&gt;
    &lt;/List&gt;
&lt;/users&gt;
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vylepšení předchozích příkladů</h2>

<p>Specifikaci jména opakujícího se uzlu (<strong>User</strong>) lze
pochopitelně k&nbsp;této datové struktuře přidat:</p>

<pre>
type <strong>User</strong> struct {
        XMLName xml.Name `xml:"user"`
        Id      uint32   `xml:"id"`
        Name    string   `xml:"user_name"`
        Surname string   `xml:"surname"`
}
</pre>

<p>Potom se kořenový uzel nezmění:</p>

<pre>
type <strong>User</strong>s struct {
        XMLName xml.Name `xml:"users"`
        List    []User
}
</pre>

<p>Můžeme ovšem postupovat i opačně a ponechat původní strukturu
<strong>User</strong> bez uvedení jména uzlu:</p>

<pre>
type <strong>User</strong> struct {
        Id      uint32 `xml:"id"`
        Name    string `xml:"user_name"`
        Surname string `xml:"surname"`
}
</pre>

<p>V&nbsp;tomto případě je vhodnější jméno poduzlů specifikovat v&nbsp;datové
struktuře představující kořenový uzel:</p>

<pre>
type <strong>User</strong>s struct {
        XMLName xml.Name `xml:"users"`
        List    []User   `xml:"user"`
}
</pre>

<p>Jen pro úplnost si obě varianty ukažme na úplném zdrojovém kódu.</p>

<p>První varianta:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/xml"
        "fmt"
)
&nbsp;
type <strong>User</strong> struct {
        XMLName xml.Name `xml:"user"`
        Id      uint32   `xml:"id"`
        Name    string   `xml:"user_name"`
        Surname string   `xml:"surname"`
}
&nbsp;
type <strong>User</strong>s struct {
        XMLName xml.Name `xml:"users"`
        List    []User
}
&nbsp;
func <strong>main</strong>() {
        var users Users = Users{
                List: []User{
                        User{
                                Id:      1,
                                Name:    "Pepek",
                                Surname: "Vyskoč"},
                        User{
                                Id:      2,
                                Name:    "Pepek",
                                Surname: "Vyskoč"},
                        User{
                                Id:      3,
                                Name:    "Josef",
                                Surname: "Vyskočil"},
                },
        }
&nbsp;
        usersAsXML, _ := xml.MarshalIndent(users, "", "    ")
        fmt.Println(string(usersAsXML))
}
</pre>

<p>Druhá varianta:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/xml"
        "fmt"
)
&nbsp;
type <strong>User</strong> struct {
        Id      uint32 `xml:"id"`
        Name    string `xml:"user_name"`
        Surname string `xml:"surname"`
}
&nbsp;
type <strong>User</strong>s struct {
        XMLName xml.Name `xml:"users"`
        List    []User   `xml:"user"`
}
&nbsp;
func <strong>main</strong>() {
        var users Users = Users{
                List: []User{
                        User{
                                Id:      1,
                                Name:    "Pepek",
                                Surname: "Vyskoč"},
                        User{
                                Id:      2,
                                Name:    "Pepek",
                                Surname: "Vyskoč"},
                        User{
                                Id:      3,
                                Name:    "Josef",
                                Surname: "Vyskočil"},
                },
        }
&nbsp;
        usersAsXML, _ := xml.MarshalIndent(users, "", "    ")
        fmt.Println(string(usersAsXML))
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Serializace jedné struktury jak do JSONu, tak i do XML &ndash; problematika anotačních řetězců</h2>

<p>Z&nbsp;předchozího textu již víme, jak lze specifikovat formát uložení
nějaké datové struktury do formátu JSON i do formátu XML. Ovšem
v&nbsp;některých případech je vyžadováno, aby se stejná struktura serializovala
i deserializovala do obou těchto formátů. I takového chování je pochopitelně
možné docílit, a to navíc poměrně jednoduše &ndash; pouze se v&nbsp;anotačním
řetězci specifikuje název uzlu v&nbsp;XML a současně i jméno atributu ve
formátu JSON:</p>

<pre>
type <strong>User</strong> struct {
        XMLName xml.Name `xml:"user" json:"-"`
        Id      uint32   `xml:"id" json:"user_id"`
        Name    string   `xml:"name&gt;first" json:"user_name"`
        Surname string   `xml:"name&gt;last" json:"surname"`
}
</pre>

<p>Úplný zdrojový kód takto upraveného demonstračního příkladu může vypadat
následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/json"
        "encoding/xml"
        "fmt"
)
&nbsp;
type <strong>User</strong> struct {
        XMLName xml.Name `xml:"user" json:"-"`
        Id      uint32   `xml:"id" json:"user_id"`
        Name    string   `xml:"name&gt;first" json:"user_name"`
        Surname string   `xml:"name&gt;last" json:"surname"`
}
&nbsp;
func <strong>main</strong>() {
        user := User{
                Id:      1,
                Name:    "Pepek",
                Surname: "Vyskoč"}
&nbsp;
        userAsXML, _ := xml.MarshalIndent(user, "", "    ")
        fmt.Println(string(userAsXML))
&nbsp;
        fmt.Println()
&nbsp;
        userAsJSON, _ := json.Marshal(user)
        fmt.Println(string(userAsJSON))
}
</pre>

<p>Výsledky jsou očekávané:</p>

<pre>
&lt;user&gt;
    &lt;id&gt;1&lt;/id&gt;
    &lt;name&gt;
        &lt;first&gt;Pepek&lt;/first&gt;
        &lt;last&gt;Vyskoč&lt;/last&gt;
    &lt;/name&gt;
&lt;/user&gt;
&nbsp;
{"user_id":1,"user_name":"Pepek","surname":"Vyskoč"}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Binární formáty a programovací jazyk Go</h2>

<p>I přesto, že se s&nbsp;výše uvedenými formáty JSON a XML setkáme prakticky
ve všech oblastech moderního IT, nemusí se vždy jednat o nejlepší možné řešení
problému přenosu strukturovaných dat. Tyto formáty totiž data neukládají
v&nbsp;kompaktní binární podobě a navíc je parsing numerických hodnot relativně
zdlouhavý, což se projevuje zejména tehdy, pokud je nutné zpracovat skutečně
obrovské množství dat (buď mnoho malých zpráv či událostí, nebo naopak rozsáhlé
datové soubory). A právě v&nbsp;těchto situacích může být výhodnější sáhnout po
nějakém vhodném binárním formátu. Těch již dnes existuje velké množství, od
staršího a dosti těžkopádného ASN.1 (<i>Abstract Syntax Notation One</i>) po
formáty, které se snaží napodobit některé vlastnosti JSONu. Příkladem může být
formát <i>CBOR</i>, jenž je podporován knihovnou <a
href="https://github.com/fxamacker/cbor">https://github.com/fxamacker/cbor</a>,
popř.&nbsp;formát <i>BSON</i>, pro který pochopitelně taktéž existuje varianta
pro Go. A konečně, ve světě Go se setkáme i s&nbsp;formátem nazvaným gob (<i>Go
Objects</i>).</p>

<p><div class="rs-tip-major">Poznámka: dnes se seznámíme pouze se základním
použitím výše zmíněných binárních formátů, podrobnější popis i mnoho dalších
demonstračních příkladů bude uvedeno až příště.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Formát gob</h2>

<p>Prvním binárním formátem, s&nbsp;nímž se setkáme, je formát nazvaný
<i>gob</i> neboli <i>Go Objects</i>. Jedná se o formát určený primárně pro
použití v&nbsp;programovacím jazyku Go, což znamená, že jeho využití je
relativně specifické (ukládání rozsáhlých dat, komunikace mezi dvojicí služeb
naprogramovaných v&nbsp;Go atd.). Tento formát umožňuje serializaci prakticky
jakékoli datové struktury, ovšem je ho možné použít i pro primitivní datové
typy, resp.&nbsp;pro jejich hodnoty. To si ostatně ukážeme v&nbsp;dalším
příkladu, v&nbsp;němž jsou serializovaná data zobrazena ve formě sekvence
hexadecimálních hodnot:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "encoding/gob"
        "encoding/hex"
        "fmt"
)
&nbsp;
func <strong>main</strong>() {
        var a bool = true
&nbsp;
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
&nbsp;
        err := encoder.Encode(a)
        if err != nil {
                fmt.Println(err)
        } else {
                content := buffer.Bytes()
                fmt.Printf("Encoded into %d bytes\n", len(content))
                encoded := hex.EncodeToString(content)
                fmt.Println(encoded)
        }
}
</pre>

<p>Výsledkem je:</p>

<pre>
Encoded into 4 bytes
03020001
</pre>

<p>Formát je v&nbsp;tomto případě jednoduchý:</p>

<ol>
<li>Délka dat (bez prvního bajtu)</li>
<li>Typ dat</li>
<li>Pozice prvku ve fiktivní struktuře (zde 0=první prvek)</li>
<li>Hodnota (true se převádí na 1)</li>
</ol>



<p><a name="k15"></a></p>
<h2 id="k15">15. Serializace datové struktury do formátu gob</h2>

<p>Do formátu <i>gob</i> lze uložit prakticky jakoukoli datovou strukturu, což
se samozřejmě týká i uživatelsky definovaných struktur. Pokusme se tedy uložit
obsah struktury typu <strong>User</strong>. V&nbsp;tomto případě se neuloží
pouze vlastní data, ale i základní formát této struktury, což později usnadní
deserializaci:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "encoding/gob"
        "encoding/hex"
        "fmt"
)
&nbsp;
type <strong>User</strong> struct {
        Id      uint32
        Name    string
        Surname string
}
&nbsp;
func <strong>main</strong>() {
        user := User{
                1,
                "Pepek",
                "Vyskoč"}
&nbsp;
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
&nbsp;
        err := encoder.Encode(user)
        if err != nil {
                fmt.Println(err)
        } else {
                content := buffer.Bytes()
                fmt.Printf("Encoded into %d bytes\n", len(content))
                encoded := hex.EncodeToString(content)
                fmt.Println(encoded)
        }
}
</pre>

<p>Popis struktury <strong>User</strong> i její obsah se uloží do sekvence 69
bajtů, což je poměrně mnoho, ovšem na rozdíl od JSONu jsou přeneseny i datové
typy apod.:</p>

<pre>
Encoded into 69 bytes
2eff81030101045573657201ff820001030102496401060001044e616d65010c0001075375726e616d65010c00000015ff8201010105506570656b01075679736b6fc48d00
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Formát CBOR (Concise Binary Object Representation)</h2>

<p>Jedním z&nbsp;binárních formátů určených pro přenos prakticky libovolně
strukturovaných dat je formát nazvaný <i>CBOR</i> neboli plným jménem
<i>Concise Binary Object Representation</i>. Tímto formátem, jenž se snaží
nabízet podobné vlastnosti jako JSON (až na možnost jeho přímého čtení
člověkem), se budeme podrobněji zabývat v&nbsp;navazující části tohoto seriálu,
takže si prozatím jen ukažme jeden příklad, jenž používá knihovnu dostupnou na
adrese <a href="github.com/fxamacker/cbor/v2">github.com/fxamacker/cbor/v2</a>
(tu lze nainstalovat běžným způsobem, ovšem pozor &ndash; vyžaduje Go 1.13 či
novější). V&nbsp;příkladu je ukázána serializace jediné hodnoty, konkrétně
pravdivostní hodnoty nastavené na hodnotu <strong>true</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/fxamacker/cbor/v2"
)
&nbsp;
func <strong>main</strong>() {
        var a bool = true
&nbsp;
        var jsonOutput []byte
&nbsp;
        cborOutput, _ = cbor.Marshal(a)
        fmt.Println(string(cborOutput))
}
</pre>

<p><div class="rs-tip-major">Poznámka: zajímavé je, že tento formát podporuje i
numerické hodnoty typu <i>half float</i>, s&nbsp;nimiž jsme se setkali <a
href="https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/">v&nbsp;článku
o typu <i>bfloat16</i></a>.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Serializace dat do formátu BSON</h2>

<p>Dalším sice relativně novým, ale rozšiřujícím se binárním formátem je formát
nazvaný <i>BSON</i> (zde je odkaz na JSON nesporný). Tento formát je podporován
v&nbsp;knihovně dodávané společně s&nbsp;ovladači pro MongoDB, ale lze ho
používat zcela samostatně a nezávisle. Rozhraní balíčku <strong>bson</strong>
je totožné s&nbsp;rozhraním <strong>encoding/json</strong>, takže například
serializace naší struktury <strong>User</strong> do souboru typu BSON může
vypadat následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "gopkg.in/mgo.v2/bson"
        "io/ioutil"
)
&nbsp;
type <strong>User</strong> struct {
        Id      uint32
        Name    string
        Surname string
}
&nbsp;
func <strong>main</strong>() {
        user := User{
                1,
                "Pepek",
                "Vyskoč"}
&nbsp;
        var bsonOutput []byte
&nbsp;
        bsonOutput, err := bson.Marshal(user)
        if err != nil {
                fmt.Println(err)
        } else {
                fmt.Printf("Encoded into %d bytes\n", len(bsonOutput))
                err := ioutil.WriteFile("1.bson", bsonOutput, 0644)
                if err != nil {
                        fmt.Println(err)
                } else {
                        fmt.Println("And stored into file")
                }
        }
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Deserializace dat z&nbsp;formátu BSON</h2>

<p>V&nbsp;předchozím příkladu jsme si ukázali serializaci datové struktury do
BSONu, takže nám logicky zbývá provést její zpětnou deserializaci. Postup je
velmi jednoduchý a je ukázán v&nbsp;dnešním posledním příkladu. Prozatím si
ukazujeme pouze &bdquo;happy path&ldquo;, tj.&nbsp;situaci, kdy je
deserializace úspěšná, ale příště se budeme zabývat i složitějšími stavy, které
mohou v&nbsp;praxi nastat:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "gopkg.in/mgo.v2/bson"
        "io/ioutil"
)
&nbsp;
type <strong>User</strong> struct {
        Id      uint32
        Name    string
        Surname string
}
&nbsp;
func <strong>main</strong>() {
        var user User
&nbsp;
        bsonInput, err := ioutil.ReadFile("1.bson")
        if err != nil {
                fmt.Println(err)
                return
        }
&nbsp;
        fmt.Printf("Read %d bytes\n", len(bsonInput))
&nbsp;
        err = bson.Unmarshal(bsonInput, &amp;user)
        if err != nil {
                fmt.Println(err)
                return
        }
        fmt.Println("Deserialized value")
        fmt.Println(user)
}
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně šest až sedm megabajtů), můžete namísto toho použít odkazy na
jednotlivé demonstrační příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_json_marshal_floats.go</td><td>serializace numerických hodnot do formátu JSON</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/01_json_marshal_floats.go">https://github.com/tisnik/go-root/blob/master/article_57/01_json_marshal_floats.go</a></td></tr>
<tr><td> 2</td><td>02_json_marshal_floats_specvalues.go</td><td>serializace speciálních numerických hodnot do formátu JSON</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/02_json_marshal_floats_specvalues.go">https://github.com/tisnik/go-root/blob/master/article_57/02_json_marshal_floats_specvalues.go</a></td></tr>
<tr><td> 3</td><td>03_json_marshal_arrays.go</td><td>serializace polí (numerických hodnot) do formátu JSON</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/03_json_marshal_arrays.go">https://github.com/tisnik/go-root/blob/master/article_57/03_json_marshal_arrays.go</a></td></tr>
<tr><td> 4</td><td>04_xml_marshal_struct_1.go</td><td>serializace jednoduchých struktur do XML</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/04_xml_marshal_struct_1.go">https://github.com/tisnik/go-root/blob/master/article_57/04_xml_marshal_struct_1.go</a></td></tr>
<tr><td> 5</td><td>05_xml_marshal_struct_2.go</td><td>specifikace názvů uzlů při serializaci do XML</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/05_xml_marshal_struct_2.go">https://github.com/tisnik/go-root/blob/master/article_57/05_xml_marshal_struct_2.go</a></td></tr>
<tr><td> 6</td><td>06_xml_marshal_struct_3.go</td><td>specifikace jména kořenového uzlu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/06_xml_marshal_struct_3.go">https://github.com/tisnik/go-root/blob/master/article_57/06_xml_marshal_struct_3.go</a></td></tr>
<tr><td> 7</td><td>07_xml_marshal_struct_4_indent.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/07_xml_marshal_struct_4_indent.go">https://github.com/tisnik/go-root/blob/master/article_57/07_xml_marshal_struct_4_indent.go</a></td></tr>
<tr><td> 8</td><td>08_xml_marshal_struct_5_control.go</td><td>řízení, jak má vypadat výsledné XML</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/08_xml_marshal_struct_5_control.go">https://github.com/tisnik/go-root/blob/master/article_57/08_xml_marshal_struct_5_control.go</a></td></tr>
<tr><td> 9</td><td>09_xml_marshal_arrays.go</td><td>serializace polí</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/09_xml_marshal_arrays.go">https://github.com/tisnik/go-root/blob/master/article_57/09_xml_marshal_arrays.go</a></td></tr>
<tr><td>10</td><td>10_xml_marshal_special_types.go</td><td>serializace speciálních hodnot, použití ukazatelů</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/10_xml_marshal_special_types.go">https://github.com/tisnik/go-root/blob/master/article_57/10_xml_marshal_special_types.go</a></td></tr>
<tr><td>11</td><td>11_xml_marshal_array_of_struct_1.go</td><td>serializace sekvence struktur</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/11_xml_marshal_array_of_struct_1.go">https://github.com/tisnik/go-root/blob/master/article_57/11_xml_marshal_array_of_struct_1.go</a></td></tr>
<tr><td>12</td><td>12_xml_marshal_array_of_struct_2.go</td><td>konfigurace kořenového uzlu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/12_xml_marshal_array_of_struct_2.go">https://github.com/tisnik/go-root/blob/master/article_57/12_xml_marshal_array_of_struct_2.go</a></td></tr>
<tr><td>13</td><td>13_xml_marshal_array_of_struct_3.go</td><td>kořenový uzel reprezentovaný vlastní strukturou</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/13_xml_marshal_array_of_struct_3.go">https://github.com/tisnik/go-root/blob/master/article_57/13_xml_marshal_array_of_struct_3.go</a></td></tr>
<tr><td>14</td><td>14_xml_marshal_array_of_struct_4.go</td><td>kořenový uzel reprezentovaný vlastní strukturou</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/14_xml_marshal_array_of_struct_4.go">https://github.com/tisnik/go-root/blob/master/article_57/14_xml_marshal_array_of_struct_4.go</a></td></tr>
<tr><td>15</td><td>15_xml_and_json.go</td><td>serializace jedné struktury jak do XML, tak i do JSONu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/15_xml_and_json.go">https://github.com/tisnik/go-root/blob/master/article_57/15_xml_and_json.go</a></td></tr>
<tr><td>16</td><td>16_gob_marshal_basic_types.go</td><td>použití formátu Gob</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/16_gob_marshal_basic_types.go">https://github.com/tisnik/go-root/blob/master/article_57/16_gob_marshal_basic_types.go</a></td></tr>
<tr><td>17</td><td>17_gob_marshal_struct.go</td><td>použití formátu Gob pro serializaci struktur</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/17_gob_marshal_struct.go">https://github.com/tisnik/go-root/blob/master/article_57/17_gob_marshal_struct.go</a></td></tr>
<tr><td>18</td><td>18_cbor_basic_types.go</td><td>základní použití formátu CBOR</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/18_cbor_basic_types.go">https://github.com/tisnik/go-root/blob/master/article_57/18_cbor_basic_types.go</a></td></tr>
<tr><td>19</td><td>19_bson_serialize.go</td><td>serializace dat do formátu BSON</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/19_bson_serialize.go">https://github.com/tisnik/go-root/blob/master/article_57/19_bson_serialize.go</a></td></tr>
<tr><td>20</td><td>20_bson_deserialize.go</td><td>deserializace dat z&nbsp;formátu BSON</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_57/20_bson_deserialize.go">https://github.com/tisnik/go-root/blob/master/article_57/20_bson_deserialize.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Gobs of data<br />
<a href="https://blog.golang.org/gobs-of-data">https://blog.golang.org/gobs-of-data</a>
</li>

<li>Formát BSON<br />
<a href="http://bsonspec.org/">http://bsonspec.org/</a>
</li>

<li>Golang Guide: A List of Top Golang Frameworks, IDEs &amp; Tools<br />
<a href="https://blog.intelligentbee.com/2017/08/14/golang-guide-list-top-golang-frameworks-ides-tools/">https://blog.intelligentbee.com/2017/08/14/golang-guide-list-top-golang-frameworks-ides-tools/</a>
</li>

<li>Repositář projektu Gift<br />
<a href="https://github.com/disintegration/gift">https://github.com/disintegration/gift</a>
</li>

<li>Dokumentace k&nbsp;projektu Gift<br />
<a href="https://godoc.org/github.com/disintegration/gift">https://godoc.org/github.com/disintegration/gift</a>
</li>

<li>Online x86 / x64 Assembler and Disassembler<br />
<a href="https://defuse.ca/online-x86-assembler.htm#disassembly2">https://defuse.ca/online-x86-assembler.htm#disassembly2</a>
</li>

<li>The Design of the Go Assembler<br />
<a href="https://talks.golang.org/2016/asm.slide#1">https://talks.golang.org/2016/asm.slide#1</a>
</li>

<li>A Quick Guide to Go's Assembler<br />
<a href="https://golang.org/doc/asm">https://golang.org/doc/asm</a>
</li>

<li>AssemblyPolicy<br />
<a href="https://github.com/golang/go/wiki/AssemblyPolicy">https://github.com/golang/go/wiki/AssemblyPolicy</a>
</li>

<li>Geohash in Golang Assembly<br />
<a href="https://mmcloughlin.com/posts/geohash-assembly">https://mmcloughlin.com/posts/geohash-assembly</a>
</li>

<li>Command objdump<br />
<a href="https://golang.org/cmd/objdump/">https://golang.org/cmd/objdump/</a>
</li>

<li>Assembly<br />
<a href="https://goroutines.com/asm">https://goroutines.com/asm</a>
</li>

<li>Go &amp; Assembly<br />
<a href="http://www.doxsey.net/blog/go-and-assembly">http://www.doxsey.net/blog/go-and-assembly</a>
</li>

<li>A Foray Into Go Assembly Programming<br />
<a href="https://blog.sgmansfield.com/2017/04/a-foray-into-go-assembly-programming/">https://blog.sgmansfield.com/2017/04/a-foray-into-go-assembly-programming/</a>
</li>

<li>Golang Capturing log.Println And fmt.Println Output<br />
<a href="https://medium.com/@hau12a1/golang-capturing-log-println-and-fmt-println-output-770209c791b4">https://medium.com/@hau12a1/golang-capturing-log-println-and-fmt-println-output-770209c791b4</a>
</li>

<li>Stránka projektu plotly<br />
<a href="https://plot.ly/">https://plot.ly/</a>
</li>

<li>Plotly JavaScript Open Source Graphing Library<br />
<a href="https://plot.ly/javascript/">https://plot.ly/javascript/</a>
</li>

<li>Domain coloring<br />
<a href="https://en.wikipedia.org/wiki/Domain_coloring">https://en.wikipedia.org/wiki/Domain_coloring</a>
</li>

<li>Michael Fogleman's projects<br />
<a href="https://www.michaelfogleman.com/projects/tagged/graphics/">https://www.michaelfogleman.com/projects/tagged/graphics/</a>
</li>

<li>Color Graphs of Complex Functions<br />
<a href="https://web.archive.org/web/20120511021419/http://w.american.edu/cas/mathstat/lcrone/ComplexPlot.html">https://web.archive.org/web/20120511021419/http://w.american.edu/cas/mathstat/lcrone/ComplexPlot.html</a>
</li>

<li>A Gallery of Complex Functions<br />
<a href="http://wismuth.com/complex/gallery.html">http://wismuth.com/complex/gallery.html</a>
</li>

<li>package glot<br />
<a href="https://godoc.org/github.com/Arafatk/glot">https://godoc.org/github.com/Arafatk/glot</a>
</li>

<li>Gnuplotting: Output terminals<br />
<a href="http://www.gnuplotting.org/output-terminals/">http://www.gnuplotting.org/output-terminals/</a>
</li>

<li>Introducing Glot the plotting library for Golang<br />
<a href="https://medium.com/@Arafat./introducing-glot-the-plotting-library-for-golang-3133399948a1">https://medium.com/@Arafat./introducing-glot-the-plotting-library-for-golang-3133399948a1</a>
</li>

<li>Introducing Glot the plotting library for Golang<br />
<a href="https://blog.gopheracademy.com/advent-2018/introducing-glot/">https://blog.gopheracademy.com/advent-2018/introducing-glot/</a>
</li>

<li>Glot is a plotting library for Golang built on top of gnuplot<br />
<a href="https://github.com/Arafatk/glot">https://github.com/Arafatk/glot</a>
</li>

<li>Example plots (gonum/plot)<br />
<a href="https://github.com/gonum/plot/wiki/Example-plots">https://github.com/gonum/plot/wiki/Example-plots</a>
</li>

<li>A repository for plotting and visualizing data (gonum/plot)<br />
<a href="https://github.com/gonum/plot">https://github.com/gonum/plot</a>
</li>

<li>golang library to make https://chartjs.org/ plots<br />
<a href="https://github.com/brentp/go-chartjs">https://github.com/brentp/go-chartjs</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>The Gonum Numerical Computing Package<br />
<a href="https://www.gonum.org/post/introtogonum/">https://www.gonum.org/post/introtogonum/</a>
</li>

<li>Gomacro na GitHubu<br />
<a href="https://github.com/cosmos72/gomacro">https://github.com/cosmos72/gomacro</a>
</li>

<li>gophernotes - Use Go in Jupyter notebooks and nteract<br />
<a href="https://github.com/gopherdata/gophernotes">https://github.com/gopherdata/gophernotes</a>
</li>

<li>gonum<br />
<a href="https://github.com/gonum">https://github.com/gonum</a>
</li>

<li>go-gota/gota -  DataFrames and data wrangling in Go (Golang)<br />
<a href="https://porter.io/github.com/go-gota/gota">https://porter.io/github.com/go-gota/gota</a>
</li>

<li>A repository for plotting and visualizing data <br />
<a href="https://github.com/gonum/plot">https://github.com/gonum/plot</a>
</li>

<li>Gonum Numerical Packages<br />
<a href="https://www.gonum.org/">https://www.gonum.org/</a>
</li>

<li>Stránky projektu MinIO<br />
<a href="https://min.io/">https://min.io/</a>
</li>

<li>MinIO Quickstart Guide<br />
<a href="https://docs.min.io/docs/minio-quickstart-guide.html">https://docs.min.io/docs/minio-quickstart-guide.html</a>
</li>

<li>MinIO Go Client API Reference<br />
<a href="https://docs.min.io/docs/golang-client-api-reference">https://docs.min.io/docs/golang-client-api-reference</a>
</li>

<li>MinIO Python Client API Reference<br />
<a href="https://docs.min.io/docs/python-client-api-reference.html">https://docs.min.io/docs/python-client-api-reference.html</a>
</li>

<li>Performance at Scale: MinIO Pushes Past 1.4 terabits per second with 256 NVMe Drives<br />
<a href="https://blog.min.io/performance-at-scale-minio-pushes-past-1-3-terabits-per-second-with-256-nvme-drives/">https://blog.min.io/performance-at-scale-minio-pushes-past-1-3-terabits-per-second-with-256-nvme-drives/</a>
</li>

<li>Benchmarking MinIO vs. AWS S3 for Apache Spark<br />
<a href="https://blog.min.io/benchmarking-apache-spark-vs-aws-s3/">https://blog.min.io/benchmarking-apache-spark-vs-aws-s3/</a>
</li>

<li>MinIO Client Quickstart Guide<br />
<a href="https://docs.min.io/docs/minio-client-quickstart-guide.html">https://docs.min.io/docs/minio-client-quickstart-guide.html</a>
</li>

<li>Analýza kvality zdrojových kódů Minia<br />
<a href="https://goreportcard.com/report/github.com/minio/minio">https://goreportcard.com/report/github.com/minio/minio</a>
</li>

<li>This is MinIO<br />
<a href="https://www.youtube.com/watch?v=vF0lQh0XOCs">https://www.youtube.com/watch?v=vF0lQh0XOCs</a>
</li>

<li>Running MinIO Standalone<br />
<a href="https://www.youtube.com/watch?v=dIQsPCHvHoM">https://www.youtube.com/watch?v=dIQsPCHvHoM</a>
</li>

<li>"Amazon S3 Compatible Storage in Kubernetes" - Rob Girard, Principal Tech Marketing Engineer, Minio<br />
<a href="https://www.youtube.com/watch?v=wlpn8K0jJ4U">https://www.youtube.com/watch?v=wlpn8K0jJ4U</a>
</li>

<li>Ginkgo<br />
<a href="http://onsi.github.io/ginkgo/">http://onsi.github.io/ginkgo/</a>
</li>

<li>Gomega<br />
<a href="https://onsi.github.io/gomega/">https://onsi.github.io/gomega/</a>
</li>

<li>Ginkgo's Preferred Matcher Library na GitHubu<br />
<a href="https://github.com/onsi/gomega/">https://github.com/onsi/gomega/</a>
</li>

<li>Provided Matchers<br />
<a href="http://onsi.github.io/gomega/#provided-matchers">http://onsi.github.io/gomega/#provided-matchers</a>
</li>

<li>Dokumentace k&nbsp;balíčku goexpect<br />
<a href="https://godoc.org/github.com/google/goexpect">https://godoc.org/github.com/google/goexpect</a>
</li>

<li>Balíček goexpect<br />
<a href="https://github.com/google/goexpect">https://github.com/google/goexpect</a>
</li>

<li>Balíček go-expect<br />
<a href="https://github.com/Netflix/go-expect">https://github.com/Netflix/go-expect</a>
</li>

<li>Balíček gexpect<br />
<a href="https://github.com/ThomasRooney/gexpect">https://github.com/ThomasRooney/gexpect</a>
</li>

<li>Expect (originál naprogramovaný v&nbsp;TCL)<br />
<a href="https://core.tcl-lang.org/expect/index">https://core.tcl-lang.org/expect/index</a>
</li>

<li>Expect (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Expect">https://en.wikipedia.org/wiki/Expect</a>
</li>

<li>Pexpect<br />
<a href="https://pexpect.readthedocs.io/en/stable/">https://pexpect.readthedocs.io/en/stable/</a>
</li>

<li>Golang SSH Client: Multiple Commands, Crypto &amp; Goexpect Examples<br />
<a href="http://networkbit.ch/golang-ssh-client/">http://networkbit.ch/golang-ssh-client/</a>
</li>

<li>goblin na GitHubu<br />
<a href="https://github.com/franela/goblin">https://github.com/franela/goblin</a>
</li>

<li>Mocha framework<br />
<a href="https://mochajs.org/">https://mochajs.org/</a>
</li>

<li>frisby na GitHubu<br />
<a href="https://github.com/verdverm/frisby">https://github.com/verdverm/frisby</a>
</li>

<li>package frisby<br />
<a href="https://godoc.org/github.com/verdverm/frisby">https://godoc.org/github.com/verdverm/frisby</a>
</li>

<li>Frisby alternatives and similar packages (generováno)<br />
<a href="https://go.libhunt.com/frisby-alternatives">https://go.libhunt.com/frisby-alternatives</a>
</li>

<li>Cucumber for golang<br />
<a href="https://github.com/DATA-DOG/godog">https://github.com/DATA-DOG/godog</a>
</li>

<li>How to Use Godog for Behavior-driven Development in Go<br />
<a href="https://semaphoreci.com/community/tutorials/how-to-use-godog-for-behavior-driven-development-in-go">https://semaphoreci.com/community/tutorials/how-to-use-godog-for-behavior-driven-development-in-go</a>
</li>

<li>Comparative Analysis Of GoLang Testing Frameworks<br />
<a href="https://www.slideshare.net/DushyantBhalgami/comparative-analysis-of-golang-testing-frameworks">https://www.slideshare.net/DushyantBhalgami/comparative-analysis-of-golang-testing-frameworks</a>
</li>

<li>A Quick Guide to Testing in Golang<br />
<a href="https://caitiem.com/2016/08/18/a-quick-guide-to-testing-in-golang/">https://caitiem.com/2016/08/18/a-quick-guide-to-testing-in-golang/</a>
</li>

<li>Tom's Obvious, Minimal Language.<br />
<a href="https://github.com/toml-lang/toml">https://github.com/toml-lang/toml</a>
</li>

<li>xml.org<br />
<a href="http://www.xml.org/">http://www.xml.org/</a>
</li>

<li>Soubory .properties<br />
<a href="https://en.wikipedia.org/wiki/.properties">https://en.wikipedia.org/wiki/.properties</a>
</li>

<li>Soubory INI<br />
<a href="https://en.wikipedia.org/wiki/INI_file">https://en.wikipedia.org/wiki/INI_file</a>
</li>

<li>JSON to YAML<br />
<a href="https://www.json2yaml.com/">https://www.json2yaml.com/</a>
</li>

<li>Data Format Converter<br />
<a href="https://toolkit.site/format.html">https://toolkit.site/format.html</a>
</li>

<li>Viper na GitHubu<br />
<a href="https://github.com/spf13/viper">https://github.com/spf13/viper</a>
</li>

<li>GoDotEnv na GitHubu<br />
<a href="https://github.com/joho/godotenv">https://github.com/joho/godotenv</a>
</li>

<li>The fantastic ORM library for Golang<br />
<a href="http://gorm.io/">http://gorm.io/</a>
</li>

<li>Dokumentace k&nbsp;balíčku <strong>gorilla/mux</strong><br />
<a href="https://godoc.org/github.com/gorilla/mux">https://godoc.org/github.com/gorilla/mux</a>
</li>

<li>Gorilla web toolkitk<br />
<a href="http://www.gorillatoolkit.org/">http://www.gorillatoolkit.org/</a>
</li>

<li>Metric types<br />
<a href="https://prometheus.io/docs/concepts/metric_types/">https://prometheus.io/docs/concepts/metric_types/</a>
</li>

<li>Histograms with Prometheus: A Tale of Woe<br />
<a href="http://linuxczar.net/blog/2017/06/15/prometheus-histogram-2/">http://linuxczar.net/blog/2017/06/15/prometheus-histogram-2/</a>
</li>

<li>Why are Prometheus histograms cumulative?<br />
<a href="https://www.robustperception.io/why-are-prometheus-histograms-cumulative">https://www.robustperception.io/why-are-prometheus-histograms-cumulative</a>
</li>

<li>Histograms and summaries<br />
<a href="https://prometheus.io/docs/practices/histograms/">https://prometheus.io/docs/practices/histograms/</a>
</li>

<li>Instrumenting Golang server in 5 min<br />
<a href="https://medium.com/@gsisimogang/instrumenting-golang-server-in-5-min-c1c32489add3">https://medium.com/@gsisimogang/instrumenting-golang-server-in-5-min-c1c32489add3</a>
</li>

<li>Semantic Import Versioning in Go<br />
<a href="https://www.aaronzhuo.com/semantic-import-versioning-in-go/">https://www.aaronzhuo.com/semantic-import-versioning-in-go/</a>
</li>

<li>Sémantické verzování<br />
<a href="https://semver.org/">https://semver.org/</a>
</li>

<li>Getting started with Go modules<br />
<a href="https://medium.com/@fonseka.live/getting-started-with-go-modules-b3dac652066d">https://medium.com/@fonseka.live/getting-started-with-go-modules-b3dac652066d</a>
</li>

<li>Create projects independent of $GOPATH using Go Modules<br />
<a href="https://medium.com/mindorks/create-projects-independent-of-gopath-using-go-modules-802260cdfb51o">https://medium.com/mindorks/create-projects-independent-of-gopath-using-go-modules-802260cdfb51o</a>
</li>

<li>Anatomy of Modules in Go<br />
<a href="https://medium.com/rungo/anatomy-of-modules-in-go-c8274d215c16">https://medium.com/rungo/anatomy-of-modules-in-go-c8274d215c16</a>
</li>

<li>Modules<br />
<a href="https://github.com/golang/go/wiki/Modules">https://github.com/golang/go/wiki/Modules</a>
</li>

<li>Go Modules Tutorial<br />
<a href="https://tutorialedge.net/golang/go-modules-tutorial/">https://tutorialedge.net/golang/go-modules-tutorial/</a>
</li>

<li>Module support<br />
<a href="https://golang.org/cmd/go/#hdr-Module_support">https://golang.org/cmd/go/#hdr-Module_support</a>
</li>

<li>Go Lang: Memory Management and Garbage Collection<br />
<a href="https://vikash1976.wordpress.com/2017/03/26/go-lang-memory-management-and-garbage-collection/">https://vikash1976.wordpress.com/2017/03/26/go-lang-memory-management-and-garbage-collection/</a>
</li>

<li>Golang Internals, Part 4: Object Files and Function Metadata<br />
<a href="https://blog.altoros.com/golang-part-4-object-files-and-function-metadata.html">https://blog.altoros.com/golang-part-4-object-files-and-function-metadata.html</a>
</li>

<li>What is REPL?<br />
<a href="https://pythonprogramminglanguage.com/repl/">https://pythonprogramminglanguage.com/repl/</a>
</li>

<li>What is a REPL?<br />
<a href="https://codewith.mu/en/tutorials/1.0/repl">https://codewith.mu/en/tutorials/1.0/repl</a>
</li>

<li>Programming at the REPL: Introduction<br />
<a href="https://clojure.org/guides/repl/introduction">https://clojure.org/guides/repl/introduction</a>
</li>

<li>What is REPL? (Quora)<br />
<a href="https://www.quora.com/What-is-REPL">https://www.quora.com/What-is-REPL</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Read-eval-print loop (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>Vim as a Go (Golang) IDE using LSP and vim-go<br />
<a href="https://octetz.com/posts/vim-as-go-ide">https://octetz.com/posts/vim-as-go-ide</a>
</li>

<li>gopls<br />
<a href="https://github.com/golang/go/wiki/gopls">https://github.com/golang/go/wiki/gopls</a>
</li>

<li>IDE Integration Guide<br />
<a href="https://github.com/stamblerre/gocode/blob/master/docs/IDE_integration.md">https://github.com/stamblerre/gocode/blob/master/docs/IDE_integration.md</a>
</li>

<li>How to instrument Go code with custom expvar metrics<br />
<a href="https://sysdig.com/blog/golang-expvar-custom-metrics/">https://sysdig.com/blog/golang-expvar-custom-metrics/</a>
</li>

<li>Golang expvar metricset (Metricbeat Reference)<br />
<a href="https://www.elastic.co/guide/en/beats/metricbeat/7.x/metricbeat-metricset-golang-expvar.html">https://www.elastic.co/guide/en/beats/metricbeat/7.x/metricbeat-metricset-golang-expvar.html</a>
</li>

<li>Package expvar<br />
<a href="https://golang.org/pkg/expvar/#NewInt">https://golang.org/pkg/expvar/#NewInt</a>
</li>

<li>Java Platform Debugger Architecture: Overview<br />
<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jpda/jpda.html">https://docs.oracle.com/en/java/javase/11/docs/specs/jpda/jpda.html</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="https://www.oracle.com/technetwork/articles/javase/index-140680.html">https://www.oracle.com/technetwork/articles/javase/index-140680.html</a>
</li>

<li>JVM Tool Interface Version 11.0<br />
<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html">https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>Go &amp; cgo: integrating existing C code with Go<br />
<a href="http://akrennmair.github.io/golang-cgo-slides/#1">http://akrennmair.github.io/golang-cgo-slides/#1</a>
</li>

<li>Using cgo to call C code from within Go code<br />
<a href="https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/">https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/</a>
</li>

<li>Package trace<br />
<a href="https://golang.org/pkg/runtime/trace/">https://golang.org/pkg/runtime/trace/</a>
</li>

<li>Introducing HTTP Tracing<br />
<a href="https://blog.golang.org/http-tracing">https://blog.golang.org/http-tracing</a>
</li>

<li>Command trace<br />
<a href="https://golang.org/cmd/trace/">https://golang.org/cmd/trace/</a>
</li>

<li>A StreamLike, Immutable, Lazy Loading and smart Golang Library to deal with slices<br />
<a href="https://github.com/wesovilabs/koazee">https://github.com/wesovilabs/koazee</a>
</li>

<li>Funkce vyššího řádu v knihovně Underscore<br />
<a href="https://www.root.cz/clanky/funkce-vyssiho-radu-v-knihovne-underscore/">https://www.root.cz/clanky/funkce-vyssiho-radu-v-knihovne-underscore/</a>
</li>

<li>Delve: a debugger for the Go programming language.<br />
<a href="https://github.com/go-delve/delve">https://github.com/go-delve/delve</a>
</li>

<li>Příkazy debuggeru Delve<br />
<a href="https://github.com/go-delve/delve/tree/master/Documentation/cli">https://github.com/go-delve/delve/tree/master/Documentation/cli</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (2. část)<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v&nbsp;editorech Emacs a Vim<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Debugging Go Code with GDB<br />
<a href="https://golang.org/doc/gdb">https://golang.org/doc/gdb</a>
</li>

<li>Debugging Go (golang) programs with gdb <br />
<a href="https://thornydev.blogspot.com/2014/01/debugging-go-golang-programs-with-gdb.html">https://thornydev.blogspot.com/2014/01/debugging-go-golang-programs-with-gdb.html</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>GDB - Supported Languages<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>13 Linux Debuggers for C++ Reviewed<br />
<a href="http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817">http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817</a>
</li>

<li>Go is on a Trajectory to Become the Next Enterprise Programming Language<br />
<a href="https://hackernoon.com/go-is-on-a-trajectory-to-become-the-next-enterprise-programming-language-3b75d70544e">https://hackernoon.com/go-is-on-a-trajectory-to-become-the-next-enterprise-programming-language-3b75d70544e</a>
</li>

<li>Go Proverbs: Simple, Poetic, Pithy<br />
<a href="https://go-proverbs.github.io/">https://go-proverbs.github.io/</a>
</li>

<li>Handling Sparse Files on Linux<br />
<a href="https://www.systutorials.com/136652/handling-sparse-files-on-linux/">https://www.systutorials.com/136652/handling-sparse-files-on-linux/</a>
</li>

<li>Gzip (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Gzip">https://en.wikipedia.org/wiki/Gzip</a>
</li>

<li>Deflate<br />
<a href="https://en.wikipedia.org/wiki/DEFLATE">https://en.wikipedia.org/wiki/DEFLATE</a>
</li>

<li>10 tools written in Go that every developer needs to know<br />
<a href="https://gustavohenrique.net/en/2019/01/10-tools-written-in-go-that-every-dev-needs-to-know/">https://gustavohenrique.net/en/2019/01/10-tools-written-in-go-that-every-dev-needs-to-know/</a>
</li>

<li>Hexadecimální prohlížeče a editory s textovým uživatelským rozhraním<br />
<a href="https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/">https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/</a>
</li>

<li>Hex dump<br />
<a href="https://en.wikipedia.org/wiki/Hex_dump">https://en.wikipedia.org/wiki/Hex_dump</a>
</li>

<li>Rozhraní io.ByteReader<br />
<a href="https://golang.org/pkg/io/#ByteReader">https://golang.org/pkg/io/#ByteReader</a>
</li>

<li>Rozhraní io.RuneReader<br />
<a href="https://golang.org/pkg/io/#RuneReader">https://golang.org/pkg/io/#RuneReader</a>
</li>

<li>Rozhraní io.ByteScanner<br />
<a href="https://golang.org/pkg/io/#ByteScanner">https://golang.org/pkg/io/#ByteScanner</a>
</li>

<li>Rozhraní io.RuneScanner<br />
<a href="https://golang.org/pkg/io/#RuneScanner">https://golang.org/pkg/io/#RuneScanner</a>
</li>

<li>Rozhraní io.Closer<br />
<a href="https://golang.org/pkg/io/#Closer">https://golang.org/pkg/io/#Closer</a>
</li>

<li>Rozhraní io.Reader<br />
<a href="https://golang.org/pkg/io/#Reader">https://golang.org/pkg/io/#Reader</a>
</li>

<li>Rozhraní io.Writer<br />
<a href="https://golang.org/pkg/io/#Writer">https://golang.org/pkg/io/#Writer</a>
</li>

<li>Typ Strings.Reader<br />
<a href="https://golang.org/pkg/strings/#Reader">https://golang.org/pkg/strings/#Reader</a>
</li>

<li>VACUUM (SQL)<br />
<a href="https://www.sqlite.org/lang_vacuum.html">https://www.sqlite.org/lang_vacuum.html</a>
</li>

<li>VACUUM (Postgres)<br />
<a href="https://www.postgresql.org/docs/8.4/sql-vacuum.html">https://www.postgresql.org/docs/8.4/sql-vacuum.html</a>
</li>

<li>go-cron<br />
<a href="https://github.com/rk/go-cron">https://github.com/rk/go-cron</a>
</li>

<li>gocron<br />
<a href="https://github.com/jasonlvhit/gocron">https://github.com/jasonlvhit/gocron</a>
</li>

<li>clockwork<br />
<a href="https://github.com/whiteShtef/clockwork">https://github.com/whiteShtef/clockwork</a>
</li>

<li>clockwerk<br />
<a href="https://github.com/onatm/clockwerk">https://github.com/onatm/clockwerk</a>
</li>

<li>JobRunner<br />
<a href="https://github.com/bamzi/jobrunner">https://github.com/bamzi/jobrunner</a>
</li>

<li>Rethinking Cron<br />
<a href="https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/">https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/</a>
</li>

<li>In the Beginning was the Command Line<br />
<a href="https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html">https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html</a>
</li>

<li>repl.it (REPL pro různé jazyky)<br />
<a href="https://repl.it/languages">https://repl.it/languages</a>
</li>

<li>GOCUI - Go Console User Interface (celé uživatelské prostředí, nejenom input box)<br />
<a href="https://github.com/jroimartin/gocui">https://github.com/jroimartin/gocui</a>
</li>

<li>Read–eval–print loop<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>go-prompt<br />
<a href="https://github.com/c-bata/go-prompt">https://github.com/c-bata/go-prompt</a>
</li>

<li>readline<br />
<a href="https://github.com/chzyer/readline">https://github.com/chzyer/readline</a>
</li>

<li>A pure golang implementation for GNU-Readline kind library<br />
<a href="https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/">https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/</a>
</li>

<li>go-readline<br />
<a href="https://github.com/fiorix/go-readline">https://github.com/fiorix/go-readline</a>
</li>

<li>4 Python libraries for building great command-line user interfaces<br />
<a href="https://opensource.com/article/17/5/4-practical-python-libraries">https://opensource.com/article/17/5/4-practical-python-libraries</a>
</li>

<li>prompt_toolkit 2.0.3 na PyPi<br />
<a href="https://pypi.org/project/prompt_toolkit/">https://pypi.org/project/prompt_toolkit/</a>
</li>

<li>python-prompt-toolkit na GitHubu<br />
<a href="https://github.com/jonathanslenders/python-prompt-toolkit">https://github.com/jonathanslenders/python-prompt-toolkit</a>
</li>

<li>The GNU Readline Library<br />
<a href="https://tiswww.case.edu/php/chet/readline/rltop.html">https://tiswww.case.edu/php/chet/readline/rltop.html</a>
</li>

<li>GNU Readline (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Readline">https://en.wikipedia.org/wiki/GNU_Readline</a>
</li>

<li>readline — GNU readline interface (Python 3.x)<br />
<a href="https://docs.python.org/3/library/readline.html">https://docs.python.org/3/library/readline.html</a>
</li>

<li>readline — GNU readline interface (Python 2.x)<br />
<a href="https://docs.python.org/2/library/readline.html">https://docs.python.org/2/library/readline.html</a>
</li>

<li>GNU Readline Library - command line editing<br />
<a href="https://tiswww.cwru.edu/php/chet/readline/readline.html">https://tiswww.cwru.edu/php/chet/readline/readline.html</a>
</li>

<li>gnureadline 6.3.8 na PyPi<br />
<a href="https://pypi.org/project/gnureadline/">https://pypi.org/project/gnureadline/</a>
</li>

<li>Editline Library (libedit)<br />
<a href="http://thrysoee.dk/editline/">http://thrysoee.dk/editline/</a>
</li>

<li>Comparing Python Command-Line Parsing Libraries – Argparse, Docopt, and Click<br />
<a href="https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/">https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/</a>
</li>

<li>libedit or editline<br />
<a href="http://www.cs.utah.edu/~bigler/code/libedit.html">http://www.cs.utah.edu/~bigler/code/libedit.html</a>
</li>

<li>WinEditLine<br />
<a href="http://mingweditline.sourceforge.net/">http://mingweditline.sourceforge.net/</a>
</li>

<li>rlcompleter — Completion function for GNU readline<br />
<a href="https://docs.python.org/3/library/rlcompleter.html">https://docs.python.org/3/library/rlcompleter.html</a>
</li>

<li>rlwrap na GitHubu<br />
<a href="https://github.com/hanslub42/rlwrap">https://github.com/hanslub42/rlwrap</a>
</li>

<li>rlwrap(1) - Linux man page<br />
<a href="https://linux.die.net/man/1/rlwrap">https://linux.die.net/man/1/rlwrap</a>
</li>

<li>readline(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/readline">https://linux.die.net/man/3/readline</a>
</li>

<li>history(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/history">https://linux.die.net/man/3/history</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>oglematchers</i><br />
<a href="https://godoc.org/github.com/jacobsa/oglematchers">https://godoc.org/github.com/jacobsa/oglematchers</a>
</li>

<li>Balíček <i>oglematchers</i><br />
<a href="https://github.com/jacobsa/oglematchers">https://github.com/jacobsa/oglematchers</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>ogletest</i><br />
<a href="https://godoc.org/github.com/jacobsa/ogletest">https://godoc.org/github.com/jacobsa/ogletest</a>
</li>

<li>Balíček <i>ogletest</i><br />
<a href="https://github.com/jacobsa/ogletest">https://github.com/jacobsa/ogletest</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>assert</i><br />
<a href="https://godoc.org/github.com/stretchr/testify/assert">https://godoc.org/github.com/stretchr/testify/assert</a>
</li>

<li>Testify - Thou Shalt Write Tests<br />
<a href="https://github.com/stretchr/testify/">https://github.com/stretchr/testify/</a>
</li>

<li>package testing<br />
<a href="https://golang.org/pkg/testing/">https://golang.org/pkg/testing/</a>
</li>

<li>Golang basics - writing unit tests<br />
<a href="https://blog.alexellis.io/golang-writing-unit-tests/">https://blog.alexellis.io/golang-writing-unit-tests/</a>
</li>

<li>An Introduction to Programming in Go / Testing<br />
<a href="https://www.golang-book.com/books/intro/12">https://www.golang-book.com/books/intro/12</a>
</li>

<li>An Introduction to Testing in Go<br />
<a href="https://tutorialedge.net/golang/intro-testing-in-go/">https://tutorialedge.net/golang/intro-testing-in-go/</a>
</li>

<li>Advanced Go Testing Tutorial<br />
<a href="https://tutorialedge.net/golang/advanced-go-testing-tutorial/">https://tutorialedge.net/golang/advanced-go-testing-tutorial/</a>
</li>

<li>GoConvey<br />
<a href="http://goconvey.co/">http://goconvey.co/</a>
</li>

<li>Testing Techniques<br />
<a href="https://talks.golang.org/2014/testing.slide">https://talks.golang.org/2014/testing.slide</a>
</li>

<li>5 simple tips and tricks for writing unit tests in #golang<br />
<a href="https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742">https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742</a>
</li>

<li>Afinní transformace<br />
<a href="https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic">https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic</a>
</li>

<li>package gg<br />
<a href="https://godoc.org/github.com/fogleman/gg">https://godoc.org/github.com/fogleman/gg</a>
</li>

<li>Generate an animated GIF with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/">http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/</a>
</li>

<li>Generate an image programmatically with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/">http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/</a>
</li>

<li>The Go image package<br />
<a href="https://blog.golang.org/go-image-package">https://blog.golang.org/go-image-package</a>
</li>

<li>Balíček draw2D: 2D rendering for different output (raster, pdf, svg)<br />
<a href="https://github.com/llgcode/draw2d">https://github.com/llgcode/draw2d</a>
</li>

<li>Draw a rectangle in Golang?<br />
<a href="https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang">https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang</a>
</li>

<li>YAML<br />
<a href="https://yaml.org/">https://yaml.org/</a>
</li>

<li>edn<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Smile<br />
<a href="https://github.com/FasterXML/smile-format-specification">https://github.com/FasterXML/smile-format-specification</a>
</li>

<li>Protocol-Buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>Marshalling (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
</li>

<li>Unmarshalling<br />
<a href="https://en.wikipedia.org/wiki/Unmarshalling">https://en.wikipedia.org/wiki/Unmarshalling</a>
</li>

<li>Introducing JSON<br />
<a href="http://json.org/">http://json.org/</a>
</li>

<li>Package json<br />
<a href="https://golang.org/pkg/encoding/json/">https://golang.org/pkg/encoding/json/</a>
</li>

<li>The Go Blog: JSON and Go<br />
<a href="https://blog.golang.org/json-and-go">https://blog.golang.org/json-and-go</a>
</li>

<li>Go by Example: JSON<br />
<a href="https://gobyexample.com/json">https://gobyexample.com/json</a>
</li>

<li>Writing Web Applications<br />
<a href="https://golang.org/doc/articles/wiki/">https://golang.org/doc/articles/wiki/</a>
</li>

<li>Golang Web Apps<br />
<a href="https://www.reinbach.com/blog/golang-webapps-1/">https://www.reinbach.com/blog/golang-webapps-1/</a>
</li>

<li>Build web application with Golang<br />
<a href="https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details">https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details</a>
</li>

<li>Golang Templates - Golang Web Pages<br />
<a href="https://www.youtube.com/watch?v=TkNIETmF-RU">https://www.youtube.com/watch?v=TkNIETmF-RU</a>
</li>

<li>Simple Golang HTTPS/TLS Examples<br />
<a href="https://github.com/denji/golang-tls">https://github.com/denji/golang-tls</a>
</li>

<li>Playing with images in HTTP response in golang<br />
<a href="https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang">https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang</a>
</li>

<li>MIME Types List<br />
<a href="https://www.freeformatter.com/mime-types-list.html">https://www.freeformatter.com/mime-types-list.html</a>
</li>

<li>Go Mutex Tutorial<br />
<a href="https://tutorialedge.net/golang/go-mutex-tutorial/">https://tutorialedge.net/golang/go-mutex-tutorial/</a>
</li>

<li>Creating A Simple Web Server With Golang<br />
<a href="https://tutorialedge.net/golang/creating-simple-web-server-with-golang/">https://tutorialedge.net/golang/creating-simple-web-server-with-golang/</a>
</li>

<li>Building a Web Server in Go<br />
<a href="https://thenewstack.io/building-a-web-server-in-go/">https://thenewstack.io/building-a-web-server-in-go/</a>
</li>

<li>How big is the pipe buffer?<br />
<a href="https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer">https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer</a>
</li>

<li>How to turn off buffering of stdout in C<br />
<a href="https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c">https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c</a>
</li>

<li>setbuf(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/setbuf">https://linux.die.net/man/3/setbuf</a>
</li>

<li>setvbuf(3) - Linux man page (stejný obsah jako předchozí stránka)<br />
<a href="https://linux.die.net/man/3/setvbuf">https://linux.die.net/man/3/setvbuf</a>
</li>

<li>Select waits on a group of channels<br />
<a href="https://yourbasic.org/golang/select-explained/">https://yourbasic.org/golang/select-explained/</a>
</li>

<li>Rob Pike: Simplicity is Complicated (video)<br />
<a href="http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893">http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893</a>
</li>

<li>Algorithms to Go<br />
<a href="https://yourbasic.org/">https://yourbasic.org/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů: vlastní filtry a lexery<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/</a>
</li>

<li>Go Defer Simplified with Practical Visuals<br />
<a href="https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff">https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff</a>
</li>

<li>5 More Gotchas of Defer in Go — Part II<br />
<a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa">https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa</a>
</li>

<li>The Go Blog: Defer, Panic, and Recover<br />
<a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a>
</li>

<li>The defer keyword in Swift 2: try/finally done right<br />
<a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer">https://www.hackingwithswift.com/new-syntax-swift-2-defer</a>
</li>

<li>Swift Defer Statement<br />
<a href="https://andybargh.com/swift-defer-statement/">https://andybargh.com/swift-defer-statement/</a>
</li>

<li>Modulo operation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Modulo_operation">https://en.wikipedia.org/wiki/Modulo_operation</a>
</li>

<li>Node.js vs Golang: Battle of the Next-Gen Languages<br />
<a href="https://www.hostingadvice.com/blog/nodejs-vs-golang/">https://www.hostingadvice.com/blog/nodejs-vs-golang/</a>
</li>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go<br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>JavaScript vs. Golang for IoT: Is Gopher Winning?<br />
<a href="https://www.iotforall.com/javascript-vs-golang-iot/">https://www.iotforall.com/javascript-vs-golang-iot/</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

<li>Printf Format Strings<br />
<a href="https://www.cprogramming.com/tutorial/printf-format-strings.html">https://www.cprogramming.com/tutorial/printf-format-strings.html</a>
</li>

<li>Java: String.format<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-</a>
</li>

<li>Java: format string syntax<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a>
</li>

<li>Selectors<br />
<a href="https://golang.org/ref/spec#Selectors">https://golang.org/ref/spec#Selectors</a>
</li>

<li>Calling Go code from Python code<br />
<a href="http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/">http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/</a>
</li>

<li>Go Data Structures: Interfaces <br />
<a href="https://research.swtch.com/interfaces">https://research.swtch.com/interfaces</a>
</li>

<li>How to use interfaces in Go<br />
<a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go</a>
</li>

<li>Interfaces in Go (part I)<br />
<a href="https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c">https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c</a>
</li>

<li>Part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>What about Trait support in Golang?<br />
<a href="https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/">https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/</a>
</li>

<li>Don't Get Bitten by Pointer vs Non-Pointer Method Receivers in Golang<br />
<a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/">https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/</a>
</li>

<li>Control Flow<br />
<a href="https://en.wikipedia.org/wiki/Control_flow">https://en.wikipedia.org/wiki/Control_flow</a>
</li>

<li>Structured programming<br />
<a href="https://en.wikipedia.org/wiki/Structured_programming">https://en.wikipedia.org/wiki/Structured_programming</a>
</li>

<li>Control Structures<br />
<a href="https://www.golang-book.com/books/intro/5">https://www.golang-book.com/books/intro/5</a>
</li>

<li>Control structures - Go if else statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html">http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html</a>
</li>

<li>Control structures - Go switch case statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html</a>
</li>

<li>Control structures - Go for loop, break, continue, range<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html</a>
</li>

<li>Goroutine IDs<br />
<a href="https://blog.sgmansfield.com/2015/12/goroutine-ids/">https://blog.sgmansfield.com/2015/12/goroutine-ids/</a>
</li>

<li>Different ways to pass channels as arguments in function in go (golang)<br />
<a href="https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang">https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang</a>
</li>

<li>justforfunc #22: using the Go execution tracer<br />
<a href="https://www.youtube.com/watch?v=ySy3sR1LFCQ">https://www.youtube.com/watch?v=ySy3sR1LFCQ</a>
</li>

<li>Single Function Exit Point<br />
<a href="http://wiki.c2.com/?SingleFunctionExitPoint">http://wiki.c2.com/?SingleFunctionExitPoint</a>
</li>

<li>Entry point<br />
<a href="https://en.wikipedia.org/wiki/Entry_point">https://en.wikipedia.org/wiki/Entry_point</a>
</li>

<li>Why does Go have a GOTO statement?!<br />
<a href="https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/">https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/</a>
</li>

<li>Effective Go<br />
<a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a>
</li>

<li>GoClipse: an Eclipse IDE for the Go programming language<br />
<a href="http://goclipse.github.io/">http://goclipse.github.io/</a>
</li>

<li>GoClipse Installation<br />
<a href="https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation">https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation</a>
</li>

<li>The zero value of a slice is not nil<br />
<a href="https://stackoverflow.com/questions/30806931/the-zero-value-of-a-slice-is-not-nil">https://stackoverflow.com/questions/30806931/the-zero-value-of-a-slice-is-not-nil</a>
</li>

<li>Go-tcha: When nil != nil<br />
<a href="https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic">https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic</a>
</li>

<li>Nils in Go<br />
<a href="https://www.doxsey.net/blog/nils-in-go">https://www.doxsey.net/blog/nils-in-go</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

