<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací paradigma založené na tocích (dat) a knihovna goflow</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací paradigma založené na tocích (dat) a knihovna goflow</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dnes si ve stručnosti představíme programování/paradigma založené na tocích (FBP - Flow-based programming). Jedná se o paradigma, v němž se aplikace definují jako sítě procesů, které si posílají data předáváním zpráv předem definovanými cestami, typicky přes buffery (fronty).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací paradigma založené na tocích (dat)</a></p>
<p><a href="#k02">2. Základní koncepty FBP</a></p>
<p><a href="#k03">3. Buffery s&nbsp;pevnou kapacitou a neomezené fronty</a></p>
<p><a href="#k04">4. Vizuální návrh sítě</a></p>
<p><a href="#k05">5. Instalace knihovny <strong>goflow</strong></a></p>
<p><a href="#k06">6. Jednoduchá síť s&nbsp;jediným uzlem</a></p>
<p><a href="#k07">7. Úplný zdrojový kód prvního demonstračního příkladu</a></p>
<p><a href="#k08">8. Nekorektní přímé rozvětvení v&nbsp;síti</a></p>
<p><a href="#k09">9. Přidání procesu se vstupním a současně i výstupním portem</a></p>
<p><a href="#k10">10. Úplný zdrojový kód třetího demonstračního příkladu</a></p>
<p><a href="#k11">11. Proces se dvěma výstupními porty</a></p>
<p><a href="#k12">12. Úplný zdrojový kód čtvrtého demonstračního příkladu</a></p>
<p><a href="#k13">13. Déletrvající výpočty</a></p>
<p><a href="#k14">14. Využití bufferů pro komunikaci mezi procesy</a></p>
<p><a href="#k15">15. Úplný zdrojový kód šestého demonstračního příkladu</a></p>
<p><a href="#k16">16. Uzel typu <strong>Splitter</strong> a <strong>Merger</strong></a></p>
<p><a href="#k17">17. Úplný zdrojový kód sedmého demonstračního příkladu</a></p>
<p><a href="#k18">18. Obsah druhé části článku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací paradigma založené na tocích (dat)</h2>

<p><i>&bdquo;τὰ πάντα ῥεῖ καὶ οὐδὲν μένει: everything flows, and nothing stays&ldquo;<br />
Hérakleitos</i></p>

<p>V&nbsp;průběhu více než sedmdesáti let vývoje informatiky bylo vytvořeno
relativně velké množství paradigmat programování. S&nbsp;mnoha paradigmaty jsme
se ostatně již mnohokrát setkali i na stránkách Roota. Připomeňme si například
články o nestrukturovaném programování/paradigmatu (<a
href="https://www.root.cz/clanky/bbc-basic-i-qbasic-oslavuji-sva-kulata-vyroci/">BASIC</a>),
strukturovaném programování (<a
href="https://www.root.cz/clanky/sedesatiny-prevratneho-programovaciho-jazyka-algol-60/">Algol</a>
a <a
href="https://www.root.cz/clanky/tricet-let-od-vydani-revolucniho-turbo-pascalu-5-5/">Pascal</a>),
objektově orientovaném paradigmatu (<a
href="https://www.root.cz/n/smalltalk/">Smalltalk</a>), funkcionálním
paradigmatu (<a href="https://www.root.cz/n/clojure/">Clojure</a>) či o
paradigmatu založeném primárně na zpracování polí (<a
href="https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/">APL</a>,
<a
href="https://www.root.cz/clanky/specializovane-jazyky-pro-praci-s-n-dimenzionalnimi-poli-jazyk-j/">J</a>).</p>

<p><div class="rs-tip-major">Poznámka: vývoj některých programovacích
paradigmat nalezneme na grafu <a
href="https://upload.wikimedia.org/wikipedia/commons/f/f7/Programming_paradigms.svg">https://upload.wikimedia.org/wikipedia/commons/f/f7/Programming_paradigms.svg</a>.</div></p>

<p>Prozatím jsme se však příliš nezabývali programováním/paradigmatem založeným
na tocích (<i>FBP &ndash; Flow-based programming</i>). Jedná se o paradigma,
v&nbsp;němž se aplikace definují jako sítě procesů &ndash; &bdquo;černé
skříňky&ldquo; &ndash;, které si posílají data předáváním zpráv předem
definovanými cestami (tedy nikoli &bdquo;náhodně&ldquo; či libovolně, jako je
tomu v&nbsp;klasickém OOP). Tyto procesy neboli černé skříňky lze prakticky
libovolně propojovat a vytvářet tak různé aplikace, aniž by bylo nutné je (tedy
ony <i>procesy</i>) interně měnit. FBP je tedy paradigma, které zcela přirozeně
vede k&nbsp;tvorbě více či méně samostatně pracujících komponent.</p>

<p>A právě paradigmatem založeným na tocích dat se budeme zabývat
v&nbsp;dnešním článku. Praktické příklady budou vytvořeny v&nbsp;jazyce Go a
používat budou knihovnu nazvanou přímočaře <strong>goflow</strong>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Základní koncepty FBP</h2>

<p><i>&bdquo;The real world is asynchronous: don't try to force everything into
a synchronous framework derived from the architecture of early
computers.&ldquo;<br />
J. Paul Morrison, inventor/discoverer of Flow-Based Programming</i></p>

<p>V&nbsp;FBP se upouští od klasického (řekněme von Neumannovského) pohledu na
aplikace jako na sekvenční proces. Namísto toho se aplikace modelují jako síť
asynchronně běžících procesů, které si předávají data přes <i>buffery</i>
(resp.&nbsp;přes <i>fronty</i>). Každý proces v&nbsp;FBP provádí činnost ve
chvíli, kdy dostává vstupní data a díky oddělení procesů a jejich nezávislosti
na ostatních procesech vlastně zcela zadarmo získáme plnou podporu pro
paralelní běh aplikace jako celku.</p>

<p><div class="rs-tip-major">Poznámka: každé programovací paradigma (kromě
původního nestrukturovaného programování) vývojářům nabízí vyšší úrovně
abstrakce, ovšem současně je i nutí se něčeho vzdát. V&nbsp;FBP se konkrétně
vzdáváme explicitního řízení/určení pořadí provádění operací pro všechny
vstupní události.</div></p>

<p>Základními stavebními prvky při návrhu aplikace při použití paradigmatu FBP
jsou <i>komponenty</i>. Interně se typicky jedná o třídy, struktury+metody
(Go), uzávěry (<i>closure</i>) či někdy o obyčejné funkce. Instance
<i>komponent</i> umístěné do grafu/sítě se nazývají <i>procesy</i>.
Z&nbsp;jedné komponenty lze pochopitelně odvodit větší množství procesů.</p>

<p>Jednotlivé procesy spolu nekomunikují přímo (voláním), ale příjmem dat na
vstupních portech popř.&nbsp;posíláním dat na porty výstupní. Jednotlivá
spojení (<i>connection</i>) mohou obsahovat buffery resp.&nbsp;přesněji řečeno
fronty (<i>FIFO</i>, <i>queue</i>), typicky s&nbsp;předem nastavenou kapacitou
(tedy maximálním počtem v&nbsp;dané chvíli čekajících zpráv). Některá propojení
mohou mít kapacitu nastavenou na nulu; zde na sebe budou procesy čekat a
navzájem se tak do jisté míry synchronizovat.</p>

<p>Porty jsou pojmenované popř.&nbsp;je možné pracovat s&nbsp;polem portů.
Důležitým konceptem FBP je právě oddělení procesů od jejich propojení &ndash;
proces typicky neví, odkud získává a kam posílá data, protože proces je
&bdquo;jen&ldquo; uzlem v&nbsp;síti. Teprve konfigurací sítě se zvolí potřebná
propojení.</p>

<p><div class="rs-tip-major">Poznámka: příklad velmi jednoduché sítě
s&nbsp;několika komunikujícími procesy lze najít například na <a
href="https://jpaulm.github.io/fbp/EB2a.jpg">https://jpaulm.github.io/fbp/EB2a.jpg</a>.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Buffery s&nbsp;pevnou kapacitou a neomezené fronty</h2>

<p>Víme již, že jednotlivé procesy jsou při využití FBP propojeny přes porty.
Porty jsou pojmenovány a při deklaraci sítě propojující jednotlivé procesy přes
porty se používají právě jména portů, což ostatně uvidíme dále na
demonstračních příkladech:</p>

<pre>
<i>// propojení dvou uzlů</i>
n.Connect("converter", "Out", "printer", "Message")
</pre>

<p><div class="rs-tip-major">Poznámka: výše uvedeným příkazem došlo
k&nbsp;propojení mezi procesem se jménem <strong>converter</strong> a procesem
se jménem <strong>printer</strong>. Na straně prvního procesu se použil port
<strong>Out</strong> a na straně druhého procesu pak port
<strong>Message</strong>.</div></p>

<p>Posílání zpráv je v&nbsp;tomto případě &bdquo;potvrzováno&ldquo; &ndash;
přijímací proces musí data skutečně přečíst. Dokud k&nbsp;přečtení nedojde,
bude první (posílající) proces pozastaven. To však ve skutečnosti není
asynchronní chování. Aby se zajistila asynchronicita (a tím pádem nepřímo i
lepší využití dostupných prostředků &ndash; CPU atd.), je nutné, aby mezi oba
komunikační porty byl vložen buffer nebo fronta. Typicky se setkáme
s&nbsp;bufferem s&nbsp;omezenou kapacitou. Interně se může jednat například o
cyklickou frontu (<i>circular buffer</i>) realizovanou buď s&nbsp;využitím pole
(kapacita se nemění) nebo jednosměrně vázaného cyklického seznamu (kapacitu lze
zvyšovat na základě dynamických požadavků aplikace):</p>

<pre>
<i>// propojení dvou uzlů</i>
n.ConnectBuf("converter", "Out1", "printer1", "Message", BufferCapacity)
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vizuální návrh sítě</h2>

<p>Pro návrh sítí procesů a portů, které tvoří součást FBP, se typicky
používají nástroje určené pro vizuální tvorbu a následnou úpravu sítí. Těchto
nástrojů dnes existuje minimálně několik desítek a některé z&nbsp;nich dokáží
síť nejenom navrhnout, ale i exportovat do podoby zdrojového kódu (typicky
v&nbsp;Javě). Příkladem velmi jednoduchého editoru FBP je nástroj nazvaný
<strong>DrawFBP</strong>, jehož zdrojové kódy (v&nbsp;Javě) i spustitelný Java
archiv (JAR) jsou dostupné na adrese <a
href="https://github.com/jpaulm/drawfbp">https://github.com/jpaulm/drawfbp</a>.
Tento nástroj slouží k&nbsp;návrhu sítě a popř.&nbsp;i k&nbsp;vygenerování
zdrojových kódů. Jeho ovládání je sice místy poněkud podivné (zejména se to
týká editace hran), ovšem stále se jedná o užitečnou aplikaci, k&nbsp;jejímuž
běhu je vyžadována pouze instalace JRE (běhového prostředí Javy).</p>

*** image ***
<p><i>Obrázek 1: Minimalisticky pojaté prostředí programu DrawFBP.</i></p>

*** image ***
<p><i>Obrázek 2: Dialog pro editaci informací o právě vloženém procesu.</i></p>

*** image ***
<p><i>Obrázek 3: Součástí projektu DrawFBP je i nápověda.</i></p>

*** image ***
<p><i>Obrázek 4: Konfigurační dialog projektu DrawFBP.</i></p>

<p>Jednou z&nbsp;předností DrawFBP je fakt, že dokáže vygenerovat XML
s&nbsp;popisem sítě, které lze dále zpracovat libovolnou knihovnou určenou pro
načítání a manipulaci s&nbsp;XML:</p>

<pre>
&lt;?xml version="1.0"?&gt;
&lt;drawfbp_file xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://github.com/jpaulm/drawfbp/blob/master/lib/drawfbp_file.xsd"&gt;
  &lt;net&gt;
    &lt;desc&gt;Click anywhere on selection area&lt;/desc&gt;
    &lt;blocks&gt;
      &lt;block&gt;
        &lt;x&gt; 520 &lt;/x&gt;
        &lt;y&gt; 320 &lt;/y&gt;
        &lt;id&gt; 2 &lt;/id&gt;
        &lt;type&gt;B&lt;/type&gt;
        &lt;width&gt;96&lt;/width&gt;
        &lt;height&gt;64&lt;/height&gt;
        &lt;description&gt;Splitter&lt;/description&gt;
        &lt;multiplex&gt;false&lt;/multiplex&gt;
        &lt;invisible&gt;false&lt;/invisible&gt;
        &lt;issubnet&gt;false&lt;/issubnet&gt;
      &lt;/block&gt;
      &lt;block&gt;
        &lt;x&gt; 336 &lt;/x&gt;
        &lt;y&gt; 320 &lt;/y&gt;
        &lt;id&gt; 4 &lt;/id&gt;
        &lt;type&gt;C&lt;/type&gt;
        &lt;width&gt;36&lt;/width&gt;
        &lt;height&gt;28&lt;/height&gt;
        &lt;description&gt;Message&lt;/description&gt;
        &lt;substreamsensitive&gt;false&lt;/substreamsensitive&gt;
        &lt;multiplex&gt;false&lt;/multiplex&gt;
        &lt;invisible&gt;false&lt;/invisible&gt;
        &lt;issubnet&gt;false&lt;/issubnet&gt;
      &lt;/block&gt;
      &lt;block&gt;
        &lt;x&gt; 712 &lt;/x&gt;
        &lt;y&gt; 360 &lt;/y&gt;
        &lt;id&gt; 7 &lt;/id&gt;
        &lt;type&gt;B&lt;/type&gt;
        &lt;width&gt;96&lt;/width&gt;
        &lt;height&gt;64&lt;/height&gt;
        &lt;description&gt;Converter 2&lt;/description&gt;
        &lt;multiplex&gt;false&lt;/multiplex&gt;
        &lt;invisible&gt;false&lt;/invisible&gt;
        &lt;issubnet&gt;false&lt;/issubnet&gt;
      &lt;/block&gt;
      &lt;block&gt;
        &lt;x&gt; 712 &lt;/x&gt;
        &lt;y&gt; 264 &lt;/y&gt;
        &lt;id&gt; 9 &lt;/id&gt;
        &lt;type&gt;B&lt;/type&gt;
        &lt;width&gt;96&lt;/width&gt;
        &lt;height&gt;64&lt;/height&gt;
        &lt;description&gt;Converter 1&lt;/description&gt;
        &lt;multiplex&gt;false&lt;/multiplex&gt;
        &lt;invisible&gt;false&lt;/invisible&gt;
        &lt;issubnet&gt;false&lt;/issubnet&gt;
      &lt;/block&gt;
      &lt;block&gt;
        &lt;x&gt; 880 &lt;/x&gt;
        &lt;y&gt; 264 &lt;/y&gt;
        &lt;id&gt; 11 &lt;/id&gt;
        &lt;type&gt;B&lt;/type&gt;
        &lt;width&gt;96&lt;/width&gt;
        &lt;height&gt;64&lt;/height&gt;
        &lt;description&gt;Printer 1&lt;/description&gt;
        &lt;multiplex&gt;false&lt;/multiplex&gt;
        &lt;invisible&gt;false&lt;/invisible&gt;
        &lt;issubnet&gt;false&lt;/issubnet&gt;
      &lt;/block&gt;
      &lt;block&gt;
        &lt;x&gt; 880 &lt;/x&gt;
        &lt;y&gt; 360 &lt;/y&gt;
        &lt;id&gt; 13 &lt;/id&gt;
        &lt;type&gt;B&lt;/type&gt;
        &lt;width&gt;96&lt;/width&gt;
        &lt;height&gt;64&lt;/height&gt;
        &lt;description&gt;Printer 2&lt;/description&gt;
        &lt;multiplex&gt;false&lt;/multiplex&gt;
        &lt;invisible&gt;false&lt;/invisible&gt;
        &lt;issubnet&gt;false&lt;/issubnet&gt;
      &lt;/block&gt;
    &lt;/blocks&gt;
    &lt;connections&gt;
      &lt;connection&gt;
        &lt;fromx&gt;354&lt;/fromx&gt;
        &lt;fromy&gt;320&lt;/fromy&gt;
        &lt;tox&gt;472&lt;/tox&gt;
        &lt;toy&gt;320&lt;/toy&gt;
        &lt;fromid&gt;4&lt;/fromid&gt;
        &lt;toid&gt;2&lt;/toid&gt;
        &lt;id&gt;2&lt;/id&gt;
        &lt;endsatline&gt;false&lt;/endsatline&gt;
        &lt;upstreamport&gt;OUT&lt;/upstreamport&gt;
        &lt;downstreamport&gt;IN&lt;/downstreamport&gt;
        &lt;capacity&gt;100&lt;/capacity&gt;
        &lt;segno&gt;0&lt;/segno&gt;
      &lt;/connection&gt;
      &lt;connection&gt;
        &lt;fromx&gt;568&lt;/fromx&gt;
        &lt;fromy&gt;304&lt;/fromy&gt;
        &lt;tox&gt;664&lt;/tox&gt;
        &lt;toy&gt;264&lt;/toy&gt;
        &lt;fromid&gt;2&lt;/fromid&gt;
        &lt;toid&gt;9&lt;/toid&gt;
        &lt;id&gt;11&lt;/id&gt;
        &lt;endsatline&gt;false&lt;/endsatline&gt;
        &lt;upstreamport&gt;OUT1&lt;/upstreamport&gt;
        &lt;downstreamport&gt;IN&lt;/downstreamport&gt;
        &lt;capacity&gt;100&lt;/capacity&gt;
        &lt;segno&gt;0&lt;/segno&gt;
      &lt;/connection&gt;
      &lt;connection&gt;
        &lt;fromx&gt;568&lt;/fromx&gt;
        &lt;fromy&gt;336&lt;/fromy&gt;
        &lt;tox&gt;664&lt;/tox&gt;
        &lt;toy&gt;360&lt;/toy&gt;
        &lt;fromid&gt;2&lt;/fromid&gt;
        &lt;toid&gt;7&lt;/toid&gt;
        &lt;id&gt;12&lt;/id&gt;
        &lt;endsatline&gt;false&lt;/endsatline&gt;
        &lt;upstreamport&gt;OUT2&lt;/upstreamport&gt;
        &lt;downstreamport&gt;IN&lt;/downstreamport&gt;
        &lt;capacity&gt;100&lt;/capacity&gt;
        &lt;segno&gt;0&lt;/segno&gt;
      &lt;/connection&gt;
      &lt;connection&gt;
        &lt;fromx&gt;760&lt;/fromx&gt;
        &lt;fromy&gt;264&lt;/fromy&gt;
        &lt;tox&gt;832&lt;/tox&gt;
        &lt;toy&gt;264&lt;/toy&gt;
        &lt;fromid&gt;9&lt;/fromid&gt;
        &lt;toid&gt;11&lt;/toid&gt;
        &lt;id&gt;13&lt;/id&gt;
        &lt;endsatline&gt;false&lt;/endsatline&gt;
        &lt;upstreamport&gt;OUT&lt;/upstreamport&gt;
        &lt;downstreamport&gt;IN&lt;/downstreamport&gt;
        &lt;segno&gt;0&lt;/segno&gt;
      &lt;/connection&gt;
      &lt;connection&gt;
        &lt;fromx&gt;760&lt;/fromx&gt;
        &lt;fromy&gt;360&lt;/fromy&gt;
        &lt;tox&gt;832&lt;/tox&gt;
        &lt;toy&gt;360&lt;/toy&gt;
        &lt;fromid&gt;7&lt;/fromid&gt;
        &lt;toid&gt;13&lt;/toid&gt;
        &lt;id&gt;14&lt;/id&gt;
        &lt;endsatline&gt;false&lt;/endsatline&gt;
        &lt;upstreamport&gt;OUT&lt;/upstreamport&gt;
        &lt;downstreamport&gt;IN&lt;/downstreamport&gt;
        &lt;segno&gt;0&lt;/segno&gt;
      &lt;/connection&gt;
    &lt;/connections&gt;
  &lt;/net&gt;
&lt;/drawfbp_file&gt;
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instalace knihovny <strong>goflow</strong></h2>

<p>Ve druhé části dnešního článku si ukážeme základní způsoby použití knihovny
nazvané <strong>goflow</strong>. Jedná se o knihovnu, která umožňuje využít
koncepty <i>FBP</i> v&nbsp;programovacím jazyce Go. Před použitím této knihovny
je pochopitelně nutné ji nainstalovat. Vytvoříme tedy prázdný projekt, a
následně &nbsp;rámci jeho adresáře provedeme instalaci zmíněné knihovny.</p>

<p>Vytvoření nového projektu se provede následovně:</p>

<pre>
$ <strong>go mod init flow1</strong>
&nbsp;
go: creating new go.mod: module flow1
</pre>

<p>Poté již postačuje přejít do adresáře s&nbsp;nově vytvořeným projektem a
nainstalovat knihovnu <strong>goflow</strong> příkazem:</p>

<pre>
$ <strong>go get -v -v github.com/trustmaster/goflow</strong>
&nbsp;
go: downloading github.com/trustmaster/goflow v0.0.0-20210928125717-b7d4fd465ab2
go: added github.com/trustmaster/goflow v0.0.0-20210928125717-b7d4fd465ab2
</pre>

<p>Od této chvíle bude možné ve všech projektech (psaných v&nbsp;Go) použít
tento import:</p>

<pre>
import (
        <strong>"github.com/trustmaster/goflow"</strong>
)
</pre>

<p><div class="rs-tip-major">Poznámka: existují dvě verze rozhraní této
knihovny, a to konkrétně verze 0 a verze 1. My si dnes popíšeme verzi 1, která
je mnohem jednodušší a minimalističtěji pojatá, než původní nulová
verze.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Jednoduchá síť s&nbsp;jediným uzlem</h2>

<p>Pokusme se nyní v&nbsp;programovém kódu (napsaném v&nbsp;Go) vytvořit
jednoduchou síť, která bude obsahovat jeden uzel se vstupním portem. Síť by
měla vypadat následovně:</p>

*** image ***
<p><i>Obrázek 5: Schéma sítě.</i></p>

<p>Nejprve nadefinujeme datovou strukturu představující uzel (proces). Ten má
přijímat zprávy, k&nbsp;čemuž se v&nbsp;knihovně <strong>goflow</strong>
používají kanály. Kanál pojmenujeme například <strong>Message</strong>:</p>

<pre>
<i>// Jediný typ uzlu v síti</i>
type Printer struct {
        <i>// vstupní port</i>
        Message &lt;-chan string
}
</pre>

<p>Dále je nutné nadefinovat metodu <strong>Process</strong> (bez parametrů
&ndash; je volána automaticky). V&nbsp;našem jednoduchém příkladu pouze
vypíšeme zprávy přečtené z&nbsp;kanálu:</p>

<pre>
<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) Process() {
        for message := range c.Message {
                fmt.Println(message)
        }
}
</pre>

<p>Nejdůležitější částí aplikace je definice samotné sítě. Nejprve vytvoříme
kostru prázdné sítě, poté do ní přidáme uzel (a pojmenujeme ho) a nakonec je
nutné nadefinovat vstupní port do uzlu (opět pojmenovaný a explicitně navázaný
na jméno kanálu):</p>

<pre>
<i>// konstrukce grafu</i>
n := goflow.NewGraph()
&nbsp;
<i>// přidání uzlu s procesem do grafu</i>
n.Add("printer", new(Printer))
&nbsp;
<i>// propojení uzlu s procesem</i>
n.MapInPort("Input", "printer", "Message")
</pre>

<p>Následně již můžeme vytvořit kanál pro vstupní zprávy posílané do sítě a
napojit ho na port pojmenovaný &bdquo;Input&ldquo; v&nbsp;předchozím
příkazu:</p>

<pre>
<i>// konstrukce kanálu</i>
channel := make(chan string)
net.SetInPort("Input", channel)
</pre>

<p>Spuštění celé sítě:</p>

<pre>
<i>// spuštění sítě</i>
<i>// (kanál bude použit pro čekání na její ukončení)</i>
wait := goflow.Run(net)
</pre>

<p>V&nbsp;této chvíli všechny procesy (v&nbsp;našem případě jediný proces)
čekají na data. Ta do sítě pošleme přes právě vytvořený kanál:</p>

<pre>
<i>// poslání několika zpráv do sítě</i>
channel &lt;- "Foo"
channel &lt;- "Bar"
channel &lt;- "Baz"
</pre>

<p>Nakonec je nutné činnost procesů ukončit a počkat na skutečné ukončení
zpracování dat:</p>

<pre>
<i>// žádost o ukončení činnosti sítě</i>
close(channel)
&nbsp;
<i>// čekání na ukončení činnosti sítě</i>
&lt;-wait
</pre>

<p><div class="rs-tip-major">Poznámka: celý postup vypadá dosti složitě a šlo
by ho bezpochyby vlastně realizovat přímo s&nbsp;využitím gorutin a kanálů.
Jeho přínos oceníme až ve chvíli, kdy bude síť mnohem rozsáhlejší.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Úplný zdrojový kód prvního demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního prvního demonstračního příkladu
(resp.&nbsp;přesněji řečeno celého projektu) lze nalézt na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_90/flow1/">https://github.com/tisnik/go-root/blob/master/article_90/flow1/</a>.
Samotný program vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/trustmaster/goflow"
)
&nbsp;
<i>// Jediný typ uzlu v síti</i>
type <strong>Printer</strong> struct {
        <i>// vstupní port</i>
        Message &lt;-chan string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) <strong>Process</strong>() {
        for message := range c.Message {
                fmt.Println(message)
        }
}
&nbsp;
<i>// Definice grafu sítě s aplikací</i>
func <strong>NewFlowApp</strong>() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer", new(Printer))
&nbsp;
        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "printer", "Message")
&nbsp;
        <i>// výsledný graf</i>
        return n
}
&nbsp;
func <strong>main</strong>() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()
&nbsp;
        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)
&nbsp;
        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)
&nbsp;
        <i>// poslání několika zpráv do sítě</i>
        channel &lt;- "Foo"
        channel &lt;- "Bar"
        channel &lt;- "Baz"
&nbsp;
        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)
&nbsp;
        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Nekorektní přímé rozvětvení v&nbsp;síti</h2>

<p>Pokusme se nyní programově nadefinovat následující síť, v&nbsp;níž je jeden
vstup posílán do dvou procesů:</p>

*** image ***
<p><i>Obrázek 6: Přímé rozvětvení v&nbsp;síti.</i></p>

<p>Teoreticky by to mělo být snadné:</p>

<pre>
<i>// přidání uzlu s procesem do grafu</i>
n.Add("printer", new(Printer))
&nbsp;
<i>// přidání uzlu s procesem do grafu</i>
n.Add("printer2", new(Printer))
&nbsp;
<i>// propojení uzlu s procesem</i>
n.MapInPort("Input", "printer", "Message")
&nbsp;
<i>// propojení uzlu s procesem</i>
n.MapInPort("Input", "printer2", "Message")
</pre>

<p>Můžeme se pokusit tuto část definice sítě zakomponovat do ucelené
aplikace:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/trustmaster/goflow"
)
&nbsp;
<i>// Jediný typ uzlu v síti</i>
type <strong>Printer</strong> struct {
        <i>// vstupní port</i>
        Message &lt;-chan string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) <strong>Process</strong>() {
        for message := range c.Message {
                fmt.Println(message)
        }
}
&nbsp;
<i>// Definice grafu sítě s aplikací</i>
func <strong>NewFlowApp</strong>() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer", new(Printer))
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer2", new(Printer))
&nbsp;
        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "printer", "Message")
&nbsp;
        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "printer2", "Message")
&nbsp;
        <i>// výsledný graf</i>
        return n
}
&nbsp;
func <strong>main</strong>() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()
&nbsp;
        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)
&nbsp;
        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)
&nbsp;
        <i>// poslání několika zpráv do sítě</i>
        channel &lt;- "Foo"
        channel &lt;- "Bar"
        channel &lt;- "Baz"
&nbsp;
        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)
&nbsp;
        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>

<p>Ovšem při ukončování aplikace dojde k&nbsp;chybě při pokusu o opakované
uzavření kanálů sloužících pro synchronizaci mezi gorutinami:</p>

<pre>
$ <strong>go run flow2.go </strong>
&nbsp;
Foo
Bar
Baz
fatal error: all goroutines are asleep - deadlock!
&nbsp;
goroutine 1 [chan receive]:
main.main()
        /home/ptisnovs/src/go/flow2/flow2.go:63 +0xbd
&nbsp;
goroutine 6 [semacquire]:
sync.runtime_Semacquire(0xc00007c240?)
        /opt/go/src/runtime/sema.go:56 +0x25
sync.(*WaitGroup).Wait(0xc00004a740?)
        /opt/go/src/sync/waitgroup.go:136 +0x52
github.com/trustmaster/goflow.(*Graph).Process(0xc00008a000)
        /home/ptisnovs/go/pkg/mod/github.com/trustmaster/goflow@v0.0.0-20210928125717-b7d4fd465ab2/graph.go:181 +0x19b
github.com/trustmaster/goflow.Run.func1()
        /home/ptisnovs/go/pkg/mod/github.com/trustmaster/goflow@v0.0.0-20210928125717-b7d4fd465ab2/component.go:19 +0x2b
created by github.com/trustmaster/goflow.Run
        /home/ptisnovs/go/pkg/mod/github.com/trustmaster/goflow@v0.0.0-20210928125717-b7d4fd465ab2/component.go:18 +0x98
&nbsp;
goroutine 7 [chan receive (nil chan)]:
main.(*Printer).Process(0x0?)
        /home/ptisnovs/src/go/flow2/flow2.go:16 +0x85
github.com/trustmaster/goflow.Run.func1()
        /home/ptisnovs/go/pkg/mod/github.com/trustmaster/goflow@v0.0.0-20210928125717-b7d4fd465ab2/component.go:19 +0x2b
created by github.com/trustmaster/goflow.Run
        /home/ptisnovs/go/pkg/mod/github.com/trustmaster/goflow@v0.0.0-20210928125717-b7d4fd465ab2/component.go:18 +0x98
&nbsp;
goroutine 8 [chan receive]:
github.com/trustmaster/goflow.(*Graph).Process.func1()
        /home/ptisnovs/go/pkg/mod/github.com/trustmaster/goflow@v0.0.0-20210928125717-b7d4fd465ab2/graph.go:175 +0x3a
created by github.com/trustmaster/goflow.(*Graph).Process
        /home/ptisnovs/go/pkg/mod/github.com/trustmaster/goflow@v0.0.0-20210928125717-b7d4fd465ab2/graph.go:174 +0x185
exit status 2
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Přidání procesu se vstupním a současně i výstupním portem</h2>

<p>Nyní celou síť upravíme takovým způsobem, že zprávy budou nejprve upraveny
v&nbsp;dalším uzlu (procesu) nazvaném <strong>Converter</strong>. Ten zprávy
převede na velká písmena:</p>

*** image ***
<p><i>Obrázek 7: Proces se vstupním a současně i výstupním portem.</i></p>

<p>Jedná se o proces s&nbsp;jedním vstupním a jedním výstupním kanálem, čemuž
odpovídá i deklarace datového typu (struktury) představujícího tento
proces:</p>

<pre>
<i>// Druhý typ uzlu v síti</i>
type <strong>Converter</strong> struct {
        <i>// vstupní port</i>
        In &lt;-chan string
&nbsp;
        <i>// výstupní port</i>
        Out chan&lt;- string
}
</pre>

<p><div class="rs-tip-major">Poznámka: kanály lze pochopitelně pojmenovat i
jinak.</div></p>

<p>Samotná funkce nového procesu je jednoduchá &ndash; každá zpráva načtená ze
vstupního kanálu je převedena na velká písmena a poslána do kanálu
výstupního:</p>

<pre>
<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanál</i>
func (c *Converter) <strong>Process</strong>() {
        for message := range c.In {
                converted := strings.ToUpper(message)
                c.Out &lt;- converted
        }
}
</pre>

<p>Nyní je nutné vytvořit graf a přidat do něj dva uzly &ndash; jeden typu
<strong>Converter</strong> a druhý typu <strong>Printer</strong>:</p>

<pre>
<i>// konstrukce grafu</i>
n := goflow.NewGraph()
&nbsp;
<i>// přidání uzlu s procesem do grafu</i>
n.Add("converter", new(Converter))
&nbsp;
<i>// přidání uzlu s procesem do grafu</i>
n.Add("printer", new(Printer))
</pre>

<p>Následuje propojení obou uzlů, konkrétně kanálů <strong>Out</strong> uzlu
<strong>converter</strong> s&nbsp;kanálem <strong>Message</strong> uzlu
<strong>printer</strong> (to je v&nbsp;tomto příkladu novinka):</p>

<pre>
<i>// propojení dvou uzlů</i>
n.Connect("converter", "Out", "printer", "Message")
</pre>

<p>Definice vstupu do sítě již známe:</p>

<pre>
<i>// propojení uzlu s procesem</i>
n.MapInPort("Input", "converter", "In")
</pre>

<p>Po překladu a spuštění získáme tuto trojici zpráv zobrazených na standardním
výstupu, což ukazuje, že tok dat opravdu odpovídá nakonfigurované síti:</p>

<pre>
FOO
BAR
BAZ
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Úplný zdrojový kód třetího demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního třetího demonstračního příkladu
(resp.&nbsp;přesněji řečeno celého projektu) lze nalézt na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_90/flow3/">https://github.com/tisnik/go-root/blob/master/article_90/flow3/</a>.
Samotný program vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/trustmaster/goflow"
        "strings"
)
&nbsp;
<i>// První typ uzlu v síti</i>
type <strong>Printer</strong> struct {
        Message &lt;-chan string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) <strong>Process</strong>() {
        for message := range c.Message {
                fmt.Println(message)
        }
}
&nbsp;
<i>// Druhý typ uzlu v síti</i>
type <strong>Converter</strong> struct {
        <i>// vstupní port</i>
        In &lt;-chan string
&nbsp;
        <i>// výstupní port</i>
        Out chan&lt;- string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanál</i>
func (c *Converter) <strong>Process</strong>() {
        for message := range c.In {
                converted := strings.ToUpper(message)
                c.Out &lt;- converted
        }
}
&nbsp;
<i>// Definice grafu sítě s aplikací</i>
func <strong>NewFlowApp</strong>() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("converter", new(Converter))
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer", new(Printer))
&nbsp;
        <i>// propojení dvou uzlů</i>
        n.Connect("converter", "Out", "printer", "Message")
&nbsp;
        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "converter", "In")
&nbsp;
        <i>// výsledný graf</i>
        return n
}
&nbsp;
func <strong>main</strong>() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()
&nbsp;
        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)
&nbsp;
        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)
&nbsp;
        <i>// poslání několika zpráv do sítě</i>
        channel &lt;- "Foo"
        channel &lt;- "Bar"
        channel &lt;- "Baz"
&nbsp;
        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)
&nbsp;
        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Proces se dvěma výstupními porty</h2>

<p>Počet vstupních nebo výstupních portů u každého procesu není prakticky
žádným způsobem omezen, takže si v&nbsp;rámci této kapitoly ukážeme, jak lze
nadefinovat proces s&nbsp;dvojicí výstupních portů pojmenovaných jednoduše
<strong>Out1</strong> a <strong>Out2</strong>:</p>

*** image ***
<p><i>Obrázek 8: Proces se dvěma výstupními porty.</i></p>

<p>Vidíme, že bude nutné upravit struktur <strong>Converter</strong> tak, aby
obsahovala dva výstupní kanály:</p>

<pre>
type <strong>Converter</strong> struct {
        <i>// vstupní port</i>
        In &lt;-chan string
&nbsp;
        <i>// první výstupní port</i>
        Out1 chan&lt;- string
&nbsp;
        <i>// druhý výstupní port</i>
        Out2 chan&lt;- string
}
</pre>

<p>Upravíme i chování procesu <strong>Converter</strong>, například tak, že
bude vytvářet dvě zprávy (každou s&nbsp;jiným obsahem) a pošle je do obou
výstupních kanálů (portů). Ve skutečnosti však záleží pouze na procesu, jaká
data a kam bude posílat. Například může rozhodovat o tom, zda je vstupní zpráva
relevantní pro externí zákazníky či pro interní administrátory a podle toho se
rozhodnout, kam výsledek poslat atd.:</p>

<pre>
func (c *Converter) <strong>Process</strong>() {
        for message := range c.In {
                converted := "to upper case: " + strings.ToUpper(message)
                c.Out1 &lt;- converted
&nbsp;
                converted = "to lower case: " + strings.ToLower(message)
                c.Out2 &lt;- converted
        }
}
</pre>

<p>Definice sítě s&nbsp;procesy a jejich propojeními bude nepatrně složitější,
než je tomu v&nbsp;předchozích příkladech. Síť bude nyní obsahovat trojici
uzlů:</p>

<pre>
<i>// konstrukce grafu</i>
n := goflow.NewGraph()
&nbsp;
<i>// přidání uzlu s procesem do grafu</i>
n.Add("converter", new(Converter))
&nbsp;
<i>// přidání uzlu s procesem do grafu</i>
n.Add("printer1", new(Printer))
&nbsp;
<i>// přidání uzlu s procesem do grafu</i>
n.Add("printer2", new(Printer))
</pre>

<p>Uzel <strong>Converter</strong> bude přes svoji dvojici výstupních portů
propojen se dvěma uzly <strong>Printer</strong>:</p>

<pre>
<i>// propojení dvou uzlů</i>
n.Connect("converter", "Out1", "printer1", "Message")
&nbsp;
<i>// propojení dvou uzlů</i>
n.Connect("converter", "Out2", "printer2", "Message")
&nbsp;
<i>// propojení uzlu s procesem</i>
n.MapInPort("Input", "converter", "In")
</pre>

<p><div class="rs-tip-major">Poznámka: již na tomto příkladu může být patrná
poměrně velká flexibilita, kterou jsme získali oddělením procesů od jejich
propojení.</div></p>

<p>Chování příkladu po spuštění celé sítě, kdy se budou jednotlivé procesy
<strong>Printer</strong> střídat v&nbsp;tisku zpráv, které dostávají:</p>

<pre>
to upper case: FOO
to upper case: BAR
to lower case: foo
to lower case: bar
to lower case: baz
to upper case: BAZ
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Úplný zdrojový kód čtvrtého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu
(resp.&nbsp;přesněji řečeno celého projektu) lze nalézt na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_90/flow4/">https://github.com/tisnik/go-root/blob/master/article_90/flow4/</a>.
Samotný program vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/trustmaster/goflow"
        "strings"
)
&nbsp;
<i>// První typ uzlu v síti</i>
type <strong>Printer</strong> struct {
        Message &lt;-chan string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) <strong>Process</strong>() {
        for message := range c.Message {
                fmt.Println(message)
        }
}
&nbsp;
<i>// Druhý typ uzlu v síti</i>
type <strong>Converter</strong> struct {
        <i>// vstupní port</i>
        In &lt;-chan string
&nbsp;
        <i>// první výstupní port</i>
        Out1 chan&lt;- string
&nbsp;
        <i>// druhý výstupní port</i>
        Out2 chan&lt;- string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanály</i>
func (c *Converter) <strong>Process</strong>() {
        for message := range c.In {
                converted := "to upper case: " + strings.ToUpper(message)
                c.Out1 &lt;- converted
&nbsp;
                converted = "to lower case: " + strings.ToLower(message)
                c.Out2 &lt;- converted
        }
}
&nbsp;
<i>// Definice grafu sítě s aplikací</i>
func <strong>NewFlowApp</strong>() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("converter", new(Converter))
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer1", new(Printer))
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer2", new(Printer))
&nbsp;
        <i>// propojení dvou uzlů</i>
        n.Connect("converter", "Out1", "printer1", "Message")
&nbsp;
        <i>// propojení dvou uzlů</i>
        n.Connect("converter", "Out2", "printer2", "Message")
&nbsp;
        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "converter", "In")
&nbsp;
        <i>// výsledný graf</i>
        return n
}
&nbsp;
func <strong>main</strong>() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()
&nbsp;
        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)
&nbsp;
        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)
&nbsp;
        <i>// poslání několika zpráv do sítě</i>
        channel &lt;- "Foo"
        channel &lt;- "Bar"
        channel &lt;- "Baz"
&nbsp;
        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)
&nbsp;
        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Déletrvající výpočty</h2>

<p>Důležité je taktéž zjištění, jak se bude celá síť chovat v&nbsp;případě, že
nějaký proces bude obsahovat déletrvající výpočty (popř.&nbsp;komunikaci
s&nbsp;databází atd.). Takový proces můžeme simulovat snadno, a to zavoláním
funkce <strong>time.Sleep</strong>. Upravíme tedy komponentu
<strong>Printer</strong>, a to tak, že pokud bude zpráva začínat malým
písmenem, bude simulována akce trvající jednu sekundu. V&nbsp;opačném případě
skončí zpracování zprávy prakticky okamžitě:</p>

<pre>
func (c *Printer) <strong>Process</strong>() {
        for message := range c.Message {
                fmt.Println(message)
                if unicode.IsLower([]rune(message)[0]) {
                        time.Sleep(1 * time.Second)
                }
        }
}
</pre>

<p>Z&nbsp;výstupu získaného po spuštění celé sítě je patrné, že se oba procesy
typu <strong>Printer</strong> (tedy <strong>Printer1</strong> a
<strong>Printer2</strong>) ve výstupu střídají. To může vypadat podezřele
&ndash; vždyť jeden z&nbsp;procesů umí zprávu zpracovat prakticky ihned a
druhému to trvá celou sekundu. Problém spočívá v&nbsp;tom, že se při komunikaci
(propojení portů) nepoužívají buffery, resp.&nbsp;přesněji řečeno, že tyto
buffery mají nulovou kapacitu, takže poslání zprávy z&nbsp;procesu
<strong>Converter</strong> je provedeno s&nbsp;čekáním na její odebrání (a tedy
vlastně synchronně):</p>

<pre>
FOO
BAR
foo
bar
BAZ
baz
FOO
foo
BAR
bar
BAZ
baz
FOO
foo
BAR
bar
BAZ
baz
FOO
foo
BAR
bar
BAZ
</pre>

<p>Pro úplnost si uveďme celý demonstrační příklad, který se však až na zmíněné
volání <strong>time.Sleep</strong> neliší od příkladu předchozího:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/trustmaster/goflow"
        "strings"
        "time"
        "unicode"
)
&nbsp;
<i>// První typ uzlu v síti</i>
type <strong>Printer</strong> struct {
        Message &lt;-chan string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) <strong>Process</strong>() {
        for message := range c.Message {
                fmt.Println(message)
                if unicode.IsLower([]rune(message)[0]) {
                        time.Sleep(1 * time.Second)
                }
        }
}
&nbsp;
<i>// Druhý typ uzlu v síti</i>
type <strong>Converter</strong> struct {
        <i>// vstupní port</i>
        In &lt;-chan string
&nbsp;
        <i>// první výstupní port</i>
        Out1 chan&lt;- string
&nbsp;
        <i>// druhý výstupní port</i>
        Out2 chan&lt;- string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanály</i>
func (c *Converter) <strong>Process</strong>() {
        for message := range c.In {
                converted := strings.ToUpper(message)
                c.Out1 &lt;- converted
&nbsp;
                converted = strings.ToLower(message)
                c.Out2 &lt;- converted
        }
}
&nbsp;
<i>// Definice grafu sítě s aplikací</i>
func <strong>NewFlowApp</strong>() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("converter", new(Converter))
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer1", new(Printer))
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer2", new(Printer))
&nbsp;
        <i>// propojení dvou uzlů</i>
        n.Connect("converter", "Out1", "printer1", "Message")
&nbsp;
        <i>// propojení dvou uzlů</i>
        n.Connect("converter", "Out2", "printer2", "Message")
&nbsp;
        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "converter", "In")
&nbsp;
        <i>// výsledný graf</i>
        return n
}
&nbsp;
func <strong>main</strong>() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()
&nbsp;
        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)
&nbsp;
        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)
&nbsp;
        <i>// poslání několika zpráv do sítě</i>
        for i := 0; i &lt; 10; i++ {
                channel &lt;- "Foo"
                channel &lt;- "Bar"
                channel &lt;- "Baz"
        }
&nbsp;
        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)
&nbsp;
        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Využití bufferů pro komunikaci mezi procesy</h2>

<p>Ve <a href="#k03">třetí kapitole</a> jsme si řekli, že pro komunikaci mezi
procesy se velmi často používají buffery s&nbsp;předem známou kapacitou.
V&nbsp;grafu sítě se kapacita většinou zapisuje do kulatých závorek, tedy
následovně:</p>

*** image ***
<p><i>Obrázek 9: Využití bufferů.</i></p>

<p>Zajištění propojení s&nbsp;využitím bufferů je snadné. Nejdříve si
nakonfigurujeme kapacity bufferů (buď všech nebo jen vybraných komunikačních
cest):</p>

<pre>
<i>// Výchozí kapacita bufferů</i>
const BufferCapacity = 100
</pre>

<p>Následně se namísto přímého propojení stylem:</p>

<pre>
<i>// propojení dvou uzlů</i>
n.Connect("converter", "Out1", "printer1", "Message")
&nbsp;
<i>// propojení dvou uzlů</i>
n.Connect("converter", "Out2", "printer2", "Message")
</pre>

<p>Použije propojení s&nbsp;využitím bufferů:</p>

<pre>
<i>// propojení dvou uzlů</i>
n.ConnectBuf("converter", "Out1", "printer1", "Message", BufferCapacity)
&nbsp;
<i>// propojení dvou uzlů</i>
n.ConnectBuf("converter", "Out2", "printer2", "Message", BufferCapacity)
</pre>

<p>Lišit se ovšem bude chování celé sítě po jejím spuštění, protože nyní není
nutné v&nbsp;procesu <strong>converter</strong> čekat na jednotlivé procesy
<strong>printer1</strong> či <strong>printer2</strong>:</p>

<pre>
foo
FOO
BAR
BAZ
FOO
BAR
BAZ
FOO
BAR
BAZ
FOO
BAR
BAZ
FOO
BAR
BAZ
FOO
BAR
BAZ
FOO
BAR
BAZ
FOO
BAR
BAZ
FOO
BAR
BAZ
FOO
BAR
BAZ
bar
baz
foo
bar
...
...
...
(běží již jen <strong>printer2</strong>)
...
...
...
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Úplný zdrojový kód šestého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního šestého demonstračního příkladu
(resp.&nbsp;přesněji řečeno celého projektu) lze nalézt na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_90/flow6/">https://github.com/tisnik/go-root/blob/master/article_90/flow6/</a>.
Samotný program vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/trustmaster/goflow"
        "strings"
        "time"
        "unicode"
)
&nbsp;
<i>// Výchozí kapacita bufferů</i>
const BufferCapacity = 100
&nbsp;
<i>// První typ uzlu v síti</i>
type Printer struct {
        Message &lt;-chan string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) Process() {
        for message := range c.Message {
                fmt.Println(message)
                if unicode.IsLower([]rune(message)[0]) {
                        time.Sleep(1 * time.Second)
                }
        }
}
&nbsp;
<i>// Druhý typ uzlu v síti</i>
type Converter struct {
        <i>// vstupní port</i>
        In &lt;-chan string
&nbsp;
        <i>// první výstupní port</i>
        Out1 chan&lt;- string
&nbsp;
        <i>// druhý výstupní port</i>
        Out2 chan&lt;- string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanály</i>
func (c *Converter) Process() {
        for message := range c.In {
                converted := strings.ToUpper(message)
                c.Out1 &lt;- converted
&nbsp;
                converted = strings.ToLower(message)
                c.Out2 &lt;- converted
        }
}
&nbsp;
<i>// Definice grafu sítě s aplikací</i>
func NewFlowApp() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("converter", new(Converter))
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer1", new(Printer))
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer2", new(Printer))
&nbsp;
        <i>// propojení dvou uzlů</i>
        n.ConnectBuf("converter", "Out1", "printer1", "Message", BufferCapacity)
&nbsp;
        <i>// propojení dvou uzlů</i>
        n.ConnectBuf("converter", "Out2", "printer2", "Message", BufferCapacity)
&nbsp;
        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "converter", "In")
&nbsp;
        <i>// propojení uzlu s procesem</i>
&nbsp;
        <i>// výsledný graf</i>
        return n
}
&nbsp;
func <strong>main</strong>() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()
&nbsp;
        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)
&nbsp;
        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)
&nbsp;
        <i>// poslání několika zpráv do sítě</i>
        for i := 0; i &lt; 10; i++ {
                channel &lt;- "Foo"
                channel &lt;- "Bar"
                channel &lt;- "Baz"
        }
&nbsp;
        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)
&nbsp;
        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Uzel typu <strong>Splitter</strong> a <strong>Merger</strong></h2>

<p>Velmi často se při návrhu sítě setkáme s&nbsp;požadavkem na implementaci
&bdquo;výhybek&ldquo;, konkrétně uzlů, v&nbsp;nichž dochází k&nbsp;rozdvojení
(roztrojení...) zpráv a taktéž uzlů, které naopak dokážou propojit dva či více
toků zpráv do jediného toku. Tyto uzly se nazývají <strong>Splitter</strong> a
<strong>Merger</strong>. Buď je již implementuje příslušná knihovna či
framework, nebo se můžeme pokusit o jejich vlastní implementaci. Nejedná se o
nic složitého (minimálně v&nbsp;Go) &ndash; ostatně jednoduchou komponentu typu
<strong>Splitter</strong> lze nadeklarovat doslova na několika řádcích (a
využít lze v&nbsp;síti mnohokrát):</p>

<pre>
<i>// Druhý typ uzlu v síti</i>
type <strong>Splitter</strong> struct {
        <i>// vstupní port</i>
        In &lt;-chan string
&nbsp;
        <i>// první výstupní port</i>
        Out1 chan&lt;- string
&nbsp;
        <i>// druhý výstupní port</i>
        Out2 chan&lt;- string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Splitter) <strong>Process</strong>() {
        for message := range c.In {
                c.Out1 &lt;- message
                c.Out2 &lt;- message
        }
}
</pre>

*** image ***
<p><i>Obrázek 10: Uzel typu <strong>Splitter</strong>.</i></p>

<p><div class="rs-tip-major">Poznámka: komponentu typu <strong>Merger</strong>
si popíšeme příště.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Úplný zdrojový kód sedmého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního sedmého demonstračního příkladu
(resp.&nbsp;přesněji řečeno celého projektu) lze nalézt na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_90/flow7/">https://github.com/tisnik/go-root/blob/master/article_90/flow7/</a>.
Samotný program vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/trustmaster/goflow"
        "strings"
        "time"
        "unicode"
)
&nbsp;
<i>// Výchozí kapacita bufferů</i>
const BufferCapacity = 100
&nbsp;
<i>// První typ uzlu v síti</i>
type <strong>Printer</strong> struct {
        Message &lt;-chan string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) <strong>Process</strong>() {
        for message := range c.Message {
                fmt.Println(message)
                if unicode.IsLower([]rune(message)[0]) {
                        time.Sleep(1 * time.Second)
                }
        }
}
&nbsp;
<i>// Druhý typ uzlu v síti</i>
type <strong>Splitter</strong> struct {
        <i>// vstupní port</i>
        In &lt;-chan string
&nbsp;
        <i>// první výstupní port</i>
        Out1 chan&lt;- string
&nbsp;
        <i>// druhý výstupní port</i>
        Out2 chan&lt;- string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Splitter) <strong>Process</strong>() {
        for message := range c.In {
                c.Out1 &lt;- message
                c.Out2 &lt;- message
        }
}
&nbsp;
<i>// Třetí typ uzlu v síti</i>
type <strong>Converter1</strong> struct {
        <i>// vstupní port</i>
        In &lt;-chan string

        <i>// výstupní port</i>
        Out chan&lt;- string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanály</i>
func (c *Converter1) <strong>Process</strong>() {
        for message := range c.In {
                converted := strings.ToUpper(message)
                c.Out &lt;- converted
        }
}
&nbsp;
<i>// Čtvrtý typ uzlu v síti</i>
type <strong>Converter2</strong> struct {
        <i>// vstupní port</i>
        In &lt;-chan string
&nbsp;
        <i>// výstupní port</i>
        Out chan&lt;- string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanály</i>
func (c *Converter2) <strong>Process</strong>() {
        for message := range c.In {
                converted := strings.ToLower(message)
                c.Out &lt;- converted
        }
}
&nbsp;
<i>// Definice grafu sítě s aplikací</i>
func <strong>NewFlowApp</strong>() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("splitter", new(Splitter))
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("converter1", new(Converter1))
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("converter2", new(Converter2))
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer1", new(Printer))
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer2", new(Printer))
&nbsp;
        <i>// propojení dvou uzlů</i>
        n.ConnectBuf("splitter", "Out1", "converter1", "In", BufferCapacity)
&nbsp;
        <i>// propojení dvou uzlů</i>
        n.ConnectBuf("splitter", "Out2", "converter2", "In", BufferCapacity)
&nbsp;
        <i>// propojení dvou uzlů</i>
        n.ConnectBuf("converter1", "Out", "printer1", "Message", BufferCapacity)
&nbsp;
        <i>// propojení dvou uzlů</i>
        n.ConnectBuf("converter2", "Out", "printer2", "Message", BufferCapacity)
&nbsp;
        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "splitter", "In")
&nbsp;
        <i>// výsledný graf</i>
        return n
}
&nbsp;
func <strong>main</strong>() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()
&nbsp;
        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)
&nbsp;
        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)
&nbsp;
        <i>// poslání několika zpráv do sítě</i>
        for i := 0; i &lt; 10; i++ {
                channel &lt;- "Foo"
                channel &lt;- "Bar"
                channel &lt;- "Baz"
        }
&nbsp;
        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)
&nbsp;
        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah druhé části článku</h2>

<p>V&nbsp;navazujícím článku nejprve dokončíme popis možností nabízených
knihovnou <strong>goflow</strong>. Posléze se seznámíme s&nbsp;některými
alternativními knihovnami určenými pro použití v&nbsp;dalších programovacích
jazycích (například v&nbsp;Pythonu atd.).</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
nového Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně stovku kilobajtů), můžete namísto toho použít odkazy na jednotlivé
demonstrační příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad/soubor</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>flow1/</td><td>ukázka definice sítě s&nbsp;jediným uzlem</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow1/">https://github.com/tisnik/go-root/blob/master/article_90/flow1/</a></td></tr>
<tr><td> 2</td><td>flow2/</td><td>nekorektně vytvořená síť</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow2/">https://github.com/tisnik/go-root/blob/master/article_90/flow2/</a></td></tr>
<tr><td> 3</td><td>flow3/</td><td>síť s&nbsp;dvojicí uzlů</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow3/">https://github.com/tisnik/go-root/blob/master/article_90/flow3/</a></td></tr>
<tr><td> 4</td><td>flow4/</td><td>explicitní rozvětvení v&nbsp;síti</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow4/">https://github.com/tisnik/go-root/blob/master/article_90/flow4/</a></td></tr>
<tr><td> 5</td><td>flow5/</td><td>vliv zpoždění při zpracování dat</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow5/">https://github.com/tisnik/go-root/blob/master/article_90/flow5/</a></td></tr>
<tr><td> 6</td><td>flow6/</td><td>propojení uzlů přes buffery s&nbsp;kapacitou</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow6/">https://github.com/tisnik/go-root/blob/master/article_90/flow6/</a></td></tr>
<tr><td> 7</td><td>flow7/</td><td>složitější síť s&nbsp;explicitním <i>splitterem</i></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow7/">https://github.com/tisnik/go-root/blob/master/article_90/flow7/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Get into the flow<br />
<a href="https://appliedgo.net/flow/">https://appliedgo.net/flow/</a>
</li>

<li>Flow-based and dataflow programming library for Go programming language<br />
<a href="https://github.com/trustmaster/goflow">https://github.com/trustmaster/goflow</a>
</li>

<li>Flow-based programming (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Flow-based_programming">https://en.wikipedia.org/wiki/Flow-based_programming</a>
</li>

<li>FlowBasedProgramming (Python wiki)<br />
<a href="https://wiki.python.org/moin/FlowBasedProgramming">https://wiki.python.org/moin/FlowBasedProgramming</a>
</li>

<li>Flow Based Programming<br />
<a href="https://github.com/flowbased/flowbased.org/wiki">https://github.com/flowbased/flowbased.org/wiki</a>
</li>

<li>Concepts<br />
<a href="https://github.com/flowbased/flowbased.org/wiki/Concepts">https://github.com/flowbased/flowbased.org/wiki/Concepts</a>
</li>

<li>Circular buffer<br />
<a href="https://en.wikipedia.org/wiki/Circular_buffer">https://en.wikipedia.org/wiki/Circular_buffer</a>
</li>

<li>Circular Buffers in Linux kernel<br />
<a href="https://www.kernel.org/doc/html/latest/core-api/circular-buffers.html">https://www.kernel.org/doc/html/latest/core-api/circular-buffers.html</a>
</li>

<li>DrawFBP<br />
<a href="https://github.com/jpaulm/drawfbp">https://github.com/jpaulm/drawfbp</a>
</li>

<li>Panta Rhei<br />
<a href="https://blogs.bu.edu/marsh-vocation/2016/09/29/panta-rhei/">https://blogs.bu.edu/marsh-vocation/2016/09/29/panta-rhei/</a>
</li>

<li>Hérakleitos<br />
<a href="https://cs.wikipedia.org/wiki/H%C3%A9rakleitos">https://cs.wikipedia.org/wiki/H%C3%A9rakleitos</a>
</li>

<li>FlowBasedProgramming (Wiki)<br />
<a href="https://www.jpaulmorrison.com/cgi-bin/wiki.pl">https://www.jpaulmorrison.com/cgi-bin/wiki.pl</a>
</li>

<li>FBP Network Protocol<br />
<a href="https://flowbased.github.io/fbp-protocol/">https://flowbased.github.io/fbp-protocol/</a>
</li>

<li>Flow-based programming specification wiki<br />
<a href="https://flow-based.org/">https://flow-based.org/</a>
</li>

<li>Flow Based Programming<br />
<a href="http://wiki.c2.com/?FlowBasedProgramming">http://wiki.c2.com/?FlowBasedProgramming</a>
</li>

<li>FlowBasedProgramming<br />
<a href="http://www.jpaulmorrison.com/cgi-bin/wiki.pl">http://www.jpaulmorrison.com/cgi-bin/wiki.pl</a>
</li>

<li>BrokerageApplication<br />
<a href="http://www.jpaulmorrison.com/cgi-bin/wiki.pl?BrokerageApplication">http://www.jpaulmorrison.com/cgi-bin/wiki.pl?BrokerageApplication</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://go.dev/ref/spec">https://go.dev/ref/spec</a>
</li>

<li>Generics in Go<br />
<a href="https://bitfieldconsulting.com/golang/generics">https://bitfieldconsulting.com/golang/generics</a>
</li>

<li>Tutorial: Getting started with generics<br />
<a href="https://go.dev/doc/tutorial/generics">https://go.dev/doc/tutorial/generics</a>
</li>

<li>Type parameters in Go<br />
<a href="https://bitfieldconsulting.com/golang/type-parameters">https://bitfieldconsulting.com/golang/type-parameters</a>
</li>

<li>Go Data Structures: Binary Search Tree<br />
<a href="https://flaviocopes.com/golang-data-structure-binary-search-tree/">https://flaviocopes.com/golang-data-structure-binary-search-tree/</a>
</li>

<li>Gobs of data<br />
<a href="https://blog.golang.org/gobs-of-data">https://blog.golang.org/gobs-of-data</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Go 1.18 Release Notes<br />
<a href="https://golang.org/doc/go1.18">https://golang.org/doc/go1.18</a>
</li>

<li>Go 1.17 Release Notes<br />
<a href="https://golang.org/doc/go1.17">https://golang.org/doc/go1.17</a>
</li>

<li>Go 1.16 Release Notes<br />
<a href="https://golang.org/doc/go1.16">https://golang.org/doc/go1.16</a>
</li>

<li>Go 1.15 Release Notes<br />
<a href="https://golang.org/doc/go1.15">https://golang.org/doc/go1.15</a>
</li>

<li>Go 1.14 Release Notes<br />
<a href="https://golang.org/doc/go1.14">https://golang.org/doc/go1.14</a>
</li>

<li>Go 1.13 Release Notes<br />
<a href="https://golang.org/doc/go1.13">https://golang.org/doc/go1.13</a>
</li>

<li>Go 1.12 Release Notes<br />
<a href="https://golang.org/doc/go1.12">https://golang.org/doc/go1.12</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>A Proposal for Adding Generics to Go<br />
<a href="https://go.dev/blog/generics-proposal">https://go.dev/blog/generics-proposal</a>
</li>

<li>Proposal: Go should have generics<br />
<a href="https://github.com/golang/proposal/blob/master/design/15292-generics.md">https://github.com/golang/proposal/blob/master/design/15292-generics.md</a>
</li>

<li>Know Go: Generics (Kniha)<br />
<a href="https://bitfieldconsulting.com/books/generics">https://bitfieldconsulting.com/books/generics</a>
</li>

<li>Balíček constraints<br />
<a href="https://pkg.go.dev/golang.org/x/exp/constraints">https://pkg.go.dev/golang.org/x/exp/constraints</a>
</li>

<li>What are the libraries/tools you missed from other programming languages in Golang?<br />
<a href="https://www.quora.com/What-are-the-libraries-tools-you-missed-from-other-programming-languages-in-Golang?share=1">https://www.quora.com/What-are-the-libraries-tools-you-missed-from-other-programming-languages-in-Golang?share=1</a>
</li>

<li>Golang Has Generics—Why I Don't Miss Generics Anymore<br />
<a href="https://blog.jonathanoliver.com/golang-has-generics/">https://blog.jonathanoliver.com/golang-has-generics/</a>
</li>

<li>Go 1.18 Generics based slice package<br />
<a href="https://golangexample.com/go-1-18-generics-based-slice-package/">https://golangexample.com/go-1-18-generics-based-slice-package/</a>
</li>

<li>The missing slice package<br />
<a href="https://github.com/ssoroka/slice">https://github.com/ssoroka/slice</a>
</li>

<li>Methods in Go (part I)<br />
<a href="https://medium.com/golangspec/methods-in-go-part-i-a4e575dff860">https://medium.com/golangspec/methods-in-go-part-i-a4e575dff860</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

