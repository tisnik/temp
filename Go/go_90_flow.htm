<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. </a></p>
<p><a href="#k03">*** 3. Buffery s&nbsp;pevnou kapacitou a neomezené fronty</a></p>
<p><a href="#k04">4. Vizuální návrh sítě</a></p>
<p><a href="#k05">5. Instalace knihovny <strong>goflow</strong></a></p>
<p><a href="#k06">6. Jednoduchá síť s&nbsp;jediným uzlem</a></p>
<p><a href="#k07">7. Úplný zdrojový kód prvního demonstračního příkladu</a></p>
<p><a href="#k08">8. Nekorektní přímé rozvětvení v&nbsp;síti</a></p>
<p><a href="#k09">9. Přidání procesu se vstupním a současně i výstupním portem</a></p>
<p><a href="#k10">10. Úplný zdrojový kód třetího demonstračního příkladu</a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">18. Obsah druhé části článku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<p><i>&bdquo;τὰ πάντα ῥεῖ καὶ οὐδὲν μένει: everything flows, and nothing stays&ldquo;<br />
Hérakleitos</i></p>

klasický pohled na aplikace jako na sekvenční proces
vs. asynchronně běžící procesy

Because FBP processes can continue executing as long they have data to work on and somewhere to put their output



<p><a name="k02"></a></p>
<h2 id="k02">2. </h2>

<p><i>&bdquo;The real world is asynchronous: don't try to force everything into
a synchronous framework derived from the architecture of early
computers.&ldquo;<br />
J. Paul Morrison, inventor/discoverer of Flow-Based Programming</i></p>

Komponenty jsou základní stavební bloky
Interně se typicky jedná o třídy, funkce popř. uzávěry atd.

Procesy - instance komponent umístěné do grafu
Spojení (connections) - procesy komunikují přes spojení
propojení přes porty. Buffery nebo fronty (FIFO)
connection Capacity - buffery
někdy lze propojení realizovat s 0 kapacitou - přímá komunikace

Porty - pojmenované popř. indexované při použití pole portů
vstupní port: READ/RECEIVE
typicky propojení více výstupních portů na jeden vstupní port
výstupní port: SEND

The network definition is usually diagrammatic, and is converted into a connection list in some lower-level language or notation. FBP is often a visual programming language at this level.

merging/splitting

https://i.iinfo.cz/r/photos/opengl/opengl_11_3.gif



<p><a name="k03"></a></p>
<h2 id="k03">3. Buffery s&nbsp;pevnou kapacitou a neomezené fronty</h2>

<p></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vizuální návrh sítě</h2>

<p>Pro návrh sítí procesů a portů, které tvoří součást FBP, se typicky
používají nástroje určené pro vizuální tvorbu a následnou úpravu sítí. Těchto
nástrojů dnes existuje minimálně několik desítek a některé z&nbsp;nich dokáží
síť nejenom navrhnout, ale i exportovat do podoby zdrojového kódu (typicky
v&nbsp;Javě). Příkladem velmi jednoduchého editoru FBP je nástroj nazvaný
<strong>DrawFBP</strong>, jehož zdrojové kódy (v&nbsp;Javě) i spustitelný Java
archiv (JAR) jsou dostupné na adrese <a
href="https://github.com/jpaulm/drawfbp">https://github.com/jpaulm/drawfbp</a>.
Tento nástroj slouží k&nbsp;návrhu sítě a popř.&nbsp;i k&nbsp;vygenerování
zdrojových kódů. Jeho ovládání je sice místy poněkud podivné (zejména se to
týká editace hran), ovšem stále se jedná o užitečnou aplikaci, k&nbsp;jejímuž
běhu je vyžadována pouze instalace JRE (běhového prostředí Javy).</p>

*** image ***
<p><i>Obrázek 1: Minimalisticky pojaté prostředí programu DrawFBP.</i></p>

*** image ***
<p><i>Obrázek 2: Dialog pro editaci informací o právě vloženém procesu.</i></p>

*** image ***
<p><i>Obrázek 3: Součástí projektu DrawFBP je i nápověda.</i></p>

*** image ***
<p><i>Obrázek 4: Konfigurační dialog projektu DrawFBP.</i></p>

<p>Jednou z&nbsp;předností DrawFBP je fakt, že dokáže vygenerovat XML
s&nbsp;popisem sítě, které lze dále zpracovat libovolnou knihovnou určenou pro
načítání a manipulaci s&nbsp;XML:</p>

<pre>
&lt;?xml version="1.0"?&gt;
&lt;drawfbp_file xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://github.com/jpaulm/drawfbp/blob/master/lib/drawfbp_file.xsd"&gt;
  &lt;net&gt;
    &lt;desc&gt;Click anywhere on selection area&lt;/desc&gt;
    &lt;blocks&gt;
      &lt;block&gt;
        &lt;x&gt; 520 &lt;/x&gt;
        &lt;y&gt; 320 &lt;/y&gt;
        &lt;id&gt; 2 &lt;/id&gt;
        &lt;type&gt;B&lt;/type&gt;
        &lt;width&gt;96&lt;/width&gt;
        &lt;height&gt;64&lt;/height&gt;
        &lt;description&gt;Splitter&lt;/description&gt;
        &lt;multiplex&gt;false&lt;/multiplex&gt;
        &lt;invisible&gt;false&lt;/invisible&gt;
        &lt;issubnet&gt;false&lt;/issubnet&gt;
      &lt;/block&gt;
      &lt;block&gt;
        &lt;x&gt; 336 &lt;/x&gt;
        &lt;y&gt; 320 &lt;/y&gt;
        &lt;id&gt; 4 &lt;/id&gt;
        &lt;type&gt;C&lt;/type&gt;
        &lt;width&gt;36&lt;/width&gt;
        &lt;height&gt;28&lt;/height&gt;
        &lt;description&gt;Message&lt;/description&gt;
        &lt;substreamsensitive&gt;false&lt;/substreamsensitive&gt;
        &lt;multiplex&gt;false&lt;/multiplex&gt;
        &lt;invisible&gt;false&lt;/invisible&gt;
        &lt;issubnet&gt;false&lt;/issubnet&gt;
      &lt;/block&gt;
      &lt;block&gt;
        &lt;x&gt; 712 &lt;/x&gt;
        &lt;y&gt; 360 &lt;/y&gt;
        &lt;id&gt; 7 &lt;/id&gt;
        &lt;type&gt;B&lt;/type&gt;
        &lt;width&gt;96&lt;/width&gt;
        &lt;height&gt;64&lt;/height&gt;
        &lt;description&gt;Converter 2&lt;/description&gt;
        &lt;multiplex&gt;false&lt;/multiplex&gt;
        &lt;invisible&gt;false&lt;/invisible&gt;
        &lt;issubnet&gt;false&lt;/issubnet&gt;
      &lt;/block&gt;
      &lt;block&gt;
        &lt;x&gt; 712 &lt;/x&gt;
        &lt;y&gt; 264 &lt;/y&gt;
        &lt;id&gt; 9 &lt;/id&gt;
        &lt;type&gt;B&lt;/type&gt;
        &lt;width&gt;96&lt;/width&gt;
        &lt;height&gt;64&lt;/height&gt;
        &lt;description&gt;Converter 1&lt;/description&gt;
        &lt;multiplex&gt;false&lt;/multiplex&gt;
        &lt;invisible&gt;false&lt;/invisible&gt;
        &lt;issubnet&gt;false&lt;/issubnet&gt;
      &lt;/block&gt;
      &lt;block&gt;
        &lt;x&gt; 880 &lt;/x&gt;
        &lt;y&gt; 264 &lt;/y&gt;
        &lt;id&gt; 11 &lt;/id&gt;
        &lt;type&gt;B&lt;/type&gt;
        &lt;width&gt;96&lt;/width&gt;
        &lt;height&gt;64&lt;/height&gt;
        &lt;description&gt;Printer 1&lt;/description&gt;
        &lt;multiplex&gt;false&lt;/multiplex&gt;
        &lt;invisible&gt;false&lt;/invisible&gt;
        &lt;issubnet&gt;false&lt;/issubnet&gt;
      &lt;/block&gt;
      &lt;block&gt;
        &lt;x&gt; 880 &lt;/x&gt;
        &lt;y&gt; 360 &lt;/y&gt;
        &lt;id&gt; 13 &lt;/id&gt;
        &lt;type&gt;B&lt;/type&gt;
        &lt;width&gt;96&lt;/width&gt;
        &lt;height&gt;64&lt;/height&gt;
        &lt;description&gt;Printer 2&lt;/description&gt;
        &lt;multiplex&gt;false&lt;/multiplex&gt;
        &lt;invisible&gt;false&lt;/invisible&gt;
        &lt;issubnet&gt;false&lt;/issubnet&gt;
      &lt;/block&gt;
    &lt;/blocks&gt;
    &lt;connections&gt;
      &lt;connection&gt;
        &lt;fromx&gt;354&lt;/fromx&gt;
        &lt;fromy&gt;320&lt;/fromy&gt;
        &lt;tox&gt;472&lt;/tox&gt;
        &lt;toy&gt;320&lt;/toy&gt;
        &lt;fromid&gt;4&lt;/fromid&gt;
        &lt;toid&gt;2&lt;/toid&gt;
        &lt;id&gt;2&lt;/id&gt;
        &lt;endsatline&gt;false&lt;/endsatline&gt;
        &lt;upstreamport&gt;OUT&lt;/upstreamport&gt;
        &lt;downstreamport&gt;IN&lt;/downstreamport&gt;
        &lt;capacity&gt;100&lt;/capacity&gt;
        &lt;segno&gt;0&lt;/segno&gt;
      &lt;/connection&gt;
      &lt;connection&gt;
        &lt;fromx&gt;568&lt;/fromx&gt;
        &lt;fromy&gt;304&lt;/fromy&gt;
        &lt;tox&gt;664&lt;/tox&gt;
        &lt;toy&gt;264&lt;/toy&gt;
        &lt;fromid&gt;2&lt;/fromid&gt;
        &lt;toid&gt;9&lt;/toid&gt;
        &lt;id&gt;11&lt;/id&gt;
        &lt;endsatline&gt;false&lt;/endsatline&gt;
        &lt;upstreamport&gt;OUT1&lt;/upstreamport&gt;
        &lt;downstreamport&gt;IN&lt;/downstreamport&gt;
        &lt;capacity&gt;100&lt;/capacity&gt;
        &lt;segno&gt;0&lt;/segno&gt;
      &lt;/connection&gt;
      &lt;connection&gt;
        &lt;fromx&gt;568&lt;/fromx&gt;
        &lt;fromy&gt;336&lt;/fromy&gt;
        &lt;tox&gt;664&lt;/tox&gt;
        &lt;toy&gt;360&lt;/toy&gt;
        &lt;fromid&gt;2&lt;/fromid&gt;
        &lt;toid&gt;7&lt;/toid&gt;
        &lt;id&gt;12&lt;/id&gt;
        &lt;endsatline&gt;false&lt;/endsatline&gt;
        &lt;upstreamport&gt;OUT2&lt;/upstreamport&gt;
        &lt;downstreamport&gt;IN&lt;/downstreamport&gt;
        &lt;capacity&gt;100&lt;/capacity&gt;
        &lt;segno&gt;0&lt;/segno&gt;
      &lt;/connection&gt;
      &lt;connection&gt;
        &lt;fromx&gt;760&lt;/fromx&gt;
        &lt;fromy&gt;264&lt;/fromy&gt;
        &lt;tox&gt;832&lt;/tox&gt;
        &lt;toy&gt;264&lt;/toy&gt;
        &lt;fromid&gt;9&lt;/fromid&gt;
        &lt;toid&gt;11&lt;/toid&gt;
        &lt;id&gt;13&lt;/id&gt;
        &lt;endsatline&gt;false&lt;/endsatline&gt;
        &lt;upstreamport&gt;OUT&lt;/upstreamport&gt;
        &lt;downstreamport&gt;IN&lt;/downstreamport&gt;
        &lt;segno&gt;0&lt;/segno&gt;
      &lt;/connection&gt;
      &lt;connection&gt;
        &lt;fromx&gt;760&lt;/fromx&gt;
        &lt;fromy&gt;360&lt;/fromy&gt;
        &lt;tox&gt;832&lt;/tox&gt;
        &lt;toy&gt;360&lt;/toy&gt;
        &lt;fromid&gt;7&lt;/fromid&gt;
        &lt;toid&gt;13&lt;/toid&gt;
        &lt;id&gt;14&lt;/id&gt;
        &lt;endsatline&gt;false&lt;/endsatline&gt;
        &lt;upstreamport&gt;OUT&lt;/upstreamport&gt;
        &lt;downstreamport&gt;IN&lt;/downstreamport&gt;
        &lt;segno&gt;0&lt;/segno&gt;
      &lt;/connection&gt;
    &lt;/connections&gt;
  &lt;/net&gt;
&lt;/drawfbp_file&gt;
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instalace knihovny <strong>goflow</strong></h2>

<p>Ve druhé části dnešního článku si ukážeme základní způsoby použití knihovny
nazvané <strong>goflow</strong>. Jedná se o knihovnu, která umožňuje využít
koncepty <i>FBP</i> v&nbsp;programovacím jazyce Go. Před použitím této knihovny
je pochopitelně nutné ji nainstalovat. Vytvoříme tedy prázdný projekt, a
následně &nbsp;rámci jeho adresáře provedeme instalaci zmíněné knihovny.</p>

<p>Vytvoření nového projektu se provede následovně:</p>

<pre>
$ <strong>go mod init flow1</strong>
&nbsp;
go: creating new go.mod: module flow1
</pre>

<p>Poté již postačuje přejít do adresáře s&nbsp;nově vytvořeným projektem a
nainstalovat knihovnu <strong>goflow</strong> příkazem:</p>

<pre>
$ <strong>go get -v -v github.com/trustmaster/goflow</strong>
&nbsp;
go: downloading github.com/trustmaster/goflow v0.0.0-20210928125717-b7d4fd465ab2
go: added github.com/trustmaster/goflow v0.0.0-20210928125717-b7d4fd465ab2
</pre>

<p>Od této chvíle bude možné ve všech projektech (psaných v&nbsp;Go) použít
tento import:</p>

<pre>
import (
        <strong>"github.com/trustmaster/goflow"</strong>
)
</pre>

<p><div class="rs-tip-major">Poznámka: existují dvě verze rozhraní této
knihovny, a to konkrétně verze 0 a verze 1. My si dnes popíšeme verzi 1, která
je mnohem jednodušší a minimalističtěji pojatá, než původní nulová
verze.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Jednoduchá síť s&nbsp;jediným uzlem</h2>

<p>Pokusme se nyní v&nbsp;programovém kódu (napsaném v&nbsp;Go) vytvořit
jednoduchou síť, která bude obsahovat jeden uzel se vstupním portem. Síť by
měla vypadat následovně:</p>

*** image ***
<p><i>Obrázek 5: Schéma sítě.</i></p>

<p>Nejprve nadefinujeme datovou strukturu představující uzel (proces). Ten má
přijímat zprávy, k&nbsp;čemuž se v&nbsp;knihovně <strong>goflow</strong>
používají kanály. Kanál pojmenujeme například <strong>Message</strong>:</p>

<pre>
<i>// Jediný typ uzlu v síti</i>
type Printer struct {
        <i>// vstupní port</i>
        Message &lt;-chan string
}
</pre>

<p>Dále je nutné nadefinovat metodu <strong>Process</strong> (bez parametrů
&ndash; je volána automaticky). V&nbsp;našem jednoduchém příkladu pouze
vypíšeme zprávy přečtené z&nbsp;kanálu:</p>

<pre>
<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) Process() {
        for message := range c.Message {
                fmt.Println(message)
        }
}
</pre>

<p>Nejdůležitější částí aplikace je definice samotné sítě. Nejprve vytvoříme
kostru prázdné sítě, poté do ní přidáme uzel (a pojmenujeme ho) a nakonec je
nutné nadefinovat vstupní port do uzlu (opět pojmenovaný a explicitně navázaný
na jméno kanálu):</p>

<pre>
<i>// konstrukce grafu</i>
n := goflow.NewGraph()
&nbsp;
<i>// přidání uzlu s procesem do grafu</i>
n.Add("printer", new(Printer))
&nbsp;
<i>// propojení uzlu s procesem</i>
n.MapInPort("Input", "printer", "Message")
</pre>

<p>Následně již můžeme vytvořit kanál pro vstupní zprávy posílané do sítě a
napojit ho na port pojmenovaný &bdquo;Input&ldquo; v&nbsp;předchozím
příkazu:</p>

<pre>
<i>// konstrukce kanálu</i>
channel := make(chan string)
net.SetInPort("Input", channel)
</pre>

<p>Spuštění celé sítě:</p>

<pre>
<i>// spuštění sítě</i>
<i>// (kanál bude použit pro čekání na její ukončení)</i>
wait := goflow.Run(net)
</pre>

<p>V&nbsp;této chvíli všechny procesy (v&nbsp;našem případě jediný proces)
čekají na data. Ta do sítě pošleme přes právě vytvořený kanál:</p>

<pre>
<i>// poslání několika zpráv do sítě</i>
channel &lt;- "Foo"
channel &lt;- "Bar"
channel &lt;- "Baz"
</pre>

<p>Nakonec je nutné činnost procesů ukončit a počkat na skutečné ukončení
zpracování dat:</p>

<pre>
<i>// žádost o ukončení činnosti sítě</i>
close(channel)
&nbsp;
<i>// čekání na ukončení činnosti sítě</i>
&lt;-wait
</pre>

<p><div class="rs-tip-major">Poznámka: celý postup vypadá dosti složitě a šlo
by ho bezpochyby vlastně realizovat přímo s&nbsp;využitím gorutin a kanálů.
Jeho přínos oceníme až ve chvíli, kdy bude síť mnohem rozsáhlejší.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Úplný zdrojový kód prvního demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního prvního demonstračního příkladu
(resp.&nbsp;přesněji řečeno celého projektu) lze nalézt na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_90/flow1/">https://github.com/tisnik/go-root/blob/master/article_90/flow1/</a>.
Samotný program vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/trustmaster/goflow"
)
&nbsp;
<i>// Jediný typ uzlu v síti</i>
type <strong>Printer</strong> struct {
        <i>// vstupní port</i>
        Message &lt;-chan string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) <strong>Process</strong>() {
        for message := range c.Message {
                fmt.Println(message)
        }
}
&nbsp;
<i>// Definice grafu sítě s aplikací</i>
func <strong>NewFlowApp</strong>() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer", new(Printer))
&nbsp;
        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "printer", "Message")
&nbsp;
        <i>// výsledný graf</i>
        return n
}
&nbsp;
func <strong>main</strong>() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()
&nbsp;
        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)
&nbsp;
        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)
&nbsp;
        <i>// poslání několika zpráv do sítě</i>
        channel &lt;- "Foo"
        channel &lt;- "Bar"
        channel &lt;- "Baz"
&nbsp;
        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)
&nbsp;
        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Nekorektní přímé rozvětvení v&nbsp;síti</h2>

<p>Pokusme se nyní programově nadefinovat následující síť, v&nbsp;níž je jeden
vstup posílán do dvou procesů:</p>

*** image ***
<p><i>Obrázek 6: Přímé rozvětvení v&nbsp;síti.</i></p>

<p>Teoreticky by to mělo být snadné:</p>

<pre>
<i>// přidání uzlu s procesem do grafu</i>
n.Add("printer", new(Printer))
&nbsp;
<i>// přidání uzlu s procesem do grafu</i>
n.Add("printer2", new(Printer))
&nbsp;
<i>// propojení uzlu s procesem</i>
n.MapInPort("Input", "printer", "Message")
&nbsp;
<i>// propojení uzlu s procesem</i>
n.MapInPort("Input", "printer2", "Message")
</pre>

<p>Můžeme se pokusit tuto část definice sítě zakomponovat do ucelené
aplikace:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/trustmaster/goflow"
)
&nbsp;
<i>// Jediný typ uzlu v síti</i>
type <strong>Printer</strong> struct {
        <i>// vstupní port</i>
        Message &lt;-chan string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) <strong>Process</strong>() {
        for message := range c.Message {
                fmt.Println(message)
        }
}
&nbsp;
<i>// Definice grafu sítě s aplikací</i>
func <strong>NewFlowApp</strong>() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer", new(Printer))
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer2", new(Printer))
&nbsp;
        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "printer", "Message")
&nbsp;
        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "printer2", "Message")
&nbsp;
        <i>// výsledný graf</i>
        return n
}
&nbsp;
func <strong>main</strong>() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()
&nbsp;
        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)
&nbsp;
        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)
&nbsp;
        <i>// poslání několika zpráv do sítě</i>
        channel &lt;- "Foo"
        channel &lt;- "Bar"
        channel &lt;- "Baz"
&nbsp;
        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)
&nbsp;
        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>

<p>Ovšem při ukončování aplikace dojde k&nbsp;chybě při pokusu o opakované
uzavření kanálů sloužících pro synchronizaci mezi gorutinami:</p>

<pre>
$ <strong>go run flow2.go </strong>
&nbsp;
Foo
Bar
Baz
fatal error: all goroutines are asleep - deadlock!
&nbsp;
goroutine 1 [chan receive]:
main.main()
        /home/ptisnovs/src/go/flow2/flow2.go:63 +0xbd
&nbsp;
goroutine 6 [semacquire]:
sync.runtime_Semacquire(0xc00007c240?)
        /opt/go/src/runtime/sema.go:56 +0x25
sync.(*WaitGroup).Wait(0xc00004a740?)
        /opt/go/src/sync/waitgroup.go:136 +0x52
github.com/trustmaster/goflow.(*Graph).Process(0xc00008a000)
        /home/ptisnovs/go/pkg/mod/github.com/trustmaster/goflow@v0.0.0-20210928125717-b7d4fd465ab2/graph.go:181 +0x19b
github.com/trustmaster/goflow.Run.func1()
        /home/ptisnovs/go/pkg/mod/github.com/trustmaster/goflow@v0.0.0-20210928125717-b7d4fd465ab2/component.go:19 +0x2b
created by github.com/trustmaster/goflow.Run
        /home/ptisnovs/go/pkg/mod/github.com/trustmaster/goflow@v0.0.0-20210928125717-b7d4fd465ab2/component.go:18 +0x98
&nbsp;
goroutine 7 [chan receive (nil chan)]:
main.(*Printer).Process(0x0?)
        /home/ptisnovs/src/go/flow2/flow2.go:16 +0x85
github.com/trustmaster/goflow.Run.func1()
        /home/ptisnovs/go/pkg/mod/github.com/trustmaster/goflow@v0.0.0-20210928125717-b7d4fd465ab2/component.go:19 +0x2b
created by github.com/trustmaster/goflow.Run
        /home/ptisnovs/go/pkg/mod/github.com/trustmaster/goflow@v0.0.0-20210928125717-b7d4fd465ab2/component.go:18 +0x98
&nbsp;
goroutine 8 [chan receive]:
github.com/trustmaster/goflow.(*Graph).Process.func1()
        /home/ptisnovs/go/pkg/mod/github.com/trustmaster/goflow@v0.0.0-20210928125717-b7d4fd465ab2/graph.go:175 +0x3a
created by github.com/trustmaster/goflow.(*Graph).Process
        /home/ptisnovs/go/pkg/mod/github.com/trustmaster/goflow@v0.0.0-20210928125717-b7d4fd465ab2/graph.go:174 +0x185
exit status 2
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Přidání procesu se vstupním a současně i výstupním portem</h2>

<p>Nyní celou síť upravíme takovým způsobem, že zprávy budou nejprve upraveny
v&nbsp;dalším uzlu (procesu) nazvaném <strong>Converter</strong>. Ten zprávy
převede na velká písmena:</p>

*** image ***
<p><i>Obrázek 7: Proces se vstupním a současně i výstupním portem.</i></p>

<p>Jedná se o proces s&nbsp;jedním vstupním a jedním výstupním kanálem, čemuž
odpovídá i deklarace datového typu (struktury) představujícího tento
proces:</p>

<pre>
<i>// Druhý typ uzlu v síti</i>
type <strong>Converter</strong> struct {
        <i>// vstupní port</i>
        In &lt;-chan string
&nbsp;
        <i>// výstupní port</i>
        Out chan&lt;- string
}
</pre>

<p><div class="rs-tip-major">Poznámka: kanály lze pochopitelně pojmenovat i
jinak.</div></p>

<p>Samotná funkce nového procesu je jednoduchá &ndash; každá zpráva načtená ze
vstupního kanálu je převedena na velká písmena a poslána do kanálu
výstupního:</p>

<pre>
<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanál</i>
func (c *Converter) <strong>Process</strong>() {
        for message := range c.In {
                converted := strings.ToUpper(message)
                c.Out &lt;- converted
        }
}
</pre>

<p>Nyní je nutné vytvořit graf a přidat do něj dva uzly &ndash; jeden typu
<strong>Converter</strong> a druhý typu <strong>Printer</strong>:</p>

<pre>
<i>// konstrukce grafu</i>
n := goflow.NewGraph()
&nbsp;
<i>// přidání uzlu s procesem do grafu</i>
n.Add("converter", new(Converter))
&nbsp;
<i>// přidání uzlu s procesem do grafu</i>
n.Add("printer", new(Printer))
</pre>

<p>Následuje propojení obou uzlů, konkrétně kanálů <strong>Out</strong> uzlu
<strong>converter</strong> s&nbsp;kanálem <strong>Message</strong> uzlu
<strong>printer</strong> (to je v&nbsp;tomto příkladu novinka):</p>

<pre>
<i>// propojení dvou uzlů</i>
n.Connect("converter", "Out", "printer", "Message")
</pre>

<p>Definice vstupu do sítě již známe:</p>

<pre>
<i>// propojení uzlu s procesem</i>
n.MapInPort("Input", "converter", "In")
</pre>

<p>Po překladu a spuštění získáme tuto trojici zpráv zobrazených na standardním
výstupu, což ukazuje, že tok dat opravdu odpovídá nakonfigurované síti:</p>

<pre>
FOO
BAR
BAZ
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Úplný zdrojový kód třetího demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního prvního demonstračního příkladu
(resp.&nbsp;přesněji řečeno celého projektu) lze nalézt na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_90/flow3/">https://github.com/tisnik/go-root/blob/master/article_90/flow3/</a>.
Samotný program vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/trustmaster/goflow"
        "strings"
)
&nbsp;
<i>// První typ uzlu v síti</i>
type <strong>Printer</strong> struct {
        Message &lt;-chan string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) <strong>Process</strong>() {
        for message := range c.Message {
                fmt.Println(message)
        }
}
&nbsp;
<i>// Druhý typ uzlu v síti</i>
type <strong>Converter</strong> struct {
        <i>// vstupní port</i>
        In &lt;-chan string
&nbsp;
        <i>// výstupní port</i>
        Out chan&lt;- string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanál</i>
func (c *Converter) <strong>Process</strong>() {
        for message := range c.In {
                converted := strings.ToUpper(message)
                c.Out &lt;- converted
        }
}
&nbsp;
<i>// Definice grafu sítě s aplikací</i>
func <strong>NewFlowApp</strong>() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("converter", new(Converter))
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer", new(Printer))
&nbsp;
        <i>// propojení dvou uzlů</i>
        n.Connect("converter", "Out", "printer", "Message")
&nbsp;
        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "converter", "In")
&nbsp;
        <i>// výsledný graf</i>
        return n
}
&nbsp;
func <strong>main</strong>() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()
&nbsp;
        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)
&nbsp;
        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)
&nbsp;
        <i>// poslání několika zpráv do sítě</i>
        channel &lt;- "Foo"
        channel &lt;- "Bar"
        channel &lt;- "Baz"
&nbsp;
        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)
&nbsp;
        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<pre>
package <strong>main</strong>

import (
        "fmt"
        "github.com/trustmaster/goflow"
        "strings"
)

<i>// První typ uzlu v síti</i>
type Printer struct {
        Message &lt;-chan string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) Process() {
        for message := range c.Message {
                fmt.Println(message)
        }
}

<i>// Druhý typ uzlu v síti</i>
type Converter struct {
        <i>// vstupní port</i>
        In &lt;-chan string

        <i>// první výstupní port</i>
        Out1 chan&lt;- string

        <i>// druhý výstupní port</i>
        Out2 chan&lt;- string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanály</i>
func (c *Converter) Process() {
        for message := range c.In {
                converted := "to upper case: " + strings.ToUpper(message)
                c.Out1 &lt;- converted

                converted = "to lower case: " + strings.ToLower(message)
                c.Out2 &lt;- converted
        }
}

<i>// Definice grafu sítě s aplikací</i>
func NewFlowApp() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("converter", new(Converter))

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer1", new(Printer))

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer2", new(Printer))

        <i>// propojení dvou uzlů</i>
        n.Connect("converter", "Out1", "printer1", "Message")

        <i>// propojení dvou uzlů</i>
        n.Connect("converter", "Out2", "printer2", "Message")

        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "converter", "In")

        <i>// výsledný graf</i>
        return n
}

func <strong>main</strong>() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()

        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)

        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)

        <i>// poslání několika zpráv do sítě</i>
        channel &lt;- "Foo"
        channel &lt;- "Bar"
        channel &lt;- "Baz"

        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)

        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<pre>
package <strong>main</strong>

import (
        "fmt"
        "github.com/trustmaster/goflow"
        "strings"
        "time"
        "unicode"
)

<i>// První typ uzlu v síti</i>
type Printer struct {
        Message &lt;-chan string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) Process() {
        for message := range c.Message {
                fmt.Println(message)
                if unicode.IsLower([]rune(message)[0]) {
                        time.Sleep(1 * time.Second)
                }
        }
}

<i>// Druhý typ uzlu v síti</i>
type Converter struct {
        <i>// vstupní port</i>
        In &lt;-chan string

        <i>// první výstupní port</i>
        Out1 chan&lt;- string

        <i>// druhý výstupní port</i>
        Out2 chan&lt;- string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanály</i>
func (c *Converter) Process() {
        for message := range c.In {
                converted := strings.ToUpper(message)
                c.Out1 &lt;- converted

                converted = strings.ToLower(message)
                c.Out2 &lt;- converted
        }
}

<i>// Definice grafu sítě s aplikací</i>
func NewFlowApp() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("converter", new(Converter))

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer1", new(Printer))

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer2", new(Printer))

        <i>// propojení dvou uzlů</i>
        n.Connect("converter", "Out1", "printer1", "Message")

        <i>// propojení dvou uzlů</i>
        n.Connect("converter", "Out2", "printer2", "Message")

        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "converter", "In")

        <i>// výsledný graf</i>
        return n
}

func <strong>main</strong>() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()

        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)

        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)

        <i>// poslání několika zpráv do sítě</i>
        for i := 0; i &lt; 10; i++ {
                channel &lt;- "Foo"
                channel &lt;- "Bar"
                channel &lt;- "Baz"
        }

        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)

        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<pre>
package <strong>main</strong>

import (
        "fmt"
        "github.com/trustmaster/goflow"
        "strings"
        "time"
        "unicode"
)

<i>// Výchozí kapacita bufferů</i>
const BufferCapacity = 100

<i>// První typ uzlu v síti</i>
type Printer struct {
        Message &lt;-chan string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) Process() {
        for message := range c.Message {
                fmt.Println(message)
                if unicode.IsLower([]rune(message)[0]) {
                        time.Sleep(1 * time.Second)
                }
        }
}

<i>// Druhý typ uzlu v síti</i>
type Converter struct {
        <i>// vstupní port</i>
        In &lt;-chan string

        <i>// první výstupní port</i>
        Out1 chan&lt;- string

        <i>// druhý výstupní port</i>
        Out2 chan&lt;- string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanály</i>
func (c *Converter) Process() {
        for message := range c.In {
                converted := strings.ToUpper(message)
                c.Out1 &lt;- converted

                converted = strings.ToLower(message)
                c.Out2 &lt;- converted
        }
}

<i>// Definice grafu sítě s aplikací</i>
func NewFlowApp() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("converter", new(Converter))

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer1", new(Printer))

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer2", new(Printer))

        <i>// propojení dvou uzlů</i>
        n.ConnectBuf("converter", "Out1", "printer1", "Message", BufferCapacity)

        <i>// propojení dvou uzlů</i>
        n.ConnectBuf("converter", "Out2", "printer2", "Message", BufferCapacity)

        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "converter", "In")

        <i>// propojení uzlu s procesem</i>

        <i>// výsledný graf</i>
        return n
}

func <strong>main</strong>() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()

        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)

        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)

        <i>// poslání několika zpráv do sítě</i>
        for i := 0; i &lt; 10; i++ {
                channel &lt;- "Foo"
                channel &lt;- "Bar"
                channel &lt;- "Baz"
        }

        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)

        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/trustmaster/goflow"
        "strings"
        "time"
        "unicode"
)
&nbsp;
<i>// Výchozí kapacita bufferů</i>
const BufferCapacity = 100
&nbsp;
<i>// První typ uzlu v síti</i>
type Printer struct {
        Message &lt;-chan string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) Process() {
        for message := range c.Message {
                fmt.Println(message)
                if unicode.IsLower([]rune(message)[0]) {
                        time.Sleep(1 * time.Second)
                }
        }
}
&nbsp;
<i>// Druhý typ uzlu v síti</i>
type Splitter struct {
        <i>// vstupní port</i>
        In &lt;-chan string
&nbsp;
        <i>// první výstupní port</i>
        Out1 chan&lt;- string
&nbsp;
        <i>// druhý výstupní port</i>
        Out2 chan&lt;- string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Splitter) Process() {
        for message := range c.In {
                c.Out1 &lt;- message
                c.Out2 &lt;- message
        }
}
&nbsp;
<i>// Třetí typ uzlu v síti</i>
type Converter1 struct {
        <i>// vstupní port</i>
        In &lt;-chan string

        <i>// výstupní port</i>
        Out chan&lt;- string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanály</i>
func (c *Converter1) Process() {
        for message := range c.In {
                converted := strings.ToUpper(message)
                c.Out &lt;- converted
        }
}
&nbsp;
<i>// Čtvrtý typ uzlu v síti</i>
type Converter2 struct {
        <i>// vstupní port</i>
        In &lt;-chan string
&nbsp;
        <i>// výstupní port</i>
        Out chan&lt;- string
}
&nbsp;
<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanály</i>
func (c *Converter2) Process() {
        for message := range c.In {
                converted := strings.ToLower(message)
                c.Out &lt;- converted
        }
}
&nbsp;
<i>// Definice grafu sítě s aplikací</i>
func NewFlowApp() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("splitter", new(Splitter))
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("converter1", new(Converter1))
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("converter2", new(Converter2))
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer1", new(Printer))
&nbsp;
        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer2", new(Printer))
&nbsp;
        <i>// propojení dvou uzlů</i>
        n.ConnectBuf("splitter", "Out1", "converter1", "In", BufferCapacity)
&nbsp;
        <i>// propojení dvou uzlů</i>
        n.ConnectBuf("splitter", "Out2", "converter2", "In", BufferCapacity)
&nbsp;
        <i>// propojení dvou uzlů</i>
        n.ConnectBuf("converter1", "Out", "printer1", "Message", BufferCapacity)
&nbsp;
        <i>// propojení dvou uzlů</i>
        n.ConnectBuf("converter2", "Out", "printer2", "Message", BufferCapacity)
&nbsp;
        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "splitter", "In")
&nbsp;
        <i>// výsledný graf</i>
        return n
}
&nbsp;
func <strong>main</strong>() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()
&nbsp;
        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)
&nbsp;
        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)
&nbsp;
        <i>// poslání několika zpráv do sítě</i>
        for i := 0; i &lt; 10; i++ {
                channel &lt;- "Foo"
                channel &lt;- "Bar"
                channel &lt;- "Baz"
        }
&nbsp;
        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)
&nbsp;
        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah druhé části článku</h2>

<p>V&nbsp;navazujícím článku nejprve dokončíme popis možností nabízených
knihovnou <strong>goflow</strong>. Posléze se seznámíme s&nbsp;některými
alternativními knihovnami určenými pro použití v&nbsp;dalších programovacích
jazycích (například v&nbsp;Pythonu atd.).</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
nového Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně stovku kilobajtů), můžete namísto toho použít odkazy na jednotlivé
demonstrační příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad/soubor</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>flow1/</td><td>ukázka definice sítě s&nbsp;jediným uzlem</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow1/">https://github.com/tisnik/go-root/blob/master/article_90/flow1/</a></td></tr>
<tr><td> 2</td><td>flow2/</td><td>nekorektně vytvořená síť</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow2/">https://github.com/tisnik/go-root/blob/master/article_90/flow2/</a></td></tr>
<tr><td> 3</td><td>flow3/</td><td>síť s&nbsp;dvojicí uzlů</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow3/">https://github.com/tisnik/go-root/blob/master/article_90/flow3/</a></td></tr>
<tr><td> 4</td><td>flow4/</td><td>explicitní rozvětvení v&nbsp;síti</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow4/">https://github.com/tisnik/go-root/blob/master/article_90/flow4/</a></td></tr>
<tr><td> 5</td><td>flow5/</td><td>vliv zpoždění při zpracování dat</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow5/">https://github.com/tisnik/go-root/blob/master/article_90/flow5/</a></td></tr>
<tr><td> 6</td><td>flow6/</td><td>propojení uzlů přes buffery s&nbsp;kapacitou</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow6/">https://github.com/tisnik/go-root/blob/master/article_90/flow6/</a></td></tr>
<tr><td> 7</td><td>flow7/</td><td>složitější síť s&nbsp;explicitním <i>splitterem</i></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow7/">https://github.com/tisnik/go-root/blob/master/article_90/flow7/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Get into the flow<br />
<a href="https://appliedgo.net/flow/">https://appliedgo.net/flow/</a>
</li>

<li>Flow-based and dataflow programming library for Go programming language<br />
<a href="https://github.com/trustmaster/goflow">https://github.com/trustmaster/goflow</a>
</li>

<li>Flow-based programming (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Flow-based_programming">https://en.wikipedia.org/wiki/Flow-based_programming</a>
</li>

<li>FlowBasedProgramming (Python wiki)<br />
<a href="https://wiki.python.org/moin/FlowBasedProgramming">https://wiki.python.org/moin/FlowBasedProgramming</a>
</li>

<li>Flow Based Programming<br />
<a href="https://github.com/flowbased/flowbased.org/wiki">https://github.com/flowbased/flowbased.org/wiki</a>
</li>

<li>Concepts<br />
<a href="https://github.com/flowbased/flowbased.org/wiki/Concepts">https://github.com/flowbased/flowbased.org/wiki/Concepts</a>
</li>

<li>Circular buffer<br />
<a href="https://en.wikipedia.org/wiki/Circular_buffer">https://en.wikipedia.org/wiki/Circular_buffer</a>
</li>

<li>Circular Buffers in Linux kernel<br />
<a href="https://www.kernel.org/doc/html/latest/core-api/circular-buffers.html">https://www.kernel.org/doc/html/latest/core-api/circular-buffers.html</a>
</li>

<li>DrawFBP<br />
<a href="https://github.com/jpaulm/drawfbp">https://github.com/jpaulm/drawfbp</a>
</li>

<li>Panta Rhei<br />
<a href="https://blogs.bu.edu/marsh-vocation/2016/09/29/panta-rhei/">https://blogs.bu.edu/marsh-vocation/2016/09/29/panta-rhei/</a>
</li>

<li>Hérakleitos<br />
<a href="https://cs.wikipedia.org/wiki/H%C3%A9rakleitos">https://cs.wikipedia.org/wiki/H%C3%A9rakleitos</a>
</li>

<li>FlowBasedProgramming (Wiki)<br />
<a href="https://www.jpaulmorrison.com/cgi-bin/wiki.pl">https://www.jpaulmorrison.com/cgi-bin/wiki.pl</a>
</li>

<li>FBP Network Protocol<br />
<a href="https://flowbased.github.io/fbp-protocol/">https://flowbased.github.io/fbp-protocol/</a>
</li>

<li>Flow-based programming specification wiki<br />
<a href="https://flow-based.org/">https://flow-based.org/</a>
</li>

<li>Flow Based Programming<br />
<a href="http://wiki.c2.com/?FlowBasedProgramming">http://wiki.c2.com/?FlowBasedProgramming</a>
</li>

<li>FlowBasedProgramming<br />
<a href="http://www.jpaulmorrison.com/cgi-bin/wiki.pl">http://www.jpaulmorrison.com/cgi-bin/wiki.pl</a>
</li>

<li>BrokerageApplication<br />
<a href="http://www.jpaulmorrison.com/cgi-bin/wiki.pl?BrokerageApplication">http://www.jpaulmorrison.com/cgi-bin/wiki.pl?BrokerageApplication</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://go.dev/ref/spec">https://go.dev/ref/spec</a>
</li>

<li>Generics in Go<br />
<a href="https://bitfieldconsulting.com/golang/generics">https://bitfieldconsulting.com/golang/generics</a>
</li>

<li>Tutorial: Getting started with generics<br />
<a href="https://go.dev/doc/tutorial/generics">https://go.dev/doc/tutorial/generics</a>
</li>

<li>Type parameters in Go<br />
<a href="https://bitfieldconsulting.com/golang/type-parameters">https://bitfieldconsulting.com/golang/type-parameters</a>
</li>

<li>Go Data Structures: Binary Search Tree<br />
<a href="https://flaviocopes.com/golang-data-structure-binary-search-tree/">https://flaviocopes.com/golang-data-structure-binary-search-tree/</a>
</li>

<li>Gobs of data<br />
<a href="https://blog.golang.org/gobs-of-data">https://blog.golang.org/gobs-of-data</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Go 1.18 Release Notes<br />
<a href="https://golang.org/doc/go1.18">https://golang.org/doc/go1.18</a>
</li>

<li>Go 1.17 Release Notes<br />
<a href="https://golang.org/doc/go1.17">https://golang.org/doc/go1.17</a>
</li>

<li>Go 1.16 Release Notes<br />
<a href="https://golang.org/doc/go1.16">https://golang.org/doc/go1.16</a>
</li>

<li>Go 1.15 Release Notes<br />
<a href="https://golang.org/doc/go1.15">https://golang.org/doc/go1.15</a>
</li>

<li>Go 1.14 Release Notes<br />
<a href="https://golang.org/doc/go1.14">https://golang.org/doc/go1.14</a>
</li>

<li>Go 1.13 Release Notes<br />
<a href="https://golang.org/doc/go1.13">https://golang.org/doc/go1.13</a>
</li>

<li>Go 1.12 Release Notes<br />
<a href="https://golang.org/doc/go1.12">https://golang.org/doc/go1.12</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>A Proposal for Adding Generics to Go<br />
<a href="https://go.dev/blog/generics-proposal">https://go.dev/blog/generics-proposal</a>
</li>

<li>Proposal: Go should have generics<br />
<a href="https://github.com/golang/proposal/blob/master/design/15292-generics.md">https://github.com/golang/proposal/blob/master/design/15292-generics.md</a>
</li>

<li>Know Go: Generics (Kniha)<br />
<a href="https://bitfieldconsulting.com/books/generics">https://bitfieldconsulting.com/books/generics</a>
</li>

<li>Balíček constraints<br />
<a href="https://pkg.go.dev/golang.org/x/exp/constraints">https://pkg.go.dev/golang.org/x/exp/constraints</a>
</li>

<li>What are the libraries/tools you missed from other programming languages in Golang?<br />
<a href="https://www.quora.com/What-are-the-libraries-tools-you-missed-from-other-programming-languages-in-Golang?share=1">https://www.quora.com/What-are-the-libraries-tools-you-missed-from-other-programming-languages-in-Golang?share=1</a>
</li>

<li>Golang Has Generics—Why I Don't Miss Generics Anymore<br />
<a href="https://blog.jonathanoliver.com/golang-has-generics/">https://blog.jonathanoliver.com/golang-has-generics/</a>
</li>

<li>Go 1.18 Generics based slice package<br />
<a href="https://golangexample.com/go-1-18-generics-based-slice-package/">https://golangexample.com/go-1-18-generics-based-slice-package/</a>
</li>

<li>The missing slice package<br />
<a href="https://github.com/ssoroka/slice">https://github.com/ssoroka/slice</a>
</li>

<li>Methods in Go (part I)<br />
<a href="https://medium.com/golangspec/methods-in-go-part-i-a4e575dff860">https://medium.com/golangspec/methods-in-go-part-i-a4e575dff860</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

