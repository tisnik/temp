<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. </a></p>
<p><a href="#k03">*** 3. Buffery s&nbsp;pevnou kapacitou a neomezené fronty</a></p>
<p><a href="#k04">*** 4. </a></p>
<p><a href="#k05">*** 5. </a></p>
<p><a href="#k06">*** 6. </a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

klasický pohled na aplikace jako na sekvenční proces
vs. asynchronně běžící procesy

Because FBP processes can continue executing as long they have data to work on and somewhere to put their output



<p><a name="k02"></a></p>
<h2 id="k02">2. </h2>

Komponenty jsou základní stavební bloky
Interně se typicky jedná o třídy, funkce popř. uzávěry atd.

Procesy - instance komponent umístěné do grafu
Spojení (connections) - procesy komunikují přes spojení
propojení přes porty. Buffery nebo fronty (FIFO)
connection Capacity - buffery
někdy lze propojení realizovat s 0 kapacitou - přímá komunikace

Porty - pojmenované popř. indexované při použití pole portů
vstupní port: READ/RECEIVE
typicky propojení více výstupních portů na jeden vstupní port
výstupní port: SEND

The network definition is usually diagrammatic, and is converted into a connection list in some lower-level language or notation. FBP is often a visual programming language at this level.

merging/splitting

https://i.iinfo.cz/r/photos/opengl/opengl_11_3.gif



<p><a name="k03"></a></p>
<h2 id="k03">3. Buffery s&nbsp;pevnou kapacitou a neomezené fronty</h2>



<p><a name="k04"></a></p>
<h2 id="k04">4. </h2>

<pre>
$ <strong>go mod init flow1</strong>
&nbsp;
go: creating new go.mod: module flow1
</pre>

<pre>
$ <strong>go get -v -v github.com/trustmaster/goflow</strong>
&nbsp;
go: downloading github.com/trustmaster/goflow v0.0.0-20210928125717-b7d4fd465ab2
go: added github.com/trustmaster/goflow v0.0.0-20210928125717-b7d4fd465ab2
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. </h2>

<pre>
package main

import (
        "fmt"
        "github.com/trustmaster/goflow"
)

<i>// Jediný typ uzlu v síti</i>
type Printer struct {
        <i>// vstupní port</i>
        Message &lt;-chan string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) Process() {
        for message := range c.Message {
                fmt.Println(message)
        }
}

<i>// Definice grafu sítě s aplikací</i>
func NewFlowApp() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer", new(Printer))

        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "printer", "Message")

        <i>// výsledný graf</i>
        return n
}

func main() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()

        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)

        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)

        <i>// poslání několika zpráv do sítě</i>
        channel &lt;- "Foo"
        channel &lt;- "Bar"
        channel &lt;- "Baz"

        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)

        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>

<pre>
package main

import (
        "fmt"
        "github.com/trustmaster/goflow"
)

<i>// Jediný typ uzlu v síti</i>
type Printer struct {
        <i>// vstupní port</i>
        Message &lt;-chan string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) Process() {
        for message := range c.Message {
                fmt.Println(message)
        }
}

<i>// Definice grafu sítě s aplikací</i>
func NewFlowApp() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer", new(Printer))

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer2", new(Printer))

        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "printer", "Message")

        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "printer2", "Message")

        <i>// výsledný graf</i>
        return n
}

func main() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()

        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)

        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)

        <i>// poslání několika zpráv do sítě</i>
        channel &lt;- "Foo"
        channel &lt;- "Bar"
        channel &lt;- "Baz"

        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)

        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

<pre>
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>

<pre>
package main

import (
        "fmt"
        "github.com/trustmaster/goflow"
        "strings"
)

<i>// První typ uzlu v síti</i>
type Printer struct {
        Message &lt;-chan string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) Process() {
        for message := range c.Message {
                fmt.Println(message)
        }
}

<i>// Druhý typ uzlu v síti</i>
type Converter struct {
        <i>// vstupní port</i>
        In &lt;-chan string

        <i>// výstupní port</i>
        Out chan&lt;- string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanál</i>
func (c *Converter) Process() {
        for message := range c.In {
                converted := strings.ToUpper(message)
                c.Out &lt;- converted
        }
}

<i>// Definice grafu sítě s aplikací</i>
func NewFlowApp() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("converter", new(Converter))

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer", new(Printer))

        <i>// propojení dvou uzlů</i>
        n.Connect("converter", "Out", "printer", "Message")

        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "converter", "In")

        <i>// výsledný graf</i>
        return n
}

func main() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()

        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)

        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)

        <i>// poslání několika zpráv do sítě</i>
        channel &lt;- "Foo"
        channel &lt;- "Bar"
        channel &lt;- "Baz"

        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)

        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>

<pre>
package main

import (
        "fmt"
        "github.com/trustmaster/goflow"
        "strings"
)

<i>// První typ uzlu v síti</i>
type Printer struct {
        Message &lt;-chan string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) Process() {
        for message := range c.Message {
                fmt.Println(message)
        }
}

<i>// Druhý typ uzlu v síti</i>
type Converter struct {
        <i>// vstupní port</i>
        In &lt;-chan string

        <i>// první výstupní port</i>
        Out1 chan&lt;- string

        <i>// druhý výstupní port</i>
        Out2 chan&lt;- string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanály</i>
func (c *Converter) Process() {
        for message := range c.In {
                converted := "to upper case: " + strings.ToUpper(message)
                c.Out1 &lt;- converted

                converted = "to lower case: " + strings.ToLower(message)
                c.Out2 &lt;- converted
        }
}

<i>// Definice grafu sítě s aplikací</i>
func NewFlowApp() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("converter", new(Converter))

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer1", new(Printer))

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer2", new(Printer))

        <i>// propojení dvou uzlů</i>
        n.Connect("converter", "Out1", "printer1", "Message")

        <i>// propojení dvou uzlů</i>
        n.Connect("converter", "Out2", "printer2", "Message")

        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "converter", "In")

        <i>// výsledný graf</i>
        return n
}

func main() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()

        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)

        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)

        <i>// poslání několika zpráv do sítě</i>
        channel &lt;- "Foo"
        channel &lt;- "Bar"
        channel &lt;- "Baz"

        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)

        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<pre>
package main

import (
        "fmt"
        "github.com/trustmaster/goflow"
        "strings"
        "time"
        "unicode"
)

<i>// První typ uzlu v síti</i>
type Printer struct {
        Message &lt;-chan string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) Process() {
        for message := range c.Message {
                fmt.Println(message)
                if unicode.IsLower([]rune(message)[0]) {
                        time.Sleep(1 * time.Second)
                }
        }
}

<i>// Druhý typ uzlu v síti</i>
type Converter struct {
        <i>// vstupní port</i>
        In &lt;-chan string

        <i>// první výstupní port</i>
        Out1 chan&lt;- string

        <i>// druhý výstupní port</i>
        Out2 chan&lt;- string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanály</i>
func (c *Converter) Process() {
        for message := range c.In {
                converted := strings.ToUpper(message)
                c.Out1 &lt;- converted

                converted = strings.ToLower(message)
                c.Out2 &lt;- converted
        }
}

<i>// Definice grafu sítě s aplikací</i>
func NewFlowApp() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("converter", new(Converter))

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer1", new(Printer))

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer2", new(Printer))

        <i>// propojení dvou uzlů</i>
        n.Connect("converter", "Out1", "printer1", "Message")

        <i>// propojení dvou uzlů</i>
        n.Connect("converter", "Out2", "printer2", "Message")

        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "converter", "In")

        <i>// výsledný graf</i>
        return n
}

func main() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()

        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)

        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)

        <i>// poslání několika zpráv do sítě</i>
        for i := 0; i &lt; 10; i++ {
                channel &lt;- "Foo"
                channel &lt;- "Bar"
                channel &lt;- "Baz"
        }

        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)

        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<pre>
package main

import (
        "fmt"
        "github.com/trustmaster/goflow"
        "strings"
        "time"
        "unicode"
)

<i>// Výchozí kapacita bufferů</i>
const BufferCapacity = 100

<i>// První typ uzlu v síti</i>
type Printer struct {
        Message &lt;-chan string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) Process() {
        for message := range c.Message {
                fmt.Println(message)
                if unicode.IsLower([]rune(message)[0]) {
                        time.Sleep(1 * time.Second)
                }
        }
}

<i>// Druhý typ uzlu v síti</i>
type Converter struct {
        <i>// vstupní port</i>
        In &lt;-chan string

        <i>// první výstupní port</i>
        Out1 chan&lt;- string

        <i>// druhý výstupní port</i>
        Out2 chan&lt;- string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanály</i>
func (c *Converter) Process() {
        for message := range c.In {
                converted := strings.ToUpper(message)
                c.Out1 &lt;- converted

                converted = strings.ToLower(message)
                c.Out2 &lt;- converted
        }
}

<i>// Definice grafu sítě s aplikací</i>
func NewFlowApp() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("converter", new(Converter))

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer1", new(Printer))

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer2", new(Printer))

        <i>// propojení dvou uzlů</i>
        n.ConnectBuf("converter", "Out1", "printer1", "Message", BufferCapacity)

        <i>// propojení dvou uzlů</i>
        n.ConnectBuf("converter", "Out2", "printer2", "Message", BufferCapacity)

        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "converter", "In")

        <i>// propojení uzlu s procesem</i>

        <i>// výsledný graf</i>
        return n
}

func main() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()

        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)

        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)

        <i>// poslání několika zpráv do sítě</i>
        for i := 0; i &lt; 10; i++ {
                channel &lt;- "Foo"
                channel &lt;- "Bar"
                channel &lt;- "Baz"
        }

        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)

        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<pre>
package main

import (
        "fmt"
        "github.com/trustmaster/goflow"
        "strings"
        "time"
        "unicode"
)

<i>// Výchozí kapacita bufferů</i>
const BufferCapacity = 100

<i>// První typ uzlu v síti</i>
type Printer struct {
        Message &lt;-chan string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Printer) Process() {
        for message := range c.Message {
                fmt.Println(message)
                if unicode.IsLower([]rune(message)[0]) {
                        time.Sleep(1 * time.Second)
                }
        }
}

<i>// Druhý typ uzlu v síti</i>
type Splitter struct {
        <i>// vstupní port</i>
        In &lt;-chan string

        <i>// první výstupní port</i>
        Out1 chan&lt;- string

        <i>// druhý výstupní port</i>
        Out2 chan&lt;- string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
func (c *Splitter) Process() {
        for message := range c.In {
                c.Out1 &lt;- message
                c.Out2 &lt;- message
        }
}

<i>// Třetí typ uzlu v síti</i>
type Converter1 struct {
        <i>// vstupní port</i>
        In &lt;-chan string

        <i>// výstupní port</i>
        Out chan&lt;- string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanály</i>
func (c *Converter1) Process() {
        for message := range c.In {
                converted := strings.ToUpper(message)
                c.Out &lt;- converted
        }
}

<i>// Čtvrtý typ uzlu v síti</i>
type Converter2 struct {
        <i>// vstupní port</i>
        In &lt;-chan string

        <i>// výstupní port</i>
        Out chan&lt;- string
}

<i>// Zpracování vstupních dat posílaných přes kanál</i>
<i>// a poslání výsledku na výstupní kanály</i>
func (c *Converter2) Process() {
        for message := range c.In {
                converted := strings.ToLower(message)
                c.Out &lt;- converted
        }
}

<i>// Definice grafu sítě s aplikací</i>
func NewFlowApp() *goflow.Graph {
        <i>// konstrukce grafu</i>
        n := goflow.NewGraph()

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("splitter", new(Splitter))

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("converter1", new(Converter1))

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("converter2", new(Converter2))

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer1", new(Printer))

        <i>// přidání uzlu s procesem do grafu</i>
        n.Add("printer2", new(Printer))

        <i>// propojení dvou uzlů</i>
        n.ConnectBuf("splitter", "Out1", "converter1", "In", BufferCapacity)

        <i>// propojení dvou uzlů</i>
        n.ConnectBuf("splitter", "Out2", "converter2", "In", BufferCapacity)

        <i>// propojení dvou uzlů</i>
        n.ConnectBuf("converter1", "Out", "printer1", "Message", BufferCapacity)

        <i>// propojení dvou uzlů</i>
        n.ConnectBuf("converter2", "Out", "printer2", "Message", BufferCapacity)

        <i>// propojení uzlu s procesem</i>
        n.MapInPort("Input", "splitter", "In")

        <i>// výsledný graf</i>
        return n
}

func main() {
        <i>// vytvoření sítě</i>
        net := NewFlowApp()

        <i>// konstrukce kanálu</i>
        channel := make(chan string)
        net.SetInPort("Input", channel)

        <i>// spuštění sítě</i>
        <i>// (kanál bude použit pro čekání na její ukončení)</i>
        wait := goflow.Run(net)

        <i>// poslání několika zpráv do sítě</i>
        for i := 0; i &lt; 10; i++ {
                channel &lt;- "Foo"
                channel &lt;- "Bar"
                channel &lt;- "Baz"
        }

        <i>// žádost o ukončení činnosti sítě</i>
        close(channel)

        <i>// čekání na ukončení činnosti sítě</i>
        &lt;-wait
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
nového Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně stovku kilobajtů), můžete namísto toho použít odkazy na jednotlivé
demonstrační příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad/soubor</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>flow1/</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow1/">https://github.com/tisnik/go-root/blob/master/article_90/flow1/</a></td></tr>
<tr><td> 2</td><td>flow2/</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow2/">https://github.com/tisnik/go-root/blob/master/article_90/flow2/</a></td></tr>
<tr><td> 3</td><td>flow3/</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow3/">https://github.com/tisnik/go-root/blob/master/article_90/flow3/</a></td></tr>
<tr><td> 4</td><td>flow4/</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow4/">https://github.com/tisnik/go-root/blob/master/article_90/flow4/</a></td></tr>
<tr><td> 5</td><td>flow5/</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow5/">https://github.com/tisnik/go-root/blob/master/article_90/flow5/</a></td></tr>
<tr><td> 6</td><td>flow6/</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow6/">https://github.com/tisnik/go-root/blob/master/article_90/flow6/</a></td></tr>
<tr><td> 7</td><td>flow7/</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_90/flow7/">https://github.com/tisnik/go-root/blob/master/article_90/flow7/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Get into the flow<br />
<a href="https://appliedgo.net/flow/">https://appliedgo.net/flow/</a>
</li>

<li>Flow-based and dataflow programming library for Go programming language<br />
<a href="https://github.com/trustmaster/goflow">https://github.com/trustmaster/goflow</a>
</li>

<li>Flow-based programming (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Flow-based_programming">https://en.wikipedia.org/wiki/Flow-based_programming</a>
</li>

<li>FlowBasedProgramming (Python wiki)<br />
<a href="https://wiki.python.org/moin/FlowBasedProgramming">https://wiki.python.org/moin/FlowBasedProgramming</a>
</li>

<li>Flow Based Programming<br />
<a href="https://github.com/flowbased/flowbased.org/wiki">https://github.com/flowbased/flowbased.org/wiki</a>
</li>

<li>Concepts<br />
<a href="https://github.com/flowbased/flowbased.org/wiki/Concepts">https://github.com/flowbased/flowbased.org/wiki/Concepts</a>
</li>

<li>Circular buffer<br />
<a href="https://en.wikipedia.org/wiki/Circular_buffer">https://en.wikipedia.org/wiki/Circular_buffer</a>
</li>

<li>Circular Buffers in Linux kernel<br />
<a href="https://www.kernel.org/doc/html/latest/core-api/circular-buffers.html">https://www.kernel.org/doc/html/latest/core-api/circular-buffers.html</a>
</li>

<li>FBP Network Protocol<br />
<a href="https://flowbased.github.io/fbp-protocol/">https://flowbased.github.io/fbp-protocol/</a>
</li>

<li>Flow-based programming specification wiki<br />
<a href="https://flow-based.org/">https://flow-based.org/</a>
</li>

<li>Flow Based Programming<br />
<a href="http://wiki.c2.com/?FlowBasedProgramming">http://wiki.c2.com/?FlowBasedProgramming</a>
</li>

<li>FlowBasedProgramming<br />
<a href="http://www.jpaulmorrison.com/cgi-bin/wiki.pl">http://www.jpaulmorrison.com/cgi-bin/wiki.pl</a>
</li>

<li>BrokerageApplication<br />
<a href="http://www.jpaulmorrison.com/cgi-bin/wiki.pl?BrokerageApplication">http://www.jpaulmorrison.com/cgi-bin/wiki.pl?BrokerageApplication</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://go.dev/ref/spec">https://go.dev/ref/spec</a>
</li>

<li>Generics in Go<br />
<a href="https://bitfieldconsulting.com/golang/generics">https://bitfieldconsulting.com/golang/generics</a>
</li>

<li>Tutorial: Getting started with generics<br />
<a href="https://go.dev/doc/tutorial/generics">https://go.dev/doc/tutorial/generics</a>
</li>

<li>Type parameters in Go<br />
<a href="https://bitfieldconsulting.com/golang/type-parameters">https://bitfieldconsulting.com/golang/type-parameters</a>
</li>

<li>Go Data Structures: Binary Search Tree<br />
<a href="https://flaviocopes.com/golang-data-structure-binary-search-tree/">https://flaviocopes.com/golang-data-structure-binary-search-tree/</a>
</li>

<li>Gobs of data<br />
<a href="https://blog.golang.org/gobs-of-data">https://blog.golang.org/gobs-of-data</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Go 1.18 Release Notes<br />
<a href="https://golang.org/doc/go1.18">https://golang.org/doc/go1.18</a>
</li>

<li>Go 1.17 Release Notes<br />
<a href="https://golang.org/doc/go1.17">https://golang.org/doc/go1.17</a>
</li>

<li>Go 1.16 Release Notes<br />
<a href="https://golang.org/doc/go1.16">https://golang.org/doc/go1.16</a>
</li>

<li>Go 1.15 Release Notes<br />
<a href="https://golang.org/doc/go1.15">https://golang.org/doc/go1.15</a>
</li>

<li>Go 1.14 Release Notes<br />
<a href="https://golang.org/doc/go1.14">https://golang.org/doc/go1.14</a>
</li>

<li>Go 1.13 Release Notes<br />
<a href="https://golang.org/doc/go1.13">https://golang.org/doc/go1.13</a>
</li>

<li>Go 1.12 Release Notes<br />
<a href="https://golang.org/doc/go1.12">https://golang.org/doc/go1.12</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>A Proposal for Adding Generics to Go<br />
<a href="https://go.dev/blog/generics-proposal">https://go.dev/blog/generics-proposal</a>
</li>

<li>Proposal: Go should have generics<br />
<a href="https://github.com/golang/proposal/blob/master/design/15292-generics.md">https://github.com/golang/proposal/blob/master/design/15292-generics.md</a>
</li>

<li>Know Go: Generics (Kniha)<br />
<a href="https://bitfieldconsulting.com/books/generics">https://bitfieldconsulting.com/books/generics</a>
</li>

<li>Balíček constraints<br />
<a href="https://pkg.go.dev/golang.org/x/exp/constraints">https://pkg.go.dev/golang.org/x/exp/constraints</a>
</li>

<li>What are the libraries/tools you missed from other programming languages in Golang?<br />
<a href="https://www.quora.com/What-are-the-libraries-tools-you-missed-from-other-programming-languages-in-Golang?share=1">https://www.quora.com/What-are-the-libraries-tools-you-missed-from-other-programming-languages-in-Golang?share=1</a>
</li>

<li>Golang Has Generics—Why I Don't Miss Generics Anymore<br />
<a href="https://blog.jonathanoliver.com/golang-has-generics/">https://blog.jonathanoliver.com/golang-has-generics/</a>
</li>

<li>Go 1.18 Generics based slice package<br />
<a href="https://golangexample.com/go-1-18-generics-based-slice-package/">https://golangexample.com/go-1-18-generics-based-slice-package/</a>
</li>

<li>The missing slice package<br />
<a href="https://github.com/ssoroka/slice">https://github.com/ssoroka/slice</a>
</li>

<li>Methods in Go (part I)<br />
<a href="https://medium.com/golangspec/methods-in-go-part-i-a4e575dff860">https://medium.com/golangspec/methods-in-go-part-i-a4e575dff860</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

