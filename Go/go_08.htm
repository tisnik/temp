<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Tvorba balíčků a pokročilejší operace s kanály v jazyce Go</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Tvorba balíčků a pokročilejší operace s kanály v jazyce Go</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V osmé části seriálu o jazyce Go dokončíme popis některých témat, kterým jsme se již věnovali minule. Ukážeme si způsob vytváření vlastních balíčků a možnosti importu balíčků. Poté se budeme věnovat implementaci datového typu &bdquo;výčet&ldquo; a povíme si další možnosti při práci s kanály.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Všechna klíčová slova jazyka Go s&nbsp;odkazy na podrobnější popis</a></p>
<p><a href="#k02">2. Další standardní identifikátory, jména datových typů a funkcí</a></p>
<p><a href="#k03">3. Klíčové slovo <strong>package</strong></a></p>
<p><a href="#k04">4. Klíčové slovo <strong>import</strong></a></p>
<p><a href="#k05">5. Vytvoření vlastního balíčku, export objektů</a></p>
<p><a href="#k06">6. Inicializace balíčků</a></p>
<p><a href="#k07">7. Adresářová struktura, na níž ukazuje proměnná <strong>GOPATH</strong></a></p>
<p><a href="#k08">8. Balíčky se spustitelným kódem</a></p>
<p><a href="#k09">9. Chybějící datový typ <strong>enum</strong> a způsob jeho náhrady jinou konstrukcí</a></p>
<p><a href="#k10">10. První krok: nový celočíselný typ použitý s&nbsp;identifikátorem <strong>iota</strong></a></p>
<p><a href="#k11">11. Převod zvolených celočíselných konstant na řetězec</a></p>
<p><a href="#k12">12. Využití struktury/záznamu pro typově zabezpečené operace s&nbsp;výčtem</a></p>
<p><a href="#k13">13. Kanály s&nbsp;předdefinovanou maximální kapacitou fronty</a></p>
<p><a href="#k14">14. Použití konstrukce <strong>range</strong> při čtení dat z&nbsp;kanálu</a></p>
<p><a href="#k15">15. Chování uzavřeného kanálu při čtení hodnot</a></p>
<p><a href="#k16">16. Uzavření kanálu jako součást synchronizační konstrukce</a></p>
<p><a href="#k17">17. Konstrukce <strong>select</strong> s&nbsp;definicí maximální doby čekání na data</a></p>
<p><a href="#k18">18. Definice čekání na data a větev <strong>default</strong></a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Všechna klíčová slova jazyka Go s&nbsp;odkazy na podrobnější popis</h2>

<p><a
href="https://www.root.cz/clanky/programovaci-jazyk-go-dokonceni-popisu-vlastnosti-samotneho-jazyka/">V&nbsp;předchozím
článku</a> jsme prakticky dokončili popis všech důležitých vlastností
programovacího jazyka Go (minimálně všech syntaktických konstrukcí dostupných
v&nbsp;současné stabilní verzi), takže si pro úplnost ještě jednou ukažme
tabulku se všemi klíčovými slovy tohoto jazyka společně s&nbsp;odkazy na články
a kapitoly, ve kterých jsme se popisu těchto klíčových slov věnovali
podobněji:</p>

<table>
<tr><td><a href="https://www.root.cz/clanky/konstrukce-pro-rizeni-behu-programu-v-jazyce-go#k16">break</a></td><td><a href="https://www.root.cz/clanky/konstrukce-pro-rizeni-behu-programu-v-jazyce-go#k07">default</a></td><td><a href="https://www.root.cz/clanky/go-minimalisticky-a-prekvapive-vykonny-programovaci-jazyk/#k15">func</a></td><td><a href="https://www.root.cz/clanky/programovaci-jazyk-go-dokonceni-popisu-vlastnosti-samotneho-jazyka#k07">interface</a></td><td><a href="https://www.root.cz/clanky/programovaci-jazyk-go-dokonceni-popisu-vlastnosti-samotneho-jazyka#k07">select</a></td></tr>
<tr><td><a href="https://www.root.cz/clanky/konstrukce-pro-rizeni-behu-programu-v-jazyce-go#k07">case</a></td><td><a href="https://www.root.cz/clanky/konstrukce-pro-rizeni-behu-programu-v-jazyce-go-dokonceni#k06">defer</a></td><td><a href="https://www.root.cz/clanky/rozhrani-metody-gorutiny-a-kanaly-v-programovacim-jazyku-go/#k13">go</a></td><td><a href="https://www.root.cz/clanky/datove-typy-v-programovacim-jazyku-go-2-cast#k07">map</a></td><td><a href="https://www.root.cz/clanky/datove-typy-v-programovacim-jazyku-go-2-cast#k04">struct</a></td></tr>
<tr><td><a href="https://www.root.cz/clanky/rozhrani-metody-gorutiny-a-kanaly-v-programovacim-jazyku-go/#k16">chan</a></td><td><a href="https://www.root.cz/clanky/konstrukce-pro-rizeni-behu-programu-v-jazyce-go#k05">else</a></td><td><a href="https://www.root.cz/clanky/konstrukce-pro-rizeni-behu-programu-v-jazyce-go#k18">goto</a></td><td><a href="#k03">package</a></td><td><a href="https://www.root.cz/clanky/konstrukce-pro-rizeni-behu-programu-v-jazyce-go#k07">switch</a></td></tr>
<tr><td><a href="https://www.root.cz/clanky/programovaci-jazyk-go-dokonceni-popisu-vlastnosti-samotneho-jazyka#k13">const</a></td><td><a href="https://www.root.cz/clanky/konstrukce-pro-rizeni-behu-programu-v-jazyce-go#k10">fallthrough</a></td><td><a href="https://www.root.cz/clanky/konstrukce-pro-rizeni-behu-programu-v-jazyce-go#k04">if</a></td><td><a href="https://www.root.cz/clanky/konstrukce-pro-rizeni-behu-programu-v-jazyce-go#k15">range</a></td><td><a href="https://www.root.cz/clanky/datove-typy-v-programovacim-jazyku-go-2-cast/#k02">type</a></td></tr>
<tr><td><a href="https://www.root.cz/clanky/konstrukce-pro-rizeni-behu-programu-v-jazyce-go#k16">continue</a></td><td><a href="https://www.root.cz/clanky/konstrukce-pro-rizeni-behu-programu-v-jazyce-go#k12">for</a></td><td><a href="#k04">import</a></td><td><a href="https://www.root.cz/clanky/konstrukce-pro-rizeni-behu-programu-v-jazyce-go#k02">return</a></td><td><a href="https://www.root.cz/clanky/go-minimalisticky-a-prekvapive-vykonny-programovaci-jazyk/#k18">var</a></td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Další standardní identifikátory, jména datových typů a funkcí</h2>

<p>Kromě těchto klíčových slov se v&nbsp;Go setkáme s&nbsp;několika
identifikátory, které mají pevný význam. Typicky se jedná o konstanty,
v&nbsp;jednom případě o &bdquo;automaticky měněnou konstantu&ldquo; a o
pojmenování standardních datových typů. Jedná se o následující slova:</p>

<table>
<tr><th>Identifikátor</th><th>Typ</th><th>Stručný popis</th></tr>
<tr><td>true</td><td>konstanta</td><td>pravdivostní hodnota</td></tr>
<tr><td>false</td><td>konstanta</td><td>pravdivostní hodnota</td></tr>
<tr><td>iota</td><td>konstanta</td><td>celočíselný automaticky zvyšovaný čítač</td></tr>
<tr><td>nil</td><td>konstanta</td><td>prázdná hodnota, prázdné rozhraní</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>bool</td><td>datový typ</td><td>logický/pravdivostní typ</td></tr>
<tr><td>byte</td><td>datový typ</td><td>alias pro typ uint8</td></tr>
<tr><td>int</td><td>datový typ</td><td>odpovídá buď typu int32 nebo int64</td></tr>
<tr><td>int8</td><td>datový typ</td><td>osmibitové celé číslo se znaménkem</td></tr>
<tr><td>int16</td><td>datový typ</td><td>šestnáctibitové celé číslo se znaménkem</td></tr>
<tr><td>int32</td><td>datový typ</td><td>32bitové celé číslo se znaménkem</td></tr>
<tr><td>int64</td><td>datový typ</td><td>64bitové celé číslo se znaménkem</td></tr>
<tr><td>uint</td><td>datový typ</td><td>odpovídá buď typu uint32 nebo uint64</td></tr>
<tr><td>uint8</td><td>datový typ</td><td>osmibitové celé číslo bez znaménka</td></tr>
<tr><td>uint16</td><td>datový typ</td><td>16bitové celé číslo bez znaménka</td></tr>
<tr><td>uint32</td><td>datový typ</td><td>32bitové celé číslo bez znaménka</td></tr>
<tr><td>uint64</td><td>datový typ</td><td>64bitové celé číslo bez znaménka</td></tr>
<tr><td>float32</td><td>datový typ</td><td>číslo s jednoduchou přesností podle IEEE 754</td></tr>
<tr><td>float64</td><td>datový typ</td><td>číslo s dvojitou přesností podle IEEE 754</td></tr>
<tr><td>complex64</td><td>datový typ</td><td>dvojice hodnot s jednoduchou přesností</td></tr>
<tr><td>complex128</td><td>datový typ</td><td>dvojice hodnot s dvojitou přesností</td></tr>
<tr><td>error</td><td>datový typ</td><td>rozhraní s&nbsp;předpisem metody <strong>Error</strong></td></tr>
<tr><td>rune</td><td>datový typ</td><td>alias pro typ int32</td></tr>
<tr><td>string</td><td>datový typ</td><td></td></tr>
<tr><td>uintptr</td><td>datový typ</td><td>používáno pro uložení adresy (ukazatele)</td></tr>
</table>

<p>Dále mají všechny moduly vytvářené v&nbsp;programovacím jazyku Go
k&nbsp;dispozici několik standardních funkcí, které není zapotřebí žádným
způsobem importovat. Jména těchto funkcí sice nejsou striktně rezervována,
ovšem většinou není vhodné deklarovat funkci stejného jména s&nbsp;odlišným
chováním:</p>

<table>
<tr><th>Funkce</th><th>Funkce</th><th>Funkce</th></tr>
<tr><td>append</td><td>cap</td><td>close</td></tr>
<tr><td>complex</td><td>copy</td><td>delete</td></tr>
<tr><td>imag</td><td>len</td><td>make</td></tr>
<tr><td>new</td><td>panic</td><td>print</td></tr>
<tr><td>println</td><td>real</td><td>recover</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Klíčové slovo <strong>package</strong></h2>

<p>S&nbsp;klíčovým slovem <strong>package</strong> jsme se setkali již <a
href="https://www.root.cz/clanky/go-minimalisticky-a-prekvapive-vykonny-programovaci-jazyk/">v&nbsp;úvodní
části tohoto seriálu</a>. Toto slovo musí být použito v&nbsp;každém zdrojovém
kódu, protože slouží ke specifikaci balíčku, ke kterému daný zdrojový soubor
přísluší. Za tímto klíčovým slovem se zapisuje název balíčku, pro nějž platí
prakticky stejné jmenné konvence, jako pro jakýkoli jiný <i>identifikátor</i>
(teoreticky lze použít znaky z&nbsp;Unicode, prakticky se využívá jen
podmnožina ASCII), ovšem s&nbsp;jednou malou výjimkou &ndash; nelze zde použít
prázdný identifikátor představovaný podtržítkem &bdquo;_&ldquo;. Další striktní
požadavky nejsou na názvy balíčků kladeny, ovšem s&nbsp;ohledem na
konzistentnost se doporučuje, aby název balíčku byl tvořen jediným podstatným
jménem zapisovaným malými písmeny. Vzhledem k&nbsp;tomu, že by v&nbsp;názvu
balíčku mělo být jen jediné slovo, není zapotřebí řešit další pravidla &ndash;
zda použít <a href="https://en.wikipedia.org/wiki/Camel_case">camelCase</a>, <a
href="https://en.wikipedia.org/wiki/Snake_case">snake_case</a> atd.</p>

<p>Na tomto místě se asi ptáte, jak a zda vůbec je možné toto pravidlo dodržet
i pro rozsáhlejší aplikace s&nbsp;desítkami či stovkami balíčků &ndash; zde
přece musí dojít k&nbsp;nějaké kolizi jmen. Ve skutečnosti je ovšem název
balíčku (většinou ono jediné podstatné jméno) spojeno s&nbsp;<i>cestou
(path)</i> k&nbsp;balíčku, která slouží k&nbsp;přesnějšímu rozlišení. Příkladem
může být například standardní balíček nazvaný <strong>httputil</strong>, jehož
zdrojové kódy naleznete na stránce <a
href="https://golang.org/src/net/http/httputil/">https://golang.org/src/net/http/httputil/</a>.
Ve zdrojových kódech, do nichž se tento balíček importuje, budeme psát cestu
k&nbsp;balíčku a teprve po ní jeho název, což nám již umožní lepší návrh
aplikace a dodržení jmenných konvencí jazyka Go. Jako oddělovač je použito
lomítko:</p>

<pre>
import "net/http/httputil"
</pre>

<p>Navíc to znamená, že jméno balíčku nemusí být unikátní; samozřejmě ovšem
není možné mít stejně pojmenovaný balíček se stejnou cestou. Příklad balíčků se
shodným jménem, ale s&nbsp;odlišnou cestou (a s&nbsp;odlišnou
funkcionalitou):</p>

<ul>
<li>github.com/Workiva/go-datastructures/queue</li>
<li>github.com/eapache/queue</li>
<li>github.com/openfaas/faas/gateway/queue</li>
<li>github.com/jaegertracing/jaeger/pkg/queue</li>
</ul>

<p>atd. (stejně pojmenovaných balíčků je ve skutečnosti několik desítek).</p>

<p>Další informace o jmenných konvencích při pojmenování balíčků naleznete na
stránkách:</p>

<ol>

<li>Style guideline for Go packages<br />
<a href="https://rakyll.org/style-packages/">https://rakyll.org/style-packages/</a>
</li>

<li>The Go Blog: Package names<br />
<a href="https://blog.golang.org/package-names">https://blog.golang.org/package-names</a>
</li>

<li>Seznam standardních balíčků<br />
<a href="https://golang.org/pkg/">https://golang.org/pkg/</a>
</li>

<li>Seznam dalších (vybraných) balíčků pro Go<br />
<a href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go</a>
</li>

<li>Vyhledávač balíčků pro jazyk Go<br />
<a href="https://go-search.org/">https://go-search.org/</a>
</li>

<li>Everything you need to know about Packages in Go<br />
<a href="https://medium.com/rungo/everything-you-need-to-know-about-packages-in-go-b8bac62b74cc">https://medium.com/rungo/everything-you-need-to-know-about-packages-in-go-b8bac62b74cc</a>
</li>

</ol>

<p><div class="rs-tip-major">Poznámka: balíček nemusí být tvořen jediným
souborem. Je tomu spíše naopak &ndash; je obvyklé (a je to i doporučované), aby
byly datové typy, rozhraní, funkce i metody implementované v&nbsp;rámci jednoho
balíčku rozděleny do několika zdrojových souborů. Pokud se vrátíme k&nbsp;již
zmíněnému balíčku <strong>httputil</strong>, je tento balíček rozdělen do čtyř
souborů <a
href="https://golang.org/src/net/http/httputil/httputil.go">httputil.go</a>, <a
href="https://golang.org/src/net/http/httputil/persist.go">persist.go</a>, <a
href="https://golang.org/src/net/http/httputil/reverseproxy.go">reverseproxy.go</a>
a <a href="https://golang.org/src/net/http/httputil/dump.go">dump.go</a>, které
jsou navíc doplněny o několik testů (ve skutečnosti má jeden z&nbsp;testů
deklarován odlišný balíček <strong>httputil_test</strong>).</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Klíčové slovo <strong>import</strong></h2>

<p>S&nbsp;balíčky úzce souvisí i další klíčové slovo nazvané
<strong>import</strong>. Jak již název tohoto slova naznačuje, slouží
k&nbsp;importu balíčků do zdrojového kódu, který je právě vyvíjen a který
vyžaduje použití konstant, proměnných, datových typů, funkcí či metod
z&nbsp;tohoto balíčku. Za klíčovým slovem <strong>import</strong> je možné
v&nbsp;tom nejjednodušším případě uvést cestu k&nbsp;balíčku s&nbsp;jeho
názvem. V&nbsp;programovacím jazyce Go se přitom nejedná o nějaký speciální
identifikátor, ale o řetězec:</p>

<pre>
import "fmt"
</pre>

<p>Taktéž je možné provést import několika balíčků současně. V&nbsp;tomto
případě se názvy těchto balíčků zapisují do kulatých závorek za slovem
<strong>import</strong>, přičemž by se měl dodržet následující formát zápisu
(namísto mezer se ovšem v&nbsp;reálných zdrojových kódech používají taby).</p>

<p>Jeden balíček:</p>

<pre>
import (
        "fmt"
)
</pre>

<p>Více balíčků:</p>

<pre>
import (
        "fmt"
        "time"
)
</pre>

<p>Pokud jsou balíčky importovány výše uvedeným způsobem, je přístup
k&nbsp;importovaným objektům (konstanty, ...) provádět s&nbsp;využitím tečkové
notace, například:</p>

<pre>
fmt.Printf("Reservation for %d\n", day)
time.Sleep(1 * time.Second)
</pre>

<p>Alternativně je ovšem možné před jméno importovaného balíčku zapsat
tečku:</p>

<pre>
import . "fmt"
</pre>

<p>V&nbsp;takovém případě se tečková notace nepoužívá a objekty z&nbsp;balíčku
se zapisují pouze svým jménem:</p>

<pre>
Printf("Reservation for %d\n", day)
</pre>

<p>Tento způsob je vhodné používat s&nbsp;rozvahou, protože se nám vlastně
pomíchají lokální identifikátory objektů s&nbsp;identifikátory objektů
naimportovaných, což může způsobit pozdější zmatky.</p>

<p><div class="rs-tip-major">Poznámka: tento typ importu se používá například
v&nbsp;testech, kdy jsou testovací scénáře uloženy do vlastního balíčku a
provádí importy testovaných balíčků, aniž by došlo k&nbsp;cyklickým
závislostem. Mimochodem &ndash; u balíčků pro testy se používají jména
<strong>xyzzy_test</strong>, takže se vlastně porušují výše zmíněná pravidla
pro pojmenování.</div></p>

<p>Další možností je vytvoření aliasu jména balíčku:</p>

<pre>
import formatter "fmt"
</pre>

<p>resp.:</p>

<pre>
import (
        formatter "fmt"
)
</pre>

<p>Ve zdrojových kódech se v&nbsp;tomto případě použije alias:</p>

<pre>
formatter.Printf("Reservation for %d\n", day)
</pre>

<p>Zajímavé je, že alias není zapisován jako řetězec, ale jako běžný
identifikátor. Důvod, proč tomu tak je, si řekneme v&nbsp;navazující
kapitole.</p>

<p><div class="rs-tip-major">Poznámka: existuje ještě jeden způsob zápisu, kdy
se namísto aliasu použije podtržítko &bdquo;_&ldquo;. To využijeme
v&nbsp;případě, že potřebujeme balíček inicializovat (konkrétně volat jeho
funkci <strong>init</strong>), ovšem nechystáme se použít žádný objekt, který
je v&nbsp;balíčku deklarován. V&nbsp;takovém případě ovšem nelze použít běžný
import, protože by překladač jazyka Go správně upozornil na chybu.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vytvoření vlastního balíčku, export objektů</h2>

<p>Nyní si ukažme, jakým způsobem je možné vytvořit vlastní balíček, který
pojmenujeme <strong>hello1</strong>. Je to snadné &ndash; do adresáře
<strong>~/go/src</strong>, který jsme si vytvořili už na začátku seriálu (a na
který ukazuje proměnná <strong>GOPATH</strong>), přidáme podadresář nazvaný
&bdquo;hello1&ldquo; a vytvoříme v&nbsp;něm soubor nazvaný
&bdquo;hello1.go&ldquo; s&nbsp;následujícím obsahem:</p>

<pre>
package hello1
&nbsp;
func <strong>Hello_world</strong>() {
        println("Hello world!")
}
</pre>

<p>V&nbsp;jakémkoli jiném adresáři nyní můžeme tento balíček naimportovat a
zavolat z&nbsp;něho funkci <strong>Hello_world</strong>:</p>

<pre>
package main
&nbsp;
import (
        "hello1"
)
&nbsp;
func <strong>main</strong>() {
        hello.Hello_world()
}
</pre>

<p>Nyní vytvořme nový balíček se jménem <strong>hello2</strong>, ovšem
tentokrát bude následující zdrojový kód uložen v&nbsp;souboru
<strong>~/go/src/hello2/hello1.go</strong> (ne &ndash; nespletli jsme se,
skutečně zde použijeme jedničku a nikoli dvojku):</p>

<pre>
package hello2
&nbsp;
func <strong>Hello_world</strong>() {
        println("Hello world #2!")
}
</pre>

<p>Takový balíček bude stále bez potíží použitelný! V&nbsp;jazyku Go je totiž
možné mít v&nbsp;jednom balíčku více zdrojových souborů, přičemž důležitý je
název adresáře a řádek <strong>package</strong>, nikoli jména souborů:</p>

<pre>
package main
&nbsp;
import (
        "hello2"
)
&nbsp;
func <strong>main</strong>() {
        hello2.Hello_world()
}
</pre>

<p>Třetí balíček obsahuje deklaraci funkce <strong>hello_world</strong>, jejíž
název začíná malým písmenem:</p>

<pre>
package hello3
&nbsp;
func <strong>hello_world</strong>() {
        println("Hello world #3!")
}
</pre>

<p>Tato zdánlivě nepatrná změna způsobí, že funkci nebude možné z&nbsp;jiného
balíčku/modulu zavolat, protože symboly začínající malým písmenem by neměly být
viditelné (přesněji řečeno &ndash; nejsou exportovány):</p>

<pre>
package main
&nbsp;
import (
        "hello3"
)
&nbsp;
func <strong>main</strong>() {
        hello3.hello_world()
}
</pre>

<p>O této vlastnosti programovacího jazyka Go nás přesvědčí pokus o
překlad:</p>

<pre>
./21_use_package_hello3.go:15:2: cannot refer to unexported name hello3.hello_world
./21_use_package_hello3.go:15:2: undefined: hello3.hello_world
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Inicializace balíčků</h2>

<p>V&nbsp;případě, že je v&nbsp;balíčku deklarována funkce
<strong>init()</strong>, bude tato funkce automaticky zavolána při importu
balíčků. Totéž rekurzivně platí i pro případné balíčky importované do našeho
balíčku atd. atd. Zkusme si nyní vytvořit nový balíček nazvaný
<strong>hello4</strong>, který bude umístěn do adresáře
<strong>~/go/src/hello4</strong>:</p>

<pre>
package hello4
&nbsp;
func <strong>init</strong>() {
        println("hello4.init() called")
}
&nbsp;
func <strong>Hello_world</strong>() {
        println("Hello world #4!")
}
</pre>

<p>Tento balíček běžným způsobem naimportujeme a zavoláme jeho funkci:</p>

<pre>
package main
&nbsp;
import (
        "hello4"
)
&nbsp;
func <strong>main</strong>() {
        hello4.Hello_world()
}
</pre>

<p>Po překladu a spuštění příkladu by se měla nejdříve zobrazit zpráva o
zavolání funkce <strong>init()</strong> a teprve poté zpráva z&nbsp;funkce
<strong>main</strong>:</p>

<pre>
hello4.init() called
Hello world #4!
</pre>

<p>V&nbsp;některých situacích může být užitečné zavolat pouze funkci
<strong>init()</strong> a balíček posléze nepoužít. To je problematické,
protože <strong>init()</strong> není exportována (začíná malým písmenem) a
současně není možné importovat nepoužívaný balíček. Řešení spočívá
v&nbsp;použití již zmíněného podtržítka, které nám dovolí import balíčku bez
jeho dalšího použití, což nám ovšem nevadí, protože <strong>init()</strong> se
zavolá při importu:</p>

<pre>
package main
&nbsp;
import (
        _ "hello4"
)
&nbsp;
func <strong>main</strong>() {
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Adresářová struktura, na níž ukazuje proměnná <strong>GOPATH</strong></h2>

<p>Vraťme se nyní <a
href="https://www.root.cz/clanky/programovaci-jazyk-go-dokonceni-popisu-vlastnosti-samotneho-jazyka/">k&nbsp;závěrečné
části předchozího článku</a>, v&nbsp;níž jsme se věnovali problematice
adresářové struktury, na niž by měla ukazovat proměnná prostředí
<strong>GOPATH</strong>. Připomeňme si, že se tento adresář (může se jmenovat
jakkoli) nazývá <i>workspace</i> a měl by obsahovat tři podadresáře pojmenované
<strong>bin</strong>, <strong>pkg</strong> a <strong>src</strong>.
V&nbsp;těchto adresářích se postupně budou vytvářet další podadresáře, ale
základní struktura by zpočátku měla vypadat následovně:</p>

<pre>
.
├── bin
│   ├──
│   └──
├── pkg
│   ├──
│   └──
└── src
    ├──
    ├──
    └──
</pre>

<p>Obsah podadresáře <strong>src</strong> vlastně již do značné míry známe,
protože ten obsahuje zdrojové kódy jednotlivých balíčků, přičemž každý balíček
je umístěn ve vlastním podadresáři. Vzhledem k&nbsp;operacím, které jsme
provedli v&nbsp;rámci předchozích kapitol by tedy aktuální adresářová struktura
<i>workspace</i>, na níž ukazuje proměnná <strong>GOPATH</strong>, měla vypadat
takto:</p>

<pre>
.
├── bin
├── pkg
└── src
    ├── hello1
    │   └── hello1.go
    ├── hello2
    │   └── hello1.go
    ├── hello3
    │   └── hello1.go
    └── hello4
        └── hello4.go
</pre>

<p>Zajímavá je funkce ostatních dvou podadresářů <strong>bin</strong> a
<strong>pkg</strong>. Jejich použití je vysvětleno v&nbsp;navazující
kapitole.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Balíčky se spustitelným kódem</h2>

<p>Nyní v&nbsp;adresáři <strong>src</strong> vytvoříme podadresář
s&nbsp;balíčkem nazvaným <strong>say_hello_1</strong>. Tento balíček bude
obsahovat jediný soubor <strong>hello.go</strong> s&nbsp;tímto obsahem:</p>

<pre>
package main
&nbsp;
func <strong>main</strong>() {
        println("Hello world #1!")
}
</pre>

<p>Povšimněte si, že v&nbsp;tomto případě je na prvním řádku zapsáno
<strong>package main</strong> a nikoli <strong>package say_hello_1</strong>. Je
tomu tak z&nbsp;toho důvodu, že tento balíček ve skutečnosti použijeme pro
vytvoření spustitelného souboru a nebudeme ho používat jako knihovnu.</p>

<p>V&nbsp;tento okamžik můžeme provést instalaci balíčku </p>

<pre>
go install say_hello_1
</pre>

<p>Balíček by se měl přeložit a jeho spustitelná nativní podoba by měla být
uložena do adresáře <strong>bin</strong>:</p>

<pre>
.
├── bin
│   └── say_hello_1
├── pkg
└── src
    ├── hello1
    │   └── hello1.go
    ├── hello2
    │   └── hello1.go
    ├── hello3
    │   └── hello1.go
    ├── hello4
    │   └── hello4.go
    └── say_hello_1
        └── hello.go
</pre>

<p>Podobně můžeme vytvořit balíček <strong>say_hello_2</strong>, opět se
souborem <strong>hello.go</strong>. To, že se soubory v&nbsp;obou balíčcích
jmenují stejně, vůbec nevadí, protože výsledná spustitelná aplikace bude
pojmenována stejně jako balíček:</p>

<pre>
├── bin
│   ├── say_hello_1
│   └── say_hello_2
├── pkg
└── src
    ├── hello1
    │   └── hello1.go
    ├── hello2
    │   └── hello1.go
    ├── hello3
    │   └── hello1.go
    ├── hello4
    │   └── hello4.go
    ├── say_hello_1
    │   └── hello.go
    └── say_hello_2
        └── hello.go
</pre>

<p>Další možnosti si ukážeme příště při popisu práce s&nbsp;repositáři,
instalací externích knihoven apod.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Chybějící datový typ <strong>enum</strong> a způsob jeho náhrady jinou konstrukcí</h2>

<p>V&nbsp;předchozím článku jsme si ukázali způsob použití identifikátoru
<strong>iota</strong>. Při té příležitosti jsme si řekli, že současná verze
programovacího jazyka Go neobsahuje plnohodnotný datový typ &bdquo;výčet&ldquo;
neboli <i>enumeration</i> resp.&nbsp;<i>enum</i>. Ve skutečnosti však máme
k&nbsp;dispozici několik způsobů, jak se k&nbsp;výčtovému typu alespoň
přiblížit. Jednotlivé způsoby si postupně popíšeme.</p>

<p>Nejvíce přímočará je pouhá deklarace celočíselných konstant v&nbsp;bloku
<strong>const</strong> s&nbsp;využitím identifikátoru <strong>iota</strong>,
který zde vystupuje v&nbsp;roli celočíselného čítače:</p>

<pre>
const (
        Pondeli = iota
        Utery
        Streda
        Ctvrtek
        Patek
        Sobota
        Nedele
)
</pre>

<p>Při takto přímočarém použití však nastávají minimálně dva problémy:</p>

<ol>

<li>Konstanty jsou typu <strong>int</strong> a takto se tedy musí předávat do
funkcí.</li>

<li>Může se stát, že některé operace změní hodnotu, která má představovat
pořadí dne v&nbsp;týdnu, na neplatnou hodnotu.</li>

</ol>

<p>Ostatně si můžeme vyzkoušet, jak se bude chovat následující demonstrační
příklad po svém překladu a spuštění:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
const (
        Pondeli = iota
        Utery
        Streda
        Ctvrtek
        Patek
        Sobota
        Nedele
)
&nbsp;
func <strong>reservation</strong>(day int) {
        fmt.Printf("Reservation for %d\n", day)
}
&nbsp;
func <strong>main</strong>() {
        reservation(Pondeli)
        reservation(Sobota)
        reservation(Nedele)
&nbsp;
        reservation(3)
&nbsp;
        day := Pondeli
        day--
        reservation(day)
}
</pre>

<p>Ze zpráv vypsaných na terminál je patrné, že můžeme použít obyčejnou
celočíselnou konstantu (<strong>3</strong>) namísto jména dne
(<strong>Ctvrtek</strong>) a navíc se operací <strong>day--</strong> získala
hodnota, která neleží v&nbsp;očekávaném rozsahu:</p>

<pre>
Reservation for 0
Reservation for 5
Reservation for 6
Reservation for 3
Reservation for -1
</pre>

<p>Toto řešení je tedy nejvíce přímočaré, ale nemusí nám vyhovovat.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. První krok: nový celočíselný typ použitý s&nbsp;identifikátorem <strong>iota</strong></h2>

<p>Existuje jeden velmi jednoduchý a elegantní způsob, jak zabránit tomu, aby
celočíselné konstanty vytvořené identifikátorem <strong>iota</strong> byly typu
<strong>int</strong>. Nejprve nadeklarujeme nový datový typ odvozený od
<strong>int</strong>:</p>

<pre>
type Enum int
</pre>

<p>Posléze všechny konstanty vytvoříme, ovšem u první konstanty explicitně
zapíšeme její datový typ:</p>

<pre>
const (
        Pondeli Enum = iota
        Utery
        Streda
        Ctvrtek
        Patek
        Sobota
        Nedele
)
</pre>

<p>Výsledkem bude, že se opět vytvoří sedm konstant s&nbsp;hodnotami 0, 1, 2,
atd., ovšem tyto konstanty budou typu <strong>Enum</strong> a nikoli typu
<strong>int</strong>. Interně se sice jedná o naprosto stejnou reprezentaci
(běžné celé číslo), ovšem z&nbsp;předchozích článků již víme, že Go striktně
vyžaduje explicitní konverze. To znamená, že následující funkci:</p>

<pre>
func <strong>reservation</strong>(day int) {
        fmt.Printf("Reservation for %d\n", day)
}
</pre>

<p>již nebude možné předat přímo nějakou konstantu:</p>

<pre>
reservation(Pondeli)
</pre>

<p>Můžeme se o tom snadno přesvědčit při pokusu o překlad tohoto příkladu:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
type Enum int
&nbsp;
const (
        Pondeli Enum = iota
        Utery
        Streda
        Ctvrtek
        Patek
        Sobota
        Nedele
)
&nbsp;
func <strong>reservation</strong>(day int) {
        fmt.Printf("Reservation for %d\n", day)
}
&nbsp;
func <strong>main</strong>() {
        reservation(Pondeli)
        reservation(Sobota)
        reservation(Nedele)
&nbsp;
        reservation(3)
&nbsp;
        day := Pondeli
        day--
        reservation(day)
}
</pre>

<p>Překladač jazyka Go vypíše chyby při pokusu o volání funkce
<strong>reservartion</strong> s&nbsp;konstantou či proměnnou špatného typu:</p>

<pre>
./02_enum_with_iota_type_check.go:29:13: cannot use Pondeli (type Enum) as type int in argument to reservation
./02_enum_with_iota_type_check.go:30:13: cannot use Sobota (type Enum) as type int in argument to reservation
./02_enum_with_iota_type_check.go:31:13: cannot use Nedele (type Enum) as type int in argument to reservation
./02_enum_with_iota_type_check.go:37:13: cannot use day (type Enum) as type int in argument to reservation
</pre>

<p>Úprava příkladu je snadná, pouze přepíšeme hlavičku funkce:</p>

<pre>
func <strong>reservation</strong>(day Enum) {
        fmt.Printf("Reservation for %d\n", day)
}
</pre>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
type Enum int
&nbsp;
const (
        Pondeli Enum = iota
        Utery
        Streda
        Ctvrtek
        Patek
        Sobota
        Nedele
)
&nbsp;
func <strong>reservation</strong>(day Enum) {
        fmt.Printf("Reservation for %d\n", day)
}
&nbsp;
func <strong>main</strong>() {
        reservation(Pondeli)
        reservation(Sobota)
        reservation(Nedele)
&nbsp;
        reservation(3)
&nbsp;
        day := Pondeli
        day--
        reservation(day)
}
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
Reservation for 0
Reservation for 5
Reservation for 6
Reservation for 3
Reservation for -1
</pre>

<p>Zde můžeme vidět, že se nám sice zdrojový kód podařilo nepatrně vylepšit,
ale stále je možné proměnnou typu <strong>Enum</strong> změnit (například
operací --) tak, že nebude obsahovat korektní hodnotu, takže se o typově
bezpečný datový typ výčet stále nejedná.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Převod zvolených celočíselných konstant na řetězec</h2>

<p>V&nbsp;některých případech, například pro účely logování, je zapotřebí
převádět konstanty představující hodnoty výčtového typu na řetězce.
K&nbsp;tomuto účelu samozřejmě můžeme použít &bdquo;obyčejnou&ldquo; funkci,
ovšem elegantnější je deklarace metody:</p>

<pre>
func (day Enum) <strong>String</strong>() string {
        days := []string{
                "Pondeli",
                "Utery",
                "Streda",
                "Ctvrtek",
                "Patek",
                "Sobota",
                "Nedele"}
        if day &lt; Pondeli || day &gt; Nedele {
                return "Unknown day"
        }
        return days[day]
}
</pre>

<p><div class="rs-tip-major">Poznámka: připomeňme si, že z&nbsp;funkce se stane
metoda ve chvíli, kdy mezi klíčové slovo <strong>func</strong> a jméno metody
vložíme tzv.&nbsp;příjemce, v&nbsp;našem případě argument typu
<strong>Enum</strong>.</div></p>

<p>Opět si ukažme úplný zdrojový kód tohoto příkladu, v&nbsp;němž se provádí
základní kontroly, zda předaná hodnota leží v&nbsp;očekávaném rozsahu:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
type Enum int
&nbsp;
const (
        Pondeli Enum = iota
        Utery
        Streda
        Ctvrtek
        Patek
        Sobota
        Nedele
)
&nbsp;
func (day Enum) <strong>String</strong>() string {
        days := []string{
                "Pondeli",
                "Utery",
                "Streda",
                "Ctvrtek",
                "Patek",
                "Sobota",
                "Nedele"}
        if day &lt; Pondeli || day &gt; Nedele {
                return "Unknown day"
        }
        return days[day]
}
&nbsp;
func <strong>reservation</strong>(day Enum) {
        fmt.Printf("Reservation for %s\n", day.String())
}
&nbsp;
func <strong>main</strong>() {
        reservation(Pondeli)
        reservation(Sobota)
        reservation(Nedele)
&nbsp;
        reservation(3)
&nbsp;
        day := Pondeli
        day--
        reservation(day)
}
</pre>

<p>Po překladu a spuštění tohoto příkladu získáme tyto řádky:</p>

<pre>
Reservation for Pondeli
Reservation for Sobota
Reservation for Nedele
Reservation for Ctvrtek
Reservation for Unknown day
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Využití struktury/záznamu pro typově zabezpečené operace s&nbsp;výčtem</h2>

<p>Při tvorbě datového typu podobného typu výčtovému můžeme jít ještě o jeden
krok dále a použít tuto deklaraci:</p>

<pre>
type Enum int
&nbsp;
type Den struct {
        X Enum
}
</pre>

<p>Touto deklarací vlastně říkáme, že typ <strong>Den</strong> je datová
struktura s&nbsp;jediným členem typu <strong>Enum</strong> pojmenovaným
<strong>X</strong>. Díky tomu se vlastně interní hodnoty
&bdquo;uschovají&ldquo; do struktury, což je dobře, protože zápisy typu:</p>

<pre>
day := Den{Pondeli}
day++
</pre>

<p>přestanou být korektní a nebude možné použít jiné hodnoty než definované
(pokud přímo nepřistoupíme k&nbsp;prvku struktury).</p>

<p>Opět se podívejme na upravený demonstrační příklad, který nyní vypadá
následovně:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
type Enum int
&nbsp;
const (
        Pondeli Enum = iota
        Utery
        Streda
        Ctvrtek
        Patek
        Sobota
        Nedele
)
&nbsp;
type Den struct {
        X Enum
}
&nbsp;
func (day Enum) <strong>String</strong>() string {
        days := []string{
                "Pondeli",
                "Utery",
                "Streda",
                "Ctvrtek",
                "Patek",
                "Sobota",
                "Nedele"}
        if day &lt; Pondeli || day &gt; Nedele {
                return "Unknown day"
        }
        return days[day]
}
&nbsp;
func <strong>reservation</strong>(day Den) {
        fmt.Printf("Reservation for %s\n", day)
}
&nbsp;
func <strong>main</strong>() {
        reservation(Den{Pondeli})
        reservation(Den{Sobota})
        reservation(Den{Nedele})
&nbsp;
        day := Den{Pondeli}
        reservation(day)
}
</pre>

<p>Příklad nyní pracuje správně (případné složené závorky lze snadno odstranit
&ndash; což ponechám váženému čtenáři za domácí úkol):</p>

<pre>
Reservation for {Pondeli}
Reservation for {Sobota}
Reservation for {Nedele}
Reservation for {Pondeli}
</pre>

<p>Nyní si otestujeme, že skutečně nebude možné měnit hodnotu našeho výčtového
typu:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
type Enum int
&nbsp;
const (
        Pondeli Enum = iota
        Utery
        Streda
        Ctvrtek
        Patek
        Sobota
        Nedele
)
&nbsp;
type Den struct {
        X Enum
}
&nbsp;
func (day Enum) <strong>String</strong>() string {
        days := []string{
                "Pondeli",
                "Utery",
                "Streda",
                "Ctvrtek",
                "Patek",
                "Sobota",
                "Nedele"}
        if day &lt; Pondeli || day &gt; Nedele {
                return "Unknown day"
        }
        return days[day]
}
&nbsp;
func <strong>reservation</strong>(day Den) {
        fmt.Printf("Reservation for %s\n", day)
}
&nbsp;
func <strong>main</strong>() {
        reservation(Den{Pondeli})
        reservation(Den{Sobota})
        reservation(Den{Nedele})
&nbsp;
        day := Den{Pondeli}
        day++
        reservation(day)
}
</pre>

<p>Při pokusu o překlad <strong>day++</strong> překladač jazyka Go zahlásí
chybu:</p>

<pre>
./06_enum_as_type.go:53:5: invalid operation: day++ (non-numeric type Den)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Kanály s&nbsp;předdefinovanou maximální kapacitou fronty</h2>

<p>Dalším doplňujícím tématem dnešního článku je zmínka o kanálech
s&nbsp;nakonfigurovanou kapacitou fronty (<i>FIFO</i>, v&nbsp;kontextu kanálů
se mluví o bufferu). Připomeňme si, že pokud je kanál vytvořen následujícím
způsobem:</p>

<pre>
channel := make(chan rune)
</pre>

<p>bude mít jeho fronta kapacitu pouze pro jediný prvek (zde typu
<strong>rune</strong>, tedy znak) a tudíž se kanál bude chovat podobně jako
<i>mailbox</i>. Ovšem kapacitu kanálu (resp.&nbsp;jeho FIFA) můžeme zvýšit
zápisem druhého (nepovinného) parametru do volání funkce
<strong>make</strong>:</p>

<pre>
channel := make(chan rune, 1234)
</pre>

<p>Teoreticky je kapacita omezena tím, že je reprezentována typem
<strong>int</strong>, prakticky však pochopitelně narazíme na limity, které
nejvíce souvisí s&nbsp;maximálním množstvím paměti, která může být procesu
přidělena.</p>

<p>Podívejme se na příklad, v&nbsp;němž je vytvořen kanál s&nbsp;kapacitou
bufferu/FIFA pro tři znaky. V&nbsp;tomto příkladu se nevytváří ani nevolá žádná
nová gorutina &ndash; všechny operace s&nbsp;kanálem jsou součástí jediné
(hlavní) gorutiny, která používá kanál pro implementaci fronty
(<i>queue</i>):</p>

<pre>
channel := make(chan rune)
</pre>
<pre>
package main
&nbsp;
import (
        "fmt"
)
&nbsp;
func <strong>main</strong>() {
        channel := make(chan rune, 3)
        channel &lt;- 'A'
        channel &lt;- 'B'
        channel &lt;- 'C'
&nbsp;
        for i := 0; i &lt; 3; i++ {
                fmt.Printf("%c ", &lt;-channel)
        }
}
</pre>

<p>Po překladu a spuštění tohoto příkladu by se měl vypsat tento řádek:</p>

<pre>
A B C
</pre>

<p><div class="rs-tip-major">Poznámka: tento způsob použití kanálu nemusí být
příliš efektivní; ostatně si sami můžete pomocí profileru vyzkoušet a porovnat
tento příklad s&nbsp;jinou implementací datového typu fronta.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Použití konstrukce <strong>range</strong> při čtení dat z&nbsp;kanálu</h2>

<p>Dalším užitečným trikem, který je možné využít při práci s&nbsp;kanály, je
čtení hodnot z&nbsp;kanálu v&nbsp;programové smyčce <strong>for</strong>
s&nbsp;konstrukcí <strong>range</strong>. Celý zápis vypadá následovně:</p>

<pre>
for msg := range channel {
        fmt.Printf("%c ", msg)
}
</pre>

<p>Tato programová smyčka skončí až ve chvíli, kdy dojde k&nbsp;uzavření
kanálu! Pokud kanál není uzavřen a jeho fronta je prázdná, smyčka bude buď
čekat na data nebo runtime programovacího jazyka Go bude detekovat stav, kdy
neběží žádná gorutina a program bude násilně ukončen. Tuto vlastnost si opět
můžeme velmi snadno odzkoušet:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
)
&nbsp;
func <strong>fill_in_channel</strong>(channel chan rune) {
        channel &lt;- 'A'
        channel &lt;- 'B'
        channel &lt;- 'C'
}
&nbsp;
func <strong>main</strong>() {
        channel := make(chan rune, 3)
&nbsp;
        go fill_in_channel(channel)
&nbsp;
        for msg := range channel {
                fmt.Printf("%c ", msg)
        }
}
</pre>

<p>Pokud tento program spustíme, dojde k&nbsp;postupnému naplnění kanálu třemi
prvky, které budou (opět postupně) čteny v&nbsp;programové smyčce. Následně
runtime jazyka Go zjistí, že existuje jen jediná gorutina (hlavní) a ta čeká na
další data &ndash; ty evidentně nemá kde získat a proto bude program násilně
ukončen:</p>

<pre>
A B C fatal error: all goroutines are asleep - deadlock!
&nbsp;
goroutine 1 [chan receive]:
main.main()
        /home/tester/temp/out/go-root/article_08/08_channel_and_range.go:25 +0xe7
exit status 2
</pre>

<p>Úprava je ve skutečnosti velmi snadná &ndash; v&nbsp;námi vytvořené gorutině
(v&nbsp;ní se volá funkce <strong>fill_in_channel</strong>) nejprve do kanálu
pošleme tři prvky a posléze kanál uzavřeme voláním:</p>

<pre>
close(channel)
</pre>

<p>Upravený zdrojový kód demonstračního příkladu vypadá následovně:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
)
&nbsp;
func <strong>fill_in_channel</strong>(channel chan rune) {
        channel &lt;- 'A'
        channel &lt;- 'B'
        channel &lt;- 'C'
        close(channel)
}
&nbsp;
func <strong>main</strong>() {
        channel := make(chan rune, 3)
&nbsp;
        go fill_in_channel(channel)
&nbsp;
        for msg := range channel {
                fmt.Printf("%c ", msg)
        }
}
</pre>

<p>Po spuštění zjistíme, že se program skutečně chová tak, jak je očekáváno:
k&nbsp;žádným pádům nedochází a hlavní gorutina je po příjmu tří prvků korektně
ukončena:</p>

<pre>
A B C
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Chování uzavřeného kanálu při čtení hodnot</h2>

<p>Pro úplnost si ukažme, jak se chová uzavřený kanál ve chvíli, kdy z&nbsp;něj
čteme další hodnoty. V&nbsp;tomto případě se <i>nejedná</i> o blokující operace
(kanál je uzavřen, žádná data do něj již nelze poslat), proto je chování
upraveno takovým způsobem, že pokus o přečtení dat z&nbsp;uzavřeného kanálu
vrátí výchozí hodnotu platnou pro ten datový typ, jaký odpovídá typu prvků
kanálu. V&nbsp;praxi to znamená, že pro uzavřený kanál <strong>chan
int</strong> získáme po přečtení sadu nul:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
)
&nbsp;
func <strong>main</strong>() {
        channel := make(chan int, 3)
        close(channel)
&nbsp;
        fmt.Printf("%d\n", &lt;-channel)
        fmt.Printf("%d\n", &lt;-channel)
        fmt.Printf("%d\n", &lt;-channel)
}
</pre>

<p>Chování příkladu po spuštění:</p>

<pre>
0
0
0
</pre>

<p><div class="rs-tip-major">Poznámka: k&nbsp;detekci tohoto stavu slouží druhá
hodnota vrácená operátorem &lt;-. Pokud je tato druhá hodnota rovna
<strong>false</strong>, je kanál uzavřen.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Uzavření kanálu jako součást synchronizační konstrukce</h2>

<p>Výše popsané chování:</p>

<ol>
<li>Čtení z&nbsp;prázdného kanálu je blokující operace.</li>
<li>Čtení z&nbsp;uzavřeného kanálu skončí ihned (a vrátí se nula)</li>
</ol>

<p>je možné využít k&nbsp;tomu, aby kanál sloužil jako synchronizační
konstrukce, a to bez toho, aby se do něj provedl byť i jediný zápis.
V&nbsp;následujícím příkladu je vytvořena nová gorutina představovaná anonymní
funkcí. Na dokončení běhu této gorutiny čekáme příkazem:</p>

<pre>
&lt;-done
</pre>

<p>Vzhledem k&nbsp;tomu, že do kanálu nebyl proveden zápis, je výše uvedený
příkaz blokován až do doby, kdy je kanál uzavřen:</p>

<pre>
package main
&nbsp;
func <strong>main</strong>() {
        done := make(chan bool)
&nbsp;
        go func() {
                println("async block")
                close(done)
        }()
&nbsp;
        println("wait for async block")
        &lt;-done
}
</pre>

<p>Po spuštění příkladu je patrné, že se skutečně čeká na dokončení gorutiny
(v&nbsp;opačném případě je program ukončen již při opuštění funkce
<strong>main</strong>):</p>

<pre>
wait for async block
async block
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Konstrukce <strong>select</strong> s&nbsp;definicí maximální doby čekání na data</h2>

<p>Další užitečnou konstrukcí, která souvisí s&nbsp;kanály a komunikací mezi
gorutinami, je čekání na data v&nbsp;příkazu <strong>select</strong>. Pokud
čekáme pouze na data z&nbsp;libovolného množství kanálů, jedná se o blokující
operaci, která může trvat libovolně dlouho:</p>

<pre>
select {
case &lt;-ch1:
        fmt.Println("Data z kanálu 1")
case &lt;-ch2:
        fmt.Println("Data z kanálu 2")
</pre>

<p>V&nbsp;případě, že potřebujeme, aby byla celá programová konstrukce
<strong>select</strong> po nějaké době ukončena, nezávisle na tom, zda jsme
data přečetli či nikoli, použijeme tuto větev (přidanou k&nbsp;ostatním
větvím):</p>

<pre>
case &lt;-time.After(2 * time.Second):
        fmt.Println("Timeout!")
}
</pre>

<p>Ve skutečnosti se nejedná o žádnou magii, protože funkce
<strong>time.After()</strong> vrací kanál typu <strong>chan Time</strong>, do
něhož je proveden jediný zápis, a to po uběhnutí specifikované doby.</p>

<p>Celý příklad, v&nbsp;němž se snažíme o přečtení dat z&nbsp;kanálu
<strong>ch1</strong> nebo <strong>ch2</strong>, ovšem s&nbsp;definovanou
maximální dobou čekání, může vypadat následovně:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "time"
)
&nbsp;
func <strong>worker</strong>(channel chan int, worker int) {
        fmt.Printf("Worker %d spuštěn\n", worker)
        time.Sleep(1 * time.Second)
        channel &lt;- 1
        fmt.Printf("Worker %d ukončen\n", worker)
}
&nbsp;
func <strong>main</strong>() {
        ch1 := make(chan int)
        ch2 := make(chan int)
&nbsp;
        go worker(ch1, 1)
        go worker(ch2, 2)
&nbsp;
        select {
        case &lt;-ch1:
                fmt.Println("Data z kanálu 1")
        case &lt;-ch2:
                fmt.Println("Data z kanálu 2")
        case &lt;-time.After(2 * time.Second):
                fmt.Println("Timeout!")
        }
}
</pre>

<p>Chování po spuštění &ndash; timeout nebyl použit:</p>

<pre>
Worker 2 spuštěn
Worker 1 spuštěn
Worker 1 ukončen
Data z kanálu 1
</pre>

<p>Nepatrnou úpravou zdrojového kódu můžeme dosáhnout toho, aby byla větev
s&nbsp;timeoutem skutečně použita; postačuje pouze zvýšit čas ve volání
<strong>time.Sleep()</strong> v&nbsp;implementaci gorutiny:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "time"
)
&nbsp;
func <strong>worker</strong>(channel chan int, worker int) {
        fmt.Printf("Worker %d spuštěn\n", worker)
        time.Sleep(5 * time.Second)
        channel &lt;- 1
        fmt.Printf("Worker %d ukončen\n", worker)
}
&nbsp;
func <strong>main</strong>() {
        ch1 := make(chan int)
        ch2 := make(chan int)
&nbsp;
        go worker(ch1, 1)
        go worker(ch2, 2)
&nbsp;
        select {
        case &lt;-ch1:
                fmt.Println("Data z kanálu 1")
        case &lt;-ch2:
                fmt.Println("Data z kanálu 2")
        case &lt;-time.After(2 * time.Second):
                fmt.Println("Timeout!")
        }
}
</pre>

<p>Nyní bude chování příkladu po jeho spuštění odlišné:</p>

<pre>
Worker 1 spuštěn
Worker 2 spuštěn
Timeout!
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Definice čekání na data a větev <strong>default</strong></h2>

<p>Jen pro úplnost si ukažme nesmyslný příklad (syntakticky je správně,
sémanticky už nikoli), v&nbsp;němž v&nbsp;programové konstrukci
<strong>select</strong> použijeme jak větev se čtením z&nbsp;kanálu
zkonstruovaného pomocí <strong>time.After()</strong>, tak i větev
<strong>default</strong>. V&nbsp;tomto případě se větev
<strong>time.After()</strong> nikdy nepoužije, protože se ve skutečnosti
neprovádí žádné čekání, pouze výběr případných dat z&nbsp;jednoho dostupného
kanálu. V&nbsp;případě, že data k&nbsp;dispozici nejsou, provede se ihned kód
ve větvi <strong>default</strong>:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "time"
)
&nbsp;
func <strong>worker</strong>(channel chan int, worker int) {
        fmt.Printf("Worker %d spuštěn\n", worker)
        time.Sleep(5 * time.Second)
        channel &lt;- 1
        fmt.Printf("Worker %d ukončen\n", worker)
}
&nbsp;
func <strong>main</strong>() {
        ch1 := make(chan int)
        ch2 := make(chan int)
&nbsp;
        go worker(ch1, 1)
        go worker(ch2, 2)
&nbsp;
        select {
        case &lt;-ch1:
                fmt.Println("Data z kanálu 1")
        case &lt;-ch2:
                fmt.Println("Data z kanálu 2")
        case &lt;-time.After(2 * time.Second):
                fmt.Println("Timeout!")
        default:
                fmt.Println("No data!")
        }
}
</pre>

<pre>
Worker 1 spuštěn
No data!
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
doslova několik kilobajtů), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_enum_with_iota.go</td><td>první (nedostatečná) implementace výčtového typu</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_08/01_enum_with_iota.go">https://github.com/tisnik/go-fedora/blob/master/article_08/01_enum_with_iota.go</a></td></tr>
<tr><td> 2</td><td>02_enum_with_iota_type_check.go</td><td>typové kontroly u celočíselných konstant (nekorektní použití)</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_08/02_enum_with_iota_type_check.go">https://github.com/tisnik/go-fedora/blob/master/article_08/02_enum_with_iota_type_check.go</a></td></tr>
<tr><td> 3</td><td>03_enum_with_iota.go</td><td>typová kontrola a její korektní použití</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_08/03_enum_with_iota.go">https://github.com/tisnik/go-fedora/blob/master/article_08/03_enum_with_iota.go</a></td></tr>
<tr><td> 4</td><td>04_enum_with_iota.go</td><td>převod výčtového typu na řetězec</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_08/04_enum_with_iota.go">https://github.com/tisnik/go-fedora/blob/master/article_08/04_enum_with_iota.go</a></td></tr>
<tr><td> 5</td><td>05_enum_as_type.go</td><td>náhrada výčtového typu strukturou</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_08/05_enum_as_type.go">https://github.com/tisnik/go-fedora/blob/master/article_08/05_enum_as_type.go</a></td></tr>
<tr><td> 6</td><td>06_enum_as_type.go</td><td>náhrada výčtového typu strukturou, pokus o provedení nepovolených operací</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_08/06_enum_as_type.go">https://github.com/tisnik/go-fedora/blob/master/article_08/06_enum_as_type.go</a></td></tr>
<tr><td> 7</td><td>07_channel_as_fifo.go</td><td>použití kanálu ve funkci FIFO</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_08/07_channel_as_fifo.go">https://github.com/tisnik/go-fedora/blob/master/article_08/07_channel_as_fifo.go</a></td></tr>
<tr><td> 8</td><td>08_channel_and_range.go</td><td>kanály a klíčové slovo <strong>range</strong></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_08/08_channel_and_range.go">https://github.com/tisnik/go-fedora/blob/master/article_08/08_channel_and_range.go</a></td></tr>
<tr><td> 9</td><td>09_channel_and_range.go</td><td>kanály a klíčové slovo <strong>range</strong></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_08/09_channel_and_range.go">https://github.com/tisnik/go-fedora/blob/master/article_08/09_channel_and_range.go</a></td></tr>
<tr><td>10</td><td>10_read_from_closed_channel.go</td><td>pokus o čtení ze zavřeného kanálu</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_08/10_read_from_closed_channel.go">https://github.com/tisnik/go-fedora/blob/master/article_08/10_read_from_closed_channel.go</a></td></tr>
<tr><td>11</td><td>11_sync_with_channel.go</td><td>synchronizace pomocí uzavření kanálu</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_08/11_sync_with_channel.go">https://github.com/tisnik/go-fedora/blob/master/article_08/11_sync_with_channel.go</a></td></tr>
<tr><td>12</td><td>12_select_statement_receive.go</td><td>specifikace maximální doby čekání na data</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_08/12_select_statement_receive.go">https://github.com/tisnik/go-fedora/blob/master/article_08/12_select_statement_receive.go</a></td></tr>
<tr><td>13</td><td>13_select_statement_receive.go</td><td>specifikace maximální doby čekání na data</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_08/13_select_statement_receive.go">https://github.com/tisnik/go-fedora/blob/master/article_08/13_select_statement_receive.go</a></td></tr>
<tr><td>14</td><td>14_select_statement_receive.go</td><td>specifikace timeoutu v&nbsp;<strong>select</strong> + větev <strong>default</strong></td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_08/14_select_statement_receive.go">https://github.com/tisnik/go-fedora/blob/master/article_08/14_select_statement_receive.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Select waits on a group of channels<br />
<a href="https://yourbasic.org/golang/select-explained/">https://yourbasic.org/golang/select-explained/</a>
</li>

<li>Rob Pike: Simplicity is Complicated (video)<br />
<a href="http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893">http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893</a>
</li>

<li>Algorithms to Go<br />
<a href="https://yourbasic.org/">https://yourbasic.org/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů: vlastní filtry a lexery<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/</a>
</li>

<li>Go Defer Simplified with Practical Visuals<br />
<a href="https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff">https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff</a>
</li>

<li>5 More Gotchas of Defer in Go — Part II<br />
<a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa">https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa</a>
</li>

<li>The Go Blog: Defer, Panic, and Recover<br />
<a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a>
</li>

<li>The defer keyword in Swift 2: try/finally done right<br />
<a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer">https://www.hackingwithswift.com/new-syntax-swift-2-defer</a>
</li>

<li>Swift Defer Statement<br />
<a href="https://andybargh.com/swift-defer-statement/">https://andybargh.com/swift-defer-statement/</a>
</li>

<li>Modulo operation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Modulo_operation">https://en.wikipedia.org/wiki/Modulo_operation</a>
</li>

<li>Node.js vs Golang: Battle of the Next-Gen Languages<br />
<a href="https://www.hostingadvice.com/blog/nodejs-vs-golang/">https://www.hostingadvice.com/blog/nodejs-vs-golang/</a>
</li>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go<br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

<li>Printf Format Strings<br />
<a href="https://www.cprogramming.com/tutorial/printf-format-strings.html">https://www.cprogramming.com/tutorial/printf-format-strings.html</a>
</li>

<li>Java: String.format<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-</a>
</li>

<li>Java: format string syntax<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a>
</li>

<li>Selectors<br />
<a href="https://golang.org/ref/spec#Selectors">https://golang.org/ref/spec#Selectors</a>
</li>

<li>Calling Go code from Python code<br />
<a href="http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/">http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/</a>
</li>

<li>Go Data Structures: Interfaces <br />
<a href="https://research.swtch.com/interfaces">https://research.swtch.com/interfaces</a>
</li>

<li>How to use interfaces in Go<br />
<a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go</a>
</li>

<li>Interfaces in Go (part I)<br />
<a href="https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c">https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c</a>
</li>

<li>Part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>What about Trait support in Golang?<br />
<a href="https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/">https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/</a>
</li>

<li>Don't Get Bitten by Pointer vs Non-Pointer Method Receivers in Golang<br />
<a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/">https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/</a>
</li>

<li>Control Flow<br />
<a href="https://en.wikipedia.org/wiki/Control_flow">https://en.wikipedia.org/wiki/Control_flow</a>
</li>

<li>Structured programming<br />
<a href="https://en.wikipedia.org/wiki/Structured_programming">https://en.wikipedia.org/wiki/Structured_programming</a>
</li>

<li>Control Structures<br />
<a href="https://www.golang-book.com/books/intro/5">https://www.golang-book.com/books/intro/5</a>
</li>

<li>Control structures - Go if else statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html">http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html</a>
</li>

<li>Control structures - Go switch case statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html</a>
</li>

<li>Control structures - Go for loop, break, continue, range<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html</a>
</li>

<li>Single Function Exit Point<br />
<a href="http://wiki.c2.com/?SingleFunctionExitPoint">http://wiki.c2.com/?SingleFunctionExitPoint</a>
</li>

<li>Entry point<br />
<a href="https://en.wikipedia.org/wiki/Entry_point">https://en.wikipedia.org/wiki/Entry_point</a>
</li>

<li>Why does Go have a GOTO statement?!<br />
<a href="https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/">https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/</a>
</li>

<li>Effective Go<br />
<a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a>
</li>

<li>GoClipse: an Eclipse IDE for the Go programming language<br />
<a href="http://goclipse.github.io/">http://goclipse.github.io/</a>
</li>

<li>GoClipse Installation<br />
<a href="https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation">https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

