<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Go a assembler</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Go a assembler</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Při tvorbě aplikací v jazyce Go se můžeme (i když nikoli příliš často) dostat do situace, v níž je nutné použít nízkoúrovňový přístup na úrovni assembleru. A právě vlastnostmi poměrně specifického assembleru jazyka Go se budeme zabývat v dnešním článku.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Go a assembler</a></p>
<p><a href="#k02">2. Vznik jazyka &bdquo;assembly language&ldquo; a nástroje nazvaného assembler</a></p>
<p><a href="#k03">3. Assemblery na domácích osmibitových mikropočítačích i na počítačích s&nbsp;procesory Motorola 68000</a></p>
<p><a href="#k04">4. Assemblery v&nbsp;Linuxu</a></p>
<p><a href="#k05">5. Assembler a programovací jazyk Go</a></p>
<p><a href="#k06">6. Kód v&nbsp;assembleru generovaný překladačem jazyka Go</a></p>
<p><a href="#k07">7. Nástroj <strong>objdump</strong> pro programovací jazyk Go</a></p>
<p><a href="#k08">8. Inlining funkcí při optimalizacích prováděných překladačem jazyka Go</a></p>
<p><a href="#k09">9. Překlad jednoduché funkce se zákazem inliningu</a></p>
<p><a href="#k10">10. Funkce <strong>Add</strong> přeložená pro jiné architektury</a></p>
<p><a href="#k11">11. Kostra aplikace, v&nbsp;níž je jedna funkce vytvořená v&nbsp;assembleru</a></p>
<p><a href="#k12">12. Vytvoření funkce v&nbsp;assembleru, překlad programu</a></p>
<p><a href="#k13">13. Zjednodušení práce se zásobníkem při čtení operandů funkce</a></p>
<p><a href="#k14">14. Použití pseudoregistru <strong>FP</strong></a></p>
<p><a href="#k15">15. Pojmenování výstupní hodnoty funkce s&nbsp;jejím využitím v&nbsp;assembleru</a></p>
<p><a href="#k16">16. Kód v&nbsp;assembleru určený pro další procesorové architektury</a></p>
<p><a href="#k17">17. Seznam dnes použitých instrukcí</a></p>
<p><a href="#k18">18. Obsah následující části seriálu</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Go a assembler</h2>

<p>V&nbsp;dnešní části seriálu o programovacím jazyku Go se budeme zabývat
tématem, jehož znalost v&nbsp;praxi využijí s&nbsp;velkou pravděpodobností
pouze někteří vývojáři. Na druhou stranu se ovšem jedná o téma, které odhaluje
činnost dalších pomocných nástrojů, které jsou nedílnou součástí ekosystému
tohoto programovacího jazyka. Zabývat se totiž budeme použitím assembleru
v&nbsp;kontextu programovacího jazyka Go. V&nbsp;Go se používá assembler
založený na nástrojích pocházejících původně z&nbsp;operačního systému Plan-9,
jehož některé vlastnosti jsou odlišné od klasického GNU Assembleru (GAS) či od
projektu Netwide Assembler (NASM). Současně se ovšem jedná o assembler, který
je univerzální napříč architekturami (pochopitelně až na odlišný instrukční kód
a sadu pracovních registrů, což jsou věci, jimiž se jednotlivé procesorové
architektury od sebe odlišují).</p>

<p>S&nbsp;assemblerem se v&nbsp;Go setkáme na několika místech, například:</p>

<ol>

<li><a
href="https://www.root.cz/clanky/muzeme-verit-prekladacum-projekty-resici-schema-duverive-duvery/">Bootstraping</a></li>

<li>Implementace některých matematických funkcí ze standardní knihovny</li>

<li>Víceslovní aritmetika a s ní související operace</li>

<li>Implementace krypto funkcí (ty mnohdy používají specializované instrukce),
opět použito i ve standardní knihovně</li>

<li>Synchronizační primitiva (zámky atd.)</li>

<li>Kód, který lze převést na vektorové instrukce (audio a video processing
atd.)</li>

<li>A pochopitelně i další části kódu, jehož sémantiku nelze přesně vyjádřit
vysokoúrovňovým jazykem (práce s&nbsp;příznaky, různé operace typu prokládání
bitů, vyhledávání v&nbsp;bitovém vzorku atd.)</li>

</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vznik jazyka &bdquo;assembly language&ldquo; a nástroje nazvaného assembler</h2>

<p><i>Assemblery</i> za sebou mají velmi dlouhý vývoj, protože první nástroje,
které se začaly tímto názvem označovat, vznikly již v&nbsp;padesátých letech
minulého století, a to na <i>mainframech</i> vyráběných společností IBM i
jejími konkurenty (UNIVAC, Burroughs, Honeywell, General Electric atd.). Před
vznikem skutečných assemblerů byla situace poněkud složitá. První aplikace pro
mainframy totiž byly většinou programovány přímo ve strojovém kódu, který bylo
možné přímo zadávat z&nbsp;takzvaného <i>řídicího panelu (control panel)</i>
počítače či načítat z&nbsp;externích paměťových médií (děrných štítků,
magnetických pásek atd.). Ovšem zapisovat programy přímo ve strojovém kódu je
zdlouhavé, vedoucí k&nbsp;častým chybám a pro větší aplikace z&nbsp;mnoha
důvodů nepraktické, o čemž se ostatně mohli relativně nedávno přesvědčit
například i studenti programující na československém mikropočítači
<i>PMI-80</i> (na druhou stranu se ovšem jednalo o vynikající učební
pomůcku).</p>

<p>Z&nbsp;důvodu usnadnění práce programátorů a pro snížení počtu chyb (oprava
chyby, resp.&nbsp;další iterace vývoje, byla velmi drahá a zdlouhavá) tedy
vznikly první utility, jejichž úkolem bylo transformovat programy zapsané
s&nbsp;využitím symbolických jmen strojových instrukcí do (binárního)
strojového kódu určeného pro konkrétní typ počítače a jeho procesoru.</p>

<img src="https://i.iinfo.cz/images/68/go-asm-1.png" class="image-401981" alt="&#160;" width="383" height="694" />
<p><i>Obrázek 1: Kód v&nbsp;assembleru je možné, pochopitelně pokud to daný
assembler umožňuje, psát i strukturovaně, používat subrutiny a funkce
atd.</i></p>

<p>Těmto programům, jejichž možnosti se postupně vylepšovaly (například do nich
přibyla podpora textových maker, řízení víceprůchodového překladu, vytváření
výstupních sestav s&nbsp;překládanými symboly, později i skutečné linkování
s&nbsp;knihovnami atd.), se začalo říkat <i>assemblery</i> a jazyku pro
symbolický zápis programů pak <i>jazyk symbolických instrukcí</i> či <i>jazyk
symbolických adres</i> &ndash; <i>assembly language</i> (někdy též zkráceně
nazývaný assembler, takže toto slovo má vlastně dodnes oba dva významy).
Jednalo se o svým způsobem převratnou myšlenku: sám počítač byl použit pro
tvorbu programů, čímž odpadla namáhavá práce s&nbsp;tužkou a papírem. Posléze
se zjistilo, že i programování přímo v&nbsp;assembleru je většinou pracné a
zdlouhavé, takže se na mainframech začaly používat různé vyšší programovací
jazyky, zejména FORTRAN a COBOL. Použití vyšších programovacích jazyků bylo
umožněno relativně vysokým výpočetním výkonem mainframů i (opět relativně)
velkou kapacitou operační paměti; naopak se díky vyšším programovacím jazykům
mohly aplikace přenášet na různé typy počítačů, což je nesporná výhoda.</p>

<img src="https://i.iinfo.cz/images/68/go-asm-2.png" class="image-401982" alt="&#160;" width="672" height="480" />
<p><i>Obrázek 2: Assembler pro počítače Commodore C64.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Assemblery na domácích osmibitových mikropočítačích i na počítačích s&nbsp;procesory Motorola 68000</h2>

<p>Oživení zájmu o programování v&nbsp;assembleru přinesl vznik minipočítačů
(například známé řady <i>PDP</i>) a na konci sedmdesátých let minulého století
pak zcela nového fenoménu, který nakonec přepsal celé dějiny výpočetní techniky
&ndash; domácích osmibitových mikropočítačů. Na osmibitových domácích
mikropočítačích se používaly dva typy <i>assemblerů</i>. Prvním typem byly
assemblery interaktivní, které uživateli nabízely poměrně komfortní vývojové
prostředí, v&nbsp;němž bylo možné zapisovat jednotlivé instrukce
v&nbsp;symbolické podobě, spouštět programy, krokovat je, vypisovat obsahy
pracovních registrů mikroprocesoru atd. Výhodou byla nezávislost těchto
assemblerů na rychlém externím paměťovém médiu (například disketové jednotce),
který mnoho uživatelů a programátorů ani nevlastnilo. Druhý typ assemblerů je
používán dodnes &ndash; jedná se vlastně o běžné překladače, kterým se na
vstupu předloží zdrojový kód (uložený na kazetě či disketě) a po překladu se
výsledný nativní kód taktéž uloží na paměťové médium (odkud ho lze následně
spustit). Tyto assemblery byly mnohdy vybaveny více či méně dokonalým systémem
maker (odtud ostatně pochází i označení <i>macroassembler</i>).</p>

<img src="https://i.iinfo.cz/images/68/go-asm-3.png" class="image-401983" alt="&#160;" width="672" height="480" />
<p><i>Obrázek 3: Atari Macro Assembler.</i></p>

<p>Assemblery byly mezi programátory poměrně populární i na osobních počítačích
<i>Amiga</i> a <i>Atari ST</i>, a to i díky tomu, že instrukční kód
mikroprocesorů <i>Motorola 68000</i> byl do značné míry ortogonální, obsahoval
relativně velké množství registrů (univerzální datové registry D0 až D7 a
adresové registry A0 až A7) a navíc bylo možné používat i takové adresovací
režimy, které korespondovaly s&nbsp;konstrukcemi používanými ve vyšších
programovacích jazycích (přístupy k&nbsp;prvkům polí, přístup k&nbsp;lokálním
proměnným umístěných v&nbsp;zásobníkovém rámci, autoinkrementace adresy atd.).
Podívejme se na jednoduchý příklad rutiny (originál najdete <a
href="http://www.virtualdub.org/blog/pivot/entry.php?id=84">zde</a>), která
sečte všechny prvky (16bitové integery &ndash; načítá se vždy jen 16bitové
slovo) v&nbsp;poli. V&nbsp;tomto příkladu se používá autoinkrementace adresy
při adresování prvků polí a taktéž instrukce <strong>DBRA</strong> provádí dvě
činnosti &ndash; snížení hodnoty registru o jedničku a skok v&nbsp;případě, že
je výsledek nenulový:</p>

<pre>
    moveq #0, d0      ; potřebujeme vynulovat horních 16 bitů d0
    moveq #0, d1      ; mezivýsledek
loop:
    move.w (a0)+, d0  ; horních 16 bitů d0 je pořád nastaveno na 0
    add.l d0, d1
    dbra d2, loop     ; d2 je použit jako počitadlo
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Assemblery v&nbsp;Linuxu</h2>

<p>V&nbsp;této kapitole budeme pod termínem &bdquo;assembler&ldquo; chápat
programový nástroj určený pro transformaci zdrojového kódu naprogramovaného
v&nbsp;jazyku symbolických adres do strojového kódu. Pro Linux vzniklo hned
několik takových nástrojů, přičemž některé nástroje jsou komerční a jiné patří
mezi open source. Z&nbsp;nekomerčních nástrojů, které nás samozřejmě zajímají
především, se jedná o známý <i>GNU Assembler</i>, dále pak o nástroj nazvaný
<i>Netwide assembler (NASM)</i>, nástroj <i>Yasm Modular Assembler</i> či až
překvapivě výkonný <i>vasm</i>. <i>NASM</i> a <i>Yasm</i> jsou pro první krůčky
v&nbsp;assembleru velmi dobře použitelné, neboť mají dobře zpracovaný
mechanismus reakce na chyby, dají se v&nbsp;nich psát čitelné programy atd.
Určitý problém nastává v&nbsp;případě, kdy je nutné vyvíjet aplikace určené pro
jinou architekturu, než je i386 či x86_64, a to z&nbsp;toho důvodu, že ani
<i>Netwide assembler</i> ani <i>Yasm</i> nedokážou pracovat s&nbsp;odlišnou
instrukční sadou. Naproti tomu <i>GNU Assembler</i> tímto problémem ani zdaleka
netrpí, ovšem zápis assembleru se pro každou architekturu odlišuje (což se
například týká i zápisu poznámek atd.).</p>

<p><i>GNU Assembler</i> (<i>gas</i>) je součástí skupiny nástrojů nazvaných
<i>GNU Binutils</i>. Jedná se o nástroje určené pro vytváření a správu
binárních souborů obsahujících takzvaný &bdquo;objektový kód&ldquo;, dále
nástrojů určených pro práci s&nbsp;knihovnami strojových funkcí i pro
profilování. Mezi <i>GNU Binutils</i> patří vedle <i>GNU Assembleru</i> i
linker <strong>ld</strong>, profiler <strong>gprof</strong>, správce archivů
strojových funkcí <strong>ar</strong>, nástroj pro odstranění symbolů
z&nbsp;objektových a spustitelných souborů <strong>strip</strong> a několik
pomocných utilit typu <strong>nm</strong>, <strong>objdump</strong>,
<strong>size</strong> a <strong>strings</strong>. <i>GNU Assembler</i> je možné
použít buď pro překlad uživatelem vytvořených zdrojových kódů nebo pro
zpracování kódů vygenerovaných překladači vyšších programovacích jazyků
(<strong>GCC</strong> atd.). Zajímavé je, že všechny moderní verze <i>GNU
Assembleru</i> podporují jak původní AT&amp;T syntaxi, tak i (podle mě
čitelnější) syntaxi používanou společností Intel.</p>

<p><i>Netwide Assembler (NASM)</i> vznikl v&nbsp;době, kdy začali na operační
systém Linux přecházet programátoři znající operační systémy DOS a (16/32bit)
Windows. Tito programátoři byli většinou dobře seznámeni s&nbsp;možnostmi
assemblerů, které se na těchto platformách používaly nejčastěji &ndash;
<i>Turbo Assembleru (TASM)</i> společnosti Borland i <i>Microsoft Macro
Assembleru (MASM)</i> a tak jim možnosti <i>GNU Assembleru</i> (který má své
kořeny na odlišných architekturách) příliš nevyhovovaly. Výsledkem snah o
vytvoření nástroje podobnému <i>TASMu</i> či <i>MASMu</i> byl právě
<i>NASM</i>, který podporuje stejný způsob zápisu operandů instrukcí a navíc
ještě zjednodušuje zápis těch instrukcí, u nichž je jeden operand tvořen
nepřímou adresou. <i>NASM</i> byl následován projektem <i>Yasm</i>
(fork+přepis), ovšem základní vlastnosti a především pak vazba na platformu
i386 a x86_64 zůstaly zachovány (to mj.&nbsp;znamená, že například na
<i>Raspberry Pi</i> možnosti těchto dvou nástrojů plně nevyužijeme, což je
určitě škoda; situace je o to zajímavější, že původní autor NASMu nyní pracuje
pro společnost ARM).</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Assembler a programovací jazyk Go</h2>

<p>Jak jsme si již naznačili <a href="#k01">v&nbsp;úvodní kapitole</a>, používá
se v&nbsp;programovacím jazyku Go assembler odvozený od assembleru
z&nbsp;operačního systému Plan-9. Důvodů, proč se používá zvláštní assembler a
nikoli například výše zmíněný GNU Assembler je několik. Kromě toho, že autoři
Go (pochopitelně) velmi dobře znají Plan-9 je assembler využitý v&nbsp;Go
napsán unifikovaně &ndash; velká část jeho zdrojového kódu je sdílena pro
všechny podporované mikroprocesorové architektury. Taktéž syntaxe assembleru
v&nbsp;Go je totožná pro všechny architektury, což v&nbsp;případě GNU
Assembleru neplatí, protože zde nalezneme snahu o dodržení konvencí zavedených
různými výrobci čipů. O tom se ostatně můžeme snadno přesvědčit, například
na aplikaci typu &bdquo;Hello world&ldquo;.</p>

<p>Architektura i386:</p>

<pre>
# Linux kernel system call table
sys_exit=1
sys_write=4
&nbsp;
.section .data
&nbsp;
hello_lbl:
        .string "Hello World!\n"
&nbsp;
.section .text
        .global _start          # tento symbol ma byt dostupny i linkeru
&nbsp;
_start:
        mov   $sys_write, %eax  # cislo syscallu pro funkci "write"
        mov   $1,%ebx           # standardni vystup
        mov   $hello_lbl,%ecx   # adresa retezce, ktery se ma vytisknout
        mov   $13,%edx          # pocet znaku, ktere se maji vytisknout
        int   $0x80             # volani Linuxoveho kernelu
&nbsp;
        movl  $sys_exit,%eax    # cislo sycallu pro funkci "exit"
        movl  $0,%ebx           # exit code = 0
        int   $0x80             # volani Linuxoveho kernelu
</pre>

<p>Architektura Aarch64:</p>

<pre>
# Linux kernel system call table
sys_exit=93
sys_write=64
&nbsp;
.section .data
&nbsp;
hello_lbl:
        .string "Hello World!\n"
&nbsp;
.section .bss
&nbsp;
.section .text
        .global _start          // tento symbol ma byt dostupny i linkeru
&nbsp;
_start:
        mov  x8, #sys_write     // cislo sycallu pro funkci "write"
        mov  x0, #1             // standardni vystup
        ldr  x1, =hello_lbl     // adresa retezce, ktery se ma vytisknout
        mov  x2, #13            // pocet znaku, ktere se maji vytisknout
        svc  0                  // volani Linuxoveho kernelu
&nbsp;
        mov  x8, #sys_exit      // cislo sycallu pro funkci "exit"
        mov  x0, #0             // exit code = 0
        svc  0                  // volani Linuxoveho kernelu
</pre>

<p>Architektura s390 (autorem je v&nbsp;tomto případě Honza Horák):</p>

<pre>
# Linux kernel system call table
sys_exit=1
sys_write=4
&nbsp;
.section .data
&nbsp;
hello_lbl:
        .string "Hello World!\n"
&nbsp;
.section .bss
&nbsp;
.section .text
        .global _start          # tento symbol ma byt dostupny i linkeru
&nbsp;
_start:
        basr  13,0              # nastaveni literal poolu
.L0:    ahi   13,.LT0-.L0
        la    1,sys_write       # cislo syscallu pro funkci "write"
        la    2,1               # standardni vystup
        l     3,.LC1-.LT0(13)   # adresa retezce, ktery se ma vytisknout
        la    4,13              # pocet znaku, ktere se maji vytisknout
        svc   0                 # volani Linuxoveho kernelu
&nbsp;
        la    1,sys_exit        # cislo sycallu pro funkci "exit"
        la    2,0               # exit code = 0
        svc   0                 # volani Linuxoveho kernelu
&nbsp;
# literal pool
.LT0:
.LC1:   .long   hello_lbl
</pre>

<p>Architektura PPC64 (autorem je Rafael Fonseca):</p>

<pre>
# Linux kernel system call table
sys_exit=1
sys_write=4
&nbsp;
.section .data
hello_lbl:
        .ascii "Hello World!\n"
&nbsp;
hello_length = . - hello_lbl
&nbsp;
.section .text
.global _start
.section ".opd", "aw"
.balign 8
_start:
        .quad ._start, .TOC.@tocbase, 0
        .previous
&nbsp;
.global ._start
._start:
        li      0,sys_write             # cislo syscallu pro funkci "write"
        li      3,1                     # fd = 1 (stdout)
        lis     4,hello_lbl@highest     # load buffer
        ori     4,4,hello_lbl@higher
        rldicr  4,4,32,31
        oris    4,4,hello_lbl@h
        ori     4,4,hello_lbl@l
        li      5,hello_length          # size
        sc                              # volani Linuxoveho kernelu
&nbsp;
        li      0,sys_exit              # cislo syscallu pro funkci "exit"
        li      3,0                     # exit code = 0
        sc                              # volani Linuxoveho kernelu
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jak se od sebe odlišuje
pojmenování registrů, zápis jmen registrů, adresování, zápis poznámek atd. Toto
vše jsou syntaktické kategorie, které je možné do určité míry sjednotit
(samozřejmě se to netýká instrukčního kódu).</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Kód v&nbsp;assembleru generovaný překladačem jazyka Go</h2>

<p>Nejprve se podívejme na možnosti vybraných nástrojů, které jsou součástí
standardní instalace programovacího jazyka Go. První nástroj se jmenuje
<strong>compile</strong> a provádí &ndash; jak již jeho název naznačuje &ndash;
překlad zdrojových kódů z&nbsp;Go do objektového kódu. Přepínačem
<strong>-S</strong> můžeme vynutit výpis generovaného objektového kódu
v&nbsp;symbolické podobě. Překládat budeme tento zdrojový kód (nejkratší
korektně zapsaný program):</p>

<pre>
package <strong>main</strong>
&nbsp;
func <strong>main</strong>() {
}
</pre>

<p>Překlad s&nbsp;výpisem (pseudo)objektového kódu se provede takto:</p>

<pre>
$ <strong>go tool compile -S asm01.go</strong>
</pre>

<p>Výsledkem může být následující text:</p>

<pre>
# command-line-arguments
"".main STEXT nosplit size=1 args=0x0 locals=0x0
        0x0000 00000 (/home/tester/go-root/article_53/asm01.go:3)  TEXT    "".main(SB), NOSPLIT, $0-0
        0x0000 00000 (/home/tester/go-root/article_53/asm01.go:3)  FUNCDATA        $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (/home/tester/go-root/article_53/asm01.go:3)  FUNCDATA        $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (/home/tester/go-root/article_53/asm01.go:3)  FUNCDATA        $3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (/home/tester/go-root/article_53/asm01.go:4)  RET
        0x0000 c3                                               .
"".init STEXT size=80 args=0x0 locals=0x8
        0x0000 00000 (&lt;autogenerated&gt;:1)  TEXT    "".init(SB), $8-0
        0x0000 00000 (&lt;autogenerated&gt;:1)  MOVQ    (TLS), CX
        0x0009 00009 (&lt;autogenerated&gt;:1)  CMPQ    SP, 16(CX)
        0x000d 00013 (&lt;autogenerated&gt;:1)  JLS     73
        0x000f 00015 (&lt;autogenerated&gt;:1)  SUBQ    $8, SP
        0x0013 00019 (&lt;autogenerated&gt;:1)  MOVQ    BP, (SP)
        0x0017 00023 (&lt;autogenerated&gt;:1)  LEAQ    (SP), BP
        0x001b 00027 (&lt;autogenerated&gt;:1)  FUNCDATA        $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x001b 00027 (&lt;autogenerated&gt;:1)  FUNCDATA        $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x001b 00027 (&lt;autogenerated&gt;:1)  FUNCDATA        $3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x001b 00027 (&lt;autogenerated&gt;:1)  PCDATA  $2, $0
        0x001b 00027 (&lt;autogenerated&gt;:1)  PCDATA  $0, $0
        0x001b 00027 (&lt;autogenerated&gt;:1)  MOVBLZX "".initdone·(SB), AX
        0x0022 00034 (&lt;autogenerated&gt;:1)  CMPB    AL, $1
        0x0025 00037 (&lt;autogenerated&gt;:1)  JLS     48
        0x0027 00039 (&lt;autogenerated&gt;:1)  PCDATA  $2, $-2
        0x0027 00039 (&lt;autogenerated&gt;:1)  PCDATA  $0, $-2
        0x0027 00039 (&lt;autogenerated&gt;:1)  MOVQ    (SP), BP
        0x002b 00043 (&lt;autogenerated&gt;:1)  ADDQ    $8, SP
        0x002f 00047 (&lt;autogenerated&gt;:1)  RET
        0x0030 00048 (&lt;autogenerated&gt;:1)  JNE     57
        0x0032 00050 (&lt;autogenerated&gt;:1)  PCDATA  $2, $0
        0x0032 00050 (&lt;autogenerated&gt;:1)  PCDATA  $0, $0
        0x0032 00050 (&lt;autogenerated&gt;:1)  CALL    runtime.throwinit(SB)
        0x0037 00055 (&lt;autogenerated&gt;:1)  UNDEF
        0x0039 00057 (&lt;autogenerated&gt;:1)  MOVB    $2, "".initdone·(SB)
        0x0040 00064 (&lt;autogenerated&gt;:1)  MOVQ    (SP), BP
        0x0044 00068 (&lt;autogenerated&gt;:1)  ADDQ    $8, SP
        0x0048 00072 (&lt;autogenerated&gt;:1)  RET
        0x0049 00073 (&lt;autogenerated&gt;:1)  NOP
        0x0049 00073 (&lt;autogenerated&gt;:1)  PCDATA  $0, $-1
        0x0049 00073 (&lt;autogenerated&gt;:1)  PCDATA  $2, $-1
        0x0049 00073 (&lt;autogenerated&gt;:1)  CALL    runtime.morestack_noctxt(SB)
        0x004e 00078 (&lt;autogenerated&gt;:1)  JMP     0
        0x0000 64 48 8b 0c 25 00 00 00 00 48 3b 61 10 76 3a 48  dH..%....H;a.v:H
        0x0010 83 ec 08 48 89 2c 24 48 8d 2c 24 0f b6 05 00 00  ...H.,$H.,$.....
        0x0020 00 00 80 f8 01 76 09 48 8b 2c 24 48 83 c4 08 c3  .....v.H.,$H....
        0x0030 75 07 e8 00 00 00 00 0f 0b c6 05 00 00 00 00 02  u...............
        0x0040 48 8b 2c 24 48 83 c4 08 c3 e8 00 00 00 00 eb b0  H.,$H...........
        rel 5+4 t=16 TLS+0
        rel 30+4 t=15 "".initdone·+0
        rel 51+4 t=8 runtime.throwinit+0
        rel 59+4 t=15 "".initdone·+-1
        rel 74+4 t=8 runtime.morestack_noctxt+0
go.loc."".main SDWARFLOC size=0
go.info."".main SDWARFINFO size=33
        0x0000 02 22 22 2e 6d 61 69 6e 00 00 00 00 00 00 00 00  ."".main........
        0x0010 00 00 00 00 00 00 00 00 00 01 9c 00 00 00 00 01  ................
        0x0020 00                                               .
        rel 9+8 t=1 "".main+0
        rel 17+8 t=1 "".main+1
        rel 27+4 t=29 gofile../home/tester/go-root/article_53/asm01.go+0
go.range."".main SDWARFRANGE size=0
go.isstmt."".main SDWARFMISC size=0
        0x0000 04 01 00                                         ...
go.loc."".init SDWARFLOC size=0
go.info."".init SDWARFINFO size=33
        0x0000 02 22 22 2e 69 6e 69 74 00 00 00 00 00 00 00 00  ."".init........
        0x0010 00 00 00 00 00 00 00 00 00 01 9c 00 00 00 00 01  ................
        0x0020 00                                               .
        rel 9+8 t=1 "".init+0
        rel 17+8 t=1 "".init+80
        rel 27+4 t=29 gofile..&lt;autogenerated&gt;+0
go.range."".init SDWARFRANGE size=0
go.isstmt."".init SDWARFMISC size=0
        0x0000 04 0f 04 0c 03 07 01 05 02 09 01 07 02 09 01 09  ................
        0x0010 02 07 00                                         ...
"".initdone· SNOPTRBSS size=1
gclocals·33cdeccccebe80329f1fdbee7f5874cb SRODATA dupok size=8
        0x0000 01 00 00 00 00 00 00 00                          ........
</pre>

<p><div class="rs-tip-major">Poznámka: jednotlivými sekcemi se budeme
podrobněji zabývat v&nbsp;navazující části tohoto seriálu.</div></p>

<p>Překlad lze provést pro různé architektury mikroprocesorů a pro různé
operační systémy (provádí se tedy crosspřeklad). Použijeme přitom standardní
prostředky programovacího jazyka Go; žádné další nástroje ani knihovny nejsou
zapotřebí!:</p>

<pre>
$ <strong>GOOS=linux GOARCH=386 go tool compile -S asm01.go</strong>
</pre>

<pre>
$ <strong>GOOS=linux GOARCH=arm go tool compile -S asm01.go</strong>
</pre>

<pre>
$ <strong>GOOS=linux GOARCH=arm64 go tool compile -S asm01.go</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si prozatím pouze odlišných
instrukcí pro různé mikroprocesorové architektury.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Nástroj <strong>objdump</strong> pro programovací jazyk Go</h2>

<p>Další nástroj, který je užitečný zejména při studiu strojového kódu
vygenerovaného překladačem programovacího jazyka Go, je utilita nazvaná
<strong>objdump</strong>. Tento nástroj (ve variantě pro Go) se spouští pomocí
<strong>go tool objdump</strong> a přepínačem <strong>-s</strong> lze zvolit
funkci či další typ objektu, který se ve výsledném spustitelném souboru vyhledá
a provede se jeho/její disassembling, tj.&nbsp;zpětná rekonstrukce kódu
v&nbsp;assembleru. Pro výše uvedený program s&nbsp;prázdnou funkcí
<strong>main</strong>:</p>

<pre>
package<strong> main</strong>
&nbsp;
func <strong>main</strong>() {
}
</pre>

<p>tedy získáme:</p>

<pre>
$ <strong>go tool objdump -s main.main asm01</strong>
&nbsp;
TEXT main.main(SB) /home/tester/go-root/article_53/asm01.go
  asm01.go:4            0x44ea70                c3                      RET
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že prázdná funkce
<strong>main</strong> je skutečně přeložena tím nejjednodušším a nejkratším
kódem &ndash; pouhou instrukcí typu <i>return</i>.</div></p>

<p>Nyní se pokusme přeložit a následně disassemblovat poněkud složitější
implementaci funkce <strong>main</strong>, která již obsahuje volání jiné
funkce (jedná se o <i>builtin</i> funkci s&nbsp;názvem
<strong>println</strong>):</p>

<pre>
package <strong>main</strong>
&nbsp;
func <strong>main</strong>() {
        println("Hello world!")
}
</pre>

<p>Postup bude následující:</p>

<pre>
$ <strong>go build asm02.go</strong>
&nbsp;
$ <strong>go tool objdump -s main.main asm02</strong>
&nbsp;
TEXT main.main(SB) /home/tester/go-root/article_53/asm02.go
  asm02.go:3            0x44ea70                64488b0c25f8ffffff      MOVQ FS:0xfffffff8, CX
  asm02.go:3            0x44ea79                483b6110                CMPQ 0x10(CX), SP
  asm02.go:3            0x44ea7d                763b                    JBE 0x44eaba
  asm02.go:3            0x44ea7f                4883ec18                SUBQ $0x18, SP
  asm02.go:3            0x44ea83                48896c2410              MOVQ BP, 0x10(SP)
  asm02.go:3            0x44ea88                488d6c2410              LEAQ 0x10(SP), BP
  asm02.go:4            0x44ea8d                e82e41fdff              CALL runtime.printlock(SB)
  asm02.go:4            0x44ea92                488d0590e50100          LEAQ 0x1e590(IP), AX
  asm02.go:4            0x44ea99                48890424                MOVQ AX, 0(SP)
  asm02.go:4            0x44ea9d                48c74424080d000000      MOVQ $0xd, 0x8(SP)
  asm02.go:4            0x44eaa6                e8354afdff              CALL runtime.printstring(SB)
  asm02.go:4            0x44eaab                e89041fdff              CALL runtime.printunlock(SB)
  asm02.go:5            0x44eab0                488b6c2410              MOVQ 0x10(SP), BP
  asm02.go:5            0x44eab5                4883c418                ADDQ $0x18, SP
  asm02.go:5            0x44eab9                c3                      RET
  asm02.go:3            0x44eaba                e83183ffff              CALL runtime.morestack_noctxt(SB)
  asm02.go:3            0x44eabf                ebaf                    JMP main.main(SB)
</pre>

<p>Předchozí kód může být u delších funkcí poněkud matoucí, ovšem přepínačem
<strong>-S</strong> můžeme zajistit, že se kromě vlastních instrukcí assembleru
vždy vypíšou i příslušné příkazy, které programátor použil v&nbsp;původním
zdrojovém kódu:</p>

<pre>
$ <strong>go tool objdump -S -s main.main asm02</strong>
&nbsp;
TEXT main.main(SB) /home/tester/go-root/article_53/asm02.go
func main() {
  0x44ea70              64488b0c25f8ffffff      MOVQ FS:0xfffffff8, CX
  0x44ea79              483b6110                CMPQ 0x10(CX), SP
  0x44ea7d              763b                    JBE 0x44eaba
  0x44ea7f              4883ec18                SUBQ $0x18, SP
  0x44ea83              48896c2410              MOVQ BP, 0x10(SP)
  0x44ea88              488d6c2410              LEAQ 0x10(SP), BP
        println("Hello world!")
  0x44ea8d              e82e41fdff              CALL runtime.printlock(SB)
  0x44ea92              488d0590e50100          LEAQ 0x1e590(IP), AX
  0x44ea99              48890424                MOVQ AX, 0(SP)
  0x44ea9d              48c74424080d000000      MOVQ $0xd, 0x8(SP)
  0x44eaa6              e8354afdff              CALL runtime.printstring(SB)
  0x44eaab              e89041fdff              CALL runtime.printunlock(SB)
}
  0x44eab0              488b6c2410              MOVQ 0x10(SP), BP
  0x44eab5              4883c418                ADDQ $0x18, SP
  0x44eab9              c3                      RET
func main() {
  0x44eaba              e83183ffff              CALL runtime.morestack_noctxt(SB)
  0x44eabf              ebaf                    JMP main.main(SB)
</pre>

<p><div class="rs-tip-major">Poznámka: prozatím se mohou všechny uváděné
postupy zdát poněkud umělé, ovšem znalost všech nástrojů využijeme
v&nbsp;dalších příkladech.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Inlining funkcí při optimalizacích prováděných překladačem jazyka Go</h2>

<p>Podobným způsobem, jaký byl popsán <a href="#k07">v&nbsp;předchozí
kapitole</a>, se pokusme přeložit a analyzovat následující jednoduchý
prográmek, v&nbsp;němž je deklarována funkce provádějící součet svých dvou
celočíselných operandů:</p>

<pre>
package <strong>main</strong>
&nbsp;
func <strong>Add</strong>(x int, y int) int {
        return x + y
}
&nbsp;
func <strong>main</strong>() {
        println(Add(1, 2))
}
</pre>

<p>Překlad:</p>

<pre>
$ <strong>go build asm02.go</strong>
</pre>

<p>Analýza funkce <strong>main</strong> nástrojem <strong>objdump</strong>:</p>

<pre>
$ <strong>go tool objdump -S -s main.main asm03</strong>
&nbsp;
TEXT main.main(SB) /home/tester/go-root/article_53/asm03.go
func main() {
  0x44ea70              64488b0c25f8ffffff      MOVQ FS:0xfffffff8, CX
  0x44ea79              483b6110                CMPQ 0x10(CX), SP
  0x44ea7d              7634                    JBE 0x44eab3
  0x44ea7f              4883ec10                SUBQ $0x10, SP
  0x44ea83              48896c2408              MOVQ BP, 0x8(SP)
  0x44ea88              488d6c2408              LEAQ 0x8(SP), BP
        println(Add(1, 2))
  0x44ea8d              e82e41fdff              CALL runtime.printlock(SB)
  0x44ea92              48c7042403000000        MOVQ $0x3, 0(SP)
  0x44ea9a              e89148fdff              CALL runtime.printint(SB)
  0x44ea9f              e89c43fdff              CALL runtime.printnl(SB)
  0x44eaa4              e89741fdff              CALL runtime.printunlock(SB)
}
  0x44eaa9              488b6c2408              MOVQ 0x8(SP), BP
  0x44eaae              4883c410                ADDQ $0x10, SP
  0x44eab2              c3                      RET
func main() {
  0x44eab3              e83883ffff              CALL runtime.morestack_noctxt(SB)
  0x44eab8              ebb6                    JMP main.main(SB)
</pre>

<p>Povšimněte si, že se v&nbsp;tomto kódu nikde nevyskytuje volání funkce
<strong>add</strong>! Veškerá volání (tedy instrukce <strong>CALL</strong>)
slouží pro výpis textů na standardní výstup. Jak je to možné? Vždyť při
spuštění programu můžeme vidět, že se výpočet provedl, resp.&nbsp;přesněji
řečeno, že se vypsal jeho výsledek.</p>

<p>Překladač programovacího jazyka Go ve skutečnosti provádí řadu optimalizací
(a to implicitně). Jednou z&nbsp;těchto optimalizací je <i>inlining</i> funkcí,
aby se zamezilo pomalým instrukcím typu <strong>CALL</strong> a
<strong>RET</strong>, které porušují <i>pipeline</i> v&nbsp;procesoru. A po
provedení inliningu se provádí i další optimalizace typu vyhodnocení
konstantních výrazů atd.</p>

<p>O tom, že se inlining skutečně provádí, se můžeme snadno přesvědčit, a to
použitím přepínačů <strong>-gcflags</strong> a <strong>-m</strong> při
překladu:</p>

<pre>
$ <strong>go build -gcflags -m asm03.go </strong>
</pre>

<p>Nyní se při překladu vypíšou informace o provedeném inliningu, z&nbsp;něhož
je zřejmé, že volání funkce <strong>Add</strong> v&nbsp;disassemblovaném
strojovém kódu neuvidíme:</p>

<pre>
# command-line-arguments
./asm03.go:3:6: can inline Add
./asm03.go:7:6: can inline main
./asm03.go:8:13: inlining call to Add
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Překlad jednoduché funkce se zákazem inliningu</h2>

<p>Nyní se pokusme přeložit stejný zdrojový kód, ovšem bez použití
inliningu:</p>

<pre>
package <strong>main</strong>
&nbsp;
func <strong>Add</strong>(x int, y int) int {
        return x + y
}
&nbsp;
func <strong>main</strong>() {
        println(Add(1, 2))
}
</pre>

<p>Překlad se zákazem optimalizací zajistí takto upravený příkaz
<strong>build</strong>:</p>

<pre>
$ <strong>go build -gcflags '-N -l' asm03.go</strong>
</pre>

<p>Nyní si můžeme zobrazit neoptimalizovanou variantu funkce
<strong>main</strong>, ve které je jasně patrné předávání parametrů do
<strong>Add</strong> a volání této funkce (zvýrazněno):</p>

<pre>
$ <strong>go tool objdump -S -s main.main asm03</strong>
&nbsp;
TEXT main.main(SB) /home/tester/go-root/article_53/asm03.go
func main() {
  0x44ea90              64488b0c25f8ffffff      MOVQ FS:0xfffffff8, CX
  0x44ea99              483b6110                CMPQ 0x10(CX), SP
  0x44ea9d              7655                    JBE 0x44eaf4
  0x44ea9f              4883ec28                SUBQ $0x28, SP
  0x44eaa3              48896c2420              MOVQ BP, 0x20(SP)
  0x44eaa8              488d6c2420              LEAQ 0x20(SP), BP
        println(Add(1, 2))
  0x44eaad              48c7042401000000        <strong>MOVQ $0x1, 0(SP)</strong>
  0x44eab5              48c744240802000000      <strong>MOVQ $0x2, 0x8(SP)</strong>
  0x44eabe              e8adffffff              <strong>CALL main.Add(SB)</strong>
  0x44eac3              488b442410              MOVQ 0x10(SP), AX
  0x44eac8              4889442418              MOVQ AX, 0x18(SP)
  0x44eacd              e8ee40fdff              CALL runtime.printlock(SB)
  0x44ead2              488b442418              MOVQ 0x18(SP), AX
  0x44ead7              48890424                MOVQ AX, 0(SP)
  0x44eadb              e85048fdff              CALL runtime.printint(SB)
  0x44eae0              e85b43fdff              CALL runtime.printnl(SB)
  0x44eae5              e85641fdff              CALL runtime.printunlock(SB)
}
  0x44eaea              488b6c2420              MOVQ 0x20(SP), BP
  0x44eaef              4883c428                ADDQ $0x28, SP
  0x44eaf3              c3                      RET
func main() {
  0x44eaf4              e8f782ffff              CALL runtime.morestack_noctxt(SB)
  0x44eaf9              eb95                    JMP main.main(SB)
</pre>

<p>A navíc budeme mít k&nbsp;dispozici i disassemblovaný kód funkce
<strong>Add</strong>, který využijeme v&nbsp;dalším textu:</p>

<pre>
$ <strong>go tool objdump -S -s main.Add asm03</strong>
&nbsp;
TEXT main.Add(SB) /home/tester/go-root/article_53/asm03.go
func Add(x int, y int) int {
  0x44ea70              48c744241800000000      MOVQ $0x0, 0x18(SP)
        return x + y
  0x44ea79              488b442408              MOVQ 0x8(SP), AX
  0x44ea7e              4803442410              ADDQ 0x10(SP), AX
  0x44ea83              4889442418              MOVQ AX, 0x18(SP)
  0x44ea88              c3                      RET
</pre>

<p>Tento kód je již tak jednoduchý, že ho můžeme relativně snadno analyzovat
pochopit. Nejdříve je nutné si uvědomit, že jak parametry funkce, tak i její
návratové hodnoty jsou ukládány na zásobníkový rámec (<i>stack frame</i>)
vytvářený při volání funkce, což (poněkud zjednodušeně řečeno) zajistily tyto
instrukce:</p>

<pre>
SUBQ $0x28, SP
MOVQ BP, 0x20(SP)
LEAQ 0x20(SP), BP
</pre>

<p>Adresování parametrů je provedeno relativně vůči hodnotě uložené v&nbsp;SP.
Přitom velikost typu <strong>int</strong> je na 64bitové architektuře AMD64
(x86-64, ...) rovna osmi bajtům. První operand je uložen s&nbsp;offsetem 8,
druhý s&nbsp;offsetem 16 (0x10) a výsledek je na offsetu 24 (0x18). Nyní je
tedy kód zřejmý:</p>

<pre>
MOVQ $0x0, 0x18(SP)      ; výsledek je nejdříve vynulován (nebylo optimalizováno)
MOVQ 0x8(SP), AX         ; první operand na AX
ADDQ 0x10(SP), AX        ; druhý operand je přičten k&nbsp;obsahu AX
MOVQ AX, 0x18(SP)        ; uložení výsledku do příslušného místa v zásobníkovém rámci
RET                      ; návrat z funkce
</pre>

<p><div class="rs-tip-major">Poznámka: velmi pěkně jsou zde vidět specifika
assembleru použitého v&nbsp;Go, zejména poněkud matoucí pojmenování registrů.
AX totiž neodpovídá 16bitovému registru AX, ale EAX (protože je použit
v&nbsp;kontextu instrukce <strong>MOVQ</strong> a <strong>ADDQ</strong>, kde
&bdquo;Q&ldquo; značí &bdquo;quad word&ldquo;). Totéž ostatně platí i pro SP,
který má dva významy, jména pseudoregistru FP atd. atd.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Funkce <strong>Add</strong> přeložená pro jiné architektury</h2>

<p>Pro zajímavost se můžeme podívat, jak se stejná funkce <strong>Add</strong>
přeloží pro další architektury. Nejprve bude uvedena neoptimalizovaná varianta
pro 32bitovou architekturu i386:</p>

<pre>
$ <strong>GOOS=linux GOARCH=386 go build -gcflags '-N -l' asm03.go</strong>
</pre>

<p>Analýza vygenerovaného kódu:</p>

<pre>
$ <strong>go tool objdump -S -s main.Add asm03</strong>
</pre>

<p>S&nbsp;výsledkem, který v&nbsp;tomto případě není tak stručný, jako
v&nbsp;případě 64bitové varianty (liší se práce se zásobníkovým rámcem):</p>

<pre>
TEXT main.Add(SB) /home/tester/go-root/article_53/asm03.go
func Add(x int, y int) int {
  0x808d840             658b0d00000000          MOVL GS:0, CX
  0x808d847             8b89fcffffff            MOVL 0xfffffffc(CX), CX
  0x808d84d             3b6108                  CMPL 0x8(CX), SP
  0x808d850             7615                    JBE 0x808d867
  0x808d852             c744240c00000000        MOVL $0x0, 0xc(SP)
        return x + y
  0x808d85a             8b442404                MOVL 0x4(SP), AX
  0x808d85e             03442408                ADDL 0x8(SP), AX
  0x808d862             8944240c                MOVL AX, 0xc(SP)
  0x808d866             c3                      RET
func Add(x int, y int) int {
  0x808d867             e894b1ffff              CALL runtime.morestack_noctxt(SB)
  0x808d86c             ebd2                    JMP main.Add(SB)
</pre>

<p>32bitový ARM, zde používající klasickou instrukční sadu, tedy nikoli Thumb
ani Thumb-2:</p>

<pre>
$ <strong>GOOS=linux GOARCH=arm go build -gcflags '-N -l' asm03.go</strong>
&nbsp;
$ <strong>go tool objdump -S -s main.Add asm03</strong>
&nbsp;
TEXT main.Add(SB) /home/tester/go-root/article_53/asm03.go
func Add(x int, y int) int {
  0x5e794               e3a00000                MOVW $0, R0
  0x5e798               e58d000c                MOVW R0, 0xc(R13)
        return x + y
  0x5e79c               e59d0008                MOVW 0x8(R13), R0
  0x5e7a0               e59d1004                MOVW 0x4(R13), R1
  0x5e7a4               e0810000                ADD R0, R1, R0
  0x5e7a8               e58d000c                MOVW R0, 0xc(R13)
  0x5e7ac               e28ef000                ADD $0, R14, R15
</pre>

<p><div class="rs-tip-major">Poznámka: tato architektura používá R13 pro
ukazatel na vrchol zásobníku, R14 pro uložení návratové adresy (link register)
a R15 pro uložení programového čítače. Bližší informace o architektuře ARM
najdete v&nbsp;článcích <a
href="https://www.root.cz/clanky/mikroprocesory-s-architekturou-arm/">Mikroprocesory
s architekturou ARM</a>, <a
href="https://www.root.cz/clanky/pohled-programatora-na-mikroprocesory-arm/">Pohled
programátora na mikroprocesory ARM</a> a <a
href="https://www.root.cz/clanky/architektura-mikroradicu-s-jadry-arm-cortex-m3/">Architektura
mikrořadičů s jádry ARM Cortex-M3</a>.</div></p>

<p>A nakonec 64bitový ARM neboli architektura AArch64:</p>

<pre>
$ <strong>GOOS=linux GOARCH=arm64 go build -gcflags '-N -l' asm03.go</strong>
&nbsp;
$ <strong>go tool objdump -S -s main.Add asm03</strong>
&nbsp;
TEXT main.Add(SB) /home/tester/go-root/article_53/asm03.go
func Add(x int, y int) int {
  0x58f30               f9000fff                MOVD ZR, 24(RSP)
        return x + y
  0x58f34               f9400be0                MOVD 16(RSP), R0
  0x58f38               f94007e1                MOVD 8(RSP), R1
  0x58f3c               8b000020                ADD R0, R1, R0
  0x58f40               f9000fe0                MOVD R0, 24(RSP)
  0x58f44               d65f03c0                RET
  0x58f48               00000000                ?
  0x58f4c               00000000                ?
</pre>

<p><div class="rs-tip-major">Poznámka: tuto architekturu jsme si popsali
v&nbsp;článcích <a
href="https://www.root.cz/clanky/64bitove-mikroprocesory-s-architekturou-aarch64/">64bitové
mikroprocesory s architekturou AArch64</a>, <a
href="https://www.root.cz/clanky/instrukcni-sada-aarch64/">Instrukční sada
AArch64</a>, <a
href="https://www.root.cz/clanky/instrukcni-sada-aarch64-2-cast/">Instrukční
sada AArch64 (2.část)</a> a <a
href="https://www.root.cz/clanky/tvorba-a-ladeni-programu-v-assembleru-mikroprocesoru-aarch64/">Tvorba
a ladění programů v&nbsp;assembleru mikroprocesorů AArch64</a>.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Kostra aplikace, v&nbsp;níž je jedna funkce vytvořená v&nbsp;assembleru</h2>

<p>Nyní si již můžeme připravit jednoduchý projekt, v&nbsp;němž bude vybraná
funkce implementovaná v&nbsp;assembleru a následně bude slinkovaná se zbytkem
programu. Vytvoříme si nový adresář, v&nbsp;němž bude projekt uložen:</p>

<pre>
$ <strong>mkdir add05</strong>
</pre>

<p>V&nbsp;tomto adresáři vytvoříme kostru projektu:</p>

<pre>
$ <strong>cd add05</strong>
$ <strong>go mod init add</strong>
</pre>

<p>Předchozí příklad by měl vytvořit soubor &bdquo;go.mod&ldquo;, který bude
obsahovat jediný řádek:</p>

<pre>
module add
</pre>

<p>Ve třetím kroku vytvoříme zdrojový kód programu uložený do souboru
&bdquo;add.go&ldquo;. Povšimněte si, že se sice jedná o syntakticky korektně
zapsaný zdrojový kód, který však nebude samostatně přeložitelný, a to
z&nbsp;toho důvodu, že u funkce <strong>add</strong> chybí její tělo:</p>

<pre>
package <strong>main</strong>
&nbsp;
func <strong>add</strong>(x int64, y int64) int64
&nbsp;
func <strong>main</strong>() {
        println(add(1, 2))
}
</pre>

<p>Pokud se pokusíte tento program přeložit, měl by překladač vypsat chybu:</p>

<pre>
$ <strong>go build </strong>
&nbsp;
# add
./add.go:3:6: missing function body
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vytvoření funkce v&nbsp;assembleru, překlad programu</h2>

<p>Nyní nám zbývá pouhá &bdquo;maličkost&ldquo; &ndash; doimplementovat funkci
<strong>add</strong> v&nbsp;assembleru a nějakým způsobem instruovat překladač,
aby ji použil namísto hlavičky funkce uvedené ve zdrojovém kódu zapsaném
v&nbsp;jazyku Go.</p>

<p>Vytvoříme tedy nový soubor pojmenovaný &bdquo;&ldquo; (použití jména
architektury je zde nutné!), jehož obsah bude následující:</p>

<pre>
TEXT ·add(SB),$0
    MOVQ    $0x0, 0x18(SP)
    MOVQ    0x8(SP), AX
    ADDQ    0x10(SP), AX
    MOVQ    AX, 0x18(SP)
    RET
</pre>

<p>Tento kód si žádá podrobnější vysvětlení. Samotná sekvence instrukcí
v&nbsp;assembleru pro nás nebude nová, protože se jedná o kód vypůjčený
z&nbsp;předchozí analýzy (nijak jsme ho nemodifikovali). Ovšem nový je první
řádek. Podívejme se na něj ještě jednou:</p>

<pre>
TEXT ·add(SB),$0
</pre>

<p>Šestým znakem je &bdquo;·&ldquo; je znak s&nbsp;pozicí v&nbsp;Unikódu 183,
jedná se tedy o znak mimo ASCII (a tudíž obtížně zapsatelný na klávesnici).
Toto je jedna ze specialit assembleru odvozeného od nástrojů z&nbsp;Plan 9,
která je však v&nbsp;ekosystému programovacího jazyka Go používaná na více
místech.</p>

<p>Dále můžeme v&nbsp;kódu vidět několik jmen registrů a pseudoregistrů:</p>

<table>
<tr><th>Registr</th><th>Význam</th></tr>
<tr><td>AX</td><td>registr architektury x86-64 (zde AX/EAX/RAX)</td></tr>
<tr><td>FP</td><td>frame pointer &ndash; pseudoregistr shodný na všech architekturách</td></tr>
<tr><td>SB</td><td>static base pointer &ndash; pseudoregistr shodný na všech architekturách</td></tr>
<tr><td>SP</td><td>stack pointer &ndash; pseudoregistr shodný na všech architekturách</td></tr>
<tr><td>SP</td><td>stack pointer (stejné jméno!) &ndash; registr architektury x86-64</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: v&nbsp;předchozím příkladu je použit
skutečný registr SP, nikoli pseudoregistr (rozlišení je provedeno na základě
zápisu operandů).</div></p>

<p>Program nyní přeložíme běžným způsobem, protože překladač jazyka Go již bude
vědět, kde hledat implementaci funkce <strong>add</strong> a jak tuto funkci
zařadit do výsledného programu:</p>

<pre>
$ <strong>go build</strong>
</pre>

<p>O správném zařazení funkce <strong>add</strong> se lze snadno
přesvědčit:</p>

<pre>
$ <strong>go tool objdump -s main.add add</strong>
&nbsp;
TEXT main.add(SB) /home/tester/go-root/article_53/add04/add_amd64.s
  add_amd64.s:2         0x44ebb0                48c744241800000000      MOVQ $0x0, 0x18(SP)
  add_amd64.s:3         0x44ebb9                488b442408              MOVQ 0x8(SP), AX
  add_amd64.s:4         0x44ebbe                4803442410              ADDQ 0x10(SP), AX
  add_amd64.s:5         0x44ebc3                4889442418              MOVQ AX, 0x18(SP)
  add_amd64.s:6         0x44ebc8                c3                      RET
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zjednodušení práce se zásobníkem při čtení operandů funkce</h2>

<p>Předchozí kód v&nbsp;assembleru nebyl ve skutečnosti příliš čitelný, neboť
jsme v&nbsp;něm ručně specifikovali offsety parametrů uložených na zásobníkovém
rámci:</p>

<pre>
TEXT ·add(SB),$0
    MOVQ    $0x0, 0x18(SP)
    MOVQ    0x8(SP), AX
    ADDQ    0x10(SP), AX
    MOVQ    AX, 0x18(SP)
    RET
</pre>

<p>Kód je však možné upravit takovým způsobem, že se offsety sice stále budou
používat, ale společně s&nbsp;názvem parametru funkce (je jedno, jaký parametr
se zapíše, důležitá je syntax). Syntaxe zápisu je <i>parametr+offset(SP)</i>.
Úpravou syntaxe se automaticky změní i použitý registr: namísto registru SP na
architektuře x86-64 se použije pseuodoregistr (zde však má stejné offsety,
takže to ani nepoznáme). Další změnou je použití dekadické soustavy a taktéž
vynechání první instrukce, která pouze vynuluje obsah 64bitového slova, do
kterého o tři instrukce dál zapíšeme vypočtený výsledek:</p>

<pre>
TEXT ·add(SB),$0
    MOVQ    <strong>x+8(SP)</strong>, AX
    ADDQ    <strong>y+16(SP)</strong>, AX
    MOVQ    AX, 24(SP)
    RET
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;navazujících kapitolách si
ukážeme, že pojmenováním návratové hodnoty (což jazyk Go umožňuje), lze zápis
ještě více zlidštit.</div></p>

<p>Po vytvoření binárního souboru:</p>

<pre>
$ <strong>go build</strong>
</pre>

<p>se můžeme přesvědčit, že výsledek je stále stejný, jako tomu bylo
v&nbsp;příkladu předchozím:</p>

<pre>
$ <strong>go tool objdump -s main.add add</strong>
&nbsp;
TEXT main.add(SB) /home/tester/go-root/article_53/add05/add_amd64.s
  add_amd64.s:2         0x44ebb0                488b442408              MOVQ 0x8(SP), AX
  add_amd64.s:3         0x44ebb5                4803442410              ADDQ 0x10(SP), AX
  add_amd64.s:4         0x44ebba                4889442418              MOVQ AX, 0x18(SP)
  add_amd64.s:5         0x44ebbf                c3                      RET
</pre>

<p>Pokud si budete chtít vyzkoušet samotný assembler (tedy překladač
z&nbsp;jazyka assembly language do objektového kódu), použijte následující
příkaz:</p>

<pre>
$ <strong>go tool asm -debug add_amd64.s </strong>
</pre>

<p>Přepínač <strong>-debug</strong> zajistí, že assembler bude opisovat
zpracovávaný kód:</p>

<pre>
1 00001 (add_amd64.s:1) TEXT    "".add(SB), $0
2 00002 (add_amd64.s:2) MOVQ    x+8(SP), AX
3 00003 (add_amd64.s:3) ADDQ    y+16(SP), AX
4 00004 (add_amd64.s:4) MOVQ    AX, 24(SP)
5 00005 (add_amd64.s:5) RET
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Použití pseudoregistru <strong>FP</strong></h2>

<p>V&nbsp;assembleru programovacího jazyka Go je možné pro adresování parametrů
funkcí, návratových hodnot atd. použít i pseudoregistr <strong>FP</strong>.
Nejedná se ovšem o registr související s&nbsp;matematickým koprocesorem
(<i>Floating Point Unit</i>), ale o registr, jehož zkratka <strong>FP</strong>
odpovídá sousloví &bdquo;Frame Pointer&ldquo;. Tento pseudoregistr tedy
umožňuje mj.&nbsp;použít offsety, u nichž nemusíme brát v&nbsp;úvahu fakt, že
na zásobníkovém rámci je uložena i návratová adresa. První parametr bude mít
vždy offset 0 (oproti FP, nikoli SP), druhý offset odpovídající velikosti
prvního parametru atd. atd. Zápis se tedy &ndash; minimálně z&nbsp;hlediska
programátora &ndash; nepatrně zjednoduší a bude vypadat následovně:</p>

<pre>
TEXT ·add(SB),$0
    MOVQ    <strong>x+0(FP)</strong>, AX
    ADDQ    <strong>y+8(FP)</strong>, AX
    MOVQ    AX, 0x18(SP)
    RET
</pre>

<p>Malý test, zda je výsledkem překladu assemblerem stále shodný strojový
kód:</p>

<pre>
$ <strong>go build</strong>
&nbsp;
$ <strong>go tool objdump -s main.add add</strong>
&nbsp;
TEXT main.add(SB) /home/tester/go-root/article_53/add06/add_amd64.s
  add_amd64.s:2         0x44ebb0                488b442408              MOVQ 0x8(SP), AX
  add_amd64.s:3         0x44ebb5                4803442410              ADDQ 0x10(SP), AX
  add_amd64.s:4         0x44ebba                4889442418              MOVQ AX, 0x18(SP)
  add_amd64.s:5         0x44ebbf                c3                      RET
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Pojmenování výstupní hodnoty funkce s&nbsp;jejím využitím v&nbsp;assembleru</h2>

<p>V&nbsp;předchozích kapitolách jsme si ukázali, že k&nbsp;parametrům funkce
je možné v&nbsp;assembleru přistupovat přes jejich jména, což zpřehlední zápis
kódu. Jak je tomu ovšem v&nbsp;případě výsledné hodnoty či výsledných hodnot
funkce? Pokud tuto hodnotu nebo hodnoty pojmenujeme, což programovací jazyk Go
podporuje, bude možné i k&nbsp;takovým hodnotám přistupovat přímo
z&nbsp;assembleru:</p>

<pre>
package <strong>main</strong>
&nbsp;
func <strong>add</strong>(x int64, y int64) (result int64)
&nbsp;
func <strong>main</strong>() {
        println(add(1, 2))
}
</pre>

<p>Samotnou implementaci funkce <strong>add</strong> v&nbsp;assembleru bude
nyní možné zapsat následovně:</p>

<pre>
TEXT ·add(SB),$0
    MOVQ    x+0(FP), AX
    ADDQ    y+8(FP), AX
    MOVQ    AX, <strong>result+16(FP)</strong>
    RET
</pre>

<p>Po vytvoření binárního souboru, opět nám již známým příkazem:</p>

<pre>
$ <strong>go build</strong>
</pre>

<p>uvidíme, že výsledek překladu bude stále shodný s&nbsp;předchozími třemi
příklady, i když assemblerovský zdrojový kód je nyní mnohem čitelnější:</p>

<pre>
$ <strong>go tool objdump -s main.add add</strong>
&nbsp;
TEXT main.add(SB) /home/tester/go-root/article_53/add07/add_amd64.s
  add_amd64.s:2         0x44ebb0                488b442408              MOVQ 0x8(SP), AX
  add_amd64.s:3         0x44ebb5                4803442410              ADDQ 0x10(SP), AX
  add_amd64.s:4         0x44ebba                4889442418              MOVQ AX, 0x18(SP)
  add_amd64.s:5         0x44ebbf                c3                      RET
</pre>

<p><div class="rs-tip-major">Poznámka: ve výpisu objektového kódu se opět
vyskytuje pouze (skutečný) registr SP, nikoli pseudoregistr FP.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Kód v&nbsp;assembleru určený pro další procesorové architektury</h2>

<p>Pokud se pokusíme náš příklad přeložit pro jiné architektury, dojde
pochopitelně k&nbsp;chybě, protože příslušná implementace funkce
neexistuje:</p>

<pre>
$ <strong>GOOS=linux GOARCH=386 go build</strong>
&nbsp;
# add
./add.go:3:6: missing function body
</pre>

<p>Popř.:</p>

<pre>
$ <strong>GOOS=linux GOARCH=arm go build</strong>
&nbsp;
# add
./add.go:3:6: missing function body
</pre>

<p>Řešení je nasnadě &ndash; je nutné vytvořit pro každou podporovanou
architekturu zvláštní soubor s&nbsp;příslušným kódem v&nbsp;assembleru:</p>

<ol>
<li>add_amd64.s pro x86-64</li>
<li>add_arm.s pro 32bitové ARMy</li>
<li>atd.</li>
</ol>

<p>Vytvoříme si tedy další soubor, tentokrát pro 32bitové ARMy:</p>

<pre>
TEXT ·add(SB),$0
    MOVW 0x8(R13), R0
    MOVW 0x4(R13), R1
    ADD  R0, R1, R0
    MOVW R0, 0xc(R13)
    ADD  $0, R14, R15
</pre>

<p><div class="rs-tip-major">Poznámka: poslední instrukce odpovídá návratu
z&nbsp;podprogramu.</div></p>

<p>Překlad (crosspřeklad) pro 32bitovou architekturu ARM:</p>

<pre>
$ <strong>GOOS=linux GOARCH=arm go build</strong>
&nbsp;
$ <strong>file add </strong>
add: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV), statically linked, not stripped
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Seznam dnes použitých instrukcí</h2>

<p>V&nbsp;tabulce umístěné pod tímto odstavcem jsou vypsány všechny instrukce
64bitových procesorů s&nbsp;architekturou x86-64 (AMD64), které jsme explicitně
použili v&nbsp;dnešních demonstračních příkladech:</p>

<table>
<tr><th>#</th><th>Mnemotechnická zkratka</th><th>Stručný popis instrukce</th></tr>
<tr><td>1</td><td>MOVQ</td><td>přesun obsahu prvního 64bitového operandu do operandu druhého (naopak, než jste možná zvyklí)</td></tr>
<tr><td>2</td><td>ADDQ</td><td>přičtení prvního 64bitového operandu k&nbsp;obsahu operandu druhého</td></tr>
<tr><td>3</td><td>RET</td><td>návrat z&nbsp;podprogramu, návratový kód je uložen v&nbsp;paměti na adrese adresované obsahem registru <strong>SP</strong> (<strong>ESP</strong>)</td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah následující části seriálu</h2>

<p>Dnes jsme si vysvětlili pouze velmi malou část celé problematiky související
s&nbsp;použitím programovacího jazyka Go společně s&nbsp;assemblerem. Příště si
ukážeme složitější příklady, včetně několika příkladů praktičtějších,
v&nbsp;nichž se již využijí specifické instrukce, které skutečně povedou ke
zrychlení výsledné aplikace (typicky se jedná o instrukce, které nemají přímou
obdobu ve vysokoúrovňovém kódu napsaném v&nbsp;Go či v&nbsp;dalším
vysokoúrovňovém programovacím jazyku).</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně pět až šest megabajtů), můžete namísto toho použít odkazy na
jednotlivé příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>asm01.go</td><td>prázdná funkce <strong>main</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_53/">https://github.com/tisnik/go-root/blob/master/article_53/</a></td></tr>
<tr><td> 2</td><td>asm02.go</td><td>volání funkce <strong>println</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_53/">https://github.com/tisnik/go-root/blob/master/article_53/</a></td></tr>
<tr><td> 3</td><td>asm03.go</td><td>funkce <strong>Add</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_53/">https://github.com/tisnik/go-root/blob/master/article_53/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>add04/go.mod</td><td>definice modulu pro projekt v&nbsp;Go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_53/add04/go.mod">https://github.com/tisnik/go-root/blob/master/article_53/add04/go.mod</a></td></tr>
<tr><td> 5</td><td>add04/add.go</td><td>kostra aplikace s&nbsp;hlavičkou funkce <strong>add</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_53/add04/add.go">https://github.com/tisnik/go-root/blob/master/article_53/add04/add.go</a></td></tr>
<tr><td> 6</td><td>add04/add_amd64.s</td><td>implementace funkce <strong>add</strong> v&nbsp;assembleru x86-64</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_53/add04/add_amd64.s">https://github.com/tisnik/go-root/blob/master/article_53/add04/add_amd64.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>add05/go.mod</td><td>definice modulu pro projekt v&nbsp;Go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_53/add05/go.mod">https://github.com/tisnik/go-root/blob/master/article_53/add05/go.mod</a></td></tr>
<tr><td> 8</td><td>add05/add.go</td><td>kostra aplikace s&nbsp;hlavičkou funkce <strong>add</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_53/add05/add.go">https://github.com/tisnik/go-root/blob/master/article_53/add05/add.go</a></td></tr>
<tr><td> 9</td><td>add05/add_amd64.s</td><td>použití pseudoregistru <strong>SP</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_53/add05/add_amd64.s">https://github.com/tisnik/go-root/blob/master/article_53/add05/add_amd64.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>add06/go.mod</td><td>definice modulu pro projekt v&nbsp;Go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_53/add06/go.mod">https://github.com/tisnik/go-root/blob/master/article_53/add06/go.mod</a></td></tr>
<tr><td>11</td><td>add06/add.go</td><td>kostra aplikace s&nbsp;hlavičkou funkce <strong>add</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_53/add06/add.go">https://github.com/tisnik/go-root/blob/master/article_53/add06/add.go</a></td></tr>
<tr><td>12</td><td>add06/add_amd64.s</td><td>použití pseudoregistru <strong>FP</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_53/add06/add_amd64.s">https://github.com/tisnik/go-root/blob/master/article_53/add06/add_amd64.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>add07/go.mod</td><td>definice modulu pro projekt v&nbsp;Go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_53/add07/go.mod">https://github.com/tisnik/go-root/blob/master/article_53/add07/go.mod</a></td></tr>
<tr><td>14</td><td>add07/add.go</td><td>kostra aplikace s&nbsp;hlavičkou funkce <strong>add</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_53/add07/add.go">https://github.com/tisnik/go-root/blob/master/article_53/add07/add.go</a></td></tr>
<tr><td>15</td><td>add07/add_amd64.s</td><td>pojmenování a použití výstupní hodnoty</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_53/add07/add_amd64.s">https://github.com/tisnik/go-root/blob/master/article_53/add07/add_amd64.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>add08/go.mod</td><td>definice modulu pro projekt v&nbsp;Go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_53/add08/go.mod">https://github.com/tisnik/go-root/blob/master/article_53/add08/go.mod</a></td></tr>
<tr><td>17</td><td>add08/add.go</td><td>kostra aplikace s&nbsp;hlavičkou funkce <strong>add</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_53/add08/add.go">https://github.com/tisnik/go-root/blob/master/article_53/add08/add.go</a></td></tr>
<tr><td>18</td><td>add08/add_amd64.s</td><td>implementace funkce <strong>add</strong> v&nbsp;assembleru x86-64</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_53/add08/add_amd64.s">https://github.com/tisnik/go-root/blob/master/article_53/add08/add_amd64.s</a></td></tr>
<tr><td>19</td><td>add08/add_arm.s</td><td>implementace funkce <strong>add</strong> v&nbsp;assembleru ARM (32bit)</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_53/add08/add_arm.s">https://github.com/tisnik/go-root/blob/master/article_53/add08/add_arm.s</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Design of the Go Assembler<br />
<a href="https://talks.golang.org/2016/asm.slide#1">https://talks.golang.org/2016/asm.slide#1</a>
</li>

<li>A Quick Guide to Go's Assembler<br />
<a href="https://golang.org/doc/asm">https://golang.org/doc/asm</a>
</li>

<li>AssemblyPolicy<br />
<a href="https://github.com/golang/go/wiki/AssemblyPolicy">https://github.com/golang/go/wiki/AssemblyPolicy</a>
</li>

<li>Geohash in Golang Assembly<br />
<a href="https://mmcloughlin.com/posts/geohash-assembly">https://mmcloughlin.com/posts/geohash-assembly</a>
</li>

<li>Command objdump<br />
<a href="https://golang.org/cmd/objdump/">https://golang.org/cmd/objdump/</a>
</li>

<li>Assembly<br />
<a href="https://goroutines.com/asm">https://goroutines.com/asm</a>
</li>

<li>Go &amp; Assembly<br />
<a href="http://www.doxsey.net/blog/go-and-assembly">http://www.doxsey.net/blog/go-and-assembly</a>
</li>

<li>A Foray Into Go Assembly Programming<br />
<a href="https://blog.sgmansfield.com/2017/04/a-foray-into-go-assembly-programming/">https://blog.sgmansfield.com/2017/04/a-foray-into-go-assembly-programming/</a>
</li>

<li>Golang Capturing log.Println And fmt.Println Output<br />
<a href="https://medium.com/@hau12a1/golang-capturing-log-println-and-fmt-println-output-770209c791b4">https://medium.com/@hau12a1/golang-capturing-log-println-and-fmt-println-output-770209c791b4</a>
</li>

<li>Stránka projektu plotly<br />
<a href="https://plot.ly/">https://plot.ly/</a>
</li>

<li>Plotly JavaScript Open Source Graphing Library<br />
<a href="https://plot.ly/javascript/">https://plot.ly/javascript/</a>
</li>

<li>Domain coloring<br />
<a href="https://en.wikipedia.org/wiki/Domain_coloring">https://en.wikipedia.org/wiki/Domain_coloring</a>
</li>

<li>Michael Fogleman's projects<br />
<a href="https://www.michaelfogleman.com/projects/tagged/graphics/">https://www.michaelfogleman.com/projects/tagged/graphics/</a>
</li>

<li>Color Graphs of Complex Functions<br />
<a href="https://web.archive.org/web/20120511021419/http://w.american.edu/cas/mathstat/lcrone/ComplexPlot.html">https://web.archive.org/web/20120511021419/http://w.american.edu/cas/mathstat/lcrone/ComplexPlot.html</a>
</li>

<li>A Gallery of Complex Functions<br />
<a href="http://wismuth.com/complex/gallery.html">http://wismuth.com/complex/gallery.html</a>
</li>

<li>package glot<br />
<a href="https://godoc.org/github.com/Arafatk/glot">https://godoc.org/github.com/Arafatk/glot</a>
</li>

<li>Gnuplotting: Output terminals<br />
<a href="http://www.gnuplotting.org/output-terminals/">http://www.gnuplotting.org/output-terminals/</a>
</li>

<li>Introducing Glot the plotting library for Golang<br />
<a href="https://medium.com/@Arafat./introducing-glot-the-plotting-library-for-golang-3133399948a1">https://medium.com/@Arafat./introducing-glot-the-plotting-library-for-golang-3133399948a1</a>
</li>

<li>Introducing Glot the plotting library for Golang<br />
<a href="https://blog.gopheracademy.com/advent-2018/introducing-glot/">https://blog.gopheracademy.com/advent-2018/introducing-glot/</a>
</li>

<li>Glot is a plotting library for Golang built on top of gnuplot<br />
<a href="https://github.com/Arafatk/glot">https://github.com/Arafatk/glot</a>
</li>

<li>Example plots (gonum/plot)<br />
<a href="https://github.com/gonum/plot/wiki/Example-plots">https://github.com/gonum/plot/wiki/Example-plots</a>
</li>

<li>A repository for plotting and visualizing data (gonum/plot)<br />
<a href="https://github.com/gonum/plot">https://github.com/gonum/plot</a>
</li>

<li>golang library to make https://chartjs.org/ plots<br />
<a href="https://github.com/brentp/go-chartjs">https://github.com/brentp/go-chartjs</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>The Gonum Numerical Computing Package<br />
<a href="https://www.gonum.org/post/introtogonum/">https://www.gonum.org/post/introtogonum/</a>
</li>

<li>Gomacro na GitHubu<br />
<a href="https://github.com/cosmos72/gomacro">https://github.com/cosmos72/gomacro</a>
</li>

<li>gophernotes - Use Go in Jupyter notebooks and nteract<br />
<a href="https://github.com/gopherdata/gophernotes">https://github.com/gopherdata/gophernotes</a>
</li>

<li>gonum<br />
<a href="https://github.com/gonum">https://github.com/gonum</a>
</li>

<li>go-gota/gota -  DataFrames and data wrangling in Go (Golang)<br />
<a href="https://porter.io/github.com/go-gota/gota">https://porter.io/github.com/go-gota/gota</a>
</li>

<li>A repository for plotting and visualizing data <br />
<a href="https://github.com/gonum/plot">https://github.com/gonum/plot</a>
</li>

<li>Gonum Numerical Packages<br />
<a href="https://www.gonum.org/">https://www.gonum.org/</a>
</li>

<li>Stránky projektu MinIO<br />
<a href="https://min.io/">https://min.io/</a>
</li>

<li>MinIO Quickstart Guide<br />
<a href="https://docs.min.io/docs/minio-quickstart-guide.html">https://docs.min.io/docs/minio-quickstart-guide.html</a>
</li>

<li>MinIO Go Client API Reference<br />
<a href="https://docs.min.io/docs/golang-client-api-reference">https://docs.min.io/docs/golang-client-api-reference</a>
</li>

<li>MinIO Python Client API Reference<br />
<a href="https://docs.min.io/docs/python-client-api-reference.html">https://docs.min.io/docs/python-client-api-reference.html</a>
</li>

<li>Performance at Scale: MinIO Pushes Past 1.4 terabits per second with 256 NVMe Drives<br />
<a href="https://blog.min.io/performance-at-scale-minio-pushes-past-1-3-terabits-per-second-with-256-nvme-drives/">https://blog.min.io/performance-at-scale-minio-pushes-past-1-3-terabits-per-second-with-256-nvme-drives/</a>
</li>

<li>Benchmarking MinIO vs. AWS S3 for Apache Spark<br />
<a href="https://blog.min.io/benchmarking-apache-spark-vs-aws-s3/">https://blog.min.io/benchmarking-apache-spark-vs-aws-s3/</a>
</li>

<li>MinIO Client Quickstart Guide<br />
<a href="https://docs.min.io/docs/minio-client-quickstart-guide.html">https://docs.min.io/docs/minio-client-quickstart-guide.html</a>
</li>

<li>Analýza kvality zdrojových kódů Minia<br />
<a href="https://goreportcard.com/report/github.com/minio/minio">https://goreportcard.com/report/github.com/minio/minio</a>
</li>

<li>This is MinIO<br />
<a href="https://www.youtube.com/watch?v=vF0lQh0XOCs">https://www.youtube.com/watch?v=vF0lQh0XOCs</a>
</li>

<li>Running MinIO Standalone<br />
<a href="https://www.youtube.com/watch?v=dIQsPCHvHoM">https://www.youtube.com/watch?v=dIQsPCHvHoM</a>
</li>

<li>"Amazon S3 Compatible Storage in Kubernetes" - Rob Girard, Principal Tech Marketing Engineer, Minio<br />
<a href="https://www.youtube.com/watch?v=wlpn8K0jJ4U">https://www.youtube.com/watch?v=wlpn8K0jJ4U</a>
</li>

<li>Ginkgo<br />
<a href="http://onsi.github.io/ginkgo/">http://onsi.github.io/ginkgo/</a>
</li>

<li>Gomega<br />
<a href="https://onsi.github.io/gomega/">https://onsi.github.io/gomega/</a>
</li>

<li>Ginkgo's Preferred Matcher Library na GitHubu<br />
<a href="https://github.com/onsi/gomega/">https://github.com/onsi/gomega/</a>
</li>

<li>Provided Matchers<br />
<a href="http://onsi.github.io/gomega/#provided-matchers">http://onsi.github.io/gomega/#provided-matchers</a>
</li>

<li>Dokumentace k&nbsp;balíčku goexpect<br />
<a href="https://godoc.org/github.com/google/goexpect">https://godoc.org/github.com/google/goexpect</a>
</li>

<li>Balíček goexpect<br />
<a href="https://github.com/google/goexpect">https://github.com/google/goexpect</a>
</li>

<li>Balíček go-expect<br />
<a href="https://github.com/Netflix/go-expect">https://github.com/Netflix/go-expect</a>
</li>

<li>Balíček gexpect<br />
<a href="https://github.com/ThomasRooney/gexpect">https://github.com/ThomasRooney/gexpect</a>
</li>

<li>Expect (originál naprogramovaný v&nbsp;TCL)<br />
<a href="https://core.tcl-lang.org/expect/index">https://core.tcl-lang.org/expect/index</a>
</li>

<li>Expect (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Expect">https://en.wikipedia.org/wiki/Expect</a>
</li>

<li>Pexpect<br />
<a href="https://pexpect.readthedocs.io/en/stable/">https://pexpect.readthedocs.io/en/stable/</a>
</li>

<li>Golang SSH Client: Multiple Commands, Crypto &amp; Goexpect Examples<br />
<a href="http://networkbit.ch/golang-ssh-client/">http://networkbit.ch/golang-ssh-client/</a>
</li>

<li>goblin na GitHubu<br />
<a href="https://github.com/franela/goblin">https://github.com/franela/goblin</a>
</li>

<li>Mocha framework<br />
<a href="https://mochajs.org/">https://mochajs.org/</a>
</li>

<li>frisby na GitHubu<br />
<a href="https://github.com/verdverm/frisby">https://github.com/verdverm/frisby</a>
</li>

<li>package frisby<br />
<a href="https://godoc.org/github.com/verdverm/frisby">https://godoc.org/github.com/verdverm/frisby</a>
</li>

<li>Frisby alternatives and similar packages (generováno)<br />
<a href="https://go.libhunt.com/frisby-alternatives">https://go.libhunt.com/frisby-alternatives</a>
</li>

<li>Cucumber for golang<br />
<a href="https://github.com/DATA-DOG/godog">https://github.com/DATA-DOG/godog</a>
</li>

<li>How to Use Godog for Behavior-driven Development in Go<br />
<a href="https://semaphoreci.com/community/tutorials/how-to-use-godog-for-behavior-driven-development-in-go">https://semaphoreci.com/community/tutorials/how-to-use-godog-for-behavior-driven-development-in-go</a>
</li>

<li>Comparative Analysis Of GoLang Testing Frameworks<br />
<a href="https://www.slideshare.net/DushyantBhalgami/comparative-analysis-of-golang-testing-frameworks">https://www.slideshare.net/DushyantBhalgami/comparative-analysis-of-golang-testing-frameworks</a>
</li>

<li>A Quick Guide to Testing in Golang<br />
<a href="https://caitiem.com/2016/08/18/a-quick-guide-to-testing-in-golang/">https://caitiem.com/2016/08/18/a-quick-guide-to-testing-in-golang/</a>
</li>

<li>Tom's Obvious, Minimal Language.<br />
<a href="https://github.com/toml-lang/toml">https://github.com/toml-lang/toml</a>
</li>

<li>xml.org<br />
<a href="http://www.xml.org/">http://www.xml.org/</a>
</li>

<li>Soubory .properties<br />
<a href="https://en.wikipedia.org/wiki/.properties">https://en.wikipedia.org/wiki/.properties</a>
</li>

<li>Soubory INI<br />
<a href="https://en.wikipedia.org/wiki/INI_file">https://en.wikipedia.org/wiki/INI_file</a>
</li>

<li>JSON to YAML<br />
<a href="https://www.json2yaml.com/">https://www.json2yaml.com/</a>
</li>

<li>Data Format Converter<br />
<a href="https://toolkit.site/format.html">https://toolkit.site/format.html</a>
</li>

<li>Viper na GitHubu<br />
<a href="https://github.com/spf13/viper">https://github.com/spf13/viper</a>
</li>

<li>GoDotEnv na GitHubu<br />
<a href="https://github.com/joho/godotenv">https://github.com/joho/godotenv</a>
</li>

<li>The fantastic ORM library for Golang<br />
<a href="http://gorm.io/">http://gorm.io/</a>
</li>

<li>Dokumentace k&nbsp;balíčku <strong>gorilla/mux</strong><br />
<a href="https://godoc.org/github.com/gorilla/mux">https://godoc.org/github.com/gorilla/mux</a>
</li>

<li>Gorilla web toolkitk<br />
<a href="http://www.gorillatoolkit.org/">http://www.gorillatoolkit.org/</a>
</li>

<li>Metric types<br />
<a href="https://prometheus.io/docs/concepts/metric_types/">https://prometheus.io/docs/concepts/metric_types/</a>
</li>

<li>Histograms with Prometheus: A Tale of Woe<br />
<a href="http://linuxczar.net/blog/2017/06/15/prometheus-histogram-2/">http://linuxczar.net/blog/2017/06/15/prometheus-histogram-2/</a>
</li>

<li>Why are Prometheus histograms cumulative?<br />
<a href="https://www.robustperception.io/why-are-prometheus-histograms-cumulative">https://www.robustperception.io/why-are-prometheus-histograms-cumulative</a>
</li>

<li>Histograms and summaries<br />
<a href="https://prometheus.io/docs/practices/histograms/">https://prometheus.io/docs/practices/histograms/</a>
</li>

<li>Instrumenting Golang server in 5 min<br />
<a href="https://medium.com/@gsisimogang/instrumenting-golang-server-in-5-min-c1c32489add3">https://medium.com/@gsisimogang/instrumenting-golang-server-in-5-min-c1c32489add3</a>
</li>

<li>Semantic Import Versioning in Go<br />
<a href="https://www.aaronzhuo.com/semantic-import-versioning-in-go/">https://www.aaronzhuo.com/semantic-import-versioning-in-go/</a>
</li>

<li>Sémantické verzování<br />
<a href="https://semver.org/">https://semver.org/</a>
</li>

<li>Getting started with Go modules<br />
<a href="https://medium.com/@fonseka.live/getting-started-with-go-modules-b3dac652066d">https://medium.com/@fonseka.live/getting-started-with-go-modules-b3dac652066d</a>
</li>

<li>Create projects independent of $GOPATH using Go Modules<br />
<a href="https://medium.com/mindorks/create-projects-independent-of-gopath-using-go-modules-802260cdfb51o">https://medium.com/mindorks/create-projects-independent-of-gopath-using-go-modules-802260cdfb51o</a>
</li>

<li>Anatomy of Modules in Go<br />
<a href="https://medium.com/rungo/anatomy-of-modules-in-go-c8274d215c16">https://medium.com/rungo/anatomy-of-modules-in-go-c8274d215c16</a>
</li>

<li>Modules<br />
<a href="https://github.com/golang/go/wiki/Modules">https://github.com/golang/go/wiki/Modules</a>
</li>

<li>Go Modules Tutorial<br />
<a href="https://tutorialedge.net/golang/go-modules-tutorial/">https://tutorialedge.net/golang/go-modules-tutorial/</a>
</li>

<li>Module support<br />
<a href="https://golang.org/cmd/go/#hdr-Module_support">https://golang.org/cmd/go/#hdr-Module_support</a>
</li>

<li>Go Lang: Memory Management and Garbage Collection<br />
<a href="https://vikash1976.wordpress.com/2017/03/26/go-lang-memory-management-and-garbage-collection/">https://vikash1976.wordpress.com/2017/03/26/go-lang-memory-management-and-garbage-collection/</a>
</li>

<li>Golang Internals, Part 4: Object Files and Function Metadata<br />
<a href="https://blog.altoros.com/golang-part-4-object-files-and-function-metadata.html">https://blog.altoros.com/golang-part-4-object-files-and-function-metadata.html</a>
</li>

<li>What is REPL?<br />
<a href="https://pythonprogramminglanguage.com/repl/">https://pythonprogramminglanguage.com/repl/</a>
</li>

<li>What is a REPL?<br />
<a href="https://codewith.mu/en/tutorials/1.0/repl">https://codewith.mu/en/tutorials/1.0/repl</a>
</li>

<li>Programming at the REPL: Introduction<br />
<a href="https://clojure.org/guides/repl/introduction">https://clojure.org/guides/repl/introduction</a>
</li>

<li>What is REPL? (Quora)<br />
<a href="https://www.quora.com/What-is-REPL">https://www.quora.com/What-is-REPL</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Read-eval-print loop (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>Vim as a Go (Golang) IDE using LSP and vim-go<br />
<a href="https://octetz.com/posts/vim-as-go-ide">https://octetz.com/posts/vim-as-go-ide</a>
</li>

<li>gopls<br />
<a href="https://github.com/golang/go/wiki/gopls">https://github.com/golang/go/wiki/gopls</a>
</li>

<li>IDE Integration Guide<br />
<a href="https://github.com/stamblerre/gocode/blob/master/docs/IDE_integration.md">https://github.com/stamblerre/gocode/blob/master/docs/IDE_integration.md</a>
</li>

<li>How to instrument Go code with custom expvar metrics<br />
<a href="https://sysdig.com/blog/golang-expvar-custom-metrics/">https://sysdig.com/blog/golang-expvar-custom-metrics/</a>
</li>

<li>Golang expvar metricset (Metricbeat Reference)<br />
<a href="https://www.elastic.co/guide/en/beats/metricbeat/7.x/metricbeat-metricset-golang-expvar.html">https://www.elastic.co/guide/en/beats/metricbeat/7.x/metricbeat-metricset-golang-expvar.html</a>
</li>

<li>Package expvar<br />
<a href="https://golang.org/pkg/expvar/#NewInt">https://golang.org/pkg/expvar/#NewInt</a>
</li>

<li>Java Platform Debugger Architecture: Overview<br />
<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jpda/jpda.html">https://docs.oracle.com/en/java/javase/11/docs/specs/jpda/jpda.html</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="https://www.oracle.com/technetwork/articles/javase/index-140680.html">https://www.oracle.com/technetwork/articles/javase/index-140680.html</a>
</li>

<li>JVM Tool Interface Version 11.0<br />
<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html">https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>Go &amp; cgo: integrating existing C code with Go<br />
<a href="http://akrennmair.github.io/golang-cgo-slides/#1">http://akrennmair.github.io/golang-cgo-slides/#1</a>
</li>

<li>Using cgo to call C code from within Go code<br />
<a href="https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/">https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/</a>
</li>

<li>Package trace<br />
<a href="https://golang.org/pkg/runtime/trace/">https://golang.org/pkg/runtime/trace/</a>
</li>

<li>Introducing HTTP Tracing<br />
<a href="https://blog.golang.org/http-tracing">https://blog.golang.org/http-tracing</a>
</li>

<li>Command trace<br />
<a href="https://golang.org/cmd/trace/">https://golang.org/cmd/trace/</a>
</li>

<li>A StreamLike, Immutable, Lazy Loading and smart Golang Library to deal with slices<br />
<a href="https://github.com/wesovilabs/koazee">https://github.com/wesovilabs/koazee</a>
</li>

<li>Funkce vyššího řádu v knihovně Underscore<br />
<a href="https://www.root.cz/clanky/funkce-vyssiho-radu-v-knihovne-underscore/">https://www.root.cz/clanky/funkce-vyssiho-radu-v-knihovne-underscore/</a>
</li>

<li>Delve: a debugger for the Go programming language.<br />
<a href="https://github.com/go-delve/delve">https://github.com/go-delve/delve</a>
</li>

<li>Příkazy debuggeru Delve<br />
<a href="https://github.com/go-delve/delve/tree/master/Documentation/cli">https://github.com/go-delve/delve/tree/master/Documentation/cli</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (2. část)<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v&nbsp;editorech Emacs a Vim<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Debugging Go Code with GDB<br />
<a href="https://golang.org/doc/gdb">https://golang.org/doc/gdb</a>
</li>

<li>Debugging Go (golang) programs with gdb <br />
<a href="https://thornydev.blogspot.com/2014/01/debugging-go-golang-programs-with-gdb.html">https://thornydev.blogspot.com/2014/01/debugging-go-golang-programs-with-gdb.html</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>GDB - Supported Languages<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>13 Linux Debuggers for C++ Reviewed<br />
<a href="http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817">http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817</a>
</li>

<li>Go is on a Trajectory to Become the Next Enterprise Programming Language<br />
<a href="https://hackernoon.com/go-is-on-a-trajectory-to-become-the-next-enterprise-programming-language-3b75d70544e">https://hackernoon.com/go-is-on-a-trajectory-to-become-the-next-enterprise-programming-language-3b75d70544e</a>
</li>

<li>Go Proverbs: Simple, Poetic, Pithy<br />
<a href="https://go-proverbs.github.io/">https://go-proverbs.github.io/</a>
</li>

<li>Handling Sparse Files on Linux<br />
<a href="https://www.systutorials.com/136652/handling-sparse-files-on-linux/">https://www.systutorials.com/136652/handling-sparse-files-on-linux/</a>
</li>

<li>Gzip (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Gzip">https://en.wikipedia.org/wiki/Gzip</a>
</li>

<li>Deflate<br />
<a href="https://en.wikipedia.org/wiki/DEFLATE">https://en.wikipedia.org/wiki/DEFLATE</a>
</li>

<li>10 tools written in Go that every developer needs to know<br />
<a href="https://gustavohenrique.net/en/2019/01/10-tools-written-in-go-that-every-dev-needs-to-know/">https://gustavohenrique.net/en/2019/01/10-tools-written-in-go-that-every-dev-needs-to-know/</a>
</li>

<li>Hexadecimální prohlížeče a editory s textovým uživatelským rozhraním<br />
<a href="https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/">https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/</a>
</li>

<li>Hex dump<br />
<a href="https://en.wikipedia.org/wiki/Hex_dump">https://en.wikipedia.org/wiki/Hex_dump</a>
</li>

<li>Rozhraní io.ByteReader<br />
<a href="https://golang.org/pkg/io/#ByteReader">https://golang.org/pkg/io/#ByteReader</a>
</li>

<li>Rozhraní io.RuneReader<br />
<a href="https://golang.org/pkg/io/#RuneReader">https://golang.org/pkg/io/#RuneReader</a>
</li>

<li>Rozhraní io.ByteScanner<br />
<a href="https://golang.org/pkg/io/#ByteScanner">https://golang.org/pkg/io/#ByteScanner</a>
</li>

<li>Rozhraní io.RuneScanner<br />
<a href="https://golang.org/pkg/io/#RuneScanner">https://golang.org/pkg/io/#RuneScanner</a>
</li>

<li>Rozhraní io.Closer<br />
<a href="https://golang.org/pkg/io/#Closer">https://golang.org/pkg/io/#Closer</a>
</li>

<li>Rozhraní io.Reader<br />
<a href="https://golang.org/pkg/io/#Reader">https://golang.org/pkg/io/#Reader</a>
</li>

<li>Rozhraní io.Writer<br />
<a href="https://golang.org/pkg/io/#Writer">https://golang.org/pkg/io/#Writer</a>
</li>

<li>Typ Strings.Reader<br />
<a href="https://golang.org/pkg/strings/#Reader">https://golang.org/pkg/strings/#Reader</a>
</li>

<li>VACUUM (SQL)<br />
<a href="https://www.sqlite.org/lang_vacuum.html">https://www.sqlite.org/lang_vacuum.html</a>
</li>

<li>VACUUM (Postgres)<br />
<a href="https://www.postgresql.org/docs/8.4/sql-vacuum.html">https://www.postgresql.org/docs/8.4/sql-vacuum.html</a>
</li>

<li>go-cron<br />
<a href="https://github.com/rk/go-cron">https://github.com/rk/go-cron</a>
</li>

<li>gocron<br />
<a href="https://github.com/jasonlvhit/gocron">https://github.com/jasonlvhit/gocron</a>
</li>

<li>clockwork<br />
<a href="https://github.com/whiteShtef/clockwork">https://github.com/whiteShtef/clockwork</a>
</li>

<li>clockwerk<br />
<a href="https://github.com/onatm/clockwerk">https://github.com/onatm/clockwerk</a>
</li>

<li>JobRunner<br />
<a href="https://github.com/bamzi/jobrunner">https://github.com/bamzi/jobrunner</a>
</li>

<li>Rethinking Cron<br />
<a href="https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/">https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/</a>
</li>

<li>In the Beginning was the Command Line<br />
<a href="https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html">https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html</a>
</li>

<li>repl.it (REPL pro různé jazyky)<br />
<a href="https://repl.it/languages">https://repl.it/languages</a>
</li>

<li>GOCUI - Go Console User Interface (celé uživatelské prostředí, nejenom input box)<br />
<a href="https://github.com/jroimartin/gocui">https://github.com/jroimartin/gocui</a>
</li>

<li>Read–eval–print loop<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>go-prompt<br />
<a href="https://github.com/c-bata/go-prompt">https://github.com/c-bata/go-prompt</a>
</li>

<li>readline<br />
<a href="https://github.com/chzyer/readline">https://github.com/chzyer/readline</a>
</li>

<li>A pure golang implementation for GNU-Readline kind library<br />
<a href="https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/">https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/</a>
</li>

<li>go-readline<br />
<a href="https://github.com/fiorix/go-readline">https://github.com/fiorix/go-readline</a>
</li>

<li>4 Python libraries for building great command-line user interfaces<br />
<a href="https://opensource.com/article/17/5/4-practical-python-libraries">https://opensource.com/article/17/5/4-practical-python-libraries</a>
</li>

<li>prompt_toolkit 2.0.3 na PyPi<br />
<a href="https://pypi.org/project/prompt_toolkit/">https://pypi.org/project/prompt_toolkit/</a>
</li>

<li>python-prompt-toolkit na GitHubu<br />
<a href="https://github.com/jonathanslenders/python-prompt-toolkit">https://github.com/jonathanslenders/python-prompt-toolkit</a>
</li>

<li>The GNU Readline Library<br />
<a href="https://tiswww.case.edu/php/chet/readline/rltop.html">https://tiswww.case.edu/php/chet/readline/rltop.html</a>
</li>

<li>GNU Readline (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Readline">https://en.wikipedia.org/wiki/GNU_Readline</a>
</li>

<li>readline — GNU readline interface (Python 3.x)<br />
<a href="https://docs.python.org/3/library/readline.html">https://docs.python.org/3/library/readline.html</a>
</li>

<li>readline — GNU readline interface (Python 2.x)<br />
<a href="https://docs.python.org/2/library/readline.html">https://docs.python.org/2/library/readline.html</a>
</li>

<li>GNU Readline Library - command line editing<br />
<a href="https://tiswww.cwru.edu/php/chet/readline/readline.html">https://tiswww.cwru.edu/php/chet/readline/readline.html</a>
</li>

<li>gnureadline 6.3.8 na PyPi<br />
<a href="https://pypi.org/project/gnureadline/">https://pypi.org/project/gnureadline/</a>
</li>

<li>Editline Library (libedit)<br />
<a href="http://thrysoee.dk/editline/">http://thrysoee.dk/editline/</a>
</li>

<li>Comparing Python Command-Line Parsing Libraries – Argparse, Docopt, and Click<br />
<a href="https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/">https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/</a>
</li>

<li>libedit or editline<br />
<a href="http://www.cs.utah.edu/~bigler/code/libedit.html">http://www.cs.utah.edu/~bigler/code/libedit.html</a>
</li>

<li>WinEditLine<br />
<a href="http://mingweditline.sourceforge.net/">http://mingweditline.sourceforge.net/</a>
</li>

<li>rlcompleter — Completion function for GNU readline<br />
<a href="https://docs.python.org/3/library/rlcompleter.html">https://docs.python.org/3/library/rlcompleter.html</a>
</li>

<li>rlwrap na GitHubu<br />
<a href="https://github.com/hanslub42/rlwrap">https://github.com/hanslub42/rlwrap</a>
</li>

<li>rlwrap(1) - Linux man page<br />
<a href="https://linux.die.net/man/1/rlwrap">https://linux.die.net/man/1/rlwrap</a>
</li>

<li>readline(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/readline">https://linux.die.net/man/3/readline</a>
</li>

<li>history(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/history">https://linux.die.net/man/3/history</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>oglematchers</i><br />
<a href="https://godoc.org/github.com/jacobsa/oglematchers">https://godoc.org/github.com/jacobsa/oglematchers</a>
</li>

<li>Balíček <i>oglematchers</i><br />
<a href="https://github.com/jacobsa/oglematchers">https://github.com/jacobsa/oglematchers</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>ogletest</i><br />
<a href="https://godoc.org/github.com/jacobsa/ogletest">https://godoc.org/github.com/jacobsa/ogletest</a>
</li>

<li>Balíček <i>ogletest</i><br />
<a href="https://github.com/jacobsa/ogletest">https://github.com/jacobsa/ogletest</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>assert</i><br />
<a href="https://godoc.org/github.com/stretchr/testify/assert">https://godoc.org/github.com/stretchr/testify/assert</a>
</li>

<li>Testify - Thou Shalt Write Tests<br />
<a href="https://github.com/stretchr/testify/">https://github.com/stretchr/testify/</a>
</li>

<li>package testing<br />
<a href="https://golang.org/pkg/testing/">https://golang.org/pkg/testing/</a>
</li>

<li>Golang basics - writing unit tests<br />
<a href="https://blog.alexellis.io/golang-writing-unit-tests/">https://blog.alexellis.io/golang-writing-unit-tests/</a>
</li>

<li>An Introduction to Programming in Go / Testing<br />
<a href="https://www.golang-book.com/books/intro/12">https://www.golang-book.com/books/intro/12</a>
</li>

<li>An Introduction to Testing in Go<br />
<a href="https://tutorialedge.net/golang/intro-testing-in-go/">https://tutorialedge.net/golang/intro-testing-in-go/</a>
</li>

<li>Advanced Go Testing Tutorial<br />
<a href="https://tutorialedge.net/golang/advanced-go-testing-tutorial/">https://tutorialedge.net/golang/advanced-go-testing-tutorial/</a>
</li>

<li>GoConvey<br />
<a href="http://goconvey.co/">http://goconvey.co/</a>
</li>

<li>Testing Techniques<br />
<a href="https://talks.golang.org/2014/testing.slide">https://talks.golang.org/2014/testing.slide</a>
</li>

<li>5 simple tips and tricks for writing unit tests in #golang<br />
<a href="https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742">https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742</a>
</li>

<li>Afinní transformace<br />
<a href="https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic">https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic</a>
</li>

<li>package gg<br />
<a href="https://godoc.org/github.com/fogleman/gg">https://godoc.org/github.com/fogleman/gg</a>
</li>

<li>Generate an animated GIF with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/">http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/</a>
</li>

<li>Generate an image programmatically with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/">http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/</a>
</li>

<li>The Go image package<br />
<a href="https://blog.golang.org/go-image-package">https://blog.golang.org/go-image-package</a>
</li>

<li>Balíček draw2D: 2D rendering for different output (raster, pdf, svg)<br />
<a href="https://github.com/llgcode/draw2d">https://github.com/llgcode/draw2d</a>
</li>

<li>Draw a rectangle in Golang?<br />
<a href="https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang">https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang</a>
</li>

<li>YAML<br />
<a href="https://yaml.org/">https://yaml.org/</a>
</li>

<li>edn<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Smile<br />
<a href="https://github.com/FasterXML/smile-format-specification">https://github.com/FasterXML/smile-format-specification</a>
</li>

<li>Protocol-Buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>Marshalling (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
</li>

<li>Unmarshalling<br />
<a href="https://en.wikipedia.org/wiki/Unmarshalling">https://en.wikipedia.org/wiki/Unmarshalling</a>
</li>

<li>Introducing JSON<br />
<a href="http://json.org/">http://json.org/</a>
</li>

<li>Package json<br />
<a href="https://golang.org/pkg/encoding/json/">https://golang.org/pkg/encoding/json/</a>
</li>

<li>The Go Blog: JSON and Go<br />
<a href="https://blog.golang.org/json-and-go">https://blog.golang.org/json-and-go</a>
</li>

<li>Go by Example: JSON<br />
<a href="https://gobyexample.com/json">https://gobyexample.com/json</a>
</li>

<li>Writing Web Applications<br />
<a href="https://golang.org/doc/articles/wiki/">https://golang.org/doc/articles/wiki/</a>
</li>

<li>Golang Web Apps<br />
<a href="https://www.reinbach.com/blog/golang-webapps-1/">https://www.reinbach.com/blog/golang-webapps-1/</a>
</li>

<li>Build web application with Golang<br />
<a href="https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details">https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details</a>
</li>

<li>Golang Templates - Golang Web Pages<br />
<a href="https://www.youtube.com/watch?v=TkNIETmF-RU">https://www.youtube.com/watch?v=TkNIETmF-RU</a>
</li>

<li>Simple Golang HTTPS/TLS Examples<br />
<a href="https://github.com/denji/golang-tls">https://github.com/denji/golang-tls</a>
</li>

<li>Playing with images in HTTP response in golang<br />
<a href="https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang">https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang</a>
</li>

<li>MIME Types List<br />
<a href="https://www.freeformatter.com/mime-types-list.html">https://www.freeformatter.com/mime-types-list.html</a>
</li>

<li>Go Mutex Tutorial<br />
<a href="https://tutorialedge.net/golang/go-mutex-tutorial/">https://tutorialedge.net/golang/go-mutex-tutorial/</a>
</li>

<li>Creating A Simple Web Server With Golang<br />
<a href="https://tutorialedge.net/golang/creating-simple-web-server-with-golang/">https://tutorialedge.net/golang/creating-simple-web-server-with-golang/</a>
</li>

<li>Building a Web Server in Go<br />
<a href="https://thenewstack.io/building-a-web-server-in-go/">https://thenewstack.io/building-a-web-server-in-go/</a>
</li>

<li>How big is the pipe buffer?<br />
<a href="https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer">https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer</a>
</li>

<li>How to turn off buffering of stdout in C<br />
<a href="https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c">https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c</a>
</li>

<li>setbuf(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/setbuf">https://linux.die.net/man/3/setbuf</a>
</li>

<li>setvbuf(3) - Linux man page (stejný obsah jako předchozí stránka)<br />
<a href="https://linux.die.net/man/3/setvbuf">https://linux.die.net/man/3/setvbuf</a>
</li>

<li>Select waits on a group of channels<br />
<a href="https://yourbasic.org/golang/select-explained/">https://yourbasic.org/golang/select-explained/</a>
</li>

<li>Rob Pike: Simplicity is Complicated (video)<br />
<a href="http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893">http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893</a>
</li>

<li>Algorithms to Go<br />
<a href="https://yourbasic.org/">https://yourbasic.org/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů: vlastní filtry a lexery<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/</a>
</li>

<li>Go Defer Simplified with Practical Visuals<br />
<a href="https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff">https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff</a>
</li>

<li>5 More Gotchas of Defer in Go — Part II<br />
<a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa">https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa</a>
</li>

<li>The Go Blog: Defer, Panic, and Recover<br />
<a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a>
</li>

<li>The defer keyword in Swift 2: try/finally done right<br />
<a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer">https://www.hackingwithswift.com/new-syntax-swift-2-defer</a>
</li>

<li>Swift Defer Statement<br />
<a href="https://andybargh.com/swift-defer-statement/">https://andybargh.com/swift-defer-statement/</a>
</li>

<li>Modulo operation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Modulo_operation">https://en.wikipedia.org/wiki/Modulo_operation</a>
</li>

<li>Node.js vs Golang: Battle of the Next-Gen Languages<br />
<a href="https://www.hostingadvice.com/blog/nodejs-vs-golang/">https://www.hostingadvice.com/blog/nodejs-vs-golang/</a>
</li>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go<br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>JavaScript vs. Golang for IoT: Is Gopher Winning?<br />
<a href="https://www.iotforall.com/javascript-vs-golang-iot/">https://www.iotforall.com/javascript-vs-golang-iot/</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

<li>Printf Format Strings<br />
<a href="https://www.cprogramming.com/tutorial/printf-format-strings.html">https://www.cprogramming.com/tutorial/printf-format-strings.html</a>
</li>

<li>Java: String.format<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-</a>
</li>

<li>Java: format string syntax<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a>
</li>

<li>Selectors<br />
<a href="https://golang.org/ref/spec#Selectors">https://golang.org/ref/spec#Selectors</a>
</li>

<li>Calling Go code from Python code<br />
<a href="http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/">http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/</a>
</li>

<li>Go Data Structures: Interfaces <br />
<a href="https://research.swtch.com/interfaces">https://research.swtch.com/interfaces</a>
</li>

<li>How to use interfaces in Go<br />
<a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go</a>
</li>

<li>Interfaces in Go (part I)<br />
<a href="https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c">https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c</a>
</li>

<li>Part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>What about Trait support in Golang?<br />
<a href="https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/">https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/</a>
</li>

<li>Don't Get Bitten by Pointer vs Non-Pointer Method Receivers in Golang<br />
<a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/">https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/</a>
</li>

<li>Control Flow<br />
<a href="https://en.wikipedia.org/wiki/Control_flow">https://en.wikipedia.org/wiki/Control_flow</a>
</li>

<li>Structured programming<br />
<a href="https://en.wikipedia.org/wiki/Structured_programming">https://en.wikipedia.org/wiki/Structured_programming</a>
</li>

<li>Control Structures<br />
<a href="https://www.golang-book.com/books/intro/5">https://www.golang-book.com/books/intro/5</a>
</li>

<li>Control structures - Go if else statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html">http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html</a>
</li>

<li>Control structures - Go switch case statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html</a>
</li>

<li>Control structures - Go for loop, break, continue, range<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html</a>
</li>

<li>Goroutine IDs<br />
<a href="https://blog.sgmansfield.com/2015/12/goroutine-ids/">https://blog.sgmansfield.com/2015/12/goroutine-ids/</a>
</li>

<li>Different ways to pass channels as arguments in function in go (golang)<br />
<a href="https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang">https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang</a>
</li>

<li>justforfunc #22: using the Go execution tracer<br />
<a href="https://www.youtube.com/watch?v=ySy3sR1LFCQ">https://www.youtube.com/watch?v=ySy3sR1LFCQ</a>
</li>

<li>Single Function Exit Point<br />
<a href="http://wiki.c2.com/?SingleFunctionExitPoint">http://wiki.c2.com/?SingleFunctionExitPoint</a>
</li>

<li>Entry point<br />
<a href="https://en.wikipedia.org/wiki/Entry_point">https://en.wikipedia.org/wiki/Entry_point</a>
</li>

<li>Why does Go have a GOTO statement?!<br />
<a href="https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/">https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/</a>
</li>

<li>Effective Go<br />
<a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a>
</li>

<li>GoClipse: an Eclipse IDE for the Go programming language<br />
<a href="http://goclipse.github.io/">http://goclipse.github.io/</a>
</li>

<li>GoClipse Installation<br />
<a href="https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation">https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation</a>
</li>

<li>The zero value of a slice is not nil<br />
<a href="https://stackoverflow.com/questions/30806931/the-zero-value-of-a-slice-is-not-nil">https://stackoverflow.com/questions/30806931/the-zero-value-of-a-slice-is-not-nil</a>
</li>

<li>Go-tcha: When nil != nil<br />
<a href="https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic">https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic</a>
</li>

<li>Nils in Go<br />
<a href="https://www.doxsey.net/blog/nils-in-go">https://www.doxsey.net/blog/nils-in-go</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

