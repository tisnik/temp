<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Komunikace přes Unixové sokety v programovacím jazyce Go</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Komunikace přes Unixové sokety v programovacím jazyce Go</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Komunikace přes Unixové sokety v&nbsp;programovacím jazyce Go</a></p>
<p><a href="#k02">*** 2. Základní nástroje, které využijeme: <strong>netstat</strong>, <strong>nc</strong> a <strong>lsof</strong></a></p>
<p><a href="#k03">3. Komunikace přes TCP sokety (<i>stream</i>)</a></p>
<p><a href="#k04">4. Komunikace přes UDP sokety (<i>datagram</i>)</a></p>
<p><a href="#k05">5. &bdquo;Jmenné prostory&ldquo; TCP a UDP</a></p>
<p><a href="#k06">6. Použití Unixových soketů (<i>stream</i> i <i>datagram</i>)</a></p>
<p><a href="#k07">7. Realizace jednoduchého klienta komunikujícího přes TCP sokety v&nbsp;jazyku Go</a></p>
<p><a href="#k08">8. Základní kostra serveru komunikujícího přes TCP sokety v&nbsp;jazyku Go</a></p>
<p><a href="#k09">*** 9. Vylepšení klienta i serveru &ndash; uzavírání prostředků a reakce na případné chyby</a></p>
<p><a href="#k10">*** 10. Simulace zpomalené reakce serveru</a></p>
<p><a href="#k11">*** 11. Server akceptující větší množství klientů realizovaný pomocí gorutin</a></p>
<p><a href="#k12">*** 12. Klient komunikující přes Unix sokety naprogramovaný v&nbsp;Go</a></p>
<p><a href="#k13">*** 13. Server komunikující přes Unix sokety naprogramovaný v&nbsp;Go</a></p>
<p><a href="#k14">*** 14. Praktická část článku</a></p>
<p><a href="#k15">*** 15. Komunikace s&nbsp;HAProxy přes Unix sokety</a></p>
<p><a href="#k16">*** 16. Konfigurace HAProxy</a></p>
<p><a href="#k17">*** 17. Realizace programu, který řídí HAProxy</a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Komunikace přes Unixové sokety v&nbsp;programovacím jazyce Go</h2>

<p></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Základní nástroje, které využijeme: <strong>netstat</strong>, <strong>nc</strong> a <strong>lsof</strong></h2>

<p></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Komunikace přes TCP sokety (<i>stream</i>)</h2>

<p>Síťové aplikace se vytváří na různých úrovních abstrakce &ndash; buď se
pouze otevřou připojení (například s&nbsp;využitím dále využitých Unixových
soketů) a následný komunikační protokol je naprogramován přímo vývojářem, nebo
se naopak využije nějaký již existující protokol na vyšší vrstvě (pravděpodobně
nejznámějším příkladem ze současnosti je protokol HTTP atd.). Nejprve si
ukážeme komunikaci mezi jednoduchým klientem a serverem na nižší úrovni, kdy
náš komunikační protokol (na aplikační úrovni) bude spočívat v&nbsp;přenosu
jediného bajtu přes TCP popř.&nbsp;přes UDP. Později namísto TCP/UDP použijeme
Unixové sokety.</p>

<p><div class="rs-tip-major">Poznámka: na nižších vrstvách (pokud půjdeme stále
níže, tak konkrétně na vrstvě TCP, IP a Ethernetu) bude samozřejmě komunikace
složitější, od toho ovšem budeme do jisté míry odstíněni standardními
knihovnami (balíčky) programovacího jazyka Go.</div></p>

<p>Nejprve na prvním terminálu spustíme nástroj <strong>nc</strong>, který bude
nakonfigurován jako <i>server</i> přijímající (naslouchající) na portu 1234.
Aby nástroj <strong>nc</strong> naslouchal požadavkům, musíme použít přepínač
<strong>-l</strong> neboli &bdquo;listen&ldquo;:</p>

<pre>
$ <strong>nc -l -v localhost 1234</strong>
&nbsp;
Listening on localhost 1234
</pre>

<p>Následně ve druhém terminálu navážeme spojení se serverem naslouchajícím na
portu 1234:</p>

<pre>
$ <strong>nc -v localhost 1234</strong>
&nbsp;
Connection to localhost 1234 port [tcp/*] succeeded!
</pre>

<p>A na prvním terminálu se zobrazí informace o navázání spojení a navíc o
portu otevřeném klientem:</p>

<pre>
Connection received on localhost 35636
</pre>

<p>Pokud nyní budete na tento terminál zapisovat nějaké zprávy, bude je server
přijímat a opisovat je na svůj (první) terminál:</p>

<pre>
aaa
bbb
cc
ddd
</pre>

<p>Na třetím terminálu si pak můžeme zobrazit podrobnější informace o
komunikačním kanále mezi serverem a klientem:</p>

<pre>
$ <strong>netstat -tunp | grep :1234</strong>
&nbsp;
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
tcp        0      0 127.0.0.1:1234          127.0.0.1:35636         ESTABLISHED 231176/nc
tcp        0      0 127.0.0.1:35636         127.0.0.1:1234          ESTABLISHED 232495/nc
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se zobrazí oba porty,
po kterých komunikace probíhá. Pro první proces (což je v&nbsp;tomto případě
server) se porty vypíšou v&nbsp;opačném pořadí, než je tomu u klienta, protože
je použito pořadí místní_port:vzdálený_port.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Komunikace přes UDP sokety (<i>datagram</i>)</h2>

<p>Nyní si vyzkoušíme podobnou komunikaci, ovšem nikoli zajištěnou
s&nbsp;využitím TCP (stream), ale použijeme namísto toho protokol UDP
(datagram). Nástroj <strong>nc</strong> komunikaci přes UDP taktéž podporuje,
ovšem musíme použít přepínač <strong>-u</strong>:</p>

<pre>
$ <strong>nc -l -u -v localhost 1234</strong>
&nbsp;
Bound on localhost 1234
</pre>

<p><div class="rs-tip-major">Poznámka: samotné hlášení je odlišné &ndash;
používá se zde slovo &bdquo;bound&ldquo; a nikoli &bdquo;listening&ldquo;, což
souvisí s&nbsp;céčkovým API k&nbsp;soketům a odlišnou sémantikou jejich
použití.</div></p>

<p>V&nbsp;dalším terminálu se k&nbsp;serveru připojíme:</p>

<pre>
$ <strong>nc -u -v localhost 1234</strong>
&nbsp;
Connection to localhost 1234 port [udp/*] succeeded!
</pre>

<p>Na terminálu serveru se taktéž vypíše informace o připojení:</p>

<pre>
Connection received on localhost 45470
</pre>

<p>A propojené porty opět získáme a necháme si vypsat nástrojem
<strong>netstat</strong>:</p>

<pre>
$ <strong>netstat -tunp | grep :1234</strong>
&nbsp;
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
udp        0      0 127.0.0.1:45470         127.0.0.1:1234          ESTABLISHED 233385/nc
udp        0      0 127.0.0.1:1234          127.0.0.1:45470         ESTABLISHED 233118/nc
</pre>

<p><div class="rs-tip-major">Poznámka: nyní se v&nbsp;prvním sloupci vypíše
&bdquo;udp&ldquo; a nikoli &bdquo;tcp&ldquo;.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. &bdquo;Jmenné prostory&ldquo; TCP a UDP</h2>

<p>Porty TCP a UDP jsou sice identifikovány celými čísly 0..65535, ovšem jedná
se o odlišné &bdquo;jmenné prostory&ldquo;. Proto nelze navázat spojení se
serverem naslouchajícím na UDP portu 1234 z&nbsp;klienta pokoušejícího se
připojit na TCP port 1234:</p>

<pre>
$ <strong>nc -l -u -v localhost 1234</strong>
&nbsp;
Bound on localhost 1234
&nbsp;
&nbsp;
&nbsp;
$ <strong>nc -v localhost 1234</strong>
&nbsp;
nc: connect to localhost port 1234 (tcp) failed: Connection refused
</pre>

<p>Platí to pochopitelně i naopak:</p>

<pre>
$ <strong>nc -l -v localhost 1234</strong>
&nbsp;
Listening on localhost 1234
&nbsp;
&nbsp;
&nbsp;
$ <strong>nc -u -v localhost 1234</strong>
<i>(proces je ihned ukončen)</i>
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si odlišného chování při
NEnavázání připojení.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Použití Unixových soketů (<i>stream</i> i <i>datagram</i>)</h2>

<p>Namísto protokolu TCP či UDP můžeme pro komunikaci mezi procesy použít
Unixové sokety, které taktéž existují ve variantě <i>stream</i> a
<i>datagram</i> (tj.&nbsp;způsob komunikace do značné míry odpovídá TCP
resp.&nbsp;UDP). Unixové sokety lze využít pro komunikaci mezi procesy běžícími
na jednom počítači a vlastní komunikace probíhá přes strukturu spravovanou
jádrem, která je z&nbsp;uživatelského prostoru viditelná jako speciální typ
souboru. Podívejme se nyní na způsob spuštění serveru, který pro komunikaci
otevře soket se jménem <strong>/tmp/test.socket</strong> (což je onen speciální
typ souboru):</p>

<pre>
$ <strong>nc -l -U -v /tmp/test.socket</strong>
&nbsp;
Bound on /tmp/test.socket
Listening on /tmp/test.socket
</pre>

<p>Samotný soket, na který se mají klienti připojit, bude vypadat
následovně:</p>

<pre>
$ <strong>lsof /tmp/test.socket</strong>
&nbsp;
COMMAND    PID     USER   FD   TYPE             DEVICE SIZE/OFF       NODE NAME
nc      235825 ptisnovs    3u  unix 0x0000000000000000      0t0 1288302629 /tmp/test.socket type=STREAM
</pre>

<p>Na druhém terminálu se k&nbsp;tomuto serveru připojíme přes unixový
soket:</p>

<pre>
$ <strong>nc -U -v /tmp/test.socket</strong>
</pre>

<p>Připojení k&nbsp;serveru je potvrzeno na prvním terminálu zprávou:</p>

<pre>
Connection received on /tmp/test.socket
</pre>

<p>A obousměrná komunikace je nástrojem <strong>lsof</strong> nalezena
takto:</p>

<pre>
$ <strong>lsof /tmp/test.socket</strong>
&nbsp;
COMMAND    PID     USER   FD   TYPE             DEVICE SIZE/OFF       NODE NAME
nc      235825 ptisnovs    3u  unix 0x0000000000000000      0t0 1288302629 /tmp/test.socket type=STREAM
nc      235825 ptisnovs    4u  unix 0x0000000000000000      0t0 1288302630 /tmp/test.socket type=STREAM
</pre>

<p>Podívejme se nyní na vlastnosti souboru
<strong>/tmp/test.socket</strong>:</p>

<pre>
$ <strong>ls -la /tmp/test.socket </strong>
&nbsp;
srwxrwxr-x 1 ptisnovs ptisnovs 0 Apr 30 15:26 /tmp/test.socket
</pre>

<p>Z&nbsp;prvního znaku &bdquo;s&ldquo; je patrné, že se skutečně jedná o
soket.</p>

<p>Komunikace přes <i>datagram</i> soket vypadá poněkud odlišně, protože se ve
skutečnosti použijí dva sokety, jeden explicitně pojmenovaný a druhý vytvořený
klientem (a klientem uzavíraný):</p>

<pre>
$ <strong>nc -l -u -U -v /tmp/test.socket</strong>
Bound on /tmp/test.socket
&nbsp;
$ <strong>nc -u -U -v /tmp/test.socket</strong>
Bound on /tmp/nc.XXXXRAlNkA
&nbsp;
$ <strong>lsof /tmp/test.socket</strong>
COMMAND    PID     USER   FD   TYPE             DEVICE SIZE/OFF       NODE NAME
nc      238174 ptisnovs    3u  unix 0x0000000000000000      0t0 1288403891 /tmp/test.socket type=DGRAM
&nbsp;
$ <strong>lsof /tmp/nc.XXXXRAlNkA</strong>
COMMAND    PID     USER   FD   TYPE             DEVICE SIZE/OFF       NODE NAME
nc      238687 ptisnovs    4u  unix 0x0000000000000000      0t0 1288437146 /tmp/nc.XXXXRAlNkA type=DGRAM
</pre>

<p><div class="rs-tip-major">Poznámka: tyto informace nám budou prozatím
postačovat k&nbsp;tomu, abychom mohli komunikaci přes unix sokety realizovat
v&nbsp;jazyce Go.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Realizace jednoduchého klienta komunikujícího přes TCP sokety v&nbsp;jazyku Go</h2>

<p>Síťové aplikace se vytváří na různých úrovních abstrakce &ndash; buď se
pouze otevřou připojení (například s&nbsp;využitím Unix socketů) a následný
komunikační protokol je naprogramován přímo vývojářem, nebo se naopak využije
nějaký již existující protokol na vyšší síťové vrstvě (HTTP atd.). Nejprve si
ukážeme komunikaci mezi jednoduchým klientem a serverem na nižší úrovni, kdy
náš komunikační protokol (na aplikační úrovni) bude spočívat v&nbsp;přenosu
jediného bajtu přes TCP popř.&nbsp;přes UDP.</p>

<p>Samotná implementace klienta bude poměrně přímočará a bude se skládat
z&nbsp;těchto kroků:</p>

<ol>

<li>Navázání připojení s&nbsp;využitím konstruktoru <strong>net.Dial(protokol,
adresa)</strong>, který je popsán na adrese <a
href="https://golang.org/pkg/net/#Dial">https://golang.org/pkg/net/#Dial</a>.
Použitý protokol je specifikován řetězcem; konkrétně se může jednat o konstanty
&bdquo;tcp&ldquo;, &bdquo;tcp4&ldquo;, &bdquo;tcp6&ldquo;, &bdquo;udp&ldquo;,
&bdquo;udp4&ldquo;, &bdquo;udp6&ldquo;, &bdquo;ip&ldquo;, &bdquo;ip4&ldquo;,
&bdquo;ip6&ldquo;, &bdquo;unix&ldquo;, &bdquo;unixgram&ldquo;
popř.&nbsp;&bdquo;unixpacket&ldquo;. V&nbsp;příkladu zvolíme &bdquo;tcp&ldquo;,
který bude funkční v&nbsp;sítích s&nbsp;IPv4 i IPv6 (nebo pochopitelně
v&nbsp;kombinovaných sítích).</li>

<li>Přečtení <i>n</i> bajtů metodou <strong>Read(b []byte) (n int, err
error)</strong> (konkrétní příjemce se liší podle toho, jaké připojení jsme
deklarovali v&nbsp;konstruktoru, ovšem tato metoda bude vždy podporována).
Povšimněte si, že této metodě je nutné předat řez (<i>slice</i>) a nikoli pole
bajtů (to je v&nbsp;tomto případě nekompatibilní datový typ). Z&nbsp;tohoto
důvodu v&nbsp;našem příkladu použijeme trik <strong>pole[:]</strong>, kterým se
vytvoří řez ukazující na celé pole (přesněji řez bude ukazovat na první prvek
pole a jeho délka bude odpovídat délce pole).</li>

<li>Přečtené pole bajtů se následně vytiskne, přičemž server implementovaný
v&nbsp;rámci další kapitoly je naprogramován takovým způsobem, aby posílal jen
jediný bajt.</li>

</ol>

<p>Úplný zdrojový kód tohoto demonstračního příkladu bude vypadat
následovně:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "net"
)
&nbsp;
func <strong>main</strong>() {
        conn, err := <u>net.Dial("tcp", "localhost:1234")</u>
        if err != nil {
                println("Connection refused!")
        } else {
                var b [1]byte
                n, err := <u>conn.Read(b[:])</u>
                if err != nil {
                        println("No response!")
                } else {
                        if n == 1 {
                                fmt.Printf("Received %d byte: %v\n", n, b)
                        } else {
                                fmt.Printf("Received %d bytes: %v\n", n, b)
                        }
                }
        }
}
</pre>

<p>O realizovaném připojení si můžeme zjistit i další informace, například
lokální i vzdálenou adresu s&nbsp;využitím metod
<strong>Conn.LocalAddr()</strong> a <strong>Conn.RemoteAddr()</strong>. Tyto
adresy převedeme do tisknutelného tvaru metodou <strong>String()</strong>. <a
href="https://github.com/tisnik/go-root/blob/master/article_11/01B_simple_client_headers.go">Upravený
klient</a> (stále však nepřipravený pro reálný provoz) může vypadat
následovně:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "net"
)
&nbsp;
func <strong>main</strong>() {
        conn, err := <u>net.Dial("tcp", "localhost:1234")</u>
        if err != nil {
                println("Connection refused!")
        } else {
                fmt.Printf("Connection established\n")
                fmt.Printf("Remote Address: %s \n", conn.RemoteAddr().String())
                fmt.Printf("Local Address:  %s \n", conn.LocalAddr().String())
&nbsp;
                var b [1]byte
                n, err := <u>conn.Read(b[:])</u>
                if err != nil {
                        println("No response!")
                } else {
                        if n == 1 {
                                fmt.Printf("Received %d byte: %v\n", n, b)
                        } else {
                                fmt.Printf("Received %d bytes: %v\n", n, b)
                        }
                }
        }
}
</pre>

<p>Příklad výsledku po připojení klienta k&nbsp;serveru popsanému <a
href="#k07">v&nbsp;další kapitole</a>:</p>

<pre>
Connection established
Remote Address: 127.0.0.1:1234
Local Address:  127.0.0.1:38082
Received 1 byte: [0]
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že server má pevně zadaný
port 1234, zatímco port otevřený na straně klienta je zvolen
systémem.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Základní kostra serveru komunikujícího přes TCP sokety v&nbsp;jazyku Go</h2>

<p>Nyní si ukažme implementaci serveru, na který se budou připojovat výše
popsaní klienti. Implementace serveru je nepatrně složitější, než implementace
klienta, a to z&nbsp;toho důvodu, že server musí obsloužit větší množství
klientů. V&nbsp;tom nejjednodušším případě použijeme takzvaný
&bdquo;neforkující&ldquo; server, který bude implementován následujícím
způsobem a který dokáže v&nbsp;dané chvíli obsloužit jen jediného klienta:</p>

<ol>

<li>Použijeme konstruktor nazvaný <strong>net.Listen()</strong>, v&nbsp;němž
opět specifikujeme protokol (viz <a href="#k07">předchozí kapitolu</a>) a
síťové rozhraní s&nbsp;portem 1234.</li>

<li>S&nbsp;využitím příkazu <strong>defer</strong> zajistíme, že se při
ukončení funkce <strong>main</strong> automaticky uzavře i otevřený port.</li>

<li>Dále v&nbsp;nekonečné smyčce budeme čekat na připojení v&nbsp;metodě
<strong>Accept</strong>. Jakmile se nějaký klient pokusí o připojení, vrátí
tato metoda strukturu implementující mj.&nbsp;metody <strong>Read</strong> a
<strong>Write</strong>. A právě s&nbsp;využitím metody <strong>Write</strong>
pošleme klientovi jediný bajt obsahující hodnotu počitadla dotazů.</li>

<li>Spojení se automaticky ukončí díky použití příkazu <strong>defer
l.Close()</strong></li>

</ol>

<p>Zdrojový kód takto napsaného serveru bude vypadat následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "net"
)
&nbsp;
func <strong>processRequest</strong>(connection net.Conn, cnt *byte) {
        var buffer = []byte{*cnt}
        *cnt++
        n, err := <u>connection.Write(buffer)</u>
        if err != nil {
                log.Println("Writing error", err)
        } else {
                log.Printf("Written %d byte(s)", n)
        }
}
&nbsp;
func <strong>main</strong>() {
        cnt := byte(0)
&nbsp;
        l, err := <u>net.Listen("tcp", "localhost:1234")</u>
        if err != nil {
                log.Fatal("Can't open the port!")
        }
&nbsp;
        for {
                connection, err := <i>l.Accept()</i>
&nbsp;
                if err != nil {
                        log.Println("Connection refused!")
                } else {
                        log.Println("Connection accepted")
                        processRequest(connection, &amp;cnt)
                }
        }
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vylepšení klienta i serveru &ndash; uzavírání prostředků a reakce na případné chyby</h2>

<pre>
package main

import (
        "log"
        "net"
)

const BufferSize = 1024

func main() {
        connection, err := net.Dial("tcp", "localhost:1234")
        if err != nil {
                log.Fatal("Connection refused!")
                return
        }
        log.Print("Connection established, waiting for data")

        defer func() {
                log.Println("Closing connection")
                err := connection.Close()
                if err != nil {
                        log.Println("Closing connection failed", err)
                }
        }()

        buffer := make([]byte, BufferSize)
        n, err := connection.Read(buffer)
        if err != nil {
                log.Println("No response!", err)
        } else {
                if n == 1 {
                        log.Printf("Received %d byte: %v\n", n, buffer[:n])
                } else {
                        log.Printf("Received %d bytes: %v\n", n, buffer[:n])
                }
        }
}
</pre>

<pre>
package main

import (
        "log"
        "net"
)

func processRequest(connection net.Conn, cnt *byte) {
        defer func() {
                log.Println("Closing connection")
                err := connection.Close()
                if err != nil {
                        log.Println("Closing connection failed", err)
                }
        }()

        var buffer = []byte{*cnt}
        *cnt++
        n, err := connection.Write(buffer)
        if err != nil {
                log.Println("Writing error", err)
        } else {
                log.Printf("Written %d byte(s)", n)
        }
}

func main() {
        cnt := byte(0)

        l, err := net.Listen("tcp", "localhost:1234")
        if err != nil {
                log.Fatal("Can't open the port!")
        }
        defer func() {
                err := l.Close()
                if err != nil {
                        log.Println("Listener close failed", err)
                }
        }()

        for {
                connection, err := l.Accept()

                if err != nil {
                        log.Println("Connection refused!")
                } else {
                        log.Println("Connection accepted")
                        processRequest(connection, &cnt)
                }
        }
}
</pre>


<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. Konfigurace HAProxy</h2>

<pre>
global
    log stdout format raw local0
    stats socket /tmp/haproxy.sock mode 600 level admin
    stats timeout 2m

defaults
    log global
    mode tcp
    timeout http-request    10s
    timeout queue           1m
    timeout connect         10s
    timeout client          1m
    timeout server          1m
    timeout http-keep-alive 10s
    timeout check           10s
    maxconn                 3000

frontend db
    # receives traffic from clients
    bind :80
    default_backend http

backend http
    # relays the client messages to servers
    server myserver localhost:8080
</pre>

<pre>
    stats socket /tmp/haproxy.sock mode 600 level admin
</pre>

<pre>
global
    log stdout format raw local0
    stats socket /tmp/haproxy_user.sock mode 600 level admin
    stats timeout 2m

defaults
    log global
    mode tcp
    timeout http-request    10s
    timeout queue           1m
    timeout connect         10s
    timeout client          1m
    timeout server          1m
    timeout http-keep-alive 10s
    timeout check           10s
    maxconn                 3000

frontend db
    # receives traffic from clients
    bind :8000
    default_backend http

backend http
    # relays the client messages to servers
    server myserver localhost:8080
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

$ sudo haproxy -f haproxy.cfg
Proxy db started.
Proxy http started.
[WARNING] 096/181552 (561729) : Server http/myserver is going DOWN for maintenance. 0 active and 0 backup servers left. 0 sessions active, 0 requeued, 0 remaining in queue.
Server http/myserver is going DOWN for maintenance. 0 active and 0 backup servers left. 0 sessions active, 0 requeued, 0 remaining in queue.
[ALERT] 096/181552 (561729) : backend 'http' has no server available!
backend http has no server available!
[WARNING] 096/181554 (561729) : Server http/myserver is UP/READY (leaving forced maintenance).
Server http/myserver is UP/READY (leaving forced maintenance).


<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů naprogramovaných
v&nbsp;jazyku Go byly uloženy do Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář, můžete namísto toho
použít odkazy na jednotlivé demonstrační příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Příklad/soubor</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td>1</td><td>simple_tcp_client</td><td>jednoduchý klient komunikující se serverem s&nbsp;využitím protokolu TCP</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A7/simple_tcp_client/">https://github.com/tisnik/go-root/blob/master/article_A7/simple_tcp_client/</a></td></tr>
<tr><td>2</td><td>simple_tcp_server</td><td>jednoduchý server naslouchající na TCP portu a komunikující přes protokol TCP</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A7/simple_tcp_server/">https://github.com/tisnik/go-root/blob/master/article_A7/simple_tcp_server/</a></td></tr>
<tr><td>3</td><td>slow_tcp_server</td><td>TCP server naprogramovaný v&nbsp;Go, který odpovídá se zpožděním</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A7/slow_tcp_server/">https://github.com/tisnik/go-root/blob/master/article_A7/slow_tcp_server/</a></td></tr>
<tr><td>4</td><td>multi_connection_tcp_server</td><td>TCP server pro větší množství klientů</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A7/multi_connection_tcp_server/">https://github.com/tisnik/go-root/blob/master/article_A7/multi_connection_tcp_server/</a></td></tr>
<tr><td>5</td><td>simple_unix_socket_client</td><td>klient používající Unixové sokety</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A7/simple_unix_socket_client/">https://github.com/tisnik/go-root/blob/master/article_A7/simple_unix_socket_client/</a></td></tr>
<tr><td>6</td><td>simple_unix_socket_server</td><td>server používající Unixové sokety</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A7/simple_unix_socket_server/">https://github.com/tisnik/go-root/blob/master/article_A7/simple_unix_socket_server/</a></td></tr>
<tr><td>7</td><td>haproxy_controller</td><td>ukázka ovládání HAProxy přes sokety</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A7/haproxy_controller/">https://github.com/tisnik/go-root/blob/master/article_A7/haproxy_controller/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>What Are Unix Sockets and How Do They Work?<br />
<a href="https://www.howtogeek.com/devops/what-are-unix-sockets-and-how-do-they-work/">https://www.howtogeek.com/devops/what-are-unix-sockets-and-how-do-they-work/</a>
</li>

<li>Unix domain socket<br />
<a href="https://en.wikipedia.org/wiki/Unix_domain_socket">https://en.wikipedia.org/wiki/Unix_domain_socket</a>
</li>

<li>Interprocess Communication With Unix Sockets<br />
<a href="https://www.baeldung.com/linux/communicate-with-unix-sockets">https://www.baeldung.com/linux/communicate-with-unix-sockets</a>
</li>

<li>Creating A Simple Web Server With Golang<br />
<a href="https://tutorialedge.net/golang/creating-simple-web-server-with-golang/">https://tutorialedge.net/golang/creating-simple-web-server-with-golang/</a>
</li>

<li>Building a Web Server in Go<br />
<a href="https://thenewstack.io/building-a-web-server-in-go/">https://thenewstack.io/building-a-web-server-in-go/</a>
</li>

<li>How big is the pipe buffer?<br />
<a href="https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer">https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer</a>
</li>

<li>How to turn off buffering of stdout in C<br />
<a href="https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c">https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c</a>
</li>

<li>OSI model<br />
<a href="https://en.wikipedia.org/wiki/OSI_model">https://en.wikipedia.org/wiki/OSI_model</a>
</li>

<li>Datagram<br />
<a href="https://cs.wikipedia.org/wiki/Datagram">https://cs.wikipedia.org/wiki/Datagram</a>
</li>

<li>Softwarová rozhraní systémů UNIX pro přístup k síťovým službám<br />
<a href="https://www.cs.vsb.cz/grygarek/PS/sockets.html">https://www.cs.vsb.cz/grygarek/PS/sockets.html</a>
</li>

<li>HAProxy: Management Guide version 2.4.22-1<br />
<a href="https://docs.haproxy.org/2.4/management.html#9.3">https://docs.haproxy.org/2.4/management.html#9.3</a>
</li>

<li>Síťový socket<br />
<a href="https://cs.wikipedia.org/wiki/S%C3%AD%C5%A5ov%C3%BD_socket">https://cs.wikipedia.org/wiki/S%C3%AD%C5%A5ov%C3%BD_socket</a>
</li>

<li>Unix domain socket<br />
<a href="https://cs.wikipedia.org/wiki/Unix_domain_socket">https://cs.wikipedia.org/wiki/Unix_domain_socket</a>
</li>

<li>unix domain sockets vs. internet sockets<br />
<a href="https://lists.freebsd.org/pipermail/freebsd-performance/2005-February/001143.html">https://lists.freebsd.org/pipermail/freebsd-performance/2005-February/001143.html</a>
</li>

<li>What's the difference between streams and datagrams in network programming?<br />
<a href="https://stackoverflow.com/questions/4688855/whats-the-difference-between-streams-and-datagrams-in-network-programming">https://stackoverflow.com/questions/4688855/whats-the-difference-between-streams-and-datagrams-in-network-programming</a>
</li>

<li>Introducing TCP/IP concepts: Selecting sockets<br />
<a href="https://www.ibm.com/docs/en/zos/2.3.0?topic=concepts-introducing-tcpip-selecting-sockets">https://www.ibm.com/docs/en/zos/2.3.0?topic=concepts-introducing-tcpip-selecting-sockets</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

