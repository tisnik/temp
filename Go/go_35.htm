<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Go pro skalní céčkaře (2.část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Go pro skalní céčkaře (2.část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešní části seriálu o jazyce Go si ukážeme další vlastnosti Go, které mohou překvapit ty vývojáře, kteří primárně používají programovací jazyk C a v&nbsp;menší míře i C++. Ukážeme si odlišnou práci s řetězci, poli, soubory a taktéž s&nbsp;chybami (chybovými stavy aplikace).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Go pro skalní céčkaře (2.část)</a></p>
<p><a href="#k02">2. Pravdivostní hodnoty</a></p>
<p><a href="#k03">3. Zpracování řetězců</a></p>
<p><a href="#k04">4. Neměnitelné a měnitelné řetězce</a></p>
<p><a href="#k05">5. Problematika znaků zakódovaných v&nbsp;UTF-8</a></p>
<p><a href="#k06">6. Porovnání řetězců bez jazykových specifik</a></p>
<p><a href="#k07">7. Porovnání řetězců na základě jazykových specifik (speciálně pro ČR)</a></p>
<p><a href="#k08">8. Spojení řetězců</a></p>
<p><a href="#k09">9. Získání podřetězce (ASCII znaky)</a></p>
<p><a href="#k10">10. Podřetězce a Unicode znaky</a></p>
<p><a href="#k11">11. Vytvoření polí</a></p>
<p><a href="#k12">12. Kopie polí</a></p>
<p><a href="#k13">13. Vícerozměrná pole</a></p>
<p><a href="#k14">14. Realokace polí resp.&nbsp;použití řezů</a></p>
<p><a href="#k15">15. Sledování kapacity řezu při realokacích polí</a></p>
<p><a href="#k16">16. Práce se soubory (základní vstupně-výstupní operace)</a></p>
<p><a href="#k17">17. Čtení či zápis po blocích</a></p>
<p><a href="#k18">18. Zpracování chyb, reakce na chyby</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Go pro skalní céčkaře (2.část)</h2>

<p>V&nbsp;dnešním článku o programovacím jazyku Go dokončíme téma, kterému jsme
se začali věnovat <a
href="https://www.root.cz/clanky/programovaci-jazyk-go-pro-skalni-ceckare/">minule</a>.
Opět si ukážeme některé vlastnosti programovacího jazyka Go, které mohou
překvapit vývojáře používající programovací jazyk C (a v&nbsp;menší míře i C++)
a kteří se snaží používat i jazyk Go, například pro nové projekty. Některé
vlastnosti programovacího jazyka Go mohou být pro nováčky poměrně matoucí, což
se týká například práce s&nbsp;řetězci (rozdíl mezi chápáním řetězců jako
sekvence bajtů a znaků). Další vlastnosti naopak vedou k&nbsp;tvorbě kratších,
bezpečnějších a popř.&nbsp;i lépe pochopitelných zdrojových kódů, zejména ve
chvíli, kdy se pracuje s&nbsp;dynamicky alokovanou pamětí, poli, spojování a
rozdělování řetězců atd. Zcela odlišné jsou jazyky Go a C při práci se soubory
resp.&nbsp;přesněji řečeno se vstupně-výstupním systémem a knihovnami, které
I/O realizují. Odlišný je i systém pro detekci a zpracování chyb, které mohou
při běhu aplikace nastat.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Pravdivostní hodnoty</h2>

<p>Popis rozdílů mezi programovacím jazykem C a jazykem Go začneme u zdánlivě
zcela triviálního tématu &ndash; pravdivostních hodnot, způsobu jejich
reprezentace a (automatických) konverzí. V&nbsp;céčku je za pravdu považována
jakákoli nenulová hodnota, což platí jak pro celočíselné hodnoty i hodnoty
s&nbsp;plovoucí řádovou čárkou, tak i pro ukazatele. To například znamená, že
následující demonstrační příklad po svém překladu, slinkování a spuštění
postupně vypíše zprávy:</p>

<pre>
false
true
true
false
</pre>

<p>Nejprve se vyhodnocuje podmínka s&nbsp;nulovým ukazatelem, dále podmínka
s&nbsp;celým číslem, na třetím řádku podmínka s&nbsp;hodnotou s&nbsp;plovoucí
řádovou čárkou a nakonec test ukazatele inicializovaného opět na hodnotu
<strong>NULL</strong>:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int main(void) {
    if (NULL) {
        puts("true");
    }
&nbsp;
    if (!NULL) {
        puts("false");
    }
&nbsp;
    if (1) {
        puts("true");
    }
&nbsp;
    if (0) {
        puts("false");
    }
&nbsp;
    if (1.5) {
        puts("true");
    }
&nbsp;
    if (0.0) {
        puts("false");
    }
&nbsp;
    void *b1 = NULL;
&nbsp;
    if (b1) {
        puts("true");
    }
&nbsp;
    if (!b1) {
        puts("false");
    }
&nbsp;
    return 0;
}
</pre>

<p>V&nbsp;programovacím jazyce Go je ovšem situace zcela odlišná, protože
v&nbsp;tomto jazyku existují pouze dvě pravdivostní hodnoty &ndash;
<strong>true</strong> a <strong>false</strong>, které jsou typu <a
href="https://golang.org/ref/spec#Boolean_types">bool</a>. Žádné další hodnoty
se nesmí v&nbsp;rozhodovací konstrukci <strong>if</strong>, v&nbsp;podmínce
smyčky <strong>for</strong> atd., vyskytovat. To například znamená, že
následující demonstrační příklad nebude možné přeložit (a tudíž pochopitelně
ani spustit):</p>

<pre>
package main
&nbsp;
func main() {
        if nil {
                println("true")
        }
&nbsp;
        if !nil {
                println("false")
        }
&nbsp;
        if 1 {
                println("true")
        }
&nbsp;
        if 0 {
                println("false")
        }
&nbsp;
        if 1.5 {
                println("true")
        }
&nbsp;
        if 0.0 {
                println("false")
        }
&nbsp;
        var b1 bool = nil
&nbsp;
        if b1 {
                println("true")
        }
&nbsp;
        if !b1 {
                println("false")
        }
}
</pre>

<p>Při pokusu o překlad se vypíšou tyto zprávy o chybě:</p>

<pre>
./01_booleans.go:4:2: use of untyped nil
./01_booleans.go:8:5: invalid operation: ! nil
./01_booleans.go:12:2: non-bool 1 (type int) used as if condition
./01_booleans.go:16:2: non-bool 0 (type int) used as if condition
./01_booleans.go:20:2: non-bool 1.5 (type float64) used as if condition
./01_booleans.go:24:2: non-bool 0 (type float64) used as if condition
./01_booleans.go:28:6: cannot use nil as type bool in assignment
</pre>

<p><div class="rs-tip-major">Poznámka: mohlo by se zdát, že se jedná o
přílišnou rigiditu, ovšem díky těmto pravidlům se prakticky zcela odstraní
chyby typu = vs. == ve výrazu za klíčovým slovem <strong>if</strong>, které
většina překladačů céčka pouze ohlašuje ve formě varování:</div></p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a int = 0
        if a = 2 {
                fmt.Println("==2")
        }
}
</pre>

<p>Pokus o překlad skončí s&nbsp;chybou:</p>

<pre>
t.go:7:5: expected boolean expression, found assignment (missing parentheses around composite literal?)
</pre>

<p>Podobně není umožněna automatická konverze numerické hodnoty
popř.&nbsp;řetězce na hodnotu pravdivostní:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a bool = true
        var b bool = false
        var c bool = 0
        var d bool = ""
&nbsp;
        fmt.Println(a)
        fmt.Println(b)
        fmt.Println(c)
        fmt.Println(d)
}
</pre>

<p>Opět se můžeme přesvědčit, že tyto chyby odhalí překladač:</p>

<pre>
./02_boolean_type_checks.go:8:6: cannot use 0 (type int) as type bool in assignment
./02_boolean_type_checks.go:9:15: cannot use "" (type string) as type bool in assignment
</pre>

<p><div class="rs-tip-major">Poznámka pro programátory používající jazyk
Python: prázdný řetězec není v&nbsp;céčku považován za nepravdu, protože se
interně jedná o ukazatel na řetězcový literál (zde konkrétně uložený
v&nbsp;sekci <strong>.rodata</strong>, překladač však většinou celou podmínku
z&nbsp;kódu odstraní).  Tento příklad tedy dvakrát za sebou vypíše zprávu
<strong>true</strong>:</div></p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int main(void) {
    if ("") {
        puts("true");
    } else {
        puts("false");
    }
&nbsp;
    if ("foobar") {
        puts("true");
    } else {
        puts("false");
    }
&nbsp;
    return 0;
}
</pre>

<p>Jak jsme si již napsali v&nbsp;předchozím odstavci, překladač celou podmínku
většinou odstraní (a to u většiny překladačů nezávisle na povolení či zákazu
optimalizací):</p>

<pre>
    if ("") {
        puts("true");
  11:   c7 04 24 00 00 00 00    mov    DWORD PTR [esp],0x0
  18:   e8 fc ff ff ff          call   19 &lt;main+0x19&gt;
    }
    else {
        puts("false");
    }
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zpracování řetězců</h2>

<p>Poněkud větší rozdíly mezi programovacími jazyky C a Go panují
v&nbsp;oblasti zpracování řetězců. Nejprve se podívejme, jak se v&nbsp;C
zpracovávají konstantní (neměnné) řetězce, které jsou na moderních
architekturách umístěny v&nbsp;segmentu nastaveném pouze pro čtení (sekce se
tedy jmenuje <strong>.rodata</strong>). Takové řetězce jsou v&nbsp;jazyku C
představovány řetězcovým literálem. Aby byl příklad poněkud komplikovanější,
obsahuje poslední řetězcový literál Unicode znaky, které jsou reprezentovány
v&nbsp;kódu <a href="http://www.utf-8.com/">UTF-8</a> proměnným počtem bajtů
(zde tedy neplatí, že každý znak reprezentuje jediný znak). Tento příklad bude
správně přeložen jen na těch systémech, které jsou nakonfigurovány pro
zpracování zdrojových kódů v&nbsp;UTF-8 (ovšem jedná se o poměrně složité téma,
o kterém se dozvíte více informací například na stránce <a
href="https://www.cprogramming.com/tutorial/unicode.html">Unicode in C and C++:
What You Can Do About It Today</a>, pro naše účely však bude dostačovat mít
možnost vypsat řetězec reprezentovaný v&nbsp;UTF-8):</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int main(void) {
    char *s1 = "www.root.cz";
    char *s2 = "";
    char *s3 = "Hello\nworld!\n";
    char *s4 = "[шщэюя]";
&nbsp;
    puts(s1);
    puts(s2);
    puts(s3);
    puts(s4);
&nbsp;
    return 0;
}
</pre>

<p><div class="rs-tip-major">Poznámka: podívejme se pro zajímavost na způsob
interní reprezentace všech čtyř řetězců v&nbsp;assembleru. Postačuje provést
překlad s&nbsp;uvedením volby <strong>-S</strong> a podívat se na výsledný kód
vygenerovaný překladačem (za povšimnutí stojí i to, že se řetězce skutečně
uložily do sekce nazvané <strong>.rodata</strong> neboli <i>read-only
data</i>):</div></p>

<pre>
        .file   "03_strings.c"
        .text
.Ltext0:
        .section        .rodata
.LC0:
        .string "www.root.cz"
.LC1:
        .string ""
.LC2:
        .string "Hello\nworld!\n"
.LC3:
        .string "[\321\210\321\211\321\215\321\216\321\217]"
        .text
        .globl  main
        .type   main, @function
</pre>

<p>Sekvenci bajtů s&nbsp;kódy 321 210 321 211 321 215 321 216 321 217
v&nbsp;osmičkové soustavě si převedeme do desítkové soustavy a nalezneme
příslušné znaky v&nbsp;Unicode (konkrétně budeme hledat v&nbsp;bloku <a
href="https://en.wikipedia.org/wiki/Cyrillic_(Unicode_block)">Cyrillic</a>:</p>

<table>
<tr><th>Bajty (octal)</th><th>Bajty (dec)</th><th>Unicode index</th><th>Index v&nbsp;hexa</th><th>Znak</th></tr>
<tr><td>321 210</td><td>209 136</td><td>1096</td><td>0x0448</td><td>ш</td></tr>
<tr><td>321 211</td><td>209 137</td><td>1097</td><td>0x0449</td><td>щ</td></tr>
<tr><td>321 215</td><td>209 141</td><td>1101</td><td>0x044d</td><td>э</td></tr>
<tr><td>321 216</td><td>209 142</td><td>1102</td><td>0x044e</td><td>ю</td></tr>
<tr><td>321 217</td><td>209 143</td><td>1103</td><td>0x044f</td><td>я</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti mohou mít znaky
(characters) reprezentované v&nbsp;UTF-8 proměnnou délku od jednoho bajtu do
čtyř bajtů (teoreticky, pokud se Unicode někdy v&nbsp;budoucnosti rozšíří
z&nbsp;21 bitů na plných 32 bitů, se může jednat i o více bajtů).</div></p>

<p>V&nbsp;programovacím jazyku Go budeme postupovat prakticky stejným způsobem,
protože zde jsou řetězce taktéž neměnné a opět se může použít UTF-8 pro Unicode
znaky (zde je ovšem podpora UTF-8 přímo součástí specifikace programovacího
jazyka):</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var s1 string = "www.root.cz"
        var s2 string = ""
        var s3 string = "Hello\nworld!\n"
        var s4 string = "шщэюя"
&nbsp;
        fmt.Println(s1)
        fmt.Println(s2)
        fmt.Println(s3)
        fmt.Println(s4)
}
</pre>

<p>Existuje ovšem i kratší způsob, v&nbsp;němž je typ proměnné odvozen od typu
hodnoty, která se do proměnné vkládá. Musíme zde použít operátor := a nikoli
pouze rovnítko:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        s1 := "www.root.cz"
        s2 := ""
        s3 := "Hello\nworld!\n"
        s4 := "шщэюя"
&nbsp;
        fmt.Println(s1)
        fmt.Println(s2)
        fmt.Println(s3)
        fmt.Println(s4)
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Neměnitelné a měnitelné řetězce</h2>

<p>Řetězcové literály jsou většinou uloženy v&nbsp;kódovém segmentu (též známý
jako textový segment, viz též <a href="#k03">předchozí kapitolu</a>), který je
na většině platforem určen pouze pro čtení (výjimkou jsou například osmibitové
mikropočítače, x86 v&nbsp;reálném režimu DOSu apod.). To znamená, že by se
správně měl použít modifikátor <strong>const</strong>, aby se následující
(jinak obecně chybný kód, jehož chování je navíc podle normy nespecifikováno)
nemohl přeložit:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int main(void) {
    const char *s = "www.root.cz";
&nbsp;
    puts(s);
    s[3] = '*';
    s[8] = '*';
    puts(s);
&nbsp;
    return 0;
}
</pre>

<p>Pokus o překlad skutečně skončí s&nbsp;chybou:</p>

<pre>
04_immutable_strings.c: In function ‘main’:
04_immutable_strings.c:7:10: error: assignment of read-only location ‘*(s + 3)’
     s[3] = '*';
          ^
04_immutable_strings.c:8:10: error: assignment of read-only location ‘*(s + 8)’
     s[8] = '*';
          ^
</pre>

<p>Pokud vynecháme modifikátor <strong>const</strong> a podíváme se do
vygenerovaného strojového kódu, uvidíme pokus o změnu obsahu segmentu, který je
určen jen pro čtení (sekce <strong>.rodata</strong>):</p>

<pre>
    char *s = "www.root.cz";
  11:   c7 45 f8 00 00 00 00    mov    DWORD PTR [ebp-0x8],0x0
&nbsp;
    s[3] = '*';
  23:   8b 45 f8                mov    eax,DWORD PTR [ebp-0x8]
  26:   83 c0 03                add    eax,0x3
  29:   c6 00 2a                mov    BYTE PTR [eax],0x2a
    s[8] = '*';
  2c:   8b 45 f8                mov    eax,DWORD PTR [ebp-0x8]
  2f:   83 c0 08                add    eax,0x8
  32:   c6 00 2a                mov    BYTE PTR [eax],0x2a
</pre>

<p>Samotný řetězec je skutečně uložen v&nbsp;sekci <strong>rodata</strong>:</p>

<pre>
Contents of section .rodata:
 0000 7777772e 726f6f74 2e637a00           www.root.cz.    
</pre>

<p>V&nbsp;programovacím jazyce Go jsou řetězce neměnné (<i>immutable</i>),
takže ani zde nebude možné tento zdrojový kód přeložit a spustit:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var s string = "www.root.cz"
&nbsp;
        fmt.Println(s)
        s[3] = '*'
        s[8] = '*'
        fmt.Println(s)
}
</pre>

<p>Výsledek spuštění tohoto příkladu:</p>

<pre>
./04_immutable_strings.go:9:7: cannot assign to s[3]
./04_immutable_strings.go:10:7: cannot assign to s[8]
</pre>

<p>Pokud v&nbsp;jazyku C budeme chtít vytvořit modifikovatelný řetězec, lze
použít tento postup &ndash; namísto ukazatele na první znak řetězcového
literálu vytvoříme pole a celý řetězec do něj uložíme:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int main(void) {
    char s[] = "www.root.cz";
&nbsp;
    puts(s);
    s[3] = '*';
    s[8] = '*';
    puts(s);
&nbsp;
    return 0;
}
</pre>

<p><div class="rs-tip-major">Poznámka: samotné naplnění pole se překladače
většinou snaží optimalizovat, takže se neprovádí inicializace bajt po bajtu
(například kopií z&nbsp;kódového segmentu), ale inicializace po větších
celcích. Konkrétně na 32bitové platformě x386 může inicializace pole vypadat
následovně (vždy po čtyřech bajtech, pochopitelně včetně koncové
nuly):</div></p>

<pre>
    char s[] = "www.root.cz";
  1c:   c7 45 ec 77 77 77 2e    mov    DWORD PTR [ebp-0x14],0x2e777777
  23:   c7 45 f0 72 6f 6f 74    mov    DWORD PTR [ebp-0x10],0x746f6f72
  2a:   c7 45 f4 2e 63 7a 00    mov    DWORD PTR [ebp-0xc],0x7a632e
</pre>

<p>Na 64bitové platformě x86-64 se počet instrukcí ještě dále snižuje na pouhé
dva přesuny:</p>

<pre>
    char s[] = "www.root.cz";
  17:   48 b8 77 77 77 2e 72    movabs rax,0x746f6f722e777777
  1e:   6f 6f 74 
  21:   48 89 45 e0             mov    QWORD PTR [rbp-0x20],rax
  25:   c7 45 e8 2e 63 7a 00    mov    DWORD PTR [rbp-0x18],0x7a632e
</pre>

<p>V&nbsp;jazyku Go se můžeme k&nbsp;výše popsanému chování přiblížit tak, že
použijeme pole bajtů a nikoli přímo řetězec (ten bude sloužit jako zdroj dat
pro naplnění pole, konverze řetězce na bajty a alokace se pochopitelně provede
automaticky):</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var s []byte = []byte("www.root.cz")
&nbsp;
        fmt.Println(string(s))
        s[3] = '*'
        s[8] = '*'
        fmt.Println(string(s))
}
</pre>

<p>Výsledek spuštění tohoto příkladu:</p>

<pre>
www.root.cz
www*root*cz
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Problematika znaků zakódovaných v&nbsp;UTF-8</h2>

<p>Ještě jednou se vraťme k&nbsp;problematice znaků v&nbsp;řetězcích
s&nbsp;kódováním UTF-8. Jednotlivé znaky jsou reprezentovány jedním až čtyřmi
bajty, takže není snadné říci, zda přepisem jednoho bajtu nedojde
k&nbsp;&bdquo;rozbití&ldquo; jednoho nebo i dvou znaků ve výsledném řetězci.
V&nbsp;následujícím zdrojovém kódu nahrazujeme první a poslední znak
hvězdičkou, což je v&nbsp;pořádku, protože tyto dva znaky patří do původní sady
ASCII a jsou tedy reprezentovány jediným bajtem. Ovšem současně přepisujeme i
bajt (ne znak!) na indexu 5, což není korektní, protože na této pozici se
nachází jeden ze dvou bajtů reprezentujících znak v&nbsp;azbuce:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int main(void) {
    char s[] = "[шщэюя]";
&nbsp;
    puts(s);
&nbsp;
    s[0] = '*';
&nbsp;
    /* problematicka cast */
    s[5] = '-';
&nbsp;
    s[11] = '*';
    puts(s);
&nbsp;
    return 0;
}
</pre>

<p>Výsledek spuštění příkladu:</p>

<pre>
[шщэюя]
*шщ-�юя*
</pre>

<p><div class="rs-tip-major">Poznámka: pokud jsme změnili první bajt znaku,
dojde k&nbsp;poškození řetězce ve dvou znacích, protože '-' reprezentuje
hodnotu menší než 128, což mj.&nbsp;znamená, že je tímto bajtem znak ukončen. A
následující hodnota je již považována za znak nový.</div></p>

<p>Tímto způsobem můžeme s&nbsp;řetězci (většinou nesprávně) manipulovat i
v&nbsp;programovacím jazyce Go:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var s []byte = []byte("[шщэюя]")
&nbsp;
        fmt.Println(string(s))
&nbsp;
        s[0] = '*'
&nbsp;
        // problematicka cast
        s[5] = '-'
&nbsp;
        s[11] = '*'
        fmt.Println(string(s))
}
</pre>

<p>Výsledek spuštění příkladu:</p>

<pre>
[шщэюя]
*шщ-�юя*
</pre>

<p>Korektní způsob, který však nemusí být příliš rychlý, spočívá v&nbsp;převodu
řetězce na pole run a v&nbsp;manipulaci s&nbsp;obsahem tohoto pole:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        s := "[шщэюя]"
&nbsp;
        var r []rune = []rune(s)
&nbsp;
        fmt.Println(string(r))
&nbsp;
        r[0] = '*'
&nbsp;
        r[3] = '-'
&nbsp;
        r[6] = '*'
        fmt.Println(string(r))
</pre>

<p>Nyní již výsledek bude odpovídat očekávání:</p>

<pre>
[шщэюя]
*шщ-юя*
</pre>

<p><div class="rs-tip-major">Poznámka: pole run je nutné převést zpět na
řetězec s&nbsp;využitím <strong>string()</strong>, protože jinak by se vypsaly
numerické kódy (indexy) znaků a nikoli jejich tvary.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Porovnání řetězců bez jazykových specifik</h2>

<p>Dále se budeme zabývat porovnáváním řetězců. V&nbsp;programovacím jazyku C
pochopitelně není možné použít pro přímé porovnání řetězců běžné relační
operátory, protože ty by porovnaly pouze hodnoty ukazatelů a nikoli obsah
řetězců. Namísto toho se používají funkce <strong>strcmp</strong> (pro
&bdquo;úzké&ldquo; znaky) popř.&nbsp;<strong>wcscmp</strong> (pro
&bdquo;široké&ldquo; znaky). Tato funkce vrací záporné číslo, pokud je první
řetězec lexikograficky menší, než řetězec druhý. Pokud jsou oba řetězce stejné,
vrací se nula a kladné číslo v&nbsp;případě, že je první řetězec lexikograficky
větší, než druhý.</p>

<p>Vyzkoušejme si nyní, jak toto porovnání funguje v&nbsp;praxi, a to i při
použití Unikódu, resp.&nbsp;přesněji řečeno řetězců se znaky zakódovanými
v&nbsp;UTF-8:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
&nbsp;
int main(void) {
        printf("%d\n", strcmp("aa", "ab"));
        printf("%d\n", strcmp("aa", "aa"));
&nbsp;
        printf("%d\n", strcmp("e", "é"));
        printf("%d\n", strcmp("e", "ě"));
        printf("%d\n", strcmp("ě", "é"));
&nbsp;
        printf("%d\n", strcmp("z", "é"));
        printf("%d\n", strcmp("z", "ě"));
&nbsp;
        printf("%d\n", strcmp("h", "ch"));
        printf("%d\n", strcmp("ch", "i"));
&nbsp;
        printf("%d\n", strcmp("Hrdina", "Chocholoušek"));
        printf("%d\n", strcmp("Crha", "Chocholoušek"));
&nbsp;
        return 0;
}
</pre>

<p>Výsledky nejsou v&nbsp;tomto případě korektní (a ani být nemohou):</p>

<pre>
-1          strcmp("aa", "ab");
0           strcmp("aa", "aa");
&nbsp;
-1          strcmp("e", "é");
-1          strcmp("e", "ě");
1           strcmp("ě", "é");
&nbsp;
-1          strcmp("z", "é");
-1          strcmp("z", "ě");
&nbsp;
1           strcmp("h", "ch");
-1          strcmp("ch", "i");
&nbsp;
1           strcmp("Hrdina", "Chocholoušek");
1           strcmp("Crha", "Chocholoušek");
</pre>

<p>Povšimněte si, že je porovnání korektní v&nbsp;prvních dvou případech, ovšem
již ne pro znaky s&nbsp;nabodeníčky. Další problém (lokální) spočívá
v&nbsp;tom, že &bdquo;ch&ldquo; není chápán jako samostatný znak ležící mezi
&bdquo;h&ldquo; a &bdquo;i&ldquo;.</p>

<p>V&nbsp;jazyce Go můžeme podobné porovnání provést přímo s&nbsp;využitím
relačních operátorů. Jinými slovy &ndash; relační operátory jsou korektně
aplikovatelné i na řetězce (pokud na chvíli zapomeneme na problémy se znaky
s&nbsp;nabodeníčky atd., což je téma, kterým se budeme podrobněji zabývat <a
href="#k07">v&nbsp;navazující kapitole</a>):</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        fmt.Println("aa" &lt; "ab")
        fmt.Println("aa" == "ab")
&nbsp;
        fmt.Println("aa" &lt; "aa")
        fmt.Println("aa" == "aa")
&nbsp;
        fmt.Println("e" &lt; "é")
        fmt.Println("e" &lt; "ě")
&nbsp;
        fmt.Println("z" &lt; "é")
        fmt.Println("z" &lt; "ě")
&nbsp;
        fmt.Println("h" &lt; "ch")
        fmt.Println("ch" &lt; "i")
&nbsp;
        fmt.Println("Hrdina" &lt; "Chocholoušek")
        fmt.Println("Crha" &lt; "Chocholoušek")
}
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;praxi to znamená, že se používají
operátory == a !=, tj.&nbsp;test na rovnost nebo naopak nerovnost dvou řetězců,
ale pro lexikografické porovnání je lepší použít přístup popsaný
v&nbsp;navazující kapitole.</div></p>

<p>V&nbsp;případě, že je nutné získat výsledky porovnání v&nbsp;numerické
podobě (-1, 0, 1), což je vyžadováno například u některých řadicích algoritmů,
je možné použít funkci <strong>strings.Compare</strong>:</p>

<pre>
package main
&nbsp;
import "fmt"
import "strings"
&nbsp;
func main() {
        fmt.Println(strings.Compare("aa", "ab"))
        fmt.Println(strings.Compare("aa", "aa"))
&nbsp;
        fmt.Println(strings.Compare("e", "é"))
        fmt.Println(strings.Compare("e", "ě"))
        fmt.Println(strings.Compare("ě", "é"))
&nbsp;
        fmt.Println(strings.Compare("z", "é"))
        fmt.Println(strings.Compare("z", "ě"))
&nbsp;
        fmt.Println(strings.Compare("h", "ch"))
        fmt.Println(strings.Compare("ch", "i"))
&nbsp;
        fmt.Println(strings.Compare("Hrdina", "Chocholoušek"))
        fmt.Println(strings.Compare("Crha", "Chocholoušek"))
}
</pre>

<p>S&nbsp;výsledky shodnými s&nbsp;původním céčkovým kódem:</p>

<pre>
-1
0
&nbsp;
-1
-1
1
&nbsp;
-1
-1
&nbsp;
1
-1
&nbsp;
1
1
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Porovnání řetězců na základě jazykových specifik (speciálně pro ČR)</h2>

<p>V&nbsp;případě, že budeme chtít provést zcela korektní porovnání řetězců,
které bude brát v&nbsp;úvahu všechna jazyková specifika, už si nevystačíme se
základními operátory &lt; ani s&nbsp;funkcí <strong>strings.Compare</strong>.
Namísto toho je nutné správně nastavit jazyk (Czech, Slovak atd.) a použít
funkci <strong>CompareString</strong> z&nbsp;balíčku
<strong>text/collate</strong> (ten si nainstalujete příkazem <strong>go
get</strong>). V&nbsp;následujícím demonstračním příkladu je ukázáno, že pro
jazyk <strong>language.Czech</strong> je k&nbsp;dispozici porovnání, které
například pracuje korektně se znakem &bdquo;Ch&ldquo;:</p>

<pre>
package main
&nbsp;
import "golang.org/x/text/collate"
import "golang.org/x/text/language"
import "fmt"
&nbsp;
func main() {
        cl := collate.New(language.Czech)
        fmt.Println(cl.CompareString("aa", "ab"))
        fmt.Println(cl.CompareString("aa", "aa"))
&nbsp;
        fmt.Println(cl.CompareString("e", "é"))
        fmt.Println(cl.CompareString("e", "ě"))
        fmt.Println(cl.CompareString("ě", "é"))
&nbsp;
        fmt.Println(cl.CompareString("z", "é"))
        fmt.Println(cl.CompareString("z", "ě"))
&nbsp;
        fmt.Println(cl.CompareString("h", "ch"))
        fmt.Println(cl.CompareString("ch", "i"))
&nbsp;
        fmt.Println(cl.CompareString("Hrdina", "Chocholoušek"))
        fmt.Println(cl.CompareString("Crha", "Chocholoušek"))
}
</pre>

<p>Výsledky porovnání jsem doplnil i o odpovídající kód. Hodnota -1 znamená
&bdquo;menší než&ldquo;:</p>

<pre>
-1          fmt.Println(cl.CompareString("aa", "ab"))
0           fmt.Println(cl.CompareString("aa", "aa"))
&nbsp;
-1          fmt.Println(cl.CompareString("e", "é"))
-1          fmt.Println(cl.CompareString("e", "ě"))
1           fmt.Println(cl.CompareString("ě", "é"))
&nbsp;
1           fmt.Println(cl.CompareString("z", "é"))
1           fmt.Println(cl.CompareString("z", "ě"))
&nbsp;
-1          fmt.Println(cl.CompareString("h", "ch"))
-1          fmt.Println(cl.CompareString("ch", "i"))
-1          fmt.Println(cl.CompareString("Hrdina", "Chocholoušek"))
-1          fmt.Println(cl.CompareString("Crha", "Chocholoušek"))
</pre>

<p><div class="rs-tip-major">Poznámka: pravděpodobně mnohem užitečnější je
v&nbsp;balíčku <strong>collate</strong> funkce pro seřazení řetězců. Tato
funkce opět pracuje korektně pro nastavený jazyk.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Spojení řetězců</h2>

<p>Tato kapitola bude relativně krátká, protože si v&nbsp;ní pouze ukážeme,
jakým způsobem se provede spojení řetězců v&nbsp;programovacím jazyku C a
v&nbsp;Go. V&nbsp;céčku je nutné pro nový řetězec alokovat dostatečnou kapacitu
paměti, zkontrolovat, zda se alokace podařila, zkopírovat do nově alokované
paměti první řetězec a připojit řetězec druhý. Na závěr je nutné provést i
dealokaci nového řetězce ve chvíli, kdy již není zapotřebí. Samotný zdrojový
kód je tedy relativně dlouhý a minimálně na třech místech mohou vzniknout chyby
(alokace paměti bez započtení koncové nuly, kontrola, zda alokace proběhla
v&nbsp;pořádku a dealokace paměti):</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
&nbsp;
int main(void) {
    const char *s1 = "Hello ";
    const char *s2 = "world!";
&nbsp;
    size_t length = strlen(s1) + strlen(s2) + 1;
    char *s3 = (char *)calloc(length, sizeof(char*));
&nbsp;
    if (s3) {
        strcpy(s3, s1);
        strcat(s3, s2);
&nbsp;
        puts(s3);
        free(s3);
    }
    else {
        perror("calloc() failed");
    }
&nbsp;
    return 0;
}
</pre>

<p>V&nbsp;případě programovacího jazyka Go je situace mnohem jednodušší,
protože se o veškerou správu paměti postará samotný překladač a navíc je možné
použít <a href="https://golang.org/ref/spec#Arithmetic_operators">přetížený
operátor + pro spojení řetězců</a>:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        s1 := "Hello "
        s2 := "world!"
&nbsp;
        s := s1 + s2
        fmt.Println(s)
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Získání podřetězce (ASCII znaky)</h2>

<p>V&nbsp;případě, že pracujeme pouze s&nbsp;ASCII řetězci
popř.&nbsp;s&nbsp;řetězci používajícím osmibitové znakové sady (ISO-8859-2,
Windows-1250, starobylá KOI-8 atd.), je získání podřetězce v&nbsp;programovacím
jazyku C na první pohled poměrně jednoduché:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
&nbsp;
int main(void) {
    const char *s1 = "Hello world!";
    char *s2 = (char*)calloc(4 + 2, sizeof(char*));
&nbsp;
    strncpy(s2, s1 + 0, 4);
&nbsp;
    puts(s2);
&nbsp;
    return 0;
}
</pre>

<p>V&nbsp;praxi je samozřejmě nutné opět provést kontrolu alokace, provést
dealokaci řetězce apod.:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
&nbsp;
int main(void) {
    const char *s1 = "Hello world!";
    char *s2 = (char*)calloc(4 + 2, sizeof(char*));
    // sem patří kontrola alokace!!!
    ...
&nbsp;
    strncpy(s2, s1 + 0, 4);
&nbsp;
    puts(s2);
&nbsp;
    // řetězec s2 je zapotřebí dealokovat
    ...
    return 0;
}
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;předchozím příkladu jsem schválně
použil výraz <strong>s1 + 0</strong>, protože onu zbytečnou nulu lze nahradit
indexem ASCII znaku.</div></p>

<p>V&nbsp;programovacím jazyku Go můžeme předchozí příklad implementovat
následujícím způsobem, který ovšem bude plně funkční pouze pro ASCII řetězce,
ve kterých platí, že index znaku je totožný s&nbsp;indexem příslušného
bajtu:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        s1 := "Hello world!"

        s2 := s1[0:4]
        fmt.Println(s2)
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Podřetězce a Unicode znaky</h2>

<p>Jeden z&nbsp;problémů, na které dříve či později narazí každý vývojář
začínající programovat v&nbsp;jazyku Go, je fakt, že některé operace
s&nbsp;řetězci pracují s&nbsp;celými znaky, ovšem další operace řetězce
zpracovávají jako pole bajtů. To samozřejmě způsobuje problémy, hlavně poté, co
je aplikace &bdquo;odladěna&ldquo; s&nbsp;využitím ASCII řetězců a následně se
v&nbsp;reálném provozu použijí speciální znaky (může se to zdát divné, ovšem
takové aplikace reálně vznikají). Ostatně stačí se podívat na následující
příklad, v&nbsp;němž se snažíme z&nbsp;řetězce s&nbsp;pěti znaky
(reprezentovaným polem devíti bajtů) přečíst postupně dva, tři či čtyři znaky
pomocí operátoru &bdquo;řezu&ldquo;:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        s := "шщэюя"
&nbsp;
        fmt.Println(s[2:4])
        fmt.Println(s[2:5])
        fmt.Println(s[2:6])
&nbsp;
        fmt.Println()
        fmt.Println(s[3:4])
        fmt.Println(s[3:5])
        fmt.Println(s[3:6])
}
</pre>

<p>Výsledky jsou pochopitelně špatné, zejména ve druhém případě, kdy je ze
znaku odstraněn poslední bajt a samotný kód je tedy nekorektní:</p>

<pre>
щ
щ�
щэ
</pre>

<p>V&nbsp;dalších třech případech, kdy se pokoušíme číst ze sudého bajtu,
dostaneme ještě horší výsledky, protože první přečtený bajt netvoří celý znak,
ale jen jeho část:</p>

<pre>
�
��
�э
</pre>

<p>Existuje však jedna možnost, jak pracovat s&nbsp;celými znaky uloženými
v&nbsp;řetězci. Nejdříve je nutné řetězec (sekvenci bajtů, kde každý znak
obsazuje od jednoho do čtyř znaků) převést na pole &bdquo;run&ldquo;, což jsou
hodnoty reprezentující plnohodnotný znak z&nbsp;Unicode. S&nbsp;takovým polem
je již možné pracovat plnohodnotným způsobem, tedy vytvářet z&nbsp;něj
řezy atd.:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        s := "шщэюя"
&nbsp;
        runes := []rune(s)
&nbsp;
        fmt.Println(string(runes[2:4]))
        fmt.Println(string(runes[2:5]))
        fmt.Println(string(runes[2:6]))
&nbsp;
        fmt.Println()
        fmt.Println(string(runes[3:4]))
        fmt.Println(string(runes[3:5]))
        fmt.Println(string(runes[3:6]))
}
</pre>

<p>Výsledky budou nyní ve všech případech korektní:</p>

<pre>
эю
эюя
эюя
&nbsp;
ю
юя
юя
</pre>

<p><div class="rs-tip-major">Poznámka: tento způsob se nedoporučuje používat
v&nbsp;těch případech, kdy se jedná o dlouhé řetězce popř.&nbsp;o často
prováděnou operaci, protože převod řetězce na pole run (a případný zpětný
převod na řetězec) může být časově náročný.</div></p>

<p><div class="rs-tip-major">Poznámka<sup>2</sup>: nutno říci, že
v&nbsp;některých jazycích je situace okolo řetězců (a Unicode) ještě
složitější. Například v&nbsp;Javě je nutné dbát na to, že znaky asijských
abeced jsou uloženy ve formě páru (<a
href="https://www.unicode.org/versions/Unicode12.1.0/ch03.pdf#G2630">surrogate
pairs</a>), takže některé metody (<strong>String.charAt()</strong> atd.) nemusí
vracet očekávatelné výsledky.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vytvoření polí</h2>

<p>Relativně jednoduchá situace je u polí, jen si musíme dát pozor na to, že
v&nbsp;C nejsou prvky lokálního pole inicializovány:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

int main(void) {
        int32_t a[10];
        int i;
&nbsp;
        puts("Pole pred upravou:");
        for (i=0; i&lt;10; i++) {
            printf(" %d", a[i]);
        }
        puts("\n");
&nbsp;
        for (i=0; i&lt;10; i++) {
            a[i] = i * 2;
        }
&nbsp;
        puts("Pole po uprave:");
        for (i=0; i&lt;10; i++) {
            printf(" %d", a[i]);
        }
        return 0;
}
</pre>

<p>Původní obsah pole je z&nbsp;hlediska programátora náhodný:</p>

<pre>
Pole pred upravou:
 -1332340384 32764 0 0 4195888 0 4195472 0 -1332340160 32764
&nbsp;
Pole po uprave:
 0 2 4 6 8 10 12 14 16 18
</pre>

<p>Standard jazyka C ovšem inicializaci prvků umožňuje, pouze ho musíme
explicitně zapsat (viz zvýrazněný kód):</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
&nbsp;
int main(void) {
        int32_t a[10] = <strong>{0}</strong>;
        int i;
&nbsp;
        puts("Pole pred upravou:");
        for (i=0; i&lt;10; i++) {
            printf(" %d", a[i]);
        }
        puts("\n");
&nbsp;
        for (i=0; i&lt;10; i++) {
            a[i] = i * 2;
        }
&nbsp;
        puts("Pole po uprave:");
        for (i=0; i&lt;10; i++) {
            printf(" %d", a[i]);
        }
        return 0;
}
</pre>

<p>Výsledek:</p>

<pre>
Pole pred upravou:
 0 0 0 0 0 0 0 0 0 0
&nbsp;
Pole po uprave:
 0 2 4 6 8 10 12 14 16 18
</pre>

<p>V&nbsp;jazyce Go jsou i prvky lokálního pole automaticky inicializovány na
<i>nulovou hodnotu</i> (podle příslušného datového typu):</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a1 [10]byte
        var a2 [10]int32
        a3 := [10]int32{1, 10, 2, 9, 3, 8, 4, 7, 5, 6}
&nbsp;
        fmt.Printf("Delka pole 1: %d\n", len(a1))
        fmt.Printf("Delka pole 2: %d\n", len(a2))
        fmt.Printf("Delka pole 3: %d\n", len(a3))
&nbsp;
        var a [10]int
&nbsp;
        fmt.Printf("Pole pred upravou: %v\n", a)
&nbsp;
        for i := 0; i &lt; len(a1); i++ {
                a[i] = i * 2
        }
&nbsp;
        fmt.Printf("Pole po uprave:    %v\n", a)
&nbsp;
        var matice [10][10]float32
        fmt.Printf("Matice:    %v\n", matice)
}
</pre>

<p>Výsledky vypsané příkladem:</p>

<pre>
Delka pole 1: 10
Delka pole 2: 10
Delka pole 3: 10
Pole pred upravou: [0 0 0 0 0 0 0 0 0 0]
Pole po uprave:    [0 2 4 6 8 10 12 14 16 18]
Matice:    [[0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0]]
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Kopie polí</h2>

<p>V&nbsp;další krátké kapitole si jen připomeňme, že pole lze v&nbsp;jazyce Go
kopírovat, takže vznikne pole nové, nezávislé na poli původním:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a1 [10]int
&nbsp;
        a2 := a1
&nbsp;
        fmt.Printf("Pole 1: %v\n", a1)
        fmt.Printf("Pole 2: %v\n", a2)
&nbsp;
        for i := 0; i &lt; len(a1); i++ {
                a1[i] = i * 2
        }
&nbsp;
        fmt.Printf("Pole 1: %v\n", a1)
        fmt.Printf("Pole 2: %v\n", a2)
}
</pre>

<p>O tom, že modifikováno bylo jen původní pole a nikoli (i) jeho kopie, se lze
snadno přesvědčit:</p>

<pre>
Pole 1: [0 0 0 0 0 0 0 0 0 0]
Pole 2: [0 0 0 0 0 0 0 0 0 0]
Pole 1: [0 2 4 6 8 10 12 14 16 18]
Pole 2: [0 0 0 0 0 0 0 0 0 0]
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Vícerozměrná pole</h2>

<p>Zastavme se na chvíli u následujícího příkladu, který sice může vypadat
uměle, ale s&nbsp;podobným konceptem se můžete setkat například
v&nbsp;algoritmech pro práci s&nbsp;bitmapami atd. V&nbsp;příkladu je vytvořeno
dvourozměrné pole 4&times;3 prvky a toto pole je modifikováno tak, že se mění
pouze spodní index (horní je nulový). Překladač tak může vygenerovat jednodušší
kód. Využívá se zde (přesně definované) vlastnosti polí: řádky jsou
v&nbsp;paměti umístěny za sebou bez výplně:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
&nbsp;
int main(void) {
    int a[3][4];
    int i, j;
&nbsp;
    puts("Pole pred upravou:");
    for (j=0; j&lt;3; j++) {
        for (i=0; i&lt;4; i++) {
            printf(" %2d", a[j][i]);
        }
        putchar('\n');
    }
    puts("\n");
&nbsp;
    for (i=0; i&lt;12; i++) {
        a[0][i] = i;
    }
&nbsp;
    puts("Pole po uprave:");
    for (j=0; j&lt;3; j++) {
        for (i=0; i&lt;4; i++) {
            printf(" %2d", a[j][i]);
        }
        putchar('\n');
    }
    return 0;
}
</pre>

<p>Příklad bude v&nbsp;C plně funkční:</p>

<pre>
Pole pred upravou:
  1  0 4196029  0
 -908827577 32764  0  0
 4195952  0 4195472  0
&nbsp;
&nbsp;
Pole po uprave:
  0  1  2  3
  4  5  6  7
  8  9 10 11
</pre>

<p>V&nbsp;jazyce Go ovšem tento algoritmus pracovat nebude, protože se meze
indexů polí pro všechny dimenze kontroluje:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var a [3][4]int
&nbsp;
        fmt.Printf("Pole pred upravou: %v\n", a)
&nbsp;
        for i := 0; i &lt; 12; i++ {
                a[0][i] = i
        }
&nbsp;
        fmt.Printf("Pole po uprave:    %v\n", a)
}
</pre>

<p>Po spuštění příkladu dojde k&nbsp;běhové chybě:</p>

<pre>
panic: runtime error: index out of range [4] with length 4
&nbsp;
goroutine 1 [running]:
main.main()
        /home/tester/go-root/article_35/10_arrays_C.go:11 +0x1f3
</pre>

<p><div class="rs-tip-major">Poznámka: to znamená, že ne všechny algoritmy je
možné snadno a bez přemýšlení přepsat z&nbsp;C do Go.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Realokace polí resp.&nbsp;použití řezů</h2>

<p>Za připomenutí stojí, že v&nbsp;programovacím jazyce Go se většinou můžeme
vyhnout ručnímu (resp.&nbsp;přesněji řečeno explicitnímu) realokování pole,
protože namísto (poměrně rigidních) polí lze využít řezy (<i>slices</i>) a
funkci <strong>append</strong>, která do řezu přidá další prvek či prvky a
v&nbsp;případě potřeby pole, nad nímž je řez postaven, realokuje
automaticky:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var s0 []int
        s1 := []int{}
        s2 := make([]int, 0)
        s3 := make([]int, 10)
&nbsp;
        fmt.Println(s0)
        fmt.Println(s1)
        fmt.Println(s2)
        fmt.Println(s3)
&nbsp;
        fmt.Println()
&nbsp;
        s0 = append(s0, 1, 2, 3)
        s1 = append(s1, 1, 2, 3)
        s2 = append(s2, 1, 2, 3)
        s3 = append(s3, 1, 2, 3)
&nbsp;
        fmt.Println(s0)
        fmt.Println(s1)
        fmt.Println(s2)
        fmt.Println(s3)
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Sledování kapacity řezu při realokacích polí</h2>

<p>To, jakým způsobem realokace probíhá, je řešeno interním algoritmem, který
ovšem můžeme sledovat čtením <i>kapacity</i> řezu:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var slice []int
&nbsp;
        for i := 1; i &lt; 11; i++ {
                slice = append(slice, i)
                fmt.Printf("Slice:          %v\n", slice)
                fmt.Printf("Slice length:   %d\n", len(slice))
                fmt.Printf("Slice capacity: %d\n\n", cap(slice))
        }
}
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
Slice:          [1]
Slice length:   1
Slice capacity: 1
&nbsp;
Slice:          [1 2]
Slice length:   2
Slice capacity: 2
&nbsp;
Slice:          [1 2 3]
Slice length:   3
Slice capacity: 4
&nbsp;
Slice:          [1 2 3 4]
Slice length:   4
Slice capacity: 4
&nbsp;
Slice:          [1 2 3 4 5]
Slice length:   5
Slice capacity: 8
&nbsp;
Slice:          [1 2 3 4 5 6]
Slice length:   6
Slice capacity: 8
&nbsp;
Slice:          [1 2 3 4 5 6 7]
Slice length:   7
Slice capacity: 8
&nbsp;
Slice:          [1 2 3 4 5 6 7 8]
Slice length:   8
Slice capacity: 8
&nbsp;
Slice:          [1 2 3 4 5 6 7 8 9]
Slice length:   9
Slice capacity: 16
&nbsp;
Slice:          [1 2 3 4 5 6 7 8 9 10]
Slice length:   10
Slice capacity: 16
</pre>

<p><div class="rs-tip-major">Poznámka: můžeme vidět, že v&nbsp;současnosti
používaný algoritmus vždy zdvojnásobí kapacitu pole, které slouží jako datová
základna pro řez.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Práce se soubory (základní vstupně-výstupní operace)</h2>

<p>Vzhledem k&nbsp;tomu, že se základní knihovny pro I/O operace v&nbsp;jazyku
C a Go velmi odlišují, bude zcela odlišné například načítání dat ze souborů,
jejich ukládání, práce s&nbsp;bloky atd.</p>

<p>Prozatím byla většina kódů psaná v&nbsp;Go v&nbsp;porovnání s&nbsp;C kratší,
ovšem například při čtení ze souboru znak po znaku (přesněji bajt po bajtu)
bude céčková varianta nepatrně kratší díky tomu, že lze použít funkce
<strong>fgetc</strong>:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
&nbsp;
const char* filename = "test_input.txt";
&nbsp;

int main(void) {
    FILE *fin = fopen(filename, "r");
    if (!fin) {
        perror("Can not open file");
        return 1;
    }
    char c;
    while ((c=fgetc(fin)) != EOF) {
        printf("%02d ", c);
    }
    fclose(fin);

    return 0;
}
</pre>

<p>Výsledky (kódy jednotlivých znaků):</p>

<pre>
108 105 110 101 32 35 49 10 108 105 110 101 32 35 50 10 108 105 110 101 32 35 51 10 108 105 110 101 32 35 52 10 108 105 110 101 32 35 53 10
</pre>

<p>V&nbsp;Go namísto toho můžeme použít čtení po celých blocích, ovšem velikost
bloku omezíme na jediný bajt:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "io"
        "log"
        "os"
)
&nbsp;
const filename = "test_input.txt"
&nbsp;
func main() {
        fin, err := os.Open(filename)
        if err != nil {
                log.Fatal(err)
        }
        defer fin.Close()
&nbsp;
        buffer := make([]byte, 1)
&nbsp;
        for {
                read, err := fin.Read(buffer)
&nbsp;
                if read &gt; 0 {
                        fmt.Printf("byte from file\n")
                        fmt.Println(buffer[0])
                } else {
                        fmt.Println("empty block (end of file?)")
                }

&nbsp;
                if err == io.EOF {
                        fmt.Println("reached end of file")
                        break
                }
&nbsp;
                if err != nil {
                        fmt.Printf("other error %v\n", err)
                        break
                }
        }
}
</pre>

<p>Výsledky:</p>

<pre>
byte from file
108
byte from file
105
...
...
...
byte from file
10
empty block (end of file?)
reached end of file
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Čtení či zápis po blocích</h2>

<p>V&nbsp;předchozí kapitole jsme si vlastně ukázali i způsob načítání dat ze
souborů po blocích. V&nbsp;céčku se může jednat například o toto řešení (blok
má kapacitu šestnácti bajtů):</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
const char* filename = "test_input.txt";
const int BLOCK_SIZE = 16;
&nbsp;
int main(void) {
    FILE *fin = fopen(filename, "r");
    if (!fin) {
        perror("Can not open file");
        return 1;
    }
&nbsp;
    char buffer[BLOCK_SIZE];
    while (1) {
        size_t read = fread(buffer, sizeof(char), BLOCK_SIZE, fin);
        if (read &gt; 0) {
            int i;
            printf("read %ld bytes\n", read);
            for (i=0; i&lt;read; i++) {
                printf("%d ", buffer[i]);
            }
            putchar('\n');
        }
        else {
            puts("reached end of file");
            break;
        }
    }
    fclose(fin);
&nbsp;
    return 0;
}
</pre>

<p>Výsledky čtení dat po blocích o kapacitě šestnácti bajtů:</p>

<pre>
read 16 bytes
108 105 110 101 32 35 49 10 108 105 110 101 32 35 50 10 
read 16 bytes
108 105 110 101 32 35 51 10 108 105 110 101 32 35 52 10 
read 8 bytes
108 105 110 101 32 35 53 10 
reached end of file
</pre>

<p>Naproti tomu v&nbsp;jazyce Go postačuje vzít příklad z&nbsp;předchozí
kapitoly a zvýšit kapacitu bufferu:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "io"
        "log"
        "os"
)
&nbsp;
const filename = "test_input.txt"
const buffer_size = 16
&nbsp;
func main() {
        fin, err := os.Open(filename)
        if err != nil {
                log.Fatal(err)
        }
        defer fin.Close()
&nbsp;
        buffer := make([]byte, buffer_size)
&nbsp;
        for {
                read, err := fin.Read(buffer)
&nbsp;
                if read &gt; 0 {
                        fmt.Printf("read %d bytes\n", read)
                        fmt.Println(buffer[:read])
                }
&nbsp;
                if err == io.EOF {
                        fmt.Println("reached end of file")
                        break
                }
&nbsp;
                if err != nil {
                        fmt.Printf("other error %v\n", err)
                        break
                }
        }
}
</pre>

<p>Výsledky jsou prakticky totožné s&nbsp;céčkovým příkladem (pouze prvky pole
se vypisují v&nbsp;hranatých závorkách):</p>

<pre>
read 16 bytes
[108 105 110 101 32 35 49 10 108 105 110 101 32 35 50 10]
read 16 bytes
[108 105 110 101 32 35 51 10 108 105 110 101 32 35 52 10]
read 8 bytes
[108 105 110 101 32 35 53 10]
reached end of file
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Zpracování chyb, reakce na chyby</h2>

<p>Jak klasické céčko, tak i programovací jazyk Go pracují s&nbsp;chybovými
stavy podobným způsobem, alespoň na první pohled. Informace o chybě je vrácena
volající funkci, která musí vzniklou situaci nějakým způsobem vyřešit. Ovšem
v&nbsp;céčku právě zde narážíme na omezení programovacího jazyka, protože
z&nbsp;funkce lze vrátit pouze jedinou hodnotu. Tato situace se řeší různými
způsoby, které však jen málokdy bývají zcela vyhovující. Například je možné
vracet obvyklou hodnotu (řekněme znak načtený ze standardního vstupu)
popř.&nbsp;speciální hodnotu při chybě. Nebo se při chybě nastaví globální
proměnná <strong>errno</strong> (což ovšem přináší další problémy &ndash; co se
má stát při výskytu více chyb, jak se s&nbsp;proměnnou pracuje ve více vláknech
atd. atd.). Popř.&nbsp;funkce vrací jen informaci o chybě a skutečné hodnoty se
vrací odkazem přes nějaký parametr.</p>

<p>V&nbsp;jazyce Go je situace mnohem lepší, protože z&nbsp;funkce lze vrátit
libovolný počet hodnot a existuje úzus, že poslední hodnotou bývá právě
informace o případné chybě, která ve volané funkci nastala. Nejedná se přitom
jen o rozlišení &bdquo;chyba nastala&ldquo; versus &bdquo;chyba
nenastala&ldquo;, protože samotná chyba je představována plnohodnotným
objektem, který může nést i další užitečné informace &ndash; vznik chyby,
chybovou zprávu, chybový kód atd. Typický příklad reakce na chybu by se
v&nbsp;jazyce Go napsal způsobem, který jsme již viděli v&nbsp;předchozích dvou
kapitolách:</p>

<pre>
fin, err := os.Open(filename)
if err != nil {
        log.Fatal(err)
}
</pre>

<p><div class="rs-tip-major">Poznámka: pokud funkce vrací více hodnot a
současně i informaci o chybě, je vhodné, aby informace o chybě byla poslední
návratovou hodnotou funkce.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně tři megabajty), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_booleans.c</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/01_booleans.c">https://github.com/tisnik/go-root/blob/master/article_35/01_booleans.c</a></td></tr>
<tr><td> 1</td><td>01_booleans.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/01_booleans.go">https://github.com/tisnik/go-root/blob/master/article_35/01_booleans.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>02_boolean_type_checks.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/02_boolean_type_checks.go">https://github.com/tisnik/go-root/blob/master/article_35/02_boolean_type_checks.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>03_strings.c</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/03_strings.c">https://github.com/tisnik/go-root/blob/master/article_35/03_strings.c</a></td></tr>
<tr><td> 3</td><td>03_strings.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/03_strings.go">https://github.com/tisnik/go-root/blob/master/article_35/03_strings.go</a></td></tr>
<tr><td> 3</td><td>03_strings_B.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/03_strings_B.go">https://github.com/tisnik/go-root/blob/master/article_35/03_strings_B.go</a></td></tr>
<tr><td> 3</td><td>03_strings.s</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/03_strings.s">https://github.com/tisnik/go-root/blob/master/article_35/03_strings.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>04_immutable_strings.c</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/04_immutable_strings.c">https://github.com/tisnik/go-root/blob/master/article_35/04_immutable_strings.c</a></td></tr>
<tr><td> 4</td><td>04_immutable_strings.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/04_immutable_strings.go">https://github.com/tisnik/go-root/blob/master/article_35/04_immutable_strings.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>05_mutable_strings.c</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/05_mutable_strings.c">https://github.com/tisnik/go-root/blob/master/article_35/05_mutable_strings.c</a></td></tr>
<tr><td> 5</td><td>05_mutable_strings.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/05_mutable_strings.go">https://github.com/tisnik/go-root/blob/master/article_35/05_mutable_strings.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>06_mutable_utf8_strings.c</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/06_mutable_utf8_strings.c">https://github.com/tisnik/go-root/blob/master/article_35/06_mutable_utf8_strings.c</a></td></tr>
<tr><td> 6</td><td>06_mutable_utf8_strings.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/06_mutable_utf8_strings.go">https://github.com/tisnik/go-root/blob/master/article_35/06_mutable_utf8_strings.go</a></td></tr>
<tr><td> 6</td><td>06_mutable_utf8_strings_B.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/06_mutable_utf8_strings_B.go">https://github.com/tisnik/go-root/blob/master/article_35/06_mutable_utf8_strings_B.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>07_string_comparison.c</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/07_string_comparison.c">https://github.com/tisnik/go-root/blob/master/article_35/07_string_comparison.c</a></td></tr>
<tr><td> 7</td><td>07_string_comparison.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/07_string_comparison.go">https://github.com/tisnik/go-root/blob/master/article_35/07_string_comparison.go</a></td></tr>
<tr><td> 7</td><td>07_string_comparison_B.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/07_string_comparison_B.go">https://github.com/tisnik/go-root/blob/master/article_35/07_string_comparison_B.go</a></td></tr>
<tr><td> 7</td><td>07_string_comparison_C.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/07_string_comparison_C.go">https://github.com/tisnik/go-root/blob/master/article_35/07_string_comparison_C.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>08_string_concatenation.c</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/08_string_concatenation.c">https://github.com/tisnik/go-root/blob/master/article_35/08_string_concatenation.c</a></td></tr>
<tr><td> 8</td><td>08_string_concatenation.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/08_string_concatenation.go">https://github.com/tisnik/go-root/blob/master/article_35/08_string_concatenation.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>09_substring.c</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/09_substring.c">https://github.com/tisnik/go-root/blob/master/article_35/09_substring.c</a></td></tr>
<tr><td> 9</td><td>09_substring.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/09_substring.go">https://github.com/tisnik/go-root/blob/master/article_35/09_substring.go</a></td></tr>
<tr><td> 9</td><td>09_substring_B.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/09_substring_B.go">https://github.com/tisnik/go-root/blob/master/article_35/09_substring_B.go</a></td></tr>
<tr><td> 9</td><td>09_substring_C.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/09_substring_C.go">https://github.com/tisnik/go-root/blob/master/article_35/09_substring_C.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>10_arrays.c</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/10_arrays.c">https://github.com/tisnik/go-root/blob/master/article_35/10_arrays.c</a></td></tr>
<tr><td>10</td><td>10_arrays_B.c</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/10_arrays_B.c">https://github.com/tisnik/go-root/blob/master/article_35/10_arrays_B.c</a></td></tr>
<tr><td>10</td><td>10_arrays_C.c</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/10_arrays_C.c">https://github.com/tisnik/go-root/blob/master/article_35/10_arrays_C.c</a></td></tr>
<tr><td>10</td><td>10_arrays.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/10_arrays.go">https://github.com/tisnik/go-root/blob/master/article_35/10_arrays.go</a></td></tr>
<tr><td>10</td><td>10_arrays_C.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/10_arrays_C.go">https://github.com/tisnik/go-root/blob/master/article_35/10_arrays_C.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>11_array_copy.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/11_array_copy.go">https://github.com/tisnik/go-root/blob/master/article_35/11_array_copy.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>12_read_byte.c</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/12_read_byte.c">https://github.com/tisnik/go-root/blob/master/article_35/12_read_byte.c</a></td></tr>
<tr><td>12</td><td>12_io_reader_read_byte.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/12_io_reader_read_byte.go">https://github.com/tisnik/go-root/blob/master/article_35/12_io_reader_read_byte.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>13_read_ascii_char.c</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/13_read_ascii_char.c">https://github.com/tisnik/go-root/blob/master/article_35/13_read_ascii_char.c</a></td></tr>
<tr><td>13</td><td>13_io_reader_read_ascii_char.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/13_io_reader_read_ascii_char.go">https://github.com/tisnik/go-root/blob/master/article_35/13_io_reader_read_ascii_char.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>14_read_block.c</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/14_read_block.c">https://github.com/tisnik/go-root/blob/master/article_35/14_read_block.c</a></td></tr>
<tr><td>14</td><td>14_io_reader_read_block.go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_35/14_io_reader_read_block.go">https://github.com/tisnik/go-root/blob/master/article_35/14_io_reader_read_block.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Semantic Import Versioning in Go<br />
<a href="https://www.aaronzhuo.com/semantic-import-versioning-in-go/">https://www.aaronzhuo.com/semantic-import-versioning-in-go/</a>
</li>

<li>Sémantické verzování<br />
<a href="https://semver.org/">https://semver.org/</a>
</li>

<li>Getting started with Go modules<br />
<a href="https://medium.com/@fonseka.live/getting-started-with-go-modules-b3dac652066d">https://medium.com/@fonseka.live/getting-started-with-go-modules-b3dac652066d</a>
</li>

<li>Create projects independent of $GOPATH using Go Modules<br />
<a href="https://medium.com/mindorks/create-projects-independent-of-gopath-using-go-modules-802260cdfb51o">https://medium.com/mindorks/create-projects-independent-of-gopath-using-go-modules-802260cdfb51o</a>
</li>

<li>Anatomy of Modules in Go<br />
<a href="https://medium.com/rungo/anatomy-of-modules-in-go-c8274d215c16">https://medium.com/rungo/anatomy-of-modules-in-go-c8274d215c16</a>
</li>

<li>Modules<br />
<a href="https://github.com/golang/go/wiki/Modules">https://github.com/golang/go/wiki/Modules</a>
</li>

<li>Go Modules Tutorial<br />
<a href="https://tutorialedge.net/golang/go-modules-tutorial/">https://tutorialedge.net/golang/go-modules-tutorial/</a>
</li>

<li>Module support<br />
<a href="https://golang.org/cmd/go/#hdr-Module_support">https://golang.org/cmd/go/#hdr-Module_support</a>
</li>

<li>Go Lang: Memory Management and Garbage Collection<br />
<a href="https://vikash1976.wordpress.com/2017/03/26/go-lang-memory-management-and-garbage-collection/">https://vikash1976.wordpress.com/2017/03/26/go-lang-memory-management-and-garbage-collection/</a>
</li>

<li>Golang Internals, Part 4: Object Files and Function Metadata<br />
<a href="https://blog.altoros.com/golang-part-4-object-files-and-function-metadata.html">https://blog.altoros.com/golang-part-4-object-files-and-function-metadata.html</a>
</li>

<li>What is REPL?<br />
<a href="https://pythonprogramminglanguage.com/repl/">https://pythonprogramminglanguage.com/repl/</a>
</li>

<li>What is a REPL?<br />
<a href="https://codewith.mu/en/tutorials/1.0/repl">https://codewith.mu/en/tutorials/1.0/repl</a>
</li>

<li>Programming at the REPL: Introduction<br />
<a href="https://clojure.org/guides/repl/introduction">https://clojure.org/guides/repl/introduction</a>
</li>

<li>What is REPL? (Quora)<br />
<a href="https://www.quora.com/What-is-REPL">https://www.quora.com/What-is-REPL</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Read-eval-print loop (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>Vim as a Go (Golang) IDE using LSP and vim-go<br />
<a href="https://octetz.com/posts/vim-as-go-ide">https://octetz.com/posts/vim-as-go-ide</a>
</li>

<li>gopls<br />
<a href="https://github.com/golang/go/wiki/gopls">https://github.com/golang/go/wiki/gopls</a>
</li>

<li>IDE Integration Guide<br />
<a href="https://github.com/stamblerre/gocode/blob/master/docs/IDE_integration.md">https://github.com/stamblerre/gocode/blob/master/docs/IDE_integration.md</a>
</li>

<li>How to instrument Go code with custom expvar metrics<br />
<a href="https://sysdig.com/blog/golang-expvar-custom-metrics/">https://sysdig.com/blog/golang-expvar-custom-metrics/</a>
</li>

<li>Golang expvar metricset (Metricbeat Reference)<br />
<a href="https://www.elastic.co/guide/en/beats/metricbeat/7.x/metricbeat-metricset-golang-expvar.html">https://www.elastic.co/guide/en/beats/metricbeat/7.x/metricbeat-metricset-golang-expvar.html</a>
</li>

<li>Package expvar<br />
<a href="https://golang.org/pkg/expvar/#NewInt">https://golang.org/pkg/expvar/#NewInt</a>
</li>

<li>Java Platform Debugger Architecture: Overview<br />
<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jpda/jpda.html">https://docs.oracle.com/en/java/javase/11/docs/specs/jpda/jpda.html</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="https://www.oracle.com/technetwork/articles/javase/index-140680.html">https://www.oracle.com/technetwork/articles/javase/index-140680.html</a>
</li>

<li>JVM Tool Interface Version 11.0<br />
<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html">https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>Go &amp; cgo: integrating existing C code with Go<br />
<a href="http://akrennmair.github.io/golang-cgo-slides/#1">http://akrennmair.github.io/golang-cgo-slides/#1</a>
</li>

<li>Using cgo to call C code from within Go code<br />
<a href="https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/">https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/</a>
</li>

<li>Package trace<br />
<a href="https://golang.org/pkg/runtime/trace/">https://golang.org/pkg/runtime/trace/</a>
</li>

<li>Introducing HTTP Tracing<br />
<a href="https://blog.golang.org/http-tracing">https://blog.golang.org/http-tracing</a>
</li>

<li>Command trace<br />
<a href="https://golang.org/cmd/trace/">https://golang.org/cmd/trace/</a>
</li>

<li>A StreamLike, Immutable, Lazy Loading and smart Golang Library to deal with slices<br />
<a href="https://github.com/wesovilabs/koazee">https://github.com/wesovilabs/koazee</a>
</li>

<li>Funkce vyššího řádu v knihovně Underscore<br />
<a href="https://www.root.cz/clanky/funkce-vyssiho-radu-v-knihovne-underscore/">https://www.root.cz/clanky/funkce-vyssiho-radu-v-knihovne-underscore/</a>
</li>

<li>Delve: a debugger for the Go programming language.<br />
<a href="https://github.com/go-delve/delve">https://github.com/go-delve/delve</a>
</li>

<li>Příkazy debuggeru Delve<br />
<a href="https://github.com/go-delve/delve/tree/master/Documentation/cli">https://github.com/go-delve/delve/tree/master/Documentation/cli</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (2. část)<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v&nbsp;editorech Emacs a Vim<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Debugging Go Code with GDB<br />
<a href="https://golang.org/doc/gdb">https://golang.org/doc/gdb</a>
</li>

<li>Debugging Go (golang) programs with gdb <br />
<a href="https://thornydev.blogspot.com/2014/01/debugging-go-golang-programs-with-gdb.html">https://thornydev.blogspot.com/2014/01/debugging-go-golang-programs-with-gdb.html</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>GDB - Supported Languages<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>13 Linux Debuggers for C++ Reviewed<br />
<a href="http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817">http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817</a>
</li>

<li>Go is on a Trajectory to Become the Next Enterprise Programming Language<br />
<a href="https://hackernoon.com/go-is-on-a-trajectory-to-become-the-next-enterprise-programming-language-3b75d70544e">https://hackernoon.com/go-is-on-a-trajectory-to-become-the-next-enterprise-programming-language-3b75d70544e</a>
</li>

<li>Go Proverbs: Simple, Poetic, Pithy<br />
<a href="https://go-proverbs.github.io/">https://go-proverbs.github.io/</a>
</li>

<li>Handling Sparse Files on Linux<br />
<a href="https://www.systutorials.com/136652/handling-sparse-files-on-linux/">https://www.systutorials.com/136652/handling-sparse-files-on-linux/</a>
</li>

<li>Gzip (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Gzip">https://en.wikipedia.org/wiki/Gzip</a>
</li>

<li>Deflate<br />
<a href="https://en.wikipedia.org/wiki/DEFLATE">https://en.wikipedia.org/wiki/DEFLATE</a>
</li>

<li>10 tools written in Go that every developer needs to know<br />
<a href="https://gustavohenrique.net/en/2019/01/10-tools-written-in-go-that-every-dev-needs-to-know/">https://gustavohenrique.net/en/2019/01/10-tools-written-in-go-that-every-dev-needs-to-know/</a>
</li>

<li>Hexadecimální prohlížeče a editory s textovým uživatelským rozhraním<br />
<a href="https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/">https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/</a>
</li>

<li>Hex dump<br />
<a href="https://en.wikipedia.org/wiki/Hex_dump">https://en.wikipedia.org/wiki/Hex_dump</a>
</li>

<li>Rozhraní io.ByteReader<br />
<a href="https://golang.org/pkg/io/#ByteReader">https://golang.org/pkg/io/#ByteReader</a>
</li>

<li>Rozhraní io.RuneReader<br />
<a href="https://golang.org/pkg/io/#RuneReader">https://golang.org/pkg/io/#RuneReader</a>
</li>

<li>Rozhraní io.ByteScanner<br />
<a href="https://golang.org/pkg/io/#ByteScanner">https://golang.org/pkg/io/#ByteScanner</a>
</li>

<li>Rozhraní io.RuneScanner<br />
<a href="https://golang.org/pkg/io/#RuneScanner">https://golang.org/pkg/io/#RuneScanner</a>
</li>

<li>Rozhraní io.Closer<br />
<a href="https://golang.org/pkg/io/#Closer">https://golang.org/pkg/io/#Closer</a>
</li>

<li>Rozhraní io.Reader<br />
<a href="https://golang.org/pkg/io/#Reader">https://golang.org/pkg/io/#Reader</a>
</li>

<li>Rozhraní io.Writer<br />
<a href="https://golang.org/pkg/io/#Writer">https://golang.org/pkg/io/#Writer</a>
</li>

<li>Typ Strings.Reader<br />
<a href="https://golang.org/pkg/strings/#Reader">https://golang.org/pkg/strings/#Reader</a>
</li>

<li>VACUUM (SQL)<br />
<a href="https://www.sqlite.org/lang_vacuum.html">https://www.sqlite.org/lang_vacuum.html</a>
</li>

<li>VACUUM (Postgres)<br />
<a href="https://www.postgresql.org/docs/8.4/sql-vacuum.html">https://www.postgresql.org/docs/8.4/sql-vacuum.html</a>
</li>

<li>go-cron<br />
<a href="https://github.com/rk/go-cron">https://github.com/rk/go-cron</a>
</li>

<li>gocron<br />
<a href="https://github.com/jasonlvhit/gocron">https://github.com/jasonlvhit/gocron</a>
</li>

<li>clockwork<br />
<a href="https://github.com/whiteShtef/clockwork">https://github.com/whiteShtef/clockwork</a>
</li>

<li>clockwerk<br />
<a href="https://github.com/onatm/clockwerk">https://github.com/onatm/clockwerk</a>
</li>

<li>JobRunner<br />
<a href="https://github.com/bamzi/jobrunner">https://github.com/bamzi/jobrunner</a>
</li>

<li>Rethinking Cron<br />
<a href="https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/">https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/</a>
</li>

<li>In the Beginning was the Command Line<br />
<a href="https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html">https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html</a>
</li>

<li>repl.it (REPL pro různé jazyky)<br />
<a href="https://repl.it/languages">https://repl.it/languages</a>
</li>

<li>GOCUI - Go Console User Interface (celé uživatelské prostředí, nejenom input box)<br />
<a href="https://github.com/jroimartin/gocui">https://github.com/jroimartin/gocui</a>
</li>

<li>Read–eval–print loop<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>go-prompt<br />
<a href="https://github.com/c-bata/go-prompt">https://github.com/c-bata/go-prompt</a>
</li>

<li>readline<br />
<a href="https://github.com/chzyer/readline">https://github.com/chzyer/readline</a>
</li>

<li>A pure golang implementation for GNU-Readline kind library<br />
<a href="https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/">https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/</a>
</li>

<li>go-readline<br />
<a href="https://github.com/fiorix/go-readline">https://github.com/fiorix/go-readline</a>
</li>

<li>4 Python libraries for building great command-line user interfaces<br />
<a href="https://opensource.com/article/17/5/4-practical-python-libraries">https://opensource.com/article/17/5/4-practical-python-libraries</a>
</li>

<li>prompt_toolkit 2.0.3 na PyPi<br />
<a href="https://pypi.org/project/prompt_toolkit/">https://pypi.org/project/prompt_toolkit/</a>
</li>

<li>python-prompt-toolkit na GitHubu<br />
<a href="https://github.com/jonathanslenders/python-prompt-toolkit">https://github.com/jonathanslenders/python-prompt-toolkit</a>
</li>

<li>The GNU Readline Library<br />
<a href="https://tiswww.case.edu/php/chet/readline/rltop.html">https://tiswww.case.edu/php/chet/readline/rltop.html</a>
</li>

<li>GNU Readline (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Readline">https://en.wikipedia.org/wiki/GNU_Readline</a>
</li>

<li>readline — GNU readline interface (Python 3.x)<br />
<a href="https://docs.python.org/3/library/readline.html">https://docs.python.org/3/library/readline.html</a>
</li>

<li>readline — GNU readline interface (Python 2.x)<br />
<a href="https://docs.python.org/2/library/readline.html">https://docs.python.org/2/library/readline.html</a>
</li>

<li>GNU Readline Library - command line editing<br />
<a href="https://tiswww.cwru.edu/php/chet/readline/readline.html">https://tiswww.cwru.edu/php/chet/readline/readline.html</a>
</li>

<li>gnureadline 6.3.8 na PyPi<br />
<a href="https://pypi.org/project/gnureadline/">https://pypi.org/project/gnureadline/</a>
</li>

<li>Editline Library (libedit)<br />
<a href="http://thrysoee.dk/editline/">http://thrysoee.dk/editline/</a>
</li>

<li>Comparing Python Command-Line Parsing Libraries – Argparse, Docopt, and Click<br />
<a href="https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/">https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/</a>
</li>

<li>libedit or editline<br />
<a href="http://www.cs.utah.edu/~bigler/code/libedit.html">http://www.cs.utah.edu/~bigler/code/libedit.html</a>
</li>

<li>WinEditLine<br />
<a href="http://mingweditline.sourceforge.net/">http://mingweditline.sourceforge.net/</a>
</li>

<li>rlcompleter — Completion function for GNU readline<br />
<a href="https://docs.python.org/3/library/rlcompleter.html">https://docs.python.org/3/library/rlcompleter.html</a>
</li>

<li>rlwrap na GitHubu<br />
<a href="https://github.com/hanslub42/rlwrap">https://github.com/hanslub42/rlwrap</a>
</li>

<li>rlwrap(1) - Linux man page<br />
<a href="https://linux.die.net/man/1/rlwrap">https://linux.die.net/man/1/rlwrap</a>
</li>

<li>readline(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/readline">https://linux.die.net/man/3/readline</a>
</li>

<li>history(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/history">https://linux.die.net/man/3/history</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>oglematchers</i><br />
<a href="https://godoc.org/github.com/jacobsa/oglematchers">https://godoc.org/github.com/jacobsa/oglematchers</a>
</li>

<li>Balíček <i>oglematchers</i><br />
<a href="https://github.com/jacobsa/oglematchers">https://github.com/jacobsa/oglematchers</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>ogletest</i><br />
<a href="https://godoc.org/github.com/jacobsa/ogletest">https://godoc.org/github.com/jacobsa/ogletest</a>
</li>

<li>Balíček <i>ogletest</i><br />
<a href="https://github.com/jacobsa/ogletest">https://github.com/jacobsa/ogletest</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>assert</i><br />
<a href="https://godoc.org/github.com/stretchr/testify/assert">https://godoc.org/github.com/stretchr/testify/assert</a>
</li>

<li>Testify - Thou Shalt Write Tests<br />
<a href="https://github.com/stretchr/testify/">https://github.com/stretchr/testify/</a>
</li>

<li>package testing<br />
<a href="https://golang.org/pkg/testing/">https://golang.org/pkg/testing/</a>
</li>

<li>Golang basics - writing unit tests<br />
<a href="https://blog.alexellis.io/golang-writing-unit-tests/">https://blog.alexellis.io/golang-writing-unit-tests/</a>
</li>

<li>An Introduction to Programming in Go / Testing<br />
<a href="https://www.golang-book.com/books/intro/12">https://www.golang-book.com/books/intro/12</a>
</li>

<li>An Introduction to Testing in Go<br />
<a href="https://tutorialedge.net/golang/intro-testing-in-go/">https://tutorialedge.net/golang/intro-testing-in-go/</a>
</li>

<li>Advanced Go Testing Tutorial<br />
<a href="https://tutorialedge.net/golang/advanced-go-testing-tutorial/">https://tutorialedge.net/golang/advanced-go-testing-tutorial/</a>
</li>

<li>GoConvey<br />
<a href="http://goconvey.co/">http://goconvey.co/</a>
</li>

<li>Testing Techniques<br />
<a href="https://talks.golang.org/2014/testing.slide">https://talks.golang.org/2014/testing.slide</a>
</li>

<li>5 simple tips and tricks for writing unit tests in #golang<br />
<a href="https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742">https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742</a>
</li>

<li>Afinní transformace<br />
<a href="https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic">https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic</a>
</li>

<li>package gg<br />
<a href="https://godoc.org/github.com/fogleman/gg">https://godoc.org/github.com/fogleman/gg</a>
</li>

<li>Generate an animated GIF with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/">http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/</a>
</li>

<li>Generate an image programmatically with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/">http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/</a>
</li>

<li>The Go image package<br />
<a href="https://blog.golang.org/go-image-package">https://blog.golang.org/go-image-package</a>
</li>

<li>Balíček draw2D: 2D rendering for different output (raster, pdf, svg)<br />
<a href="https://github.com/llgcode/draw2d">https://github.com/llgcode/draw2d</a>
</li>

<li>Draw a rectangle in Golang?<br />
<a href="https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang">https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang</a>
</li>

<li>YAML<br />
<a href="https://yaml.org/">https://yaml.org/</a>
</li>

<li>edn<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Smile<br />
<a href="https://github.com/FasterXML/smile-format-specification">https://github.com/FasterXML/smile-format-specification</a>
</li>

<li>Protocol-Buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>Marshalling (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
</li>

<li>Unmarshalling<br />
<a href="https://en.wikipedia.org/wiki/Unmarshalling">https://en.wikipedia.org/wiki/Unmarshalling</a>
</li>

<li>Introducing JSON<br />
<a href="http://json.org/">http://json.org/</a>
</li>

<li>Package json<br />
<a href="https://golang.org/pkg/encoding/json/">https://golang.org/pkg/encoding/json/</a>
</li>

<li>The Go Blog: JSON and Go<br />
<a href="https://blog.golang.org/json-and-go">https://blog.golang.org/json-and-go</a>
</li>

<li>Go by Example: JSON<br />
<a href="https://gobyexample.com/json">https://gobyexample.com/json</a>
</li>

<li>Writing Web Applications<br />
<a href="https://golang.org/doc/articles/wiki/">https://golang.org/doc/articles/wiki/</a>
</li>

<li>Golang Web Apps<br />
<a href="https://www.reinbach.com/blog/golang-webapps-1/">https://www.reinbach.com/blog/golang-webapps-1/</a>
</li>

<li>Build web application with Golang<br />
<a href="https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details">https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details</a>
</li>

<li>Golang Templates - Golang Web Pages<br />
<a href="https://www.youtube.com/watch?v=TkNIETmF-RU">https://www.youtube.com/watch?v=TkNIETmF-RU</a>
</li>

<li>Simple Golang HTTPS/TLS Examples<br />
<a href="https://github.com/denji/golang-tls">https://github.com/denji/golang-tls</a>
</li>

<li>Playing with images in HTTP response in golang<br />
<a href="https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang">https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang</a>
</li>

<li>MIME Types List<br />
<a href="https://www.freeformatter.com/mime-types-list.html">https://www.freeformatter.com/mime-types-list.html</a>
</li>

<li>Go Mutex Tutorial<br />
<a href="https://tutorialedge.net/golang/go-mutex-tutorial/">https://tutorialedge.net/golang/go-mutex-tutorial/</a>
</li>

<li>Creating A Simple Web Server With Golang<br />
<a href="https://tutorialedge.net/golang/creating-simple-web-server-with-golang/">https://tutorialedge.net/golang/creating-simple-web-server-with-golang/</a>
</li>

<li>Building a Web Server in Go<br />
<a href="https://thenewstack.io/building-a-web-server-in-go/">https://thenewstack.io/building-a-web-server-in-go/</a>
</li>

<li>How big is the pipe buffer?<br />
<a href="https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer">https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer</a>
</li>

<li>How to turn off buffering of stdout in C<br />
<a href="https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c">https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c</a>
</li>

<li>setbuf(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/setbuf">https://linux.die.net/man/3/setbuf</a>
</li>

<li>setvbuf(3) - Linux man page (stejný obsah jako předchozí stránka)<br />
<a href="https://linux.die.net/man/3/setvbuf">https://linux.die.net/man/3/setvbuf</a>
</li>

<li>Select waits on a group of channels<br />
<a href="https://yourbasic.org/golang/select-explained/">https://yourbasic.org/golang/select-explained/</a>
</li>

<li>Rob Pike: Simplicity is Complicated (video)<br />
<a href="http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893">http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893</a>
</li>

<li>Algorithms to Go<br />
<a href="https://yourbasic.org/">https://yourbasic.org/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů: vlastní filtry a lexery<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/</a>
</li>

<li>Go Defer Simplified with Practical Visuals<br />
<a href="https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff">https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff</a>
</li>

<li>5 More Gotchas of Defer in Go — Part II<br />
<a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa">https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa</a>
</li>

<li>The Go Blog: Defer, Panic, and Recover<br />
<a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a>
</li>

<li>The defer keyword in Swift 2: try/finally done right<br />
<a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer">https://www.hackingwithswift.com/new-syntax-swift-2-defer</a>
</li>

<li>Swift Defer Statement<br />
<a href="https://andybargh.com/swift-defer-statement/">https://andybargh.com/swift-defer-statement/</a>
</li>

<li>Modulo operation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Modulo_operation">https://en.wikipedia.org/wiki/Modulo_operation</a>
</li>

<li>Node.js vs Golang: Battle of the Next-Gen Languages<br />
<a href="https://www.hostingadvice.com/blog/nodejs-vs-golang/">https://www.hostingadvice.com/blog/nodejs-vs-golang/</a>
</li>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go<br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>JavaScript vs. Golang for IoT: Is Gopher Winning?<br />
<a href="https://www.iotforall.com/javascript-vs-golang-iot/">https://www.iotforall.com/javascript-vs-golang-iot/</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

<li>Printf Format Strings<br />
<a href="https://www.cprogramming.com/tutorial/printf-format-strings.html">https://www.cprogramming.com/tutorial/printf-format-strings.html</a>
</li>

<li>Java: String.format<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-</a>
</li>

<li>Java: format string syntax<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a>
</li>

<li>Selectors<br />
<a href="https://golang.org/ref/spec#Selectors">https://golang.org/ref/spec#Selectors</a>
</li>

<li>Calling Go code from Python code<br />
<a href="http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/">http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/</a>
</li>

<li>Go Data Structures: Interfaces <br />
<a href="https://research.swtch.com/interfaces">https://research.swtch.com/interfaces</a>
</li>

<li>How to use interfaces in Go<br />
<a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go</a>
</li>

<li>Interfaces in Go (part I)<br />
<a href="https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c">https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c</a>
</li>

<li>Part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>What about Trait support in Golang?<br />
<a href="https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/">https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/</a>
</li>

<li>Don't Get Bitten by Pointer vs Non-Pointer Method Receivers in Golang<br />
<a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/">https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/</a>
</li>

<li>Control Flow<br />
<a href="https://en.wikipedia.org/wiki/Control_flow">https://en.wikipedia.org/wiki/Control_flow</a>
</li>

<li>Structured programming<br />
<a href="https://en.wikipedia.org/wiki/Structured_programming">https://en.wikipedia.org/wiki/Structured_programming</a>
</li>

<li>Control Structures<br />
<a href="https://www.golang-book.com/books/intro/5">https://www.golang-book.com/books/intro/5</a>
</li>

<li>Control structures - Go if else statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html">http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html</a>
</li>

<li>Control structures - Go switch case statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html</a>
</li>

<li>Control structures - Go for loop, break, continue, range<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html</a>
</li>

<li>Goroutine IDs<br />
<a href="https://blog.sgmansfield.com/2015/12/goroutine-ids/">https://blog.sgmansfield.com/2015/12/goroutine-ids/</a>
</li>

<li>Different ways to pass channels as arguments in function in go (golang)<br />
<a href="https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang">https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang</a>
</li>

<li>justforfunc #22: using the Go execution tracer<br />
<a href="https://www.youtube.com/watch?v=ySy3sR1LFCQ">https://www.youtube.com/watch?v=ySy3sR1LFCQ</a>
</li>

<li>Single Function Exit Point<br />
<a href="http://wiki.c2.com/?SingleFunctionExitPoint">http://wiki.c2.com/?SingleFunctionExitPoint</a>
</li>

<li>Entry point<br />
<a href="https://en.wikipedia.org/wiki/Entry_point">https://en.wikipedia.org/wiki/Entry_point</a>
</li>

<li>Why does Go have a GOTO statement?!<br />
<a href="https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/">https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/</a>
</li>

<li>Effective Go<br />
<a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a>
</li>

<li>GoClipse: an Eclipse IDE for the Go programming language<br />
<a href="http://goclipse.github.io/">http://goclipse.github.io/</a>
</li>

<li>GoClipse Installation<br />
<a href="https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation">https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation</a>
</li>

<li>The zero value of a slice is not nil<br />
<a href="https://stackoverflow.com/questions/30806931/the-zero-value-of-a-slice-is-not-nil">https://stackoverflow.com/questions/30806931/the-zero-value-of-a-slice-is-not-nil</a>
</li>

<li>Go-tcha: When nil != nil<br />
<a href="https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic">https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic</a>
</li>

<li>Nils in Go<br />
<a href="https://www.doxsey.net/blog/nils-in-go">https://www.doxsey.net/blog/nils-in-go</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

