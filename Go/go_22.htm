<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Vstupně-výstupní funkce standardní knihovny programovacího jazyka Go</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Vstupně-výstupní funkce standardní knihovny programovacího jazyka Go</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku o programovacím jazyku Go si přiblížíme některé další možnosti poskytované jeho standardní knihovnou. Nejprve se budeme zabývat systémem používaným pro vstup a výstup dat, což ve skutečnosti není tak triviální téma, jak by se mohlo na první pohled zdát.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Vstupně-výstupní funkce standardní knihovny programovacího jazyka Go</a></p>
<p><a href="#k02">2. Nejdůležitější rozhraní používaná vstupně-výstupním systémem</a></p>
<p><a href="#k03">3. Rozhraní <strong>io.ByteReader</strong></a></p>
<p><a href="#k04">4. Vylepšení testu na zdetekovaný konec dat</a></p>
<p><a href="#k05">5. Bajty versus znaky</a></p>
<p><a href="#k06">6. Rozhraní <strong>io.RuneReader</strong></a></p>
<p><a href="#k07">7. Rozhraní <strong>io.ByteWriter</strong></a></p>
<p><a href="#k08">8. Zápis jednotlivých znaků metodou <strong>WriteRune</strong></a></p>
<p><a href="#k09">9. Rozhraní <strong>io.ByteScanner</strong></a></p>
<p><a href="#k10">10. Vícenásobné vrácení bajtu do vstupu</a></p>
<p><a href="#k11">11. Rozhraní <strong>io.RuneScanner</strong></a></p>
<p><a href="#k12">12. Rozhraní <strong>io.Reader</strong></a></p>
<p><a href="#k13">13. Čtení bloku bajtů ze standardního vstupu a z&nbsp;řetězce</a></p>
<p><a href="#k14">14. Spojení více vstupů &ndash; multireader</a></p>
<p><a href="#k15">15. Rozhraní <strong>io.Writer</strong></a></p>
<p><a href="#k16">16. Kopie souborů po blocích</a></p>
<p><a href="#k17">17. Načtení celého řádku ze standardního vstupu</a></p>
<p><a href="#k18">18. Skládání rozhraní souvisejících se vstupně-výstupními operacemi</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Vstupně-výstupní funkce standardní knihovny programovacího jazyka Go</h2>

<p>Již v&nbsp;předchozích částech <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">seriálu o
programovacím jazyku Go</a> jsme se seznámili s&nbsp;některými balíčky
patřícími do standardní knihovny tohoto jazyka. Ve skutečnosti je standardní
knihovna poměrně rozsáhlá a obsahuje funkce a datové typy používané především
pro tvorbu síťových služeb, webových služeb, mikroslužeb, utilit používaných
systémovými administrátory, aplikací ovládaných z&nbsp;příkazové řádky (CLI)
apod. Naopak ve standardní knihovně nenalezneme například podporu pro tvorbu
plnohodnotných desktopových aplikací s&nbsp;grafickým uživatelským rozhraním,
protože (alespoň prozatím) používá většina Go aplikací s&nbsp;uživatelským
rozhraním možností poskytovaných moderními webovými prohlížeči (což ostatně pro
jazyk vyvinutý primárně ve společnosti Google pravděpodobně dává smysl, i když
se v&nbsp;delším časovém horizontu může jednat o dvousečnou zbraň &ndash;
ostatně historie IT zná už mnoho jednoúčelových programovacích jazyků, které se
mimo svou niku nijak významně nerozšířily).</p>

<p>V&nbsp;dnešním článku si přiblížíme některé další možnosti poskytované
standardní knihovnou. Nejprve se budeme zabývat systémem používaným pro vstup a
výstup dat (a zdaleka se nejedná pouze o operace nad soubory). Mohlo by se
možná zdát, že se jedná o triviální téma, ovšem například zkušenosti
z&nbsp;jiných jazyků (příkladem může být Java a jejich několik generací IO a
NIO knihoven) ukazují, že dobře navržená a především pak rozšiřitelná IO
knihovna je pro další rozvoj jazyka velmi užitečná a důležitá. V&nbsp;jazyku Go
je celý systém vstupně-výstupních operací založen na několika rozhraních,
jejichž metody mohou být (a ve skutečnosti i jsou) implementovány hned několika
různými způsoby a použít je lze pro různé účely. Většina těchto rozhraní
obsahuje pouze jedinou metodu, což je ovšem v&nbsp;programovacím jazyku Go
velmi často používané řešení, s&nbsp;nímž se setkáme nejenom ve standardní
knihovně.</p>

<p>To, že mnoho dále popsaných rozhraní obsahuje předpis pouze jediné metody má
i další praktický dopad &ndash; pokud budeme potřebovat vytvořit další
mechanismus používaný z&nbsp;pohledu programátora stejným způsobem, jako další
vstupně-výstupní prostředky (soubory, síť, obsah archivu atd.), postačuje
nadeklarovat nový datový typ a pro něj jedinou metodu z&nbsp;vybraného rozhraní
(například <strong>ByteReader</strong>, <strong>Reader</strong> či
<strong>ReadWriter</strong>. Nový takto navržený mechanismus bude od této
chvíle možné do aplikací zařadit bez nutnosti jejich dalších modifikací.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nejdůležitější rozhraní používaná vstupně-výstupním systémem</h2>

<p>V&nbsp;následující tabulce jsou zmíněny základní informace o rozhraních,
s&nbsp;nimiž se prakticky vždy setkáme při práci se vstupně-výstupním systémem
základní knihovny programovacího jazyka Go:</p>

<table>
<tr><th>Typ operace</th><th>Čtení</th><th>Zápis</th></tr>
<tr><td>jednotlivých bajtů</td><td><a href="#k03">io.ByteReader</a></td><td><a href="#k07">io.ByteWriter</a></td></tr>
<tr><td>jednotlivých znaků</td><td><a href="#k06">io.RuneReader</a></td><td>&times;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>jednotlivých bajtů s&nbsp;bufferem</td><td><a href="#k09">io.ByteScanner</a></td><td>&times;</td></tr>
<tr><td>jednotlivých znaků s&nbsp;bufferem</td><td><a href="#k11">io.RuneScanner</a></td><td>&times;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>bloku bajtů</td><td><a href="#k12">io.Reader</a></td><td><a href="#k15">io.Writer</a></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: připomeňme si, že v&nbsp;programovacím
jazyce Go pro implementaci nějakého rozhraní postačuje pouze vytvořit metodu,
jejíž hlavička odpovídá metodě předepsané v&nbsp;rozhraní. Nemusíme tedy nikde
uvádět (ostatně neexistující) klíčové slovo <strong>implements</strong> tak,
jako je tomu v&nbsp;některých jiných programovacích jazycích.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Rozhraní <strong>io.ByteReader</strong></h2>

<p>Základním rozhraním, které může být implementováno pro prakticky libovolné
vstupní či vstupně-výstupní zařízení, je rozhraní nazvané
<strong>ByteReader</strong>. Toto rozhraní předepisuje jedinou metodu nazvanou
<strong>ReadByte</strong>, která pochopitelně slouží k&nbsp;načtení jednoho
bajtu ze vstupu. Pokud už další bajt nelze z&nbsp;nějakého důvodu načíst,
například proto, že se dosáhlo konce dat nebo došlo k&nbsp;nějaké
vstupně-výstupní chybě (výpadek připojení, odpojení souborového systému,
skutečná chyba na fyzické datové vrstvě...), vrátí se ve druhé návratové
hodnotě informace o chybě a první vrácená hodnota z&nbsp;metody
<strong>ReadByte</strong> není obecně definována (musíme tedy počítat
s&nbsp;tím, že může obsahovat jakoukoli hodnotu):</p>

<pre>
type <strong>ByteReader</strong> interface {
        <strong>ReadByte</strong>() (byte, error)
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že toto rozhraní
nepředpokládá žádné další vlastnosti vstupního zařízení &ndash; to nemusí umět
například vrátit bajt zpátky do vstupního bufferu (pokud takový buffer vůbec
existuje) a už vůbec není zapotřebí umět v&nbsp;datech provádět operaci typu
<i>seek</i> nebo rozpoznávat jednotlivé znaky (v&nbsp;Unicode, konkrétně
v&nbsp;kódování UTF-8). Z&nbsp;tohoto důvodu nalezneme metodu
<strong>ReadByte</strong> (a tím pádem i celé rozhraní
<strong>ByteReader</strong>) například v&nbsp;implementacích dekomprimačních
algoritmů, u některých síťových protokolů atd. Dále se explicitně nepředpokládá
operace typu <strong>Close</strong>; tu je nutné v&nbsp;případě potřeby
implementovat přes další rozhraní.</div></p>

<p>Demonstrační příklad používající rozhraní nazvané
<strong>ByteReader</strong> a jeho metodu <strong>ReadByte</strong> je ve
skutečnosti velmi jednoduchý. Využijeme zde faktu, že metoda
<strong>ReadByte</strong> je implementována i datovým typem nazvaným
<strong>Reader</strong>, tentokrát ovšem definovaným v&nbsp;balíčku
<strong>strings</strong> a nikoli v&nbsp;balíčku <strong>io</strong>.
Konstruktor tohoto datového typu se volá funkcí <strong>NewReader</strong>,
které předáme řetězec použitý jako zdroj dat:</p>

<pre>
reader := strings.NewReader("Hello world!")
</pre>

<p>Povšimněte si, jakým způsobem je realizován test na to, zda řetězec,
z&nbsp;něhož načítáme jednotlivé bajty, ještě obsahuje nějaká data či zda jsme
došli až na konec řetězce:</p>

<pre>
b, err := reader.ReadByte()
if err == nil {
        fmt.Printf("%c", b)
} else {
        fmt.Printf("\nerror %v", err)
        break
}
</pre>

<p>Následuje výpis <a
href="https://github.com/tisnik/go-root/blob/master/article_22/01_read_byte.go">úplného
zdrojového kódu</a> tohoto demonstračního příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "strings"
)
&nbsp;
func <strong>main</strong>() {
        reader := strings.NewReader("Hello world!")
        for {
                b, err := reader.ReadByte()
                if err == nil {
                        fmt.Printf("%c", b)
                } else {
                        fmt.Printf("\nerror %v", err)
                        break
                }
        }
}
</pre>

<p>Příklad výstupu:</p>

<pre>
Hello world!
error EOF
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vylepšení testu na zdetekovaný konec dat</h2>

<p>Ve skutečnosti ovšem můžeme test na to, zda jsme na vstupu došli až na konec
dat, napsat daleko explicitněji, a to kontrolou, jaká konkrétní chybová hodnota
se vrátila z&nbsp;metody <strong>ReadByte</strong>. V&nbsp;případě, že se
vrátila hodnota odpovídající konstantě <strong>io.EOF</strong>, nejedná se o
skutečnou chybu, ale o &bdquo;obyčejný&ldquo; konec dat, který většinou budeme
chtít zpracovat jiným způsobem, než odlišný typ chyby. Tato úprava zdrojového
kódu je provedena <a
href="https://github.com/tisnik/go-root/blob/master/article_22/02_better_read_byte.go">v&nbsp;další
verzi demonstračního příkladu</a>, jenž je vypsán pod tímto odstavcem:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "io"
        "strings"
)
&nbsp;
func <strong>main</strong>() {
        reader := strings.NewReader("Hello world!")
        for {
                b, err := reader.ReadByte()
                if err == io.EOF {
                        fmt.Println("\nEOF detected")
                        break
                }
                if err == nil {
                        fmt.Printf("%c", b)
                } else {
                        fmt.Printf("\nerror %v", err)
                        break
                }
        }
}
</pre>

<p>Opět si ukažme příklad výstupu, který bude od prvního příkladu nepatrně
odlišný:</p>

<pre>
Hello world!
EOF detected
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Bajty versus znaky</h2>

<p>Další komplikace při praktickém používání vstupně-výstupních operací může
nastat v&nbsp;případě, kdy budeme potřebovat ze vstupu načítat celé
<i>znaky</i> a nikoli jednotlivé dále nezpracovávané <i>bajty</i>. Připomeňme
si, že v&nbsp;programovacím jazyku Go existuje striktní rozlišení mezi bajty a
znaky, přičemž znaky jsou reprezentovány datovým typem nazvaným <i>rune</i>,
protože je nutné rozpoznávat celý rozsah Unicode a nikoli už pouhé ASCII, které
je jen nepatrnou (i když velmi důležitou) podmnožinou Unicode. Nejdříve se
podívejme na způsob, jakým se vlastně zpracovávají jednotlivé bajty metodou
pojmenovanou <strong>ReadByte</strong> v&nbsp;tom případě, kdy zdroj dat
obsahuje znaky Unicode (samotný zdrojový kód napsaný v&nbsp;Go přitom používá
kódování UTF-8, tj.&nbsp;jedno z&nbsp;nejčastějších kódování Unicode). Postačí
nám nepatrná úprava předchozího demonstračního příkladu do <a
href="https://github.com/tisnik/go-root/blob/master/article_22/03_read_byte_from_unicode.go">modifikovaného
tvaru</a>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "io"
        "strings"
)
&nbsp;
func <strong>main</strong>() {
        reader := strings.NewReader("* ěščř ½µ§я¤ *")
        for {
                b, err := reader.ReadByte()
                if err == io.EOF {
                        fmt.Println("\nEOF detected")
                        break
                }
                if err == nil {
                        fmt.Printf("%02x ", b)
                } else {
                        fmt.Printf("\nerror %v", err)
                        break
                }
        }
}
</pre>

<p>Výsledkem by měla být sekvence bajtů vypsaných v&nbsp;hexadecimální
soustavě:</p>

<pre>
2a 20 c4 9b c5 a1 c4 8d c5 99 20 c2 bd c2 b5 c2 a7 d1 8f c2 a4 20 2a 
EOF detected
</pre>

<p><div class="rs-tip-major">Poznámka: počet vypsaných hodnot a tedy i počet
načtených bajtů je samozřejmě v&nbsp;tomto případě numericky vyšší, než počet
znaků ve vstupním řetězci. Obě hodnoty by byly shodné jen ve chvíli, kdyby
řetězec obsahoval pouze ASCII znaky.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Rozhraní <strong>io.RuneReader</strong></h2>

<p>V&nbsp;případě, že skutečně budeme chtít postupně načítat jednotlivé znaky a
nikoli bajty, je výhodnější namísto rozhraní <strong>ByteReader</strong> využít
spíše rozhraní nazvané <strong>RuneReader</strong> s&nbsp;jedinou předepsanou
metodou, jejíž jméno je <strong>ReadRune</strong>. Tato metoda vrací jak
načtený znak, tak i jeho velikost reprezentovanou v&nbsp;bajtech (přičemž znaky
z&nbsp;původní ASCII jsou reprezentovány jedním bajtem, ostatní znaky pak více
bajty). V&nbsp;případě, že se načtení dalšího znaku nezdaří, vrátí se ve třetí
návratové hodnotě chyba (a první dvě návratové hodnoty by se neměly dále
zpracovávat):</p>

<pre>
type <strong>RuneReader</strong> interface {
        <strong>ReadRune</strong>() (r rune, size int, err error)
}
</pre>

<p>Samozřejmě si opět všechno vyzkoušíme <a
href="https://github.com/tisnik/go-root/blob/master/article_22/04_read_rune_from_unicode.go">v&nbsp;demonstračním
příkladu</a>, v&nbsp;němž pro jednoduchost opět použijeme objekt typu
<strong>Reader</strong>, jehož zdrojem dat je obyčejný řetězec:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "io"
        "strings"
)
&nbsp;
func <strong>main</strong>() {
        reader := strings.NewReader("* ěščř ½µ§я¤ *")
        for {
                c, size, err := reader.ReadRune()
                if err == io.EOF {
                        fmt.Println("\nEOF detected")
                        break
                }
                if err == nil {
                        fmt.Printf("%c %d\n", c, size)
                } else {
                        fmt.Printf("\nerror %v", err)
                        break
                }
        }
}
</pre>

<p>V&nbsp;tomto případě by měl výsledek práce tohoto demonstračního příkladu
vypadat následovně:</p>

<pre>
* 1
  1
ě 2
š 2
č 2
ř 2
  1
½ 2
µ 2
§ 2
я 2
¤ 2
  1
* 1
&nbsp;
EOF detected
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že ASCII znaky jsou
skutečně reprezentovány jediným bajtem, kdežto ostatní znaky více
bajty.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Rozhraní <strong>io.ByteWriter</strong></h2>

<p>Opakem rozhraní <strong>ByteReader</strong>, s&nbsp;nímž jsme se seznámili
v&nbsp;předchozích kapitolách, je rozhraní, které se &ndash; což asi nebude
příliš překvapující &ndash; jmenuje <strong>ByteWriter</strong>. Toto rozhraní
předepisuje pouze jedinou metodu s&nbsp;názvem <strong>WriteByte</strong>,
která slouží k&nbsp;zápisu bajtu do výstupního zařízení (či libovolného
výstupního mechanismu) a vrací hodnotu obsahující popis případné chyby, která
může při zápisu nastat:</p>

<pre>
type <strong>ByteWriter</strong> interface {
        <strong>WriteByte</strong>(c byte) error
}
</pre>

<p>Toto rozhraní je implementováno například datovým typem se jménem
<strong>Buffer</strong> ze standardního balíčku <strong>bytes</strong>. Samotný
buffer umožňuje zápis a čtení na úrovni jednotlivých bajtů či znaků do operační
paměti, přičemž velikost bufferu se dynamicky podle potřeb mění.
V&nbsp;následujícím <a
href="https://github.com/tisnik/go-root/blob/master/article_22/05_write_byte.go">demonstračním
příkladu</a> je buffer zpočátku prázdný a hodnoty (jednotlivé bajty) do něj
zapíšeme právě metodou <strong>WriteByte</strong> a zpětně je pro kontrolu
přečteme metodou <strong>ReadByte</strong>, kterou již dobře známe
z&nbsp;předchozího textu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "fmt"
)
&nbsp;
func <strong>main</strong>() {
        buffer := bytes.Buffer{}
        buffer.WriteByte(65)
&nbsp;
        b, _ := buffer.ReadByte()
        fmt.Printf("%02x\n", b)
&nbsp;
        buffer.WriteByte(0xff)
&nbsp;
        b, _ = buffer.ReadByte()
        fmt.Printf("%02x\n", b)
}
</pre>

<p>Příklad výstupu:</p>

<pre>
41
ff
</pre>

<p>V&nbsp;předchozím odstavci jsme si řekli, že <strong>buffer</strong>
umožňuje, aby se čtení a zápis prováděly na úrovni jednotlivých bajtů či znaků.
To nám umožňuje i kombinaci obou přístupů, tj.&nbsp;například zápis bajtů,
které se následně pokusíme přečíst jako jednotlivé znaky Unicode zakódované
pomocí UTF-8. Vyzkoušejme si to <a
href="https://github.com/tisnik/go-root/blob/master/article_22/06_write_byte_read_rune.go">na
dalším příkladu</a>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "fmt"
)
&nbsp;
func <strong>main</strong>() {
        buffer := bytes.Buffer{}
        buffer.WriteByte(65)
&nbsp;
        c, size, err := buffer.ReadRune()
        fmt.Printf("%c %d %v\n", c, size, err)
&nbsp;
        buffer.WriteByte(0xc4)
        buffer.WriteByte(0x9b)
&nbsp;
        c, size, err = buffer.ReadRune()
        fmt.Printf("%c %d %v\n", c, size, err)
&nbsp;
        c, size, err = buffer.ReadRune()
        fmt.Printf("%c %d %v\n", c, size, err)
}
</pre>

<p>Výsledek činnosti tohoto demonstračního příkladu by měl vypadat
následovně:</p>

<pre>
A 1 &lt;nil&gt;
ě 2 &lt;nil&gt;
 0 EOF
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že na posledním řádku se
ve skutečnosti žádný znak nevrátil &ndash; naopak se vrátila chybová hodnota
oznamující, že buffer je prázdný a čtení tedy nelze provést.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zápis jednotlivých znaků metodou <strong>WriteRune</strong></h2>

<p>Vzhledem k&nbsp;tomu, že existují standardní rozhraní
<strong>io.ByteWriter</strong>, <strong>io.ByteReader</strong> a
<strong>io.RuneReader</strong>, mohlo by se očekávat, že bude existovat i
rozhraní pojmenované <strong>io.RuneWriter</strong>. Ve skutečnosti tomu tak
není, i když například již výše zmíněný typ <strong>Buffer</strong>
z&nbsp;balíčku <strong>bytes</strong> obsahuje metodu nazvanou
<strong>WriteRune</strong>, která by byla předepsána právě teoretickým
rozhraním <strong>io.RuneWriter</strong>. Ostatně si chování této metody můžeme
velmi snadno otestovat, a to překladem a spuštěním <a
href="https://github.com/tisnik/go-root/blob/master/article_22/07_write_rune.go">dalšího
demonstračního příkladu</a>, jehož zdrojový kód vypadá takto:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "fmt"
)
&nbsp;
func <strong>main</strong>() {
        buffer := bytes.Buffer{}
        buffer.WriteRune('a')
        buffer.WriteRune('ě')
        buffer.WriteRune('я')
&nbsp;
        for {
                b, err := buffer.ReadByte()
                if err == nil {
                        fmt.Printf("%02x ", b)
                } else {
                        fmt.Printf("\nerror %v", err)
                        break
                }
        }
}
</pre>

<p>Tento příklad by měl po svém spuštění vypsat následující trojici řádků:</p>

<pre>
A 1 &lt;nil&gt;
ě 2 &lt;nil&gt;
 0 EOF
</pre>

<p><div class="rs-tip-major">Poznámka: namísto rozhraní
<strong>RuneWriter</strong> se většinou používají funkce a metody sloužící pro
zápis celých řetězců, popř.&nbsp;je možné znaky před jejich zápisem převést na
sekvenci bajtů. S&nbsp;tímto přístupem se setkáme později.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Rozhraní <strong>io.ByteScanner</strong></h2>

<p>Další dvojice rozhraní, s&nbsp;nimiž se v&nbsp;dnešním článku alespoň ve
stručnosti seznámíme, se jmenuje <strong>io.ByteScanner</strong> a
<strong>io.RuneScanner</strong>. Rozhraní <strong>io.ByteScanner</strong> je
založeno na již popsaném rozhraní <strong>io.ByteReader</strong>, ovšem
k&nbsp;metodě <strong>ReadByte</strong> je navíc přidána i metoda pojmenovaná
<strong>UnreadByte</strong>:</p>

<pre>
type <strong>ByteScanner</strong> interface {
        ByteReader
        <strong>UnreadByte</strong>() error
}
</pre>

<p>Tato metoda &ndash; pokud ji samozřejmě nějaký datový typ implementuje
&ndash; zajistí, že další volání metody <strong>ReadByte</strong> vrátí stejný
bajt, jako předchozí volání této metody. Jak je popsané chování interně
zajištěno, již pochopitelně do značné míry závisí na tom, jaké zařízení či
vstupní mechanismus je použit. Někde je možné použít vstupní buffer, jindy se
zapamatuje pouze poslední načítaný znak atd. Většinou není možné metodu
<strong>UnreadByte</strong> zavolat vícekrát za sebou, a to právě z&nbsp;toho
důvodu, že její interní implementace si pamatuje pouze poslední čtený znak.</p>

<p><div class="rs-tip-major">Poznámka: některé implementace, například ty
založené na typu <strong>Buffer</strong>, naopak umožňují prakticky libovolné
volání metody <strong>UnreadByte</strong>, protože je tato metoda
implementována pouhým posunem indexu či ukazatele v&nbsp;poli reprezentujícím
vstupní data. Jedná se však spíše o výjimku, než o pravidlo a na možnost
vícenásobného volání <strong>UnreadByte</strong> se není obecně možné
spoléhat.</div></p>

<p>Tato dvě rozhraní jsou velmi užitečná, protože v&nbsp;mnoha algoritmech se
při zpracování vstupních dat dozvíme, že například nějaký blok již skončil, až
ve chvíli, kdy přečteme <i>následující</i> bajt či znak, který již má logicky
patřit do dalšího bloku. Čistě programové řešení by většinou bylo zbytečně
komplikované, takže použití rozhraní <strong>ByteScanner</strong> a
<strong>RuneScanner</strong> je snadnější a čistější.</p>

<p>V&nbsp;dalším demonstračním příkladu si ukážeme použití metody
<strong>UnreadByte</strong> při čtení bajtů (nikoli celých znaků!)
z&nbsp;řetězce představujícího zdroj dat pro objekt typu
<strong>strings.Reader</strong>. Úplný zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_22/08_unread_byte.go">https://github.com/tisnik/go-root/blob/master/article_22/08_unread_byte.go</a>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "strings"
)
&nbsp;
func <strong>main</strong>() {
        reader := strings.NewReader("Hello world!")
        cnt := 0
&nbsp;
        for {
                b, err := reader.ReadByte()
                if err == nil {
                        fmt.Printf("%c", b)
                } else {
                        fmt.Printf("\nerror %v", err)
                        break
                }
                cnt++
                if cnt == 5 || cnt == 10 || cnt == 14 || cnt == 15 {
                        reader.UnreadByte()
                }
        }
}
</pre>

<p>Z&nbsp;výpisu produkovaného tímto příkladem je patrné, že se skutečně
podařilo zdvojit pátý, desátý, čtrnáctý a patnáctý bajt v&nbsp;řetězci:</p>

<pre>
Helloo worrld!!!
error EOF
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Vícenásobné vrácení bajtu do vstupu</h2>

<p>Objekt typu <strong>strings.Reader</strong> ve skutečnosti umožňuje
několikanásobné zpětné vložení bajtu, protože se interně jedná pouze o posun
ukazatele ve vstupních datech. Můžeme tedy napsat například:</p>

<pre>
if cnt == 6 {
        for i := 0; i &lt;= 6; i++ {
                reader.UnreadByte()
        }
}
</pre>

<p>Chování takto upraveného příkladu si samozřejmě můžeme otestovat; <a
href="https://github.com/tisnik/go-root/blob/master/article_22/09_unread_more_bytes.go">zde
je jeho úplný zdrojový kód</a>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "strings"
)
&nbsp;
func <strong>main</strong>() {
        reader := strings.NewReader("Hello world!")
        cnt := 0
&nbsp;
        for {
                b, err := reader.ReadByte()
                if err == nil {
                        fmt.Printf("%c", b)
                } else {
                        fmt.Printf("\nerror %v", err)
                        break
                }
                cnt++
                if cnt == 6 {
                        for i := 0; i &lt;= 6; i++ {
                                reader.UnreadByte()
                        }
                }
        }
}
</pre>

<p>Výsledek činnosti tohoto demonstračního příkladu by měl vypadat
následovně:</p>

<pre>
Hello Hello world!
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se v&nbsp;tomto
případě ve skutečnosti skutečně vrátila zpět operace čtení bajtu, nedošlo tedy
k&nbsp;několikanásobnému vložení stejného bajtu do řetězce (což by platilo,
pokud by čtení nenávratně mazalo vstupní data a systém by si pamatoval jen
poslední načtený bajt), ale k&nbsp;posunu ukazatele (<strong>r.i</strong>) na
jeho začátek.</div></p>

<pre>
func (r *Reader) <strong>UnreadByte</strong>() error {
        r.prevRune = -1
        if r.i &lt;= 0 {
                return errors.New("strings.Reader.UnreadByte: at beginning of string")
        }
        r.i--
        return nil
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Rozhraní <strong>io.RuneScanner</strong></h2>

<p>Další rozhraní se stejnou filozofií, jako má výše popsané rozhraní
<strong>io.ByteScanner</strong>, se jmenuje <strong>RuneScanner</strong>. Toto
rozhraní je odvozeno od <strong>io.RuneReader</strong>, ovšem navíc je do něj
přidána metoda určená pro vrácení posledně čteného znaku/runy:</p>

<pre>
type <strong>RuneScanner</strong> interface {
        RuneReader
        <strong>UnreadRune</strong>() error
}
</pre>

<p>Použití tohoto rozhraní je snadné, což si ostatně můžeme ukázat <a
href="https://github.com/tisnik/go-root/blob/master/article_22/10_unread_rune.go">v&nbsp;pořadí
již desátém příkladu</a>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "io"
        "strings"
)
&nbsp;
func <strong>main</strong>() {
        reader := strings.NewReader("* ěščř ½µ§я¤ *")
        cnt := 0
&nbsp;
        for {
                c, size, err := reader.ReadRune()
                if err == io.EOF {
                        fmt.Println("\nEOF detected")
                        break
                }
                if err == nil {
                        fmt.Printf("%c %d\n", c, size)
                } else {
                        fmt.Printf("\nerror %v", err)
                        break
                }
                cnt++
                if cnt == 5 || cnt == 10 || cnt == 14 || cnt == 15 {
                        reader.UnreadRune()
                }
        }
}
</pre>

<p>Na výstupu můžeme vidět, že se některé znaky/runy skutečně načetly a vypsaly
vícekrát. Zdvojené a ztrojené znaky jsou zvýrazněny:</p>

<pre>
* 1
  1
ě 2
š 2
<strong>č 2</strong>
<strong>č 2</strong>
ř 2
  1
½ 2
<strong>µ 2</strong>
<strong>µ 2</strong>
§ 2
я 2
<strong>¤ 2</strong>
<strong>¤ 2</strong>
<strong>¤ 2</strong>
  1
* 1
&nbsp;
EOF detected
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Rozhraní <strong>Reader</strong></h2>

<p>Ve standardní knihovně programovacího jazyka Go nalezneme i další dvě
důležitá rozhraní, s&nbsp;nimiž se dokonce v&nbsp;praxi setkáme většinou mnohem
častěji, než s&nbsp;výše zmíněnými rozhraními <strong>ByteReader</strong> a
<strong>ByteWriter</strong>. První z&nbsp;těchto rozhraní předepisuje jedinou
metodu určenou pro bufferované čtení dat z&nbsp;prakticky libovolného vstupního
mechanismu (zařízení, souboru, roury atd.), u něhož se předpokládá, že dokáže
načítat blok dat a rozeznávat jejich případný konec. Toto rozhraní se jmenuje
jednoduše <strong>Reader</strong> a jediná metoda tohoto rozhraní má jméno
<strong>Read</strong>:</p>

<pre>
type <strong>Reader</strong> interface {
        <strong>Read</strong>(p []byte) (n int, err error)
}
</pre>

<p>Počet načítaných bajtů závisí na velikosti/kapacitě pole bajtů a taktéž na
tom, kolik bajtů se ještě na vstupu nachází. Ideálně se vždy načte tolik bajtů,
kolik odpovídá kapacitě předaného pole, ovšem například na konci souboru (pokud
provádíme načítání ze souboru) to bude méně. Počet skutečně načtených bajtů
získáme snadno &ndash; z&nbsp;první návratové hodnoty.</p>

<p>Podívejme se nyní na typické použití tohoto rozhraní při načítání dat ze
vstupního souboru. Soubor nejdříve otevřeme a zajistíme jeho uzavření na konci
funkce:</p>

<pre>
fin, err := os.Open(filename)
if err != nil {
        log.Fatal(err)
}
defer fin.Close()
</pre>

<p>Dále vytvoříme buffer pro čtení dat:</p>

<pre>
const buffer_size = 16
buffer := make([]byte, buffer_size)
</pre>

<p>Další čtení (v&nbsp;našem případě po šestnácti bajtech) je již snadné:</p>

<pre>
for {
        read, err := fin.Read(buffer)
&nbsp;
        if read &gt; 0 {
                fmt.Printf("read %d bytes\n", read)
                fmt.Println(buffer[:read])
        }
&nbsp;
        if err != nil {
                fmt.Printf("other error %v\n", err)
                break
        }
}
</pre>

<p>Úplná implementace čtení bajtů ze souboru po blocích pevné délky <a
href="https://github.com/tisnik/go-root/blob/master/article_22/11_io_reader_read.go">vypadá
takto</a>:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "io"
        "log"
        "os"
)
&nbsp;
const filename = "test_input.txt"
const buffer_size = 16
&nbsp;
func <strong>main</strong>() {
        fin, err := os.Open(filename)
        if err != nil {
                log.Fatal(err)
        }
        defer fin.Close()
&nbsp;
        buffer := make([]byte, buffer_size)
&nbsp;
        for {
                read, err := fin.Read(buffer)
&nbsp;
                if read &gt; 0 {
                        fmt.Printf("read %d bytes\n", read)
                        fmt.Println(buffer[:read])
                }
&nbsp;
                if err == io.EOF {
                        fmt.Println("reached end of file")
                        break
                }
&nbsp;
                if err != nil {
                        fmt.Printf("other error %v\n", err)
                        break
                }
        }
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Čtení bloku bajtů ze standardního vstupu a z&nbsp;řetězce</h2>

<p>Nepatrnou úpravou předchozího příkladu můžeme zajistit čtení bloku bajtů ze
standardního vstupu. Ten je představován objektem <strong>os.Stdin</strong>,
který pochopitelně nemusíme ani otevírat ani uzavírat. Podívejme se tedy jen na
<a
href="https://github.com/tisnik/go-root/blob/master/article_22/12_stdin_read.go">způsob
implementace</a>:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "io"
        "os"
)
&nbsp;
const buffer_size = 16
&nbsp;
func <strong>main</strong>() {
        buffer := make([]byte, buffer_size)
&nbsp;
        for {
                read, err := os.Stdin.Read(buffer)
&nbsp;
                if read &gt; 0 {
                        fmt.Printf("read %d bytes\n", read)
                        fmt.Println(buffer[:read])
                }
&nbsp;
                if err == io.EOF {
                        fmt.Println("reached end of file")
                        break
                }
&nbsp;
                if err != nil {
                        fmt.Printf("other error %v\n", err)
                        break
                }
        }
}
</pre>

<p>Podobně můžeme využít objekt <strong>strings.Reader</strong> pro čtení bloku
bajtů z&nbsp;řetězce, což je implementováno v&nbsp;dnešním <a
href="https://github.com/tisnik/go-root/blob/master/article_22/13_string_reader_read.go">třináctém
demonstračním příkladu</a>:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "io"
        "strings"
)
&nbsp;
const input_string = "Hello world!"
const buffer_size = 4
&nbsp;
func <strong>main</strong>() {
        r := strings.NewReader(input_string)
&nbsp;
        buffer := make([]byte, buffer_size)
&nbsp;
        for {
                read, err := r.Read(buffer)
&nbsp;
                if read &gt; 0 {
                        fmt.Printf("read %d bytes\n", read)
                        fmt.Println(buffer[:read])
                }
&nbsp;
                if err == io.EOF {
                        fmt.Println("reached end of file")
                        break
                }
&nbsp;
                if err != nil {
                        fmt.Printf("other error %v\n", err)
                        break
                }
        }
}
</pre>

<p>Načtené bloky bajtů se můžeme pokusit převést na řetězec konstruktorem
<strong>string</strong>. Opět si ukažme <a
href="https://github.com/tisnik/go-root/blob/master/article_22/14_string_reader_as_str.go">celý
zdrojový kód takto upraveného příkladu</a>:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "io"
        "strings"
)
&nbsp;
const input_string = "Hello world!"
const buffer_size = 4
&nbsp;
func <strong>main</strong>() {
        r := strings.NewReader(input_string)
&nbsp;
        buffer := make([]byte, buffer_size)
&nbsp;
        for {
                read, err := r.Read(buffer)
&nbsp;
                if read &gt; 0 {
                        fmt.Printf("read %d bytes\n", read)
                        fmt.Println(string(buffer[:read]))
                }
&nbsp;
                if err == io.EOF {
                        fmt.Println("reached end of file")
                        break
                }
&nbsp;
                if err != nil {
                        fmt.Printf("other error %v\n", err)
                        break
                }
        }
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Spojení více vstupů &ndash; multireader</h2>

<p>Konečně se dostáváme k&nbsp;zajímavějším způsobům použití standardních
vstupně-výstupních rozhraní. Dobrým příkladem může být funkce
<strong>io.MultiReader</strong>, které se na vstup předá <i>libovolné
množství</i> objektů implementujících rozhraní <strong>io.Reader</strong> a
výsledkem bude opět objekt typu <strong>io.Reader</strong>, který ovšem bude
vracet spojené vstupní proudy. To je potenciálně velmi užitečné a především
&ndash; toto spojení dat se provede zcela automaticky a bez toho, abychom
museli nějakým způsobem měnit logiku aplikace. V&nbsp;dalším příkladu je
ukázáno, jak se spojí tři objekty typu <strong>Reader</strong>:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "io"
        "strings"
)
&nbsp;
const input_string_1 = "Hello"
const input_string_2 = "world"
const input_string_3 = "!"
&nbsp;
const buffer_size = 4
&nbsp;
func <strong>main</strong>() {
        r1 := strings.NewReader(input_string_1)
        r2 := strings.NewReader(input_string_2)
        r3 := strings.NewReader(input_string_3)
        r := io.MultiReader(r1, r2, r3)
&nbsp;
        buffer := make([]byte, buffer_size)
&nbsp;
        for {
                read, err := r.Read(buffer)
&nbsp;
                if read &gt; 0 {
                        fmt.Printf("read %d bytes\n", read)
                        fmt.Println(string(buffer[:read]))
                }
&nbsp;
                if err == io.EOF {
                        fmt.Println("reached end of file")
                        break
                }
&nbsp;
                if err != nil {
                        fmt.Printf("other error %v\n", err)
                        break
                }
        }
}
</pre>

<p>Příklad výstupu:</p>

<pre>
read 4 bytes
Hell
read 1 bytes
o
read 4 bytes
worl
read 1 bytes
d
read 1 bytes
!
reached end of file
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Rozhraní <strong>io.Writer</strong></h2>

<p>Opakem rozhraní <strong>io.Reader</strong> je pochopitelně rozhraní
pojmenované <strong>io.Writer</strong>. Toto rozhraní předepisuje jedinou
metodu určenou pro zápis bloku bajtů do libovolného výstupu. Metoda vrací počet
skutečně zapsaných bajtů (ten se může lišit od kapacitu bufferu, například při
chybě) a případnou hodnotu reprezentující chybu:</p>

<pre>
type <strong>Writer</strong> interface {
        <strong>Write</strong>(p []byte) (n int, err error)
}
</pre>

<p>Typicky se tato metoda využívá při zápisu do souborů s&nbsp;binárním
obsahem, ovšem můžeme ji pochopitelně použít i v&nbsp;případě, že potřebujeme
pracovat s&nbsp;textovými soubory obsahujícími pouze ASCII znaky. A právě tento
způsob použití je použit v&nbsp;dalším demonstračním příkladu:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "log"
        "os"
)
&nbsp;
const filename = "test_output.txt"
const message = "Hello world!"
&nbsp;
func <strong>main</strong>() {
        fout, err := os.Create(filename)
        if err != nil {
                log.Fatal(err)
        }
        defer fout.Close()
&nbsp;
        buffer := []byte(message)
        written, err := fout.Write(buffer)
&nbsp;
        if written &gt; 0 {
                fmt.Printf("written %d bytes\n", written)
        }
&nbsp;
        if err != nil {
                fmt.Printf("I/O error %v\n", err)
        }
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Kopie souborů po blocích</h2>

<p>Ukažme si ještě, jak zajistit kopii souborů po blocích nějaké pevně zadané
délky. Samotná kopie po blocích samozřejmě není nic složitého, pouze musíme
zajistit, aby se správně pracovalo s&nbsp;posledním blokem, který pochopitelně
nemusí být zcela zaplněn. To je zajištěno zvýrazněným výrazem:</p>

<pre>
read, err := src.Read(buffer)
&nbsp;
if read &gt; 0 {
        fmt.Printf("read %d bytes\n", read)
        written, err := dst.Write(<strong>buffer[:read]</strong>)
        if written &gt; 0 {
                fmt.Printf("written %d bytes\n", written)
        }
        if err != nil {
                fmt.Printf("write error %v\n", err)
                return copied, err
        }
        copied += int64(written)
}
</pre>

<p>Následuje výpis celého zdrojového kódu tohoto příkladu:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "io"
        "os"
)
&nbsp;
func <strong>closeFile</strong>(file *os.File) {
        fmt.Printf("Closing file '%s'\n", file.Name())
        file.Close()
}
&nbsp;
func <strong>copyFile</strong>(srcName, dstName string) (written int64, err error) {
        src, err := os.Open(srcName)
        if err != nil {
                panic(err)
        }
        defer closeFile(src)
&nbsp;
        dst, err := os.Create(dstName)
        if err != nil {
                panic(err)
        }
        defer closeFile(dst)
&nbsp;
        buffer := make([]byte, 16)
        copied := int64(0)
&nbsp;
        for {
                read, err := src.Read(buffer)
&nbsp;
                if read &gt; 0 {
                        fmt.Printf("read %d bytes\n", read)
                        written, err := dst.Write(buffer[:read])
                        if written &gt; 0 {
                                fmt.Printf("written %d bytes\n", written)
                        }
                        if err != nil {
                                fmt.Printf("write error %v\n", err)
                                return copied, err
                        }
                        copied += int64(written)
                }
&nbsp;
                if err == io.EOF {
                        fmt.Println("reached end of file")
                        break
                }
&nbsp;
                if err != nil {
                        fmt.Printf("other error %v\n", err)
                        return copied, err
                }
        }
        return copied, nil
}
&nbsp;
func <strong>testCopyFile</strong>(srcName, dstName string) {
        copied, err := copyFile(srcName, dstName)
        if err != nil {
                fmt.Printf("copyFile('%s', '%s') failed!!!\n", srcName, dstName)
        } else {
                fmt.Printf("Copied %d bytes\n", copied)
        }
        fmt.Println()
}
&nbsp;
func <strong>main</strong>() {
        testCopyFile("test_input.txt", "output.txt")
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Načtení celého řádku ze standardního vstupu</h2>

<p>V&nbsp;dnešním posledním demonstračním příkladu je ukázáno jiné použití
standardních vstupně-výstupních funkcí a metod. Využijeme zde balíček
<strong>bufio</strong>, v&nbsp;němž se mj.&nbsp;nachází i objekt typu
<strong>Reader</strong> obsahující metodu <strong>ReadString</strong>, které se
předá znak, jenž reprezentuje konec dat. V&nbsp;případě, že metodě předáme znak
konce řádku, načte tato metoda celý textový řádek a vrátí ho ve formě řetězce,
tedy s&nbsp;využitím základních konverzních funkcí pro převod bajtů na
Unicode:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bufio"
        "os"
)
&nbsp;
func <strong>main</strong>() {
        reader := bufio.NewReader(os.Stdin)
&nbsp;
        print("Login: ")
        login, err := reader.ReadString('\n')
        if err != nil {
                println("Error reading login")
        }
&nbsp;
        print("Password: ")
        password, err := reader.ReadString('\n')
        if err != nil {
                println("Error reading password")
        }
&nbsp;
        println(login)
        println(password)
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Skládání rozhraní souvisejících se vstupně-výstupními operacemi</h2>

<p>Ve standardní knihovně nalezneme i rozhraní, která jsou složena
z&nbsp;některých rozhraní jednodušších. Příkladem může být především rozhraní
se jménem <strong>io.ReadWriter</strong> s&nbsp;oběma metodami
<strong>Read</strong> i <strong>Write</strong>. Tyto metody ovšem nejsou
předepsány přímo, ale nové rozhraní je skutečně <i>složeno</i> z&nbsp;rozhraní
jednodušších, o čemž se ostatně můžeme snadno přesvědčit:</div></p>

<pre>
type <strong>ReadWriter</strong> interface {
        Reader
        Writer
}
</pre>

<p>Podobně nalezneme ve standardní knihovně i další podobná rozhraní
vycházející ze dvou či tří rozhraní s&nbsp;původně jedinou metodou, zejména
pak:</p>

<pre>
type <strong>ReadCloser</strong> interface {
        Reader
        Closer
}
&nbsp;
type <strong>WriteCloser</strong> interface {
        Writer
        Closer
}
&nbsp;
type <strong>ReadWriteCloser</strong> interface {
        Reader
        Writer
        Closer
}
&nbsp;
type <strong>ReadSeeker</strong> interface {
        Reader
        Seeker
}
&nbsp;
type <strong>WriteSeeker</strong> interface {
        Writer
        Seeker
}
&nbsp;
type <strong>ReadWriteSeeker</strong> interface {
        Reader
        Writer
        Seeker
}
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně dva megabajty), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_read_byte.go</td><td>čtení bajtů z&nbsp;objektu <strong>strings.Reader</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/01_read_byte.go">https://github.com/tisnik/go-root/blob/master/article_22/01_read_byte.go</a></td></tr>
<tr><td> 2</td><td>02_better_read_byte.go</td><td>explicitní test, zda se při čtení došlo na konec dat</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/02_better_read_byte.go">https://github.com/tisnik/go-root/blob/master/article_22/02_better_read_byte.go</a></td></tr>
<tr><td> 3</td><td>03_read_byte_from_unicode.go</td><td>čtení jednotlivých bajtů (nikoli znaků) z&nbsp;řetězce</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/03_read_byte_from_unicode.go">https://github.com/tisnik/go-root/blob/master/article_22/03_read_byte_from_unicode.go</a></td></tr>
<tr><td> 4</td><td>04_read_rune_from_unicode.go</td><td>čtení znaků/run z&nbsp;řetězce</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/04_read_rune_from_unicode.go">https://github.com/tisnik/go-root/blob/master/article_22/04_read_rune_from_unicode.go</a></td></tr>
<tr><td> 5</td><td>05_write_byte.go</td><td>základní použití rozhraní <strong>ByteWriter</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/05_write_byte.go">https://github.com/tisnik/go-root/blob/master/article_22/05_write_byte.go</a></td></tr>
<tr><td> 6</td><td>06_write_byte_read_rune.go</td><td>kombinace zápisu bajtů a čtení znaků/run</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/06_write_byte_read_rune.go">https://github.com/tisnik/go-root/blob/master/article_22/06_write_byte_read_rune.go</a></td></tr>
<tr><td> 7</td><td>07_write_rune.go</td><td>zápis jednotlivých znaků/run metodou <strong>WriteRune</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/07_write_rune.go">https://github.com/tisnik/go-root/blob/master/article_22/07_write_rune.go</a></td></tr>
<tr><td> 8</td><td>08_unread_byte.go</td><td>použití metody <strong>UnreadByte</strong> z&nbsp;rozhraní <strong>ByteScanner</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/08_unread_byte.go">https://github.com/tisnik/go-root/blob/master/article_22/08_unread_byte.go</a></td></tr>
<tr><td> 9</td><td>09_unread_more_bytes.go</td><td>vícenásobné vrácení bajtu zpět do vstupu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/09_unread_more_bytes.go">https://github.com/tisnik/go-root/blob/master/article_22/09_unread_more_bytes.go</a></td></tr>
<tr><td>10</td><td>10_unread_rune.go</td><td>použití metody <strong>UnreadRune</strong> z&nbsp;rozhraní <strong>RuneScanner</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/10_unread_rune.go">https://github.com/tisnik/go-root/blob/master/article_22/10_unread_rune.go</a></td></tr>
<tr><td>11</td><td>11_io_reader_read.go</td><td>použití metody <strong>Read</strong> z&nbsp;rozhraní <strong>Reader</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/11_io_reader_read.go">https://github.com/tisnik/go-root/blob/master/article_22/11_io_reader_read.go</a></td></tr>
<tr><td>12</td><td>12_stdin_read.go</td><td>čtení bloku bajtů ze standardního vstupu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/12_stdin_read.go">https://github.com/tisnik/go-root/blob/master/article_22/12_stdin_read.go</a></td></tr>
<tr><td>13</td><td>13_string_reader_read.go</td><td>čtení bloku bajtů z&nbsp;řetězce</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/13_string_reader_read.go">https://github.com/tisnik/go-root/blob/master/article_22/13_string_reader_read.go</a></td></tr>
<tr><td>14</td><td>14_string_reader_as_str.go</td><td>čtení bloku bajtů a jejich převod na řetězec</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/14_string_reader_as_str.go">https://github.com/tisnik/go-root/blob/master/article_22/14_string_reader_as_str.go</a></td></tr>
<tr><td>15</td><td>15_multi_reader.go</td><td>spojení více vstupů neboli multireader</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/15_multi_reader.go">https://github.com/tisnik/go-root/blob/master/article_22/15_multi_reader.go</a></td></tr>
<tr><td>16</td><td>16_io_writer_write.go</td><td>použití metody <strong>Write</strong> z&nbsp;rozhraní <strong>Writer</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/16_io_writer_write.go">https://github.com/tisnik/go-root/blob/master/article_22/16_io_writer_write.go</a></td></tr>
<tr><td>17</td><td>17_input_via_reader.go</td><td>načtení řetězce metodou <strong>ReadString</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/17_input_via_reader.go">https://github.com/tisnik/go-root/blob/master/article_22/17_input_via_reader.go</a></td></tr>
<tr><td>18</td><td>18_file_block_copy.go</td><td>načtení řetězce metodou <strong>ReadString</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/18_file_block_copy.go">https://github.com/tisnik/go-root/blob/master/article_22/18_file_block_copy.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Rozhraní io.ByteReader<br />
<a href="https://golang.org/pkg/io/#ByteReader">https://golang.org/pkg/io/#ByteReader</a>
</li>

<li>Rozhraní io.RuneReader<br />
<a href="https://golang.org/pkg/io/#RuneReader">https://golang.org/pkg/io/#RuneReader</a>
</li>

<li>Rozhraní io.ByteScanner<br />
<a href="https://golang.org/pkg/io/#ByteScanner">https://golang.org/pkg/io/#ByteScanner</a>
</li>

<li>Rozhraní io.RuneScanner<br />
<a href="https://golang.org/pkg/io/#RuneScanner">https://golang.org/pkg/io/#RuneScanner</a>
</li>

<li>Rozhraní io.Closer<br />
<a href="https://golang.org/pkg/io/#Closer">https://golang.org/pkg/io/#Closer</a>
</li>

<li>Rozhraní io.Reader<br />
<a href="https://golang.org/pkg/io/#Reader">https://golang.org/pkg/io/#Reader</a>
</li>

<li>Rozhraní io.Writer<br />
<a href="https://golang.org/pkg/io/#Writer">https://golang.org/pkg/io/#Writer</a>
</li>

<li>Typ Strings.Reader<br />
<a href="https://golang.org/pkg/strings/#Reader">https://golang.org/pkg/strings/#Reader</a>
</li>

<li>VACUUM (SQL)<br />
<a href="https://www.sqlite.org/lang_vacuum.html">https://www.sqlite.org/lang_vacuum.html</a>
</li>

<li>VACUUM (Postgres)<br />
<a href="https://www.postgresql.org/docs/8.4/sql-vacuum.html">https://www.postgresql.org/docs/8.4/sql-vacuum.html</a>
</li>

<li>go-cron<br />
<a href="https://github.com/rk/go-cron">https://github.com/rk/go-cron</a>
</li>

<li>gocron<br />
<a href="https://github.com/jasonlvhit/gocron">https://github.com/jasonlvhit/gocron</a>
</li>

<li>clockwork<br />
<a href="https://github.com/whiteShtef/clockwork">https://github.com/whiteShtef/clockwork</a>
</li>

<li>clockwerk<br />
<a href="https://github.com/onatm/clockwerk">https://github.com/onatm/clockwerk</a>
</li>

<li>JobRunner<br />
<a href="https://github.com/bamzi/jobrunner">https://github.com/bamzi/jobrunner</a>
</li>

<li>Rethinking Cron<br />
<a href="https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/">https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/</a>
</li>

<li>In the Beginning was the Command Line<br />
<a href="https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html">https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html</a>
</li>

<li>repl.it (REPL pro různé jazyky)<br />
<a href="https://repl.it/languages">https://repl.it/languages</a>
</li>

<li>GOCUI - Go Console User Interface (celé uživatelské prostředí, nejenom input box)<br />
<a href="https://github.com/jroimartin/gocui">https://github.com/jroimartin/gocui</a>
</li>

<li>Read–eval–print loop<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>go-prompt<br />
<a href="https://github.com/c-bata/go-prompt">https://github.com/c-bata/go-prompt</a>
</li>

<li>readline<br />
<a href="https://github.com/chzyer/readline">https://github.com/chzyer/readline</a>
</li>

<li>A pure golang implementation for GNU-Readline kind library<br />
<a href="https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/">https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/</a>
</li>

<li>go-readline<br />
<a href="https://github.com/fiorix/go-readline">https://github.com/fiorix/go-readline</a>
</li>

<li>4 Python libraries for building great command-line user interfaces<br />
<a href="https://opensource.com/article/17/5/4-practical-python-libraries">https://opensource.com/article/17/5/4-practical-python-libraries</a>
</li>

<li>prompt_toolkit 2.0.3 na PyPi<br />
<a href="https://pypi.org/project/prompt_toolkit/">https://pypi.org/project/prompt_toolkit/</a>
</li>

<li>python-prompt-toolkit na GitHubu<br />
<a href="https://github.com/jonathanslenders/python-prompt-toolkit">https://github.com/jonathanslenders/python-prompt-toolkit</a>
</li>

<li>The GNU Readline Library<br />
<a href="https://tiswww.case.edu/php/chet/readline/rltop.html">https://tiswww.case.edu/php/chet/readline/rltop.html</a>
</li>

<li>GNU Readline (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Readline">https://en.wikipedia.org/wiki/GNU_Readline</a>
</li>

<li>readline — GNU readline interface (Python 3.x)<br />
<a href="https://docs.python.org/3/library/readline.html">https://docs.python.org/3/library/readline.html</a>
</li>

<li>readline — GNU readline interface (Python 2.x)<br />
<a href="https://docs.python.org/2/library/readline.html">https://docs.python.org/2/library/readline.html</a>
</li>

<li>GNU Readline Library - command line editing<br />
<a href="https://tiswww.cwru.edu/php/chet/readline/readline.html">https://tiswww.cwru.edu/php/chet/readline/readline.html</a>
</li>

<li>gnureadline 6.3.8 na PyPi<br />
<a href="https://pypi.org/project/gnureadline/">https://pypi.org/project/gnureadline/</a>
</li>

<li>Editline Library (libedit)<br />
<a href="http://thrysoee.dk/editline/">http://thrysoee.dk/editline/</a>
</li>

<li>Comparing Python Command-Line Parsing Libraries – Argparse, Docopt, and Click<br />
<a href="https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/">https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/</a>
</li>

<li>libedit or editline<br />
<a href="http://www.cs.utah.edu/~bigler/code/libedit.html">http://www.cs.utah.edu/~bigler/code/libedit.html</a>
</li>

<li>WinEditLine<br />
<a href="http://mingweditline.sourceforge.net/">http://mingweditline.sourceforge.net/</a>
</li>

<li>rlcompleter — Completion function for GNU readline<br />
<a href="https://docs.python.org/3/library/rlcompleter.html">https://docs.python.org/3/library/rlcompleter.html</a>
</li>

<li>rlwrap na GitHubu<br />
<a href="https://github.com/hanslub42/rlwrap">https://github.com/hanslub42/rlwrap</a>
</li>

<li>rlwrap(1) - Linux man page<br />
<a href="https://linux.die.net/man/1/rlwrap">https://linux.die.net/man/1/rlwrap</a>
</li>

<li>readline(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/readline">https://linux.die.net/man/3/readline</a>
</li>

<li>history(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/history">https://linux.die.net/man/3/history</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>oglematchers</i><br />
<a href="https://godoc.org/github.com/jacobsa/oglematchers">https://godoc.org/github.com/jacobsa/oglematchers</a>
</li>

<li>Balíček <i>oglematchers</i><br />
<a href="https://github.com/jacobsa/oglematchers">https://github.com/jacobsa/oglematchers</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>ogletest</i><br />
<a href="https://godoc.org/github.com/jacobsa/ogletest">https://godoc.org/github.com/jacobsa/ogletest</a>
</li>

<li>Balíček <i>ogletest</i><br />
<a href="https://github.com/jacobsa/ogletest">https://github.com/jacobsa/ogletest</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>assert</i><br />
<a href="https://godoc.org/github.com/stretchr/testify/assert">https://godoc.org/github.com/stretchr/testify/assert</a>
</li>

<li>Testify - Thou Shalt Write Tests<br />
<a href="https://github.com/stretchr/testify/">https://github.com/stretchr/testify/</a>
</li>

<li>package <strong>testing</strong><br />
<a href="https://golang.org/pkg/testing/">https://golang.org/pkg/testing/</a>
</li>

<li>Golang basics - writing unit tests<br />
<a href="https://blog.alexellis.io/golang-writing-unit-tests/">https://blog.alexellis.io/golang-writing-unit-tests/</a>
</li>

<li>An Introduction to Programming in Go / Testing<br />
<a href="https://www.golang-book.com/books/intro/12">https://www.golang-book.com/books/intro/12</a>
</li>

<li>An Introduction to Testing in Go<br />
<a href="https://tutorialedge.net/golang/intro-testing-in-go/">https://tutorialedge.net/golang/intro-testing-in-go/</a>
</li>

<li>Advanced Go Testing Tutorial<br />
<a href="https://tutorialedge.net/golang/advanced-go-testing-tutorial/">https://tutorialedge.net/golang/advanced-go-testing-tutorial/</a>
</li>

<li>GoConvey<br />
<a href="http://goconvey.co/">http://goconvey.co/</a>
</li>

<li>Testing Techniques<br />
<a href="https://talks.golang.org/2014/testing.slide">https://talks.golang.org/2014/testing.slide</a>
</li>

<li>5 simple tips and tricks for writing unit tests in #golang<br />
<a href="https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742">https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742</a>
</li>

<li>Afinní transformace<br />
<a href="https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic">https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic</a>
</li>

<li>package gg<br />
<a href="https://godoc.org/github.com/fogleman/gg">https://godoc.org/github.com/fogleman/gg</a>
</li>

<li>Generate an animated GIF with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/">http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/</a>
</li>

<li>Generate an image programmatically with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/">http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/</a>
</li>

<li>The Go image package<br />
<a href="https://blog.golang.org/go-image-package">https://blog.golang.org/go-image-package</a>
</li>

<li>Balíček draw2D: 2D rendering for different output (raster, pdf, svg)<br />
<a href="https://github.com/llgcode/draw2d">https://github.com/llgcode/draw2d</a>
</li>

<li>Draw a rectangle in Golang?<br />
<a href="https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang">https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang</a>
</li>

<li>YAML<br />
<a href="https://yaml.org/">https://yaml.org/</a>
</li>

<li>edn<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Smile<br />
<a href="https://github.com/FasterXML/smile-format-specification">https://github.com/FasterXML/smile-format-specification</a>
</li>

<li>Protocol-Buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>Marshalling (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
</li>

<li>Unmarshalling<br />
<a href="https://en.wikipedia.org/wiki/Unmarshalling">https://en.wikipedia.org/wiki/Unmarshalling</a>
</li>

<li>Introducing JSON<br />
<a href="http://json.org/">http://json.org/</a>
</li>

<li>Package json<br />
<a href="https://golang.org/pkg/encoding/json/">https://golang.org/pkg/encoding/json/</a>
</li>

<li>The Go Blog: JSON and Go<br />
<a href="https://blog.golang.org/json-and-go">https://blog.golang.org/json-and-go</a>
</li>

<li>Go by Example: JSON<br />
<a href="https://gobyexample.com/json">https://gobyexample.com/json</a>
</li>

<li>Writing Web Applications<br />
<a href="https://golang.org/doc/articles/wiki/">https://golang.org/doc/articles/wiki/</a>
</li>

<li>Golang Web Apps<br />
<a href="https://www.reinbach.com/blog/golang-webapps-1/">https://www.reinbach.com/blog/golang-webapps-1/</a>
</li>

<li>Build web application with Golang<br />
<a href="https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details">https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details</a>
</li>

<li>Golang Templates - Golang Web Pages<br />
<a href="https://www.youtube.com/watch?v=TkNIETmF-RU">https://www.youtube.com/watch?v=TkNIETmF-RU</a>
</li>

<li>Simple Golang HTTPS/TLS Examples<br />
<a href="https://github.com/denji/golang-tls">https://github.com/denji/golang-tls</a>
</li>

<li>Playing with images in HTTP response in golang<br />
<a href="https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang">https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang</a>
</li>

<li>MIME Types List<br />
<a href="https://www.freeformatter.com/mime-types-list.html">https://www.freeformatter.com/mime-types-list.html</a>
</li>

<li>Go Mutex Tutorial<br />
<a href="https://tutorialedge.net/golang/go-mutex-tutorial/">https://tutorialedge.net/golang/go-mutex-tutorial/</a>
</li>

<li>Creating A Simple Web Server With Golang<br />
<a href="https://tutorialedge.net/golang/creating-simple-web-server-with-golang/">https://tutorialedge.net/golang/creating-simple-web-server-with-golang/</a>
</li>

<li>Building a Web Server in Go<br />
<a href="https://thenewstack.io/building-a-web-server-in-go/">https://thenewstack.io/building-a-web-server-in-go/</a>
</li>

<li>How big is the pipe buffer?<br />
<a href="https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer">https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer</a>
</li>

<li>How to turn off buffering of stdout in C<br />
<a href="https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c">https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c</a>
</li>

<li>setbuf(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/setbuf">https://linux.die.net/man/3/setbuf</a>
</li>

<li>setvbuf(3) - Linux man page (stejný obsah jako předchozí stránka)<br />
<a href="https://linux.die.net/man/3/setvbuf">https://linux.die.net/man/3/setvbuf</a>
</li>

<li>Select waits on a group of channels<br />
<a href="https://yourbasic.org/golang/select-explained/">https://yourbasic.org/golang/select-explained/</a>
</li>

<li>Rob Pike: Simplicity is Complicated (video)<br />
<a href="http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893">http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893</a>
</li>

<li>Algorithms to Go<br />
<a href="https://yourbasic.org/">https://yourbasic.org/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů: vlastní filtry a lexery<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/</a>
</li>

<li>Go Defer Simplified with Practical Visuals<br />
<a href="https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff">https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff</a>
</li>

<li>5 More Gotchas of Defer in Go — Part II<br />
<a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa">https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa</a>
</li>

<li>The Go Blog: Defer, Panic, and Recover<br />
<a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a>
</li>

<li>The defer keyword in Swift 2: try/finally done right<br />
<a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer">https://www.hackingwithswift.com/new-syntax-swift-2-defer</a>
</li>

<li>Swift Defer Statement<br />
<a href="https://andybargh.com/swift-defer-statement/">https://andybargh.com/swift-defer-statement/</a>
</li>

<li>Modulo operation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Modulo_operation">https://en.wikipedia.org/wiki/Modulo_operation</a>
</li>

<li>Node.js vs Golang: Battle of the Next-Gen Languages<br />
<a href="https://www.hostingadvice.com/blog/nodejs-vs-golang/">https://www.hostingadvice.com/blog/nodejs-vs-golang/</a>
</li>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go<br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>JavaScript vs. Golang for IoT: Is Gopher Winning?<br />
<a href="https://www.iotforall.com/javascript-vs-golang-iot/">https://www.iotforall.com/javascript-vs-golang-iot/</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

<li>Printf Format Strings<br />
<a href="https://www.cprogramming.com/tutorial/printf-format-strings.html">https://www.cprogramming.com/tutorial/printf-format-strings.html</a>
</li>

<li>Java: String.format<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-</a>
</li>

<li>Java: format string syntax<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a>
</li>

<li>Selectors<br />
<a href="https://golang.org/ref/spec#Selectors">https://golang.org/ref/spec#Selectors</a>
</li>

<li>Calling Go code from Python code<br />
<a href="http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/">http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/</a>
</li>

<li>Go Data Structures: Interfaces <br />
<a href="https://research.swtch.com/interfaces">https://research.swtch.com/interfaces</a>
</li>

<li>How to use interfaces in Go<br />
<a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go</a>
</li>

<li>Interfaces in Go (part I)<br />
<a href="https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c">https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c</a>
</li>

<li>Part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>What about Trait support in Golang?<br />
<a href="https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/">https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/</a>
</li>

<li>Don't Get Bitten by Pointer vs Non-Pointer Method Receivers in Golang<br />
<a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/">https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/</a>
</li>

<li>Control Flow<br />
<a href="https://en.wikipedia.org/wiki/Control_flow">https://en.wikipedia.org/wiki/Control_flow</a>
</li>

<li>Structured programming<br />
<a href="https://en.wikipedia.org/wiki/Structured_programming">https://en.wikipedia.org/wiki/Structured_programming</a>
</li>

<li>Control Structures<br />
<a href="https://www.golang-book.com/books/intro/5">https://www.golang-book.com/books/intro/5</a>
</li>

<li>Control structures - Go if else statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html">http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html</a>
</li>

<li>Control structures - Go switch case statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html</a>
</li>

<li>Control structures - Go for loop, break, continue, range<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html</a>
</li>

<li>Single Function Exit Point<br />
<a href="http://wiki.c2.com/?SingleFunctionExitPoint">http://wiki.c2.com/?SingleFunctionExitPoint</a>
</li>

<li>Entry point<br />
<a href="https://en.wikipedia.org/wiki/Entry_point">https://en.wikipedia.org/wiki/Entry_point</a>
</li>

<li>Why does Go have a GOTO statement?!<br />
<a href="https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/">https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/</a>
</li>

<li>Effective Go<br />
<a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a>
</li>

<li>GoClipse: an Eclipse IDE for the Go programming language<br />
<a href="http://goclipse.github.io/">http://goclipse.github.io/</a>
</li>

<li>GoClipse Installation<br />
<a href="https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation">https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

