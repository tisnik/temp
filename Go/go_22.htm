<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku o programovacím jazyku Go si přiblížíme některé další možnosti poskytované jeho standardní knihovnou. Nejprve se budeme zabývat systémem používaným pro vstup a výstup dat, což ve skutečnosti není tak triviální téma, jak by se mohlo na první pohled zdát.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Vstupně-výstupní funkce standardní knihovny programovacího jazyka Go</a></p>
<p><a href="#k02">*** 2. Nejdůležitější rozhraní používaná vstupně-výstupním systémem</a></p>
<p><a href="#k03">*** 3. Rozhraní <strong>ByteReader</strong></a></p>
<p><a href="#k04">*** 4. Vylepšení testu na zdetekovaný konec dat</a></p>
<p><a href="#k05">*** 5. Bajty versus znaky</a></p>
<p><a href="#k06">*** 6. Rozhraní <strong>RuneReader</strong></a></p>
<p><a href="#k07">*** 7. Rozhraní <strong>ByteWriter</strong></a></p>
<p><a href="#k08">*** 8. Zápis jednotlivých znaků metodou <strong>WriteRune</strong></a></p>
<p><a href="#k09">*** 9. Rozhraní <strong>ByteScanner</strong></a></p>
<p><a href="#k10">*** 10. Vícenásobné vrácení bajtu do vstupu</a></p>
<p><a href="#k11">*** 11. Rozhraní <strong>RuneScanner</strong></a></p>
<p><a href="#k12">*** 12. Rozhraní <strong>Reader</strong></a></p>
<p><a href="#k13">*** 13. Čtení bajtů ze standardního vstupu a z&nbsp;řetězce</a></p>
<p><a href="#k14">*** 14. Spojení více vstupů &ndash; multireader</a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. Rozhraní <strong>Writer</strong></a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. Skládání rozhraní souvisejících se vstupně-výstupními operacemi</a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Vstupně-výstupní funkce standardní knihovny programovacího jazyka Go</h2>

<p>Již v&nbsp;předchozích částech <a href="">seriálu o programovacím jazyku Go</a> jsme se seznámili s&nbsp;některými balíčky patřícími do standardní knihovny tohoto jazyka. Ve skutečnosti je standardní knihovna poměrně rozsáhlá a obsahuje funkce a datové typy používané především pro tvorbu síťových služeb, webových služeb, mikroslužeb, utilit používaných systémovými administrátory, aplikací ovládaných z&nbsp;příkazové řádky (CLI) apod. Naopak ve standardní knihovně nenalezneme například podporu pro tvorbu plnohodnotných desktopových aplikací s&nbsp;grafickým uživatelským rozhraním, protože (alespoň prozatím) používá většina Go aplikací s&nbsp;uživatelským rozhraním možností poskytovaných moderními webovými prohlížeči (což ostatně pro jazyk vyvinutý primárně ve společnosti Google pravděpodobně dává smysl, i když se v&nbsp;delším časovém horizontu může jednat o dvousečnou zbraň &ndash; historie IT zná už mnoho jednoúčelových programovacích jazyků, které se mimo svou niku nijak významně nerozšířily).</p>

<p>V&nbsp;dnešním článku si přiblížíme některé další možnosti poskytované standardní knihovnou. Nejprve se budeme zabývat systémem používaným pro vstup a výstup dat (a zdaleka se nejedná pouze o operace nad soubory). Mohlo by se možná zdát, že se jedná o triviální téma, ovšem například zkušenosti z&nbsp;jiných jazyků (příkladem může být Java a jejich několik generací IO a NIO knihoven) ukazují, že dobře navržená a především pak rozšiřitelná IO knihovna je pro další rozvoj jazyka velmi užitečná a důležitá. V&nbsp;jazyku Go je celý systém vstupně-výstupních operací založen na několika rozhraních, jejichž metody mohou být (a ve skutečnosti i jsou) implementovány hned několika různými způsoby a použít je lze pro různé účely. Většina těchto rozhraní obsahuje pouze jedinou metodu, což je ovšem v&nbsp;programovacím jazyku Go velmi často používané řešení, s&nbsp;nímž se setkáme nejenom ve standardní knihovně.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nejdůležitější rozhraní používaná vstupně-výstupním systémem</h2>

<p>V&nbsp;následující tabulce jsou zmíněny základní informace o rozhraních, s&nbsp;nimiž se setkáme při práci se vstupně-výstupním systémem základní knihovny programovacího jazyka Go:</p>

<table>
<tr><th>Typ operace</th><th>Čtení</th><th>Zápis</th></tr>
<tr><td>jednotlivých bajtů</td><td><a href="">ByteReader</a></td><td><a href="">ByteWriter</a></td></tr>
<tr><td>jednotlivých znaků</td><td><a href="">RuneReader</a></td><td>&times;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>jednotlivých bajtů s&nbsp;bufferem</td><td>ByteScanner</td><td>&times;</td></tr>
<tr><td>jednotlivých znaků s&nbsp;bufferem</td><td>RuneScanner</td><td>&times;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>bloku bajtů</td><td><a href="">Reader</a></td><td><a href="">Writer</a></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: připomeňme si, že v&nbsp;programovacím jazyce Go pro implementaci nějakého rozhraní postačuje pouze vytvořit metodu, jejíž hlavička odpovídá metodě předepsané v&nbsp;rozhraní. Nemusíme tedy nikde uvádět (ostatně neexistující) klíčové slovo <strong>implements</strong> tak, jako je tomu v&nbsp;některých jiných programovacích jazycích..</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Rozhraní <strong>ByteReader</strong></h2>

<p>Základním rozhraním, které může být implementováno pro prakticky libovolné vstupní zařízení, je rozhraní nazvané <strong>ByteReader</strong>. Toto rozhraní předepisuje jedinou metodu nazvanou <strong>ReadByte</strong>, která pochopitelně slouží k&nbsp;načtení jediného bajtu ze vstupu. Pokud už další bajt nelze z&nbsp;nějakého důvodu načíst, například proto, že se dosáhlo konce dat nebo došlo k&nbsp;nějaké I/O chybě (výpadek připojení, ...), vrátí se informace o chybě a první vrácená hodnota z&nbsp;metody <strong>ReadByte</strong> není obecně definována:</p>

<pre>
type <strong>ByteReader</strong> interface {
        <strong>ReadByte</strong>() (byte, error)
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že toto rozhraní nepředpokládá žádné další vlastnosti vstupního zařízení &ndash; to nemusí umět například vrátit bajt zpátky do vstupního bufferu (pokud takový buffer vůbec existuje) a už vůbec není zapotřebí umět v&nbsp;datech provádět operaci typu <i>seek</i> nebo rozpoznávat jednotlivé znaky (v&nbsp;Unicode, konkrétně v&nbsp;kódování UTF-8). Z&nbsp;tohoto důvodu najdeme metodu <strong>ReadByte</strong> (a tím pádem i celé rozhraní <strong>ByteReader</strong>) například v&nbsp;implementacích dekomprimačních algoritmů, u některých síťových protokolů atd.</div></p>

<p>Demonstrační příklad používající rozhraní nazvané <strong>ByteReader</strong> a jeho metodu <strong>ReadByte</strong> je ve skutečnosti velmi jednoduchý. Využijeme zde faktu, že metoda <strong>ReadByte</strong> je implementována i datovým typem nazvaným <strong>Reader</strong>, tentokrát ovšem definovaným v&nbsp;balíčku <strong>strings</strong> a nikoli v&nbsp;balíčku <strong>io</strong>. Konstruktor tohoto datového typu se volá funkcí <strong>NewReader</strong>, které předáme řetězec použitý jako zdroj dat:</p>

<pre>
reader := strings.NewReader("Hello world!")
</pre>

<p>Povšimněte si, jakým způsobem je realizován test na to, zda řetězec, z&nbsp;něhož načítáme jednotlivé bajty, ještě obsahuje nějaká data či zda jsme došli až na konec řetězce:</p>

<pre>
b, err := reader.ReadByte()
if err == nil {
        fmt.Printf("%c", b)
} else {
        fmt.Printf("\nerror %v", err)
        break
}
</pre>

<p>Následuje výpis <a href="">úplného zdrojového kódu</a> tohoto demonstračního příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "strings"
)
&nbsp;
func <strong>main</strong>() {
        reader := strings.NewReader("Hello world!")
        for {
                b, err := reader.ReadByte()
                if err == nil {
                        fmt.Printf("%c", b)
                } else {
                        fmt.Printf("\nerror %v", err)
                        break
                }
        }
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vylepšení testu na zdetekovaný konec dat</h2>

<p>Ve skutečnosti ovšem můžeme test na konec dat napsat daleko explicitněji, a to kontrolou, jaká konkrétní chybová hodnota se vrátila z&nbsp;metody <strong>ReadByte</strong>. V&nbsp;případě, že se vrátila hodnota odpovídající konstantě <strong>io.EOF</strong>, nejedná se o skutečnou chybu, ale o &bdquo;obyčejný&ldquo; konec dat, který většinou budeme chtít zpracovat jiným způsobem, než odlišnou chybu. Tato úprava zdrojového kódu je provedena <a href="">v&nbsp;další verzi demonstračního příkladu</a>, jenž je vypsán pod tímto odstavcem:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "io"
        "strings"
)
&nbsp;
func <strong>main</strong>() {
        reader := strings.NewReader("Hello world!")
        for {
                b, err := reader.ReadByte()
                if err == io.EOF {
                        fmt.Println("\nEOF detected")
                        break
                }
                if err == nil {
                        fmt.Printf("%c", b)
                } else {
                        fmt.Printf("\nerror %v", err)
                        break
                }
        }
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Bajty versus znaky</h2>

<p>Další komplikace může nastat v&nbsp;případě, kdy budeme potřebovat ze vstupu načítat celé <i>znaky</i> a nikoli jednotlivé dále nezpracovávané <i>bajty</i>. Připomeňme si, že v&nbsp;programovacím jazyku Go existuje striktní rozlišení mezi bajty a znaky, přičemž znaky jsou reprezentovány datovým typem nazvaným <i>rune</i>, protože je nutné rozpoznávat celý rozsah Unicode a nikoli už pouhé ASCII, které je jen nepatrnou (i když velmi důležitou) podmnožinou Unicode. Nejdříve se podívejme na způsob, jakým se vlastně zpracovávají jednotlivé bajty metodou pojmenovanou <strong>ReadByte</strong> v&nbsp;tom případě, kdy zdroj dat obsahuje znaky Unicode (samotný zdrojový kód napsaný v&nbsp;Go přitom používá kódování UTF-8, tj.&nbsp;jedno z&nbsp;nejčastějších kódování Unicode). Postačí nám nepatrná úprava předchozího demonstračního příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "io"
        "strings"
)
&nbsp;
func <strong>main</strong>() {
        reader := strings.NewReader("* ěščř ½µ§я¤ *")
        for {
                b, err := reader.ReadByte()
                if err == io.EOF {
                        fmt.Println("\nEOF detected")
                        break
                }
                if err == nil {
                        fmt.Printf("%02x ", b)
                } else {
                        fmt.Printf("\nerror %v", err)
                        break
                }
        }
}
</pre>

<p>Výsledkem by měla být sekvence bajtů vypsaných v&nbsp;hexadecimální soustavě:</p>

<pre>
2a 20 c4 9b c5 a1 c4 8d c5 99 20 c2 bd c2 b5 c2 a7 d1 8f c2 a4 20 2a 
EOF detected
</pre>

<p><div class="rs-tip-major">Poznámka: počet vypsaných hodnot a tedy i počet načtených bajtů je samozřejmě v&nbsp;tomto případě numericky vyšší, než počet znaků ve vstupním řetězci.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Rozhraní <strong>RuneReader</strong></h2>

<p>V&nbsp;případě, že skutečně budeme chtít postupně načítat jednotlivé znaky, použije se namísto rozhraní <strong>ByteReader</strong> spíše rozhraní nazvané <strong>RuneReader</strong> s&nbsp;jedinou předepsanou metodou, jejíž jméno je <strong>ReadRune</strong>. Tato metoda vrací jak načtený znak, tak i jeho velikost reprezentovanou v&nbsp;bajtech (přičemž znaky z&nbsp;původní ASCII jsou reprezentovány jedním bajtem, ostatní znaky pak více bajty). V&nbsp;případě, že se načtení dalšího znaku nezdaří, vrátí se ve třetí návratové hodnotě chyba:</p>

<pre>
type <strong>RuneReader</strong> interface {
        <strong>ReadRune</strong>() (r rune, size int, err error)
}
</pre>

<p>Samozřejmě si opět všechno vyzkoušíme v&nbsp;demonstračním příkladu, v&nbsp;němž opět použijeme objekt typu <strong>Reader</strong>, jehož zdrojem dat je obyčejný řetězec:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "io"
        "strings"
)
&nbsp;
func <strong>main</strong>() {
        reader := strings.NewReader("* ěščř ½µ§я¤ *")
        for {
                c, size, err := reader.ReadRune()
                if err == io.EOF {
                        fmt.Println("\nEOF detected")
                        break
                }
                if err == nil {
                        fmt.Printf("%c %d\n", c, size)
                } else {
                        fmt.Printf("\nerror %v", err)
                        break
                }
        }
}
</pre>

<p>V&nbsp;tomto případě by měl výsledek práce tohoto demonstračního příkladu vypadat následovně:</p>

<pre>
* 1
  1
ě 2
š 2
č 2
ř 2
  1
½ 2
µ 2
§ 2
я 2
¤ 2
  1
* 1
&nbsp;
EOF detected
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Rozhraní <strong>ByteWriter</strong></h2>

<p>Opakem rozhraní <strong>ByteReader</strong> je rozhraní, které se &ndash; což asi nebude příliš překvapující &ndash; jmenuje <strong>ByteWriter</strong>. Toto rozhraní předepisuje pouze jedinou metodu s&nbsp;názvem <strong>WriteByte</strong>, která slouží k&nbsp;zápisu bajtu do výstupního zařízení (či libovolného výstupního mechanismu) a vrací hodnotu obsahující popis případné chyby, která může při zápisu nastat:</p>

<pre>
type <strong>ByteWriter</strong> interface {
        <strong>WriteByte</strong>(c byte) error
}
</pre>

<p>Toto rozhraní je implementováno například datovým typem se jménem <strong>Buffer</strong> ze standardního balíčku <strong>bytes</strong>. Samotný buffer umožňuje zápis a čtení na úrovni jednotlivých bajtů či znaků do operační paměti, přičemž velikost bufferu se dynamicky podle potřeb mění. V&nbsp;následujícím <a href="">demonstračním příkladu</a> je buffer zpočátku prázdný a hodnoty (jednotlivé bajty) do něj zapíšeme právě metodou <strong>WriteByte</strong> a zpětně je pro kontrolu přečteme metodou <strong>ReadByte</strong>, kterou již dobře známe z&nbsp;předchozího textu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "fmt"
)
&nbsp;
func <strong>main</strong>() {
        buffer := bytes.Buffer{}
        buffer.WriteByte(65)
&nbsp;
        b, _ := buffer.ReadByte()
        fmt.Printf("%02x\n", b)
&nbsp;
        buffer.WriteByte(0xff)
&nbsp;
        b, _ = buffer.ReadByte()
        fmt.Printf("%02x\n", b)
}
</pre>

<p>V&nbsp;předchozím odstavci jsme si řekli, že <strong>buffer</strong> umožňuje, aby se čtení a zápis prováděly na úrovni jednotlivých bajtů či znaků. To nám umožňuje i kombinaci obou přístupů, tj.&nbsp;například zápis bajtů, které se následně pokusíme přečíst jako jednotlivé znaky Unicode zakódované pomocí UTF-8:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "fmt"
)
&nbsp;
func <strong>main</strong>() {
        buffer := bytes.Buffer{}
        buffer.WriteByte(65)
&nbsp;
        c, size, err := buffer.ReadRune()
        fmt.Printf("%c %d %v\n", c, size, err)
&nbsp;
        buffer.WriteByte(0xc4)
        buffer.WriteByte(0x9b)
&nbsp;
        c, size, err = buffer.ReadRune()
        fmt.Printf("%c %d %v\n", c, size, err)
&nbsp;
        c, size, err = buffer.ReadRune()
        fmt.Printf("%c %d %v\n", c, size, err)
}
</pre>

<p>Výsledek činnosti tohoto demonstračního příkladu by měl vypadat následovně:</p>

<pre>
A 1 &lt;nil&gt;
ě 2 &lt;nil&gt;
 0 EOF
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že na posledním řádku se ve skutečnosti žádný znak nevrátil &ndash; naopak se vrátila chybová hodnota oznamující, že buffer je prázdný.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zápis jednotlivých znaků metodou <strong>WriteRune</strong></h2>

<p>Vzhledem k&nbsp;tomu, že existují standardní rozhraní <strong>ByteWriter</strong>, <strong>ByteReader</strong> a <strong>RuneReader</strong>, mohlo by se očekávat, že bude existovat i rozhraní pojmenované <strong>RuneWriter</strong>. Ve skutečnosti tomu tak není, i když například již výše zmíněný typ <strong>Buffer</strong> z&nbsp;balíčku <strong>bytes</strong> obsahuje metodu nazvanou <strong>WriteRune</strong>, která by byla předepsána teoretickým rozhraním <strong>RuneWriter</strong>. Ostatně si chování této metody můžeme velmi snadno otestovat, a to překladem a spuštěním <a href="">dalšího demonstračního příkladu</a>, jehož zdrojový kód vypadá takto:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "fmt"
)
&nbsp;
func <strong>main</strong>() {
        buffer := bytes.Buffer{}
        buffer.WriteRune('a')
        buffer.WriteRune('ě')
        buffer.WriteRune('я')
&nbsp;
        for {
                b, err := buffer.ReadByte()
                if err == nil {
                        fmt.Printf("%02x ", b)
                } else {
                        fmt.Printf("\nerror %v", err)
                        break
                }
        }
}
</pre>

<p><div class="rs-tip-major">Poznámka: namísto rozhraní <strong>RuneWriter</strong> se většinou používají funkce a metody sloužící pro zápis celých řetězců, popř.&nbsp;je možné znaky před jejich zápisem převést na sekvenci bajtů. S&nbsp;tímto přístupem se setkáme později.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Rozhraní <strong>ByteScanner</strong></h2>

<p>Další dvojice rozhraní, s&nbsp;nimiž se v&nbsp;dnešním článku seznámíme, se jmenuje <strong>ByteScanner</strong> a <strong>RuneScanner</strong>. Rozhraní <strong>ByteScanner</strong> je založeno na již popsaném rozhraní <strong>ByteReader</strong>, ovšem k&nbsp;metodě <strong>ReadByte</strong> je přidána i metoda pojmenovaná <strong>UnreadByte</strong>:</p>

<pre>
type <strong>ByteScanner</strong> interface {
        ByteReader
        <strong>UnreadByte</strong>() error
}
</pre>

<p>Tato metoda &ndash; pokud ji pochopitelně nějaký datový typ implementuje &ndash; zajistí, že další volání metody <strong>ReadByte</strong> vrátí stejný bajt, jako předchozí volání této metody. Jak je popsané chování interně zajištěno, již pochopitelně závisí na tom, jaké zařízení či vstupní mechanismus je použit. Někde je možné použít vstupní buffer, jindy se zapamatuje poslední načítaný znak atd. Většinou není možné metodu <strong>UnreadByte</strong> zavolat vícekrát za sebou, a to právě z&nbsp;toho důvodu, že její interní implementace si pamatuje pouze poslední čtený znak.</p>

<p><div class="rs-tip-major">Poznámka: některé implementace, například ty založené na typu <strong>buffer</strong>, naopak umožňují prakticky libovolné volání metody <strong>UnreadByte</strong>, protože je tato metoda implementována pouhým posunem indexu či ukazatele v&nbsp;poli reprezentujícím vstupní data. Jedná se však spíše o výjimku, než o pravidlo.</div></p>

<p>Tato dvě rozhraní jsou velmi užitečná, protože v&nbsp;mnoha algoritmech se při zpracování vstupních dat dozvíme, že například nějaký blok již skončil až ve chvíli, kdy přečteme <i>následující</i> bajt či znak, který již má logicky patřit do dalšího bloku. Čistě programové řešení by většinou bylo zbytečně komplikované, takže použití rozhraní <strong>ByteScanner</strong> a <strong>RuneScanner</strong> je snadnější a čistější.</p>

<p>V&nbsp;dalším demonstračním příkladu si ukážeme použití metody <strong>UnreadByte</strong> při čtení bajtů (nikoli celých znaků!) z&nbsp;řetězce představujícího zdroj dat pro objekt typu <strong>strings.Reader</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "strings"
)
&nbsp;
func <strong>main</strong>() {
        reader := strings.NewReader("Hello world!")
        cnt := 0
&nbsp;
        for {
                b, err := reader.ReadByte()
                if err == nil {
                        fmt.Printf("%c", b)
                } else {
                        fmt.Printf("\nerror %v", err)
                        break
                }
                cnt++
                if cnt == 5 || cnt == 10 || cnt == 14 || cnt == 15 {
                        reader.UnreadByte()
                }
        }
}
</pre>

<p>Z&nbsp;výpisu produkovaného tímto příkladem je patrné, že se skutečně podařilo zdvojit pátý, desátý, čtrnáctý a patnáctý bajt v&nbsp;řetězci:</p>

<pre>
Helloo worrld!!!
error EOF
</pre>

<p>Objekt typu <strong>strings.Reader</strong> ve skutečnosti umožňuje několikanásobné zpětné vložení bajtu, protože se interně jedná pouze o posun ukazatele ve vstupních datech. Můžeme tedy napsat například:</p>

<pre>
if cnt == 6 {
        for i := 0; i &lt;= 6; i++ {
                reader.UnreadByte()
        }
}
</pre>


<p><a name="k10"></a></p>
<h2 id="k10">10. Vícenásobné vrácení bajtu do vstupu</h2>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "strings"
)
&nbsp;
func <strong>main</strong>() {
        reader := strings.NewReader("Hello world!")
        cnt := 0
&nbsp;
        for {
                b, err := reader.ReadByte()
                if err == nil {
                        fmt.Printf("%c", b)
                } else {
                        fmt.Printf("\nerror %v", err)
                        break
                }
                cnt++
                if cnt == 6 {
                        for i := 0; i &lt;= 6; i++ {
                                reader.UnreadByte()
                        }
                }
        }
}
</pre>

<p>Výsledek činnosti tohoto demonstračního příkladu by měl vypadat následovně:</p>

<pre>
Hello Hello world!
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se v&nbsp;tomto případě ve skutečnosti skutečně vrátila zpět operace čtení bajtu, nedošlo tedy k&nbsp;sedminásobnému vložení stejného bajtu do řetězce (což by platilo, pokud by čtení nenávratně mazalo vstupní data a systém by si pamatoval jen poslední načtený bajt), ale k&nbsp;posunu ukazatele na jeho začátek.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Rozhraní <strong>RuneScanner</strong></h2>

<p>Další rozhraní se stejnou filozofií, jako má výše popsané rozhraní <strong>ByteScanner</strong>, se jmenuje <strong>RuneScanner</strong>.</p>

<pre>
type <strong>RuneScanner</strong> interface {
        RuneReader
        <strong>UnreadRune</strong>() error
}
</pre>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "io"
        "strings"
)
&nbsp;
func <strong>main</strong>() {
        reader := strings.NewReader("* ěščř ½µ§я¤ *")
        cnt := 0
&nbsp;
        for {
                c, size, err := reader.ReadRune()
                if err == io.EOF {
                        fmt.Println("\nEOF detected")
                        break
                }
                if err == nil {
                        fmt.Printf("%c %d\n", c, size)
                } else {
                        fmt.Printf("\nerror %v", err)
                        break
                }
                cnt++
                if cnt == 5 || cnt == 10 || cnt == 14 || cnt == 15 {
                        reader.UnreadRune()
                }
        }
}
</pre>

<p></p>

<pre>
* 1
  1
ě 2
š 2
č 2
č 2
ř 2
  1
½ 2
µ 2
µ 2
§ 2
я 2
¤ 2
¤ 2
¤ 2
  1
* 1
&nbsp;
EOF detected
</pre>


<p><a name="k12"></a></p>
<h2 id="k12">12. Rozhraní <strong>Reader</strong></h2>

<p>Ve standardní knihovně programovacího jazyka Go nalezneme i další dvě důležitá rozhraní, s&nbsp;nimiž se dokonce v&nbsp;praxi setkáme častěji, než s&nbsp;výše zmíněnými rozhraními <strong>ByteReader</strong> a <strong>ByteWriter</strong>. První z&nbsp;těchto rozhraní předepisuje jedinou metodu určenou pro bufferované čtení dat z&nbsp;prakticky libovolného vstupního mechanismu (zařízení, souboru, roury atd.), u něhož se předpokládá, že dokáže načítat blok dat a rozeznávat jejich případný konec. Toto rozhraní se jmenuje jednoduše <strong>Reader</strong> a jediná metoda tohoto rozhraní má jméno <strong>Read</strong>:</p>

<pre>
type <strong>Reader</strong> interface {
        Read(p []byte) (n int, err error)
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Čtení bajtů ze standardního vstupu a z&nbsp;řetězce</h2>









<pre>
type <strong>StringWriter</strong> interface {
        WriteString(s string) (n int, err error)
}
</pre>



<pre>
package main
&nbsp;
import (
        "fmt"
        "io"
        "log"
        "os"
)
&nbsp;
const filename = "test_input.txt"
const buffer_size = 16
&nbsp;
func <strong>main</strong>() {
        fin, err := os.Open(filename)
        if err != nil {
                log.Fatal(err)
        }
        defer fin.Close()
&nbsp;
        buffer := make([]byte, buffer_size)
&nbsp;
        for {
                read, err := fin.Read(buffer)
&nbsp;
                if read &gt; 0 {
                        fmt.Printf("read %d bytes\n", read)
                        fmt.Println(buffer[:read])
                }
&nbsp;
                if err == io.EOF {
                        fmt.Println("reached end of file")
                        break
                }
&nbsp;
                if err != nil {
                        fmt.Printf("other error %v\n", err)
                        break
                }
        }
}
</pre>

<pre>
package main
&nbsp;
import (
        "fmt"
        "io"
        "os"
)
&nbsp;
const buffer_size = 16
&nbsp;
func <strong>main</strong>() {
        buffer := make([]byte, buffer_size)
&nbsp;
        for {
                read, err := os.Stdin.Read(buffer)
&nbsp;
                if read &gt; 0 {
                        fmt.Printf("read %d bytes\n", read)
                        fmt.Println(buffer[:read])
                }
&nbsp;
                if err == io.EOF {
                        fmt.Println("reached end of file")
                        break
                }
&nbsp;
                if err != nil {
                        fmt.Printf("other error %v\n", err)
                        break
                }
        }
}
</pre>



<pre>
package main
&nbsp;
import (
        "fmt"
        "io"
        "strings"
)
&nbsp;
const input_string = "Hello world!"
const buffer_size = 4
&nbsp;
func <strong>main</strong>() {
        r := strings.NewReader(input_string)
&nbsp;
        buffer := make([]byte, buffer_size)
&nbsp;
        for {
                read, err := r.Read(buffer)
&nbsp;
                if read &gt; 0 {
                        fmt.Printf("read %d bytes\n", read)
                        fmt.Println(buffer[:read])
                }
&nbsp;
                if err == io.EOF {
                        fmt.Println("reached end of file")
                        break
                }
&nbsp;
                if err != nil {
                        fmt.Printf("other error %v\n", err)
                        break
                }
        }
}
</pre>

<pre>
package main
&nbsp;
import (
        "fmt"
        "io"
        "strings"
)
&nbsp;
const input_string = "Hello world!"
const buffer_size = 4
&nbsp;
func <strong>main</strong>() {
        r := strings.NewReader(input_string)
&nbsp;
        buffer := make([]byte, buffer_size)
&nbsp;
        for {
                read, err := r.Read(buffer)
&nbsp;
                if read &gt; 0 {
                        fmt.Printf("read %d bytes\n", read)
                        fmt.Println(string(buffer[:read]))
                }
&nbsp;
                if err == io.EOF {
                        fmt.Println("reached end of file")
                        break
                }
&nbsp;
                if err != nil {
                        fmt.Printf("other error %v\n", err)
                        break
                }
        }
}
</pre>



<pre>
package main
&nbsp;
import (
        "fmt"
        "io"
        "strings"
)
&nbsp;
const input_string_1 = "Hello"
const input_string_2 = "world"
const input_string_3 = "!"
&nbsp;
const buffer_size = 4
&nbsp;
func <strong>main</strong>() {
        r1 := strings.NewReader(input_string_1)
        r2 := strings.NewReader(input_string_2)
        r3 := strings.NewReader(input_string_3)
        r := io.MultiReader(r1, r2, r3)
&nbsp;
        buffer := make([]byte, buffer_size)
&nbsp;
        for {
                read, err := r.Read(buffer)
&nbsp;
                if read &gt; 0 {
                        fmt.Printf("read %d bytes\n", read)
                        fmt.Println(string(buffer[:read]))
                }
&nbsp;
                if err == io.EOF {
                        fmt.Println("reached end of file")
                        break
                }
&nbsp;
                if err != nil {
                        fmt.Printf("other error %v\n", err)
                        break
                }
        }
}
</pre>



<pre>
package main
&nbsp;
import (
        "fmt"
        "log"
        "os"
)
&nbsp;
const filename = "test_output.txt"
const message = "Hello world!"
&nbsp;
func <strong>main</strong>() {
        fout, err := os.Create(filename)
        if err != nil {
                log.Fatal(err)
        }
        defer fout.Close()
&nbsp;
        buffer := []byte(message)
        written, err := fout.Write(buffer)
&nbsp;
        if written &gt; 0 {
                fmt.Printf("written %d bytes\n", written)
        }
&nbsp;
        if err != nil {
                fmt.Printf("I/O error %v\n", err)
        }
}
</pre>




<p></p>

<pre>
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Spojení více vstupů &ndash; multireader</h2>

<p></p>

<pre>
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<p></p>

<pre>
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Rozhraní <strong>Writer</strong></h2>

<p></p>

<pre>
type <strong>Writer</strong> interface {
        Write(p []byte) (n int, err error)
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<p></p>

<pre>
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Skládání rozhraní souvisejících se vstupně-výstupními operacemi</h2>

<p>Ve standardní knihovně nalezneme i rozhraní, která jsou složena z&nbsp;rozhraní jednodušších. Příkladem může být především rozhraní <strong>ReadWriter</strong> s&nbsp;oběma metodami <strong>Read</strong> i <strong>Write</strong>. Tyto metody ovšem nejsou předepsány přímo, ale nové rozhraní je skutečně složeno z&nbsp;rozhraní jednodušších:</div></p>

<pre>
type <strong>ReadWriter</strong> interface {
        Reader
        Writer
}
</pre>

<p>Podobně nalezneme ve standardní knihovně i další podobná rozhraní vycházející z&nbsp;rozhraní s&nbsp;původně jedinou metodou, zejména pak:</p>

<pre>
type <strong>ReadCloser</strong> interface {
        Reader
        Closer
}
&nbsp;
type <strong>WriteCloser</strong> interface {
        Writer
        Closer
}
&nbsp;
type <strong>ReadWriteCloser</strong> interface {
        Reader
        Writer
        Closer
}
&nbsp;
type <strong>ReadSeeker</strong> interface {
        Reader
        Seeker
}
&nbsp;
type <strong>WriteSeeker</strong> interface {
        Writer
        Seeker
}
&nbsp;
type <strong>ReadWriteSeeker</strong> interface {
        Reader
        Writer
        Seeker
}
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně dva megabajty), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/">https://github.com/tisnik/go-root/blob/master/article_22/</a></td></tr>
<tr><td> 2</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/">https://github.com/tisnik/go-root/blob/master/article_22/</a></td></tr>
<tr><td> 3</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/">https://github.com/tisnik/go-root/blob/master/article_22/</a></td></tr>
<tr><td> 4</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/">https://github.com/tisnik/go-root/blob/master/article_22/</a></td></tr>
<tr><td> 5</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/">https://github.com/tisnik/go-root/blob/master/article_22/</a></td></tr>
<tr><td> 6</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/">https://github.com/tisnik/go-root/blob/master/article_22/</a></td></tr>
<tr><td> 7</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/">https://github.com/tisnik/go-root/blob/master/article_22/</a></td></tr>
<tr><td> 8</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/">https://github.com/tisnik/go-root/blob/master/article_22/</a></td></tr>
<tr><td> 9</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/">https://github.com/tisnik/go-root/blob/master/article_22/</a></td></tr>
<tr><td>10</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/">https://github.com/tisnik/go-root/blob/master/article_22/</a></td></tr>
<tr><td>11</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/">https://github.com/tisnik/go-root/blob/master/article_22/</a></td></tr>
<tr><td>12</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/">https://github.com/tisnik/go-root/blob/master/article_22/</a></td></tr>
<tr><td>13</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/">https://github.com/tisnik/go-root/blob/master/article_22/</a></td></tr>
<tr><td>14</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/">https://github.com/tisnik/go-root/blob/master/article_22/</a></td></tr>
<tr><td>15</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/">https://github.com/tisnik/go-root/blob/master/article_22/</a></td></tr>
<tr><td>16</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/">https://github.com/tisnik/go-root/blob/master/article_22/</a></td></tr>
<tr><td>17</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_22/">https://github.com/tisnik/go-root/blob/master/article_22/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>VACUUM (SQL)<br />
<a href="https://www.sqlite.org/lang_vacuum.html">https://www.sqlite.org/lang_vacuum.html</a>
</li>

<li>VACUUM (Postgres)<br />
<a href="https://www.postgresql.org/docs/8.4/sql-vacuum.html">https://www.postgresql.org/docs/8.4/sql-vacuum.html</a>
</li>

<li>go-cron<br />
<a href="https://github.com/rk/go-cron">https://github.com/rk/go-cron</a>
</li>

<li>gocron<br />
<a href="https://github.com/jasonlvhit/gocron">https://github.com/jasonlvhit/gocron</a>
</li>

<li>clockwork<br />
<a href="https://github.com/whiteShtef/clockwork">https://github.com/whiteShtef/clockwork</a>
</li>

<li>clockwerk<br />
<a href="https://github.com/onatm/clockwerk">https://github.com/onatm/clockwerk</a>
</li>

<li>JobRunner<br />
<a href="https://github.com/bamzi/jobrunner">https://github.com/bamzi/jobrunner</a>
</li>

<li>Rethinking Cron<br />
<a href="https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/">https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/</a>
</li>

<li>In the Beginning was the Command Line<br />
<a href="https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html">https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html</a>
</li>

<li>repl.it (REPL pro různé jazyky)<br />
<a href="https://repl.it/languages">https://repl.it/languages</a>
</li>

<li>GOCUI - Go Console User Interface (celé uživatelské prostředí, nejenom input box)<br />
<a href="https://github.com/jroimartin/gocui">https://github.com/jroimartin/gocui</a>
</li>

<li>Read–eval–print loop<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>go-prompt<br />
<a href="https://github.com/c-bata/go-prompt">https://github.com/c-bata/go-prompt</a>
</li>

<li>readline<br />
<a href="https://github.com/chzyer/readline">https://github.com/chzyer/readline</a>
</li>

<li>A pure golang implementation for GNU-Readline kind library<br />
<a href="https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/">https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/</a>
</li>

<li>go-readline<br />
<a href="https://github.com/fiorix/go-readline">https://github.com/fiorix/go-readline</a>
</li>

<li>4 Python libraries for building great command-line user interfaces<br />
<a href="https://opensource.com/article/17/5/4-practical-python-libraries">https://opensource.com/article/17/5/4-practical-python-libraries</a>
</li>

<li>prompt_toolkit 2.0.3 na PyPi<br />
<a href="https://pypi.org/project/prompt_toolkit/">https://pypi.org/project/prompt_toolkit/</a>
</li>

<li>python-prompt-toolkit na GitHubu<br />
<a href="https://github.com/jonathanslenders/python-prompt-toolkit">https://github.com/jonathanslenders/python-prompt-toolkit</a>
</li>

<li>The GNU Readline Library<br />
<a href="https://tiswww.case.edu/php/chet/readline/rltop.html">https://tiswww.case.edu/php/chet/readline/rltop.html</a>
</li>

<li>GNU Readline (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Readline">https://en.wikipedia.org/wiki/GNU_Readline</a>
</li>

<li>readline — GNU readline interface (Python 3.x)<br />
<a href="https://docs.python.org/3/library/readline.html">https://docs.python.org/3/library/readline.html</a>
</li>

<li>readline — GNU readline interface (Python 2.x)<br />
<a href="https://docs.python.org/2/library/readline.html">https://docs.python.org/2/library/readline.html</a>
</li>

<li>GNU Readline Library - command line editing<br />
<a href="https://tiswww.cwru.edu/php/chet/readline/readline.html">https://tiswww.cwru.edu/php/chet/readline/readline.html</a>
</li>

<li>gnureadline 6.3.8 na PyPi<br />
<a href="https://pypi.org/project/gnureadline/">https://pypi.org/project/gnureadline/</a>
</li>

<li>Editline Library (libedit)<br />
<a href="http://thrysoee.dk/editline/">http://thrysoee.dk/editline/</a>
</li>

<li>Comparing Python Command-Line Parsing Libraries – Argparse, Docopt, and Click<br />
<a href="https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/">https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/</a>
</li>

<li>libedit or editline<br />
<a href="http://www.cs.utah.edu/~bigler/code/libedit.html">http://www.cs.utah.edu/~bigler/code/libedit.html</a>
</li>

<li>WinEditLine<br />
<a href="http://mingweditline.sourceforge.net/">http://mingweditline.sourceforge.net/</a>
</li>

<li>rlcompleter — Completion function for GNU readline<br />
<a href="https://docs.python.org/3/library/rlcompleter.html">https://docs.python.org/3/library/rlcompleter.html</a>
</li>

<li>rlwrap na GitHubu<br />
<a href="https://github.com/hanslub42/rlwrap">https://github.com/hanslub42/rlwrap</a>
</li>

<li>rlwrap(1) - Linux man page<br />
<a href="https://linux.die.net/man/1/rlwrap">https://linux.die.net/man/1/rlwrap</a>
</li>

<li>readline(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/readline">https://linux.die.net/man/3/readline</a>
</li>

<li>history(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/history">https://linux.die.net/man/3/history</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>oglematchers</i><br />
<a href="https://godoc.org/github.com/jacobsa/oglematchers">https://godoc.org/github.com/jacobsa/oglematchers</a>
</li>

<li>Balíček <i>oglematchers</i><br />
<a href="https://github.com/jacobsa/oglematchers">https://github.com/jacobsa/oglematchers</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>ogletest</i><br />
<a href="https://godoc.org/github.com/jacobsa/ogletest">https://godoc.org/github.com/jacobsa/ogletest</a>
</li>

<li>Balíček <i>ogletest</i><br />
<a href="https://github.com/jacobsa/ogletest">https://github.com/jacobsa/ogletest</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>assert</i><br />
<a href="https://godoc.org/github.com/stretchr/testify/assert">https://godoc.org/github.com/stretchr/testify/assert</a>
</li>

<li>Testify - Thou Shalt Write Tests<br />
<a href="https://github.com/stretchr/testify/">https://github.com/stretchr/testify/</a>
</li>

<li>package <strong>testing</strong><br />
<a href="https://golang.org/pkg/testing/">https://golang.org/pkg/testing/</a>
</li>

<li>Golang basics - writing unit tests<br />
<a href="https://blog.alexellis.io/golang-writing-unit-tests/">https://blog.alexellis.io/golang-writing-unit-tests/</a>
</li>

<li>An Introduction to Programming in Go / Testing<br />
<a href="https://www.golang-book.com/books/intro/12">https://www.golang-book.com/books/intro/12</a>
</li>

<li>An Introduction to Testing in Go<br />
<a href="https://tutorialedge.net/golang/intro-testing-in-go/">https://tutorialedge.net/golang/intro-testing-in-go/</a>
</li>

<li>Advanced Go Testing Tutorial<br />
<a href="https://tutorialedge.net/golang/advanced-go-testing-tutorial/">https://tutorialedge.net/golang/advanced-go-testing-tutorial/</a>
</li>

<li>GoConvey<br />
<a href="http://goconvey.co/">http://goconvey.co/</a>
</li>

<li>Testing Techniques<br />
<a href="https://talks.golang.org/2014/testing.slide">https://talks.golang.org/2014/testing.slide</a>
</li>

<li>5 simple tips and tricks for writing unit tests in #golang<br />
<a href="https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742">https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742</a>
</li>

<li>Afinní transformace<br />
<a href="https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic">https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic</a>
</li>

<li>package gg<br />
<a href="https://godoc.org/github.com/fogleman/gg">https://godoc.org/github.com/fogleman/gg</a>
</li>

<li>Generate an animated GIF with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/">http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/</a>
</li>

<li>Generate an image programmatically with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/">http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/</a>
</li>

<li>The Go image package<br />
<a href="https://blog.golang.org/go-image-package">https://blog.golang.org/go-image-package</a>
</li>

<li>Balíček draw2D: 2D rendering for different output (raster, pdf, svg)<br />
<a href="https://github.com/llgcode/draw2d">https://github.com/llgcode/draw2d</a>
</li>

<li>Draw a rectangle in Golang?<br />
<a href="https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang">https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang</a>
</li>

<li>YAML<br />
<a href="https://yaml.org/">https://yaml.org/</a>
</li>

<li>edn<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Smile<br />
<a href="https://github.com/FasterXML/smile-format-specification">https://github.com/FasterXML/smile-format-specification</a>
</li>

<li>Protocol-Buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>Marshalling (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
</li>

<li>Unmarshalling<br />
<a href="https://en.wikipedia.org/wiki/Unmarshalling">https://en.wikipedia.org/wiki/Unmarshalling</a>
</li>

<li>Introducing JSON<br />
<a href="http://json.org/">http://json.org/</a>
</li>

<li>Package json<br />
<a href="https://golang.org/pkg/encoding/json/">https://golang.org/pkg/encoding/json/</a>
</li>

<li>The Go Blog: JSON and Go<br />
<a href="https://blog.golang.org/json-and-go">https://blog.golang.org/json-and-go</a>
</li>

<li>Go by Example: JSON<br />
<a href="https://gobyexample.com/json">https://gobyexample.com/json</a>
</li>

<li>Writing Web Applications<br />
<a href="https://golang.org/doc/articles/wiki/">https://golang.org/doc/articles/wiki/</a>
</li>

<li>Golang Web Apps<br />
<a href="https://www.reinbach.com/blog/golang-webapps-1/">https://www.reinbach.com/blog/golang-webapps-1/</a>
</li>

<li>Build web application with Golang<br />
<a href="https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details">https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details</a>
</li>

<li>Golang Templates - Golang Web Pages<br />
<a href="https://www.youtube.com/watch?v=TkNIETmF-RU">https://www.youtube.com/watch?v=TkNIETmF-RU</a>
</li>

<li>Simple Golang HTTPS/TLS Examples<br />
<a href="https://github.com/denji/golang-tls">https://github.com/denji/golang-tls</a>
</li>

<li>Playing with images in HTTP response in golang<br />
<a href="https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang">https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang</a>
</li>

<li>MIME Types List<br />
<a href="https://www.freeformatter.com/mime-types-list.html">https://www.freeformatter.com/mime-types-list.html</a>
</li>

<li>Go Mutex Tutorial<br />
<a href="https://tutorialedge.net/golang/go-mutex-tutorial/">https://tutorialedge.net/golang/go-mutex-tutorial/</a>
</li>

<li>Creating A Simple Web Server With Golang<br />
<a href="https://tutorialedge.net/golang/creating-simple-web-server-with-golang/">https://tutorialedge.net/golang/creating-simple-web-server-with-golang/</a>
</li>

<li>Building a Web Server in Go<br />
<a href="https://thenewstack.io/building-a-web-server-in-go/">https://thenewstack.io/building-a-web-server-in-go/</a>
</li>

<li>How big is the pipe buffer?<br />
<a href="https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer">https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer</a>
</li>

<li>How to turn off buffering of stdout in C<br />
<a href="https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c">https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c</a>
</li>

<li>setbuf(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/setbuf">https://linux.die.net/man/3/setbuf</a>
</li>

<li>setvbuf(3) - Linux man page (stejný obsah jako předchozí stránka)<br />
<a href="https://linux.die.net/man/3/setvbuf">https://linux.die.net/man/3/setvbuf</a>
</li>

<li>Select waits on a group of channels<br />
<a href="https://yourbasic.org/golang/select-explained/">https://yourbasic.org/golang/select-explained/</a>
</li>

<li>Rob Pike: Simplicity is Complicated (video)<br />
<a href="http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893">http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893</a>
</li>

<li>Algorithms to Go<br />
<a href="https://yourbasic.org/">https://yourbasic.org/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů: vlastní filtry a lexery<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/</a>
</li>

<li>Go Defer Simplified with Practical Visuals<br />
<a href="https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff">https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff</a>
</li>

<li>5 More Gotchas of Defer in Go — Part II<br />
<a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa">https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa</a>
</li>

<li>The Go Blog: Defer, Panic, and Recover<br />
<a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a>
</li>

<li>The defer keyword in Swift 2: try/finally done right<br />
<a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer">https://www.hackingwithswift.com/new-syntax-swift-2-defer</a>
</li>

<li>Swift Defer Statement<br />
<a href="https://andybargh.com/swift-defer-statement/">https://andybargh.com/swift-defer-statement/</a>
</li>

<li>Modulo operation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Modulo_operation">https://en.wikipedia.org/wiki/Modulo_operation</a>
</li>

<li>Node.js vs Golang: Battle of the Next-Gen Languages<br />
<a href="https://www.hostingadvice.com/blog/nodejs-vs-golang/">https://www.hostingadvice.com/blog/nodejs-vs-golang/</a>
</li>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go<br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>JavaScript vs. Golang for IoT: Is Gopher Winning?<br />
<a href="https://www.iotforall.com/javascript-vs-golang-iot/">https://www.iotforall.com/javascript-vs-golang-iot/</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

<li>Printf Format Strings<br />
<a href="https://www.cprogramming.com/tutorial/printf-format-strings.html">https://www.cprogramming.com/tutorial/printf-format-strings.html</a>
</li>

<li>Java: String.format<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-</a>
</li>

<li>Java: format string syntax<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a>
</li>

<li>Selectors<br />
<a href="https://golang.org/ref/spec#Selectors">https://golang.org/ref/spec#Selectors</a>
</li>

<li>Calling Go code from Python code<br />
<a href="http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/">http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/</a>
</li>

<li>Go Data Structures: Interfaces <br />
<a href="https://research.swtch.com/interfaces">https://research.swtch.com/interfaces</a>
</li>

<li>How to use interfaces in Go<br />
<a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go</a>
</li>

<li>Interfaces in Go (part I)<br />
<a href="https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c">https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c</a>
</li>

<li>Part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>What about Trait support in Golang?<br />
<a href="https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/">https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/</a>
</li>

<li>Don't Get Bitten by Pointer vs Non-Pointer Method Receivers in Golang<br />
<a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/">https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/</a>
</li>

<li>Control Flow<br />
<a href="https://en.wikipedia.org/wiki/Control_flow">https://en.wikipedia.org/wiki/Control_flow</a>
</li>

<li>Structured programming<br />
<a href="https://en.wikipedia.org/wiki/Structured_programming">https://en.wikipedia.org/wiki/Structured_programming</a>
</li>

<li>Control Structures<br />
<a href="https://www.golang-book.com/books/intro/5">https://www.golang-book.com/books/intro/5</a>
</li>

<li>Control structures - Go if else statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html">http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html</a>
</li>

<li>Control structures - Go switch case statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html</a>
</li>

<li>Control structures - Go for loop, break, continue, range<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html</a>
</li>

<li>Single Function Exit Point<br />
<a href="http://wiki.c2.com/?SingleFunctionExitPoint">http://wiki.c2.com/?SingleFunctionExitPoint</a>
</li>

<li>Entry point<br />
<a href="https://en.wikipedia.org/wiki/Entry_point">https://en.wikipedia.org/wiki/Entry_point</a>
</li>

<li>Why does Go have a GOTO statement?!<br />
<a href="https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/">https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/</a>
</li>

<li>Effective Go<br />
<a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a>
</li>

<li>GoClipse: an Eclipse IDE for the Go programming language<br />
<a href="http://goclipse.github.io/">http://goclipse.github.io/</a>
</li>

<li>GoClipse Installation<br />
<a href="https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation">https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

