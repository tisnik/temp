<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Využití standardního balíčku "unsafe" v jazyku Go</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Využití standardního balíčku "unsafe" v jazyku Go</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Využití standardního balíčku "unsafe" v&nbsp;programovacím jazyku Go</a></p>
<p><a href="#k02">*** 2. Nápověda dostupná pro balíček <i>unsafe</i></a></p>
<p><a href="#k03">*** 3. Funkce <strong>unsafe.Sizeof</strong></a></p>
<p><a href="#k04">*** 4. Příklady použití funkce <strong>unsafe.Sizeof</strong></a></p>
<p><a href="#k05">*** 5. <strong>unsafe.Sizeof</strong> a složitější datové struktury</a></p>
<p><a href="#k06">*** 6. Vliv velikosti datových struktur na pořadí prvků</a></p>
<p><a href="#k07">*** 7. Funkce <strong>unsafe.Alignof</strong></a></p>
<p><a href="#k08">*** 8. Zarovnání u základních datových typů i u struktur</a></p>
<p><a href="#k09">*** 9. Vliv typů prvků struktury na zarovnání</a></p>
<p><a href="#k10">*** 10. Funkce <strong>unsafe.Offsetof</strong></a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Využití standardního balíčku "unsafe" v&nbsp;programovacím jazyku Go</h2>

<p>V&nbsp;seriálu <a href="https://www.root.cz/serialy/programovaci-jazyk-go/">o programovacím jazyku Go</a>, který zde na Rootu vychází, jsme si (pochopitelně kromě mnoha dalších věcí) popsali i mnoho balíčků patřících do standardní knihovny, tj.&nbsp;balíčků, které není zapotřebí samostatně instalovat a které tak mohou být součástí každé aplikace vytvořené v&nbsp;Go (existují totiž i poměrně rozsáhlé aplikace, které si kupodivu vystačí &bdquo;pouze&ldquo; se základní knihovnou tohoto jazyka). Už několikrát jsme se zmínili i o standardním balíčku nazvaném <i>unsafe</i>. Typicky jsme se s&nbsp;tímto balíčkem setkali v&nbsp;souvislosti s&nbsp;voláním nativního céčkového kódu. V&nbsp;dnešním článku si možnosti nabízené tímto balíčkem popíšeme poněkud podrobněji, pochopitelně i s&nbsp;uvedením demonstračních příkladů.</p>

<p><div class="rs-tip-major">Poznámka: jak již název balíčku <i>unsafe</i> naznačuje nebo dokonce varuje, může neopatrné použití funkcí z&nbsp;<i>unsafe</i> vést k&nbsp;pádům aplikace, například při přístupu k&nbsp;neinicializované paměti atd. Taktéž je vhodné mít na paměti, že některé operace budou plně funkční pouze na některých architekturách nebo na některých operačních systémech.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nápověda dostupná pro balíček <i>unsafe</i></h2>

<p>Vzhledem k&nbsp;tomu, že je <i>unsafe</i> standardním balíčkem, je snadné získat nápovědu s&nbsp;jeho popisem a později i nápovědu s&nbsp;popisem jednotlivých datových typů a funkcí, které jsou v&nbsp;něm implementovány.  Pokud máte nainstalovány základní nástroje Go, postačuje na příkazovém řádku napsat:</p>

<pre>
$ <strong>go doc unsafe</strong>
</pre>

<p>Povšimněte si, jak je tento balíček vlastně &bdquo;malý&ldquo; &ndash; obsahuje totiž pouze pět funkcí a tři datové typy:</p>

<pre>
package unsafe // import "unsafe"
&nbsp;
Package unsafe contains operations that step around the type safety of Go
programs.
&nbsp;
Packages that import unsafe may be non-portable and are not protected by the Go
1 compatibility guidelines.
&nbsp;
func Alignof(x ArbitraryType) uintptr
func Offsetof(x ArbitraryType) uintptr
func Sizeof(x ArbitraryType) uintptr
func String(ptr *byte, len IntegerType) string
func StringData(str string) *byte
type ArbitraryType int
    func Slice(ptr *ArbitraryType, len IntegerType) []ArbitraryType
    func SliceData(slice []ArbitraryType) *ArbitraryType
type IntegerType int
type Pointer *ArbitraryType
    func Add(ptr Pointer, len IntegerType) Pointer
</pre>

<p><div class="rs-tip-major">Poznámka: pochopitelně stále platí, že všechny veřejně dostupné symboly (v&nbsp;tomto případě se jedná o jména funkcí a typů) jsou v&nbsp;balíčku <strong>unsafe</strong> mají na začátku svého názvu velké písmeno.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Funkce <strong>unsafe.Sizeof</strong></h2>

<p></p>

<pre>
$ <strong>go doc unsafe.Sizeof</strong>
</pre>

<pre>
package unsafe // import "unsafe"
&nbsp;
func Sizeof(x ArbitraryType) uintptr
    Sizeof takes an expression x of any type and returns the size in bytes of a
    hypothetical variable v as if v was declared via var v = x. The size does
    not include any memory possibly referenced by x. For instance, if x is a
    slice, Sizeof returns the size of the slice descriptor, not the size of the
    memory referenced by the slice; if x is an interface, Sizeof returns the
    size of the interface value itself, not the size of the value stored in the
    interface. For a struct, the size includes any padding introduced by field
    alignment. The return value of Sizeof is a Go constant if the type of the
    argument x does not have variable size. (A type has variable size if it is a
    type parameter or if it is an array or struct type with elements of variable
    size).
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Příklady použití funkce <strong>unsafe.Sizeof</strong></h2>

<p></p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
func <strong>main</strong>() {
        fmt.Printf("sizeof int8       = %d byte(s)\n", unsafe.Sizeof(int8(0)))
        fmt.Printf("sizeof int16      = %d byte(s)\n", unsafe.Sizeof(int16(0)))
        fmt.Printf("sizeof int32      = %d byte(s)\n", unsafe.Sizeof(int32(0)))
        fmt.Printf("sizeof int64      = %d byte(s)\n", unsafe.Sizeof(int64(0)))
        fmt.Printf("sizeof int        = %d byte(s)\n", unsafe.Sizeof(int(0)))
        fmt.Printf("sizeof float32    = %d byte(s)\n", unsafe.Sizeof(float32(0)))
        fmt.Printf("sizeof float64    = %d byte(s)\n", unsafe.Sizeof(float64(0)))
        fmt.Printf("sizeof complex64  = %d byte(s)\n", unsafe.Sizeof(complex64(0)))
        fmt.Printf("sizeof complex128 = %d byte(s)\n", unsafe.Sizeof(complex128(0)))
        fmt.Printf("sizeof uintptr    = %d byte(s)\n", unsafe.Sizeof(uintptr(0)))
}
</pre>

<p></p>

<pre>
sizeof int8       = 1 byte(s)
sizeof int16      = 2 byte(s)
sizeof int32      = 4 byte(s)
sizeof int64      = 8 byte(s)
sizeof int        = 8 byte(s)
sizeof float32    = 4 byte(s)
sizeof float64    = 8 byte(s)
sizeof complex64  = 8 byte(s)
sizeof complex128 = 16 byte(s)
sizeof uintptr    = 8 byte(s)
</pre>

<p></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. <strong>unsafe.Sizeof</strong> a složitější datové struktury</h2>

<p></p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
func <strong>main</strong>() {
        array1 := [...]int32{1}
        array2 := [...]int32{1, 2}
        array3 := [...]int32{1, 2, 3}
&nbsp;
        slice1 := []int32{1}
        slice2 := []int32{1, 2}
        slice3 := []int32{1, 2, 3}
&nbsp;
        fmt.Printf("sizeof int    = %d byte(s)\n", unsafe.Sizeof(int32(42)))
        fmt.Println()
&nbsp;
        fmt.Printf("sizeof array1 = %d byte(s)\n", unsafe.Sizeof(array1))
        fmt.Printf("sizeof array2 = %d byte(s)\n", unsafe.Sizeof(array2))
        fmt.Printf("sizeof array3 = %d byte(s)\n", unsafe.Sizeof(array3))
        fmt.Println()
&nbsp;
        fmt.Printf("sizeof slice1 = %d byte(s)\n", unsafe.Sizeof(slice1))
        fmt.Printf("sizeof slice2 = %d byte(s)\n", unsafe.Sizeof(slice2))
        fmt.Printf("sizeof slice3 = %d byte(s)\n", unsafe.Sizeof(slice3))
}
</pre>

<p></p>

<pre>
sizeof int    = 4 byte(s)
&nbsp;
sizeof array1 = 4 byte(s)
sizeof array2 = 8 byte(s)
sizeof array3 = 12 byte(s)
&nbsp;
sizeof slice1 = 24 byte(s)
sizeof slice2 = 24 byte(s)
sizeof slice3 = 24 byte(s)
</pre>

<p></p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
type <strong>Vector2D</strong> struct {
        x float32
        y float32
}
&nbsp;
type <strong>Vector3D</strong> struct {
        x float32
        y float32
        z float32
}
&nbsp;
type <strong>User</strong> struct {
        ID      uint32
        Name    string
        Surname string
}
&nbsp;
func <strong>main</strong>() {
        vector2d := Vector2D{
                x: 10,
                y: 20,
        }
&nbsp;
        vector3d := Vector3D{
                x: 10,
                y: 20,
                z: 30,
        }
&nbsp;
        user := User{
                ID:      42,
                Name:    "Pepa",
                Surname: "Vyskoč",
        }
&nbsp;
        fmt.Printf("sizeof str      = %d byte(s)\n", unsafe.Sizeof("foo"))
        fmt.Println()
&nbsp;
        fmt.Printf("sizeof Vector2D = %d byte(s)\n", unsafe.Sizeof(vector2d))
        fmt.Printf("sizeof Vector3D = %d byte(s)\n", unsafe.Sizeof(vector3d))
        fmt.Printf("sizeof User     = %d byte(s)\n", unsafe.Sizeof(user))
        fmt.Println()
&nbsp;
        fmt.Printf("sizeof &amp;Vector2D = %d byte(s)\n", unsafe.Sizeof(&amp;vector2d))
        fmt.Printf("sizeof &amp;Vector3D = %d byte(s)\n", unsafe.Sizeof(&amp;vector3d))
        fmt.Printf("sizeof &amp;User     = %d byte(s)\n", unsafe.Sizeof(&amp;user))
}
</pre>

<p></p>

<pre>
sizeof str      = 16 byte(s)

sizeof Vector2D = 8 byte(s)
sizeof Vector3D = 12 byte(s)
sizeof User     = 40 byte(s)

sizeof &amp;Vector2D = 8 byte(s)
sizeof &amp;Vector3D = 8 byte(s)
sizeof &amp;User     = 8 byte(s)
</pre>

<p></p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
type <strong>User</strong> struct {
        ID      uint32
        Name    string
        Surname string
}
&nbsp;
func <strong>main</strong>() {
        var a *int32 = nil
        var b *int64 = nil
        var c []int32 = nil
        var d interface{} = nil
        var e map[string]string = nil
        var f chan int = nil
&nbsp;
        fmt.Printf("sizeof *int32      = %d byte(s)\n", unsafe.Sizeof(a))
        fmt.Printf("sizeof *int64      = %d byte(s)\n", unsafe.Sizeof(b))
        fmt.Printf("sizeof slice       = %d byte(s)\n", unsafe.Sizeof(c))
        fmt.Printf("sizeof {}interface = %d byte(s)\n", unsafe.Sizeof(d))
        fmt.Printf("sizeof map         = %d byte(s)\n", unsafe.Sizeof(e))
        fmt.Printf("sizeof chan        = %d byte(s)\n", unsafe.Sizeof(f))
}
</pre>

<p></p>

<pre>
sizeof *int32      = 8 byte(s)
sizeof *int64      = 8 byte(s)
sizeof slice       = 24 byte(s)
sizeof {}interface = 16 byte(s)
sizeof map         = 8 byte(s)
sizeof chan        = 8 byte(s)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vliv velikosti datových struktur na pořadí prvků</h2>

<pre>
package main

import (
        "fmt"
        "unsafe"
)

type Struct1 struct {
        x byte
        y uint16
        z uint32
}

type Struct2 struct {
        z uint32
        y uint16
        x byte
}

type Struct3 struct {
        x byte
        z uint32
        y uint16
}

type Struct4 struct {
        y uint16
        z uint32
        x byte
}

func main() {
        fmt.Printf("sizeof Struct1   = %d byte(s)\n", unsafe.Sizeof(Struct1{}))
        fmt.Printf("sizeof Struct2   = %d byte(s)\n", unsafe.Sizeof(Struct2{}))
        fmt.Printf("sizeof Struct3   = %d byte(s)\n", unsafe.Sizeof(Struct3{}))
        fmt.Printf("sizeof Struct4   = %d byte(s)\n", unsafe.Sizeof(Struct4{}))
}
</pre>

<pre>
sizeof Struct1   = 8 byte(s)
sizeof Struct2   = 8 byte(s)
sizeof Struct3   = 12 byte(s)
sizeof Struct4   = 12 byte(s)
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Funkce <strong>unsafe.Alignof</strong></h2>

<p></p>

<pre>
$ <strong>go doc unsafe.Alignof</strong>
</pre>

<pre>
package unsafe // import "unsafe"
&nbsp;
func Alignof(x ArbitraryType) uintptr
    Alignof takes an expression x of any type and returns the required
    alignment of a hypothetical variable v as if v was declared via var v = x.
    It is the largest value m such that the address of v is always zero mod m.
    It is the same as the value returned by reflect.TypeOf(x).Align().
    As a special case, if a variable s is of struct type and f is a field
    within that struct, then Alignof(s.f) will return the required alignment
    of a field of that type within a struct. This case is the same as the value
    returned by reflect.TypeOf(s.f).FieldAlign(). The return value of Alignof
    is a Go constant if the type of the argument does not have variable size.
    (See the description of Sizeof for a definition of variable sized types.)
</pre>

<p></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zarovnání u základních datových typů i u struktur</h2>

<pre>
package main

import (
        "fmt"
        "unsafe"
)

func main() {
        fmt.Printf("alignof int8       = %d byte(s)\n", unsafe.Alignof(int8(0)))
        fmt.Printf("alignof int16      = %d byte(s)\n", unsafe.Alignof(int16(0)))
        fmt.Printf("alignof int32      = %d byte(s)\n", unsafe.Alignof(int32(0)))
        fmt.Printf("alignof int64      = %d byte(s)\n", unsafe.Alignof(int64(0)))
        fmt.Printf("alignof int        = %d byte(s)\n", unsafe.Alignof(int(0)))
        fmt.Printf("alignof float32    = %d byte(s)\n", unsafe.Alignof(float32(0)))
        fmt.Printf("alignof float64    = %d byte(s)\n", unsafe.Alignof(float64(0)))
        fmt.Printf("alignof complex64  = %d byte(s)\n", unsafe.Alignof(complex64(0)))
        fmt.Printf("alignof complex128 = %d byte(s)\n", unsafe.Alignof(complex128(0)))
        fmt.Printf("alignof uintptr    = %d byte(s)\n", unsafe.Alignof(uintptr(0)))
}
</pre>

<pre>
alignof int8       = 1 byte(s)
alignof int16      = 2 byte(s)
alignof int32      = 4 byte(s)
alignof int64      = 8 byte(s)
alignof int        = 8 byte(s)
alignof float32    = 4 byte(s)
alignof float64    = 8 byte(s)
alignof complex64  = 4 byte(s)
alignof complex128 = 8 byte(s)
alignof uintptr    = 8 byte(s)
</pre>

<pre>
package main

import (
        "fmt"
        "unsafe"
)

type Vector2D struct {
        x float32
        y float32
}

type Vector3D struct {
        x float32
        y float32
        z float32
}

type User struct {
        ID      uint32
        Name    string
        Surname string
}

func main() {
        vector2d := Vector2D{
                x: 10,
                y: 20,
        }

        vector3d := Vector3D{
                x: 10,
                y: 20,
                z: 30,
        }

        user := User{
                ID:      42,
                Name:    "Pepa",
                Surname: "Vyskoč",
        }

        fmt.Printf("alignof Vector2D = %d byte(s)\n", unsafe.Alignof(vector2d))
        fmt.Printf("alignof Vector3D = %d byte(s)\n", unsafe.Alignof(vector3d))
        fmt.Printf("alignof User     = %d byte(s)\n", unsafe.Alignof(user))
        fmt.Println()
}
</pre>

<pre>
alignof Vector2D = 4 byte(s)
alignof Vector3D = 4 byte(s)
alignof User     = 8 byte(s)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vliv typů prvků struktury na zarovnání</h2>

<pre>
package main

import (
        "fmt"
        "unsafe"
)

type Struct1 struct {
        x byte
}

type Struct2 struct {
        x byte
        y byte
}

type Struct3 struct {
        x byte
        y byte
        z byte
}

type Struct4 struct {
        x byte
        y byte
        z byte
        w byte
}

func main() {
        fmt.Printf("alignof Struct1   = %d byte(s)\n", unsafe.Alignof(Struct1{}))
        fmt.Printf("alignof Struct2   = %d byte(s)\n", unsafe.Alignof(Struct2{}))
        fmt.Printf("alignof Struct3   = %d byte(s)\n", unsafe.Alignof(Struct3{}))
        fmt.Printf("alignof Struct4   = %d byte(s)\n", unsafe.Alignof(Struct4{}))
}
</pre>

<pre>
alignof Struct1   = 1 byte(s)
alignof Struct2   = 1 byte(s)
alignof Struct3   = 1 byte(s)
alignof Struct4   = 1 byte(s)
</pre>

<pre>
package main

import (
        "fmt"
        "unsafe"
)

type Struct1 struct {
        i int32
        x byte
}

type Struct2 struct {
        i int32
        x byte
        y byte
}

type Struct3 struct {
        i int32
        x byte
        y byte
        z byte
}

type Struct4 struct {
        i int32
        x byte
        y byte
        z byte
        w byte
}

func main() {
        fmt.Printf("alignof Struct1   = %d byte(s)\n", unsafe.Alignof(Struct1{}))
        fmt.Printf("alignof Struct2   = %d byte(s)\n", unsafe.Alignof(Struct2{}))
        fmt.Printf("alignof Struct3   = %d byte(s)\n", unsafe.Alignof(Struct3{}))
        fmt.Printf("alignof Struct4   = %d byte(s)\n", unsafe.Alignof(Struct4{}))
}
</pre>

<pre>
alignof Struct1   = 4 byte(s)
alignof Struct2   = 4 byte(s)
alignof Struct3   = 4 byte(s)
alignof Struct4   = 4 byte(s)
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Funkce <strong>unsafe.Offsetof</strong></h2>

<pre>
$ go doc unsafe.Offsetof
</pre>

<pre>
package unsafe // import "unsafe"
&nbsp;
func Offsetof(x ArbitraryType) uintptr
    Offsetof returns the offset within the struct of the field represented by x,
    which must be of the form structValue.field. In other words, it returns the
    number of bytes between the start of the struct and the start of the field.
    The return value of Offsetof is a Go constant if the type of the argument x
    does not have variable size. (See the description of Sizeof for a definition
    of variable sized types.)
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<pre>
package main

import (
        "fmt"
        "unsafe"
)

type Vector3D struct {
        x float32
        y float32
        z float32
}

func main() {
        vector3d := Vector3D{
                x: 10,
                y: 20,
                z: 30,
        }

        fmt.Printf("offsetof Vector3D.x = %d byte(s)\n", unsafe.Offsetof(vector3d.x))
        fmt.Printf("offsetof Vector3D.y = %d byte(s)\n", unsafe.Offsetof(vector3d.y))
        fmt.Printf("offsetof Vector3D.a = %d byte(s)\n", unsafe.Offsetof(vector3d.z))
        fmt.Println()
}
</pre>

<pre>
offsetof Vector3D.x = 0 byte(s)
offsetof Vector3D.y = 4 byte(s)
offsetof Vector3D.a = 8 byte(s)
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<pre>
package main

import (
        "fmt"
        "unsafe"
)

type Struct1 struct {
        x byte
        y uint16
        z uint32
}

type Struct2 struct {
        z uint32
        y uint16
        x byte
}

type Struct3 struct {
        x byte
        z uint32
        y uint16
}

type Struct4 struct {
        y uint16
        z uint32
        x byte
}

func main() {
        fmt.Printf("offsetof Struct1.x   = %d byte(s)\n", unsafe.Offsetof(Struct1{}.x))
        fmt.Printf("offsetof Struct1.y   = %d byte(s)\n", unsafe.Offsetof(Struct1{}.y))
        fmt.Printf("offsetof Struct1.z   = %d byte(s)\n", unsafe.Offsetof(Struct1{}.z))
        fmt.Println()
        fmt.Printf("offsetof Struct2.x   = %d byte(s)\n", unsafe.Offsetof(Struct2{}.x))
        fmt.Printf("offsetof Struct2.y   = %d byte(s)\n", unsafe.Offsetof(Struct2{}.y))
        fmt.Printf("offsetof Struct2.z   = %d byte(s)\n", unsafe.Offsetof(Struct2{}.z))
        fmt.Println()
        fmt.Printf("offsetof Struct3.x   = %d byte(s)\n", unsafe.Offsetof(Struct3{}.x))
        fmt.Printf("offsetof Struct3.y   = %d byte(s)\n", unsafe.Offsetof(Struct3{}.y))
        fmt.Printf("offsetof Struct3.z   = %d byte(s)\n", unsafe.Offsetof(Struct3{}.z))
        fmt.Println()
        fmt.Printf("offsetof Struct4.x   = %d byte(s)\n", unsafe.Offsetof(Struct4{}.x))
        fmt.Printf("offsetof Struct4.y   = %d byte(s)\n", unsafe.Offsetof(Struct4{}.y))
        fmt.Printf("offsetof Struct4.z   = %d byte(s)\n", unsafe.Offsetof(Struct4{}.z))
        fmt.Println()
}
</pre>

<pre>
offsetof Struct1.x   = 0 byte(s)
offsetof Struct1.y   = 2 byte(s)
offsetof Struct1.z   = 4 byte(s)

offsetof Struct2.x   = 6 byte(s)
offsetof Struct2.y   = 4 byte(s)
offsetof Struct2.z   = 0 byte(s)

offsetof Struct3.x   = 0 byte(s)
offsetof Struct3.y   = 8 byte(s)
offsetof Struct3.z   = 4 byte(s)

offsetof Struct4.x   = 8 byte(s)
offsetof Struct4.y   = 0 byte(s)
offsetof Struct4.z   = 4 byte(s)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<p></p>



<pre>
$ <strong>go doc unsafe.Pointer</strong>
</pre>

<pre>
package unsafe // import "unsafe"
&nbsp;
type Pointer *ArbitraryType
    Pointer represents a pointer to an arbitrary type. There are four special
    operations available for type Pointer that are not available for other
    types:
      - A pointer value of any type can be converted to a Pointer.
      - A Pointer can be converted to a pointer value of any type.
      - A uintptr can be converted to a Pointer.
      - A Pointer can be converted to a uintptr.
</pre>


<pre>
package <strong>main</strong>
&nbsp;
<i>// #include &lt;stdio.h&gt;</i>
<i>// #include &lt;stdlib.h&gt;</i>
import "C"
import "unsafe"
&nbsp;
func <strong>main</strong>() {
        cs := C.CString("Hello world!")
        C.puts(cs)
}
</pre>
<pre>
package <strong>main</strong>
&nbsp;
<i>// #include &lt;stdio.h&gt;</i>
<i>// #include &lt;stdlib.h&gt;</i>
import "C"
import "unsafe"
&nbsp;
func <strong>main</strong>() {
        cs := C.CString("Hello world!")
        C.puts(cs)
        C.free(unsafe.Pointer(cs))
}
</pre>

<p></p>

<pre>
package <strong>main</strong>
&nbsp;
<i>// #include &lt;stdio.h&gt;</i>
<i>// #include &lt;stdlib.h&gt;</i>
import "C"
import "unsafe"
&nbsp;
func <strong>main</strong>() {
        for {
                cs := C.CString("Hello world!")
                C.puts(cs)
                C.free(unsafe.Pointer(cs))
        }
}
</pre>

<p></p>

<pre>
package <strong>main</strong>
&nbsp;
<i>// #include &lt;stdio.h&gt;</i>
<i>// #include &lt;stdlib.h&gt;</i>
import "C"
import "unsafe"
&nbsp;
func <strong>main</strong>() {
        cs := C.CString("Hello world!")
        C.free(unsafe.Pointer(cs))
        C.puts(cs)
}
</pre>

<pre>
package <strong>main</strong>
&nbsp;
<i>// #include &lt;stdio.h&gt;</i>
<i>// #include &lt;stdlib.h&gt;</i>
import "C"
import "unsafe"
&nbsp;
func <strong>main</strong>() {
        cs := C.CString("Hello world!")
        C.puts(cs)
        C.free(unsafe.Pointer(cs))
        C.free(unsafe.Pointer(cs))
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<p></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<p></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<p></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

<p></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně pět až šest megabajtů), můžete namísto toho použít odkazy na
jednotlivé příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>sizeof_1.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_1.go">https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_1.go</a></td></tr>
<tr><td> 2</td><td>sizeof_2.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_2.go">https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_2.go</a></td></tr>
<tr><td> 3</td><td>sizeof_3.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_3.go">https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_3.go</a></td></tr>
<tr><td> 4</td><td>sizeof_4.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_4.go">https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_4.go</a></td></tr>
<tr><td> 5</td><td>sizeof_5.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_5.go">https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_5.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>alignof_1.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/alignof_1.go">https://github.com/tisnik/go-root/blob/master/unsafe/alignof_1.go</a></td></tr>
<tr><td> 7</td><td>alignof_2.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/alignof_2.go">https://github.com/tisnik/go-root/blob/master/unsafe/alignof_2.go</a></td></tr>
<tr><td> 8</td><td>alignof_3.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/alignof_3.go">https://github.com/tisnik/go-root/blob/master/unsafe/alignof_3.go</a></td></tr>
<tr><td> 9</td><td>alignof_4.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/alignof_4.go">https://github.com/tisnik/go-root/blob/master/unsafe/alignof_4.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>offsetof_1.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/offsetof_1.go">https://github.com/tisnik/go-root/blob/master/unsafe/offsetof_1.go</a></td></tr>
<tr><td>11</td><td>offsetof_2.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/offsetof_2.go">https://github.com/tisnik/go-root/blob/master/unsafe/offsetof_2.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/">https://github.com/tisnik/go-root/blob/master/unsafe/</a></td></tr>
<tr><td>13</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/">https://github.com/tisnik/go-root/blob/master/unsafe/</a></td></tr>
<tr><td>14</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/">https://github.com/tisnik/go-root/blob/master/unsafe/</a></td></tr>
<tr><td>15</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/">https://github.com/tisnik/go-root/blob/master/unsafe/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Unsafe package: documentation<br />
<a href="https://pkg.go.dev/unsafe">https://pkg.go.dev/unsafe</a>
</li>

<li>An Introduction to Go's `unsafe` Package: Unsafe Operations<br />
<a href="https://reintech.io/blog/introduction-to-gos-unsafe-package">https://reintech.io/blog/introduction-to-gos-unsafe-package</a>
</li>

<li>Go &amp; cgo: integrating existing C code with Go<br />
<a href="http://akrennmair.github.io/golang-cgo-slides/#1">http://akrennmair.github.io/golang-cgo-slides/#1</a>
</li>

<li>Using cgo to call C code from within Go code<br />
<a href="https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/">https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/</a>
</li>

<li>Delve: a debugger for the Go programming language.<br />
<a href="https://github.com/go-delve/delve">https://github.com/go-delve/delve</a>
</li>

<li>Příkazy debuggeru Delve<br />
<a href="https://github.com/go-delve/delve/tree/master/Documentation/cli">https://github.com/go-delve/delve/tree/master/Documentation/cli</a>
</li>

<li>Unsafe Go<br />
<a href="https://i0tool5.github.io/learnings/golang/going-unsafe/">https://i0tool5.github.io/learnings/golang/going-unsafe/</a>
</li>

<li>Unsafe Package Usage in Go<br />
<a href="https://go-cookbook.com/snippets/standard-library-packages/unsafe-package">https://go-cookbook.com/snippets/standard-library-packages/unsafe-package</a>
</li>

<li>Padding &amp; Alignment in Go<br />
<a href="https://bitstack.substack.com/p/padding-and-alignment-in-go">https://bitstack.substack.com/p/padding-and-alignment-in-go</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

