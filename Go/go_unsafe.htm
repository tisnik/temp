<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Využití standardního balíčku "unsafe" v jazyku Go</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Využití standardního balíčku "unsafe" v jazyku Go</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešní části dnes již dosti nepravidelně vycházejícího seriálu o programovacím jazyku Go si popíšeme možnosti nabízené standardním balíčkem nazvaným &bdquo;unsafe&ldquo;. I přes poněkud nebezpečně znějící název obsahuje tento balíček užitečné funkce.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Využití standardního balíčku &bdquo;unsafe&ldquo; v&nbsp;programovacím jazyku Go</a></p>
<p><a href="#k02">2. Nápověda dostupná pro balíček &bdquo;unsafe&ldquo;</a></p>
<p><a href="#k03">3. Funkce <strong>unsafe.Sizeof</strong></a></p>
<p><a href="#k04">4. Příklady použití funkce <strong>unsafe.Sizeof</strong></a></p>
<p><a href="#k05">5. <strong>unsafe.Sizeof</strong> a složitější datové struktury</a></p>
<p><a href="#k06">6. Velikost hodnot <strong>nil</strong> různého typu</a></p>
<p><a href="#k07">7. Vliv pořadí prvků ve struktuře na její celkovou velikost</a></p>
<p><a href="#k08">8. Vyhodnocení <strong>unsafe.Sizeof</strong> na konstantu</a></p>
<p><a href="#k09">9. Funkce <strong>unsafe.Alignof</strong></a></p>
<p><a href="#k10">10. Zarovnání u základních datových typů i u struktur</a></p>
<p><a href="#k11">11. Vliv typů prvků struktury na její celkové zarovnání</a></p>
<p><a href="#k12">12. Vyhodnocení <strong>unsafe.Alignof</strong> na konstantu</a></p>
<p><a href="#k13">13. Funkce <strong>unsafe.Offsetof</strong></a></p>
<p><a href="#k14">14. Přečtení offsetů jednotlivých prvků datových struktur</a></p>
<p><a href="#k15">15. Offsety prvků ve strukturách obsahujících výplňové bajty</a></p>
<p><a href="#k16">16. Datový typ <strong>unsafe.Pointer</strong></a></p>
<p><a href="#k17">17. Explicitní (ruční) alokace a dealokace paměti</a></p>
<p><a href="#k18">18. Unsafe ukazatele jsou skutečně unsafe</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Využití standardního balíčku &bdquo;unsafe&ldquo; v&nbsp;programovacím jazyku Go</h2>

<p>V&nbsp;seriálu <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">o programovacím
jazyku Go</a>, který zde na Rootu (dnes již spíše nepravidelně) vychází, jsme
si, pochopitelně kromě mnoha dalších věcí, popsali i mnoho balíčků patřících do
standardní knihovny, tj.&nbsp;balíčků, které není zapotřebí samostatně
instalovat a které tak mohou být součástí každé aplikace vytvořené
v&nbsp;jazyku Go (existují totiž i poměrně rozsáhlé aplikace, které si kupodivu
vystačí &bdquo;pouze&ldquo; se základní knihovnou tohoto jazyka). Už několikrát
jsme se zmínili i o standardním balíčku nazvaném <strong>unsafe</strong>.
Typicky jsme se s&nbsp;tímto balíčkem setkali v&nbsp;souvislosti s&nbsp;voláním
nativního céčkového kódu, zejména při práci s&nbsp;céčkovými ukazateli.
V&nbsp;dnešním článku si možnosti nabízené tímto balíčkem popíšeme poněkud
podrobněji, pochopitelně i s&nbsp;uvedením demonstračních příkladů.</p>

<p><div class="rs-tip-major">Poznámka: jak již název balíčku
<strong>unsafe</strong> naznačuje nebo dokonce varuje, může neopatrné použití
funkcí z&nbsp;<i>unsafe</i> vést k&nbsp;pádům aplikace, například při přístupu
k&nbsp;neinicializované paměti atd. Taktéž je vhodné mít na paměti, že některé
operace budou plně funkční pouze na některých architekturách nebo na některých
operačních systémech.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nápověda dostupná pro balíček &bdquo;unsafe&ldquo;</h2>

<p>Vzhledem k&nbsp;tomu, že je <strong>unsafe</strong> standardním balíčkem, je
snadné získat nápovědu s&nbsp;jeho popisem a později i nápovědu s&nbsp;popisem
jednotlivých datových typů a funkcí, které jsou v&nbsp;něm implementovány.
Pokud máte nainstalovány základní nástroje jazyka Go, postačuje pro získání
nápovědy napsat do příkazového řádku následující příkaz:</p>

<pre>
$ <strong>go doc unsafe</strong>
</pre>

<p>Povšimněte si, jak je tento balíček ve skutečnosti &bdquo;malý&ldquo;
&ndash; obsahuje totiž pouze pět veřejně dostupných (viditelných) funkcí a tři
veřejné datové typy (dokonce ani neobsahuje žádné definice konstant):</p>

<pre>
package unsafe // import "unsafe"
&nbsp;
Package unsafe contains operations that step around the type safety of Go
programs.
&nbsp;
Packages that import unsafe may be non-portable and are not protected by the Go
1 compatibility guidelines.
&nbsp;
func Alignof(x ArbitraryType) uintptr
func Offsetof(x ArbitraryType) uintptr
func Sizeof(x ArbitraryType) uintptr
func String(ptr *byte, len IntegerType) string
func StringData(str string) *byte
type ArbitraryType int
    func Slice(ptr *ArbitraryType, len IntegerType) []ArbitraryType
    func SliceData(slice []ArbitraryType) *ArbitraryType
type IntegerType int
type Pointer *ArbitraryType
    func Add(ptr Pointer, len IntegerType) Pointer
</pre>

<p><div class="rs-tip-major">Poznámka: pochopitelně stále platí, že všechny
veřejně dostupné symboly (v&nbsp;tomto případě se jedná o jména funkcí a typů)
jsou v&nbsp;balíčku <strong>unsafe</strong> mají na začátku svého názvu velké
písmeno; jinak by tyto symboly nebyly mimo svůj balíček dostupné.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Funkce <strong>unsafe.Sizeof</strong></h2>

<p>První funkcí z&nbsp;balíčku <strong>unsafe</strong>, se kterou se
v&nbsp;dnešním článku alespoň ve stručnosti seznámíme, je funkce nazvaná
<strong>Sizeof</strong>. Tato funkce umožňuje zjistit velikost paměti, kterou
je nutné rezervovat pro uložení výsledku nějakého výrazu. Ovšem je nutné si dát
pozor na to, že se nejedná o přímou obdobu operátoru <strong>sizeof</strong>
známého z&nbsp;programovacího jazyka C, protože <strong>unsafe.Sizeof</strong>
pracuje přímo s&nbsp;hodnotami a nikoli se zápisem typu.</p>

<p>Zobrazení nápovědy k&nbsp;této funkci je snadné:</p>

<pre>
$ <strong>go doc unsafe.Sizeof</strong>
</pre>

<p>Zobrazit by se měly následující informace, které si v&nbsp;rámci dalších
kapitol ověříme:</p>

<pre>
package unsafe // import "unsafe"
&nbsp;
func Sizeof(x ArbitraryType) uintptr
    Sizeof takes an expression x of any type and returns the size in bytes of a
    hypothetical variable v as if v was declared via var v = x. The size does
    not include any memory possibly referenced by x. For instance, if x is a
    slice, Sizeof returns the size of the slice descriptor, not the size of the
    memory referenced by the slice; if x is an interface, Sizeof returns the
    size of the interface value itself, not the size of the value stored in the
    interface. For a struct, the size includes any padding introduced by field
    alignment. The return value of Sizeof is a Go constant if the type of the
    argument x does not have variable size. (A type has variable size if it is a
    type parameter or if it is an array or struct type with elements of variable
    size).
</pre>

<p><div class="rs-tip-major">Poznámka: zajímavé je, že výsledkem této funkce je
hodnota typu <strong>uintptr</strong>, což by mohlo značit, že se jedná o
ukazatel. Ve skutečnosti tomu tak není a na <strong>uintptr</strong> se můžeme
spíše dívat jako na rozdíl mezi dvěma ukazateli &ndash; taková hodnota musí mít
rozsah odpovídající platformě (na 32bitových platformách nemá smysl mít
velikost/rozsah 64 bitový a naopak na 64bitových platformách nemusí 32 bitů
dostačovat). Rozsah hodnot typu <strong>uintptr</strong> se odlišuje podle
použité architektury, tj.&nbsp;má buď šířku 32 bitů nebo 64 bitů.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Příklady použití funkce <strong>unsafe.Sizeof</strong></h2>

<p>Vyzkoušejme si nyní základní způsoby použití funkce
<strong>unsafe.Sizeof</strong>. Nejdříve si necháme vypsat velikosti
numerických hodnot různých typů (jedná se skutečně o hodnoty, které pouze
konvertujeme tak, abychom získali hodnotu kýženého typu):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
func <strong>main</strong>() {
        fmt.Printf("sizeof int8       = %d byte(s)\n", unsafe.Sizeof(int8(0)))
        fmt.Printf("sizeof int16      = %d byte(s)\n", unsafe.Sizeof(int16(0)))
        fmt.Printf("sizeof int32      = %d byte(s)\n", unsafe.Sizeof(int32(0)))
        fmt.Printf("sizeof int64      = %d byte(s)\n", unsafe.Sizeof(int64(0)))
        fmt.Printf("sizeof int        = %d byte(s)\n", unsafe.Sizeof(int(0)))
        fmt.Printf("sizeof float32    = %d byte(s)\n", unsafe.Sizeof(float32(0)))
        fmt.Printf("sizeof float64    = %d byte(s)\n", unsafe.Sizeof(float64(0)))
        fmt.Printf("sizeof complex64  = %d byte(s)\n", unsafe.Sizeof(complex64(0)))
        fmt.Printf("sizeof complex128 = %d byte(s)\n", unsafe.Sizeof(complex128(0)))
        fmt.Printf("sizeof uintptr    = %d byte(s)\n", unsafe.Sizeof(uintptr(0)))
}
</pre>

<p>Výsledky mohou na 64bitové platformě vypadat následovně:</p>

<pre>
sizeof int8       = 1 byte(s)
sizeof int16      = 2 byte(s)
sizeof int32      = 4 byte(s)
sizeof int64      = 8 byte(s)
sizeof int        = 8 byte(s)
sizeof float32    = 4 byte(s)
sizeof float64    = 8 byte(s)
sizeof complex64  = 8 byte(s)
sizeof complex128 = 16 byte(s)
sizeof uintptr    = 8 byte(s)
</pre>

<p><div class="rs-tip-major">Poznámka: na 32bitových platformách se mohou
vracet různé velikosti u hodnot typů <strong>int</strong> a
<strong>uintptr</strong>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. <strong>unsafe.Sizeof</strong> a složitější datové struktury</h2>

<p>Samozřejmě je možné funkci <strong>unsafe.Sizeof</strong> použít i pro
zjištění velikosti obsazené nějakým polem nebo řezem. Nejprve si ukažme
zdrojový kód příkladu, ve kterém tyto velikosti zjišťujeme a posléze
okomentujeme vypsané výsledky:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
func <strong>main</strong>() {
        array1 := [...]int32{1}
        array2 := [...]int32{1, 2}
        array3 := [...]int32{1, 2, 3}
&nbsp;
        slice1 := []int32{1}
        slice2 := []int32{1, 2}
        slice3 := []int32{1, 2, 3}
&nbsp;
        fmt.Printf("sizeof int    = %d byte(s)\n", unsafe.Sizeof(int32(42)))
        fmt.Println()
&nbsp;
        fmt.Printf("sizeof array1 = %d byte(s)\n", unsafe.Sizeof(array1))
        fmt.Printf("sizeof array2 = %d byte(s)\n", unsafe.Sizeof(array2))
        fmt.Printf("sizeof array3 = %d byte(s)\n", unsafe.Sizeof(array3))
        fmt.Println()
&nbsp;
        fmt.Printf("sizeof slice1 = %d byte(s)\n", unsafe.Sizeof(slice1))
        fmt.Printf("sizeof slice2 = %d byte(s)\n", unsafe.Sizeof(slice2))
        fmt.Printf("sizeof slice3 = %d byte(s)\n", unsafe.Sizeof(slice3))
}
</pre>

<p>Z&nbsp;vypsaných výsledků je patrné, že u polí je jejich velikost
(v&nbsp;tomto případě) vypočtena jako
<i>počet_prvků&times;velikost_jednoho_prvku</i>, což je logické. Ovšem pozor si
musíme dát u řezů, protože se vždy vrátí pouze velikost struktury
s&nbsp;informacemi o řezu. Tato struktura obsahuje ukazatel na pole (nikoli
celé pole), kapacitu řezu a počet skutečně uložených prvků. Velikost řezu je
tedy vždy stejná &ndash; na 64bitových systémech 3&times;8 bajtů:</p>

<pre>
sizeof int    = 4 byte(s)
&nbsp;
sizeof array1 = 4 byte(s)
sizeof array2 = 8 byte(s)
sizeof array3 = 12 byte(s)
&nbsp;
sizeof slice1 = 24 byte(s)
sizeof slice2 = 24 byte(s)
sizeof slice3 = 24 byte(s)
</pre>

<p>Dále se pokusíme zjistit, jak velkou oblast paměti je nutné rezervovat pro
hodnoty, které reprezentují uživatelské datové struktury a taktéž jakou
velikost mají ukazatele na hodnoty typu struktura:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
type <strong>Vector2D</strong> struct {
        x float32
        y float32
}
&nbsp;
type <strong>Vector3D</strong> struct {
        x float32
        y float32
        z float32
}
&nbsp;
type <strong>User</strong> struct {
        ID      uint32
        Name    string
        Surname string
}
&nbsp;
func <strong>main</strong>() {
        vector2d := Vector2D{
                x: 10,
                y: 20,
        }
&nbsp;
        vector3d := Vector3D{
                x: 10,
                y: 20,
                z: 30,
        }
&nbsp;
        user := User{
                ID:      42,
                Name:    "Pepa",
                Surname: "Vyskoč",
        }
&nbsp;
        fmt.Printf("sizeof str      = %d byte(s)\n", unsafe.Sizeof("foo"))
        fmt.Println()
&nbsp;
        fmt.Printf("sizeof Vector2D = %d byte(s)\n", unsafe.Sizeof(vector2d))
        fmt.Printf("sizeof Vector3D = %d byte(s)\n", unsafe.Sizeof(vector3d))
        fmt.Printf("sizeof User     = %d byte(s)\n", unsafe.Sizeof(user))
        fmt.Println()
&nbsp;
        fmt.Printf("sizeof &amp;Vector2D = %d byte(s)\n", unsafe.Sizeof(&amp;vector2d))
        fmt.Printf("sizeof &amp;Vector3D = %d byte(s)\n", unsafe.Sizeof(&amp;vector3d))
        fmt.Printf("sizeof &amp;User     = %d byte(s)\n", unsafe.Sizeof(&amp;user))
}
</pre>

<p>V&nbsp;testovaných příkladech velikost struktury odpovídá součtu velikostí
prvků, přičemž pro typ <strong>User</strong> platí, že každý řetězec je uložen
v&nbsp;šestnácti bajtech (nejedná se totiž o vlastní řetězec, ale opět o
dvojici ukazatel+velikost, podobně jako je tomu u řezů):</p>

<pre>
sizeof str      = 16 byte(s)
&nbsp;
sizeof Vector2D = 8 byte(s)
sizeof Vector3D = 12 byte(s)
sizeof User     = 40 byte(s)
&nbsp;
sizeof &amp;Vector2D = 8 byte(s)
sizeof &amp;Vector3D = 8 byte(s)
sizeof &amp;User     = 8 byte(s)
</pre>

<p><div class="rs-tip-major">Poznámka: ovšem obecně to neplatí! Velikost
struktury může být větší než velikosti jejich prvků, což si ostatně ukážeme
v&nbsp;navazujících kapitolách.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Velikost hodnot <strong>nil</strong> různého typu</h2>

<p>V&nbsp;programovacím jazyce Go se na několika místech můžeme setkat se
speciální hodnotou <strong>nil</strong>. Tato hodnota se většinou používá pro
reprezentaci nulové hodnoty pro různé datové typy. Proměnné v&nbsp;Go jsou
totiž vždy inicializovány a pokud není ve zdrojových kódech explicitně uvedena
jejich hodnota, je automaticky provedena inicializace na hodnotu nulovou.
Z&nbsp;tohoto důvodu má <strong>nil</strong> význam především u těch datových
typů, v&nbsp;nichž je nutné neinicializovanou hodnotu nějakým způsobem
jednoznačně odlišit od ostatních hodnot. Příkladem mohou být ukazatele,
rozhraní, mapy popř.&nbsp;řezy (připomeňme si, že prázdný řez je odlišný od
řezu neinicializovaného).</p>

<p>Hodnota <strong>nil</strong> se naopak nepoužívá u číselných typů, řetězců
ani u pravdivostních hodnot, protože v&nbsp;tomto případě je vždy proměnná
inicializována &ndash; na nulu u číselných typů (celá čísla, čísla
s&nbsp;plovoucí řádovou čárkou, komplexní čísla), na prázdný řetězec u řetězců
a na hodnotu <strong>false</strong> u pravdivostních hodnot. Vše je shrnuto
v&nbsp;následující tabulce:</p>

<table>
<tr><th>Typ</th><th>Výchozí hodnota</th></tr>
<tr><td>všechny numerické typy</td><td>0, 0.0, 0.0+0.0i atd.</td></tr>
<tr><td>řetězce</td><td>""</td></tr>
<tr><td>pole</td><td>prvky rekurzivně inicializované dle této tabulky</td></tr>
<tr><td>ukazatel</td><td>nil</td></tr>
<tr><td>řez</td><td>nil</td></tr>
<tr><td>kanál</td><td>nil</td></tr>
<tr><td>mapa</td><td>nil</td></tr>
</table>

<p>V&nbsp;dalším demonstračním příkladu si otestujeme, jakým způsobem dokáže
funkce <strong>unsage.Sizeof</strong> zjistit velikosti hodnot
<strong>nil</strong>, které jsou však různého typu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
type <strong>User</strong> struct {
        ID      uint32
        Name    string
        Surname string
}
&nbsp;
func <strong>main</strong>() {
        var a *int32 = nil
        var b *int64 = nil
        var c []int32 = nil
        var d interface{} = nil
        var e map[string]string = nil
        var f chan int = nil
&nbsp;
        fmt.Printf("sizeof *int32      = %d byte(s)\n", unsafe.Sizeof(a))
        fmt.Printf("sizeof *int64      = %d byte(s)\n", unsafe.Sizeof(b))
        fmt.Printf("sizeof slice       = %d byte(s)\n", unsafe.Sizeof(c))
        fmt.Printf("sizeof {}interface = %d byte(s)\n", unsafe.Sizeof(d))
        fmt.Printf("sizeof map         = %d byte(s)\n", unsafe.Sizeof(e))
        fmt.Printf("sizeof chan        = %d byte(s)\n", unsafe.Sizeof(f))
}
</pre>

<p>Z&nbsp;výsledků je patrné, že i když ve zdrojových kódech (nebo při tisku na
terminál) vidíme hodnotu <strong>nil</strong>, může se interně jednat o bloky,
které zabírají různě velké místo v&nbsp;operační paměti:</p>

<pre>
sizeof *int32      = 8 byte(s)
sizeof *int64      = 8 byte(s)
sizeof slice       = 24 byte(s)
sizeof {}interface = 16 byte(s)
sizeof map         = 8 byte(s)
sizeof chan        = 8 byte(s)
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vliv pořadí prvků ve struktuře na její celkové velikosti</h2>

<p>Interně jsou prvky ve struktuře zarovnány způsobem, který zjistíme (o
několik kapitol níže) funkcí <strong>unsafe.Alignof</strong>. Mezi prvky
struktur tedy mohou být vkládány výplně (<i>padding</i>), jejichž existence,
umístění i velikost závisí na typu a taktéž na pořadí prvků struktury. Můžeme
si to ukázat na čtveřici struktur, které obsahují prvky stejného typu, ovšem
v&nbsp;odlišném pořadí. Už jen prohození pořadí prvků může vést k&nbsp;tomu, že
se změní celková velikost struktury:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
type <strong>Struct1</strong> struct {
        x byte
        y uint16
        z uint32
}
&nbsp;
type <strong>Struct2</strong> struct {
        z uint32
        y uint16
        x byte
}
&nbsp;
type <strong>Struct3</strong> struct {
        x byte
        z uint32
        y uint16
}
&nbsp;
type <strong>Struct4</strong> struct {
        y uint16
        z uint32
        x byte
}
&nbsp;
func <strong>main</strong>() {
        fmt.Printf("sizeof Struct1   = %d byte(s)\n", unsafe.Sizeof(Struct1{}))
        fmt.Printf("sizeof Struct2   = %d byte(s)\n", unsafe.Sizeof(Struct2{}))
        fmt.Printf("sizeof Struct3   = %d byte(s)\n", unsafe.Sizeof(Struct3{}))
        fmt.Printf("sizeof Struct4   = %d byte(s)\n", unsafe.Sizeof(Struct4{}))
}
</pre>

<p>Z&nbsp;výsledků je patrné, že v&nbsp;některých případech kvůli zarovnání
naroste velikost struktury o čtyři bajty:</p>

<pre>
sizeof Struct1   = 8 byte(s)
sizeof Struct2   = 8 byte(s)
sizeof Struct3   = 12 byte(s)
sizeof Struct4   = 12 byte(s)
</pre>

<p><div class="rs-tip-major">Poznámka: samotný nárůst je v&nbsp;tomto případě
sice minimální, ovšem pokud by se jednalo o pole či řez s&nbsp;milionem
struktur, už by se jednalo o významný údaj. Zde nám tedy může knihovna
<strong>unsafe</strong> pomoci.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vyhodnocení <strong>unsafe.Sizeof</strong> na konstantu</h2>

<p>Připomeňme si, že v&nbsp;jazyku Go je možné pracovat s&nbsp;konstantami.
Jejich hodnoty jsou vyhodnoceny v&nbsp;čase překladu. Pokud tomu tak není
(tj.&nbsp;není možné vypočítat hodnotu konstanty), bude překladač hlásit
chybu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math"
)
&nbsp;
func <strong>main</strong>() {
        const x = math.Pi / 2
        const y = math.Sin(x)
        fmt.Println("vim-go")
}
</pre>

<p>Tento program není možné přeložit, protože hodnotu konstanty
<strong>x</strong> překladač nezjistí v&nbsp;době překladu (v&nbsp;tomto
případě by ji zjistit mohl, ovšem spuštěním kódu z&nbsp;balíčku
<strong>math</strong>):</p>

<pre>
$ <strong>go build not_constant.go</strong>
&nbsp;
# command-line-arguments
./not_constant.go:10:12: math.Sin(x) (value of type float64) is not constant
</pre>

<p>Na druhou stranu výsledky volání funkce <strong>unsafe.Sizeof</strong> ve
skutečnosti konstantami jsou, což je sice poněkud zvláštní, ale velmi užitečné.
Z&nbsp;tohoto důvodu je možné přeložit a spustit i následující program:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
type <strong>Vector2D</strong> struct {
        x float32
        y float32
}
&nbsp;
type <strong>Vector3D</strong> struct {
        x float32
        y float32
        z float32
}
&nbsp;
type <strong>User</strong> struct {
        ID      uint32
        Name    string
        Surname string
}
&nbsp;
type <strong>Struct1</strong> struct {
        x byte
        y uint16
        z uint32
}
&nbsp;
type <strong>Struct2</strong> struct {
        z uint32
        y uint16
        x byte
}
&nbsp;
type <strong>Struct3</strong> struct {
        x byte
        z uint32
        y uint16
}
&nbsp;
type <strong>Struct4</strong> struct {
        y uint16
        z uint32
        x byte
}
&nbsp;
func <strong>main</strong>() {
        const s01 = unsafe.Sizeof(int8(0))
        const s02 = unsafe.Sizeof(int16(0))
        const s03 = unsafe.Sizeof(int32(0))
        const s04 = unsafe.Sizeof(int64(0))
        const s05 = unsafe.Sizeof(int(0))
        const s06 = unsafe.Sizeof(float32(0))
        const s07 = unsafe.Sizeof(float64(0))
        const s08 = unsafe.Sizeof(complex64(0))
        const s09 = unsafe.Sizeof(complex128(0))
        const s10 = unsafe.Sizeof(uintptr(0))
&nbsp;
        fmt.Printf("sizeof int8        = %d byte(s)\n", s01)
        fmt.Printf("sizeof int16       = %d byte(s)\n", s02)
        fmt.Printf("sizeof int32       = %d byte(s)\n", s03)
        fmt.Printf("sizeof int64       = %d byte(s)\n", s04)
        fmt.Printf("sizeof int         = %d byte(s)\n", s05)
        fmt.Printf("sizeof float32     = %d byte(s)\n", s06)
        fmt.Printf("sizeof float64     = %d byte(s)\n", s07)
        fmt.Printf("sizeof complex64   = %d byte(s)\n", s08)
        fmt.Printf("sizeof complex128  = %d byte(s)\n", s09)
        fmt.Printf("sizeof uintptr     = %d byte(s)\n", s10)
        fmt.Println()
&nbsp;
        array1 := [...]int32{1}
        array2 := [...]int32{1, 2}
        array3 := [...]int32{1, 2, 3}
&nbsp;
        const s11 = unsafe.Sizeof(array1)
        const s12 = unsafe.Sizeof(array2)
        const s13 = unsafe.Sizeof(array3)
&nbsp;
        fmt.Printf("sizeof array1      = %d byte(s)\n", s11)
        fmt.Printf("sizeof array2      = %d byte(s)\n", s12)
        fmt.Printf("sizeof array3      = %d byte(s)\n", s13)
        fmt.Println()
&nbsp;
        slice1 := []int32{1}
        slice2 := []int32{1, 2}
        slice3 := []int32{1, 2, 3}
&nbsp;
        const s14 = unsafe.Sizeof(slice1)
        const s15 = unsafe.Sizeof(slice2)
        const s16 = unsafe.Sizeof(slice3)
&nbsp;
        fmt.Printf("sizeof slice1      = %d byte(s)\n", s14)
        fmt.Printf("sizeof slice2      = %d byte(s)\n", s15)
        fmt.Printf("sizeof slice3      = %d byte(s)\n", s16)
        fmt.Println()
&nbsp;
        fmt.Printf("sizeof str         = %d byte(s)\n", unsafe.Sizeof("foo"))
        fmt.Println()
&nbsp;
        vector2d := Vector2D{
                x: 10,
                y: 20,
        }
&nbsp;
        vector3d := Vector3D{
                x: 10,
                y: 20,
                z: 30,
        }
&nbsp;
        user := User{
                ID:      42,
                Name:    "Pepa",
                Surname: "Vyskoč",
        }
&nbsp;
        const s17 = unsafe.Sizeof(vector2d)
        const s18 = unsafe.Sizeof(vector3d)
        const s19 = unsafe.Sizeof(user)
        const s20 = unsafe.Sizeof(&amp;vector2d)
        const s21 = unsafe.Sizeof(&amp;vector3d)
        const s22 = unsafe.Sizeof(&amp;user)
&nbsp;
        fmt.Printf("sizeof Vector2D    = %d byte(s)\n", s17)
        fmt.Printf("sizeof Vector3D    = %d byte(s)\n", s18)
        fmt.Printf("sizeof User        = %d byte(s)\n", s19)
        fmt.Println()
&nbsp;
        fmt.Printf("sizeof &amp;Vector2D   = %d byte(s)\n", s20)
        fmt.Printf("sizeof &amp;Vector3D   = %d byte(s)\n", s21)
        fmt.Printf("sizeof &amp;User       = %d byte(s)\n", s22)
&nbsp;
        var a *int32 = nil
        var b *int64 = nil
        var c []int32 = nil
        var d interface{} = nil
        var e map[string]string = nil
        var f chan int = nil
&nbsp;
        const s23 = unsafe.Sizeof(a)
        const s24 = unsafe.Sizeof(b)
        const s25 = unsafe.Sizeof(c)
        const s26 = unsafe.Sizeof(d)
        const s27 = unsafe.Sizeof(e)
        const s28 = unsafe.Sizeof(f)
&nbsp;
        const s29 = unsafe.Sizeof(Struct1{})
        const s30 = unsafe.Sizeof(Struct2{})
        const s31 = unsafe.Sizeof(Struct3{})
        const s32 = unsafe.Sizeof(Struct4{})
&nbsp;
        fmt.Printf("sizeof *int32      = %d byte(s)\n", s23)
        fmt.Printf("sizeof *int64      = %d byte(s)\n", s24)
        fmt.Printf("sizeof slice       = %d byte(s)\n", s25)
        fmt.Printf("sizeof {}interface = %d byte(s)\n", s26)
        fmt.Printf("sizeof map         = %d byte(s)\n", s27)
        fmt.Printf("sizeof chan        = %d byte(s)\n", s28)
&nbsp;
        fmt.Printf("sizeof Struct1     = %d byte(s)\n", s29)
        fmt.Printf("sizeof Struct2     = %d byte(s)\n", s30)
        fmt.Printf("sizeof Struct3     = %d byte(s)\n", s31)
        fmt.Printf("sizeof Struct4     = %d byte(s)\n", s32)
}
</pre>

<p>Výsledky budou vypadat následovně:</p>

<pre>
sizeof int8        = 1 byte(s)
sizeof int16       = 2 byte(s)
sizeof int32       = 4 byte(s)
sizeof int64       = 8 byte(s)
sizeof int         = 8 byte(s)
sizeof float32     = 4 byte(s)
sizeof float64     = 8 byte(s)
sizeof complex64   = 8 byte(s)
sizeof complex128  = 16 byte(s)
sizeof uintptr     = 8 byte(s)
&nbsp;
sizeof array1      = 4 byte(s)
sizeof array2      = 8 byte(s)
sizeof array3      = 12 byte(s)
&nbsp;
sizeof slice1      = 24 byte(s)
sizeof slice2      = 24 byte(s)
sizeof slice3      = 24 byte(s)
&nbsp;
sizeof str         = 16 byte(s)
&nbsp;
sizeof Vector2D    = 8 byte(s)
sizeof Vector3D    = 12 byte(s)
sizeof User        = 40 byte(s)
&nbsp;
sizeof &amp;Vector2D   = 8 byte(s)
sizeof &amp;Vector3D   = 8 byte(s)
sizeof &amp;User       = 8 byte(s)
sizeof *int32      = 8 byte(s)
sizeof *int64      = 8 byte(s)
sizeof slice       = 24 byte(s)
sizeof {}interface = 16 byte(s)
sizeof map         = 8 byte(s)
sizeof chan        = 8 byte(s)
sizeof Struct1     = 8 byte(s)
sizeof Struct2     = 8 byte(s)
sizeof Struct3     = 12 byte(s)
sizeof Struct4     = 12 byte(s)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Funkce <strong>unsafe.Alignof</strong></h2>

<p>Druhou funkcí z&nbsp;balíčku <strong>unsafe</strong>, se kterou se dnes
seznámíme, je funkce nazvaná <strong>unsafe.Alignof</strong>. I pro tuto funkci
je pochopitelně možné získat nápovědu:</p>

<pre>
$ <strong>go doc unsafe.Alignof</strong>
</pre>

<p>Nápověda je zobrazena na terminálu:</p>

<pre>
package unsafe // import "unsafe"
&nbsp;
func Alignof(x ArbitraryType) uintptr
    Alignof takes an expression x of any type and returns the required
    alignment of a hypothetical variable v as if v was declared via var v = x.
    It is the largest value m such that the address of v is always zero mod m.
    It is the same as the value returned by reflect.TypeOf(x).Align().
    As a special case, if a variable s is of struct type and f is a field
    within that struct, then Alignof(s.f) will return the required alignment
    of a field of that type within a struct. This case is the same as the value
    returned by reflect.TypeOf(s.f).FieldAlign(). The return value of Alignof
    is a Go constant if the type of the argument does not have variable size.
    (See the description of Sizeof for a definition of variable sized types.)
</pre>

<p>Tato funkce se do určité míry podobá <strong>unsafe.Sizef</strong>, protože
i jí je možné předat výraz libovolného typu a i navrácená hodnota je konstantní
(z&nbsp;pohledu překladače). <strong>unsafe.Alignof</strong> vrací požadované
zarovnání hodnoty v&nbsp;operační paměti. Pokud se například vrátí hodnota 2,
znamená to, že paměťový blok s&nbsp;hodnotou bude zarovnán na sudé adresy.
V&nbsp;případě, že se vrátí hodnota 8, bude zarovnání provedeno na adresy
dělitelné osmi atd. Ve všech případech se předpokládá, že adresování probíhá po
bajtech.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zarovnání u základních datových typů i u struktur</h2>

<p>Otestujme si nyní, jak musí být zarovnány hodnoty základních datových typů
v&nbsp;paměti. Je to snadné:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
func <strong>main</strong>() {
        fmt.Printf("alignof int8       = %d byte(s)\n", unsafe.Alignof(int8(0)))
        fmt.Printf("alignof int16      = %d byte(s)\n", unsafe.Alignof(int16(0)))
        fmt.Printf("alignof int32      = %d byte(s)\n", unsafe.Alignof(int32(0)))
        fmt.Printf("alignof int64      = %d byte(s)\n", unsafe.Alignof(int64(0)))
        fmt.Printf("alignof int        = %d byte(s)\n", unsafe.Alignof(int(0)))
        fmt.Printf("alignof float32    = %d byte(s)\n", unsafe.Alignof(float32(0)))
        fmt.Printf("alignof float64    = %d byte(s)\n", unsafe.Alignof(float64(0)))
        fmt.Printf("alignof complex64  = %d byte(s)\n", unsafe.Alignof(complex64(0)))
        fmt.Printf("alignof complex128 = %d byte(s)\n", unsafe.Alignof(complex128(0)))
        fmt.Printf("alignof uintptr    = %d byte(s)\n", unsafe.Alignof(uintptr(0)))
}
</pre>

<p>Výsledky pro 64bitovou platformu vypadají takto:</p>

<pre>
alignof int8       = 1 byte(s)
alignof int16      = 2 byte(s)
alignof int32      = 4 byte(s)
alignof int64      = 8 byte(s)
alignof int        = 8 byte(s)
alignof float32    = 4 byte(s)
alignof float64    = 8 byte(s)
alignof complex64  = 4 byte(s)
alignof complex128 = 8 byte(s)
alignof uintptr    = 8 byte(s)
</pre>

<p>Podobným způsobem je možné zjistit i zarovnání celých struktur
v&nbsp;paměti:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
type <strong>Vector2D</strong> struct {
        x float32
        y float32
}
&nbsp;
type <strong>Vector3D</strong> struct {
        x float32
        y float32
        z float32
}
&nbsp;
type <strong>User</strong> struct {
        ID      uint32
        Name    string
        Surname string
}
&nbsp;
func <strong>main</strong>() {
        vector2d := Vector2D{
                x: 10,
                y: 20,
        }
&nbsp;
        vector3d := Vector3D{
                x: 10,
                y: 20,
                z: 30,
        }
&nbsp;
        user := User{
                ID:      42,
                Name:    "Pepa",
                Surname: "Vyskoč",
        }
&nbsp;
        fmt.Printf("alignof Vector2D = %d byte(s)\n", unsafe.Alignof(vector2d))
        fmt.Printf("alignof Vector3D = %d byte(s)\n", unsafe.Alignof(vector3d))
        fmt.Printf("alignof User     = %d byte(s)\n", unsafe.Alignof(user))
        fmt.Println()
}
</pre>

<p>Výsledky mohou být v&nbsp;tomto případě poněkud překvapivé, protože ukazují,
že se zarovnání může odlišovat, i když by se mohlo předpokládat, že bude vždy
stejné (32 nebo 64 bitů, v&nbsp;závislosti na platformě). Ovšem ve skutečnosti
je zarovnání celé struktury omezeno zarovnáním jejích prvků:</p>

<pre>
alignof Vector2D = 4 byte(s)
alignof Vector3D = 4 byte(s)
alignof User     = 8 byte(s)
</pre>

<p><div class="rs-tip-major">Poznámka: struktury jsou v&nbsp;jazyku Go
<i>hodnotovými typy</i>, nikoli <i>referencemi</i> (což je případ objektů
v&nbsp;Javě a struktur v&nbsp;Pythonu).</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vliv typů prvků struktury na její celkové zarovnání</h2>

<p>Celkové zarovnání struktury do značné míry závisí na tom, jaké typy prvků
struktura obsahuje a v&nbsp;jakém pořadí jsou ve struktuře uloženy. Opět si to
otestujme na jednoduchém demonstračním příkladu se strukturami obsahujícími
prvky typu <strong>byte</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
type <strong>Struct1</strong> struct {
        x byte
}
&nbsp;
type <strong>Struct2</strong> struct {
        x byte
        y byte
}
&nbsp;
type <strong>Struct3</strong> struct {
        x byte
        y byte
        z byte
}
&nbsp;
type <strong>Struct4</strong> struct {
        x byte
        y byte
        z byte
        w byte
}
&nbsp;
func <strong>main</strong>() {
        fmt.Printf("alignof Struct1   = %d byte(s)\n", unsafe.Alignof(Struct1{}))
        fmt.Printf("alignof Struct2   = %d byte(s)\n", unsafe.Alignof(Struct2{}))
        fmt.Printf("alignof Struct3   = %d byte(s)\n", unsafe.Alignof(Struct3{}))
        fmt.Printf("alignof Struct4   = %d byte(s)\n", unsafe.Alignof(Struct4{}))
}
</pre>

<p>Pro struktury s&nbsp;prvky typu <strong>byte</strong> se (nezávisle na počtu
prvků) vždy vrátí zarovnání 1, tedy vlastně žádné speciální zarovnání:</p>

<pre>
alignof Struct1   = 1 byte(s)
alignof Struct2   = 1 byte(s)
alignof Struct3   = 1 byte(s)
alignof Struct4   = 1 byte(s)
</pre>

<p>Jinak je tomu ovšem tehdy, pokud struktury obsahují prvky typu
<strong>int32</strong>, <strong>float32</strong> či například
<strong>float64</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
type <strong>Struct1</strong> struct {
        i int32
        x byte
}
&nbsp;
type <strong>Struct2</strong> struct {
        i int32
        x byte
        y byte
}
&nbsp;
type <strong>Struct3</strong> struct {
        i int32
        x byte
        y byte
        z byte
}
&nbsp;
type <strong>Struct4</strong> struct {
        i int32
        x byte
        y byte
        z byte
        w byte
}
&nbsp;
func <strong>main</strong>() {
        fmt.Printf("alignof Struct1   = %d byte(s)\n", unsafe.Alignof(Struct1{}))
        fmt.Printf("alignof Struct2   = %d byte(s)\n", unsafe.Alignof(Struct2{}))
        fmt.Printf("alignof Struct3   = %d byte(s)\n", unsafe.Alignof(Struct3{}))
        fmt.Printf("alignof Struct4   = %d byte(s)\n", unsafe.Alignof(Struct4{}))
}
</pre>

<p>Nyní je vynuceno zarovnání na adresu dělitelnou čtyřmi:</p>

<pre>
alignof Struct1   = 4 byte(s)
alignof Struct2   = 4 byte(s)
alignof Struct3   = 4 byte(s)
alignof Struct4   = 4 byte(s)
</pre>

<p><div class="rs-tip-major">Poznámka: dokážete sami odhadnout, jaké bude
zarovnání celé struktury, pokud bude struktura začínat prvkem typu
<strong>byte</strong> a teprve dalším prvkem typu
<strong>int32</strong>?</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vyhodnocení <strong>unsafe.Alignof</strong> na konstantu</h2>

<p>I funkce <strong>unsafe.Alignof</strong> je zvláštní tím, že se vyhodnocuje
v&nbsp;čase překladu, takže její výsledek je možné uložit do konstanty. To je
ukázáno v&nbsp;dalším demonstračním příkladu, ve kterém výsledky všech volání
této funkce uložíme do konstant a teprve hodnoty těchto konstant jsou
vypsány:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
type <strong>Vector2D</strong> struct {
        x float32
        y float32
}
&nbsp;
type <strong>Vector3D</strong> struct {
        x float32
        y float32
        z float32
}
&nbsp;
type <strong>User</strong> struct {
        ID      uint32
        Name    string
        Surname string
}
&nbsp;
type <strong>Struct1</strong> struct {
        x byte
}
&nbsp;
type <strong>Struct2</strong> struct {
        x byte
        y byte
}
&nbsp;
type <strong>Struct3</strong> struct {
        x byte
        y byte
        z byte
}
&nbsp;
type <strong>Struct4</strong> struct {
        x byte
        y byte
        z byte
        w byte
}
&nbsp;
type <strong>Struct5</strong> struct {
        i int32
        x byte
}
&nbsp;
type <strong>Struct6</strong> struct {
        i int32
        x byte
        y byte
}
&nbsp;
type <strong>Struct7</strong> struct {
        i int32
        x byte
        y byte
        z byte
}
&nbsp;
type <strong>Struct8</strong> struct {
        i int32
        x byte
        y byte
        z byte
        w byte
}
&nbsp;
func <strong>main</strong>() {
        const c01 = unsafe.Alignof(int8(0))
        const c02 = unsafe.Alignof(int16(0))
        const c03 = unsafe.Alignof(int32(0))
        const c04 = unsafe.Alignof(int64(0))
        const c05 = unsafe.Alignof(int(0))
        const c06 = unsafe.Alignof(float32(0))
        const c07 = unsafe.Alignof(float64(0))
        const c08 = unsafe.Alignof(complex64(0))
        const c09 = unsafe.Alignof(complex128(0))
        const c10 = unsafe.Alignof(uintptr(0))
&nbsp;
        fmt.Printf("alignof int8       = %d byte(s)\n", c01)
        fmt.Printf("alignof int16      = %d byte(s)\n", c02)
        fmt.Printf("alignof int32      = %d byte(s)\n", c03)
        fmt.Printf("alignof int64      = %d byte(s)\n", c04)
        fmt.Printf("alignof int        = %d byte(s)\n", c05)
        fmt.Printf("alignof float32    = %d byte(s)\n", c06)
        fmt.Printf("alignof float64    = %d byte(s)\n", c07)
        fmt.Printf("alignof complex64  = %d byte(s)\n", c08)
        fmt.Printf("alignof complex128 = %d byte(s)\n", c09)
        fmt.Printf("alignof uintptr    = %d byte(s)\n", c10)
        fmt.Println()
&nbsp;
        vector2d := Vector2D{
                x: 10,
                y: 20,
        }
&nbsp;
        vector3d := Vector3D{
                x: 10,
                y: 20,
                z: 30,
        }
&nbsp;
        user := User{
                ID:      42,
                Name:    "Pepa",
                Surname: "Vyskoč",
        }
&nbsp;
        const c11 = unsafe.Alignof(vector2d)
        const c12 = unsafe.Alignof(vector3d)
        const c13 = unsafe.Alignof(user)
&nbsp;
        fmt.Printf("alignof Vector2D   = %d byte(s)\n", c11)
        fmt.Printf("alignof Vector3D   = %d byte(s)\n", c12)
        fmt.Printf("alignof User       = %d byte(s)\n", c13)
        fmt.Println()
&nbsp;
        const c14 = unsafe.Alignof(Struct1{})
        const c15 = unsafe.Alignof(Struct2{})
        const c16 = unsafe.Alignof(Struct3{})
        const c17 = unsafe.Alignof(Struct4{})
&nbsp;
        fmt.Printf("alignof Struct1    = %d byte(s)\n", c14)
        fmt.Printf("alignof Struct2    = %d byte(s)\n", c15)
        fmt.Printf("alignof Struct3    = %d byte(s)\n", c16)
        fmt.Printf("alignof Struct4    = %d byte(s)\n", c17)
        fmt.Println()
&nbsp;
        const c18 = unsafe.Alignof(Struct5{})
        const c19 = unsafe.Alignof(Struct6{})
        const c20 = unsafe.Alignof(Struct7{})
        const c21 = unsafe.Alignof(Struct8{})
&nbsp;
        fmt.Printf("alignof Struct5    = %d byte(s)\n", c18)
        fmt.Printf("alignof Struct6    = %d byte(s)\n", c19)
        fmt.Printf("alignof Struct7    = %d byte(s)\n", c20)
        fmt.Printf("alignof Struct8    = %d byte(s)\n", c21)
}
</pre>

<p>Tento zdrojový kód bude stále přeložitelný a po svém spuštění by měl vypsat
následující zprávy:</p>

<pre>
alignof int8       = 1 byte(s)
alignof int16      = 2 byte(s)
alignof int32      = 4 byte(s)
alignof int64      = 8 byte(s)
alignof int        = 8 byte(s)
alignof float32    = 4 byte(s)
alignof float64    = 8 byte(s)
alignof complex64  = 4 byte(s)
alignof complex128 = 8 byte(s)
alignof uintptr    = 8 byte(s)
&nbsp;
alignof Vector2D   = 4 byte(s)
alignof Vector3D   = 4 byte(s)
alignof User       = 8 byte(s)
&nbsp;
alignof Struct1    = 1 byte(s)
alignof Struct2    = 1 byte(s)
alignof Struct3    = 1 byte(s)
alignof Struct4    = 1 byte(s)
&nbsp;
alignof Struct5    = 4 byte(s)
alignof Struct6    = 4 byte(s)
alignof Struct7    = 4 byte(s)
alignof Struct8    = 4 byte(s)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Funkce <strong>unsafe.Offsetof</strong></h2>

<p>Třetí funkcí z&nbsp;balíčku <strong>unsafe</strong>, s&nbsp;níž se dnes
setkáme, je funkce nazvaná <strong>unsafe.Offsetof</strong>. I pro ni je
pochopitelně připravena nápověda:</p>

<pre>
$ <strong>go doc unsafe.Offsetof</strong>
</pre>

<p>Nápověda zobrazená na terminálu:</p>

<pre>
package unsafe // import "unsafe"
&nbsp;
func Offsetof(x ArbitraryType) uintptr
    Offsetof returns the offset within the struct of the field represented by x,
    which must be of the form structValue.field. In other words, it returns the
    number of bytes between the start of the struct and the start of the field.
    The return value of Offsetof is a Go constant if the type of the argument x
    does not have variable size. (See the description of Sizeof for a definition
    of variable sized types.)
</pre>

<p>Tato funkce slouží k&nbsp;výpočtu (relativního) offsetu zvoleného prvku
libovolné struktury. Výsledkem je opět konstantní hodnota. Tuto funkci je možné
s&nbsp;výhodou použít pro zjištění, ve kterých místech struktury jsou použity
výplňové bajty (<i>padding</i>), které zvětšují celkovou velikost struktury a
vedou i ke zpomalení běhu aplikace (kvůli vyšší pravděpodobnosti výpadku
cachí).</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Přečtení offsetů jednotlivých prvků datových struktur</h2>

<p>Funkci <strong>unsafe.Offsetof</strong> otestujeme na datové struktuře
<strong>Vector3D</strong>, která obsahuje trojici prvků typu
<strong>float32</strong>. Zjistíme offsety všech tří prvků, které jsou následně
vypsány na terminál:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
type <strong>Vector3D</strong> struct {
        x float32
        y float32
        z float32
}
&nbsp;
func <strong>main</strong>() {
        vector3d := Vector3D{
                x: 10,
                y: 20,
                z: 30,
        }
&nbsp;
        fmt.Printf("offsetof Vector3D.x = %d byte(s)\n", unsafe.Offsetof(vector3d.x))
        fmt.Printf("offsetof Vector3D.y = %d byte(s)\n", unsafe.Offsetof(vector3d.y))
        fmt.Printf("offsetof Vector3D.a = %d byte(s)\n", unsafe.Offsetof(vector3d.z))
        fmt.Println()
}
</pre>

<p>Zobrazené výsledky by v&nbsp;tomto případě neměly být překvapivé, protože
již víme, že se pro hodnoty typu <strong>float32</strong> nepoužívají výplně a
zarovnání musí být nastaveno na adresy dělitelné čtyřmi (což splňuje i celá
struktura):</p>

<pre>
offsetof Vector3D.x = 0 byte(s)
offsetof Vector3D.y = 4 byte(s)
offsetof Vector3D.a = 8 byte(s)
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Offsety prvků ve strukturách obsahujících výplňové bajty</h2>

<p>V&nbsp;případě, že datové struktury obsahují výplňové bajty
(<i>padding</i>), bude jejich velikost vrácená funkcí
<strong>unsafe.Sizeof</strong> větší, než pouhý součet velikostí jednotlivých
prvků takové struktury. A současně se pozici výplňových bajtů (nepřímo) dozvíme
právě z&nbsp;výsledků získaných funkcí <strong>unsafe.Offsetof</strong>. Můžeme
si to ostatně velmi snadno otestovat na strukturách, které se liší pořadím
prvků s&nbsp;různými bitovými šířkami:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
type <strong>Struct1</strong> struct {
        x byte
        y byte
        z byte
}
&nbsp;
type <strong>Struct2</strong> struct {
        x byte
        y byte
        z uint32
}
&nbsp;
type <strong>Struct3</strong> struct {
        x byte
        y uint32
        z byte
}
&nbsp;
type <strong>Struct4</strong> struct {
        x uint32
        y byte
        z byte
}
&nbsp;
type <strong>Struct5</strong> struct {
        x byte
        y uint16
        z uint32
}
&nbsp;
type <strong>Struct6</strong> struct {
        z uint32
        y uint16
        x byte
}
&nbsp;
type <strong>Struct7</strong> struct {
        x byte
        z uint32
        y uint16
}
&nbsp;
type <strong>Struct8</strong> struct {
        y uint16
        z uint32
        x byte
}
&nbsp;
func <strong>main</strong>() {
        fmt.Printf("offsetof Struct1.x   = %d byte(s)\n", unsafe.Offsetof(Struct1{}.x))
        fmt.Printf("offsetof Struct1.y   = %d byte(s)\n", unsafe.Offsetof(Struct1{}.y))
        fmt.Printf("offsetof Struct1.z   = %d byte(s)\n", unsafe.Offsetof(Struct1{}.z))
        fmt.Println()
        fmt.Printf("offsetof Struct2.x   = %d byte(s)\n", unsafe.Offsetof(Struct2{}.x))
        fmt.Printf("offsetof Struct2.y   = %d byte(s)\n", unsafe.Offsetof(Struct2{}.y))
        fmt.Printf("offsetof Struct2.z   = %d byte(s)\n", unsafe.Offsetof(Struct2{}.z))
        fmt.Println()
        fmt.Printf("offsetof Struct3.x   = %d byte(s)\n", unsafe.Offsetof(Struct3{}.x))
        fmt.Printf("offsetof Struct3.y   = %d byte(s)\n", unsafe.Offsetof(Struct3{}.y))
        fmt.Printf("offsetof Struct3.z   = %d byte(s)\n", unsafe.Offsetof(Struct3{}.z))
        fmt.Println()
        fmt.Printf("offsetof Struct4.x   = %d byte(s)\n", unsafe.Offsetof(Struct4{}.x))
        fmt.Printf("offsetof Struct4.y   = %d byte(s)\n", unsafe.Offsetof(Struct4{}.y))
        fmt.Printf("offsetof Struct4.z   = %d byte(s)\n", unsafe.Offsetof(Struct4{}.z))
        fmt.Println()
        fmt.Printf("offsetof Struct5.x   = %d byte(s)\n", unsafe.Offsetof(Struct5{}.x))
        fmt.Printf("offsetof Struct5.y   = %d byte(s)\n", unsafe.Offsetof(Struct5{}.y))
        fmt.Printf("offsetof Struct5.z   = %d byte(s)\n", unsafe.Offsetof(Struct5{}.z))
        fmt.Println()
        fmt.Printf("offsetof Struct6.x   = %d byte(s)\n", unsafe.Offsetof(Struct6{}.x))
        fmt.Printf("offsetof Struct6.y   = %d byte(s)\n", unsafe.Offsetof(Struct6{}.y))
        fmt.Printf("offsetof Struct6.z   = %d byte(s)\n", unsafe.Offsetof(Struct6{}.z))
        fmt.Println()
        fmt.Printf("offsetof Struct7.x   = %d byte(s)\n", unsafe.Offsetof(Struct7{}.x))
        fmt.Printf("offsetof Struct7.y   = %d byte(s)\n", unsafe.Offsetof(Struct7{}.y))
        fmt.Printf("offsetof Struct7.z   = %d byte(s)\n", unsafe.Offsetof(Struct7{}.z))
        fmt.Println()
        fmt.Printf("offsetof Struct8.x   = %d byte(s)\n", unsafe.Offsetof(Struct8{}.x))
        fmt.Printf("offsetof Struct8.y   = %d byte(s)\n", unsafe.Offsetof(Struct8{}.y))
        fmt.Printf("offsetof Struct8.z   = %d byte(s)\n", unsafe.Offsetof(Struct8{}.z))
        fmt.Println()
}
</pre>

<p>Povšimněte si, že v&nbsp;některých případech výplňové bajty použity nejsou
(<strong>Struct1</strong>), ovšem v&nbsp;případě, že na sebe například navazují
prvky <strong>byte+uint32</strong> se již výplňové bajty používají
(<strong>Struct2</strong> a mnohé další struktury z&nbsp;tohoto příkladu):</p>

<pre>
offsetof Struct1.x   = 0 byte(s)
offsetof Struct1.y   = 1 byte(s)
offsetof Struct1.z   = 2 byte(s)
&nbsp;
offsetof Struct2.x   = 0 byte(s)
offsetof Struct2.y   = 1 byte(s)
offsetof Struct2.z   = 4 byte(s)
&nbsp;
offsetof Struct3.x   = 0 byte(s)
offsetof Struct3.y   = 4 byte(s)
offsetof Struct3.z   = 8 byte(s)
&nbsp;
offsetof Struct4.x   = 0 byte(s)
offsetof Struct4.y   = 4 byte(s)
offsetof Struct4.z   = 5 byte(s)
&nbsp;
offsetof Struct5.x   = 0 byte(s)
offsetof Struct5.y   = 2 byte(s)
offsetof Struct5.z   = 4 byte(s)
&nbsp;
offsetof Struct6.x   = 6 byte(s)
offsetof Struct6.y   = 4 byte(s)
offsetof Struct6.z   = 0 byte(s)
&nbsp;
offsetof Struct7.x   = 0 byte(s)
offsetof Struct7.y   = 8 byte(s)
offsetof Struct7.z   = 4 byte(s)
&nbsp;
offsetof Struct8.x   = 8 byte(s)
offsetof Struct8.y   = 0 byte(s)
offsetof Struct8.z   = 4 byte(s)
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Datový typ <strong>unsafe.Pointer</strong></h2>

<p>Ve standardní knihovně <strong>unsafe</strong> nalezneme i definice tří
datových typů. Jedním z&nbsp;nejdůležitějších (a nyní skutečně
&bdquo;nebezpečných&ldquo;) typů je <strong>unsafe.Pointer</strong>. Tento typ
se používá především ve chvíli, kdy je nutné volat nativní kód, který je
vytvořen například v&nbsp;programovacím jazyku C atd.:</p>

<pre>
$ <strong>go doc unsafe.Pointer</strong>
</pre>

<p>Nápověda k&nbsp;tomuto datovému typu:</p>

<pre>
package unsafe // import "unsafe"
&nbsp;
type Pointer *ArbitraryType
    Pointer represents a pointer to an arbitrary type. There are four special
    operations available for type Pointer that are not available for other
    types:
      - A pointer value of any type can be converted to a Pointer.
      - A Pointer can be converted to a pointer value of any type.
      - A uintptr can be converted to a Pointer.
      - A Pointer can be converted to a uintptr.
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Explicitní (ruční) alokace a dealokace paměti</h2>

<p>Jak jsme si řekli <a href="#k16">v&nbsp;předchozí kapitole</a>, používá se
datový typ <strong>unsafe.Pointer</strong> například při volání nativního
céčkového kódu atd. To je ukázáno v&nbsp;dalším demonstračním příkladu, ve
kterém je nejdříve v&nbsp;operační paměti alokován céčkovský řetězec (což je
odlišná struktura, než řetězec v&nbsp;jazyce Go!) a následně je zavolána
céčkovská funkce <strong>puts</strong>, která tento řetězec vypíše na terminál.
Povšimněte si, že céčkovské funkce se volají přes pseudobalíček nazvaný
<strong>C</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
<i>// #include &lt;stdio.h&gt;</i>
<i>// #include &lt;stdlib.h&gt;</i>
import "C"
import "unsafe"
&nbsp;
func <strong>main</strong>() {
        cs := C.CString("Hello world!")
        C.puts(cs)
}
</pre>

<p>Výše uvedený demonstrační příklad ovšem není korektní, protože céčkovský
řetězec nebude uvolněn správcem paměti jazyka Go. O uvolnění se musíme
explicitně postarat sami zavoláním céčkovské funkce <strong>free</strong>
&ndash; a právě zde se objevuje první použití typu
<strong>unsafe.Pointer</strong> použitý pro přetypování:</p>

<pre>
package <strong>main</strong>
&nbsp;
<i>// #include &lt;stdio.h&gt;</i>
<i>// #include &lt;stdlib.h&gt;</i>
import "C"
import "unsafe"
&nbsp;
func <strong>main</strong>() {
        cs := C.CString("Hello world!")
        C.puts(cs)
        C.free(unsafe.Pointer(cs))
}
</pre>

<p>Ostatně sami se můžeme snadno přesvědčit, že nebude docházet k&nbsp;OOM, a
to ani v&nbsp;případě, že se bude alokace+dealokace provádět opakovaně:</p>

<pre>
package <strong>main</strong>
&nbsp;
<i>// #include &lt;stdio.h&gt;</i>
<i>// #include &lt;stdlib.h&gt;</i>
import "C"
import "unsafe"
&nbsp;
func <strong>main</strong>() {
        for {
                cs := C.CString("Hello world!")
                C.puts(cs)
                C.free(unsafe.Pointer(cs))
        }
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Unsafe ukazatele jsou skutečně unsafe</h2>

<p>V&nbsp;programovacím jazyce Go se při práci s&nbsp;běžnými ukazateli hlídá
oblast platnosti hodnot, jejichž adresa je uložena v&nbsp;ukazateli. To
například znamená, že správce paměti hodnotu neuvolní z&nbsp;paměti ve chvíli,
kdy stále existuje ukazatel s&nbsp;její adresou atd. Ovšem u <i>unsafe</i>
ukazatelů tomu tak není, takže může docházet k&nbsp;několika problémům, které
je nutné řešit podobně, jako v&nbsp;běžném céčku &ndash; tedy ručně a bez
pomoci překladače.</p>

<p>Příkladem může být uvolnění bloku paměti s&nbsp;následným přístupem do
tohoto bloku přes unsafe ukazatel:</p>

<pre>
package <strong>main</strong>
&nbsp;
<i>// #include &lt;stdio.h&gt;</i>
<i>// #include &lt;stdlib.h&gt;</i>
import "C"
import "unsafe"
&nbsp;
func <strong>main</strong>() {
        cs := C.CString("Hello world!")
        C.free(unsafe.Pointer(cs))
        C.puts(cs)
}
</pre>

<p><div class="rs-tip-major">Poznámka: zde bychom již neměli volat
<strong>C.puts</strong>, protože nám paměť s&nbsp;řetězcem již nepatří. Chování
tohoto programu je nedefinované a obecně chybné.</div></p>

<p>Již uvolněný blok paměti není možné znovu uvolnit, na což nás může (ale
nemusí) upozornit runtime knihovna jazyka C:</p>

<pre>
package <strong>main</strong>
&nbsp;
<i>// #include &lt;stdio.h&gt;</i>
<i>// #include &lt;stdlib.h&gt;</i>
import "C"
import "unsafe"
&nbsp;
func <strong>main</strong>() {
        cs := C.CString("Hello world!")
        C.puts(cs)
        C.free(unsafe.Pointer(cs))
        C.free(unsafe.Pointer(cs))
}
</pre>

<p>Opět se jedná o nedefinované a obecně chybné chování. Na mém systému dojde
k&nbsp;detekci problému a pádu aplikace (<strong>SIGABRT</strong>):</p>

<pre>
free(): double free detected in tcache 2
SIGABRT: abort
PC=0x7f239b7d2034 m=0 sigcode=18446744073709551610
signal arrived during cgo execution
&nbsp;
goroutine 1 gp=0xc0000061c0 m=0 mp=0x4fbe40 [syscall]:
runtime.cgocall(0x46ada0, 0xc000080ef8)
	/usr/lib/golang/src/runtime/cgocall.go:167 +0x4b fp=0xc000080ed0 sp=0xc000080e98 pc=0x45d4cb
main._Cfunc_free(0x38996050)
	_cgo_gotypes.go:77 +0x3f fp=0xc000080ef8 sp=0xc000080ed0 pc=0x46aaff
main.main.func2(0x38996050)
	/home/ptisnovs/xy/unsafe/unsafe_pointer_5.go:12 +0x34 fp=0xc000080f28 sp=0xc000080ef8 pc=0x46acd4
main.main()
	/home/ptisnovs/xy/unsafe/unsafe_pointer_5.go:12 +0x4f fp=0xc000080f50 sp=0xc000080f28 pc=0x46ac8f
runtime.main()
	/usr/lib/golang/src/runtime/proc.go:272 +0x28b fp=0xc000080fe0 sp=0xc000080f50 pc=0x43370b
runtime.goexit({})
	/usr/lib/golang/src/runtime/asm_amd64.s:1700 +0x1 fp=0xc000080fe8 sp=0xc000080fe0 pc=0x4664e1
&nbsp;
goroutine 2 gp=0xc000006c40 m=nil [force gc (idle)]:
runtime.gopark(0x0?, 0x0?, 0x0?, 0x0?, 0x0?)
	/usr/lib/golang/src/runtime/proc.go:424 +0xce fp=0xc000068fa8 sp=0xc000068f88 pc=0x46016e
runtime.goparkunlock(...)
	/usr/lib/golang/src/runtime/proc.go:430
runtime.forcegchelper()
	/usr/lib/golang/src/runtime/proc.go:337 +0xb3 fp=0xc000068fe0 sp=0xc000068fa8 pc=0x433a53
runtime.goexit({})
	/usr/lib/golang/src/runtime/asm_amd64.s:1700 +0x1 fp=0xc000068fe8 sp=0xc000068fe0 pc=0x4664e1
created by runtime.init.7 in goroutine 1
	/usr/lib/golang/src/runtime/proc.go:325 +0x1a
&nbsp;
goroutine 3 gp=0xc000007180 m=nil [GC sweep wait]:
runtime.gopark(0x0?, 0x0?, 0x0?, 0x0?, 0x0?)
	/usr/lib/golang/src/runtime/proc.go:424 +0xce fp=0xc000069780 sp=0xc000069760 pc=0x46016e
runtime.goparkunlock(...)
	/usr/lib/golang/src/runtime/proc.go:430
runtime.bgsweep(0xc00002a080)
	/usr/lib/golang/src/runtime/mgcsweep.go:277 +0x94 fp=0xc0000697c8 sp=0xc000069780 pc=0x41f9b4
runtime.gcenable.gowrap1()
	/usr/lib/golang/src/runtime/mgc.go:204 +0x25 fp=0xc0000697e0 sp=0xc0000697c8 pc=0x414325
runtime.goexit({})
	/usr/lib/golang/src/runtime/asm_amd64.s:1700 +0x1 fp=0xc0000697e8 sp=0xc0000697e0 pc=0x4664e1
created by runtime.gcenable in goroutine 1
	/usr/lib/golang/src/runtime/mgc.go:204 +0x66
&nbsp;
goroutine 4 gp=0xc000007340 m=nil [GC scavenge wait]:
runtime.gopark(0xc00002a080?, 0x49bd40?, 0x1?, 0x0?, 0xc000007340?)
	/usr/lib/golang/src/runtime/proc.go:424 +0xce fp=0xc000069f78 sp=0xc000069f58 pc=0x46016e
runtime.goparkunlock(...)
	/usr/lib/golang/src/runtime/proc.go:430
runtime.(*scavengerState).park(0x4fb080)
	/usr/lib/golang/src/runtime/mgcscavenge.go:425 +0x49 fp=0xc000069fa8 sp=0xc000069f78 pc=0x41d3e9
runtime.bgscavenge(0xc00002a080)
	/usr/lib/golang/src/runtime/mgcscavenge.go:653 +0x3c fp=0xc000069fc8 sp=0xc000069fa8 pc=0x41d95c
runtime.gcenable.gowrap2()
	/usr/lib/golang/src/runtime/mgc.go:205 +0x25 fp=0xc000069fe0 sp=0xc000069fc8 pc=0x4142c5
runtime.goexit({})
	/usr/lib/golang/src/runtime/asm_amd64.s:1700 +0x1 fp=0xc000069fe8 sp=0xc000069fe0 pc=0x4664e1
created by runtime.gcenable in goroutine 1
	/usr/lib/golang/src/runtime/mgc.go:205 +0xa5
&nbsp;
rax    0x0
rbx    0x16b5bb
rcx    0x7f239b7d2034
rdx    0x6
rdi    0x16b5bb
rsi    0x16b5bb
rbp    0x7ffe3ab331f0
rsp    0x7ffe3ab331b0
r8     0xffffffff
r9     0x0
r10    0x8
r11    0x246
r12    0x7f239b735740
r13    0x7ffe3ab33330
r14    0x6
r15    0x7ffe3ab33330
rip    0x7f239b7d2034
rflags 0x246
cs     0x33
fs     0x0
gs     0x0
exit status 2
</pre>

<p><div class="rs-tip-major">Poznámka: hodně štěstí při ladění Go kódu
kombinovaného s&nbsp;nativním kódem.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně pět až šest megabajtů), můžete namísto toho použít odkazy na
jednotlivé příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>sizeof_1.go</td><td>zjištění velikosti hodnot standardních primitivních datových typů</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_1.go">https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_1.go</a></td></tr>
<tr><td> 2</td><td>sizeof_2.go</td><td>zjištění velikosti polí a řezů (<i>slices</i>)</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_2.go">https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_2.go</a></td></tr>
<tr><td> 3</td><td>sizeof_3.go</td><td>zjištění velikosti hodnot, jejichž typy jsou definovány uživatelskými strukturami</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_3.go">https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_3.go</a></td></tr>
<tr><td> 4</td><td>sizeof_4.go</td><td>zjištění velikosti hodnot <strong>nil</strong>, které jsou různých typů</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_4.go">https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_4.go</a></td></tr>
<tr><td> 5</td><td>sizeof_5.go</td><td>vliv pořadí prvků ve struktuře na její celkové velikosti</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_5.go">https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_5.go</a></td></tr>
<tr><td> 6</td><td>sizeof_6.go</td><td>vyhodnocení <strong>unsafe.Sizeof</strong> na konstantu</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_6.go">https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_6.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>alignof_1.go</td><td>zjištění zarovnání u základních datových typů</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/alignof_1.go">https://github.com/tisnik/go-root/blob/master/unsafe/alignof_1.go</a></td></tr>
<tr><td> 8</td><td>alignof_2.go</td><td>zjištění zarovnání u uživatelských datových struktur</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/alignof_2.go">https://github.com/tisnik/go-root/blob/master/unsafe/alignof_2.go</a></td></tr>
<tr><td> 9</td><td>alignof_3.go</td><td>vliv typů prvků struktury na její celkové zarovnání (první varianta příkladu)</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/alignof_3.go">https://github.com/tisnik/go-root/blob/master/unsafe/alignof_3.go</a></td></tr>
<tr><td>10</td><td>alignof_4.go</td><td>vliv typů prvků struktury na její celkové zarovnání (druhá varianta příkladu)</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/alignof_4.go">https://github.com/tisnik/go-root/blob/master/unsafe/alignof_4.go</a></td></tr>
<tr><td>11</td><td>alignof_5.go</td><td>hodnota zarovnání je konstantou</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/alignof_5.go">https://github.com/tisnik/go-root/blob/master/unsafe/alignof_5.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>offsetof_1.go</td><td>přečtení offsetů jednotlivých prvků datových struktur</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/offsetof_1.go">https://github.com/tisnik/go-root/blob/master/unsafe/offsetof_1.go</a></td></tr>
<tr><td>13</td><td>offsetof_2.go</td><td>offsety prvků ve strukturách obsahujících výplňové bajty</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/offsetof_2.go">https://github.com/tisnik/go-root/blob/master/unsafe/offsetof_2.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>unsafe_pointer_1.go</td><td>nízkoúrovňová alokace a dealokace céčkového řetězce</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/unsafe_pointer_1.go">https://github.com/tisnik/go-root/blob/master/unsafe/unsafe_pointer_1.go</a></td></tr>
<tr><td>15</td><td>unsafe_pointer_2.go</td><td>detekce, zda dojde k&nbsp;OOM</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/unsafe_pointer_2.go">https://github.com/tisnik/go-root/blob/master/unsafe/unsafe_pointer_2.go</a></td></tr>
<tr><td>16</td><td>unsafe_pointer_3.go</td><td>dealokace paměti v&nbsp;bloku <strong>defer</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/unsafe_pointer_3.go">https://github.com/tisnik/go-root/blob/master/unsafe/unsafe_pointer_3.go</a></td></tr>
<tr><td>17</td><td>unsafe_pointer_4.go</td><td>nekorektní dealokace paměti (na špatném místě)</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/unsafe_pointer_4.go">https://github.com/tisnik/go-root/blob/master/unsafe/unsafe_pointer_4.go</a></td></tr>
<tr><td>18</td><td>unsafe_pointer_5.go</td><td>dvojí dealokace stejného bloku paměti (<i>double free</i>)</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/unsafe_pointer_5.go">https://github.com/tisnik/go-root/blob/master/unsafe/unsafe_pointer_5.go</a></td></tr>
<tr><td>19</td><td>unsafe_slice_1.go</td><td>převod Go řetězců na céčkové řetězce a naopak</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/unsafe_slice_1.go">https://github.com/tisnik/go-root/blob/master/unsafe/unsafe_slice_1.go</a></td></tr>
<tr><td>20</td><td>unsafe_slice_2.go</td><td>základní způsob využití typu <strong>unsafe.Slice</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/unsafe_slice_2.go">https://github.com/tisnik/go-root/blob/master/unsafe/unsafe_slice_2.go</a></td></tr>
<tr><td>21</td><td>unsafe_slice_3.go</td><td>další způsob využití typu <strong>unsafe.Slice</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/unsafe_slice_3.go">https://github.com/tisnik/go-root/blob/master/unsafe/unsafe_slice_3.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Unsafe package: documentation<br />
<a href="https://pkg.go.dev/unsafe">https://pkg.go.dev/unsafe</a>
</li>

<li>An Introduction to Go's `unsafe` Package: Unsafe Operations<br />
<a href="https://reintech.io/blog/introduction-to-gos-unsafe-package">https://reintech.io/blog/introduction-to-gos-unsafe-package</a>
</li>

<li>Go &amp; cgo: integrating existing C code with Go<br />
<a href="http://akrennmair.github.io/golang-cgo-slides/#1">http://akrennmair.github.io/golang-cgo-slides/#1</a>
</li>

<li>Using cgo to call C code from within Go code<br />
<a href="https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/">https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/</a>
</li>

<li>Delve: a debugger for the Go programming language.<br />
<a href="https://github.com/go-delve/delve">https://github.com/go-delve/delve</a>
</li>

<li>Příkazy debuggeru Delve<br />
<a href="https://github.com/go-delve/delve/tree/master/Documentation/cli">https://github.com/go-delve/delve/tree/master/Documentation/cli</a>
</li>

<li>Unsafe Go<br />
<a href="https://i0tool5.github.io/learnings/golang/going-unsafe/">https://i0tool5.github.io/learnings/golang/going-unsafe/</a>
</li>

<li>Unsafe Package Usage in Go<br />
<a href="https://go-cookbook.com/snippets/standard-library-packages/unsafe-package">https://go-cookbook.com/snippets/standard-library-packages/unsafe-package</a>
</li>

<li>Padding &amp; Alignment in Go<br />
<a href="https://bitstack.substack.com/p/padding-and-alignment-in-go">https://bitstack.substack.com/p/padding-and-alignment-in-go</a>
</li>

<li>How to Use Unsafe in Go Without Killing Your Service<br />
<a href="https://dev.to/devflex-pro/how-to-use-unsafe-in-go-without-killing-your-service-699">https://dev.to/devflex-pro/how-to-use-unsafe-in-go-without-killing-your-service-699</a>
</li>

<li>Understanding Struct Padding in Go: In-Depth Guide<br />
<a href="https://kushallabs.com/understanding-struct-padding-in-go-in-depth-guide-ed70c0432c63">https://kushallabs.com/understanding-struct-padding-in-go-in-depth-guide-ed70c0432c63</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

