<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Využití standardního balíčku "unsafe" v jazyku Go</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Využití standardního balíčku "unsafe" v jazyku Go</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešní části dnes již dosti nepravidelně vycházejícího seriálu o programovacím jazyku Go si popíšeme možnosti nabízené standardním balíčkem nazvaným &bdquo;unsafe&ldquo;. I přes poněkud nebezpečně znějící název obsahuje tento balíček užitečné funkce.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Využití standardního balíčku &bdquo;unsafe&ldquo; v&nbsp;programovacím jazyku Go</a></p>
<p><a href="#k02">2. Nápověda dostupná pro balíček &bdquo;unsafe&ldquo;</a></p>
<p><a href="#k03">3. Funkce <strong>unsafe.Sizeof</strong></a></p>
<p><a href="#k04">4. Příklady použití funkce <strong>unsafe.Sizeof</strong></a></p>
<p><a href="#k05">5. <strong>unsafe.Sizeof</strong> a složitější datové struktury</a></p>
<p><a href="#k06">6. Velikost hodnot <strong>nil</strong> různého typu</a></p>
<p><a href="#k07">7. Vliv pořadí prvků ve struktuře na její celkovou velikost</a></p>
<p><a href="#k08">8. Vyhodnocení <strong>unsafe.Sizeof</strong> na konstantu</a></p>
<p><a href="#k09">9. Funkce <strong>unsafe.Alignof</strong></a></p>
<p><a href="#k10">10. Zarovnání u základních datových typů i u struktur</a></p>
<p><a href="#k11">*** 11. Vliv typů prvků struktury na její celkové zarovnání</a></p>
<p><a href="#k12">*** 12. Vyhodnocení <strong>unsafe.Alignof</strong> na konstantu</a></p>
<p><a href="#k13">13. Funkce <strong>unsafe.Offsetof</strong></a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Využití standardního balíčku &bdquo;unsafe&ldquo; v&nbsp;programovacím jazyku Go</h2>

<p>V&nbsp;seriálu <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">o programovacím
jazyku Go</a>, který zde na Rootu (dnes již spíše nepravidelně) vychází, jsme
si, pochopitelně kromě mnoha dalších věcí, popsali i mnoho balíčků patřících do
standardní knihovny, tj.&nbsp;balíčků, které není zapotřebí samostatně
instalovat a které tak mohou být součástí každé aplikace vytvořené
v&nbsp;jazyku Go (existují totiž i poměrně rozsáhlé aplikace, které si kupodivu
vystačí &bdquo;pouze&ldquo; se základní knihovnou tohoto jazyka). Už několikrát
jsme se zmínili i o standardním balíčku nazvaném <strong>unsafe</strong>.
Typicky jsme se s&nbsp;tímto balíčkem setkali v&nbsp;souvislosti s&nbsp;voláním
nativního céčkového kódu, zejména při práci s&nbsp;céčkovými ukazateli.
V&nbsp;dnešním článku si možnosti nabízené tímto balíčkem popíšeme poněkud
podrobněji, pochopitelně i s&nbsp;uvedením demonstračních příkladů.</p>

<p><div class="rs-tip-major">Poznámka: jak již název balíčku
<strong>unsafe</strong> naznačuje nebo dokonce varuje, může neopatrné použití
funkcí z&nbsp;<i>unsafe</i> vést k&nbsp;pádům aplikace, například při přístupu
k&nbsp;neinicializované paměti atd. Taktéž je vhodné mít na paměti, že některé
operace budou plně funkční pouze na některých architekturách nebo na některých
operačních systémech.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nápověda dostupná pro balíček &bdquo;unsafe&ldquo;</h2>

<p>Vzhledem k&nbsp;tomu, že je <strong>unsafe</strong> standardním balíčkem, je
snadné získat nápovědu s&nbsp;jeho popisem a později i nápovědu s&nbsp;popisem
jednotlivých datových typů a funkcí, které jsou v&nbsp;něm implementovány.
Pokud máte nainstalovány základní nástroje jazyka Go, postačuje pro získání
nápovědy napsat do příkazového řádku následující příkaz:</p>

<pre>
$ <strong>go doc unsafe</strong>
</pre>

<p>Povšimněte si, jak je tento balíček ve skutečnosti &bdquo;malý&ldquo;
&ndash; obsahuje totiž pouze pět veřejně dostupných (viditelných) funkcí a tři
veřejné datové typy (dokonce ani neobsahuje žádné definice konstant):</p>

<pre>
package unsafe // import "unsafe"
&nbsp;
Package unsafe contains operations that step around the type safety of Go
programs.
&nbsp;
Packages that import unsafe may be non-portable and are not protected by the Go
1 compatibility guidelines.
&nbsp;
func Alignof(x ArbitraryType) uintptr
func Offsetof(x ArbitraryType) uintptr
func Sizeof(x ArbitraryType) uintptr
func String(ptr *byte, len IntegerType) string
func StringData(str string) *byte
type ArbitraryType int
    func Slice(ptr *ArbitraryType, len IntegerType) []ArbitraryType
    func SliceData(slice []ArbitraryType) *ArbitraryType
type IntegerType int
type Pointer *ArbitraryType
    func Add(ptr Pointer, len IntegerType) Pointer
</pre>

<p><div class="rs-tip-major">Poznámka: pochopitelně stále platí, že všechny
veřejně dostupné symboly (v&nbsp;tomto případě se jedná o jména funkcí a typů)
jsou v&nbsp;balíčku <strong>unsafe</strong> mají na začátku svého názvu velké
písmeno; jinak by tyto symboly nebyly mimo svůj balíček dostupné.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Funkce <strong>unsafe.Sizeof</strong></h2>

<p>První funkcí z&nbsp;balíčku <strong>unsafe</strong>, se kterou se
v&nbsp;dnešním článku alespoň ve stručnosti seznámíme, je funkce nazvaná
<strong>Sizeof</strong>. Tato funkce umožňuje zjistit velikost paměti, kterou
je nutné rezervovat pro uložení výsledku nějakého výrazu. Ovšem je nutné si dát
pozor na to, že se nejedná o přímou obdobu operátoru <strong>sizeof</strong>
známého z&nbsp;programovacího jazyka C, protože <strong>unsafe.Sizeof</strong>
pracuje přímo s&nbsp;hodnotami a nikoli se zápisem typu.</p>

<p>Zobrazení nápovědy k&nbsp;této funkci je snadné:</p>

<pre>
$ <strong>go doc unsafe.Sizeof</strong>
</pre>

<p>Zobrazit by se měly následující informace, které si v&nbsp;rámci dalších
kapitol ověříme:</p>

<pre>
package unsafe // import "unsafe"
&nbsp;
func Sizeof(x ArbitraryType) uintptr
    Sizeof takes an expression x of any type and returns the size in bytes of a
    hypothetical variable v as if v was declared via var v = x. The size does
    not include any memory possibly referenced by x. For instance, if x is a
    slice, Sizeof returns the size of the slice descriptor, not the size of the
    memory referenced by the slice; if x is an interface, Sizeof returns the
    size of the interface value itself, not the size of the value stored in the
    interface. For a struct, the size includes any padding introduced by field
    alignment. The return value of Sizeof is a Go constant if the type of the
    argument x does not have variable size. (A type has variable size if it is a
    type parameter or if it is an array or struct type with elements of variable
    size).
</pre>

<p><div class="rs-tip-major">Poznámka: zajímavé je, že výsledkem této funkce je
hodnota typu <strong>uintptr</strong>, což by mohlo značit, že se jedná o
ukazatel. Ve skutečnosti tomu tak není a na <strong>uintptr</strong> se můžeme
spíše dívat jako na rozdíl mezi dvěma ukazateli &ndash; taková hodnota musí mít
rozsah odpovídající platformě (na 32bitových platformách nemá smysl mít
velikost/rozsah 64 bitový a naopak na 64bitových platformách nemusí 32 bitů
dostačovat). Rozsah hodnot typu <strong>uintptr</strong> se odlišuje podle
použité architektury, tj.&nbsp;má buď šířku 32 bitů nebo 64 bitů.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Příklady použití funkce <strong>unsafe.Sizeof</strong></h2>

<p>Vyzkoušejme si nyní základní způsoby použití funkce
<strong>unsafe.Sizeof</strong>. Nejdříve si necháme vypsat velikosti
numerických hodnot různých typů (jedná se skutečně o hodnoty, které pouze
konvertujeme tak, abychom získali hodnotu kýženého typu):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
func <strong>main</strong>() {
        fmt.Printf("sizeof int8       = %d byte(s)\n", unsafe.Sizeof(int8(0)))
        fmt.Printf("sizeof int16      = %d byte(s)\n", unsafe.Sizeof(int16(0)))
        fmt.Printf("sizeof int32      = %d byte(s)\n", unsafe.Sizeof(int32(0)))
        fmt.Printf("sizeof int64      = %d byte(s)\n", unsafe.Sizeof(int64(0)))
        fmt.Printf("sizeof int        = %d byte(s)\n", unsafe.Sizeof(int(0)))
        fmt.Printf("sizeof float32    = %d byte(s)\n", unsafe.Sizeof(float32(0)))
        fmt.Printf("sizeof float64    = %d byte(s)\n", unsafe.Sizeof(float64(0)))
        fmt.Printf("sizeof complex64  = %d byte(s)\n", unsafe.Sizeof(complex64(0)))
        fmt.Printf("sizeof complex128 = %d byte(s)\n", unsafe.Sizeof(complex128(0)))
        fmt.Printf("sizeof uintptr    = %d byte(s)\n", unsafe.Sizeof(uintptr(0)))
}
</pre>

<p>Výsledky mohou na 64bitové platformě vypadat následovně:</p>

<pre>
sizeof int8       = 1 byte(s)
sizeof int16      = 2 byte(s)
sizeof int32      = 4 byte(s)
sizeof int64      = 8 byte(s)
sizeof int        = 8 byte(s)
sizeof float32    = 4 byte(s)
sizeof float64    = 8 byte(s)
sizeof complex64  = 8 byte(s)
sizeof complex128 = 16 byte(s)
sizeof uintptr    = 8 byte(s)
</pre>

<p><div class="rs-tip-major">Poznámka: na 32bitových platformách se mohou
vracet různé velikosti u hodnot typů <strong>int</strong> a
<strong>uintptr</strong>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. <strong>unsafe.Sizeof</strong> a složitější datové struktury</h2>

<p>Samozřejmě je možné funkci <strong>unsafe.Sizeof</strong> použít i pro
zjištění velikosti obsazené nějakým polem nebo řezem. Nejprve si ukažme
zdrojový kód příkladu, ve kterém tyto velikosti zjišťujeme a posléze
okomentujeme vypsané výsledky:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
func <strong>main</strong>() {
        array1 := [...]int32{1}
        array2 := [...]int32{1, 2}
        array3 := [...]int32{1, 2, 3}
&nbsp;
        slice1 := []int32{1}
        slice2 := []int32{1, 2}
        slice3 := []int32{1, 2, 3}
&nbsp;
        fmt.Printf("sizeof int    = %d byte(s)\n", unsafe.Sizeof(int32(42)))
        fmt.Println()
&nbsp;
        fmt.Printf("sizeof array1 = %d byte(s)\n", unsafe.Sizeof(array1))
        fmt.Printf("sizeof array2 = %d byte(s)\n", unsafe.Sizeof(array2))
        fmt.Printf("sizeof array3 = %d byte(s)\n", unsafe.Sizeof(array3))
        fmt.Println()
&nbsp;
        fmt.Printf("sizeof slice1 = %d byte(s)\n", unsafe.Sizeof(slice1))
        fmt.Printf("sizeof slice2 = %d byte(s)\n", unsafe.Sizeof(slice2))
        fmt.Printf("sizeof slice3 = %d byte(s)\n", unsafe.Sizeof(slice3))
}
</pre>

<p>Z&nbsp;vypsaných výsledků je patrné, že u polí je jejich velikost
(v&nbsp;tomto případě) vypočtena jako
<i>počet_prvků&times;velikost_jednoho_prvku</i>, což je logické. Ovšem pozor si
musíme dát u řezů, protože se vždy vrátí pouze velikost struktury
s&nbsp;informacemi o řezu. Tato struktura obsahuje ukazatel na pole (nikoli
celé pole), kapacitu řezu a počet skutečně uložených prvků. Velikost řezu je
tedy vždy stejná &ndash; na 64bitových systémech 3&times;8 bajtů:</p>

<pre>
sizeof int    = 4 byte(s)
&nbsp;
sizeof array1 = 4 byte(s)
sizeof array2 = 8 byte(s)
sizeof array3 = 12 byte(s)
&nbsp;
sizeof slice1 = 24 byte(s)
sizeof slice2 = 24 byte(s)
sizeof slice3 = 24 byte(s)
</pre>

<p>Dále se pokusíme zjistit, jak velkou oblast paměti je nutné rezervovat pro
hodnoty, které reprezentují uživatelské datové struktury a taktéž jakou
velikost mají ukazatele na hodnoty typu struktura:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
type <strong>Vector2D</strong> struct {
        x float32
        y float32
}
&nbsp;
type <strong>Vector3D</strong> struct {
        x float32
        y float32
        z float32
}
&nbsp;
type <strong>User</strong> struct {
        ID      uint32
        Name    string
        Surname string
}
&nbsp;
func <strong>main</strong>() {
        vector2d := Vector2D{
                x: 10,
                y: 20,
        }
&nbsp;
        vector3d := Vector3D{
                x: 10,
                y: 20,
                z: 30,
        }
&nbsp;
        user := User{
                ID:      42,
                Name:    "Pepa",
                Surname: "Vyskoč",
        }
&nbsp;
        fmt.Printf("sizeof str      = %d byte(s)\n", unsafe.Sizeof("foo"))
        fmt.Println()
&nbsp;
        fmt.Printf("sizeof Vector2D = %d byte(s)\n", unsafe.Sizeof(vector2d))
        fmt.Printf("sizeof Vector3D = %d byte(s)\n", unsafe.Sizeof(vector3d))
        fmt.Printf("sizeof User     = %d byte(s)\n", unsafe.Sizeof(user))
        fmt.Println()
&nbsp;
        fmt.Printf("sizeof &amp;Vector2D = %d byte(s)\n", unsafe.Sizeof(&amp;vector2d))
        fmt.Printf("sizeof &amp;Vector3D = %d byte(s)\n", unsafe.Sizeof(&amp;vector3d))
        fmt.Printf("sizeof &amp;User     = %d byte(s)\n", unsafe.Sizeof(&amp;user))
}
</pre>

<p>V&nbsp;testovaných příkladech velikost struktury odpovídá součtu velikostí
prvků, přičemž pro typ <strong>User</strong> platí, že každý řetězec je uložen
v&nbsp;šestnácti bajtech (nejedná se totiž o vlastní řetězec, ale opět o
dvojici ukazatel+velikost, podobně jako je tomu u řezů):</p>

<pre>
sizeof str      = 16 byte(s)
&nbsp;
sizeof Vector2D = 8 byte(s)
sizeof Vector3D = 12 byte(s)
sizeof User     = 40 byte(s)
&nbsp;
sizeof &amp;Vector2D = 8 byte(s)
sizeof &amp;Vector3D = 8 byte(s)
sizeof &amp;User     = 8 byte(s)
</pre>

<p><div class="rs-tip-major">Poznámka: ovšem obecně to neplatí! Velikost
struktury může být větší než velikosti jejich prvků, což si ostatně ukážeme
v&nbsp;navazujících kapitolách.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Velikost hodnot <strong>nil</strong> různého typu</h2>

<p>V&nbsp;programovacím jazyce Go se na několika místech můžeme setkat se
speciální hodnotou <strong>nil</strong>. Tato hodnota se většinou používá pro
reprezentaci nulové hodnoty pro různé datové typy. Proměnné v&nbsp;Go jsou
totiž vždy inicializovány a pokud není ve zdrojových kódech explicitně uvedena
jejich hodnota, je automaticky provedena inicializace na hodnotu nulovou.
Z&nbsp;tohoto důvodu má <strong>nil</strong> význam především u těch datových
typů, v&nbsp;nichž je nutné neinicializovanou hodnotu nějakým způsobem
jednoznačně odlišit od ostatních hodnot. Příkladem mohou být ukazatele,
rozhraní, mapy popř.&nbsp;řezy (připomeňme si, že prázdný řez je odlišný od
řezu neinicializovaného).</p>

<p>Hodnota <strong>nil</strong> se naopak nepoužívá u číselných typů, řetězců
ani u pravdivostních hodnot, protože v&nbsp;tomto případě je vždy proměnná
inicializována &ndash; na nulu u číselných typů (celá čísla, čísla
s&nbsp;plovoucí řádovou čárkou, komplexní čísla), na prázdný řetězec u řetězců
a na hodnotu <strong>false</strong> u pravdivostních hodnot. Vše je shrnuto
v&nbsp;následující tabulce:</p>

<table>
<tr><th>Typ</th><th>Výchozí hodnota</th></tr>
<tr><td>všechny numerické typy</td><td>0, 0.0, 0.0+0.0i atd.</td></tr>
<tr><td>řetězce</td><td>""</td></tr>
<tr><td>pole</td><td>prvky rekurzivně inicializované dle této tabulky</td></tr>
<tr><td>ukazatel</td><td>nil</td></tr>
<tr><td>řez</td><td>nil</td></tr>
<tr><td>kanál</td><td>nil</td></tr>
<tr><td>mapa</td><td>nil</td></tr>
</table>

<p>V&nbsp;dalším demonstračním příkladu si otestujeme, jakým způsobem dokáže
funkce <strong>unsage.Sizeof</strong> zjistit velikosti hodnot
<strong>nil</strong>, které jsou však různého typu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
type <strong>User</strong> struct {
        ID      uint32
        Name    string
        Surname string
}
&nbsp;
func <strong>main</strong>() {
        var a *int32 = nil
        var b *int64 = nil
        var c []int32 = nil
        var d interface{} = nil
        var e map[string]string = nil
        var f chan int = nil
&nbsp;
        fmt.Printf("sizeof *int32      = %d byte(s)\n", unsafe.Sizeof(a))
        fmt.Printf("sizeof *int64      = %d byte(s)\n", unsafe.Sizeof(b))
        fmt.Printf("sizeof slice       = %d byte(s)\n", unsafe.Sizeof(c))
        fmt.Printf("sizeof {}interface = %d byte(s)\n", unsafe.Sizeof(d))
        fmt.Printf("sizeof map         = %d byte(s)\n", unsafe.Sizeof(e))
        fmt.Printf("sizeof chan        = %d byte(s)\n", unsafe.Sizeof(f))
}
</pre>

<p>Z&nbsp;výsledků je patrné, že i když ve zdrojových kódech (nebo při tisku na
terminál) vidíme hodnotu <strong>nil</strong>, může se interně jednat o bloky,
které zabírají různě velké místo v&nbsp;operační paměti:</p>

<pre>
sizeof *int32      = 8 byte(s)
sizeof *int64      = 8 byte(s)
sizeof slice       = 24 byte(s)
sizeof {}interface = 16 byte(s)
sizeof map         = 8 byte(s)
sizeof chan        = 8 byte(s)
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vliv pořadí prvků ve struktuře na její celkové velikosti</h2>

<p>Interně jsou prvky ve struktuře zarovnány způsobem, který zjistíme (o
několik kapitol níže) funkcí <strong>unsafe.Alignof</strong>. Mezi prvky
struktur tedy mohou být vkládány výplně (<i>padding</i>), jejichž existence,
umístění i velikost závisí na typu a taktéž na pořadí prvků struktury. Můžeme
si to ukázat na čtveřici struktur, které obsahují prvky stejného typu, ovšem
v&nbsp;odlišném pořadí. Už jen prohození pořadí prvků může vést k&nbsp;tomu, že
se změní celková velikost struktury:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
type <strong>Struct1</strong> struct {
        x byte
        y uint16
        z uint32
}
&nbsp;
type <strong>Struct2</strong> struct {
        z uint32
        y uint16
        x byte
}
&nbsp;
type <strong>Struct3</strong> struct {
        x byte
        z uint32
        y uint16
}
&nbsp;
type <strong>Struct4</strong> struct {
        y uint16
        z uint32
        x byte
}
&nbsp;
func <strong>main</strong>() {
        fmt.Printf("sizeof Struct1   = %d byte(s)\n", unsafe.Sizeof(Struct1{}))
        fmt.Printf("sizeof Struct2   = %d byte(s)\n", unsafe.Sizeof(Struct2{}))
        fmt.Printf("sizeof Struct3   = %d byte(s)\n", unsafe.Sizeof(Struct3{}))
        fmt.Printf("sizeof Struct4   = %d byte(s)\n", unsafe.Sizeof(Struct4{}))
}
</pre>

<p>Z&nbsp;výsledků je patrné, že v&nbsp;některých případech kvůli zarovnání
naroste velikost struktury o čtyři bajty:</p>

<pre>
sizeof Struct1   = 8 byte(s)
sizeof Struct2   = 8 byte(s)
sizeof Struct3   = 12 byte(s)
sizeof Struct4   = 12 byte(s)
</pre>

<p><div class="rs-tip-major">Poznámka: samotný nárůst je v&nbsp;tomto případě
sice minimální, ovšem pokud by se jednalo o pole či řez s&nbsp;milionem
struktur, už by se jednalo o významný údaj. Zde nám tedy může knihovna
<strong>unsafe</strong> pomoci.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vyhodnocení <strong>unsafe.Sizeof</strong> na konstantu</h2>

<p>Připomeňme si, že v&nbsp;jazyku Go je možné pracovat s&nbsp;konstantami.
Jejich hodnoty jsou vyhodnoceny v&nbsp;čase překladu. Pokud tomu tak není
(tj.&nbsp;není možné vypočítat hodnotu konstanty), bude překladač hlásit
chybu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math"
)
&nbsp;
func <strong>main</strong>() {
        const x = math.Pi / 2
        const y = math.Sin(x)
        fmt.Println("vim-go")
}
</pre>

<p>Tento program není možné přeložit, protože hodnotu konstanty
<strong>x</strong> překladač nezjistí v&nbsp;době překladu (v&nbsp;tomto
případě by ji zjistit mohl, ovšem spuštěním kódu z&nbsp;balíčku
<strong>math</strong>):</p>

<pre>
$ <strong>go build not_constant.go</strong>
&nbsp;
# command-line-arguments
./not_constant.go:10:12: math.Sin(x) (value of type float64) is not constant
</pre>

<p>Na druhou stranu výsledky volání funkce <strong>unsafe.Sizeof</strong> ve
skutečnosti konstantami jsou, což je sice poněkud zvláštní, ale velmi užitečné.
Z&nbsp;tohoto důvodu je možné přeložit a spustit i následující program:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
type <strong>Vector2D</strong> struct {
        x float32
        y float32
}
&nbsp;
type <strong>Vector3D</strong> struct {
        x float32
        y float32
        z float32
}
&nbsp;
type <strong>User</strong> struct {
        ID      uint32
        Name    string
        Surname string
}
&nbsp;
type <strong>Struct1</strong> struct {
        x byte
        y uint16
        z uint32
}
&nbsp;
type <strong>Struct2</strong> struct {
        z uint32
        y uint16
        x byte
}
&nbsp;
type <strong>Struct3</strong> struct {
        x byte
        z uint32
        y uint16
}
&nbsp;
type <strong>Struct4</strong> struct {
        y uint16
        z uint32
        x byte
}
&nbsp;
func <strong>main</strong>() {
        const s01 = unsafe.Sizeof(int8(0))
        const s02 = unsafe.Sizeof(int16(0))
        const s03 = unsafe.Sizeof(int32(0))
        const s04 = unsafe.Sizeof(int64(0))
        const s05 = unsafe.Sizeof(int(0))
        const s06 = unsafe.Sizeof(float32(0))
        const s07 = unsafe.Sizeof(float64(0))
        const s08 = unsafe.Sizeof(complex64(0))
        const s09 = unsafe.Sizeof(complex128(0))
        const s10 = unsafe.Sizeof(uintptr(0))
&nbsp;
        fmt.Printf("sizeof int8        = %d byte(s)\n", s01)
        fmt.Printf("sizeof int16       = %d byte(s)\n", s02)
        fmt.Printf("sizeof int32       = %d byte(s)\n", s03)
        fmt.Printf("sizeof int64       = %d byte(s)\n", s04)
        fmt.Printf("sizeof int         = %d byte(s)\n", s05)
        fmt.Printf("sizeof float32     = %d byte(s)\n", s06)
        fmt.Printf("sizeof float64     = %d byte(s)\n", s07)
        fmt.Printf("sizeof complex64   = %d byte(s)\n", s08)
        fmt.Printf("sizeof complex128  = %d byte(s)\n", s09)
        fmt.Printf("sizeof uintptr     = %d byte(s)\n", s10)
        fmt.Println()
&nbsp;
        array1 := [...]int32{1}
        array2 := [...]int32{1, 2}
        array3 := [...]int32{1, 2, 3}
&nbsp;
        const s11 = unsafe.Sizeof(array1)
        const s12 = unsafe.Sizeof(array2)
        const s13 = unsafe.Sizeof(array3)
&nbsp;
        fmt.Printf("sizeof array1      = %d byte(s)\n", s11)
        fmt.Printf("sizeof array2      = %d byte(s)\n", s12)
        fmt.Printf("sizeof array3      = %d byte(s)\n", s13)
        fmt.Println()
&nbsp;
        slice1 := []int32{1}
        slice2 := []int32{1, 2}
        slice3 := []int32{1, 2, 3}
&nbsp;
        const s14 = unsafe.Sizeof(slice1)
        const s15 = unsafe.Sizeof(slice2)
        const s16 = unsafe.Sizeof(slice3)
&nbsp;
        fmt.Printf("sizeof slice1      = %d byte(s)\n", s14)
        fmt.Printf("sizeof slice2      = %d byte(s)\n", s15)
        fmt.Printf("sizeof slice3      = %d byte(s)\n", s16)
        fmt.Println()
&nbsp;
        fmt.Printf("sizeof str         = %d byte(s)\n", unsafe.Sizeof("foo"))
        fmt.Println()
&nbsp;
        vector2d := Vector2D{
                x: 10,
                y: 20,
        }
&nbsp;
        vector3d := Vector3D{
                x: 10,
                y: 20,
                z: 30,
        }
&nbsp;
        user := User{
                ID:      42,
                Name:    "Pepa",
                Surname: "Vyskoč",
        }
&nbsp;
        const s17 = unsafe.Sizeof(vector2d)
        const s18 = unsafe.Sizeof(vector3d)
        const s19 = unsafe.Sizeof(user)
        const s20 = unsafe.Sizeof(&amp;vector2d)
        const s21 = unsafe.Sizeof(&amp;vector3d)
        const s22 = unsafe.Sizeof(&amp;user)
&nbsp;
        fmt.Printf("sizeof Vector2D    = %d byte(s)\n", s17)
        fmt.Printf("sizeof Vector3D    = %d byte(s)\n", s18)
        fmt.Printf("sizeof User        = %d byte(s)\n", s19)
        fmt.Println()
&nbsp;
        fmt.Printf("sizeof &amp;Vector2D   = %d byte(s)\n", s20)
        fmt.Printf("sizeof &amp;Vector3D   = %d byte(s)\n", s21)
        fmt.Printf("sizeof &amp;User       = %d byte(s)\n", s22)
&nbsp;
        var a *int32 = nil
        var b *int64 = nil
        var c []int32 = nil
        var d interface{} = nil
        var e map[string]string = nil
        var f chan int = nil
&nbsp;
        const s23 = unsafe.Sizeof(a)
        const s24 = unsafe.Sizeof(b)
        const s25 = unsafe.Sizeof(c)
        const s26 = unsafe.Sizeof(d)
        const s27 = unsafe.Sizeof(e)
        const s28 = unsafe.Sizeof(f)
&nbsp;
        const s29 = unsafe.Sizeof(Struct1{})
        const s30 = unsafe.Sizeof(Struct2{})
        const s31 = unsafe.Sizeof(Struct3{})
        const s32 = unsafe.Sizeof(Struct4{})
&nbsp;
        fmt.Printf("sizeof *int32      = %d byte(s)\n", s23)
        fmt.Printf("sizeof *int64      = %d byte(s)\n", s24)
        fmt.Printf("sizeof slice       = %d byte(s)\n", s25)
        fmt.Printf("sizeof {}interface = %d byte(s)\n", s26)
        fmt.Printf("sizeof map         = %d byte(s)\n", s27)
        fmt.Printf("sizeof chan        = %d byte(s)\n", s28)
&nbsp;
        fmt.Printf("sizeof Struct1     = %d byte(s)\n", s29)
        fmt.Printf("sizeof Struct2     = %d byte(s)\n", s30)
        fmt.Printf("sizeof Struct3     = %d byte(s)\n", s31)
        fmt.Printf("sizeof Struct4     = %d byte(s)\n", s32)
}
</pre>

<p>Výsledky budou vypadat následovně:</p>

<pre>
sizeof int8        = 1 byte(s)
sizeof int16       = 2 byte(s)
sizeof int32       = 4 byte(s)
sizeof int64       = 8 byte(s)
sizeof int         = 8 byte(s)
sizeof float32     = 4 byte(s)
sizeof float64     = 8 byte(s)
sizeof complex64   = 8 byte(s)
sizeof complex128  = 16 byte(s)
sizeof uintptr     = 8 byte(s)
&nbsp;
sizeof array1      = 4 byte(s)
sizeof array2      = 8 byte(s)
sizeof array3      = 12 byte(s)
&nbsp;
sizeof slice1      = 24 byte(s)
sizeof slice2      = 24 byte(s)
sizeof slice3      = 24 byte(s)
&nbsp;
sizeof str         = 16 byte(s)
&nbsp;
sizeof Vector2D    = 8 byte(s)
sizeof Vector3D    = 12 byte(s)
sizeof User        = 40 byte(s)
&nbsp;
sizeof &amp;Vector2D   = 8 byte(s)
sizeof &amp;Vector3D   = 8 byte(s)
sizeof &amp;User       = 8 byte(s)
sizeof *int32      = 8 byte(s)
sizeof *int64      = 8 byte(s)
sizeof slice       = 24 byte(s)
sizeof {}interface = 16 byte(s)
sizeof map         = 8 byte(s)
sizeof chan        = 8 byte(s)
sizeof Struct1     = 8 byte(s)
sizeof Struct2     = 8 byte(s)
sizeof Struct3     = 12 byte(s)
sizeof Struct4     = 12 byte(s)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Funkce <strong>unsafe.Alignof</strong></h2>

<p>Druhou funkcí z&nbsp;balíčku <strong>unsafe</strong>, se kterou se dnes
seznámíme, je funkce nazvaná <strong>unsafe.Alignof</strong>. I pro tuto funkci
je pochopitelně možné získat nápovědu:</p>

<pre>
$ <strong>go doc unsafe.Alignof</strong>
</pre>

<p>Nápověda je zobrazena na terminálu:</p>

<pre>
package unsafe // import "unsafe"
&nbsp;
func Alignof(x ArbitraryType) uintptr
    Alignof takes an expression x of any type and returns the required
    alignment of a hypothetical variable v as if v was declared via var v = x.
    It is the largest value m such that the address of v is always zero mod m.
    It is the same as the value returned by reflect.TypeOf(x).Align().
    As a special case, if a variable s is of struct type and f is a field
    within that struct, then Alignof(s.f) will return the required alignment
    of a field of that type within a struct. This case is the same as the value
    returned by reflect.TypeOf(s.f).FieldAlign(). The return value of Alignof
    is a Go constant if the type of the argument does not have variable size.
    (See the description of Sizeof for a definition of variable sized types.)
</pre>

<p>Tato funkce se do určité míry podobá <strong>unsafe.Sizef</strong>, protože
i jí je možné předat výraz libovolného typu a i navrácená hodnota je konstantní
(z&nbsp;pohledu překladače). <strong>unsafe.Alignof</strong> vrací požadované
zarovnání hodnoty v&nbsp;operační paměti. Pokud se například vrátí hodnota 2,
znamená to, že paměťový blok s&nbsp;hodnotou bude zarovnán na sudé adresy.
V&nbsp;případě, že se vrátí hodnota 8, bude zarovnání provedeno na adresy
dělitelné osmi atd. Ve všech případech se předpokládá, že adresování probíhá po
bajtech.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zarovnání u základních datových typů i u struktur</h2>

<p>Otestujme si nyní, jak musí být zarovnány hodnoty základních datových typů
v&nbsp;paměti. Je to snadné:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
func <strong>main</strong>() {
        fmt.Printf("alignof int8       = %d byte(s)\n", unsafe.Alignof(int8(0)))
        fmt.Printf("alignof int16      = %d byte(s)\n", unsafe.Alignof(int16(0)))
        fmt.Printf("alignof int32      = %d byte(s)\n", unsafe.Alignof(int32(0)))
        fmt.Printf("alignof int64      = %d byte(s)\n", unsafe.Alignof(int64(0)))
        fmt.Printf("alignof int        = %d byte(s)\n", unsafe.Alignof(int(0)))
        fmt.Printf("alignof float32    = %d byte(s)\n", unsafe.Alignof(float32(0)))
        fmt.Printf("alignof float64    = %d byte(s)\n", unsafe.Alignof(float64(0)))
        fmt.Printf("alignof complex64  = %d byte(s)\n", unsafe.Alignof(complex64(0)))
        fmt.Printf("alignof complex128 = %d byte(s)\n", unsafe.Alignof(complex128(0)))
        fmt.Printf("alignof uintptr    = %d byte(s)\n", unsafe.Alignof(uintptr(0)))
}
</pre>

<p>Výsledky pro 64bitovou platformu vypadají takto:</p>

<pre>
alignof int8       = 1 byte(s)
alignof int16      = 2 byte(s)
alignof int32      = 4 byte(s)
alignof int64      = 8 byte(s)
alignof int        = 8 byte(s)
alignof float32    = 4 byte(s)
alignof float64    = 8 byte(s)
alignof complex64  = 4 byte(s)
alignof complex128 = 8 byte(s)
alignof uintptr    = 8 byte(s)
</pre>

<p>Podobným způsobem je možné zjistit i zarovnání celých struktur
v&nbsp;paměti:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
type <strong>Vector2D</strong> struct {
        x float32
        y float32
}
&nbsp;
type <strong>Vector3D</strong> struct {
        x float32
        y float32
        z float32
}
&nbsp;
type <strong>User</strong> struct {
        ID      uint32
        Name    string
        Surname string
}
&nbsp;
func <strong>main</strong>() {
        vector2d := Vector2D{
                x: 10,
                y: 20,
        }
&nbsp;
        vector3d := Vector3D{
                x: 10,
                y: 20,
                z: 30,
        }
&nbsp;
        user := User{
                ID:      42,
                Name:    "Pepa",
                Surname: "Vyskoč",
        }
&nbsp;
        fmt.Printf("alignof Vector2D = %d byte(s)\n", unsafe.Alignof(vector2d))
        fmt.Printf("alignof Vector3D = %d byte(s)\n", unsafe.Alignof(vector3d))
        fmt.Printf("alignof User     = %d byte(s)\n", unsafe.Alignof(user))
        fmt.Println()
}
</pre>

<p>Výsledky mohou být v&nbsp;tomto případě poněkud překvapivé, protože ukazují,
že se zarovnání může odlišovat, i když by se mohlo předpokládat, že bude vždy
stejné (32 nebo 64 bitů, v&nbsp;závislosti na platformě). Ovšem ve skutečnosti
je zarovnání celé struktury omezeno zarovnáním jejích prvků:</p>

<pre>
alignof Vector2D = 4 byte(s)
alignof Vector3D = 4 byte(s)
alignof User     = 8 byte(s)
</pre>

<p><div class="rs-tip-major">Poznámka: struktury jsou v&nbsp;jazyku Go
<i>hodnotovými typy</i>, nikoli <i>referencemi</i> (což je případ objektů
v&nbsp;Javě a struktur v&nbsp;Pythonu).</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vliv typů prvků struktury na její celkové zarovnání</h2>

<pre>
package main

import (
        "fmt"
        "unsafe"
)

type Struct1 struct {
        x byte
}

type Struct2 struct {
        x byte
        y byte
}

type Struct3 struct {
        x byte
        y byte
        z byte
}

type Struct4 struct {
        x byte
        y byte
        z byte
        w byte
}

func main() {
        fmt.Printf("alignof Struct1   = %d byte(s)\n", unsafe.Alignof(Struct1{}))
        fmt.Printf("alignof Struct2   = %d byte(s)\n", unsafe.Alignof(Struct2{}))
        fmt.Printf("alignof Struct3   = %d byte(s)\n", unsafe.Alignof(Struct3{}))
        fmt.Printf("alignof Struct4   = %d byte(s)\n", unsafe.Alignof(Struct4{}))
}
</pre>

<pre>
alignof Struct1   = 1 byte(s)
alignof Struct2   = 1 byte(s)
alignof Struct3   = 1 byte(s)
alignof Struct4   = 1 byte(s)
</pre>

<pre>
package main

import (
        "fmt"
        "unsafe"
)

type Struct1 struct {
        i int32
        x byte
}

type Struct2 struct {
        i int32
        x byte
        y byte
}

type Struct3 struct {
        i int32
        x byte
        y byte
        z byte
}

type Struct4 struct {
        i int32
        x byte
        y byte
        z byte
        w byte
}

func main() {
        fmt.Printf("alignof Struct1   = %d byte(s)\n", unsafe.Alignof(Struct1{}))
        fmt.Printf("alignof Struct2   = %d byte(s)\n", unsafe.Alignof(Struct2{}))
        fmt.Printf("alignof Struct3   = %d byte(s)\n", unsafe.Alignof(Struct3{}))
        fmt.Printf("alignof Struct4   = %d byte(s)\n", unsafe.Alignof(Struct4{}))
}
</pre>

<pre>
alignof Struct1   = 4 byte(s)
alignof Struct2   = 4 byte(s)
alignof Struct3   = 4 byte(s)
alignof Struct4   = 4 byte(s)
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vyhodnocení <strong>unsafe.Alignof</strong> na konstantu</h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. Funkce <strong>unsafe.Offsetof</strong></h2>

<p>Třetí funkcí z&nbsp;balíčku <strong>unsafe</strong>, s&nbsp;níž se dnes
setkáme, je funkce nazvaná <strong>unsafe.Offsetof</strong>. I pro ni je
pochopitelně připravena nápověda:</p>

<pre>
$ <strong>go doc unsafe.Offsetof</strong>
</pre>

<p>Nápověda zobrazená na terminálu:</p>

<pre>
package unsafe // import "unsafe"
&nbsp;
func Offsetof(x ArbitraryType) uintptr
    Offsetof returns the offset within the struct of the field represented by x,
    which must be of the form structValue.field. In other words, it returns the
    number of bytes between the start of the struct and the start of the field.
    The return value of Offsetof is a Go constant if the type of the argument x
    does not have variable size. (See the description of Sizeof for a definition
    of variable sized types.)
</pre>

<p>Tato funkce slouží k&nbsp;výpočtu (relativního) offsetu zvoleného prvku
libovolné struktury. Výsledkem je opět konstantní hodnota. Tuto funkci je možné
s&nbsp;výhodou použít pro zjištění, ve kterých místech struktury jsou použity
výplňové bajty (<i>padding</i>), které zvětšují celkovou velikost struktury a
vedou i ke zpomalení běhu aplikace (kvůli vyšší pravděpodobnosti výpadku
cachí).</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<pre>
package main
&nbsp;
import (
        "fmt"
        "unsafe"
)
&nbsp;
type Vector3D struct {
        x float32
        y float32
        z float32
}
&nbsp;
func main() {
        vector3d := Vector3D{
                x: 10,
                y: 20,
                z: 30,
        }

        fmt.Printf("offsetof Vector3D.x = %d byte(s)\n", unsafe.Offsetof(vector3d.x))
        fmt.Printf("offsetof Vector3D.y = %d byte(s)\n", unsafe.Offsetof(vector3d.y))
        fmt.Printf("offsetof Vector3D.a = %d byte(s)\n", unsafe.Offsetof(vector3d.z))
        fmt.Println()
}
</pre>

<pre>
offsetof Vector3D.x = 0 byte(s)
offsetof Vector3D.y = 4 byte(s)
offsetof Vector3D.a = 8 byte(s)
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<pre>
package main

import (
        "fmt"
        "unsafe"
)

type Struct1 struct {
        x byte
        y byte
        z byte
}

type Struct2 struct {
        x byte
        y byte
        z uint32
}

type Struct3 struct {
        x byte
        y uint32
        z byte
}

type Struct4 struct {
        x uint32
        y byte
        z byte
}

type Struct5 struct {
        x byte
        y uint16
        z uint32
}

type Struct6 struct {
        z uint32
        y uint16
        x byte
}

type Struct7 struct {
        x byte
        z uint32
        y uint16
}

type Struct8 struct {
        y uint16
        z uint32
        x byte
}

func main() {
        fmt.Printf("offsetof Struct1.x   = %d byte(s)\n", unsafe.Offsetof(Struct1{}.x))
        fmt.Printf("offsetof Struct1.y   = %d byte(s)\n", unsafe.Offsetof(Struct1{}.y))
        fmt.Printf("offsetof Struct1.z   = %d byte(s)\n", unsafe.Offsetof(Struct1{}.z))
        fmt.Println()
        fmt.Printf("offsetof Struct2.x   = %d byte(s)\n", unsafe.Offsetof(Struct2{}.x))
        fmt.Printf("offsetof Struct2.y   = %d byte(s)\n", unsafe.Offsetof(Struct2{}.y))
        fmt.Printf("offsetof Struct2.z   = %d byte(s)\n", unsafe.Offsetof(Struct2{}.z))
        fmt.Println()
        fmt.Printf("offsetof Struct3.x   = %d byte(s)\n", unsafe.Offsetof(Struct3{}.x))
        fmt.Printf("offsetof Struct3.y   = %d byte(s)\n", unsafe.Offsetof(Struct3{}.y))
        fmt.Printf("offsetof Struct3.z   = %d byte(s)\n", unsafe.Offsetof(Struct3{}.z))
        fmt.Println()
        fmt.Printf("offsetof Struct4.x   = %d byte(s)\n", unsafe.Offsetof(Struct4{}.x))
        fmt.Printf("offsetof Struct4.y   = %d byte(s)\n", unsafe.Offsetof(Struct4{}.y))
        fmt.Printf("offsetof Struct4.z   = %d byte(s)\n", unsafe.Offsetof(Struct4{}.z))
        fmt.Println()
        fmt.Printf("offsetof Struct5.x   = %d byte(s)\n", unsafe.Offsetof(Struct5{}.x))
        fmt.Printf("offsetof Struct5.y   = %d byte(s)\n", unsafe.Offsetof(Struct5{}.y))
        fmt.Printf("offsetof Struct5.z   = %d byte(s)\n", unsafe.Offsetof(Struct5{}.z))
        fmt.Println()
        fmt.Printf("offsetof Struct6.x   = %d byte(s)\n", unsafe.Offsetof(Struct6{}.x))
        fmt.Printf("offsetof Struct6.y   = %d byte(s)\n", unsafe.Offsetof(Struct6{}.y))
        fmt.Printf("offsetof Struct6.z   = %d byte(s)\n", unsafe.Offsetof(Struct6{}.z))
        fmt.Println()
        fmt.Printf("offsetof Struct7.x   = %d byte(s)\n", unsafe.Offsetof(Struct7{}.x))
        fmt.Printf("offsetof Struct7.y   = %d byte(s)\n", unsafe.Offsetof(Struct7{}.y))
        fmt.Printf("offsetof Struct7.z   = %d byte(s)\n", unsafe.Offsetof(Struct7{}.z))
        fmt.Println()
        fmt.Printf("offsetof Struct8.x   = %d byte(s)\n", unsafe.Offsetof(Struct8{}.x))
        fmt.Printf("offsetof Struct8.y   = %d byte(s)\n", unsafe.Offsetof(Struct8{}.y))
        fmt.Printf("offsetof Struct8.z   = %d byte(s)\n", unsafe.Offsetof(Struct8{}.z))
        fmt.Println()
}
</pre>

<pre>
offsetof Struct1.x   = 0 byte(s)
offsetof Struct1.y   = 1 byte(s)
offsetof Struct1.z   = 2 byte(s)

offsetof Struct2.x   = 0 byte(s)
offsetof Struct2.y   = 1 byte(s)
offsetof Struct2.z   = 4 byte(s)

offsetof Struct3.x   = 0 byte(s)
offsetof Struct3.y   = 4 byte(s)
offsetof Struct3.z   = 8 byte(s)

offsetof Struct4.x   = 0 byte(s)
offsetof Struct4.y   = 4 byte(s)
offsetof Struct4.z   = 5 byte(s)

offsetof Struct5.x   = 0 byte(s)
offsetof Struct5.y   = 2 byte(s)
offsetof Struct5.z   = 4 byte(s)

offsetof Struct6.x   = 6 byte(s)
offsetof Struct6.y   = 4 byte(s)
offsetof Struct6.z   = 0 byte(s)

offsetof Struct7.x   = 0 byte(s)
offsetof Struct7.y   = 8 byte(s)
offsetof Struct7.z   = 4 byte(s)

offsetof Struct8.x   = 8 byte(s)
offsetof Struct8.y   = 0 byte(s)
offsetof Struct8.z   = 4 byte(s)

</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<p></p>



<pre>
$ <strong>go doc unsafe.Pointer</strong>
</pre>

<pre>
package unsafe // import "unsafe"
&nbsp;
type Pointer *ArbitraryType
    Pointer represents a pointer to an arbitrary type. There are four special
    operations available for type Pointer that are not available for other
    types:
      - A pointer value of any type can be converted to a Pointer.
      - A Pointer can be converted to a pointer value of any type.
      - A uintptr can be converted to a Pointer.
      - A Pointer can be converted to a uintptr.
</pre>


<pre>
package <strong>main</strong>
&nbsp;
<i>// #include &lt;stdio.h&gt;</i>
<i>// #include &lt;stdlib.h&gt;</i>
import "C"
import "unsafe"
&nbsp;
func <strong>main</strong>() {
        cs := C.CString("Hello world!")
        C.puts(cs)
}
</pre>
<pre>
package <strong>main</strong>
&nbsp;
<i>// #include &lt;stdio.h&gt;</i>
<i>// #include &lt;stdlib.h&gt;</i>
import "C"
import "unsafe"
&nbsp;
func <strong>main</strong>() {
        cs := C.CString("Hello world!")
        C.puts(cs)
        C.free(unsafe.Pointer(cs))
}
</pre>

<p></p>

<pre>
package <strong>main</strong>
&nbsp;
<i>// #include &lt;stdio.h&gt;</i>
<i>// #include &lt;stdlib.h&gt;</i>
import "C"
import "unsafe"
&nbsp;
func <strong>main</strong>() {
        for {
                cs := C.CString("Hello world!")
                C.puts(cs)
                C.free(unsafe.Pointer(cs))
        }
}
</pre>

<p></p>

<pre>
package <strong>main</strong>
&nbsp;
<i>// #include &lt;stdio.h&gt;</i>
<i>// #include &lt;stdlib.h&gt;</i>
import "C"
import "unsafe"
&nbsp;
func <strong>main</strong>() {
        cs := C.CString("Hello world!")
        C.free(unsafe.Pointer(cs))
        C.puts(cs)
}
</pre>

<pre>
package <strong>main</strong>
&nbsp;
<i>// #include &lt;stdio.h&gt;</i>
<i>// #include &lt;stdlib.h&gt;</i>
import "C"
import "unsafe"
&nbsp;
func <strong>main</strong>() {
        cs := C.CString("Hello world!")
        C.puts(cs)
        C.free(unsafe.Pointer(cs))
        C.free(unsafe.Pointer(cs))
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

<p></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně pět až šest megabajtů), můžete namísto toho použít odkazy na
jednotlivé příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>sizeof_1.go</td><td>zjištění velikosti hodnot standardních primitivních datových typů</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_1.go">https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_1.go</a></td></tr>
<tr><td> 2</td><td>sizeof_2.go</td><td>zjištění velikosti polí a řezů (<i>slices</i>)</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_2.go">https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_2.go</a></td></tr>
<tr><td> 3</td><td>sizeof_3.go</td><td>zjištění velikosti hodnot, jejichž typy jsou definovány uživatelskými strukturami</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_3.go">https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_3.go</a></td></tr>
<tr><td> 4</td><td>sizeof_4.go</td><td>zjištění velikosti hodnot <strong>nil</strong>, které jsou různých typů</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_4.go">https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_4.go</a></td></tr>
<tr><td> 5</td><td>sizeof_5.go</td><td>vliv pořadí prvků ve struktuře na její celkové velikosti</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_5.go">https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_5.go</a></td></tr>
<tr><td> 6</td><td>sizeof_6.go</td><td>vyhodnocení <strong>unsafe.Sizeof</strong> na konstantu</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_6.go">https://github.com/tisnik/go-root/blob/master/unsafe/sizeof_6.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>alignof_1.go</td><td>zjištění zarovnání u základních datových typů</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/alignof_1.go">https://github.com/tisnik/go-root/blob/master/unsafe/alignof_1.go</a></td></tr>
<tr><td> 8</td><td>alignof_2.go</td><td>zjištění zarovnání u uživatelských datových struktur</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/alignof_2.go">https://github.com/tisnik/go-root/blob/master/unsafe/alignof_2.go</a></td></tr>
<tr><td> 9</td><td>alignof_3.go</td><td>vliv typů prvků struktury na její celkové zarovnání (první varianta příkladu)</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/alignof_3.go">https://github.com/tisnik/go-root/blob/master/unsafe/alignof_3.go</a></td></tr>
<tr><td>10</td><td>alignof_4.go</td><td>vliv typů prvků struktury na její celkové zarovnání (druhá varianta příkladu)</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/alignof_4.go">https://github.com/tisnik/go-root/blob/master/unsafe/alignof_4.go</a></td></tr>
<tr><td>11</td><td>alignof_5.go</td><td>hodnota zarovnání je konstantou</td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/alignof_5.go">https://github.com/tisnik/go-root/blob/master/unsafe/alignof_5.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>offsetof_1.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/offsetof_1.go">https://github.com/tisnik/go-root/blob/master/unsafe/offsetof_1.go</a></td></tr>
<tr><td>13</td><td>offsetof_2.go</td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/offsetof_2.go">https://github.com/tisnik/go-root/blob/master/unsafe/offsetof_2.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/">https://github.com/tisnik/go-root/blob/master/unsafe/</a></td></tr>
<tr><td>15</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/unsafe/">https://github.com/tisnik/go-root/blob/master/unsafe/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Unsafe package: documentation<br />
<a href="https://pkg.go.dev/unsafe">https://pkg.go.dev/unsafe</a>
</li>

<li>An Introduction to Go's `unsafe` Package: Unsafe Operations<br />
<a href="https://reintech.io/blog/introduction-to-gos-unsafe-package">https://reintech.io/blog/introduction-to-gos-unsafe-package</a>
</li>

<li>Go &amp; cgo: integrating existing C code with Go<br />
<a href="http://akrennmair.github.io/golang-cgo-slides/#1">http://akrennmair.github.io/golang-cgo-slides/#1</a>
</li>

<li>Using cgo to call C code from within Go code<br />
<a href="https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/">https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/</a>
</li>

<li>Delve: a debugger for the Go programming language.<br />
<a href="https://github.com/go-delve/delve">https://github.com/go-delve/delve</a>
</li>

<li>Příkazy debuggeru Delve<br />
<a href="https://github.com/go-delve/delve/tree/master/Documentation/cli">https://github.com/go-delve/delve/tree/master/Documentation/cli</a>
</li>

<li>Unsafe Go<br />
<a href="https://i0tool5.github.io/learnings/golang/going-unsafe/">https://i0tool5.github.io/learnings/golang/going-unsafe/</a>
</li>

<li>Unsafe Package Usage in Go<br />
<a href="https://go-cookbook.com/snippets/standard-library-packages/unsafe-package">https://go-cookbook.com/snippets/standard-library-packages/unsafe-package</a>
</li>

<li>Padding &amp; Alignment in Go<br />
<a href="https://bitstack.substack.com/p/padding-and-alignment-in-go">https://bitstack.substack.com/p/padding-and-alignment-in-go</a>
</li>

<li>How to Use Unsafe in Go Without Killing Your Service<br />
<a href="https://dev.to/devflex-pro/how-to-use-unsafe-in-go-without-killing-your-service-699">https://dev.to/devflex-pro/how-to-use-unsafe-in-go-without-killing-your-service-699</a>
</li>

<li>Understanding Struct Padding in Go: In-Depth Guide<br />
<a href="https://kushallabs.com/understanding-struct-padding-in-go-in-depth-guide-ed70c0432c63">https://kushallabs.com/understanding-struct-padding-in-go-in-depth-guide-ed70c0432c63</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

