<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Jazyk Go a vyhodnocování výrazů v době běhu aplikace</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Jazyk Go a vyhodnocování výrazů v době běhu aplikace</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Go a skriptovací jazyky</a></p>
<p><a href="#k02">2. Doménově specifické jazyky</a></p>
<p><a href="#k03">3. Obecné skriptovací jazyky versus doménově specifické jazyky (DSL)</a></p>
<p><a href="#k04">4. Projekt <strong>Gval</strong></a></p>
<p><a href="#k05">5. Příklad typu &bdquo;Hello world!&ldquo;</a></p>
<p><a href="#k06">6. Aritmetický výraz</a></p>
<p><a href="#k07">7. Priority operátorů</a></p>
<p><a href="#k08">8. Parametry ve výrazech</a></p>
<p><a href="#k09">9. Předání parametrů pro vyhodnocení výrazu</a></p>
<p><a href="#k10">10. Předání parametrů, které se ve výrazu nepoužijí</a></p>
<p><a href="#k11">11. Logické operátory</a></p>
<p><a href="#k12">12. Ternární operátor</a></p>
<p><a href="#k13">13. Přístup k&nbsp;prvkům pole</a></p>
<p><a href="#k14">14. Přístup k&nbsp;prvkům datové struktury</a></p>
<p><a href="#k15">*** 15. Indexy pole předané v&nbsp;parametru</a></p>
<p><a href="#k16">*** 16. Jména prvků datové struktury předaná v&nbsp;parametru</a></p>
<p><a href="#k17">*** 17. Zkrácený přístup k&nbsp;prvkům datové struktury s&nbsp;využitím tečkové notace</a></p>
<p><a href="#k18">*** 18. Obsah dalšího článku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Go a skriptovací jazyky</h2>

<p><a href="https://www.root.cz/serialy/programovaci-jazyk-go/">V&nbsp;seriálu
o programovacím jazyce Go</a> jsme se již několikrát zmínili o možnosti
zkombinování tohoto staticky typovaného a překládaného (kompilovaného)
programovacího jazyka s&nbsp;nějakým interpretrem, typicky s&nbsp;interpretrem
vhodného vyššího programovacího jazyka. Díky této kombinaci je například možné
&bdquo;skriptovat&ldquo; aplikaci naprogramovanou v&nbsp;Go, rozšiřovat tuto
aplikaci o další logiku, upravovat či definovat nová &bdquo;business&ldquo;
pravidla atd. Většinou je tato možnost rozšiřování možností aplikace
s&nbsp;využitím skriptů výhodná pro všechny spolupracující strany &ndash; firma
produkující daný software vlastně zadarmo získá další aplikační oblast,
zákazník či uživatel si takto může aplikaci upravit ke svým potřebám a
popř.&nbsp;na úpravách může spolupracovat i další společnost/vývojáři nezávislí
na autorech původního software (dlouholetým příkladem z&nbsp;praxe jsou
například CADy a jejich nadstavby).</p>

<p>Prozatím jsme se v&nbsp;praktické části seriálu o Go věnovali způsobům
vestavění interpretru <a
href="https://www.root.cz/serialy/programovaci-jazyk-lua/">programovacího
jazyka Lua</a> do aplikace naprogramované v&nbsp;Go. Kombinace Lua+Go
resp.&nbsp;obecněji řečeno Lua+staticky typovaný překládaný jazyk je velmi
běžná a vlastně i logická, protože právě jazyk Lua je navržen s&nbsp;ohledem na
jeho relativně snadnou &bdquo;vložitelnost&ldquo; (<i>embed</i>) do větších
aplikací. Důvodem, proč jsou některé hry, například <i>Escape from Monkey
Island</i>, <i>Grim Fandango</i>, <i>Fish Fillets</i>, <i>Neverwinter
Nights</i> či <i>MDK2</i> z&nbsp;menší či větší části naprogramované právě
v&nbsp;<i>Lue</i>, spočívá v&nbsp;tom, že kombinace nízkoúrovňového a
skriptovacího jazyka umožňuje soustředit se při vývoji na podstatné věci
&ndash; herní engine vytvořit co nejefektivnější s&nbsp;využitím všech možností
nízkoúrovňového jazyka a naopak herní scénář a logiku hry naskriptovat
s&nbsp;co největším urychlením cyklu oprava&ndash;překlad&ndash;spuštění (viz
též <a href="#k20">odkazy na konci dnešního článku</a>).</p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti existuje hned několik
projektů, které programátorům používajícím programovací jazyk Go zpřístupňují
interpret skriptovacího jazyka Lua. Jedná se o projekty <a
href="https://github.com/yuin/gopher-lua">Gopher-Lua</a>, <a
href="https://github.com/Shopify/go-lua">go-lua</a> a taktéž <a
href="https://github.com/aarzilli/golua">golua</a> (interface k&nbsp;původnímu
céčkovému interpretru). Rozšířením knihovny Gopher-Lua je <a
href="https://github.com/alexeyco/binder">Binder</a>.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Doménově specifické jazyky</h2>

<p>Doménově specifické jazyky (<i>DSL &ndash; Domain-Specific Language</i>)
jsou velmi důležitou součástí informatiky a mnohé z&nbsp;nich jsou velmi
úspěšné a rozšířené do mnoha oblastí. Za připomenutí stojí například <i>jazyk
pro popis regulárních výrazů</i>, jenž je podporován jak mnoha nástroji, tak i
knihovnami, popř.&nbsp;je přímo součástí některých obecných programovacích
jazyků (Perl apod.). I v&nbsp;některých dalších případech je tento přístup
velmi užitečný a rozšířený, ostatně například SQL je s&nbsp;velkou
pravděpodobností <a href="https://www.tiobe.com/tiobe-index/">nejpopulárnějším
samostatně chápaným doménově specifickým jazykem</a> neboli DSL vůbec, protože
umožňuje snadné optimalizace dotazů a vůbec pokládání dotazů čitelným,
pochopitelným a přenositelným způsobem. Dalším doménově specifickým jazykem,
s&nbsp;nímž jsme se již na stránkách Roota v&nbsp;rámci několika článků
seznámili, je jazyk <i>Gherkin</i> určený pro popis chování systémů a pro psaní
BDD testů. Dalším příkladem je <a
href="https://www.root.cz/clanky/graficky-metaformat-postscript/">PostScript</a>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Obecné skriptovací jazyky versus doménově specifické jazyky (DSL)</h2>

<p>Mnohé z&nbsp;doménově specifických jazyků nejsou <a
href="https://cs.wikipedia.org/wiki/Turingovsk%C3%A1_%C3%BAplnost">Turingovsky
kompletní (úplný)</a>, což však není nedostatek, ale mnohdy naopak požadovaná
vlastnost. Příkladem mohou být DSL, v&nbsp;nichž není možné zapsat programové
smyčky ani rekurzi &ndash; tudíž je většinou výpočet resp.&nbsp;vyhodnocení
výrazu časově dosti přesně určené. Další DSL neumožňují explicitní alokaci
paměti, což může být v&nbsp;dané oblasti použití taktéž výhodné. Nasazení DSL
oproti plnohodnotnému jazyku tedy může být výhodné, protože cíleně omezené
možnosti takového jazyka můžeme chápat jako formu &bdquo;sémantického
sandboxingu&ldquo; (právě proto jsou regulární výrazy <i>regulární</i>).</p>

<p><div class="rs-tip-major">Poznámka: na tomto místě je zajímavé zmínit
PostScript, který je sice DSL, konkrétně specifickým jazykem pro popis
tiskových stran, ovšem oproti mnoha jiným DSL je Turingovsky kompletní. To
například umožňuje vykreslování procedurální grafiky (viz například <a
href="https://www.root.cz/clanky/fraktaly-v-signaturach-a-dalsi-hacky/#k03">tyto
příklady</a>), ovšem pokud tyto zcela korektní PostScriptové soubory spustíte
na podnikové tiskárně, můžete se dočkat nemilého překvapení
v&nbsp;několikahodinové odstávce, popř.&nbsp;nepříjemného e-mailu z&nbsp;IT
oddělení :-)</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Projekt <strong>Gval</strong></h2>

<p>V&nbsp;dnešním článku si popíšeme doménově specifický jazyk nazvaný
<i>Gval</i>, což je zkratka odvozená ze sousloví &bdquo;Go eVALuate&ldquo;.
Toto sousloví je poměrně přiléhavé, protože se skutečně jedná o DSL zaměřený na
vyhodnocování (<i>evaluate</i>) výrazů, přičemž tyto výrazy mohou být
v&nbsp;některých případech i poměrně komplikované. Jejich syntaxe je odvozena
od samotného programovacího jazyka Go, jak ostatně uvidíme v&nbsp;navazujících
kapitolách, v&nbsp;nichž si ukážeme praktické příklady.</p>

<p>Tento DSL lze použít například při zpracování konfiguračních souborů
(například můžeme nastavit limit počtu workerů na výraz "2*CPU_threads" namísto
pracného nastavování konkrétní číselné hodnoty) nebo i v&nbsp;dialozích a
formulářích grafického uživatelského rozhraní. Příkladem může být vstupní pole
pro odhad pracnosti, do kterého takto můžeme zadat "3*8*60" namísto nutnosti
počítání výsledné hodnoty v&nbsp;nějakém jiném nástroji (ostatně informační
systémy jsou tady od toho, aby nám práci zjednodušovaly a nikoli ji dělaly
složitější &ndash; což se mnohdy děje).</p>

<p><div class="rs-tip-major">Poznámka: to, jaké pojmenované (symbolické)
konstanty je možné ve výrazech použít, je samozřejmě plně v&nbsp;rukou
programátora &ndash; výraz tedy v&nbsp;žádném případě nemá přístup
k&nbsp;celému stavovému prostoru aplikace.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Příklad typu &bdquo;Hello world!&ldquo;</h2>

<p>Podívejme se nyní na způsob předání výrazu do knihovny
<strong>gval</strong>, na způsob jeho vyhodnocení a předání výsledku. Kostra
příkladu získaného přímo ze stránek projektu může vypadat následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "os"
&nbsp;
        "github.com/PaesslerAG/gval"
)
&nbsp;
func <strong>main</strong>() {
        <i>// parametry předávané vyhodnocovanému výrazu</i>
        parameters := map[string]interface{}{"name": "World"}
&nbsp;
        <i>// vyhodnocení výrazu</i>
        value, err := <u>gval.Evaluate(`"Hello " + name + "!"`, parameters)</u>
        if err != nil {
                <i>// kód pro zpracování chyby při vyhodnocování výrazu</i>
                fmt.Println(err)
                os.Exit(1)
        }
&nbsp;
        <i>// výpis výsledku výrazu</i>
        fmt.Print(value)
}
</pre>

<p>Celý tento příklad je postaven okolo funkce <strong>Evaluate</strong>, jejíž
hlavička vypadá následovně:</p>

<pre>
func <strong>Evaluate</strong>(expression string, parameter interface{}, opts ...Language) (interface{}, error)
</pre>

<p>Jak je už z&nbsp;hlavičky této funkce patrné, předá se jí především vlastní
výraz reprezentovaný řetězcem. Dále je možné předat i parametry, což jsou
dvojice jméno+hodnota, které můžeme v&nbsp;rámci výrazu většinou považovat za
pojmenované konstanty (takto tedy aplikace uživatelům nabízí část svého
interního stavu). Poslední parametr je nepovinný a umožňuje rozšiřovat možnosti
doménově specifického jazyka. O této možnosti se zmíníme v&nbsp;navazujícím
článku.</p>

<p>Funkce <strong>Evaluate</strong> vrací dvě hodnoty &ndash; v&nbsp;první řadě
výsledek vyhodnoceného výrazu a taktéž informaci o případné chybě, která může
nastat jak při parsingu výrazu, tak i při jeho vyhodnocování. Povšimněte si
především toho, že výsledná hodnota je typu <strong>interface{}</strong>, což
v&nbsp;programovacím jazyce Go značí libovolnou hodnotu (každý datový typ
<i>splňuje</i> prázdné rozhraní). O případné přetypování se tedy musí postarat
sám programátor, a to i s&nbsp;případnou kontrolou chyb &ndash; typ výsledné
hodnoty totiž přímo závisí na vstupu od uživatele!</p>

<p>Pro spuštění příkladu je nutné vytvořit i projektový soubor příkazem:</p>

<pre>
$ <strong>go mod init jméno_projektu</strong>
</pre>

<p>Po překladu a spuštění by měl projektový soubor vypadat takto:</p>

<pre>
module gval01
&nbsp;
go 1.16
&nbsp;
require github.com/PaesslerAG/gval v1.1.1
</pre>

<p>A soubor se seznamem všech závislostí (i tranzitivních závislostí) bude
vypadat následovně:</p>

<pre>
github.com/PaesslerAG/gval v1.1.1 h1:4d7pprU9876+m3rc08X33UjGip8oV1kkm8Gh5GBuTss=
github.com/PaesslerAG/gval v1.1.1/go.mod h1:Fa8gfkCmUsELXgayr8sfL/sw+VzCVoa03dcOcR/if2w=
github.com/PaesslerAG/jsonpath v0.1.0/go.mod h1:4BzmtoM/PI8fPO4aQGIusjGxGir2BzcV0grWtFzq1Y8=
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Aritmetický výraz</h2>

<p>Ve druhém demonstračním příkladu je ukázáno vyhodnocení velmi jednoduchého
aritmetického výrazu, který obsahuje pouze (celo)číselné konstanty. Jedná se o
jednoduchou modifikaci prvního příkladu, na které budeme stavět i další
demonstrační příklady:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "os"
&nbsp;
        "github.com/PaesslerAG/gval"
)
&nbsp;
func <strong>main</strong>() {
        <i>// parametry předávané vyhodnocovanému výrazu</i>
        parameters := make(map[string]interface{})
&nbsp;
        <i>// vyhodnocení výrazu</i>
        value, err := <u>gval.Evaluate("6*7", parameters)</u>
        if err != nil {
                <i>// kód pro zpracování chyby při vyhodnocování výrazu</i>
                fmt.Println(err)
                os.Exit(1)
        }
&nbsp;
        <i>// výpis výsledku výrazu</i>
        fmt.Print(value)
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Priority operátorů</h2>

<p>Ve výrazech, a to jak ve výrazech aritmetických, tak i logických, je
definována a dodržena priorita operátorů. Ta je přímo odvozena od specifikace
programovacího jazyka Go. Tabulka priorit je v&nbsp;Go poměrně jednoduchá,
zejména v&nbsp;porovnání s&nbsp;tabulkami, které mnozí čtenáři pravděpodobně
znají z&nbsp;jazyků C, C++ či Javy. Nejvyšší prioritu mají unární operátory
(s&nbsp;jediným operandem) a následně existuje pouze pět priorit operátorů
binárních, které si můžete zapamatovat s&nbsp;využitím mnemotechnické pomůcky
MACAO:</p>

<table>
<tr><th>Úroveň</th><th>Operátory</th><th>Mnemotechnická pomůcka</th></tr>
<tr><td>1</td><td>* / %</td><td>Multiplicative</td></tr>
<tr><td>2</td><td>+ -</td><td>Additive</td></tr>
<tr><td>3</td><td>== &gt; &lt; &gt;= &lt;= !=</td><td>Comparison</td></tr>
<tr><td>4</td><td>&amp;&amp;</td><td>And</td></tr>
<tr><td>5</td><td>||</td><td>Or</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je situace nepatrně
složitější, a to kvůli <i>ternárnímu operátoru</i>, který do programovacího
jazyka Go nebyl přidán.</div></p>

<p>Podívejme se nyní, jak se vyhodnotí výraz s&nbsp;aditivními a
multiplikativními operátory:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "os"
&nbsp;
        "github.com/PaesslerAG/gval"
)
&nbsp;
func <strong>main</strong>() {
        <i>// parametry předávané vyhodnocovanému výrazu</i>
        parameters := make(map[string]interface{})
&nbsp;
        <i>// vyhodnocení výrazu</i>
        value, err := <u>gval.Evaluate("2 + 4*10", parameters)</u>
        if err != nil {
                <i>// kód pro zpracování chyby při vyhodnocování výrazu</i>
                fmt.Println(err)
                os.Exit(1)
        }
&nbsp;
        <i>// výpis výsledku výrazu</i>
        fmt.Print(value)
}
</pre>

<p>Výsledek je korektní: 42.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Parametry ve výrazech</h2>

<p>Ve výrazech vyhodnocovaných knihovnou <strong>gval</strong> je možné
používat i jména parametrů. Prozatím si ukažme, jak vypadá takový výraz:</p>

<pre>
2*x + y
</pre>

<p>Nyní se můžeme pokusit o vyhodnocení takového výrazu &ndash; viz též
zdrojový kód uvedený pod tímto odstavcem:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "os"
&nbsp;
        "github.com/PaesslerAG/gval"
)
&nbsp;
func <strong>main</strong>() {
        <i>// parametry předávané vyhodnocovanému výrazu</i>
        parameters := make(map[string]interface{})
&nbsp;
        <i>// vyhodnocení výrazu</i>
        value, err := <u>gval.Evaluate("2*x + y", parameters)</u>
        if err != nil {
                <i>// kód pro zpracování chyby při vyhodnocování výrazu</i>
                fmt.Println(err)
                os.Exit(1)
        }
&nbsp;
        <i>// výpis výsledku výrazu</i>
        fmt.Print(value)
}
</pre>

<p>Výraz je sice po syntaktické stránce zapsán korektně, ovšem nelze
vyhodnotit, protože vyhodnocovací engine nemá přístup k&nbsp;parametrům
<strong>x</strong> a <strong>y</strong>. Dojde tedy k&nbsp;chybě:</p>

<pre>
can not evaluate 2*x + y: invalid operation (float64) * (&lt;nil&gt;)
exit status 1
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Předání parametrů pro vyhodnocení výrazu</h2>

<p>Parametry, které mají být viditelné ve vyhodnocovaném výrazu, je nutné
explicitně vytvořit a přidat jím nějakou hodnotu. Tento krok je sice zdánlivě
zbytečně zdlouhavý, ale právě díky explicitně nastaveným parametrům je striktně
oddělen stavový prostor aplikace od vyhodnocovaného výrazu &ndash; tedy jedná
se o další formu sandboxingu.</p>

<p>Příklad deklarace mapy s&nbsp;parametry (ty mohou mít libovolnou
hodnotu):</p>

<pre>
<i>// parametry předávané vyhodnocovanému výrazu</i>
parameters := map[string]interface{}{
        "x": 10,
        "y": 20,
}
</pre>

<p>Takto definovanou mapu lze předat funkci <strong>gval.Evaluate</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "os"
&nbsp;
        "github.com/PaesslerAG/gval"
)
&nbsp;
func <strong>main</strong>() {
        <i>// parametry předávané vyhodnocovanému výrazu</i>
        parameters := map[string]interface{}{
                "x": 10,
                "y": 20,
        }
&nbsp;
        <i>// vyhodnocení výrazu</i>
        value, err := <u>gval.Evaluate("2*x + y", parameters)</u>
        if err != nil {
                <i>// kód pro zpracování chyby při vyhodnocování výrazu</i>
                fmt.Println(err)
                os.Exit(1)
        }
&nbsp;
        <i>// výpis výsledku výrazu</i>
        fmt.Print(value)
}
</pre>

<p>Výsledkem bude v&nbsp;tomto případě hodnota <strong>40</strong> (podle
očekávání).</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Předání parametrů, které se ve výrazu nepoužijí</h2>

<p>Funkci <strong>gval.Evaluate</strong> je možné předat větší množství
parametrů, než bude skutečně ve výrazu využito. V&nbsp;tomto případě se ani
nenahlásí varování (bylo by ostatně ve většině případů zbytečné). V&nbsp;dalším
demonstračním příkladu předáváme čtyři parametry, ovšem ve skutečnosti jsou ve
výrazu použity jen dva z&nbsp;nich:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "os"
&nbsp;
        "github.com/PaesslerAG/gval"
)
&nbsp;
func <strong>main</strong>() {
        <i>// parametry předávané vyhodnocovanému výrazu</i>
        parameters := map[string]interface{}{
                "x": 10,
                "y": 20,
                "z": 0,
                "w": -1,
        }
&nbsp;
        <i>// vyhodnocení výrazu</i>
        value, err := <u>gval.Evaluate("2*x + y", parameters)</u>
        if err != nil {
                <i>// kód pro zpracování chyby při vyhodnocování výrazu</i>
                fmt.Println(err)
                os.Exit(1)
        }
&nbsp;
        <i>// výpis výsledku výrazu</i>
        fmt.Print(value)
}
</pre>

<p>I v&nbsp;tomto případě se výraz vyhodnotí a vrátí hodnotu
<strong>40</strong>.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Logické operátory</h2>

<p>Ve výrazech vyhodnocovaných knihovnou <strong>gval</strong> je možné použít
i logické operátory a taktéž logické konstanty <strong>true</strong> a
<strong>false</strong>. Následuje jednoduchý demonstrační příklad, který je
založen na použití relačních operací, které vrací pravdivostní hodnotu
<strong>true</strong> či <strong>false</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "os"
&nbsp;
        "github.com/PaesslerAG/gval"
)
&nbsp;
func <strong>main</strong>() {
        <i>// parametry předávané vyhodnocovanému výrazu</i>
        parameters := map[string]interface{}{
                "x": 10,
                "y": 20,
        }
&nbsp;
        <i>// vyhodnocení výrazu</i>
        value, err := <u>gval.Evaluate("2*x &gt; y-5", parameters)</u>
        if err != nil {
                <i>// kód pro zpracování chyby při vyhodnocování výrazu</i>
                fmt.Println(err)
                os.Exit(1)
        }
&nbsp;
        <i>// výpis výsledku výrazu</i>
        fmt.Print(value)
}
</pre>

<p>Nepatrně složitější příklad používá logickou spojku &amp;&amp; neboli
logický součin:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "os"
&nbsp;
        "github.com/PaesslerAG/gval"
)
&nbsp;
func <strong>main</strong>() {
        <i>// parametry předávané vyhodnocovanému výrazu</i>
        parameters := map[string]interface{}{
                "x": 10,
                "y": 20,
        }
&nbsp;
        <i>// vyhodnocení výrazu</i>
        value, err := <u>gval.Evaluate("x &lt; y &amp;&amp; 2*x &gt; y-5", parameters)</u>
        if err != nil {
                <i>// kód pro zpracování chyby při vyhodnocování výrazu</i>
                fmt.Println(err)
                os.Exit(1)
        }
&nbsp;
        <i>// výpis výsledku výrazu</i>
        fmt.Print(value)
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Ternární operátor</h2>

<p>Ve výrazech vyhodnocovaných knihovnou <strong>gval</strong> je možné použít
i takzvaný <i>ternární operátor</i>. Ten byl představen v&nbsp;programovacím
jazyku C a odtud se rozšířil i do mnohých dalších programovacích jazyků, včetně
Javy, JavaScriptu či C#. V&nbsp;jazyce Go tento operátor použit není, ovšem ve
výrazech je velmi užitečný (nemáme zde totiž možnost použít konstrukci
<strong>if-else</strong>) a proto byl do <strong>gval</strong> přidán.</p>

<p>Pochopitelně se opět podíváme na způsob jeho využití:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "os"
&nbsp;
        "github.com/PaesslerAG/gval"
)
&nbsp;
func <strong>main</strong>() {
        <i>// parametry předávané vyhodnocovanému výrazu</i>
        parameters := map[string]interface{}{
                "x": 10,
                "y": 20,
        }
&nbsp;
        <i>// vyhodnocení výrazu</i>
        value, err := <u>gval.Evaluate("x&lt;y ? \"mensi\":\"vetsi\"", parameters)</u>
        if err != nil {
                <i>// kód pro zpracování chyby při vyhodnocování výrazu</i>
                fmt.Println(err)
                os.Exit(1)
        }
&nbsp;
        <i>// výpis výsledku výrazu</i>
        fmt.Print(value)
}
</pre>

<p>V&nbsp;tomto případě je však výhodnější řetězec s&nbsp;výrazem zapsat do
zpětných apostrofů, čímž obejdeme nutnost použití \" pro zápis jednoduchých
uvozovek:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "os"
&nbsp;
        "github.com/PaesslerAG/gval"
)
&nbsp;
func <strong>main</strong>() {
        <i>// parametry předávané vyhodnocovanému výrazu</i>
        parameters := map[string]interface{}{
                "x": 10,
                "y": 20,
        }
&nbsp;
        <i>// vyhodnocení výrazu</i>
        value, err := <u>gval.Evaluate(`x&lt;y ? "mensi":"vetsi"`, parameters)</u>
        if err != nil {
                <i>// kód pro zpracování chyby při vyhodnocování výrazu</i>
                fmt.Println(err)
                os.Exit(1)
        }
&nbsp;
        <i>// výpis výsledku výrazu</i>
        fmt.Print(value)
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Přístup k&nbsp;prvkům pole</h2>

<p>Mezi parametry, které se předávají k&nbsp;vyhodnocení výrazem, mohou být i
pole nebo řezy (<i>slice</i>):</p>

<pre>
parameters := map[string]interface{}{
        "x":   10,
        "y":   20,
        <strong>"arr": []int{10, 20, 30}</strong>,
}
</pre>

<p>Ve výrazu se k&nbsp;prvkům polí přistupuje běžným způsobem &ndash; použitím
celočíselných indexů, které začínají od nuly (tedy naprosto stejně, jako je
tomu v&nbsp;jazyce Go):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "os"
&nbsp;
        "github.com/PaesslerAG/gval"
)
&nbsp;
func <strong>main</strong>() {
        <i>// parametry předávané vyhodnocovanému výrazu</i>
        parameters := map[string]interface{}{
                "x":   10,
                "y":   20,
                "arr": []int{10, 20, 30},
        }
&nbsp;
        <i>// vyhodnocení výrazu</i>
        value, err := <u>gval.Evaluate("arr[0] + arr[1] + arr[2]", parameters)</u>
        if err != nil {
                <i>// kód pro zpracování chyby při vyhodnocování výrazu</i>
                fmt.Println(err)
                os.Exit(1)
        }
&nbsp;
        <i>// výpis výsledku výrazu</i>
        fmt.Print(value)
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Přístup k&nbsp;prvkům datové struktury</h2>

<p>Ve výrazu vyhodnocovaném knihovnou <strong>gval</strong> je možné
přistupovat i k&nbsp;prvkům datové struktury.  V&nbsp;následujícím
demonstračním příkladu je použita tato jednoduchá datová struktura:</p>

<pre>
type <strong>User</strong> struct {
        ID      uint32
        Name    string
        Surname string
}
</pre>

<p>Následně je vytvořena instance této struktury a všechny tři její prvky jsou
naplněny daty:</p>

<pre>
user := User{
        1,
        "Pepek",
        "Vyskoč"}
</pre>

<p>V&nbsp;případě, že tento objekt předáme jako parametr:</p>

<pre>
parameters := map[string]interface{}{
        "x":    10,
        "y":    20,
        "arr":  []int{10, 20, 30},
        <strong>"user": user</strong>,
}
</pre>

<p>Je možné přistupovat k&nbsp;prvkům parametru s&nbsp;využitím běžných
hranatých závorek, tedy stejně, jako je tomu v&nbsp;samotném jazyku Go:</p>

<pre>
`"Jméno:    " + user["Name"] + "\nPříjmení: " + user["Surname"]`
</pre>

<p>Následuje úplný zdrojový kód výše popsaného demonstračního příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "os"
&nbsp;
        "github.com/PaesslerAG/gval"
)
&nbsp;
<i>// User je uživatelsky definovaná datová struktura s viditelnými atributy</i>
type <strong>User</strong> struct {
        ID      uint32
        Name    string
        Surname string
}
&nbsp;
func <strong>main</strong>() {
        user := User{
                1,
                "Pepek",
                "Vyskoč"}
&nbsp;
        <i>// parametry předávané vyhodnocovanému výrazu</i>
        parameters := map[string]interface{}{
                "x":    10,
                "y":    20,
                "arr":  []int{10, 20, 30},
                "user": user,
        }
&nbsp;
        <i>// vyhodnocení výrazu</i>
        value, err := <u>gval.Evaluate(`"Jméno:    " + user["Name"] + "\nPříjmení: " + user["Surname"]`, parameters)</u>
        if err != nil {
                <i>// kód pro zpracování chyby při vyhodnocování výrazu</i>
                fmt.Println(err)
                os.Exit(1)
        }
&nbsp;
        <i>// výpis výsledku výrazu</i>
        fmt.Print(value)
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Indexy pole předané v&nbsp;parametru</h2>

<pre>
package <strong>main</strong>

import (
        "fmt"
        "os"

        "github.com/PaesslerAG/gval"
)

func <strong>main</strong>() {
        <i>// parametry předávané vyhodnocovanému výrazu</i>
        parameters := map[string]interface{}{
                "index1": 0,
                "index2": 2,
                "arr":    []int{10, 20, 30},
        }

        <i>// vyhodnocení výrazu</i>
        value, err := gval.Evaluate("arr[index1] + arr[index2]", parameters)
        if err != nil {
                <i>// kód pro zpracování chyby při vyhodnocování výrazu</i>
                fmt.Println(err)
                os.Exit(1)
        }

        <i>// výpis výsledku výrazu</i>
        fmt.Print(value)
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Jména prvků datové struktury předaná v&nbsp;parametru</h2>

<pre>
package <strong>main</strong>

import (
        "fmt"
        "os"

        "github.com/PaesslerAG/gval"
)

<i>// User je uživatelsky definovaná datová struktura s viditelnými atributy</i>
type <strong>User</strong> struct {
        ID      uint32
        Name    string
        Surname string
}

func <strong>main</strong>() {
        user := User{
                1,
                "Pepek",
                "Vyskoč"}

        <i>// parametry předávané vyhodnocovanému výrazu</i>
        parameters := map[string]interface{}{
                "selector1": "Name",
                "selector2": "Surname",
                "arr":       []int{10, 20, 30},
                "user":      user,
        }

        <i>// vyhodnocení výrazu</i>
        value, err := gval.Evaluate(`"Jméno:    " + user[selector1] + "\nPříjmení: " + user[selector2]`, parameters)
        if err != nil {
                <i>// kód pro zpracování chyby při vyhodnocování výrazu</i>
                fmt.Println(err)
                os.Exit(1)
        }

        <i>// výpis výsledku výrazu</i>
        fmt.Print(value)
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Zkrácený přístup k&nbsp;prvkům datové struktury s&nbsp;využitím tečkové notace</h2>

<pre>
package <strong>main</strong>

import (
        "fmt"
        "os"

        "github.com/PaesslerAG/gval"
)

<i>// User je uživatelsky definovaná datová struktura s viditelnými atributy</i>
type <strong>User</strong> struct {
        ID      uint32
        Name    string
        Surname string
}

func <strong>main</strong>() {
        user := User{
                1,
                "Pepek",
                "Vyskoč"}

        <i>// parametry předávané vyhodnocovanému výrazu</i>
        parameters := map[string]interface{}{
                "user": user,
        }

        <i>// vyhodnocení výrazu</i>
        value, err := gval.Evaluate(`"Jméno:    " + user.Name + "\nPříjmení: " + user.Surname`, parameters)
        if err != nil {
                <i>// kód pro zpracování chyby při vyhodnocování výrazu</i>
                fmt.Println(err)
                os.Exit(1)
        }

        <i>// výpis výsledku výrazu</i>
        fmt.Print(value)
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah dalšího článku</h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
nového Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně stovku kilobajtů), můžete namísto toho použít odkazy na jednotlivé
demonstrační příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad/soubor</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_hello_world</td><td>varianta programu typu &bdquo;Hello world&ldquo; založená na <strong>gval</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_78/01_hello_world">https://github.com/tisnik/go-root/blob/master/article_78/01_hello_world</a></td></tr>
<tr><td> 2</td><td>02_arithmetic</td><td>aritmetické operátory</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_78/02_arithmetic">https://github.com/tisnik/go-root/blob/master/article_78/02_arithmetic</a></td></tr>
<tr><td> 3</td><td>03_priority</td><td>priority operátorů</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_78/03_priority">https://github.com/tisnik/go-root/blob/master/article_78/03_priority</a></td></tr>
<tr><td> 4</td><td>04_no_constants</td><td>pokus o vyhodnocení bez parametrů/konstant</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_78/04_no_constants">https://github.com/tisnik/go-root/blob/master/article_78/04_no_constants</a></td></tr>
<tr><td> 5</td><td>05_constants</td><td>vyhodnocení výrazu s&nbsp;předanými parametry</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_78/05_constants">https://github.com/tisnik/go-root/blob/master/article_78/05_constants</a></td></tr>
<tr><td> 6</td><td>06_more_constants</td><td>nepoužité parametry</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_78/06_more_constants">https://github.com/tisnik/go-root/blob/master/article_78/06_more_constants</a></td></tr>
<tr><td> 7</td><td>07_boolean_expression</td><td>pravdivostní výrazy, jednoduchý příklad</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_78/07_boolean_expression">https://github.com/tisnik/go-root/blob/master/article_78/07_boolean_expression</a></td></tr>
<tr><td> 8</td><td>08_boolean_expression</td><td>pravdivostní výrazy, komplikovanější příklad</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_78/08_boolean_expression">https://github.com/tisnik/go-root/blob/master/article_78/08_boolean_expression</a></td></tr>
<tr><td> 9</td><td>09_ternary_operator</td><td>ternární operátor</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_78/09_ternary_operator">https://github.com/tisnik/go-root/blob/master/article_78/09_ternary_operator</a></td></tr>
<tr><td>10</td><td>10_ternary_operator</td><td>ternární operátor, lepší zápis výrazu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_78/10_ternary_operator">https://github.com/tisnik/go-root/blob/master/article_78/10_ternary_operator</a></td></tr>
<tr><td>11</td><td>11_array_indexing</td><td>indexování prvků v&nbsp;polích konstantou</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_78/11_array_indexing">https://github.com/tisnik/go-root/blob/master/article_78/11_array_indexing</a></td></tr>
<tr><td>12</td><td>12_struct_selector</td><td>výběr prvků struktury konstantou</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_78/12_struct_selector">https://github.com/tisnik/go-root/blob/master/article_78/12_struct_selector</a></td></tr>
<tr><td>13</td><td>13_array_indexing_by_parameter</td><td>indexování prvků v&nbsp;polích parametrem</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_78/13_array_indexing_by_parameter">https://github.com/tisnik/go-root/blob/master/article_78/13_array_indexing_by_parameter</a></td></tr>
<tr><td>14</td><td>14_struct_selector_by_parameter</td><td>výběr prvků struktury parametrem</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_78/14_struct_selector_by_parameter">https://github.com/tisnik/go-root/blob/master/article_78/14_struct_selector_by_parameter</a></td></tr>
<tr><td>15</td><td>15_dot_selector</td><td>výběr prvku struktury tečkovým operátorem</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_78/15_dot_selector">https://github.com/tisnik/go-root/blob/master/article_78/15_dot_selector</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>A curated list of awesome Go frameworks, libraries and software<br />
<a href="https://awesome-go.com/">https://awesome-go.com/</a>
</li>

<li>Gval na GitHubu<br />
<a href="https://github.com/PaesslerAG/gval">https://github.com/PaesslerAG/gval</a>
</li>

<li>Dokumentace k&nbsp;balíčku Gval<br />
<a href="https://coveralls.io/github/PaesslerAG/gval?branch=master">https://coveralls.io/github/PaesslerAG/gval?branch=master</a>
</li>

<li>Gval code coverage report<br />
<a href="https://coveralls.io/github/PaesslerAG/gval?branch=master">https://coveralls.io/github/PaesslerAG/gval?branch=master</a>
</li>

<li>Gopher-Lua<br />
<a href="https://github.com/yuin/gopher-lua">https://github.com/yuin/gopher-lua</a>
</li>

<li>Go-lua<br />
<a href="https://github.com/Shopify/go-lua">https://github.com/Shopify/go-lua</a>
</li>

<li>Binder<br />
<a href="https://github.com/alexeyco/binder">https://github.com/alexeyco/binder</a>
</li>

<li>Kooperace mezi jazykem Lua a nativním (céčkovým) kódem<br />
<a href="https://www.root.cz/clanky/kooperace-mezi-jazykem-lua-a-nativnim-ceckovym-kodem/">https://www.root.cz/clanky/kooperace-mezi-jazykem-lua-a-nativnim-ceckovym-kodem/</a>
</li>

<li>Kooperace mezi jazykem Lua a nativním (céčkovým) kódem: knihovna FFI<br />
<a href="https://www.root.cz/clanky/kooperace-mezi-jazykem-lua-a-nativnim-ceckovym-kodem-knihovna-ffi/">https://www.root.cz/clanky/kooperace-mezi-jazykem-lua-a-nativnim-ceckovym-kodem-knihovna-ffi/</a>
</li>

<li>Skriptovací jazyk Lua v&nbsp;aplikacích naprogramovaných v&nbsp;Go<br />
<a href="https://www.root.cz/clanky/skriptovaci-jazyk-lua-v-aplikacich-naprogramovanych-v-go/">https://www.root.cz/clanky/skriptovaci-jazyk-lua-v-aplikacich-naprogramovanych-v-go/</a>
</li>

<li>Jazyk Joker: dialekt Clojure naprogramovaný v&nbsp;Go<br />
<a href="https://www.root.cz/clanky/jazyk-joker-dialekt-clojure-naprogramovany-v-go/">https://www.root.cz/clanky/jazyk-joker-dialekt-clojure-naprogramovany-v-go/</a>
</li>

<li>Behave na GitHubu<br />
<a href="https://github.com/behave/behave">https://github.com/behave/behave</a>
</li>

<li>behave 1.2.6 (PyPi)<br />
<a href="https://pypi.python.org/pypi/behave">https://pypi.python.org/pypi/behave</a>
</li>

<li>Dokumentace k Behave<br />
<a href="http://behave.readthedocs.io/en/latest/">http://behave.readthedocs.io/en/latest/</a>
</li>

<li>Příklady použití Behave<br />
<a href="https://github.com/behave/behave.example">https://github.com/behave/behave.example</a>
</li>

<li>Domain-specific language<br />
<a href="https://en.wikipedia.org/wiki/Domain-specific_language">https://en.wikipedia.org/wiki/Domain-specific_language</a>
</li>

<li>Turingovská úplnost<br />
<a href="https://cs.wikipedia.org/wiki/Turingovsk%C3%A1_%C3%BAplnost">https://cs.wikipedia.org/wiki/Turingovsk%C3%A1_%C3%BAplnost</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

