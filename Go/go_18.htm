<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Knihovny určené pro tvorbu testů v programovacím jazyce Go</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Knihovny určené pro tvorbu testů v programovacím jazyce Go</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešní části seriálu o programovacím jazyce Go navážeme na část předchozí, v níž jsme se seznámili se základními způsoby psaní jednotkových testů i s mockováním funkcí a metod. Dnes si popíšeme další knihovny, které jsou určeny pro usnadnění psaní jednotkových i integračních testů.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Knihovny určené pro tvorbu testů v&nbsp;programovacím jazyce Go</a></p>
<p><a href="#k02">2. Krátké zopakování &ndash; použití standardního balíčku <strong>testing</strong> pro vytvoření jednotkového testu</a></p>
<p><a href="#k03">3. Výsledek běhu standardních jednotkových testů</a></p>
<p><a href="#k04">4. Když možnosti balíčku <strong>testing</strong> nedostačují...</a></p>
<p><a href="#k05">5. Přepis jednotkových testů s&nbsp;využitím balíčku <strong>oglematchers</strong></a></p>
<p><a href="#k06">6. Zjednodušení testů použitím &bdquo;tečkového&ldquo; importu</a></p>
<p><a href="#k07">7. Kombinace balíčků <strong>ogletest</strong> a <strong>oglematchers</strong></a></p>
<p><a href="#k08">8. Třetí varianta jednotkových testů</a></p>
<p><a href="#k09">9. Knihovna <strong>assertions</strong></a></p>
<p><a href="#k10">10. Použití základních funkcí pro otestování platnosti předpokladů</a></p>
<p><a href="#k11">11. Kombinace knihoven <strong>assert</strong> a <strong>assertions</strong></a></p>
<p><a href="#k12">12. Zjednodušení zápisu testů použitím &bdquo;tečkového&ldquo; importu</a></p>
<p><a href="#k13">13. Knihovna GoConvey</a></p>
<p><a href="#k14">14. Přepis jednotkových testů s&nbsp;použitím knihovny GoConvey</a></p>
<p><a href="#k15">15. Výsledky testů</a></p>
<p><a href="#k16">16. Alternativní formát výstupu</a></p>
<p><a href="#k17">17. Pořadí spouštění jednotlivých kroků definovaných v&nbsp;BDD testech</a></p>
<p><a href="#k18">18. Výsledky BDD testů</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Knihovny určené pro tvorbu testů v&nbsp;programovacím jazyce Go</h2>

<p><a
href="https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/">V&nbsp;předchozí
části</a> <a href="https://www.root.cz/serialy/programovaci-jazyk-go/">seriálu
o programovacím jazyku Go</a> jsme si řekli základní informace o tvorbě
jednotkových testů (<i>unit test</i>) v&nbsp;jazyce Go. Připomeňme si jen ve
stručnosti, že již v&nbsp;základní instalaci tohoto programovacího jazyka je
programátorům k&nbsp;dispozici balíček nazvaný <strong>testing</strong>, který
je možné pro psaní jednotkových testů použít. Současně je možné základnímu
nástroji <strong>go</strong>, který spouští většinu standardních operací
v&nbsp;kontextu ekosystému tohoto jazyka, předat příkaz <strong>test</strong>,
jenž provede následující operace:</p>

<ol>

<li>Nalezne v&nbsp;aktuálním adresáři popř.&nbsp;i v&nbsp;případných
podadresářích soubory končící na &bdquo;_test.go&ldquo; (jména souborů by ovšem
neměla začínat samotným podtržítkem).</li>

<li>V&nbsp;těchto souborech se nástroj dále pokusí najít ty funkce, jejichž
názvy začínají prefixem &bdquo;Test&ldquo;, za nímž následuje alespoň jedno
velké písmeno (korektní název testu je tedy například &bdquo;TestAdd&ldquo;,
ovšem nikoli už &bdquo;Testik&ldquo;).</li>

<li>Tyto funkce se následně spustí s&nbsp;tím, že jejich prvním (a většinou i
jediným) parametrem bude reference na strukturu typu
<strong>testing.T</strong>. Existuje přitom možnost paralelního spouštění
testů, což by nám však nemělo v&nbsp;praxi vadit, protože jednotlivé testy by
měly být naprogramovány takovým způsobem, aby je bylo možné spouštět
izolovaně.</li>

</ol>

<p>Samotné jednotkové testy jsou psány přímo v&nbsp;programovacím jazyce Go, a
to (alespoň při použití základního modulu <strong>testing</strong>) bez použití
dalších specializovaných knihoven a případných nových jazykových konstrukcí.
Slovy tvůrců tohoto jazyka:</p>

<p><i>&bdquo;A related point is that testing frameworks tend to develop into
mini-languages of their own, with conditionals and controls and printing
mechanisms, but Go already has all those capabilities; why recreate them? We'd
rather write tests in Go; it's one fewer language to learn and the approach
keeps the tests straightforward and easy to understand.&ldquo;</i></p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;praxi to znamená mj.&nbsp;i to,
že nemůžeme použít (neexistující) klíčové slovo <strong>assert</strong>, což je
mezi moderními programovacími jazyky spíše výjimka.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Krátké zopakování &ndash; použití standardního balíčku <strong>testing</strong> pro vytvoření jednotkového testu</h2>

<p>Připomeňme si nyní, jak vlastně mohou jednotkové testy vypadat, nejprve
v&nbsp;případě, že použijeme standardní balíček <strong>testing</strong>.
Testovat budeme známou funkci pro výpočet faktoriálu, která je implementována
rekurzivním výpočtem (což možná není pro jazyk Go příliš idiomatické a vlastně
ani nejrychlejší řešení). Tato funkce, kterou budeme v&nbsp;rámci dnešního
článku testovat hned několika různými způsoby a knihovnami, je <a
href="https://github.com/tisnik/go-root/blob/master/article_18/01_factorial_testing/factorial.go">implementována
následujícím způsobem</a>:</p>

<pre>
package factorial
&nbsp;
func <strong>Factorial</strong>(n int64) int64 {
        switch {
        case n &lt; 0:
                return 1
        case n == 0:
                return 1
        default:
                return n * Factorial(n-1)
        }
}
</pre>

<p><div class="rs-tip-major">Poznámka: funkci pro výpočet faktoriálu je
pochopitelně možné napsat i jednodušším způsobem (minimálně lze ušetřit jednu
programovou větev), ovšem ukázaná implementace má tu výhodu, že ji lze snadno
měnit a zkoušet tak vliv provedených změn na jednotlivé testy.</div></p>

<p>Jednotkové testy budou uloženy v&nbsp;souboru nazvaném <a
href="https://github.com/tisnik/go-root/blob/master/article_18/01_factorial_testing/factorial_test.go">factorial_test.go</a>.
V&nbsp;tomto souboru samozřejmě může být napsáno libovolné množství
jednotkových testů, pouze musíme dodržet výše zmíněnou jmennou konvenci.
Povšimněte si, že v&nbsp;jednotlivých testech explicitně zapisujeme podmínky a
v&nbsp;nich se volají metody <strong>t.Error</strong>,
<strong>t.Errorf</strong>, <strong>t.Fail</strong>, <strong>t.FailNow</strong>,
<strong>t.Fatal</strong> atd., s&nbsp;nimiž jsme se seznámili minule:</p>

<pre>
package factorial_test
&nbsp;
import (
        "factorial"
        "testing"
)
&nbsp;
func <strong>TestFactorialForZero</strong>(t *testing.T) {
        result := factorial.Factorial(0)
        if result != 1 {
                t.Errorf("Expected that 0! == 1, but got %d instead", result)
        }
}
&nbsp;
func <strong>TestFactorialForOne</strong>(t *testing.T) {
        result := factorial.Factorial(1)
        if result != 1 {
                t.Errorf("Expected that 1! == 1, but got %d instead", result)
        }
}
&nbsp;
func <strong>TestFactorialForSmallNumber</strong>(t *testing.T) {
        result := factorial.Factorial(5)
        if result &lt;= 10 || result &gt;= 10000 {
                t.Errorf("Expected that 5! == is between 10..10000")
        }
}
&nbsp;
func <strong>TestFactorialForSmallNumberNegative</strong>(t *testing.T) {
        result := factorial.Factorial(20)
        if result &lt;= 10 || result &gt;= 10000 {
                t.Errorf("Expected that 20! == is between 10..10000")
        }
}
&nbsp;
func <strong>TestFactorialForTen</strong>(t *testing.T) {
        result := factorial.Factorial(10)
        expected := int64(3628800)
        if result != expected {
                t.Errorf("Expected that 10! == %d, but got %d instead", expected, result)
        }
}
&nbsp;
func <strong>TestFactorialForBigNumber</strong>(t *testing.T) {
        result := factorial.Factorial(20)
        if result &lt;= 0 {
                t.Errorf("Expected that 20! &gt; 0, but got negative number %d instead", result)
        }
}
&nbsp;
func <strong>TestFactorialForEvenBiggerNumber</strong>(t *testing.T) {
        result := factorial.Factorial(30)
        if result &lt;= 0 {
                t.Errorf("Expected that 30! &gt; 0, but got negative number %d instead", result)
        }
}
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Výsledek běhu standardních jednotkových testů</h2>

<p>Zajímavé bude i samotné spuštění jednotkových testů, protože dva testy jsou
schválně napsány takovým způsobem, aby jimi testovaná podmínka ve skutečnosti
<i>nebyla</i> splněna. Aby bylo možné získat podrobnější informace i o těch
testech, které proběhly korektně, použijeme při spouštění příkazu <strong>go
test</strong> i přepínač <strong>-v</strong> (<i>verbose</i>):</p>

<pre>
$ <strong>go test -v</strong>
</pre>

<p>Výsledky by měly vypadat takto:</p>

<pre>
=== RUN   TestFactorialForZero
--- PASS: TestFactorialForZero (0.00s)
=== RUN   TestFactorialForOne
--- PASS: TestFactorialForOne (0.00s)
=== RUN   TestFactorialForSmallNumber
--- PASS: TestFactorialForSmallNumber (0.00s)
=== RUN   TestFactorialForSmallNumberNegative
--- FAIL: TestFactorialForSmallNumberNegative (0.00s)
    factorial_test.go:32: Expected that 20! == is between 10..10000
=== RUN   TestFactorialForTen
--- PASS: TestFactorialForTen (0.00s)
=== RUN   TestFactorialForBigNumber
--- PASS: TestFactorialForBigNumber (0.00s)
=== RUN   TestFactorialForEvenBiggerNumber
--- FAIL: TestFactorialForEvenBiggerNumber (0.00s)
    factorial_test.go:54: Expected that 30! &gt; 0, but got negative number -8764578968847253504 instead
FAIL
exit status 1
FAIL    _/home/tester/go-root/article_18/01_factorial_testing   0.004s
</pre>

<p><div class="rs-tip-major">Poznámka: jeden z&nbsp;testů byl napsán schválně
takovým způsobem, aby jeho podmínka nebyla splněna. Další z&nbsp;testů, které
nebyly úspěšné, sice teoreticky správně předpokládá, že faktoriál jakékoli celé
hodnoty by měl být kladné číslo, ovšem kvůli přetečení výsledků při použití
datového typu <strong>int64</strong> tato podmínka ve skutečnosti není vždy
splněna (ostatně si můžete sami vyzkoušet, pro jaké <i>n</i> je funkce korektní
a pro jaké by bylo zapotřebí použít balíček <strong>big</strong> a jeho datový
typ <strong>Int</strong> s&nbsp;prakticky neomezenou přesností).</div></p>

<p>Pokud do testu přidáme funkci začínající prefixem &bdquo;Test&ldquo;, ovšem
se špatným (či neexistujícím) typem parametru, bude tento problém nahlášen při
pokusu o spuštění jednotkových testů:</p>

<pre>
package factorial_test
&nbsp;
import (
        "factorial"
        "testing"
)
&nbsp;
func <strong>TestX</strong>() {
        println("TestX")
}
&nbsp;
func <strong>TestFactorialForZero</strong>(t *testing.T) {
        result := factorial.Factorial(0)
        if result != 1 {
                t.Errorf("Expected that 0! == 1, but got %d instead", result)
        }
}
</pre>

<p>V&nbsp;případě, že se testy pokusíme spustit, bude zpráva o špatné
<i>signatuře</i> (hlavičce) funkce s&nbsp;implementací testu nahlášena již ve
fázi přípravy testů (nikoli až při jejich běhu):</p>

<pre>
$ <strong>go test -v</strong>
&nbsp;
# factorial
/home/test/go/src/factorial/factorial_test.go:8:1: wrong signature for TestX, must be: func TestX(t *testing.T)
FAIL    factorial [setup failed]
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Když možnosti balíčku <strong>testing</strong> nedostačují...</h2>

<p>Již při letmém pohledu na jednotkové testy, které jsme si ukázali <a
href="#k02">v&nbsp;předchozích dvou kapitolách</a>, je patrné, že se
v&nbsp;nich prakticky neustále opakují ty samé operace: zavolání testované
funkce (nebo metody), porovnání výsledků zavolané funkce s&nbsp;očekávanými
hodnotami a případné zahlášení chybného výsledku v&nbsp;programové větvi
s&nbsp;podmínkou. To sice plně odpovídá záměrům tvůrců programovacího jazyka
Go, ovšem je nutné si uvědomit, že (pravděpodobně) velká většina programátorů,
kteří jazyk Go používají, vyvíjí SW i v&nbsp;jiných programovacích jazycích,
v&nbsp;nichž může být přístup k&nbsp;tvorbě jednotkových testů odlišný.
Z&nbsp;tohoto důvodu pravděpodobně nebude příliš velkým překvapením, že vzniklo
relativně velké množství různých knihoven i celých nástrojů, jejichž cílem je
umožnit psát jednotkové a integrační testy sice přímo v&nbsp;programovacím
jazyku Go, ovšem s&nbsp;minimem ručního a explicitního zápisu programových
bloků <strong>if</strong> s&nbsp;podmínkami. Dnes si některé z&nbsp;těchto
knihoven alespoň ve stručnosti představíme:</p>

<ol>
<li>Pomocná knihovna <a href="#k05">oglematchers</a> usnadňující specifikaci podmínek.</li>
<li>Knihovna <a href="#k07">ogletest</a> využívající zmíněnou knihovnu <i>oglematchers</i>.</li>
<li>Jednoduše použitelná knihovna <a href="#k09">assertions</a>, opět usnadňující specifikaci podmínek.</li>
<li>Knihovna nazvaná <a href="#k11">assert</a>, která doplňuje knihovnu <i>assertions</i>.</li>
<li>A konečně se jedná o knihovnu se jménem <a href="#k13">GoConvey</a>.</li>
</ol>



<p><a name="k05"></a></p>
<h2 id="k05">5. Přepis jednotkových testů s&nbsp;využitím balíčku <strong>oglematchers</strong></h2>

<p>První z&nbsp;knihoven, s&nbsp;níž se dnes seznámíme, se jmenuje
<i>oglematchers</i> a její zdrojové kódy nalezneme na GitHubu na adrese <a
href="https://github.com/jacobsa/oglematchers">https://github.com/jacobsa/oglematchers</a>.
Striktně řečeno se vlastně nejedná o knihovnu určenou pro vytváření
plnohodnotných jednotkových testů, ale &bdquo;pouze&ldquo; o sadu pomocných
funkcí umožňujících explicitnější zápis podmínek pro jednotkové testy. Dobré
vlastnosti knihovny <i>oglematchers</i> plně oceníme až ve chvíli, kdy je
zkombinujeme s&nbsp;knihovnou <i>ogletest</i>, s&nbsp;níž se seznámíme až <a
href="#k07">v&nbsp;sedmé kapitole</a>.</p>

<p>Instalace této knihovny probíhá naprosto stejným způsobem, jako instalace
prakticky jakéhokoli jiného balíčku programovacího jazyka Go:</p>

<pre>
$ <strong>go get -u github.com/jacobsa/oglematchers</strong>
</pre>

<p>Principem, na němž je knihovna <i>oglematchers</i> založena, jsou takzvané
<i>matchery</i>, což jsou objekty testující jednu či více podmínek, které se
jednou vytvoří a následně je možné je použít ve více testech či ve více krocích
jediného testu. Navíc je možné <i>matchery</i> různým způsobem kombinovat ve
stylu &bdquo;musí platit alespoň jedna z&nbsp;podmínek&ldquo; nebo &bdquo;musí
současně platit všechny podmínky&ldquo;. Nezávisle na tom, jakým způsobem je
<i>matcher</i> vytvořen, nabízí programátorům metodu <strong>Matches</strong>,
které se předá testovaná hodnota či testované hodnoty a výsledkem je buď
návratová hodnota <strong>nil</strong> ve chvíli, kdy test proběhl
v&nbsp;pořádku, či &bdquo;nenilová&ldquo; hodnota reprezentující chybu:</p>

<table>
<tr><th>Matcher</th></tr>
<tr><td><a href="https://godoc.org/github.com/jacobsa/oglematchers#AllOf">AllOf</a></td></tr>
<tr><td><a href="https://godoc.org/github.com/jacobsa/oglematchers#AnyOf">AnyOf</a></td></tr>
<tr><td><a href="https://godoc.org/github.com/jacobsa/oglematchers#Any">Any</a></td></tr>
<tr><td><a href="https://godoc.org/github.com/jacobsa/oglematchers#Contains">Contains</a></td></tr>
<tr><td><a href="https://godoc.org/github.com/jacobsa/oglematchers#DeepEquals">DeepEquals</a></td></tr>
<tr><td><a href="https://godoc.org/github.com/jacobsa/oglematchers#ElementsAre">ElementsAre</a></td></tr>
<tr><td><a href="https://godoc.org/github.com/jacobsa/oglematchers#Equals">Equals</a></td></tr>
<tr><td><a href="https://godoc.org/github.com/jacobsa/oglematchers#Error">Error</a></td></tr>
<tr><td><a href="https://godoc.org/github.com/jacobsa/oglematchers#GreaterOrEqual">GreaterOrEqual</a></td></tr>
<tr><td><a href="https://godoc.org/github.com/jacobsa/oglematchers#GreaterThan">GreaterThan</a></td></tr>
<tr><td><a href="https://godoc.org/github.com/jacobsa/oglematchers#HasSameTypeAs">HasSameTypeAs</a></td></tr>
<tr><td><a href="https://godoc.org/github.com/jacobsa/oglematchers#HasSubstr">HasSubstr</a></td></tr>
<tr><td><a href="https://godoc.org/github.com/jacobsa/oglematchers#IdenticalTo">IdenticalTo</a></td></tr>
<tr><td><a href="https://godoc.org/github.com/jacobsa/oglematchers#LessOrEqual">LessOrEqual</a></td></tr>
<tr><td><a href="https://godoc.org/github.com/jacobsa/oglematchers#LessThan">LessThan</a></td></tr>
<tr><td><a href="https://godoc.org/github.com/jacobsa/oglematchers#MatchesRegexp">MatchesRegexp</a></td></tr>
<tr><td><a href="https://godoc.org/github.com/jacobsa/oglematchers#Not">Not</a></td></tr>
<tr><td><a href="https://godoc.org/github.com/jacobsa/oglematchers#Panics">Panics</a></td></tr>
<tr><td><a href="https://godoc.org/github.com/jacobsa/oglematchers#Pointee">Pointee</a></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: velkou předností <i>matcherů</i> oproti
explicitně zapisovaným podmínkám je právě možnost použít je v&nbsp;libovolném
množství jednotkových testů. Toho lze samozřejmě dosáhnout i při použití
standardní knihovny <i>testing</i>, protože funkce jsou v&nbsp;jazyku Go
plnohodnotným datovým typem (a tedy je lze uložit do proměnné atd. atd.), ovšem
výsledný zápis nebude příliš standardní.</div></p>

<p>Jednotkové testy naprogramované s&nbsp;využitím základní knihovny
<i>testing</i> je samozřejmě možné relativně snadno přepsat takovým způsobem,
aby se použily některé možnosti nabízené knihovnou <i>oglematchers</i>. Nejprve
se podívejme na ty testy, v&nbsp;nichž je použita jednoduchá podmínka
porovnávající výsledek výpočtu faktoriálu s&nbsp;očekávanou hodnotou.
Povšimněte si, že se skutečně jedná o pomocnou knihovnu, protože používáme
všechny konvence, které známe ze standardní knihovny <i>testing</i>; pouze
samotný zápis testované podmínky a její vyhodnocení je odlišný. V&nbsp;tom
nejjednodušším případě můžeme zkonstruovat <i>matcher</i>, který porovná
hodnotu vypočtenou funkcí <strong>Factorial</strong> s&nbsp;očekávanou
hodnotou. Samotný <i>matcher</i> se v&nbsp;takovém případě sestrojí
konstruktorem <strong>Equals</strong>:</p>

<pre>
func <strong>TestFactorialForZero</strong>(t *testing.T) {
        result := factorial.Factorial(0)
        m := <strong>oglematchers.Equals</strong>(1)
        if <strong>m.Matches</strong>(result) != nil {
                t.Errorf("Expected that 0! == 1, but got %d instead", result)
        }
}
</pre>

<p>Samozřejmě jsou k&nbsp;dispozici i jiné typy <i>matcherů</i>, například
takový matcher, který testuje podmínku &bdquo;větší než&ldquo;. Ten se vytvoří
konstruktorem <strong>GreaterThan</strong>; opět je samozřejmě k&nbsp;dispozici
metoda <strong>Matches</strong> pro vlastní testování:</p>

<pre>
func <strong>TestFactorialForBigNumber</strong>(t *testing.T) {
        result := factorial.Factorial(20)
        m := <strong>oglematchers.GreaterThan</strong>(0)
        if <strong>m.Matches</strong>(result) != nil {
                t.Errorf("Expected that 20! &gt; 0, but got negative number %d instead", result)
        }
}
</pre>

<p>Zajímavější jsou ty jednotkové testy, ve kterých se používají dvě podmínky,
které musí platit současně. Zde je možné vytvořit <i>matcher</i> konstruktorem
<strong>AllOf</strong>, jemuž se předají další matchery, jejichž podmínky musí
platit současně. Podobným způsobem je možné v&nbsp;případě potřeby konstruovat
i složitější podmínky:</p>

<pre>
func <strong>TestFactorialForSmallNumber</strong>(t *testing.T) {
        result := factorial.Factorial(5)
        m := <strong>oglematchers.AllOf</strong>(
                <strong>oglematchers.GreaterThan</strong>(10),
                <strong>oglematchers.LessThan</strong>(10000))
        if <strong>m.Matches</strong>(result) != nil {
                t.Errorf("Expected that 5! == is between 10..10000")
        }
}
</pre>

<p>Úplný kód <a
href="https://github.com/tisnik/go-root/blob/master/article_18/02_factorial_oglematchers/factorial_test.go">příkladu
s&nbsp;přepsanými jednotkovými testy</a> může vypadat následovně:</p>

<pre>
package factorial_test
&nbsp;
import (
        "factorial"
        "github.com/jacobsa/oglematchers"
        "testing"
)
&nbsp;
func <strong>TestFactorialForZero</strong>(t *testing.T) {
        result := factorial.Factorial(0)
        m := oglematchers.Equals(1)
        if m.Matches(result) != nil {
                t.Errorf("Expected that 0! == 1, but got %d instead", result)
        }
}
&nbsp;
func <strong>TestFactorialForOne</strong>(t *testing.T) {
        result := factorial.Factorial(1)
        m := oglematchers.Equals(1)
        if m.Matches(result) != nil {
                t.Errorf("Expected that 1! == 1, but got %d instead", result)
        }
}
&nbsp;
func <strong>TestFactorialForSmallNumber</strong>(t *testing.T) {
        result := factorial.Factorial(5)
        m := oglematchers.AllOf(
                oglematchers.GreaterThan(10),
                oglematchers.LessThan(10000))
        if m.Matches(result) != nil {
                t.Errorf("Expected that 5! == is between 10..10000")
        }
}
&nbsp;
func <strong>TestFactorialForSmallNumberNegative</strong>(t *testing.T) {
        result := factorial.Factorial(20)
        m := oglematchers.AllOf(
                oglematchers.GreaterThan(10),
                oglematchers.LessThan(10000))
        if m.Matches(result) != nil {
                t.Errorf("Expected that 20! == is between 10..10000")
        }
}
&nbsp;
func <strong>TestFactorialForTen</strong>(t *testing.T) {
        result := factorial.Factorial(10)
        expected := int64(3628800)
        m := oglematchers.Equals(expected)
        if m.Matches(result) != nil {
                t.Errorf("Expected that 10! == %d, but got %d instead", expected, result)
        }
}
&nbsp;
func <strong>TestFactorialForBigNumber</strong>(t *testing.T) {
        result := factorial.Factorial(20)
        m := oglematchers.GreaterThan(0)
        if m.Matches(result) != nil {
                t.Errorf("Expected that 20! &gt; 0, but got negative number %d instead", result)
        }
}
&nbsp;
func <strong>TestFactorialForEvenBiggerNumber</strong>(t *testing.T) {
        result := factorial.Factorial(30)
        m := oglematchers.GreaterThan(0)
        if m.Matches(result) != nil {
                t.Errorf("Expected that 30! &gt; 0, but got negative number %d instead", result)
        }
}
</pre>

<p>Vzhledem k&nbsp;tomu, že jsme použili stejný formát testů, jaký odpovídá
standardnímu balíčku <i>testing</i>, budou se i samotné testy spouštět naprosto
stejným způsobem, jako běžné jednotkové testy:</p>

<pre>
$ <strong>go test</strong>
&nbsp;
--- FAIL: TestFactorialForSmallNumberNegative (0.00s)
    factorial_test.go:41: Expected that 20! == is between 10..10000
--- FAIL: TestFactorialForEvenBiggerNumber (0.00s)
    factorial_test.go:66: Expected that 30! &gt; 0, but got negative number -8764578968847253504 instead
FAIL
exit status 1
FAIL    _/home/tester/go-root/article_18/02_factorial_oglematchers      0.004s
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Zjednodušení testů použitím &bdquo;tečkového&ldquo; importu</h2>

<p>Psaní prefixu &bdquo;oglematchers&ldquo; před všemi funkcemi z&nbsp;balíčku
<i>oglematchers</i> je v&nbsp;případě tvorby jednotkových testů většinou
nadbytečné, protože (opět většinou) v&nbsp;modulech s&nbsp;jednotkovými testy
importujeme pouze omezené množství dalších balíčků &ndash; testovaný balíček,
balíček <i>oglematchers</i> a pochopitelně i balíček <i>testing</i>. Samotný
zápis zdrojového kódu s&nbsp;testy si v&nbsp;takovém případě můžeme zjednodušit
použitím &bdquo;tečkového&ldquo; importu, s&nbsp;nímž jsme se již seznámili
v&nbsp;předchozích částech tohoto seriálu:</p>

<pre>
import (
        "factorial"
        . "github.com/jacobsa/oglematchers"
        "testing"
)
</pre>

<p>Podívejme se nyní na to, jak bude vypadat <a
href="https://github.com/tisnik/go-root/blob/master/article_18/03_factorial_oglematchers2/factorial_test.go">přepsaný
zdrojový kód se všemi jednotkovými testy</a>. Samotná logika testů zůstává
zachována, pouze není nutné psát prefix s&nbsp;názvem balíčku:</p>

<pre>
package factorial_test
&nbsp;
import (
        "factorial"
        . "github.com/jacobsa/oglematchers"
        "testing"
)
&nbsp;
func <strong>TestFactorialForZero</strong>(t *testing.T) {
        result := factorial.Factorial(0)
        m := Equals(1)
        if m.Matches(result) != nil {
                t.Errorf("Expected that 0! == 1, but got %d instead", result)
        }
}
&nbsp;
func <strong>TestFactorialForOne</strong>(t *testing.T) {
        result := factorial.Factorial(1)
        m := Equals(1)
        if m.Matches(result) != nil {
                t.Errorf("Expected that 1! == 1, but got %d instead", result)
        }
}
&nbsp;
func <strong>TestFactorialForSmallNumber</strong>(t *testing.T) {
        result := factorial.Factorial(5)
        m := AllOf(
                GreaterThan(10),
                LessThan(10000))
        if m.Matches(result) != nil {
                t.Errorf("Expected that 5! == is between 10..10000")
        }
}
&nbsp;
func <strong>TestFactorialForSmallNumberNegative</strong>(t *testing.T) {
        result := factorial.Factorial(20)
        m := AllOf(
                GreaterThan(10),
                LessThan(10000))
        if m.Matches(result) != nil {
                t.Errorf("Expected that 20! == is between 10..10000")
        }
}
&nbsp;
func <strong>TestFactorialForTen</strong>(t *testing.T) {
        result := factorial.Factorial(10)
        expected := int64(3628800)
        m := Equals(expected)
        if m.Matches(result) != nil {
                t.Errorf("Expected that 10! == %d, but got %d instead", expected, result)
        }
}
&nbsp;
func <strong>TestFactorialForBigNumber</strong>(t *testing.T) {
        result := factorial.Factorial(20)
        m := GreaterThan(0)
        if m.Matches(result) != nil {
                t.Errorf("Expected that 20! &gt; 0, but got negative number %d instead", result)
        }
}
&nbsp;
func <strong>TestFactorialForEvenBiggerNumber</strong>(t *testing.T) {
        result := factorial.Factorial(30)
        m := GreaterThan(0)
        if m.Matches(result) != nil {
                t.Errorf("Expected that 30! &gt; 0, but got negative number %d instead", result)
        }
}
</pre>

<p>Vzhledem k&nbsp;tomu, že se logika jednotlivých jednotkových testů
nezměnila, je pochopitelné, že i jejich výsledky budou naprosto stejné, o čemž
se samozřejmě můžeme velmi snadno přesvědčit:</p>

<pre>
$ <strong>go test</strong>
&nbsp;
--- FAIL: TestFactorialForSmallNumberNegative (0.00s)
    factorial_test.go:41: Expected that 20! == is between 10..10000
--- FAIL: TestFactorialForEvenBiggerNumber (0.00s)
    factorial_test.go:66: Expected that 30! &gt; 0, but got negative number -8764578968847253504 instead
FAIL
exit status 1
FAIL    _/home/tester/go-root/article_18/03_factorial_oglematchers2     0.004s
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Kombinace balíčků <strong>ogletest</strong> a <strong>oglematchers</strong></h2>

<p>Možnosti poskytované knihovnou <i>oglematchers</i> v&nbsp;celé šíři oceníme
až ve chvíli, kdy ji zkombinujeme s&nbsp;knihovnou nazvanou <i>ogletest</i>
(asi není nutno dodávat, že obě knihovny pochází ze stejného zdroje). Knihovna
<i>ogletest</i> se snaží nahradit některé koncepty základní knihovny
<i>testing</i>, což vyžaduje provedení určitých změn ve struktuře testů. Stále
se sice využívá příkazu <strong>go test</strong>, ovšem v&nbsp;celém souboru
s&nbsp;jednotkovými testy se bude nacházet jen jediný test, který vlastně bude
spouštět všechny testy další. Tento speciální test může vypadat následovně:</p>

<pre>
func <strong>TestOgletest</strong>(t *testing.T) {
        ogletest.RunTests(t)
}
</pre>

<p>Dále vytvoříme datovou strukturu, v&nbsp;níž bude možné udržovat kontext,
v&nbsp;rámci něhož jsou jednotkové testy spouštěny:</p>

<pre>
type <strong>FactorialTest</strong> struct{}
</pre>

<p>Tuto strukturu bude nutné zaregistrovat ve funkci <strong>init</strong>:</p>

<pre>
func <strong>init</strong>() {
        ogletest.RegisterTestSuite(&amp;FactorialTest{})
}
</pre>

<p>V&nbsp;tomto okamžiku je možné spustit všechny jednotkové testy, které jsou
implementovány jako <i>metody</i> datového typu
<strong>FactorialTest</strong>, například:</p>

<pre>
func (t *FactorialTest) <strong>FactorialForZero</strong>() {
        result := factorial.Factorial(0)
        ogletest.ExpectThat(result, oglematchers.Equals(1))
}
</pre>

<p>nebo:</p>

<pre>
func (t *FactorialTest) TestFactorialSmallNumberNegative() {
        result := factorial.Factorial(20)
        ogletest.ExpectThat(result, oglematchers.AllOf(
                oglematchers.GreaterThan(10),
                oglematchers.LessThan(10000)))
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že v&nbsp;tomto případě
není nutné, aby měly funkce/metody s&nbsp;implementací jednotkových testů
nějaká speciální jména.</div></p>

<p>V&nbsp;knihovně <i>ogletest</i> nalezneme dvě skupiny funkcí určených pro
psaní jednotkových testů. V&nbsp;první skupině (<strong>Expect*</strong>) jsou
funkce s&nbsp;podmínkou, při jejímž nesplnění se zaznamená chyba a test
pokračuje dále. Ve druhé skupině (<strong>Assert*</strong>) naopak nalezneme
takové funkce, které při nesplnění podmínky aktuálně spuštěný test ukončí.
Samotné podmínky jsou v&nbsp;obou skupinách prakticky totožné:</p>

<table>
<tr><th>První skupina</th><th>Druhá skupina</th></tr>
<tr><td>ExpectEq</td><td>AssertEq</td></tr>
<tr><td>ExpectFalse</td><td>AssertFalse</td></tr>
<tr><td>ExpectGe</td><td>AssertGe</td></tr>
<tr><td>ExpectGt</td><td>AssertGt</td></tr>
<tr><td>ExpectLe</td><td>AssertLe</td></tr>
<tr><td>ExpectLt</td><td>AssertLt</td></tr>
<tr><td>ExpectNe</td><td>AssertNe</td></tr>
<tr><td>ExpectThat</td><td>AssertThat</td></tr>
<tr><td>ExpectTrue</td><td>AssertTrue</td></tr>
</table>

<p>V&nbsp;příkladu použijeme funkci <strong>ExpectThat</strong>, která jako
testovanou podmínku akceptuje <i>matcher</i>.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Třetí varianta jednotkových testů</h2>

<p>Podívejme se nyní na způsob reimplementace jednotkových testů, v&nbsp;nichž
se použije jak knihovna <i>oglematchers</i>, tak i knihovna <i>ogletest</i>.
V&nbsp;každém testu nejprve vytvoříme instanci <i>matcheru</i> a posléze
porovnáme očekávaný výsledek s&nbsp;výsledkem vypočteným funkcí faktoriálu, a
to s&nbsp;využitím funkce <strong>ExpectThat</strong>, o níž jsme se zmínili <a
href="#k07">v&nbsp;předchozí kapitole</a>. Novou variantu jednotkových testů
najdeme na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_18/04_factorial_ogletest/factorial_test.go">https://github.com/tisnik/go-root/blob/master/article_18/04_factorial_ogletest/factorial_test.go</a>:</p>

<pre>
package factorial_test
&nbsp;
import (
        "factorial"
        "github.com/jacobsa/oglematchers"
        "github.com/jacobsa/ogletest"
        "testing"
)
&nbsp;
func <strong>TestOgletest</strong>(t *testing.T) {
        ogletest.RunTests(t)
}
&nbsp;
type <strong>FactorialTest</strong> struct{}
&nbsp;
func <strong>init</strong>() {
        ogletest.RegisterTestSuite(&amp;FactorialTest{})
}
&nbsp;
func (t *FactorialTest) <strong>FactorialForZero</strong>() {
        result := factorial.Factorial(0)
        ogletest.ExpectThat(result, oglematchers.Equals(1))
}
&nbsp;
func (t *FactorialTest) <strong>FactorialForOne</strong>() {
        result := factorial.Factorial(1)
        ogletest.ExpectThat(result, oglematchers.Equals(1))
}
&nbsp;
func (t *FactorialTest) <strong>TestFactorialSmallNumber</strong>() {
        result := factorial.Factorial(5)
        ogletest.ExpectThat(result, oglematchers.AllOf(
                oglematchers.GreaterThan(10),
                oglematchers.LessThan(10000)))
}
&nbsp;
func (t *FactorialTest) <strong>TestFactorialSmallNumberNegative</strong>() {
        result := factorial.Factorial(20)
        ogletest.ExpectThat(result, oglematchers.AllOf(
                oglematchers.GreaterThan(10),
                oglematchers.LessThan(10000)))
}
&nbsp;
func (t *FactorialTest) <strong>TestFactorialForTen</strong>() {
        result := factorial.Factorial(10)
        expected := int64(3628800)
        ogletest.ExpectThat(result, oglematchers.Equals(expected))
}
&nbsp;
func (t *FactorialTest) <strong>TestFactorialBigNumber</strong>() {
        result := factorial.Factorial(20)
        ogletest.ExpectThat(result, oglematchers.GreaterThan(0))
}
&nbsp;
func (t *FactorialTest) <strong>TestFactorialEvenBiggerNumber</strong>() {
        result := factorial.Factorial(30)
        ogletest.ExpectThat(result, oglematchers.GreaterThan(0))
}
</pre>

<p>Testy opět spustíme příkazem:</p>

<pre>
$ <strong>go test</strong>
</pre>

<p>Tentokrát je ovšem už z&nbsp;výstupu patrné, že se o samotné spouštění
jednotlivých podmínek stará knihovna <i>ogletest</i> a nikoli
<i>testing</i>:</p>

<pre>
[----------] Running tests from FactorialTest
[ RUN      ] FactorialTest.FactorialForZero
[       OK ] FactorialTest.FactorialForZero
[ RUN      ] FactorialTest.FactorialForOne
[       OK ] FactorialTest.FactorialForOne
[ RUN      ] FactorialTest.TestFactorialSmallNumber
[       OK ] FactorialTest.TestFactorialSmallNumber
[ RUN      ] FactorialTest.TestFactorialSmallNumberNegative
factorial_test.go:39:
Expected: greater than 10, and less than 10000
Actual:   2432902008176640000
&nbsp;
[  FAILED  ] FactorialTest.TestFactorialSmallNumberNegative
[ RUN      ] FactorialTest.TestFactorialForTen
[       OK ] FactorialTest.TestFactorialForTen
[ RUN      ] FactorialTest.TestFactorialBigNumber
[       OK ] FactorialTest.TestFactorialBigNumber
[ RUN      ] FactorialTest.TestFactorialEvenBiggerNumber
factorial_test.go:57:
Expected: greater than 0
Actual:   -8764578968847253504
&nbsp;
[  FAILED  ] FactorialTest.TestFactorialEvenBiggerNumber
[----------] Finished with tests from FactorialTest
--- FAIL: TestOgletest (0.00s)
FAIL
exit status 1
FAIL    _/home/tester/go-root/article_18/04_factorial_ogletest  0.005s
</pre>

<p>Samozřejmě nám nic nebrání použít &bdquo;tečkový&ldquo; import, v&nbsp;tomto
případě jak knihovny <i>oglematchers</i>, tak i knihovny <i>ogletest</i>.
K&nbsp;žádnému konfliktu ve jménech identifikátorů by nemělo dojít, a samotná
<a
href="https://github.com/tisnik/go-root/blob/master/article_18/05_factorial_ogletest2/factorial_test.go">implementace
testů se zkrátí a vlastně i zpřehlední</a>:</p>

<pre>
package factorial_test
&nbsp;
import (
        "factorial"
        . "github.com/jacobsa/oglematchers"
        . "github.com/jacobsa/ogletest"
        "testing"
)
&nbsp;
func <strong>TestOgletest</strong>(t *testing.T) {
        RunTests(t)
}
&nbsp;
type <strong>FactorialTest</strong> struct{}
&nbsp;
func <strong>init</strong>() {
        RegisterTestSuite(&amp;FactorialTest{})
}
&nbsp;
func (t *FactorialTest) <strong>FactorialForZero</strong>() {
        result := factorial.Factorial(0)
        ExpectThat(result, Equals(1))
}
&nbsp;
func (t *FactorialTest) <strong>FactorialForOne</strong>() {
        result := factorial.Factorial(1)
        ExpectThat(result, Equals(1))
}
&nbsp;
func (t *FactorialTest) <strong>TestFactorialSmallNumber</strong>() {
        result := factorial.Factorial(5)
        ExpectThat(result, AllOf(
                GreaterThan(10),
                LessThan(10000)))
}
&nbsp;
func (t *FactorialTest) <strong>TestFactorialSmallNumberNegative</strong>() {
        result := factorial.Factorial(20)
        ExpectThat(result, AllOf(
                GreaterThan(10),
                LessThan(10000)))
}
&nbsp;
func (t *FactorialTest) <strong>TestFactorialForTen</strong>() {
        result := factorial.Factorial(10)
        expected := int64(3628800)
        ExpectThat(result, Equals(expected))
}
&nbsp;
func (t *FactorialTest) <strong>TestFactorialBigNumber</strong>() {
        result := factorial.Factorial(20)
        ExpectThat(result, GreaterThan(0))
}
&nbsp;
func (t *FactorialTest) <strong>TestFactorialEvenBiggerNumber</strong>() {
        result := factorial.Factorial(30)
        ExpectThat(result, GreaterThan(0))
}
</pre>

<p>Se shodnými výsledky:</p>

<pre>
[----------] Running tests from FactorialTest
[ RUN      ] FactorialTest.FactorialForZero
[       OK ] FactorialTest.FactorialForZero
[ RUN      ] FactorialTest.FactorialForOne
[       OK ] FactorialTest.FactorialForOne
[ RUN      ] FactorialTest.TestFactorialSmallNumber
[       OK ] FactorialTest.TestFactorialSmallNumber
[ RUN      ] FactorialTest.TestFactorialSmallNumberNegative
factorial_test.go:39:
Expected: greater than 10, and less than 10000
Actual:   2432902008176640000

[  FAILED  ] FactorialTest.TestFactorialSmallNumberNegative
[ RUN      ] FactorialTest.TestFactorialForTen
[       OK ] FactorialTest.TestFactorialForTen
[ RUN      ] FactorialTest.TestFactorialBigNumber
[       OK ] FactorialTest.TestFactorialBigNumber
[ RUN      ] FactorialTest.TestFactorialEvenBiggerNumber
factorial_test.go:57:
Expected: greater than 0
Actual:   -8764578968847253504

[  FAILED  ] FactorialTest.TestFactorialEvenBiggerNumber
[----------] Finished with tests from FactorialTest
--- FAIL: TestOgletest (0.00s)
FAIL
exit status 1
FAIL    _/home/tester/go-root/article_18/05_factorial_ogletest2 0.004s
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Knihovna <strong>assertions</strong></h2>

<p>Třetí doplňkovou knihovnou určenou pro usnadnění psaní testů, s&nbsp;níž se
v&nbsp;dnešním článku setkáme, je knihovna nazvaná <i>assertions</i>, jejíž
repositář naleznete na adrese <a
href="https://github.com/smartystreets/assertions">https://github.com/smartystreets/assertions</a>.
V&nbsp;této knihovně je deklarováno několik funkcí, které se používají podobným
způsobem jako klasické <i>aserce</i>. Zajímavé je, že ve chvíli, kdy je
testovaná podmínka splněna, vrací tyto funkce prázdný řetězec (nikoli
<strong>nil</strong>!), v&nbsp;opačném případě řetězec s&nbsp;popisem podmínky
i důvodem, proč nebyla splněna &ndash; tyto informace tedy nebudeme muset
zapisovat ručně.</p>

<p>Mezi aserce, které lze použít v&nbsp;testech patří:</p>

<table>
<tr><th>Funkce/aserce</th></tr>
<tr><td>ShouldAlmostEqual</td></tr>
<tr><td>ShouldBeBetween</td></tr>
<tr><td>ShouldBeBetweenOrEqual</td></tr>
<tr><td>ShouldBeBlank</td></tr>
<tr><td>ShouldBeChronological</td></tr>
<tr><td>ShouldBeEmpty</td></tr>
<tr><td>ShouldBeError</td></tr>
<tr><td>ShouldBeFalse</td></tr>
<tr><td>ShouldBeGreaterThan</td></tr>
<tr><td>ShouldBeGreaterThanOrEqualTo</td></tr>
<tr><td>ShouldBeIn</td></tr>
<tr><td>ShouldBeLessThan</td></tr>
<tr><td>ShouldBeLessThanOrEqualTo</td></tr>
<tr><td>ShouldBeNil</td></tr>
<tr><td>ShouldBeTrue</td></tr>
<tr><td>ShouldBeZeroValue</td></tr>
<tr><td>ShouldContain</td></tr>
<tr><td>ShouldContainKey</td></tr>
<tr><td>ShouldContainSubstring</td></tr>
<tr><td>ShouldEndWith</td></tr>
<tr><td>ShouldEqual</td></tr>
<tr><td>ShouldEqualJSON</td></tr>
<tr><td>ShouldEqualTrimSpace</td></tr>
<tr><td>ShouldEqualWithout</td></tr>
<tr><td>ShouldHappenAfter</td></tr>
<tr><td>ShouldHappenBefore</td></tr>
<tr><td>ShouldHappenBetween</td></tr>
<tr><td>ShouldHappenOnOrAfter</td></tr>
<tr><td>ShouldHappenOnOrBefore</td></tr>
<tr><td>ShouldHappenOnOrBetween</td></tr>
<tr><td>ShouldHappenWithin</td></tr>
<tr><td>ShouldHaveLength</td></tr>
<tr><td>ShouldHaveSameTypeAs</td></tr>
<tr><td>ShouldImplement</td></tr>
<tr><td>ShouldNotAlmostEqual</td></tr>
<tr><td>ShouldNotBeBetween</td></tr>
<tr><td>ShouldNotBeBetweenOrEqual</td></tr>
<tr><td>ShouldNotBeBlank</td></tr>
<tr><td>ShouldNotBeChronological</td></tr>
<tr><td>ShouldNotBeEmpty</td></tr>
<tr><td>ShouldNotBeIn</td></tr>
<tr><td>ShouldNotBeNil</td></tr>
<tr><td>ShouldNotBeZeroValue</td></tr>
<tr><td>ShouldNotContain</td></tr>
<tr><td>ShouldNotContainKey</td></tr>
<tr><td>ShouldNotContainSubstring</td></tr>
<tr><td>ShouldNotEndWith</td></tr>
<tr><td>ShouldNotEqual</td></tr>
<tr><td>ShouldNotHappenOnOrBetween</td></tr>
<tr><td>ShouldNotHappenWithin</td></tr>
<tr><td>ShouldNotHaveSameTypeAs</td></tr>
<tr><td>ShouldNotImplement</td></tr>
<tr><td>ShouldNotPanic</td></tr>
<tr><td>ShouldNotPanicWith</td></tr>
<tr><td>ShouldNotPointTo</td></tr>
<tr><td>ShouldNotResemble</td></tr>
<tr><td>ShouldNotStartWith</td></tr>
<tr><td>ShouldPanic</td></tr>
<tr><td>ShouldPanicWith</td></tr>
<tr><td>ShouldPointTo</td></tr>
<tr><td>ShouldResemble</td></tr>
<tr><td>ShouldStartWith</td></tr>
</table>

<p>Význam většiny asercí by měl být zřejmý z&nbsp;jejich pojmenování.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Použití základních funkcí pro otestování platnosti předpokladů</h2>

<p>V&nbsp;následujícím demonstračním příkladu je ukázáno použití některých
asercí zmíněných <a href="#k09">v&nbsp;deváté kapitole</a>, zejména asercí
<strong>ShouldEqual</strong>, <strong>ShouldBeGreaterThan</strong> a
<strong>ShouldBeBetween</strong>. Výsledky testů prozatím pouze vytiskneme na
standardní výstup. Zdrojový kód s&nbsp;testy naleznete na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_18/06_factorial_assertions/factorial_test.go">https://github.com/tisnik/go-root/blob/master/article_18/06_factorial_assertions/factorial_test.go</a>:</p>

<pre>
package factorial_test
&nbsp;
import (
        "factorial"
        "github.com/smartystreets/assertions"
        "testing"
)
&nbsp;
func <strong>TestFactorialForZero</strong>(t *testing.T) {
        result := factorial.Factorial(0)
        println(assertions.ShouldEqual(result, 1))
}
&nbsp;
func <strong>TestFactorialForOne</strong>(t *testing.T) {
        result := factorial.Factorial(1)
        println(assertions.ShouldEqual(result, 1))
}
&nbsp;
func <strong>TestFactorialForSmallNumber</strong>(t *testing.T) {
        result := factorial.Factorial(5)
        println(assertions.ShouldBeBetween(result, 10, 10000))
}
&nbsp;
func <strong>TestFactorialForSmallNegative</strong>(t *testing.T) {
        result := factorial.Factorial(20)
        println(assertions.ShouldBeBetween(result, 10, 10000))
}
&nbsp;
func <strong>TestFactorialForTen</strong>(t *testing.T) {
        result := factorial.Factorial(10)
        expected := int64(3628800)
        println(assertions.ShouldEqual(result, expected))
}
&nbsp;
func <strong>TestFactorialForBigNumber</strong>(t *testing.T) {
        result := factorial.Factorial(20)
        println(assertions.ShouldBeGreaterThan(result, 0))
}
&nbsp;
func <strong>TestFactorialForEvenBiggerNumber</strong>(t *testing.T) {
        result := factorial.Factorial(30)
        println(assertions.ShouldBeGreaterThan(result, 0))
}
</pre>

<p>V&nbsp;tomto případě všechny testy pochopitelně projdou bez chyby, ovšem
informace o všech nesplněných podmínkách se vypíšou na terminál:</p>

<pre>
=== RUN   TestFactorialForZero
&nbsp;
--- PASS: TestFactorialForZero (0.00s)
=== RUN   TestFactorialForOne
&nbsp;
--- PASS: TestFactorialForOne (0.00s)
=== RUN   TestFactorialForSmallNumber
&nbsp;
--- PASS: TestFactorialForSmallNumber (0.00s)
=== RUN   TestFactorialForSmallNegative
Expected '2432902008176640000' to be between '10' and '10000' (but it wasn't)!
--- PASS: TestFactorialForSmallNegative (0.00s)
=== RUN   TestFactorialForTen
&nbsp;
--- PASS: TestFactorialForTen (0.00s)
=== RUN   TestFactorialForBigNumber
&nbsp;
--- PASS: TestFactorialForBigNumber (0.00s)
=== RUN   TestFactorialForEvenBiggerNumber
Expected '-8764578968847253504' to be greater than '0' (but it wasn't)!
--- PASS: TestFactorialForEvenBiggerNumber (0.00s)
PASS
ok      _/home/tester/go-root/article_18/06_factorial_assertions        0.005s
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Kombinace knihoven <strong>assert</strong> a <strong>assertions</strong></h2>

<p>Knihovnu <i>assertions</i>, resp.&nbsp;přesněji řečeno funkce/aserce
z&nbsp;této knihovny, můžeme snadno zkombinovat s&nbsp;další knihovnou nazvanou
přímočaře a jednoduše <i>assert</i>. Tuto knihovnu nainstalujete příkazem:</p>

<pre>
$ <strong>go get github.com/mockupcode/gunit </strong>
</pre>

<p>Prakticky jedinou veřejně dostupnou funkcí z&nbsp;této knihovny je funkce
<strong>Equal</strong>, která se používá pro porovnání dvou hodnot libovolných
typů, což je ostatně patrné i při pohledu na <a
href="https://github.com/tisnik/go-root/blob/master/article_18/07_factorial_assertions2/factorial_test.go">další
demonstrační příklad</a>:</p>

<pre>
package factorial_test
&nbsp;
import (
        "factorial"
        "github.com/mockupcode/gunit/assert"
        "github.com/smartystreets/assertions"
        "testing"
)
&nbsp;
func <strong>TestFactorialForZero</strong>(t *testing.T) {
        assert := assert.GetAssertion(t)
        result := factorial.Factorial(0)
        assert.Equal(assertions.ShouldEqual(result, 1), "")
}
&nbsp;
func <strong>TestFactorialForOne</strong>(t *testing.T) {
        assert := assert.GetAssertion(t)
        result := factorial.Factorial(1)
        assert.Equal(assertions.ShouldEqual(result, 1), "")
}
&nbsp;
func <strong>TestFactorialForSmallNumber</strong>(t *testing.T) {
        assert := assert.GetAssertion(t)
        result := factorial.Factorial(5)
        assert.Equal(assertions.ShouldBeBetween(result, 10, 10000), "")
}
&nbsp;
func <strong>TestFactorialForSmallNegative</strong>(t *testing.T) {
        assert := assert.GetAssertion(t)
        result := factorial.Factorial(20)
        assert.Equal(assertions.ShouldBeBetween(result, 10, 10000), "")
}
&nbsp;
func <strong>TestFactorialForTen</strong>(t *testing.T) {
        assert := assert.GetAssertion(t)
        result := factorial.Factorial(10)
        expected := int64(3628800)
        assert.Equal(assertions.ShouldEqual(result, expected), "")
}
&nbsp;
func <strong>TestFactorialForBigNumber</strong>(t *testing.T) {
        assert := assert.GetAssertion(t)
        result := factorial.Factorial(20)
        assert.Equal(assertions.ShouldBeGreaterThan(result, 0), "")
}
&nbsp;
func <strong>TestFactorialForEvenBiggerNumber</strong>(t *testing.T) {
        assert := assert.GetAssertion(t)
        result := factorial.Factorial(30)
        assert.Equal(assertions.ShouldBeGreaterThan(result, 0), "")
}
</pre>

<p>Nyní již budou některé testy korektně hlásit všechny nalezené problémy, a to
automaticky generovanými a přitom snadno pochopitelnými chybovými zprávami:</p>

<pre>
=== RUN   TestFactorialForZero
--- PASS: TestFactorialForZero (0.00s)
=== RUN   TestFactorialForOne
--- PASS: TestFactorialForOne (0.00s)
=== RUN   TestFactorialForSmallNumber
--- PASS: TestFactorialForSmallNumber (0.00s)
=== RUN   TestFactorialForSmallNegative
--- FAIL: TestFactorialForSmallNegative
        factorial_test.go:33: Expected Expected '2432902008176640000' to be between '10' and '10000' (but it wasn't)! but found .
--- FAIL: TestFactorialForSmallNegative (0.00s)
=== RUN   TestFactorialForTen
--- PASS: TestFactorialForTen (0.00s)
=== RUN   TestFactorialForBigNumber
--- PASS: TestFactorialForBigNumber (0.00s)
=== RUN   TestFactorialForEvenBiggerNumber
--- FAIL: TestFactorialForEvenBiggerNumber
        factorial_test.go:52: Expected Expected '-8764578968847253504' to be greater than '0' (but it wasn't)! but found .
--- FAIL: TestFactorialForEvenBiggerNumber (0.00s)
FAIL
exit status 1
FAIL    _/home/tester/go-root/article_18/07_factorial_assertions2       0.006s
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Zjednodušení zápisu testů použitím &bdquo;tečkového&ldquo; importu</h2>

<p>Opět si můžeme zápis testů zjednodušit použitím již několikrát zmíněného
&bdquo;tečkového&ldquo; importu, jak je to ukázáno <a
href="https://github.com/tisnik/go-root/blob/master/article_18/08_factorial_assertions3/factorial_test.go">v&nbsp;dalším
demonstračním příkladu</a>:</p>

<pre>
package factorial_test
&nbsp;
import (
        "factorial"
        . "github.com/mockupcode/gunit/assert"
        . "github.com/smartystreets/assertions"
        "testing"
)
&nbsp;
func <strong>TestFactorialForZero</strong>(t *testing.T) {
        assert := GetAssertion(t)
        result := factorial.Factorial(0)
        assert.Equal(ShouldEqual(result, 1), "")
}
&nbsp;
func <strong>TestFactorialForOne</strong>(t *testing.T) {
        assert := GetAssertion(t)
        result := factorial.Factorial(1)
        assert.Equal(ShouldEqual(result, 1), "")
}
&nbsp;
func <strong>TestFactorialForSmallNumber</strong>(t *testing.T) {
        assert := GetAssertion(t)
        result := factorial.Factorial(5)
        assert.Equal(ShouldBeBetween(result, 10, 10000), "")
}
&nbsp;
func <strong>TestFactorialForSmallNegative</strong>(t *testing.T) {
        assert := GetAssertion(t)
        result := factorial.Factorial(20)
        assert.Equal(ShouldBeBetween(result, 10, 10000), "")
}
&nbsp;
func <strong>TestFactorialForTen</strong>(t *testing.T) {
        assert := GetAssertion(t)
        result := factorial.Factorial(10)
        expected := int64(3628800)
        assert.Equal(ShouldEqual(result, expected), "")
}
&nbsp;
func <strong>TestFactorialForBigNumber</strong>(t *testing.T) {
        assert := GetAssertion(t)
        result := factorial.Factorial(20)
        assert.Equal(ShouldBeGreaterThan(result, 0), "")
}
&nbsp;
func <strong>TestFactorialForEvenBiggerNumber</strong>(t *testing.T) {
        assert := GetAssertion(t)
        result := factorial.Factorial(30)
        assert.Equal(ShouldBeGreaterThan(result, 0), "")
}
</pre>

<p>Výsledky běhu testů budou podle očekávání shodné s&nbsp;předchozími
výsledky:</p>

<pre>
=== RUN   TestFactorialForZero
--- PASS: TestFactorialForZero (0.00s)
=== RUN   TestFactorialForOne
--- PASS: TestFactorialForOne (0.00s)
=== RUN   TestFactorialForSmallNumber
--- PASS: TestFactorialForSmallNumber (0.00s)
=== RUN   TestFactorialForSmallNegative
--- FAIL: TestFactorialForSmallNegative
        factorial_test.go:33: Expected Expected '2432902008176640000' to be between '10' and '10000' (but it wasn't)! but found .
--- FAIL: TestFactorialForSmallNegative (0.00s)
=== RUN   TestFactorialForTen
--- PASS: TestFactorialForTen (0.00s)
=== RUN   TestFactorialForBigNumber
--- PASS: TestFactorialForBigNumber (0.00s)
=== RUN   TestFactorialForEvenBiggerNumber
--- FAIL: TestFactorialForEvenBiggerNumber
        factorial_test.go:52: Expected Expected '-8764578968847253504' to be greater than '0' (but it wasn't)! but found .
--- FAIL: TestFactorialForEvenBiggerNumber (0.00s)
FAIL
exit status 1
FAIL    _/home/tester/go-root/article_18/08_factorial_assertions3       0.004s
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Knihovna GoConvey</h2>

<p>Již <a
href="https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/">minule</a>
jsme se zmínili o nástroji pojmenovaném <i>GoConvey</i>, ovšem především
z&nbsp;toho důvodu, abychom si představili jeho webové uživatelské rozhraní
používané jak pro spouštění testů, tak i pro prezentaci jejich výsledků. Ovšem
základem, na němž je nástroj <i>GoConvey</i> postaven, je knihovna určená pro
psaní testů, které již většinou nemusejí mít tvar klasických jednotkových
testů, ale spíše testů s&nbsp;popisem chování daného systému (<i>behavio(u)r
tests</i>).</p>

<p><div class="rs-tip-major">Poznámka: celou knihovnu budeme nazývat plným
jménem <i>GoConvery</i>, i když se importovaný balíček bude jmenovat pouze
<strong>convey</strong>.</div></p>

<p>Testy vytvořené s&nbsp;využitím této knihovny popisují očekávané chování
systému (tedy většinou změnu jeho stavu), takže můžeme například psát:</p>

<pre>
convey.Convey("0! should be equal 1", t, func() {
        convey.So(Factorial(0), convey.ShouldEqual, 1)
})
</pre>

<p>Povšimněte si, že samotné otestování je v&nbsp;tomto případě většinou
realizováno anonymní funkcí, která je předaná do funkce
<strong>Convey</strong>.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Přepis jednotkových testů s&nbsp;použitím knihovny GoConvey</h2>

<p>Podívejme se, jakým způsobem by bylo možné napsat jednotkové testy (tedy ne
přímo BDD testy) s&nbsp;využitím knihovny <i>GoConvey</i>, přesněji řečeno
balíčku <strong>convey</strong>. Povšimněte si způsobu zápisu operandů funkce
<strong>So</strong>:</p>

<pre>
convey.So(Factorial(0), convey.ShouldEqual, 1)
convey.So(Factorial(5), convey.ShouldBeBetween, 1, 10000)
convey.So(Factorial(30), convey.ShouldBeGreaterThan, 0)
</pre>

<p><a
href="https://github.com/tisnik/go-root/blob/master/article_18/09_factorial_convey/behaviour_test.go">Zdrojový
kód celého příkladu</a> vypadá následovně:</p>

<pre>
package factorial
&nbsp;
import (
        "github.com/smartystreets/goconvey/convey"
        "testing"
)
&nbsp;
func <strong>TestFactorialForZero</strong>(t *testing.T) {
        convey.Convey("0! should be equal 1", t, func() {
                convey.So(Factorial(0), convey.ShouldEqual, 1)
        })
}
&nbsp;
func <strong>TestFactorialForOne</strong>(t *testing.T) {
        convey.Convey("1! should be equal 1", t, func() {
                convey.So(Factorial(1), convey.ShouldEqual, 1)
        })
}
&nbsp;
func <strong>TestFactorialForSmallNumber</strong>(t *testing.T) {
        convey.Convey("5! should be between 1 and 10000", t, func() {
                convey.So(Factorial(5), convey.ShouldBeBetween, 1, 10000)
        })
}
&nbsp;
func <strong>TestFactorialForSmallNumberNegative</strong>(t *testing.T) {
        convey.Convey("20! should be between 1 and 10000", t, func() {
                convey.So(Factorial(20), convey.ShouldBeBetween, 1, 10000)
        })
}
&nbsp;
func <strong>TestFactorialForTen</strong>(t *testing.T) {
        convey.Convey("10! should be equal to 3628800", t, func() {
                convey.So(Factorial(10), convey.ShouldEqual, 3628800)
        })
}
&nbsp;
func <strong>TestFactorialForBigNumber</strong>(t *testing.T) {
        convey.Convey("20! should be greater than zero", t, func() {
                convey.So(Factorial(20), convey.ShouldBeGreaterThan, 0)
        })
}
&nbsp;
func <strong>TestFactorialForEvenBiggerNumber</strong>(t *testing.T) {
        convey.Convey("30! should be greater than zero", t, func() {
                convey.So(Factorial(30), convey.ShouldBeGreaterThan, 0)
        })
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Výsledky testů</h2>

<p>Testy se v&nbsp;tomto případě spouští klasicky příkazem:</p>

<pre>
$ <strong>go test -v</strong>
</pre>

<p>Pokud máte terminál nakonfigurovaný takovým způsobem, aby zobrazovat většinu
znaků Unicode, může výsledek vypadat takto:</p>

<pre>
=== RUN   TestFactorialForZero
&nbsp;
  0! should be equal 1 ✔
&nbsp;
&nbsp;
1 total assertion
&nbsp;
--- PASS: TestFactorialForZero (0.00s)
=== RUN   TestFactorialForOne
&nbsp;
  1! should be equal 1 ✔
&nbsp;
&nbsp;
2 total assertions
&nbsp;
--- PASS: TestFactorialForOne (0.00s)
=== RUN   TestFactorialForSmallNumber
&nbsp;
  5! should be between 1 and 10000 ✔
&nbsp;
&nbsp;
3 total assertions
&nbsp;
--- PASS: TestFactorialForSmallNumber (0.00s)
=== RUN   TestFactorialForSmallNumberNegative
&nbsp;
  20! should be between 1 and 10000 ✘
&nbsp;
&nbsp;
Failures:
&nbsp;
  * /home/tester/temp/go-root/article_18/09_factorial_convey/behaviour_test.go 
  Line 28:
  Expected '2432902008176640000' to be between '1' and '10000' (but it wasn't)!
  goroutine 21 [running]:
  _/home/tester/temp/go-root/article_18/09_factorial_convey.TestFactorialForSmallNumberNegative.func1()
        /home/tester/temp/go-root/article_18/09_factorial_convey/behaviour_test.go:28 +0xe6
  github.com/jtolds/gls.(*ContextManager).SetValues.func1(0x0)
        /home/tester/go/src/github.com/jtolds/gls/context.go:97 +0x3f2
  github.com/jtolds/gls.EnsureGoroutineId.func1()
        /home/tester/go/src/github.com/jtolds/gls/gid.go:24 +0x2e
  github.com/jtolds/gls._m(0x0, 0xc00008a880)
        /home/tester/go/src/github.com/jtolds/gls/stack_tags.go:108 +0x31
  github.com/jtolds/gls.github_com_jtolds_gls_markS(0x0, 0xc00008a880)
        /home/tester/go/src/github.com/jtolds/gls/stack_tags.go:56 +0x35
  github.com/jtolds/gls.addStackTag(0x0, 0xc00008a880)
        /home/tester/go/src/github.com/jtolds/gls/stack_tags.go:49 +0x3a
  github.com/jtolds/gls.EnsureGoroutineId(0xc000078c00)
        /home/tester/go/src/github.com/jtolds/gls/gid.go:24 +0xc3
  github.com/jtolds/gls.(*ContextManager).SetValues(0xc000074540, 0xc000078ba0, 0xc00008a840)
        /home/tester/go/src/github.com/jtolds/gls/context.go:63 +0x147
  _/home/tester/temp/go-root/article_18/09_factorial_convey.TestFactorialForSmallNumberNegative(0xc0000bc400)
        /home/tester/temp/go-root/article_18/09_factorial_convey/behaviour_test.go:27 +0x99
  testing.tRunner(0xc0000bc400, 0x5ac5f8)
        /opt/go/src/testing/testing.go:827 +0xbf
  created by testing.(*T).Run
        /opt/go/src/testing/testing.go:878 +0x353
  
&nbsp;
&nbsp;
4 total assertions
&nbsp;
--- FAIL: TestFactorialForSmallNumberNegative (0.00s)
=== RUN   TestFactorialForTen
&nbsp;
  10! should be equal to 3628800 ✔
&nbsp;
&nbsp;
5 total assertions
&nbsp;
--- PASS: TestFactorialForTen (0.00s)
=== RUN   TestFactorialForBigNumber
&nbsp;
  20! should be greater than zero ✔
&nbsp;
&nbsp;
6 total assertions
&nbsp;
--- PASS: TestFactorialForBigNumber (0.00s)
=== RUN   TestFactorialForEvenBiggerNumber
&nbsp;
  30! should be greater than zero ✘
&nbsp;
&nbsp;
Failures:
&nbsp;
  * /home/tester/temp/go-root/article_18/09_factorial_convey/behaviour_test.go 
  Line 46:
  Expected '-8764578968847253504' to be greater than '0' (but it wasn't)!
  goroutine 24 [running]:
  _/home/tester/temp/go-root/article_18/09_factorial_convey.TestFactorialForEvenBiggerNumber.func1()
        /home/tester/temp/go-root/article_18/09_factorial_convey/behaviour_test.go:46 +0xca
  github.com/jtolds/gls.(*ContextManager).SetValues.func1(0x0)
        /home/tester/go/src/github.com/jtolds/gls/context.go:97 +0x3f2
  github.com/jtolds/gls.EnsureGoroutineId.func1()
        /home/tester/go/src/github.com/jtolds/gls/gid.go:24 +0x2e
  github.com/jtolds/gls._m(0x0, 0xc00008b000)
        /home/tester/go/src/github.com/jtolds/gls/stack_tags.go:108 +0x31
  github.com/jtolds/gls.github_com_jtolds_gls_markS(0x0, 0xc00008b000)
        /home/tester/go/src/github.com/jtolds/gls/stack_tags.go:56 +0x35
  github.com/jtolds/gls.addStackTag(0x0, 0xc00008b000)
        /home/tester/go/src/github.com/jtolds/gls/stack_tags.go:49 +0x3a
  github.com/jtolds/gls.EnsureGoroutineId(0xc000079200)
        /home/tester/go/src/github.com/jtolds/gls/gid.go:24 +0xc3
  github.com/jtolds/gls.(*ContextManager).SetValues(0xc000074540, 0xc0000791a0, 0xc00008afc0)
        /home/tester/go/src/github.com/jtolds/gls/context.go:63 +0x147
  _/home/tester/temp/go-root/article_18/09_factorial_convey.TestFactorialForEvenBiggerNumber(0xc0000bc800)
        /home/tester/temp/go-root/article_18/09_factorial_convey/behaviour_test.go:45 +0x99
  testing.tRunner(0xc0000bc800, 0x5ac5d0)
        /opt/go/src/testing/testing.go:827 +0xbf
  created by testing.(*T).Run
        /opt/go/src/testing/testing.go:878 +0x353
  
&nbsp;
&nbsp;
7 total assertions
&nbsp;
--- FAIL: TestFactorialForEvenBiggerNumber (0.00s)
FAIL
exit status 1
FAIL    _/home/tester/temp/go-root/article_18/09_factorial_convey       0.008s
</pre>

<p>Povšimněte si, že v&nbsp;případě nedodržení nějaké podmínky je vypsán celý
<i>stack trace</i>.</p>

<p>Již bez zbytečného podrobnějšího vysvětlení si ukažme, jak vypadá úprava
testů s&nbsp;využitím tečkového importu:</p>

<pre>
package factorial
&nbsp;
import (
        . "github.com/smartystreets/goconvey/convey"
        "testing"
)
&nbsp;
func <strong>TestFactorialForZero</strong>(t *testing.T) {
        Convey("0! should be equal 1", t, func() {
                So(Factorial(0), ShouldEqual, 1)
        })
}
&nbsp;
func <strong>TestFactorialForOne</strong>(t *testing.T) {
        Convey("1! should be equal 1", t, func() {
                So(Factorial(1), ShouldEqual, 1)
        })
}
&nbsp;
func <strong>TestFactorialForSmallNumber</strong>(t *testing.T) {
        Convey("5! should be between 1 and 10000", t, func() {
                So(Factorial(5), ShouldBeBetween, 1, 10000)
        })
}
&nbsp;
func <strong>TestFactorialForSmallNumberNegative</strong>(t *testing.T) {
        Convey("20! should be between 1 and 10000", t, func() {
                So(Factorial(20), ShouldBeBetween, 1, 10000)
        })
}
&nbsp;
func <strong>TestFactorialForTen</strong>(t *testing.T) {
        Convey("10! should be equal to 3628800", t, func() {
                So(Factorial(10), ShouldEqual, 3628800)
        })
}
&nbsp;
func <strong>TestFactorialForBigNumber</strong>(t *testing.T) {
        Convey("20! should be greater than zero", t, func() {
                So(Factorial(20), ShouldBeGreaterThan, 0)
        })
}
&nbsp;
func <strong>TestFactorialForEvenBiggerNumber</strong>(t *testing.T) {
        Convey("30! should be greater than zero", t, func() {
                So(Factorial(30), ShouldBeGreaterThan, 0)
        })
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Alternativní formát výstupu</h2>

<p>V&nbsp;případě potřeby dalšího zpracování výsledků testů můžeme nástroj
<i>GoConvey</i> přepínačem <strong>-convey-json</strong> donutit k&nbsp;tomu,
aby se výsledky posílané na standardní výstup či do výstupního souboru uložily
ve formě JSONu. Pro každou testovací funkci se bude jednat o samostatný záznam,
který je možné z&nbsp;výstupu relativně snadno vyříznout:</p>

<pre>
=== RUN   TestFactorialForZero
&gt;-&gt;-&gt;OPEN-JSON-&gt;-&gt;-&gt;
{
  "Title": "0! should be equal 1",
  "File": "/home/tester/go-root/article_18/09_factorial_convey/behaviour_test.go",
  "Line": 9,
  "Depth": 1,
  "Assertions": [
    {
      "File": "",
      "Line": 0,
      "Expected": "",
      "Actual": "",
      "Failure": "",
      "Error": null,
      "StackTrace": "",
      "Skipped": false
    }
  ],
  "Output": ""
},
&lt;-&lt;-&lt;-CLOSE-JSON&lt;-&lt;-&lt;
--- PASS: TestFactorialForZero (0.00s)
=== RUN   TestFactorialForOne
&gt;-&gt;-&gt;OPEN-JSON-&gt;-&gt;-&gt;
{
  "Title": "1! should be equal 1",
  "File": "/home/tester/go-root/article_18/09_factorial_convey/behaviour_test.go",
  "Line": 15,
  "Depth": 1,
  "Assertions": [
    {
      "File": "",
      "Line": 0,
      "Expected": "",
      "Actual": "",
      "Failure": "",
      "Error": null,
      "StackTrace": "",
      "Skipped": false
    }
  ],
  "Output": ""
},
&lt;-&lt;-&lt;-CLOSE-JSON&lt;-&lt;-&lt;
--- PASS: TestFactorialForOne (0.00s)
=== RUN   TestFactorialForSmallNumber
&gt;-&gt;-&gt;OPEN-JSON-&gt;-&gt;-&gt;
{
  "Title": "5! should be between 1 and 10000",
  "File": "/home/tester/go-root/article_18/09_factorial_convey/behaviour_test.go",
  "Line": 21,
  "Depth": 1,
  "Assertions": [
    {
      "File": "",
      "Line": 0,
      "Expected": "",
      "Actual": "",
      "Failure": "",
      "Error": null,
      "StackTrace": "",
      "Skipped": false
    }
  ],
  "Output": ""
},
&lt;-&lt;-&lt;-CLOSE-JSON&lt;-&lt;-&lt;
--- PASS: TestFactorialForSmallNumber (0.00s)
=== RUN   TestFactorialForSmallNumberNegative
&gt;-&gt;-&gt;OPEN-JSON-&gt;-&gt;-&gt;
{
  "Title": "20! should be between 1 and 10000",
  "File": "/home/tester/go-root/article_18/09_factorial_convey/behaviour_test.go",
  "Line": 27,
  "Depth": 1,
  "Assertions": [
    {
      "File": "/home/tester/go-root/article_18/09_factorial_convey/behaviour_test.go",
      "Line": 28,
      "Expected": "",
      "Actual": "",
      "Failure": "Expected '2432902008176640000' to be between '1' and '10000' (but it wasn't)!",
      "Error": null,
      "StackTrace": "goroutine 8 [running]:\n_/home/tester/go-root/article_18/09_factorial_convey.TestFactorialForSmallNumberNegative.func1()\n\t/home/tester/go-root/article_18/09_factorial_convey/behaviour_test.go:28 +0xe6\ngithub.com/jtolds/gls.(*ContextManager).SetValues.func1(0x0)\n\t/home/tester/go/src/github.com/jtolds/gls/context.go:97 +0x3f2\ngithub.com/jtolds/gls.EnsureGoroutineId.func1()\n\t/home/tester/go/src/github.com/jtolds/gls/gid.go:24 +0x2e\ngithub.com/jtolds/gls._m(0x0, 0xc00000a8e0)\n\t/home/tester/go/src/github.com/jtolds/gls/stack_tags.go:108 +0x31\ngithub.com/jtolds/gls.github_com_jtolds_gls_markS(0x0, 0xc00000a8e0)\n\t/home/tester/go/src/github.com/jtolds/gls/stack_tags.go:56 +0x35\ngithub.com/jtolds/gls.addStackTag(0x0, 0xc00000a8e0)\n\t/home/tester/go/src/github.com/jtolds/gls/stack_tags.go:49 +0x3a\ngithub.com/jtolds/gls.EnsureGoroutineId(0xc00000ede0)\n\t/home/tester/go/src/github.com/jtolds/gls/gid.go:24 +0xc3\ngithub.com/jtolds/gls.(*ContextManager).SetValues(0xc00004a550, 0xc00000ed80, 0xc00000a8a0)\n\t/home/tester/go/src/github.com/jtolds/gls/context.go:63 +0x147\n_/home/tester/go-root/article_18/09_factorial_convey.TestFactorialForSmallNumberNegative(0xc0000a6400)\n\t/home/tester/go-root/article_18/09_factorial_convey/behaviour_test.go:27 +0x99\ntesting.tRunner(0xc0000a6400, 0x5ac5f8)\n\t/opt/go/src/testing/testing.go:827 +0xbf\ncreated by testing.(*T).Run\n\t/opt/go/src/testing/testing.go:878 +0x353\n",
      "Skipped": false
    }
  ],
  "Output": ""
},
&lt;-&lt;-&lt;-CLOSE-JSON&lt;-&lt;-&lt;
--- FAIL: TestFactorialForSmallNumberNegative (0.00s)
=== RUN   TestFactorialForTen
&gt;-&gt;-&gt;OPEN-JSON-&gt;-&gt;-&gt;
{
  "Title": "10! should be equal to 3628800",
  "File": "/home/tester/go-root/article_18/09_factorial_convey/behaviour_test.go",
  "Line": 33,
  "Depth": 1,
  "Assertions": [
    {
      "File": "",
      "Line": 0,
      "Expected": "",
      "Actual": "",
      "Failure": "",
      "Error": null,
      "StackTrace": "",
      "Skipped": false
    }
  ],
  "Output": ""
},
&lt;-&lt;-&lt;-CLOSE-JSON&lt;-&lt;-&lt;
--- PASS: TestFactorialForTen (0.00s)
=== RUN   TestFactorialForBigNumber
&gt;-&gt;-&gt;OPEN-JSON-&gt;-&gt;-&gt;
{
  "Title": "20! should be greater than zero",
  "File": "/home/tester/go-root/article_18/09_factorial_convey/behaviour_test.go",
  "Line": 39,
  "Depth": 1,
  "Assertions": [
    {
      "File": "",
      "Line": 0,
      "Expected": "",
      "Actual": "",
      "Failure": "",
      "Error": null,
      "StackTrace": "",
      "Skipped": false
    }
  ],
  "Output": ""
},
&lt;-&lt;-&lt;-CLOSE-JSON&lt;-&lt;-&lt;
--- PASS: TestFactorialForBigNumber (0.00s)
=== RUN   TestFactorialForEvenBiggerNumber
&gt;-&gt;-&gt;OPEN-JSON-&gt;-&gt;-&gt;
{
  "Title": "30! should be greater than zero",
  "File": "/home/tester/go-root/article_18/09_factorial_convey/behaviour_test.go",
  "Line": 45,
  "Depth": 1,
  "Assertions": [
    {
      "File": "/home/tester/go-root/article_18/09_factorial_convey/behaviour_test.go",
      "Line": 46,
      "Expected": "",
      "Actual": "",
      "Failure": "Expected '-8764578968847253504' to be greater than '0' (but it wasn't)!",
      "Error": null,
      "StackTrace": "goroutine 11 [running]:\n_/home/tester/go-root/article_18/09_factorial_convey.TestFactorialForEvenBiggerNumber.func1()\n\t/home/tester/go-root/article_18/09_factorial_convey/behaviour_test.go:46 +0xca\ngithub.com/jtolds/gls.(*ContextManager).SetValues.func1(0x0)\n\t/home/tester/go/src/github.com/jtolds/gls/context.go:97 +0x3f2\ngithub.com/jtolds/gls.EnsureGoroutineId.func1()\n\t/home/tester/go/src/github.com/jtolds/gls/gid.go:24 +0x2e\ngithub.com/jtolds/gls._m(0x0, 0xc00000ae40)\n\t/home/tester/go/src/github.com/jtolds/gls/stack_tags.go:108 +0x31\ngithub.com/jtolds/gls.github_com_jtolds_gls_markS(0x0, 0xc00000ae40)\n\t/home/tester/go/src/github.com/jtolds/gls/stack_tags.go:56 +0x35\ngithub.com/jtolds/gls.addStackTag(0x0, 0xc00000ae40)\n\t/home/tester/go/src/github.com/jtolds/gls/stack_tags.go:49 +0x3a\ngithub.com/jtolds/gls.EnsureGoroutineId(0xc00000f350)\n\t/home/tester/go/src/github.com/jtolds/gls/gid.go:24 +0xc3\ngithub.com/jtolds/gls.(*ContextManager).SetValues(0xc00004a550, 0xc00000f2f0, 0xc00000ae00)\n\t/home/tester/go/src/github.com/jtolds/gls/context.go:63 +0x147\n_/home/tester/go-root/article_18/09_factorial_convey.TestFactorialForEvenBiggerNumber(0xc0000a6800)\n\t/home/tester/go-root/article_18/09_factorial_convey/behaviour_test.go:45 +0x99\ntesting.tRunner(0xc0000a6800, 0x5ac5d0)\n\t/opt/go/src/testing/testing.go:827 +0xbf\ncreated by testing.(*T).Run\n\t/opt/go/src/testing/testing.go:878 +0x353\n",
      "Skipped": false
    }
  ],
  "Output": ""
},
&lt;-&lt;-&lt;-CLOSE-JSON&lt;-&lt;-&lt;
--- FAIL: TestFactorialForEvenBiggerNumber (0.00s)
FAIL
exit status 1
FAIL	_/home/tester/go-root/article_18/09_factorial_convey	0.007s
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Pořadí spouštění jednotlivých kroků definovaných v&nbsp;BDD testech</h2>

<p>Při praktickém používání knihovny <i>Convey</i> je nutné si uvědomit, jakým
způsobem se vlastně zajišťuje <i>kontext</i> (<i>context</i>), v&nbsp;němž jsou
jednotlivé kroky jednotkových testů spouštěny. Pro vysvětlení této problematiky
se podívejme na další (již poslední) příklad testů, v&nbsp;němž se pracuje se
standardním řezem (<i>slice</i>). Tyto testy, jejichž zdrojový kód nalezneme na
adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_17/slice_test/slice_test.go">https://github.com/tisnik/go-root/blob/master/article_17/slice_test/slice_test.go</a>,
tedy provádí testování vlastností základního datového typu programovacího
jazyka Go:</p>

<pre>
package slices
&nbsp;
import (
        "testing"
        . "github.com/smartystreets/goconvey/convey"
)
&nbsp;
func <strong>TestSliceManipulation</strong>(t *testing.T) {
        Convey("Given an empty slice", t, func() {
                s := []int{}
&nbsp;
                Convey("The slice should be empty initially", func() {
                        So(s, ShouldBeEmpty)
                })
&nbsp;
                Convey("When an item is added", func() {
                        s = append(s, 1)
&nbsp;
                        Convey("The slice should not be empty", func() {
                                So(s, ShouldNotBeEmpty)
                        })
                        Convey("The slice length should be one", func() {
                                So(len(s), ShouldEqual, 1)
                        })
                        Convey("And length should NOT be zero, of course", func() {
                                So(len(s), ShouldNotEqual, 0)
                        })
                        Convey("When another item is added", func() {
                                s = append(s, 2)

                                Convey("The slice length should be two", func() {
                                        So(len(s), ShouldEqual, 2)
                                })
                                Convey("And length should NOT be zero, of course", func() {
                                        So(len(s), ShouldNotEqual, 1)
                                })
                        })
&nbsp;
                        Convey("Now the slice length should be one again", func() {
                                So(len(s), ShouldEqual, 1)
                        })
                })
                Convey("And now the slice should be empty again", func() {
                        So(s, ShouldBeEmpty)
                })
        })
}
</pre>

<p>Povšimněte si zejména těch řádků, na nichž se mění obsah řezu funkcí
<strong>append</strong> (víme již, že řez je vlastně pouze
&bdquo;pohledem&ldquo; na pole, které slouží pro uložení jednotlivých prvků,
toto pole je při některých operacích realokováno).</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Výsledky BDD testů</h2>

<p>Výsledky BDD testů nyní vypadají následovně:</p>

<pre>
=== RUN   TestSliceManipulation
&nbsp;
  Given an empty slice 
    The slice should be empty initially ✔
    When an item is added 
      The slice should not be empty ✔
      The slice length should be one ✔
      And length should NOT be zero, of course ✔
      When another item is added 
        The slice length should be two ✔
        And length should NOT be zero, of course ✔
      Now the slice length should be one again ✔
    And now the slice should be empty again ✔
&nbsp;
&nbsp;
8 total assertions
</pre>

<p>Testy v&nbsp;tomto případě běží (zdánlivě) paralelně, což znamená, že
například poslední test stále vidí prázdný řez a nikoli řez, do něhož byly
předchozími testy přidány dva prvky. Toto je velmi důležitá vlastnost celého
systému <i>GoConvey</i>, která do značné míry zaručuje nezávislost testů (což
samozřejmě neznamená, že například při práci se soubory dosáhneme ideální
izolace testů).</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně jeden megabajt), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>factorial.go</td><td>implementace funkce pro výpočet faktoriálu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/01_factorial_testing/factorial.go">https://github.com/tisnik/go-root/blob/master/article_18/01_factorial_testing/factorial.go</a></td></tr>
<tr><td> 1</td><td>factorial_test.go</td><td>jednotkové testy naprogramované s&nbsp;využitím balíčku <i>testing</i></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/01_factorial_testing/factorial_test.go">https://github.com/tisnik/go-root/blob/master/article_18/01_factorial_testing/factorial_test.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>factorial.go</td><td>implementace funkce pro výpočet faktoriálu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/02_factorial_oglematchers/factorial.go">https://github.com/tisnik/go-root/blob/master/article_18/02_factorial_oglematchers/factorial.go</a></td></tr>
<tr><td> 2</td><td>factorial_test.go</td><td>jednotkové testy využívající knihovnu <i>oglematchers</i></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/02_factorial_oglematchers/factorial_test.go">https://github.com/tisnik/go-root/blob/master/article_18/02_factorial_oglematchers/factorial_test.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>factorial.go</td><td>implementace funkce pro výpočet faktoriálu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/03_factorial_oglematchers2/factorial.go">https://github.com/tisnik/go-root/blob/master/article_18/03_factorial_oglematchers2/factorial.go</a></td></tr>
<tr><td> 3</td><td>factorial_test.go</td><td>použití &bdquo;tečkové&ldquo; notace při importu knihoven</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/03_factorial_oglematchers2/factorial_test.go">https://github.com/tisnik/go-root/blob/master/article_18/03_factorial_oglematchers2/factorial_test.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>factorial.go</td><td>implementace funkce pro výpočet faktoriálu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/04_factorial_ogletest/factorial.go">https://github.com/tisnik/go-root/blob/master/article_18/04_factorial_ogletest/factorial.go</a></td></tr>
<tr><td> 4</td><td>factorial_test.go</td><td>jednotkové testy používající knihovny <i>oglematchers</i> a <i>ogletest</i></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/04_factorial_ogletest/factorial_test.go">https://github.com/tisnik/go-root/blob/master/article_18/04_factorial_ogletest/factorial_test.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>factorial.go</td><td>implementace funkce pro výpočet faktoriálu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/05_factorial_ogletest2/factorial.go">https://github.com/tisnik/go-root/blob/master/article_18/05_factorial_ogletest2/factorial.go</a></td></tr>
<tr><td> 5</td><td>factorial_test.go</td><td>použití &bdquo;tečkové&ldquo; notace při importu knihoven</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/05_factorial_ogletest2/factorial_test.go">https://github.com/tisnik/go-root/blob/master/article_18/05_factorial_ogletest2/factorial_test.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>factorial.go</td><td>implementace funkce pro výpočet faktoriálu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/06_factorial_assertions/factorial.go">https://github.com/tisnik/go-root/blob/master/article_18/06_factorial_assertions/factorial.go</a></td></tr>
<tr><td> 6</td><td>factorial_test.go</td><td>použití knihovny <i>assertions</i> pro tisk podmínek v&nbsp;jednotkovém testu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/06_factorial_assertions/factorial_test.go">https://github.com/tisnik/go-root/blob/master/article_18/06_factorial_assertions/factorial_test.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>factorial.go</td><td>implementace funkce pro výpočet faktoriálu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/07_factorial_assertions2/factorial.go">https://github.com/tisnik/go-root/blob/master/article_18/07_factorial_assertions2/factorial.go</a></td></tr>
<tr><td> 7</td><td>factorial_test.go</td><td>použití knihovny <i>assertions</i> pro vytvoření jednotkových testů</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/07_factorial_assertions2/factorial_test.go">https://github.com/tisnik/go-root/blob/master/article_18/07_factorial_assertions2/factorial_test.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>factorial.go</td><td>implementace funkce pro výpočet faktoriálu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/08_factorial_assertions3/factorial.go">https://github.com/tisnik/go-root/blob/master/article_18/08_factorial_assertions3/factorial.go</a></td></tr>
<tr><td> 8</td><td>factorial_test.go</td><td>použití &bdquo;tečkové&ldquo; notace při importu knihoven</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/08_factorial_assertions3/factorial_test.go">https://github.com/tisnik/go-root/blob/master/article_18/08_factorial_assertions3/factorial_test.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>factorial.go</td><td>implementace funkce pro výpočet faktoriálu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/09_factorial_convey/factorial.go">https://github.com/tisnik/go-root/blob/master/article_18/09_factorial_convey/factorial.go</a></td></tr>
<tr><td> 9</td><td>behaviour_test.go</td><td>BDD test založený na knihovně <i>GoConvey</i></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/09_factorial_convey/behaviour_test.go">https://github.com/tisnik/go-root/blob/master/article_18/09_factorial_convey/behaviour_test.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>factorial.go</td><td>implementace funkce pro výpočet faktoriálu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/10_factorial_convey2/factorial.go">https://github.com/tisnik/go-root/blob/master/article_18/10_factorial_convey2/factorial.go</a></td></tr>
<tr><td>10</td><td>behaviour_test.go</td><td>BDD test založený na knihovně <i>GoConvey</i></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_18/10_factorial_convey2/behaviour_test.go">https://github.com/tisnik/go-root/blob/master/article_18/10_factorial_convey2/behaviour_test.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Dokumentace k&nbsp;balíčku <i>oglematchers</i><br />
<a href="https://godoc.org/github.com/jacobsa/oglematchers">https://godoc.org/github.com/jacobsa/oglematchers</a>
</li>

<li>Balíček <i>oglematchers</i><br />
<a href="https://github.com/jacobsa/oglematchers">https://github.com/jacobsa/oglematchers</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>ogletest</i><br />
<a href="https://godoc.org/github.com/jacobsa/ogletest">https://godoc.org/github.com/jacobsa/ogletest</a>
</li>

<li>Balíček <i>ogletest</i><br />
<a href="https://github.com/jacobsa/ogletest">https://github.com/jacobsa/ogletest</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>assert</i><br />
<a href="https://godoc.org/github.com/stretchr/testify/assert">https://godoc.org/github.com/stretchr/testify/assert</a>
</li>

<li>Testify - Thou Shalt Write Tests<br />
<a href="https://github.com/stretchr/testify/">https://github.com/stretchr/testify/</a>
</li>

<li>Package testing<br />
<a href="https://golang.org/pkg/testing/">https://golang.org/pkg/testing/</a>
</li>

<li>Golang basics - writing unit tests<br />
<a href="https://blog.alexellis.io/golang-writing-unit-tests/">https://blog.alexellis.io/golang-writing-unit-tests/</a>
</li>

<li>An Introduction to Programming in Go / Testing<br />
<a href="https://www.golang-book.com/books/intro/12">https://www.golang-book.com/books/intro/12</a>
</li>

<li>An Introduction to Testing in Go<br />
<a href="https://tutorialedge.net/golang/intro-testing-in-go/">https://tutorialedge.net/golang/intro-testing-in-go/</a>
</li>

<li>Advanced Go Testing Tutorial<br />
<a href="https://tutorialedge.net/golang/advanced-go-testing-tutorial/">https://tutorialedge.net/golang/advanced-go-testing-tutorial/</a>
</li>

<li>GoConvey<br />
<a href="http://goconvey.co/">http://goconvey.co/</a>
</li>

<li>Testing Techniques<br />
<a href="https://talks.golang.org/2014/testing.slide">https://talks.golang.org/2014/testing.slide</a>
</li>

<li>5 simple tips and tricks for writing unit tests in #golang<br />
<a href="https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742">https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742</a>
</li>

<li>Afinní transformace<br />
<a href="https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic">https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic</a>
</li>

<li>package gg<br />
<a href="https://godoc.org/github.com/fogleman/gg">https://godoc.org/github.com/fogleman/gg</a>
</li>

<li>Generate an animated GIF with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/">http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/</a>
</li>

<li>Generate an image programmatically with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/">http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/</a>
</li>

<li>The Go image package<br />
<a href="https://blog.golang.org/go-image-package">https://blog.golang.org/go-image-package</a>
</li>

<li>Balíček draw2D: 2D rendering for different output (raster, pdf, svg)<br />
<a href="https://github.com/llgcode/draw2d">https://github.com/llgcode/draw2d</a>
</li>

<li>Draw a rectangle in Golang?<br />
<a href="https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang">https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang</a>
</li>

<li>YAML<br />
<a href="https://yaml.org/">https://yaml.org/</a>
</li>

<li>edn<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Smile<br />
<a href="https://github.com/FasterXML/smile-format-specification">https://github.com/FasterXML/smile-format-specification</a>
</li>

<li>Protocol-Buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>Marshalling (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
</li>

<li>Unmarshalling<br />
<a href="https://en.wikipedia.org/wiki/Unmarshalling">https://en.wikipedia.org/wiki/Unmarshalling</a>
</li>

<li>Introducing JSON<br />
<a href="http://json.org/">http://json.org/</a>
</li>

<li>Package json<br />
<a href="https://golang.org/pkg/encoding/json/">https://golang.org/pkg/encoding/json/</a>
</li>

<li>The Go Blog: JSON and Go<br />
<a href="https://blog.golang.org/json-and-go">https://blog.golang.org/json-and-go</a>
</li>

<li>Go by Example: JSON<br />
<a href="https://gobyexample.com/json">https://gobyexample.com/json</a>
</li>

<li>Writing Web Applications<br />
<a href="https://golang.org/doc/articles/wiki/">https://golang.org/doc/articles/wiki/</a>
</li>

<li>Golang Web Apps<br />
<a href="https://www.reinbach.com/blog/golang-webapps-1/">https://www.reinbach.com/blog/golang-webapps-1/</a>
</li>

<li>Build web application with Golang<br />
<a href="https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details">https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details</a>
</li>

<li>Golang Templates - Golang Web Pages<br />
<a href="https://www.youtube.com/watch?v=TkNIETmF-RU">https://www.youtube.com/watch?v=TkNIETmF-RU</a>
</li>

<li>Simple Golang HTTPS/TLS Examples<br />
<a href="https://github.com/denji/golang-tls">https://github.com/denji/golang-tls</a>
</li>

<li>Playing with images in HTTP response in golang<br />
<a href="https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang">https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang</a>
</li>

<li>MIME Types List<br />
<a href="https://www.freeformatter.com/mime-types-list.html">https://www.freeformatter.com/mime-types-list.html</a>
</li>

<li>Go Mutex Tutorial<br />
<a href="https://tutorialedge.net/golang/go-mutex-tutorial/">https://tutorialedge.net/golang/go-mutex-tutorial/</a>
</li>

<li>Creating A Simple Web Server With Golang<br />
<a href="https://tutorialedge.net/golang/creating-simple-web-server-with-golang/">https://tutorialedge.net/golang/creating-simple-web-server-with-golang/</a>
</li>

<li>Building a Web Server in Go<br />
<a href="https://thenewstack.io/building-a-web-server-in-go/">https://thenewstack.io/building-a-web-server-in-go/</a>
</li>

<li>How big is the pipe buffer?<br />
<a href="https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer">https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer</a>
</li>

<li>How to turn off buffering of stdout in C<br />
<a href="https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c">https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c</a>
</li>

<li>setbuf(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/setbuf">https://linux.die.net/man/3/setbuf</a>
</li>

<li>setvbuf(3) - Linux man page (stejný obsah jako předchozí stránka)<br />
<a href="https://linux.die.net/man/3/setvbuf">https://linux.die.net/man/3/setvbuf</a>
</li>

<li>Select waits on a group of channels<br />
<a href="https://yourbasic.org/golang/select-explained/">https://yourbasic.org/golang/select-explained/</a>
</li>

<li>Rob Pike: Simplicity is Complicated (video)<br />
<a href="http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893">http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893</a>
</li>

<li>Algorithms to Go<br />
<a href="https://yourbasic.org/">https://yourbasic.org/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů: vlastní filtry a lexery<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/</a>
</li>

<li>Go Defer Simplified with Practical Visuals<br />
<a href="https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff">https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff</a>
</li>

<li>5 More Gotchas of Defer in Go — Part II<br />
<a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa">https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa</a>
</li>

<li>The Go Blog: Defer, Panic, and Recover<br />
<a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a>
</li>

<li>The defer keyword in Swift 2: try/finally done right<br />
<a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer">https://www.hackingwithswift.com/new-syntax-swift-2-defer</a>
</li>

<li>Swift Defer Statement<br />
<a href="https://andybargh.com/swift-defer-statement/">https://andybargh.com/swift-defer-statement/</a>
</li>

<li>Modulo operation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Modulo_operation">https://en.wikipedia.org/wiki/Modulo_operation</a>
</li>

<li>Node.js vs Golang: Battle of the Next-Gen Languages<br />
<a href="https://www.hostingadvice.com/blog/nodejs-vs-golang/">https://www.hostingadvice.com/blog/nodejs-vs-golang/</a>
</li>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go<br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>JavaScript vs. Golang for IoT: Is Gopher Winning?<br />
<a href="https://www.iotforall.com/javascript-vs-golang-iot/">https://www.iotforall.com/javascript-vs-golang-iot/</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

<li>Printf Format Strings<br />
<a href="https://www.cprogramming.com/tutorial/printf-format-strings.html">https://www.cprogramming.com/tutorial/printf-format-strings.html</a>
</li>

<li>Java: String.format<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-</a>
</li>

<li>Java: format string syntax<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a>
</li>

<li>Selectors<br />
<a href="https://golang.org/ref/spec#Selectors">https://golang.org/ref/spec#Selectors</a>
</li>

<li>Calling Go code from Python code<br />
<a href="http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/">http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/</a>
</li>

<li>Go Data Structures: Interfaces <br />
<a href="https://research.swtch.com/interfaces">https://research.swtch.com/interfaces</a>
</li>

<li>How to use interfaces in Go<br />
<a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go</a>
</li>

<li>Interfaces in Go (part I)<br />
<a href="https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c">https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c</a>
</li>

<li>Part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>What about Trait support in Golang?<br />
<a href="https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/">https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/</a>
</li>

<li>Don't Get Bitten by Pointer vs Non-Pointer Method Receivers in Golang<br />
<a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/">https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/</a>
</li>

<li>Control Flow<br />
<a href="https://en.wikipedia.org/wiki/Control_flow">https://en.wikipedia.org/wiki/Control_flow</a>
</li>

<li>Structured programming<br />
<a href="https://en.wikipedia.org/wiki/Structured_programming">https://en.wikipedia.org/wiki/Structured_programming</a>
</li>

<li>Control Structures<br />
<a href="https://www.golang-book.com/books/intro/5">https://www.golang-book.com/books/intro/5</a>
</li>

<li>Control structures - Go if else statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html">http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html</a>
</li>

<li>Control structures - Go switch case statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html</a>
</li>

<li>Control structures - Go for loop, break, continue, range<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html</a>
</li>

<li>Single Function Exit Point<br />
<a href="http://wiki.c2.com/?SingleFunctionExitPoint">http://wiki.c2.com/?SingleFunctionExitPoint</a>
</li>

<li>Entry point<br />
<a href="https://en.wikipedia.org/wiki/Entry_point">https://en.wikipedia.org/wiki/Entry_point</a>
</li>

<li>Why does Go have a GOTO statement?!<br />
<a href="https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/">https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/</a>
</li>

<li>Effective Go<br />
<a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a>
</li>

<li>GoClipse: an Eclipse IDE for the Go programming language<br />
<a href="http://goclipse.github.io/">http://goclipse.github.io/</a>
</li>

<li>GoClipse Installation<br />
<a href="https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation">https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

