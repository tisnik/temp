<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Textová uživatelská rozhraní naprogramovaná v jazyku Go</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Textová uživatelská rozhraní naprogramovaná v jazyku Go</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Poměrně velké množství užitečných a úspěšných aplikací používá pro komunikaci s uživatelem TUI neboli textové uživatelské rozhraní. Dnes se seznámíme s některými knihovnami určenými pro tvorbu TUI v jazyce Go. Ve druhé části článku se zaměříme na nízkoúrovňovou knihovnu tcell.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Textová uživatelská rozhraní naprogramovaná v&nbsp;jazyku Go</a></p>
<p><a href="#k02">2. Interaktivní příkazový řádek s&nbsp;historií, automatickým doplňováním atd.</a></p>
<p><a href="#k03">3. Balíček <strong>go-prompt</strong> pro aplikace naprogramované v&nbsp;jazyku Go</a></p>
<p><a href="#k04">4. Příklady použití balíčku <strong>go-prompt</strong></a></p>
<p><a href="#k05">5. Knihovny pro ovládání terminálu i pro tvorbu plnohodnotných TUI</a></p>
<p><a href="#k06">6. Vybrané knihovny pro Go</a></p>
<p><a href="#k07">7. Práce s&nbsp;textovým terminálem s&nbsp;využitím knihovny <strong>tcell</strong></a></p>
<p><a href="#k08">8. Koncept událostí (<i>event</i>)</a></p>
<p><a href="#k09">9. Kostra programu, který dokáže vypsat obarvený text na terminál a reagovat na stisk kláves</a></p>
<p><a href="#k10">10. Korektní ukončení programu</a></p>
<p><a href="#k11">11. Vykreslení okna do plochy terminálu, reakce na změnu velikosti terminálu</a></p>
<p><a href="#k12">12. Kreslení na plochu terminálu s&nbsp;využitím myši</a></p>
<p><a href="#k13">13. Podporované styly zpráv vypisovaných na plochu terminálu</a></p>
<p><a href="#k14">14. Standardní barvová paleta terminálů (a její nedodržování)</a></p>
<p><a href="#k15">15. Světlý vs.&nbsp;tmavý text na ploše terminálu</a></p>
<p><a href="#k16">16. Specifikace 24bitové barvy popředí (textů)</a></p>
<p><a href="#k17">17. Specifikace 24bitové barvy pozadí</a></p>
<p><a href="#k18">18. Změna stylu zobrazení textového kurzoru na vybraných terminálech</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Textová uživatelská rozhraní naprogramovaná v&nbsp;jazyku Go</h2>

<p>Již mnohokrát jsme si <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">v&nbsp;seriálu o
programovacím jazyku Go</a> řekli, že se tento jazyk primárně používá pro
tvorbu síťových utilit, mikroslužeb či dokonce ucelených webových aplikací. Je
to ostatně logické, protože právě v&nbsp;těchto oblastech se využijí prakticky
všechny užitečné vlastnosti tohoto programovacího jazyka, zejména pak podpora
pro práci s&nbsp;<i>gorutinami</i>, komunikace mezi gorutinami s&nbsp;využitím
<i>kanálů</i> a v&nbsp;neposlední řadě taktéž možnost přeložit nástroj
naprogramovaný v&nbsp;jazyku Go do jediného binárního souboru (pro určenou
platformu), který nevyžaduje prakticky žádnou instalaci (na rozdíl od aplikací
v&nbsp;některých jiných jazycích, v&nbsp;nichž je nutné zajistit buď
kompatibilní dynamicky linkované knihovny či dokonce celý <i>runtime</i> daného
programovacího jazyka).</p>

<p>To však samozřejmě neznamená, že by se jazyk Go nemohl využívat i
v&nbsp;dalších oblastech. Sice se (s&nbsp;poměrně velkou pravděpodobností)
prozatím neprosadí například pro tvorbu her, ovšem naproti tomu nalezneme velké
množství nástrojů naprogramovaných právě v&nbsp;jazyce Go, které se ovládají
interaktivně příkazy zadávanými z&nbsp;příkazového řádku (<i>command line</i>)
nebo které dokonce obsahují plnohodnotné <a
href="https://github.com/rothgar/awesome-tuis">textové uživatelské rozhraní</a>
(<i>TUI</i>). Příklady takových projektů jsou &bdquo;lazy&ldquo; aplikace od
<i>Jesse Duffielda</i> (ke kterým se někdy vrátíme) nebo <i>fjira</i> (prozatím
tomuto textovému rozhraní pro JIRu ovšem chybí některé možnosti nabízené
standardním webovým klientem):</p>

<ol>

<li>lazygit<br />
<a href="https://github.com/jesseduffield/lazygit">https://github.com/jesseduffield/lazygit</a>
</li>

<li>lazydocker<br />
<a href="https://github.com/jesseduffield/lazydocker">https://github.com/jesseduffield/lazydocker</a>
</li>

<li>lazynpm<br />
<a href="https://github.com/jesseduffield/lazynpm">https://github.com/jesseduffield/lazynpm</a>
</li>

<li>fjira<br />
<a href="https://github.com/mk-5/fjira">https://github.com/mk-5/fjira</a>
</li>

</ol>

<a href="https://www.root.cz/obrazek/1101537/"><img src="https://i.iinfo.cz/images/298/tcell-prev.png" class="image-1101537" width="370" height="225" data-prev-filename="https://i.iinfo.cz/images/298/tcell-prev.png" data-prev-width="370" data-prev-height="225" data-large-filename="https://i.iinfo.cz/images/298/tcell-large.png" data-large-width="720" data-large-height="438" alt="&#160;" title="Autor: original authors of lazygit, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 1: Textové uživatelské rozhraní lazygitu.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Interaktivní příkazový řádek s&nbsp;historií, automatickým doplňováním atd.</h2>

<p>U poměrně velkého množství aplikací se s&nbsp;výhodou využije ovládání
s&nbsp;využitím interaktivního příkazového řádku, který je doplněn o množství
pomocných technik &ndash; možností editace, doplněním historie, schránky,
automatickým doplňováním atd. atd. Takové aplikace tedy používají interaktivní
smyčku REPL (<a
href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">Read-Eval-Print
Loop</a>), tj.&nbsp;aplikace se spustí, vypíše tzv.&nbsp;výzvu (<i>prompt</i>)
uživateli, akceptuje zadané příkazy, nějakým způsobem je vykoná a opět vypíše
výzvu. Zde je již většinou nutné investovat více času na přípravu prostředí
aplikace, protože dnes uživatelé (po právu) vyžadují, aby nástroj
s&nbsp;vlastní interaktivní smyčkou REPL podporoval historii příkazů,
vyhledávání v&nbsp;historii, obarvení vstupů, podporu pro automatické
doplňování příkazů atd. atd.</p>

<a href="https://www.root.cz/obrazek/358439/"><img src="https://i.iinfo.cz/images/472/golang-20-1-prev.png" class="image-358439" alt="&#160;" width="370" height="242" /></a>
<p><i>Obrázek 2: Velmi dobrým příkladem aplikace s&nbsp;interaktivní smyčkou
REPL je IPython.</i></p>

<p>Pro aplikace s&nbsp;interaktivní smyčkou REPL programované v&nbsp;jazyku Go
vzniklo několik knihoven, které nabízí některé či všechny výše uvedené a
vyžadované funkce. Jedná se například o tyto knihovny:</p>

<ul>

<li>go-readline<br />
<a href="https://github.com/fiorix/go-readline">https://github.com/fiorix/go-readline</a>
</li>

<li>go-prompt<br />
<a href="https://github.com/c-bata/go-prompt">https://github.com/c-bata/go-prompt</a>
</li>

<li>readline<br />
<a href="https://github.com/chzyer/readline">https://github.com/chzyer/readline</a>
</li>

</ul>



<p><a name="k03"></a></p>
<h2 id="k03">3. Balíček <strong>go-prompt</strong> pro aplikace naprogramované v&nbsp;jazyku Go</h2>

<p>Pravděpodobně nejpoužívanějším balíčkem pro Go, který zajišťuje interaktivní
REPL, je balíček nazvaný <strong>go-prompt</strong>, jenž je inspirován
podobným balíčkem pro Python nazvaným <strong>prompt_toolkit</strong>.
S&nbsp;<strong>go-prompt</strong> jsme se již v&nbsp;tomto seriálu setkali,
takže si pouze ve stručnosti uveďme jeho základní vlastnosti a způsob jeho
použití. Tento balíček nabízí uživatelům následující funkce:</p>

<ol>

<li>Plnohodnotnou editaci na příkazovém řádku, samozřejmě včetně možnosti
přesunu kurzoru s&nbsp;využitím příkazů Ctrl+znak, specializovaných kláves
Home, End atd.</li>

<li>Mazání textu před kurzorem, za kurzorem, smazání slova apod.</li>

<li>Automatické doplňování příkazů na základě tabulky, kterou je možné
dynamicky měnit.</li>

<li>Kontextovou nápovědu s&nbsp;dostupnými příkazy, a to včetně popisu
jednotlivých příkazů.</li>

<li>Historii již zapsaných příkazů.</li>

<li>Fuzzy vyhledávání příkazů.</li>

</ol>



<p><a name="k04"></a></p>
<h2 id="k04">4. Příklady použití balíčku <strong>go-prompt</strong></h2>

<p>Základním příkazem, který nalezneme v&nbsp;balíčku
<strong>go-prompt</strong>, je příkaz <strong>Input</strong>, který většinu
výše zmíněné funkcionality nabízí a kterému lze předat jinou funkci použitou
pro doplňování příkazů a nabízení všech v&nbsp;dané chvíli dostupných
alternativ:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "github.com/c-bata/go-prompt"
&nbsp;
func <strong>completer</strong>(in prompt.Document) []prompt.Suggest {
        return []prompt.Suggest{}
}
&nbsp;
func <strong>main</strong>() {
        login := prompt.Input("Login: ", completer)
        password := prompt.Input("Password: ", completer)
        println(login)
        println(password)
}
</pre>

<a href="https://www.root.cz/obrazek/358443/"><img src="https://i.iinfo.cz/images/472/golang-20-5-prev.png" class="image-358443" alt="&#160;" width="370" height="242" /></a>
<p><i>Obrázek 3: Povšimněte si, že se stiskem klávesy <strong>Ctrl+A</strong>
či <strong>Home</strong> můžeme bez problémů přesunout na začátek vstupního
řádku. Všechny ostatní editační příkazy budou taktéž funkční.</i></p>

<p>A takto lze zajistit automatické doplňování příkazů:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/c-bata/go-prompt"
        "os"
)
&nbsp;
func <strong>executor</strong>(t string) {
        switch t {
        case "exit":
                fallthrough
        case "quit":
                os.Exit(0)
        case "help":
                println("HELP:\nexit\nquit")
        default:
                println("Nothing happens")
        }
}
&nbsp;
func <strong>completer</strong>(in prompt.Document) []prompt.Suggest {
        return []prompt.Suggest{
                {Text: "help"},
                {Text: "exit"},
                {Text: "quit"},
        }
}
&nbsp;
func <strong>main</strong>() {
        p := prompt.New(executor, completer)
        p.Run()
}
</pre>

<a href="https://www.root.cz/obrazek/358445/"><img src="https://i.iinfo.cz/images/472/golang-20-7-prev.png" class="image-358445" alt="&#160;" width="370" height="242" /></a>
<p><i>Obrázek 4: Po spuštění se pouze očekává příkaz, žádná nápověda se
nevypíše.</i></p>

<a href="https://www.root.cz/obrazek/358446/"><img src="https://i.iinfo.cz/images/472/golang-20-8-prev.png" class="image-358446" alt="&#160;" width="370" height="242" /></a>
<p><i>Obrázek 5: Vrácením kurzoru se zobrazí tabulka se všemi dostupnými
příkazy.</i></p>

<a href="https://www.root.cz/obrazek/358447/"><img src="https://i.iinfo.cz/images/472/golang-20-9-prev.png" class="image-358447" alt="&#160;" width="370" height="242" /></a>
<p><i>Obrázek 6: Nápověda prozatím <strong>není</strong> kontextová, ovšem
klávesou <strong>Tab</strong> lze příkaz doplnit.</i></p>

<a href="https://www.root.cz/obrazek/358448/"><img src="https://i.iinfo.cz/images/472/golang-20-10-prev.png" class="image-358448" alt="&#160;" width="370" height="242" /></a>
<p><i>Obrázek 7: Doplněný příkaz se zobrazí odlišnou barvou.</i></p>

<p>A nakonec si ukažme zajištění kontextové nápovědy k&nbsp;vybíraným
příkazům:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/c-bata/go-prompt"
        "os"
)
&nbsp;
func <strong>executor</strong>(t string) {
        switch t {
        case "exit":
                fallthrough
        case "quit":
                os.Exit(0)
        case "help":
                println("HELP:\nexit\nquit")
        default:
                println("Nothing happens")
        }
        return
}
&nbsp;
func <strong>completer</strong>(in prompt.Document) []prompt.Suggest {
        s := []prompt.Suggest{
                {Text: "help", Description: "show help with all commands"},
                {Text: "exit", Description: "quit the application"},
                {Text: "quit", Description: "quit the application"},
        }
        return prompt.FilterHasPrefix(s, in.GetWordBeforeCursor(), true)
}
&nbsp;
func <strong>main</strong>() {
        p := prompt.New(executor, completer)
        p.Run()
}
</pre>

<a href="https://www.root.cz/obrazek/358451/"><img src="https://i.iinfo.cz/images/472/golang-20-13-prev.png" class="image-358451" alt="&#160;" width="370" height="242" /></a>
<p><i>Obrázek 8: Zobrazení všech příkazů i s&nbsp;nápovědou.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Knihovny pro ovládání terminálu i pro tvorbu plnohodnotných TUI</h2>

<p>Pro aplikace s&nbsp;příkazovým řádkem nebo s&nbsp;plnohodnotnou smyčkou REPL
v&nbsp;naprosté většině případů plně dostačuje funkcionalita nabízená výše
zmíněným balíčkem <strong>go-prompt</strong>. Ovšem v&nbsp;mnoha aplikacích by
bylo vhodné nabídnout uživatelům plnohodnotné textové uživatelské rozhraní.
Knihoven resp.&nbsp;přesněji řečeno balíčků pro tvorbu textového uživatelského
rozhraní v&nbsp;jazyku Go existuje celá řada (minimálně desítky). Jak se ovšem
tyto knihovny od sebe odlišují a lze z&nbsp;nich vybrat tu nejlepší? Do značné
míry záleží na požadavcích programátora, protože knihovny pro tvorbu textového
uživatelského rozhraní je možné rozdělit do několika kategorií:</p>

<ul>

<li>U některých aplikací požadujeme poměrně malé množství dostupných funkcí.
Typicky se jedná o možnost změny pozice textového kurzoru, změnu barvy
vykreslování znaků, změnu stylu vykreslování znaků (podtržené atd.), čtení
kláves bez čekání na stisk Enter a výpis znaku. Příkladem mohou být různé hry
běžící v&nbsp;textovém režimu.</li>

<li>Další skupina aplikací již vyžaduje některé sofistikovanější funkce,
například možnost definice obdélníkových oken, které mohou tvořit základní
abstrakci nad textovým terminálem. Ve světě jazyka C tuto vrstvu abstrakce
nabízí známá knihovna <i>ncurses</i> a její obdobu nalezneme i v&nbsp;jazyce
Go.</li>

<li>Ve třetí skupině aplikací se nachází ty aplikace, které již potřebují
vykreslit složitější a unifikované ovládací prvky (<i>widgety</i>), mezi něž
patří tlačítka, výběrové seznamy, zatrhávací boxy, vstupní textová pole atd.
Ovšem mnohé knihovny nabízí i další užitečné prvky, mezi něž patří různé typy
grafů (zobrazovaných v&nbsp;textovém režimu) apod.</li>

<li>A konečně ve čtvrté skupině nalezneme takové aplikace, které vyžadují
&bdquo;plnohodnotné GUI, ovšem pracující v&nbsp;textovém režimu&ldquo;. Takové
aplikace již pracují s&nbsp;okny (které se mohou překrývat), ovládacími prvky,
reagují na události od uživatele atd. V&nbsp;krátkosti &ndash; moderní variantu
kdysi populární knihovny <i>Turbo Vision</i>. I takové knihovny pro jazyk Go
nalezneme, i když prozatím v&nbsp;podobě, která zdaleka není finální.</li>

</ul>

<a href="http://www.root.cz/obrazek/229450/"><img src="http://i.iinfo.cz/images/386/tp01-prev.png" class="image-229450" alt="&#160;" height="231" width="370" /></a>
<p><i>Obrázek 9: Ukázka možností kdysi populární knihovny TurboVision: dialog
se základními informacemi o IDE Turbo Pascal 7.0.</i></p>

<a href="http://www.root.cz/obrazek/229456/"><img src="http://i.iinfo.cz/images/571/bp02-prev.png" class="image-229456" alt="&#160;" height="231" width="370" /></a>
<p><i>Obrázek 10: Další ukázka použití TurboVision: textové uživatelské
vývojové prostředí Borland Pascal.</i></p>

<p>Z&nbsp;výše uvedeného seznamu je pravděpodobně patrné, že nebude existovat
jedna knihovna, která by vyhovovala všem požadavkům. Z&nbsp;tohoto důvodu se
postupně seznámíme s&nbsp;několika různými knihovnami a u každé si na
příkladech ukážeme její silné stránky i to, kdy je již vhodnější přejít
k&nbsp;odlišně koncipované knihovně.</p>

<p><div class="rs-tip-major">Poznámka: i programy, které jsou založeny na
textovém uživatelském rozhraní, je možné ovládat s&nbsp;využitím myši. Záleží
jen na programátorovi, zda bude myš použita standardním způsobem (pro výběr
textu) či zda ji bude možné použít i pro ovládání jednotlivých TUI prvků
aplikace (tlačítka, výběrové boxy, přesuny oken atd.).</div></p>

<img src="https://i.iinfo.cz/images/133/prompt-toolkit-5-8.png" class="image-335561" alt="&#160;" width="806" height="531" />
<p><i>Obrázek 11: Typická aplikace s&nbsp;plnohodnotným menu v&nbsp;TUI &ndash;
Midnight Commander.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vybrané knihovny pro Go</h2>

<p>Mezi knihovny určené pro programovací jazyk Go, které programátorům nabízí
spíše základní funkce určené pro ovládání textového terminálu, patří
<i>termbox-go</i> a taktéž knihovna <i>tcell</i>. První z&nbsp;těchto knihoven
nalezneme na GitHubu, konkrétně na adrese <a
href="https://github.com/nsf/termbox-go">https://github.com/nsf/termbox-go</a>.
Tato knihovna již sice oficiálně není udržována, ale je stále používána
v&nbsp;některých projektech a o její popularitě svědčí i relativně vysoký počet
&bdquo;hvězdiček&ldquo;. Naproti tomu druhá zmíněná knihovna, kterou nalezneme
na stránce <a
href="https://github.com/gdamore/tcell">https://github.com/gdamore/tcell</a>,
je stále vyvíjena a dokonce pro ni existuje i komerční podpora. Ukázky použití
této knihovny budou uvedeny v&nbsp;navazujících kapitolách.</p>

<p>A jaký je stav knihoven, které nabízí textové ovládací prvky či dokonce
plnohodnotné textové uživatelské rozhraní? Příkladem takové knihovny může být
knihovna nazvaná <i>termui</i>, kterou nalezneme na GitHubu na adrese <a
href="https://github.com/gizak/termui">https://github.com/gizak/termui</a>.
V&nbsp;této knihovně programátor najde relativně velké množství prvků určených
pro zobrazování informací (spíše než typicky ovládacích prvků). To znamená, že
se tato knihovna hodí například pro implementaci různých <i>dashboardů</i>. Na
druhé straně spektra můžeme najít knihovnu <i>gocui</i> (<a
href="https://github.com/jroimartin/gocui">https://github.com/jroimartin/gocui</a>).
Tato knihovna byla použita například v&nbsp;nástroji <i>kcli</i> (<a
href="https://github.com/cswank/kcli">https://github.com/cswank/kcli</a>),
s&nbsp;nímž jsme se setkali v&nbsp;článcích o Apache Kafce.</p>

<img src="https://i.iinfo.cz/images/437/kcli-1.png" class="image-450789" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/licenses/by/4.0/legalcode.cs&quot;&gt;CC-BY&lt;/a&gt;" width="617" height="401" />
<p><i>Obrázek 12: Nápověda ke klávesovým zkratkám nástroje
<strong>kcli</strong>.</i></p>

<p>Zapomenout nesmíme ani na knihovnu <i>tview</i> popř.&nbsp;na její fork
pojmenovaný <i>cview</i>. S&nbsp;možnostmi nabízenými touto knihovnou se
seznámíme v&nbsp;samostatném článku.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Práce s&nbsp;textovým terminálem s&nbsp;využitím knihovny <strong>tcell</strong></h2>

<p>První knihovna, která programátorům umožňuje pracovat s&nbsp;textovým
terminálem z&nbsp;programovacího jazyka Go, s&nbsp;níž se v&nbsp;tomto seriálu
seznámíme, se jmenuje <i>tcell</i>. Tato knihovna umožňuje na libovolnou pozici
terminálu vykreslit libovolný znak z&nbsp;Unicode a specifikovat u něj styl
vykreslení (tučné písmo, kurzíva, podtržení, přeškrtnutí, blikání), barvu
popředí, barvu pozadí a taktéž skupinu dalších znaků, které se postupně složí
(představte si spojení háčku s&nbsp;písmenem). Taktéž je podporována změna
stylu textového kurzoru, ovšem pouze za předpokladu, že tyto změny podporuje i
vlastní emulátor terminálu. To pochopitelně není vše, protože terminál je
vstupně-výstupním zařízením. Výstup již známe &ndash; je jím mřížka znaků.
Vstupem je klávesnice a myš, popř.&nbsp;nějaká další operace vyvolaná například
příkazem <i>paste</i>. V&nbsp;knihovně <i>tcell</i> se s&nbsp;těmito zařízeními
pracuje tak, že stisk kláves, stisk tlačítek myši (ale i změna velikosti okna
terminálu) generuje takzvanou událost, na kterou je možné reagovat, což uvidíme
hned v&nbsp;další kapitole.</p>

<a href="https://www.root.cz/obrazek/1101538/"><img src="https://i.iinfo.cz/images/215/tcell2-prev.png" class="image-1101538" width="370" height="195" data-prev-filename="https://i.iinfo.cz/images/215/tcell2-prev.png" data-prev-width="370" data-prev-height="195" data-large-filename="https://i.iinfo.cz/images/215/tcell2.png" data-large-width="656" data-large-height="346" alt="&#160;" title="Autor: original authors of todo app, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 13: Ukázka aplikace naprogramované v&nbsp;Go, která pro vstup a
výstup na terminál používá knihovnu tcell &ndash; jednoduchý manažer úloh.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Koncept událostí (<i>event</i>)</h2>

<p>Při programování grafických uživatelských rozhraní je často používán pojem
události (<strong>event(s)</strong>). Událostmi řízené programování je ostatně
s&nbsp;programováním GUI prakticky neoddělitelně spojeno. Každý widget může
v&nbsp;průběhu svého života generovat nějaké události. Naprostá většina
událostí vzniká tak, že uživatel s&nbsp;widgetem interaktivně pracuje
(například stlačí tlačítko zobrazené na obrazovce). Ke každému widgetu je
příslušná jedna &bdquo;implicitní&ldquo; událost, na kterou reaguje. Tato
událost se nastavuje pomocí změny vlastnosti widgetu, což bude ukázáno
v&nbsp;demonstračních příkladech v&nbsp;následujících kapitolách. Kromě
implicitní události lze na widgety navázat i další události, například tlačítko
(<strong>button</strong>) může reagovat i na stlačení klávesy na klávesnici, na
pravé tlačítko myši či na rolování kolečkem myši.</p>

<p>V&nbsp;textových uživatelských rozhraních se s&nbsp;událostmi může pracovat
naprosto stejným způsobem &ndash; ovšem za předpokladu, že příslušná TUI
knihovna podporuje přímou manipulaci s&nbsp;widgety. V&nbsp;případě dnes
popisované knihovny <i>tcell</i> tomu tak ovšem není &ndash; zde se pracuje na
nižší úrovni. I tak je však <i>tcell</i> na událostech postavena, ovšem nyní
jsou události spojené přímo s&nbsp;akcemi uživatele s&nbsp;terminálem a nikoli
s&nbsp;jednotlivými ovládacími prvky. Událostí může být stisk klávesy, stisk
tlačítka myši (pokud je práce s&nbsp;myší povolena), vložení textu ze schránky,
ale například i změna velikosti okna terminálu. Na všechny tyto události může
aplikace adekvátním způsobem reagovat.</p>

<p>Události se typicky zpracovávají v&nbsp;nekonečné smyčce (což není tak úplně
pravda &ndash; z&nbsp;této smyčky se totiž vyskakuje při ukončování aplikace),
v&nbsp;níž se postupně čte další událost z&nbsp;takzvané <i>fronty
událostí</i>. Aplikace poté může na danou událost nějakým způsobem zareagovat.
V&nbsp;kostře příkladu ukázané pod tímto odstavcem je ukázáno, jak se reaguje
na dva typy událostí &ndash; změna velikosti okna terminálu a stisk nějaké
klávesy. Povšimněte si, že událost nesoucí informaci o stisknuté klávese
obsahuje jak kód klávesy (kurzorové šipky, Home, End, Esc atd.), tak i kód
znaku v&nbsp;případě alfanumerického vstupu (terminál nám přitom nedokáže
rozlišit například mezi Levý Shift+A, Pravý Shift+A nebo (Caps Lock) A &ndash;
vždy dostaneme jen znak &bdquo;A&ldquo;):</p>

<pre>
for {
        screen.Show()
&nbsp;
        event := screen.PollEvent()
&nbsp;
        switch ev := event.(type) {
        case *tcell.EventResize:
                screen.Sync()
        case *tcell.EventKey:
                if ev.Key() == tcell.KeyEscape || ev.Key() == tcell.KeyCtrlC {
                        return
                } else if ev.Rune() == 'C' || ev.Rune() == 'c' {
                        screen.Clear()
                }
        }
}
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;konstrukci
<strong>switch</strong> je proveden rozeskok na základě typu události, což je
(mnohdy velmi elegantní) specialita programovacího jazyka Go.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Kostra programu, který dokáže vypsat obarvený text na terminál a reagovat na stisk kláves</h2>

<p>Následuje program, který bude sloužit jako kostra pro všechny následující
demonstrační příklady. V&nbsp;tomto programu, který je mj.&nbsp;odvozen od
příkladu uvedeného v&nbsp;originální dokumentaci ke knihovně <i>tcell</i>, je
definována funkce <strong>drawText</strong> určená pro výpis textu do zvoleného
obdélníku (dokonce se zalomením). Interně tato funkce volá metodu
<strong>Screen.SetContent</strong> určenou pro tisk jediného znaku
v&nbsp;mřížce terminálu. Specifikovat se přitom musí souřadnice znaku, jeho kód
(Unicode), případné znaky, z&nbsp;nichž se výsledek složí (ukážeme si příště) a
styl. V&nbsp;hlavní funkci <strong>main</strong> je nejprve provedena
inicializace obrazovky, vymazání obsahu obrazovky terminálu a vstup do smyčky
událostí:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
&nbsp;
        tcell "github.com/gdamore/tcell/v2"
)
&nbsp;
func <strong>drawText</strong>(s tcell.Screen, x1, y1, x2, y2 int, style tcell.Style, text string) {
        row := y1
        column := x1
        for _, r := range []rune(text) {
                s.SetContent(col, row, r, nil, style)
                col++
                if column &gt;= x2 {
                        row++
                        column = x1
                }
                if row &gt; y2 {
                        break
                }
        }
}
&nbsp;
func <strong>main</strong>() {
        defStyle := tcell.StyleDefault.Background(tcell.ColorReset).Foreground(tcell.ColorReset)
&nbsp;
        screen, err := tcell.NewScreen()
        if err != nil {
                log.Fatalf("%+v", err)
        }
&nbsp;
        err = screen.Init()
        if err != nil {
                log.Fatalf("%+v", err)
        }
&nbsp;
        screen.SetStyle(defStyle)
        screen.Clear()
        drawText(screen, 5, 5, 20, 20, defStyle, "Hello, world!")
&nbsp;
        defer func() {
                screen.Fini()
        }()
&nbsp;
        for {
                screen.Show()
&nbsp;
                event := screen.PollEvent()
&nbsp;
                switch ev := event.(type) {
                case *tcell.EventResize:
                        screen.Sync()
                case *tcell.EventKey:
                        if ev.Key() == tcell.KeyEscape || ev.Key() == tcell.KeyCtrlC {
                                return
                        } else if ev.Rune() == 'C' || ev.Rune() == 'c' {
                                screen.Clear()
                        }
                }
        }
}
</pre>

<p>Výsledek by měl vypadat následovně:</p>

<img src="https://i.iinfo.cz/images/205/tcell3-1.png" class="image-1101539" width="660" height="437" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 14: Takto vypadá tento demonstrační příklad po svém spuštění
v&nbsp;emulátoru terminálu.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Korektní ukončení programu</h2>

<p>V&nbsp;předchozím demonstračním příkladu se při jeho ukončování volala tato
anonymní funkce:</p>

<pre>
defer func() {
        screen.Fini()
}()
</pre>

<p>To však není zcela ideální řešení, protože nám neumožňuje korektně reagovat
na všechny případné chyby v&nbsp;aplikaci, která by tak mohla ponechat terminál
v&nbsp;nějakém &bdquo;nepěkném&ldquo; stavu (což mnohé aplikace skutečně
dělají). Korektnější řešení je opět převzato z&nbsp;původní dokumentace ke
knihovně <i>tcell</i> a vypadá následovně &ndash; pokusíme se zjistit, zda
došlo k&nbsp;nějaké chybě a pokud ano, tak se spojení s&nbsp;terminálem ukončí,
jeho stav se obnoví a teprve poté se původní chyba znovu vyvolá:</p>

<pre>
<strong>quit</strong> := func() {
        maybePanic := recover()
        screen.Fini()
        if maybePanic != nil {
                panic(maybePanic)
        }
}
defer <strong>quit</strong>()
</pre>

<p>Žádné další změny nebyly provedeny, takže výsledný zdrojový kód upraveného
příkladu vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
&nbsp;
        tcell "github.com/gdamore/tcell/v2"
)
&nbsp;
func <strong>drawText</strong>(s tcell.Screen, x1, y1, x2, y2 int, style tcell.Style, text string) {
        row := y1
        column := x1
        for _, r := range []rune(text) {
                s.SetContent(col, row, r, nil, style)
                col++
                if column &gt;= x2 {
                        row++
                        column = x1
                }
                if row &gt; y2 {
                        break
                }
        }
}
&nbsp;
func <strong>main</strong>() {
        defStyle := tcell.StyleDefault.Background(tcell.ColorReset).Foreground(tcell.ColorReset)
&nbsp;
        screen, err := tcell.NewScreen()
        if err != nil {
                log.Fatalf("%+v", err)
        }
&nbsp;
        err = screen.Init()
        if err != nil {
                log.Fatalf("%+v", err)
        }
&nbsp;
        screen.SetStyle(defStyle)
        screen.Clear()
        drawText(screen, 5, 5, 20, 20, defStyle, "Hello, world!")
&nbsp;
        quit := func() {
                maybePanic := recover()
                screen.Fini()
                if maybePanic != nil {
                        panic(maybePanic)
                }
        }
        defer quit()
&nbsp;
        for {
                screen.Show()
&nbsp;
                event := screen.PollEvent()
&nbsp;
                switch ev := event.(type) {
                case *tcell.EventResize:
                        screen.Sync()
                case *tcell.EventKey:
                        if ev.Key() == tcell.KeyEscape || ev.Key() == tcell.KeyCtrlC {
                                return
                        } else if ev.Rune() == 'C' || ev.Rune() == 'c' {
                                screen.Clear()
                        }
                }
        }
}
</pre>

<img src="https://i.iinfo.cz/images/205/tcell3-2.png" class="image-1101540" width="660" height="437" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 15: Takto vypadá tento demonstrační příklad po svém spuštění
v&nbsp;emulátoru terminálu.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vykreslení okna do plochy terminálu, reakce na změnu velikosti terminálu</h2>

<p>Poměrně velké množství aplikací rozděluje zobrazované informace do několika
oken, které jsou na terminálu zobrazeny společně. Knihovna <i>tcell</i> sice
neumožňuje plnohodnotnou práci s&nbsp;takovými okny (ve smyslu, že by každé
takové okno bylo samostatnou strukturou s&nbsp;vlastními událostmi atd.), ale
můžeme se alespoň pokusit o vykreslení okrajů okna &ndash; což je ostatně
přesně ten způsob, který je využívaný v&nbsp;nástrojích <i>lazygit</i>,
<i>lazynpm</i> atd. V&nbsp;dalším demonstračním příkladu je okno vykresleno ve
funkci <strong>drawBox</strong>. Povšimněte si, že knihovna <i>tcell</i>
obsahuje i konstanty s&nbsp;těmi nejpoužívanějšími znaky (<i>runes</i>), mezi
něž patří mj.&nbsp;i Unicode znaky pro okraje oken:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "log"
&nbsp;
        tcell "github.com/gdamore/tcell/v2"
)
&nbsp;
func drawText(s tcell.Screen, x1, y1, x2, y2 int, style tcell.Style, text string) {
        row := y1
        column := x1
        for _, r := range []rune(text) {
                s.SetContent(col, row, r, nil, style)
                col++
                if column &gt;= x2 {
                        row++
                        column = x1
                }
                if row &gt; y2 {
                        break
                }
        }
}
&nbsp;
func drawBox(s tcell.Screen, x1, y1, x2, y2 int, style tcell.Style, text string) {
        if y2 &lt; y1 {
                y1, y2 = y2, y1
        }
        if x2 &lt; x1 {
                x1, x2 = x2, x1
        }
&nbsp;
        // Fill background
        for row := y1; row &lt;= y2; row++ {
                for column := x1; column &lt;= x2; col++ {
                        s.SetContent(col, row, ' ', nil, style)
                }
        }
&nbsp;
        // Draw borders
        for column := x1; column &lt;= x2; col++ {
                s.SetContent(col, y1, tcell.RuneHLine, nil, style)
                s.SetContent(col, y2, tcell.RuneHLine, nil, style)
        }
        for row := y1 + 1; row &lt; y2; row++ {
                s.SetContent(x1, row, tcell.RuneVLine, nil, style)
                s.SetContent(x2, row, tcell.RuneVLine, nil, style)
        }
&nbsp;
        // Only draw corners if necessary
        if y1 != y2 &amp;&amp; x1 != x2 {
                s.SetContent(x1, y1, tcell.RuneULCorner, nil, style)
                s.SetContent(x2, y1, tcell.RuneURCorner, nil, style)
                s.SetContent(x1, y2, tcell.RuneLLCorner, nil, style)
                s.SetContent(x2, y2, tcell.RuneLRCorner, nil, style)
        }
&nbsp;
        drawText(s, x1+1, y1+1, x2-1, y2-1, style, text)
}
&nbsp;
func drawBoxAroundScreen(screen tcell.Screen, style tcell.Style) {
        const offset = 5
        xmax, ymax := screen.Size()
        drawBox(screen, offset, offset, xmax-offset, ymax-offset, style, fmt.Sprintf("[%d, %d]", xmax, ymax))
}
&nbsp;
func <strong>main</strong>() {
        defStyle := tcell.StyleDefault.Background(tcell.ColorBlack).Foreground(tcell.ColorReset)
        boxStyle := tcell.StyleDefault.Foreground(tcell.ColorWhite).Background(tcell.ColorDarkBlue)
&nbsp;
        screen, err := tcell.NewScreen()
        if err != nil {
                log.Fatalf("%+v", err)
        }
&nbsp;
        err = screen.Init()
        if err != nil {
                log.Fatalf("%+v", err)
        }
&nbsp;
        screen.SetStyle(defStyle)
        screen.Clear()
        drawBoxAroundScreen(screen, boxStyle)
&nbsp;
        quit := func() {
                maybePanic := recover()
                screen.Fini()
                if maybePanic != nil {
                        panic(maybePanic)
                }
        }
        defer quit()
&nbsp;
        for {
                screen.Show()
&nbsp;
                ev := screen.PollEvent()
&nbsp;
                switch ev := ev.(type) {
                case *tcell.EventResize:
                        //screen.Sync()
                        screen.Clear()
                        drawBoxAroundScreen(screen, boxStyle)
                case *tcell.EventKey:
                        if ev.Key() == tcell.KeyEscape || ev.Key() == tcell.KeyCtrlC {
                                return
                        } else if ev.Rune() == 'C' || ev.Rune() == 'c' {
                                screen.Clear()
                        }
                }
        }
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Kreslení na plochu terminálu s&nbsp;využitím myši</h2>

<p></p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
&nbsp;
        tcell "github.com/gdamore/tcell/v2"
)
&nbsp;
func drawStar(s tcell.Screen, x, y int, style tcell.Style) {
        s.SetContent(x, y, '*', nil, style)
}
&nbsp;
func <strong>main</strong>() {
        defStyle := tcell.StyleDefault.Background(tcell.ColorBlack).Foreground(tcell.ColorReset)
        starStyle := tcell.StyleDefault.Foreground(tcell.ColorRed).Background(tcell.ColorBlack)
&nbsp;
        screen, err := tcell.NewScreen()
        if err != nil {
                log.Fatalf("%+v", err)
        }
&nbsp;
        err = screen.Init()
        if err != nil {
                log.Fatalf("%+v", err)
        }
&nbsp;
        screen.EnableMouse()
        screen.SetStyle(defStyle)
        screen.Clear()
&nbsp;
        quit := func() {
                maybePanic := recover()
                screen.Fini()
                if maybePanic != nil {
                        panic(maybePanic)
                }
        }
        defer quit()
&nbsp;
        for {
                screen.Show()
&nbsp;
                ev := screen.PollEvent()
&nbsp;
                switch ev := ev.(type) {
                case *tcell.EventResize:
                        screen.Sync()
                case *tcell.EventKey:
                        if ev.Key() == tcell.KeyEscape || ev.Key() == tcell.KeyCtrlC {
                                return
                        } else if ev.Rune() == 'C' || ev.Rune() == 'c' {
                                screen.Clear()
                        }
                case *tcell.EventMouse:
                        if ev.Buttons() == tcell.Button1 {
                                x, y := ev.Position()
                                drawStar(screen, x, y, starStyle)
                        }
&nbsp;
                }
        }
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Podporované styly zpráv vypisovaných na plochu terminálu</h2>

<pre>
package <strong>main</strong>

import (
        "log"

        tcell "github.com/gdamore/tcell/v2"
)

func drawText(s tcell.Screen, x1, y1, x2, y2 int, style tcell.Style, text string) {
        row := y1
        column := x1
        for _, r := range []rune(text) {
                s.SetContent(column, row, r, nil, style)
                column++
                if column &gt;= x2 {
                        row++
                        column = x1
                }
                if row &gt; y2 {
                        break
                }
        }
}

func <strong>main</strong>() {
        screen, err := tcell.NewScreen()
        if err != nil {
                log.Fatalf("%+v", err)
        }

        err = screen.Init()
        if err != nil {
                log.Fatalf("%+v", err)
        }

        screen.SetStyle(tcell.StyleDefault)
        screen.Clear()

        style := tcell.StyleDefault
        drawText(screen, 5, 1, 30, 1, style, "Normal text")
        drawText(screen, 5, 2, 30, 2, style.Bold(true), "Bold text")
        drawText(screen, 5, 3, 30, 3, style.Italic(true), "Italic text")
        drawText(screen, 5, 4, 30, 4, style.Underline(true), "Underline text")
        drawText(screen, 5, 5, 30, 5, style.StrikeThrough(true), "Strike through text")
        drawText(screen, 5, 6, 30, 6, style.Blink(true), "Blink")
        drawText(screen, 5, 7, 30, 7, style.Reverse(true), "Reverse")
        drawText(screen, 5, 8, 30, 8, style.Url("https://www.root.cz"), "https://www.root.cz")

        defer func() {
                screen.Fini()
        }()

        for {
                screen.Show()

                event := screen.PollEvent()

                switch ev := event.(type) {
                case *tcell.EventResize:
                        screen.Sync()
                case *tcell.EventKey:
                        if ev.Key() == tcell.KeyEscape || ev.Key() == tcell.KeyCtrlC {
                                return
                        } else if ev.Rune() == 'C' || ev.Rune() == 'c' {
                                screen.Clear()
                        }
                }
        }
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Standardní barvová paleta terminálů (a její nedodržování)</h2>

<p>Barvu popředí (znaků) či pozadí lze vybírat ze standardní palety, která
obsahuje šestnáct barev s&nbsp;indexy 0 až 15, které jsou doplněny o několik
odstínů šedi. Mnohé terminály ovšem mají barvovou paletu větší, například se
setkáme s&nbsp;88 barvami v&nbsp;paletě (<i>xterm</i>), 256 barvami atd. (a
několik terminálů naopak podporuje jen osm barev). Barvu znaku můžeme nastavit
následovně (za <i>i</i> se volí index příslušné barvy):</p>

<pre>
package <strong>main</strong>

import (
        "fmt"
        "log"

        tcell "github.com/gdamore/tcell/v2"
)

func drawText(s tcell.Screen, x1, y1, x2, y2 int, style tcell.Style, text string) {
        row := y1
        column := x1
        for _, r := range []rune(text) {
                s.SetContent(column, row, r, nil, style)
                column++
                if column &gt;= x2 {
                        row++
                        column = x1
                }
                if row &gt; y2 {
                        break
                }
        }
}

func <strong>main</strong>() {
        screen, err := tcell.NewScreen()
        if err != nil {
                log.Fatalf("%+v", err)
        }

        err = screen.Init()
        if err != nil {
                log.Fatalf("%+v", err)
        }

        screen.SetStyle(tcell.StyleDefault)
        screen.Clear()

        style := tcell.StyleDefault
        for i := 0; i &lt; 16; i++ {
                s := style.Foreground(tcell.PaletteColor(i))
                msg := fmt.Sprintf("Color #%d", i)
                drawText(screen, 5, i, 30, i, s, msg)
        }

        defer func() {
                screen.Fini()
        }()

        for {
                screen.Show()

                event := screen.PollEvent()

                switch ev := event.(type) {
                case *tcell.EventResize:
                        screen.Sync()
                case *tcell.EventKey:
                        if ev.Key() == tcell.KeyEscape || ev.Key() == tcell.KeyCtrlC {
                                return
                        } else if ev.Rune() == 'C' || ev.Rune() == 'c' {
                                screen.Clear()
                        }
                }
        }
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Světlý vs.&nbsp;tmavý text na ploše terminálu</h2>

<p>S&nbsp;barvami do jisté míry souvisí i poslední textový atribut, který jsme
si zatím nepopsali. Tento atribut se jmenuje <i>dim</i> a umožňuje snížit
intenzitu barvy textu. Pokud namísto volání:</p>

<pre>
package <strong>main</strong>

<p>Vše si pochopitelně můžeme vyzkoušet i prakticky:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "log"

        tcell "github.com/gdamore/tcell/v2"
)

func drawText(s tcell.Screen, x1, y1, x2, y2 int, style tcell.Style, text string) {
        row := y1
        column := x1
        for _, r := range []rune(text) {
                s.SetContent(column, row, r, nil, style)
                column++
                if column &gt;= x2 {
                        row++
                        column = x1
                }
                if row &gt; y2 {
                        break
                }
        }
}

func <strong>main</strong>() {
        screen, err := tcell.NewScreen()
        if err != nil {
                log.Fatalf("%+v", err)
        }

        err = screen.Init()
        if err != nil {
                log.Fatalf("%+v", err)
        }

        screen.SetStyle(tcell.StyleDefault)
        screen.Clear()

        style := tcell.StyleDefault
        for i := 0; i &lt; 16; i++ {
                s := style.Background(tcell.PaletteColor(i))
                msg := fmt.Sprintf("Color #%d", i)
                drawText(screen, 5, i, 30, i, s, msg)
        }

        for i := 0; i &lt; 16; i++ {
                s := style.Background(tcell.PaletteColor(i)).Dim(true)
                msg := fmt.Sprintf("Color #%d", i)
                drawText(screen, 55, i, 75, i, s, msg)
        }

        defer func() {
                screen.Fini()
        }()

        for {
                screen.Show()

                event := screen.PollEvent()

                switch ev := event.(type) {
                case *tcell.EventResize:
                        screen.Sync()
                case *tcell.EventKey:
                        if ev.Key() == tcell.KeyEscape || ev.Key() == tcell.KeyCtrlC {
                                return
                        } else if ev.Rune() == 'C' || ev.Rune() == 'c' {
                                screen.Clear()
                        }
                }
        }
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Specifikace 24bitové barvy popředí (textů)</h2>

<p>V&nbsp;předchozích kapitolách jsme si řekli, že textové terminály většinou
podporují osm, šestnáct, 88, 256 popř.&nbsp;2<sup>24</sup> barev
(<strong>xterm</strong> pak 4096 barev, ovšem ve výchozím nastavení jen 88
barev). Knihovna <i>tcell</i> dokáže pracovat s&nbsp;celým barvovým spektrem,
tedy s&nbsp;oněmi více než šestnácti miliony barvových odstínů. Záleží pak na
konkrétním textovém terminálu, zda dokáže všechny barvy zobrazit nebo například
provede převod na nejbližší barvu z&nbsp;palety 4096 odstínů. Pro převod
vlastní barvy (reprezentované v&nbsp;barvovém prostoru RGB) na příslušný řídicí
kód (escape sekvenci) slouží funkce nazvaná <strong>NewRGBColor</strong>. Tato
funkce je použita v&nbsp;dalším demonstračním příkladu, v&nbsp;němž se pokusíme
zobrazit text s&nbsp;proměnlivou barvou popředí:</p>

<img src="https://i.iinfo.cz/images/427/tcell4-4.png" class="image-1101549" width="660" height="437" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 24: Část výstupu produkovaného demonstračním příkladem
z&nbsp;této kapitoly.</i></p>

<p>Úplný zdrojový kód demonstračního příkladu, který vykreslil text tak, jak je
patrný na obrázku číslo 24, vypadá takto:</p>

<pre>
package <strong>main</strong>

import (
        "fmt"
        "log"

        tcell "github.com/gdamore/tcell/v2"
)

func drawText(s tcell.Screen, x1, y1, x2, y2 int, style tcell.Style, text string) {
        row := y1
        column := x1
        for _, r := range []rune(text) {
                s.SetContent(column, row, r, nil, style)
                column++
                if column &gt;= x2 {
                        row++
                        column = x1
                }
                if row &gt; y2 {
                        break
                }
        }
}

func drawPalette(screen tcell.Screen, green int32, offset int) {
        style := tcell.StyleDefault
        for j := 0; j &lt; 16; j++ {
                for i := 0; i &lt; 16; i++ {
                        color := tcell.NewRGBColor(int32(i&lt;&lt;4), green, int32(j&lt;&lt;4))
                        s := style.Foreground(tcell.Color(color))
                        msg := fmt.Sprintf(" %02x%02x%02x ", i, green, j)
                        drawText(screen, i*10, j+offset, i*10+8, j+offset, s, msg)
                }
        }
}

func <strong>main</strong>() {
        screen, err := tcell.NewScreen()
        if err != nil {
                log.Fatalf("%+v", err)
        }

        err = screen.Init()
        if err != nil {
                log.Fatalf("%+v", err)
        }

        screen.SetStyle(tcell.StyleDefault)
        screen.Clear()

        defer func() {
                screen.Fini()
        }()

        drawPalette(screen, 0, 1)
        drawPalette(screen, 255, 20)

        for {
                screen.Show()

                event := screen.PollEvent()

                switch ev := event.(type) {
                case *tcell.EventResize:
                        screen.Sync()
                case *tcell.EventKey:
                        if ev.Key() == tcell.KeyEscape || ev.Key() == tcell.KeyCtrlC {
                                return
                        } else if ev.Rune() == 'C' || ev.Rune() == 'c' {
                                screen.Clear()
                        }
                }
        }
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Specifikace 24bitové barvy pozadí</h2>

<p>Z&nbsp;celého barvového spektra s&nbsp;šestnácti miliony barvových odstínů
je možné vybrat i barvu pozadí (<i>background</i>) znaků, což je ukázáno
v&nbsp;dalším, dnes již předposledním, demonstračním příkladu (obecně platí, že
terminály, které dokážou zobrazit 24bitové barvy popředí, podporují i 24bitové
barvy pozadí):</p>

<img src="https://i.iinfo.cz/images/427/tcell4-5.png" class="image-1101550" width="660" height="437" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 25: Část výstupu produkovaného demonstračním příkladem
z&nbsp;této kapitoly.</i></p>

<p>Opět si ukažme celý zdrojový kód příkladu, který vyprodukuje tento
výstup:</p>

<pre>
package <strong>main</strong>

import (
        "fmt"
        "log"

        tcell "github.com/gdamore/tcell/v2"
)

func drawText(s tcell.Screen, x1, y1, x2, y2 int, style tcell.Style, text string) {
        row := y1
        column := x1
        for _, r := range []rune(text) {
                s.SetContent(column, row, r, nil, style)
                column++
                if column &gt;= x2 {
                        row++
                        column = x1
                }
                if row &gt; y2 {
                        break
                }
        }
}

func drawPalette(screen tcell.Screen, green int32, offset int) {
        style := tcell.StyleDefault
        for j := 0; j &lt; 16; j++ {
                for i := 0; i &lt; 16; i++ {
                        color := tcell.NewRGBColor(int32(i&lt;&lt;4), green, int32(j&lt;&lt;4))
                        s := style.Background(tcell.Color(color))
                        msg := fmt.Sprintf(" %02x%02x%02x ", i, green, j)
                        drawText(screen, i*10, j+offset, i*10+8, j+offset, s, msg)
                }
        }
}

func <strong>main</strong>() {
        screen, err := tcell.NewScreen()
        if err != nil {
                log.Fatalf("%+v", err)
        }

        err = screen.Init()
        if err != nil {
                log.Fatalf("%+v", err)
        }

        screen.SetStyle(tcell.StyleDefault)
        screen.Clear()

        defer func() {
                screen.Fini()
        }()

        drawPalette(screen, 0, 1)
        drawPalette(screen, 255, 20)

        for {
                screen.Show()

                event := screen.PollEvent()

                switch ev := event.(type) {
                case *tcell.EventResize:
                        screen.Sync()
                case *tcell.EventKey:
                        if ev.Key() == tcell.KeyEscape || ev.Key() == tcell.KeyCtrlC {
                                return
                        } else if ev.Rune() == 'C' || ev.Rune() == 'c' {
                                screen.Clear()
                        }
                }
        }
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Změna stylu zobrazení textového kurzoru na vybraných terminálech</h2>

<p>Poslední vlastností, která je ovšem podporována pouze některými textovými
terminály, je schopnost programově změnit tvar textového kurzoru.
K&nbsp;dispozici je několik možných tvarů a vlastností textového kurzoru, ovšem
&ndash; podobně jako v&nbsp;případě barev &ndash; i zde platí, že do značné
míry záleží na konfiguraci konkrétního terminálu a v&nbsp;neposlední řadě i na
jeho reálných schopnostech (textový terminál na PC například nedokáže zobrazit
kurzor ve tvaru vertikálního I, protože to neumožňuje jeho hardware).
Samostatnou kapitolou je pak automatická změna tvaru kurzoru ve chvíli, kdy
terminál ztratí fokus. Nicméně i přes tyto potenciální nedostatky je možné si
vybrat z&nbsp;následujících tvarů kurzoru:</p>

<ul>
<li>Blokový kurzor</li>
<li>Blikající blokový kurzor</li>
<li>Kurzor ve tvaru horizontálního podtržení (_)</li>
<li>Blikající kurzor ve tvaru horizontálního podtržení (_)</li>
<li>Kurzor ve tvaru I</li>
<li>Blikající kurzor ve tvaru I</li>
</ul>

<p>Výsledky mohou vypadat následovně (v&nbsp;příkladu se kurzory přepínají
klávesami <strong>1</strong> až <strong>6</strong>):</p>

<img src="https://i.iinfo.cz/images/427/tcell4-6.png" class="image-1101551" width="660" height="437" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 26: Blokový kurzor (xfce4-terminal).</i></p>

<img src="https://i.iinfo.cz/images/427/tcell4-7.png" class="image-1101552" width="660" height="437" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 27: Horizontální kurzor (xfce4-terminal).</i></p>

<img src="https://i.iinfo.cz/images/427/tcell4-8.png" class="image-1101553" width="660" height="437" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 28: Vertikální kurzor (xfce4-terminal).</i></p>

<a href="https://www.root.cz/obrazek/1101554/"><img src="https://i.iinfo.cz/images/427/tcell4-9-prev.png" class="image-1101554" width="370" height="241" data-prev-filename="https://i.iinfo.cz/images/427/tcell4-9-prev.png" data-prev-width="370" data-prev-height="241" data-large-filename="https://i.iinfo.cz/images/427/tcell4-9-large.png" data-large-width="720" data-large-height="468" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 29: Blokový kurzor (xterm).</i></p>

<a href="https://www.root.cz/obrazek/1101555/"><img src="https://i.iinfo.cz/images/427/tcell4-10-prev.png" class="image-1101555" width="370" height="241" data-prev-filename="https://i.iinfo.cz/images/427/tcell4-10-prev.png" data-prev-width="370" data-prev-height="241" data-large-filename="https://i.iinfo.cz/images/427/tcell4-10-large.png" data-large-width="720" data-large-height="468" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 30: Horizontální kurzor (xterm).</i></p>

<a href="https://www.root.cz/obrazek/1101556/"><img src="https://i.iinfo.cz/images/427/tcell4-11-prev.png" class="image-1101556" width="370" height="241" data-prev-filename="https://i.iinfo.cz/images/427/tcell4-11-prev.png" data-prev-width="370" data-prev-height="241" data-large-filename="https://i.iinfo.cz/images/427/tcell4-11-large.png" data-large-width="720" data-large-height="468" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 31: Vertikální kurzor (xterm).</i></p>

<p>A pochopitelně si na závěr ukažme úplný zdrojový kód dnešního posledního
demonstračního příkladu:</p>

<pre>
package <strong>main</strong>

import (
        "log"

        tcell "github.com/gdamore/tcell/v2"
)

func <strong>main</strong>() {
        screen, err := tcell.NewScreen()
        if err != nil {
                log.Fatalf("%+v", err)
        }

        err = screen.Init()
        if err != nil {
                log.Fatalf("%+v", err)
        }

        screen.SetStyle(tcell.StyleDefault)
        screen.Clear()
        screen.ShowCursor(10, 5)

        defer func() {
                screen.Fini()
        }()

        for {
                screen.Show()

                event := screen.PollEvent()

                switch ev := event.(type) {
                case *tcell.EventResize:
                        screen.Sync()
                case *tcell.EventKey:
                        switch ev.Key() {
                        case tcell.KeyEscape:
                                fallthrough
                        case tcell.KeyCtrlC:
                                return
                        }
                        switch ev.Rune() {
                        case 'C':
                                fallthrough
                        case 'c':
                                screen.Clear()
                        case '1':
                                screen.SetCursorStyle(tcell.CursorStyleBlinkingBlock)
                        case '2':
                                screen.SetCursorStyle(tcell.CursorStyleSteadyBlock)
                        case '3':
                                screen.SetCursorStyle(tcell.CursorStyleBlinkingUnderline)
                        case '4':
                                screen.SetCursorStyle(tcell.CursorStyleSteadyUnderline)
                        case '5':
                                screen.SetCursorStyle(tcell.CursorStyleBlinkingBar)
                        case '6':
                                screen.SetCursorStyle(tcell.CursorStyleSteadyBar)
                        }
                }
        }
}
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů naprogramovaných
v&nbsp;jazyku Go byly uloženy do Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář, můžete namísto toho
použít odkazy na jednotlivé demonstrační příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad/soubor</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>03_simple_input.go</td><td>vstupní příkazový řádek realizovaný balíčkem <strong>go-prompt</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_20/03_simple_input.go">https://github.com/tisnik/go-root/blob/master/article_20/03_simple_input.go</a></td></tr>
<tr><td> 2</td><td>04_prompt.go</td><td>vstupní příkazový řádek s&nbsp;historií</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_20/04_prompt.go">https://github.com/tisnik/go-root/blob/master/article_20/04_prompt.go</a></td></tr>
<tr><td> 3</td><td>05_basic_completer.go</td><td>nabízení slov/příkazů pro automatické doplnění</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_20/05_basic_completer.go">https://github.com/tisnik/go-root/blob/master/article_20/05_basic_completer.go</a></td></tr>
<tr><td> 4</td><td>06_prefix_completer.go</td><td>vylepšení automatického doplňování příkazů</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_20/06_prefix_completer.go">https://github.com/tisnik/go-root/blob/master/article_20/06_prefix_completer.go</a></td></tr>
<tr><td> 5</td><td>07_completion_description.go</td><td>popis jednotlivých příkazů zobrazovaný uživateli</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_20/07_completion_description.go">https://github.com/tisnik/go-root/blob/master/article_20/07_completion_description.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>example_1.go</td><td>kostra programu, který dokáže vypsat obarvený text na terminál a reagovat na stisk kláves</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_AC/example_1.go">https://github.com/tisnik/go-root/blob/master/article_AC/example_1.go</a></td></tr>
<tr><td> 7</td><td>example_2.go</td><td>korektní ukončení programu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_AC/example_2.go">https://github.com/tisnik/go-root/blob/master/article_AC/example_2.go</a></td></tr>
<tr><td> 8</td><td>example_3.go</td><td>vykreslení okna do plochy terminálu, reakce na změnu velikosti terminálu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_AC/example_3.go">https://github.com/tisnik/go-root/blob/master/article_AC/example_3.go</a></td></tr>
<tr><td> 9</td><td>example_4.go</td><td>kreslení na plochu terminálu s&nbsp;využitím myši</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_AC/example_4.go">https://github.com/tisnik/go-root/blob/master/article_AC/example_4.go</a></td></tr>
<tr><td>10</td><td>example_5.go</td><td>podporované styly zpráv vypisovaných na plochu terminálu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_AC/example_5.go">https://github.com/tisnik/go-root/blob/master/article_AC/example_5.go</a></td></tr>
<tr><td>11</td><td>example_6.go</td><td>standardní barvová paleta terminálů (a její nedodržování)</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_AC/example_6.go">https://github.com/tisnik/go-root/blob/master/article_AC/example_6.go</a></td></tr>
<tr><td>12</td><td>example_7.go</td><td>světlý vs.&nbsp;tmavý text na ploše terminálu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_AC/example_7.go">https://github.com/tisnik/go-root/blob/master/article_AC/example_7.go</a></td></tr>
<tr><td>13</td><td>example_8.go</td><td>specifikace 24bitové barvy popředí (textů)</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_AC/example_8.go">https://github.com/tisnik/go-root/blob/master/article_AC/example_8.go</a></td></tr>
<tr><td>14</td><td>example_9.go</td><td>specifikace 24bitové barvy pozadí</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_AC/example_9.go">https://github.com/tisnik/go-root/blob/master/article_AC/example_9.go</a></td></tr>
<tr><td>15</td><td>example_A.go</td><td>změna stylu zobrazení textového kurzoru na vybraných terminálech</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_AC/example_A.go">https://github.com/tisnik/go-root/blob/master/article_AC/example_A.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Tvorba aplikací a her s&nbsp;textovým uživatelským rozhraním s&nbsp;využitím knihovny Blessed<br />
<a href="https://www.root.cz/clanky/tvorba-aplikaci-a-her-s-textovym-uzivatelskym-rozhranim-s-vyuzitim-knihovny-blessed/">https://www.root.cz/clanky/tvorba-aplikaci-a-her-s-textovym-uzivatelskym-rozhranim-s-vyuzitim-knihovny-blessed/</a>
</li>

<li>Tvorba aplikací a her s&nbsp;textovým rozhraním s&nbsp;knihovnou Blessed (dokončení)<br />
<a href="https://www.root.cz/clanky/tvorba-aplikaci-a-her-s-textovym-rozhranim-s-knihovnou-blessed-dokonceni/">https://www.root.cz/clanky/tvorba-aplikaci-a-her-s-textovym-rozhranim-s-knihovnou-blessed-dokonceni/</a>
</li>

<li>Text-Based User Interfaces<br />
<a href="https://appliedgo.net/tui/">https://appliedgo.net/tui/</a>
</li>

<li>PTerm: A powerful TUI framework written in Go<br />
<a href="https://pterm.sh/">https://pterm.sh/</a>
</li>

<li>termbox-go<br />
<a href="https://github.com/nsf/termbox-go">https://github.com/nsf/termbox-go</a>
</li>

<li>tcell<br />
<a href="https://github.com/gdamore/tcell">https://github.com/gdamore/tcell</a>
</li>

<li>termui<br />
<a href="https://github.com/gizak/termui">https://github.com/gizak/termui</a>
</li>

<li>GOCUI &ndash; Go Console User Interface<br />
<a href="https://github.com/jroimartin/gocui">https://github.com/jroimartin/gocui</a>
</li>

<li>Fork předešlého<br />
<a href="https://github.com/jesseduffield/gocui">https://github.com/jesseduffield/gocui</a>
</li>

<li>CLUI<br />
<a href="https://github.com/VladimirMarkelov/clui">https://github.com/VladimirMarkelov/clui</a>
</li>

<li>tview &ndash; Rich Interactive Widgets for Terminal UIs<br />
<a href="https://github.com/rivo/tview">https://github.com/rivo/tview</a>
</li>

<li>cview<br />
<a href="https://code.rocket9labs.com/tslocum/cview">https://code.rocket9labs.com/tslocum/cview</a>
</li>

<li>ANSI Escape Code &ndash; Colors<br />
<a href="https://en.wikipedia.org/wiki/ANSI_escape_code#Colors">https://en.wikipedia.org/wiki/ANSI_escape_code#Colors</a>
</li>

<li>A curated list of awesome Go frameworks, libraries and software<br />
<a href="https://awesome-go.com/">https://awesome-go.com/</a>
</li>

<li>Aurora<br />
<a href="https://github.com/logrusorgru/aurora">https://github.com/logrusorgru/aurora</a>
</li>

<li>colourize<br />
<a href="https://github.com/TreyBastian/colourize">https://github.com/TreyBastian/colourize</a>
</li>

<li>go-colortext<br />
<a href="https://github.com/daviddengcn/go-colortext">https://github.com/daviddengcn/go-colortext</a>
</li>

<li>blessed na PyPi<br />
<a href="https://pypi.org/project/blessed/">https://pypi.org/project/blessed/</a>
</li>

<li>blessed na GitHubu<br />
<a href="https://github.com/jquast/blessed">https://github.com/jquast/blessed</a>
</li>

<li>Blessed documentation!<br />
<a href="https://blessed.readthedocs.io/en/latest/">https://blessed.readthedocs.io/en/latest/</a>
</li>

<li>termbox-go na GitHubu<br />
<a href="https://github.com/nsf/termbox-go">https://github.com/nsf/termbox-go</a>
</li>

<li>termui na GitHubu<br />
<a href="https://github.com/gizak/termui">https://github.com/gizak/termui</a>
</li>

<li>blessed na GitHubu<br />
<a href="https://github.com/chjj/blessed">https://github.com/chjj/blessed</a>
</li>

<li>blessed-contrib na GitHubu<br />
<a href="https://github.com/yaronn/blessed-contrib">https://github.com/yaronn/blessed-contrib</a>
</li>

<li>tui-rs na GitHubu<br />
<a href="https://github.com/fdehau/tui-rs">https://github.com/fdehau/tui-rs</a>
</li>

<li>asciigraph<br />
<a href="https://github.com/guptarohit/asciigraph">https://github.com/guptarohit/asciigraph</a>
</li>

<li>Standardní balíček text/tabwriter<br />
<a href="https://golang.org/pkg/text/tabwriter/">https://golang.org/pkg/text/tabwriter/</a>
</li>

<li>Elastic tabstops: A better way to indent and align code<br />
<a href="https://nickgravgaard.com/elastic-tabstops/">https://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>ASCII Table Writer<br />
<a href="https://github.com/olekukonko/tablewriter">https://github.com/olekukonko/tablewriter</a>
</li>

<li>TablePrinter<br />
<a href="https://github.com/lensesio/tableprinter">https://github.com/lensesio/tableprinter</a>
</li>

<li>go-pretty<br />
<a href="https://github.com/jedib0t/go-pretty">https://github.com/jedib0t/go-pretty</a>
</li>

<li>cfmt<br />
<a href="https://github.com/mingrammer/cfmt">https://github.com/mingrammer/cfmt</a>
</li>

<li>box-cli-maker<br />
<a href="https://github.com/Delta456/box-cli-maker">https://github.com/Delta456/box-cli-maker</a>
</li>

<li>go-prompt<br />
<a href="https://github.com/c-bata/go-prompt">https://github.com/c-bata/go-prompt</a>
</li>

<li>lazygit<br />
<a href="https://github.com/jesseduffield/lazygit">https://github.com/jesseduffield/lazygit</a>
</li>

<li>lazydocker<br />
<a href="https://github.com/jesseduffield/lazydocker">https://github.com/jesseduffield/lazydocker</a>
</li>

<li>lazynpm<br />
<a href="https://github.com/jesseduffield/lazynpm">https://github.com/jesseduffield/lazynpm</a>
</li>

<li>Awesome TUIs &ndash; list of projects that provide terminal user interfaces<br />
<a href="https://github.com/rothgar/awesome-tuis">https://github.com/rothgar/awesome-tuis</a>
</li>

<li>fjira<br />
<a href="https://github.com/mk-5/fjira">https://github.com/mk-5/fjira</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

