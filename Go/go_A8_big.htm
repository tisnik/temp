<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V některých oblastech se vývojáři setkávají s takovými číselnými hodnotami, které nelze reprezentovat základními datovými typy (int, float, atd.). Z tohoto důvodu se v mnoha jazycích setkáme s podporou hodnot s neomezeným rozsahem či volitelnou přesností. Výjimkou není ani programovací jazyk Go.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Číselné hodnoty s&nbsp;neomezeným rozsahem a přesností v&nbsp;programovacím jazyku Go</a></p>
<p><a href="#k02">2. Datový typ <strong>big.Int</strong> &ndash; celá čísla s&nbsp;neomezeným rozsahem</a></p>
<p><a href="#k03">*** 3. Aritmetické operace prováděné s&nbsp;hodnotami typu <strong>big.Int</strong></a></p>
<p><a href="#k04">4. Výpočet faktoriálu s&nbsp;využitím datového typu <strong>big.Int</strong></a></p>
<p><a href="#k05">5. Převod hodnoty typu <strong>big.Int</strong> na text s&nbsp;volitelnou bází</a></p>
<p><a href="#k06">*** 6. Konstrukce hodnoty typu <strong>big.Int</strong> z&nbsp;řetězce</a></p>
<p><a href="#k07">*** 7. Interní struktura hodnot typu <strong>big.Int</strong></a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">18. Obsah navazujícího článku</a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Číselné hodnoty s&nbsp;neomezeným rozsahem a přesností v&nbsp;programovacím jazyku Go</h2>

<p>Jak již bylo napsáno v&nbsp;perexu tohoto článku, existují oblasti
(příkladem je šifrování), v&nbsp;nichž se využívají takové numerické hodnoty,
které není vhodné či dokonce vůbec možné reprezentovat s&nbsp;využitím
základních (primitivních) datových typů, mezi něž typicky patří celočíselný typ
či typy (různé varianty <strong>int</strong>) a typy numerických hodnot
s&nbsp;plovoucí řádovou čárkou (různé varianty <strong>float</strong>).
Z&nbsp;tohoto důvodu se v&nbsp;některých vyšších programovacích jazycích
setkáme s&nbsp;podporou takových datových typů, které umožňují reprezentovat
celočíselné hodnoty s&nbsp;libovolným rozsahem (to je případ Pythonu a jeho
typu <strong>int</strong>) popř.&nbsp;hodnoty s&nbsp;desetinnou tečkou, které
budou mít jak neomezený rozsah, tak i neomezenou (či volitelnou) přesnost
(podporováno v&nbsp;Clojure i mnoha implementacích Scheme a LISPu). To ovšem
není vše, protože se mnohdy setkáme i s&nbsp;datovým typem <i>zlomek</i>, kde
jak čitatel, tak i jmenovatel mají neomezený rozsah (opět podporováno
v&nbsp;Clojure, Scheme, LISPu a dalších vysokoúrovňových programovacích
jazycích).</p>

<p><div class="rs-tip-major">Poznámka: pojmem &bdquo;neomezená&ldquo; je
myšleno spíše &bdquo;prakticky neomezená&ldquo;, protože je zřejmé, že pro
uložení hodnoty se skutečně neomezeným rozsahem by bylo nutné použít paměť o
neomezené kapacitě. K&nbsp;tomuto závěru postačuje aplikovat <a
href="https://cs.wikipedia.org/wiki/Dirichlet%C5%AFv_princip">Dirichletův
princip</a> &ndash; paměť o omezeném počtu bitů <i>n</i> (ať je <i>n</i>
jakkoli velké, ale konečné) může být použita pouze pro uložení
<i>2<sup>n</sup></i> různých hodnot, a to nezávisle na způsobu jejich
reprezentace.</div></p>

<p>V&nbsp;dnešním článku se zaměříme na &bdquo;neomezené&ldquo; numerické
hodnoty a operaci pro práci s&nbsp;nimi, které jsou součástí ekosystému jazyka
Go. Ovšem již na tomto místě je pravděpodobně dobré upozornit na to, že podpora
dále popsaných numerických typů je v&nbsp;jazyku Go striktně omezena na
definici několika struktur a taktéž funkcí a metod určených pro práci
s&nbsp;těmito strukturami. Jinými slovy to znamená &ndash; v&nbsp;žádném
případě se nejedná o integrální součást jazyka a tudíž například není možné
sčítat dva zlomky s&nbsp;využitím standardního operátoru + nebo je porovnávat
operátorem &lt;. V&nbsp;tomto ohledu jsme narazili na omezení sémantiky
programovacího jazyka Go (tento jazyk neumožňuje přetěžovat operátory, nelze
definovat nové typy literálů/konstant a neexistuje zde podpora maker &ndash;
tedy alespoň prozatím).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Datový typ <strong>big.Int</strong> &ndash; celá čísla s&nbsp;neomezeným rozsahem</h2>

<p>Připomeňme si, že v&nbsp;programovacím jazyku Go mají vývojáři
k&nbsp;dispozici několik základních datových typů určených pro práci
s&nbsp;celými čísly, ať již se znaménkem, nebo bez znaménka. Jedná se o tyto
typy, přičemž <strong>int</strong> a <strong>uint</strong> jsou systémově
závislé aliasy:</p>

<table>
<tr><th>Identifikátor</th><th>Typ</th><th>Stručný popis</th></tr>
<tr><td>int</td><td>datový typ</td><td>odpovídá buď typu int32 nebo int64</td></tr> 
<tr><td>int8</td><td>datový typ</td><td>osmibitové celé číslo se znaménkem</td></tr> 
<tr><td>int16</td><td>datový typ</td><td>šestnáctibitové celé číslo se znaménkem</td></tr> 
<tr><td>int32</td><td>datový typ</td><td>32bitové celé číslo se znaménkem</td></tr> 
<tr><td>int64</td><td>datový typ</td><td>64bitové celé číslo se znaménkem</td></tr> 
<tr><td>uint</td><td>datový typ</td><td>odpovídá buď typu uint32 nebo uint64</td></tr> 
<tr><td>uint8</td><td>datový typ</td><td>osmibitové celé číslo bez znaménka</td></tr> 
<tr><td>uint16</td><td>datový typ</td><td>16bitové celé číslo bez znaménka</td></tr> 
<tr><td>uint32</td><td>datový typ</td><td>32bitové celé číslo bez znaménka</td></tr> 
<tr><td>uint64</td><td>datový typ</td><td>64bitové celé číslo bez znaménka</td></tr> 
</table>

<p>Práce s&nbsp;hodnotami těchto typů je většinou velmi rychlá, a to
z&nbsp;toho důvodu, že současné mikroprocesory operaci s&nbsp;celými čísly
typicky provedou přímo v&nbsp;aritmeticko-logické jednotce v&nbsp;několika
strojových cyklech (které se navíc překrývají s&nbsp;dalšími instrukcemi díky
instrukční pipeline). Ovšem mohou nastat situace, kdy nám ani rozsah typu
<strong>int64</strong> nebo <strong>uint64</strong> nebude dostačovat (a typ
<strong>long long</strong> není k&nbsp;dispozici).  V&nbsp;tomto případě je
možné využít možnosti poskytované standardním balíčkem
<strong>math/big</strong>, v&nbsp;němž se mj.&nbsp;nachází i specifikace nového
typu <strong>Int</strong>. Podívejme se nyní na způsob konstrukce hodnoty
<strong>big.Int</strong> z&nbsp;celých čísel a z&nbsp;převodu hodnoty
<strong>big.Int</strong> na textovou reprezentaci. Hodnota 10 ve volání metody
<strong>big.Int.Text</strong> určuje bázi, tj.&nbsp;o jakou číselnou soustavu
se jedná (k&nbsp;této problematice se ještě později vrátíme):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        var x big.Int
        var y big.Int
        x.SetInt64(1)
        y.SetInt64(2)
&nbsp;
        fmt.Println(x.Text(10))
        fmt.Println(y.Text(10))
}
</pre>

<p>Po překladu a spuštění tohoto demonstračního příkladu by se na standardním
výstupu měly objevit tyto dva řádky:</p>

<pre>
1
2
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Aritmetické operace prováděné s&nbsp;hodnotami typu <strong>big.Int</strong></h2>

<p></p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        var x big.Int
        var y big.Int
        x.SetInt64(1)
        y.SetInt64(2)
&nbsp;
        var z big.Int
        z.Add(&amp;x, &amp;y)
&nbsp;
        fmt.Println(x.Text(10))
        fmt.Println(y.Text(10))
        fmt.Println(z.Text(10))
}
</pre>

<p></p>

<pre>
1
2
3
</pre>

<p></p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        var x big.Int
        x.SetInt64(2)
&nbsp;
        var z big.Int
        z.SetInt64(1)
&nbsp;
        for i := 0; i &lt; 100; i++ {
                z.Mul(&amp;z, &amp;x)
                fmt.Println(z.Text(10))
        }
}
</pre>

<p></p>

<pre>
2
4
8
16
32
64
128
256
512
1024
2048
4096
8192
16384
32768
65536
131072
262144
...
...
...
1152921504606846976
2305843009213693952
4611686018427387904
9223372036854775808
18446744073709551616
36893488147419103232
73786976294838206464
147573952589676412928
295147905179352825856
590295810358705651712
1180591620717411303424
2361183241434822606848
4722366482869645213696
9444732965739290427392
18889465931478580854784
37778931862957161709568
75557863725914323419136
151115727451828646838272
302231454903657293676544
604462909807314587353088
1208925819614629174706176
2417851639229258349412352
4835703278458516698824704
9671406556917033397649408
19342813113834066795298816
38685626227668133590597632
77371252455336267181195264
154742504910672534362390528
309485009821345068724781056
618970019642690137449562112
1237940039285380274899124224
2475880078570760549798248448
4951760157141521099596496896
9903520314283042199192993792
19807040628566084398385987584
39614081257132168796771975168
79228162514264337593543950336
158456325028528675187087900672
316912650057057350374175801344
633825300114114700748351602688
1267650600228229401496703205376
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výpočet faktoriálu s&nbsp;využitím datového typu <strong>big.Int</strong></h2>

<p>S&nbsp;celými čísly o prakticky neomezeném rozsahu můžeme provádět všechny
základní aritmetické operace; pouze nesmíme zapomenout na to, že se nezapisují
s&nbsp;využitím operátorů +, -, *, / a %, ale příslušnými metodami popsanými na
stránce <a
href="https://golang.org/pkg/math/big/#Int">https://golang.org/pkg/math/big/#Int</a>.
Taktéž porovnání dvou hodnot se neprovádí standardní šesticí relačních
operátorů, ale metodou <strong>Int.Cmp</strong>. Pro zajímavost si ukažme,
jakým způsobem je možné implementovat funkci pro výpočet faktoriálu pro
libovolné kladné <i>n</i>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>factorial</strong>(n *big.Int) *big.Int {
        one := big.NewInt(1)
        if n.Cmp(big.NewInt(0)) &lt;= 0 {
                return one
        }
        return one.Mul(n, factorial(one.Sub(n, one)))
}
&nbsp;
func <strong>main</strong>() {
        for n := int64(1); n &lt; 80; n++ {
                f := factorial(big.NewInt(n))
                fmt.Printf("%3d! = %s\n", n, f.Text(10))
        }
}
</pre>

<p>Z&nbsp;výsledků je patrné, že skutečně nejsme omezení klasickými datovými
typy <strong>uint64</strong> atd.:</p>

<pre>
  1! = 1
  2! = 2
  3! = 6
  4! = 24
  5! = 120
  6! = 720
  7! = 5040
  8! = 40320
  9! = 362880
 10! = 3628800
 11! = 39916800
 12! = 479001600
 13! = 6227020800
 14! = 87178291200
 15! = 1307674368000
 16! = 20922789888000
 17! = 355687428096000
 18! = 6402373705728000
 19! = 121645100408832000
 20! = 2432902008176640000
 21! = 51090942171709440000
 22! = 1124000727777607680000
 23! = 25852016738884976640000
 24! = 620448401733239439360000
 25! = 15511210043330985984000000
 26! = 403291461126605635584000000
 27! = 10888869450418352160768000000
 28! = 304888344611713860501504000000
 29! = 8841761993739701954543616000000
 30! = 265252859812191058636308480000000
 31! = 8222838654177922817725562880000000
 32! = 263130836933693530167218012160000000
 33! = 8683317618811886495518194401280000000
 34! = 295232799039604140847618609643520000000
 35! = 10333147966386144929666651337523200000000
 36! = 371993326789901217467999448150835200000000
 37! = 13763753091226345046315979581580902400000000
 38! = 523022617466601111760007224100074291200000000
 39! = 20397882081197443358640281739902897356800000000
 40! = 815915283247897734345611269596115894272000000000
 41! = 33452526613163807108170062053440751665152000000000
 42! = 1405006117752879898543142606244511569936384000000000
 43! = 60415263063373835637355132068513997507264512000000000
 44! = 2658271574788448768043625811014615890319638528000000000
 45! = 119622220865480194561963161495657715064383733760000000000
 46! = 5502622159812088949850305428800254892961651752960000000000
 47! = 258623241511168180642964355153611979969197632389120000000000
 48! = 12413915592536072670862289047373375038521486354677760000000000
 49! = 608281864034267560872252163321295376887552831379210240000000000
 50! = 30414093201713378043612608166064768844377641568960512000000000000
 51! = 1551118753287382280224243016469303211063259720016986112000000000000
 52! = 80658175170943878571660636856403766975289505440883277824000000000000
 53! = 4274883284060025564298013753389399649690343788366813724672000000000000
 54! = 230843697339241380472092742683027581083278564571807941132288000000000000
 55! = 12696403353658275925965100847566516959580321051449436762275840000000000000
 56! = 710998587804863451854045647463724949736497978881168458687447040000000000000
 57! = 40526919504877216755680601905432322134980384796226602145184481280000000000000
 58! = 2350561331282878571829474910515074683828862318181142924420699914240000000000000
 59! = 138683118545689835737939019720389406345902876772687432540821294940160000000000000
 60! = 8320987112741390144276341183223364380754172606361245952449277696409600000000000000
 61! = 507580213877224798800856812176625227226004528988036003099405939480985600000000000000
 62! = 31469973260387937525653122354950764088012280797258232192163168247821107200000000000000
 63! = 1982608315404440064116146708361898137544773690227268628106279599612729753600000000000000
 64! = 126886932185884164103433389335161480802865516174545192198801894375214704230400000000000000
 65! = 8247650592082470666723170306785496252186258551345437492922123134388955774976000000000000000
 66! = 544344939077443064003729240247842752644293064388798874532860126869671081148416000000000000000
 67! = 36471110918188685288249859096605464427167635314049524593701628500267962436943872000000000000000
 68! = 2480035542436830599600990418569171581047399201355367672371710738018221445712183296000000000000000
 69! = 171122452428141311372468338881272839092270544893520369393648040923257279754140647424000000000000000
 70! = 11978571669969891796072783721689098736458938142546425857555362864628009582789845319680000000000000000
 71! = 850478588567862317521167644239926010288584608120796235886430763388588680378079017697280000000000000000
 72! = 61234458376886086861524070385274672740778091784697328983823014963978384987221689274204160000000000000000
 73! = 4470115461512684340891257138125051110076800700282905015819080092370422104067183317016903680000000000000000
 74! = 330788544151938641225953028221253782145683251820934971170611926835411235700971565459250872320000000000000000
 75! = 24809140811395398091946477116594033660926243886570122837795894512655842677572867409443815424000000000000000000
 76! = 1885494701666050254987932260861146558230394535379329335672487982961844043495537923117729972224000000000000000000
 77! = 145183092028285869634070784086308284983740379224208358846781574688061991349156420080065207861248000000000000000000
 78! = 11324281178206297831457521158732046228731749579488251990048962825668835325234200766245086213177344000000000000000000
 79! = 894618213078297528685144171539831652069808216779571907213868063227837990693501860533361810841010176000000000000000000
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Převod hodnoty typu <strong>big.Int</strong> na text s&nbsp;volitelnou bází</h2>

<p>V&nbsp;demonstračních příkladech jsme se již setkali s&nbsp;použitím metody
<strong>big.Int.Text</strong> určené pro převod numerické hodnoty na řetězec,
tj.&nbsp;na tisknutelný text. Této metodě se předává <i>báze</i>, což je základ
číselné soustavy, která se má pro tisk hodnoty použít. Podporovány jsou
soustavy se základy 2 až 62. Je tedy podporována dvojková, osmičková, desítková
i šestnáctková soustava (pokud máme jmenovat ty nejpoužívanější báze). Soustavy
se základem vyšším než 10 používají jak numerické cifry, tak i znaky malé
abecedy a poté i abecedy velké. Jednotlivé cifry jsou tedy reprezentovány
těmito znaky:</p>

<pre>
0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
</pre>

<p>Můžeme si to snadno otestovat &ndash; necháme i vytisknout jednu hodnotu
100000000000 (desítkově), ovšem postupně s&nbsp;použitím všech podporovaných
bází:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        var x big.Int
        x.SetInt64(10000000000)
&nbsp;
        for base := 2; base &lt;= 62; base++ {
                fmt.Println(base, x.Text(base))
        }
}
</pre>

<p>Výsledek by měl vypadat následovně:</p>

<pre>
2 1001010100000010111110010000000000
3 221210220202122010101
4 21110002332100000
5 130440000000000
6 4332142412144
7 502544411644
8 112402762000
9 27726678111
10 10000000000
11 4271815011
12 1b30b91054
13 c349ba483
14 6ac162c24
15 3d7dace6a
16 2540be400
17 1764g6422
18 g603fb9a
19 b3abb909
20 7g500000
21 5bcaikk4
22 40487b0c
23 2lcfd6fg
24 247kjf2g
25 1fo00000
26 169gphag
27 plokh3a
28 kl17a14
29 gnfiqc6
30 dlfkb3a
31 b893q85
32 9a0np00
33 7oh8of1
34 6g35112
35 5fdv5ap
36 4ldqpds
37 3x7qoxa
38 3c7wbss
39 2wwm1Bg
40 2hqa000
41 24czqE1
42 1ylsqa4
43 1p103zn
44 1gs0Fbc
45 198tgra
46 12piFGg
47 HseAcl
48 DbClBg
49 zjwtdw
50 w00000
51 sO7E6j
52 qfzAIg
53 nMisEf
54 lG2vfa
55 jLJa6J
56 i8Knsw
57 gziF6s
58 fdCzz6
59 dWfrGp
60 cPAhKE
61 bPexBe
62 aUKYOA
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Interní struktura hodnot typu <strong>big.Int</strong></h2>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        var x big.Int
        x.SetInt64(100000000)
&nbsp;
        fmt.Println(x.Bytes())
}
</pre>

<pre>
[5 245 225 0]
</pre>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        var x big.Int
        x.SetInt64(100000000000)
        x.Mul(&amp;x, &amp;x)
&nbsp;
        fmt.Println(x.Bits())
&nbsp;
        words := x.Bits()
        words[0] = 1
        words[1] = 0
&nbsp;
        fmt.Println(x.Bits())
        fmt.Println(x.Text(10))
&nbsp;
        words[0] = 0
        words[1] = 1
&nbsp;
        fmt.Println(x.Bits())
        fmt.Println(x.Text(10))
}
</pre>

<pre>
[1864712049423024128 542]
[1 0]
1
[0 1]
18446744073709551616
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "math/big"
)
&nbsp;
func <strong>main</strong>() {
        var x big.Int
        x.SetInt64(0)
&nbsp;
        fmt.Println(x.Bytes())
        fmt.Println(x.Text(10))
        fmt.Println()
&nbsp;
        x.SetBytes([]byte{})
        fmt.Println(x.Bytes())
        fmt.Println(x.Text(10))
        fmt.Println()
&nbsp;
        x.SetBytes([]byte{1, 0})
        fmt.Println(x.Bytes())
        fmt.Println(x.Text(10))
        fmt.Println()
&nbsp;
        x.SetBytes([]byte{1, 0, 0})
        fmt.Println(x.Bytes())
        fmt.Println(x.Text(10))
        fmt.Println()
&nbsp;
        x.SetBytes([]byte{1, 0, 0, 0})
        fmt.Println(x.Bytes())
        fmt.Println(x.Text(10))
        fmt.Println()
&nbsp;
        x.SetBytes([]byte{1, 0, 0, 0, 0})
        fmt.Println(x.Bytes())
        fmt.Println(x.Text(10))
        fmt.Println()
&nbsp;
        x.SetBytes([]byte{1, 0, 0, 0, 0, 0})
        fmt.Println(x.Bytes())
        fmt.Println(x.Text(10))
        fmt.Println()
&nbsp;
        x.SetBytes([]byte{1, 0, 0, 0, 0, 0, 0})
        fmt.Println(x.Bytes())
        fmt.Println(x.Text(10))
        fmt.Println()
&nbsp;
        x.SetBytes([]byte{1, 0, 0, 0, 0, 0, 0, 0})
        fmt.Println(x.Bytes())
        fmt.Println(x.Text(10))
        fmt.Println()
}
</pre>

<pre>
[]
0
&nbsp;
[]
0
&nbsp;
[1 0]
256
&nbsp;
[1 0 0]
65536
&nbsp;
[1 0 0 0]
16777216
&nbsp;
[1 0 0 0 0]
4294967296
&nbsp;
[1 0 0 0 0 0]
1099511627776
&nbsp;
[1 0 0 0 0 0 0]
281474976710656
&nbsp;
[1 0 0 0 0 0 0 0]
72057594037927936
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<p></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<p></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<p></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<p></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<p></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah navazujícího článku</h2>

<p>Prozatím jsme si popsali pouze dva datové typy realizované ve standardní
knihovně <strong>big</strong>: <strong>big.Int</strong> a
<strong>big.Rat</strong>. Zbývá nám popis posledního typu, který je
programátorům ve standardní knihovně nabízený. Jedná se o typ pojmenovaný
<strong>big.Float</strong>, jenž programátorům umožňuje pracovat
s&nbsp;&bdquo;neomezenými&ldquo; hodnotami s&nbsp;plovoucí řádovou čárkou. To
ovšem není vše, protože i pro programovací jazyk Go (podobně jako pro mnoho
dalších programovacích jazyků) vznikla i implementace numerického typu
s&nbsp;poněkud záhadným jménem <strong>Posit</strong>. S&nbsp;těmito dvěma
koncepty se seznámíme v&nbsp;navazující části <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">seriálu o
programovacím jazyku Go</a>.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů naprogramovaných
v&nbsp;jazyku Go byly uloženy do Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář, můžete namísto toho
použít odkazy na jednotlivé demonstrační příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad/soubor</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_bigint_construction.go</td><td>konstrukce instance datového typu <strong>big.Int</strong> a tisk uložené hodnoty</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/01_bigint_construction.go">https://github.com/tisnik/go-root/blob/master/article_A8/01_bigint_construction.go</a></td></tr>
<tr><td> 2</td><td>02_bigint_add.go</td><td>aritmetická operace součtu a datový typ <strong>big.Int</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/02_bigint_add.go">https://github.com/tisnik/go-root/blob/master/article_A8/02_bigint_add.go</a></td></tr>
<tr><td> 3</td><td>03_bigint_large_numbers.go</td><td>aritmetická operace součinu a datový typ <strong>big.Int</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/03_bigint_large_numbers.go">https://github.com/tisnik/go-root/blob/master/article_A8/03_bigint_large_numbers.go</a></td></tr>
<tr><td> 4</td><td>04_factorial.go</td><td>výpočet faktoriálu s&nbsp;využitím datového typu <strong>big.Int</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/04_factorial.go">https://github.com/tisnik/go-root/blob/master/article_A8/04_factorial.go</a></td></tr>
<tr><td> 5</td><td>05_bigint_print_base.go</td><td>převod hodnoty typu <strong>big.Int</strong> na text s&nbsp;volitelnou bází</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/05_bigint_print_base.go">https://github.com/tisnik/go-root/blob/master/article_A8/05_bigint_print_base.go</a></td></tr>
<tr><td> 6</td><td>06_bigint_as_bytes.go</td><td>zobrazení interní struktury hodnot typu <strong>big.Int</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/06_bigint_as_bytes.go">https://github.com/tisnik/go-root/blob/master/article_A8/06_bigint_as_bytes.go</a></td></tr>
<tr><td> 7</td><td>07_bigint_change_raw.go</td><td>modifikace interní struktury hodnot typu <strong>big.Int</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/07_bigint_change_raw.go">https://github.com/tisnik/go-root/blob/master/article_A8/07_bigint_change_raw.go</a></td></tr>
<tr><td> 8</td><td>08_bigint_change_raw.go</td><td>nastavení jednotlivých bajtů hodnoty typu <strong>big.Int</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/08_bigint_change_raw.go">https://github.com/tisnik/go-root/blob/master/article_A8/08_bigint_change_raw.go</a></td></tr>
<tr><td> 9</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/">https://github.com/tisnik/go-root/blob/master/article_A8/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/">https://github.com/tisnik/go-root/blob/master/article_A8/</a></td></tr>
<tr><td>11</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/">https://github.com/tisnik/go-root/blob/master/article_A8/</a></td></tr>
<tr><td>12</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/">https://github.com/tisnik/go-root/blob/master/article_A8/</a></td></tr>
<tr><td>13</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/">https://github.com/tisnik/go-root/blob/master/article_A8/</a></td></tr>
<tr><td>14</td><td></td><td></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_A8/">https://github.com/tisnik/go-root/blob/master/article_A8/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Balíček <strong>big</strong> pro jazyk Go<br />
<a href="https://pkg.go.dev/math/big">https://pkg.go.dev/math/big</a>
</li>

<li>Zdrojové kódu pro balíček <strong>big</strong><br />
<a href="https://cs.opensource.google/go/go/+/master:src/math/big/">https://cs.opensource.google/go/go/+/master:src/math/big/</a>
</li>

<li>Arbitrary-precision arithmetic<br />
<a href="https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic">https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic</a>
</li>

<li>Floating-point error mitigation<br />
<a href="https://en.wikipedia.org/wiki/Floating-point_error_mitigation">https://en.wikipedia.org/wiki/Floating-point_error_mitigation</a>
</li>

<li>Beating Floating Point at its Own Game: Posit Arithmetic<br />
<a href="http://www.johngustafson.net/pdfs/BeatingFloatingPoint.pdf">http://www.johngustafson.net/pdfs/BeatingFloatingPoint.pdf</a>
</li>

<li>Unum (number format)<br />
<a href="https://en.wikipedia.org/wiki/Unum_(number_format)">https://en.wikipedia.org/wiki/Unum_(number_format)</a>
</li>

<li>The GNU MPFR Library<br />
<a href="https://www.mpfr.org/">https://www.mpfr.org/</a>
</li>

<li>GMP: Arithmetic without limitations<br />
<a href="https://gmplib.org/">https://gmplib.org/</a>
</li>

<li>GNU MP 6.2.1 manual<br />
<a href="https://gmplib.org/manual/index">https://gmplib.org/manual/index</a>
</li>

<li>Anatomy of a posit number<br />
<a href="https://www.johndcook.com/blog/2018/04/11/anatomy-of-a-posit-number/">https://www.johndcook.com/blog/2018/04/11/anatomy-of-a-posit-number/</a>
</li>

<li>Better floating point: posits in plain language<br />
<a href="http://loyc.net/2019/unum-posits.html">http://loyc.net/2019/unum-posits.html</a>
</li>

<li>Posits, a New Kind of Number, Improves the Math of AI: The first posit-based processor core gave a ten-thousandfold accuracy boost<br />
<a href="https://spectrum.ieee.org/floating-point-numbers-posits-processor">https://spectrum.ieee.org/floating-point-numbers-posits-processor</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

