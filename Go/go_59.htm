<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Generické datové typy v jazyce Go?</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Generické datové typy v jazyce Go?</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Programovací jazyk Go je některými vývojáři kritizován za to, že neobsahuje podporu pro generické datové typy, generické funkce ani metody. Dnes se seznámíme jak s použitím generických typů v jiných jazycích, tak i s projektem Genny, který tuto problematiku v Go alespoň částečně řeší.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Generické datové typy v&nbsp;jazyce Go?</a></p>
<p><a href="#k02">2. Beztypové a jednoúčelové kontejnery</a></p>
<p><a href="#k03">3. Statická genericita</a></p>
<p><a href="#k04">4. Dynamická genericita</a></p>
<p><a href="#k05">5. Použití generických datových typů v&nbsp;Javě</a></p>
<p><a href="#k06">6. Type erasure v&nbsp;Javě</a></p>
<p><a href="#k07">7. Generické datové typy v&nbsp;programovacím jazyku Rust</a></p>
<p><a href="#k08">8. Generické funkce v&nbsp;Rustu</a></p>
<p><a href="#k09">9. Generické funkce a silná typová kontrola v&nbsp;Rustu</a></p>
<p><a href="#k10">10. Stav podpory generických datových typů v&nbsp;jazyce Go</a></p>
<p><a href="#k11">11. Příklad omezení současné verze Go</a></p>
<p><a href="#k12">12. Projekt Genny</a></p>
<p><a href="#k13">13. Vygenerování kódu pro funkci pro součet dvou čísel projektem Genny</a></p>
<p><a href="#k14">14. Změna názvu funkce s&nbsp;generickým numerickým datovým typem</a></p>
<p><a href="#k15">15. Vygenerování testů generické funkce pro součet</a></p>
<p><a href="#k16">16. Anonymní funkce v&nbsp;expandovaném kódu</a></p>
<p><a href="#k17">17. Negenerický binární strom (s&nbsp;konkrétními typy hodnot uzlů)</a></p>
<p><a href="#k18">18. Generický binární strom</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Generické datové typy v&nbsp;jazyce Go?</h2>

<p>Již <a
href="https://www.root.cz/clanky/go-minimalisticky-a-prekvapive-vykonny-programovaci-jazyk/">v&nbsp;úvodní
části</a> <a href="https://www.root.cz/serialy/programovaci-jazyk-go/">seriálu
o programovacím jazyku Go</a> jsme si mj.&nbsp;řekli, že tento jazyk byl
navržen takovým způsobem, že obsahuje pouze ty syntaktické a sémantické prvky,
na nichž se <a
href="https://www.informit.com/articles/article.aspx?p=1623555">shodli všichni
tři</a> autoři tohoto projektu. Všechny vlastnosti, u nichž nebylo na sto
procent jisté, že jsou správně navrženy a že jejich implementace nebude
zpomalovat překladač ani výsledný zkompilovaný a slinkovaný kód, nebyly do
první verze programovacího jazyka Go přidány. Týká se to některých vlastností,
které mohou programátorům chybět &ndash; například výjimek, tříd (a na třídách
postavené větvi objektově orientovaného programování) a taktéž generických
datových typů a generických funkcí. A zejména neexistence generických datových
typů může být pro některé typy aplikací značně omezující, protože je například
složité implementovat obecné a současně i typově bezpečné datové struktury typu
graf, strom, zásobník, fronta atd.</p>

<p>V&nbsp;dnešním článku se nejprve ve stručnosti seznámíme s&nbsp;tím, jakým
způsobem jsou generické datové typy implementovány <a
href="#k05">v&nbsp;Javě</a> a taktéž <a href="#08">v&nbsp;Rustu</a>, tedy
v&nbsp;těch programovacích jazycích, jejichž niky se částečně překrývají
s&nbsp;oblastí použití jazyka Go. Ve <a href="#k12">druhé části článku</a> si
ukážeme způsob použití projektu nazvaného <i>Genny</i>, který &ndash; alespoň
částečně &ndash; dokáže do Go zavést alespoň minimální podporu generických
datových typů. Využívá se přitom generování zdrojového kódu v&nbsp;Go, což je
zcela odlišný postup, než který známe právě z&nbsp;Javy nebo z&nbsp;Rustu (kde
je &bdquo;duplikátní&ldquo; kód vytvářen buď v&nbsp;době překladu, nebo je celá
problematika vyřešena pomocí takzvané <i>type erasure</i> prováděné taktéž
v&nbsp;době překladu).</p>

<p><div class="rs-tip-major">Poznámka: zabývat se tedy nebudeme jazyky typu <a
href="https://www.root.cz/n/python/">Python</a>, v&nbsp;nichž je použit <a
href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a> a tedy zcela
jiný přístup k&nbsp;práci s&nbsp;hodnotami a datovými strukturami.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Beztypové a jednoúčelové kontejnery</h2>

<p>V&nbsp;některých programovacích jazycích (a nejedná se pouze o dynamicky
typované jazyky) se setkáme s&nbsp;takzvanými beztypovými
popř.&nbsp;s&nbsp;jednoúčelovými kontejnery, kterými můžeme do jisté míry
nahradit kontejnery s&nbsp;generickými typy. Typicky se jedná o implementace
seznamů, front, zásobníků, různých typů stromů, obecných orientovaných i
neorientovaných grafů atd. Beztypové kontejnery jsou většinou založeny na
vlastnostech třídního OOP (dědění a polymorfismus) a většinou taktéž na tom, že
hierarchie tříd mívá v&nbsp;mnoha jazycích společného předka. To tedy znamená,
že pokud vytvoříme kontejner (řekněme seznam) pro prvky typu &bdquo;instance
třídy na vrcholu hierarchie tříd&ldquo;, bude možné do takové třídy uložit
jakýkoli objekt, ovšem za tu cenu, že se ztrácí informace o uloženém typu (tu
je nutné získávat pro každý prvek zvlášť, pokud to jazyk díky <a
href="https://en.wikipedia.org/wiki/Run-time_type_information">RTTI</a>
umožňuje).</p>

<p><div class="rs-tip-major">Podobné řešení nabízela Java před verzí
5.</div></p>

<p>Naopak je mnohdy možné vytvořit takzvané jednoúčelové kontejnery. Ty dokážou
ukládat prvky jediného typu popř.&nbsp;v&nbsp;OOP jazycích i odvozeného typu
(potomci třídy). Popř.&nbsp;se může jednat o prvky implementující či splňující
nějaké rozhraní. Typickým příkladem může být pole či řez v&nbsp;jazyku Go. Při
použití jednoúčelových kontejnerů se informace o typu prvků neztratí a naopak
je striktně kontrolována překladačem. Nevýhoda je ovšem zřejmá &ndash; pro
každý datový typ je mnohdy nutné vytvořit prakticky stejný kontejner, jehož
implementace se mnohdy odlišuje pouze v&nbsp;několika maličkostech.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Statická genericita</h2>

<p>Generické datové typy a generické funkce lze realizovat rozličnými způsoby.
Pokud samotný programovací jazyk genericitu nepodporuje, ovšem má rozumný
makrosystém, lze použít (či spíše zneužít) právě tento makrosystém, kdy makra
budou expandována na konkrétní datový typ (například komplexní číslo
s&nbsp;položkami typu <strong>float</strong>), popř.&nbsp;na konkrétní funkci
(s&nbsp;tím, že jméno funkce bude muset být nějakým způsobem unikátní). Jedná
se ovšem o velmi křehké řešení &ndash; mnoho chybových hlášení bude používat
expandovaný kód, který uživatel nenapsal atd.</p>

<p>V&nbsp;některých programovacích jazycích, například v&nbsp;Javě, se používá
odlišný způsob, při němž se ve zdrojovém kódu konkrétní datový typ (vhodným
způsobem) zapíše a překladač ho tedy zpracuje a použije pro případné typové
kontroly. Ovšem interně &ndash; v&nbsp;generovaném kódu nebo bajtkódu &ndash;
se použije nějaký obecný společný nadtyp, typicky třída <strong>Object</strong>
(v&nbsp;závislosti na konkrétní hierarchii tříd a datových typů). Prakticky
stejným způsobem je vyřešeno vytváření funkcí a metod z&nbsp;generických funkcí
a metod.</p>

<p><div class="rs-tip-major">Poznámka: existuje ještě třetí možnost, a to přímo
generování zdrojového kódu. S&nbsp;touto možností se seznámíme níže
v&nbsp;souvislosti s&nbsp;projektem <i>Genny</i>.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Dynamická genericita</h2>

<p>V&nbsp;případě, že překladač programovacího jazyka vytváří kód běžící ve
virtuálním stroji, je možné generické datové typy popř.&nbsp;i generické funkce
a metody vytvářet právě virtuálním strojem, a to přímo za běhu aplikace. Toto
řešení má některé výhody (vytvoří se pouze tolik variant, kolik je skutečně
zapotřebí), ovšem samozřejmě za tuto možnost zaplatíme pomalejším během a
mnohdy i většími paměťovými nároky.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Použití generických datových typů v&nbsp;Javě</h2>

<p>Nejprve se alespoň ve stručnosti podívejme na způsob použití generických
datových typů v&nbsp;programovacím jazyku Java. Uvedeme si jeden
z&nbsp;nejtypičtějších motivačních příkladů, na němž se například
v&nbsp;učebnicích ukazují výhody generických datových typů v&nbsp;silně
typovaných programovacích jazycích. V&nbsp;příkladu je vytvořen obecný seznam
(jehož konkrétní implementace je založena na sekvenci prvků uložených
v&nbsp;poli). Do tohoto seznamu můžeme vkládat libovolné objekty, přesněji
řečeno instance jakékoli třídy. Proč tomu tak je? Seznam je kontejnerem pro
objekty typu <strong>Object</strong> a právě třída <strong>Object</strong> leží
na vrcholu hierarchie všech tříd Javy (jedná se o stromovou strukturu
s&nbsp;jediným kořenem). Platí zde tedy jeden z&nbsp;principů třídního OOP
&ndash; potomek může nahradit předka. Ve zdrojovém kódu vidíme, že do seznamu
lze vložit i celé číslo, ovšem v&nbsp;tomto případě je interně použit takzvaný
<i>boxing</i>, v&nbsp;němž je numerická hodnota nahrazena objektem, zde
konkrétně instancí třídy <strong>Integer</strong>:</p>

<pre>
import java.util.List;
import java.util.ArrayList;
import java.awt.Color;
&nbsp;
public class <strong>Test1</strong> {
    public static void <strong>main</strong>(String[] args) {
        List l = new ArrayList();
        l.add(new Object());
        l.add("foobar");
        l.add(42);
        l.add(Color.green);
&nbsp;
        for (Object i : l) {
            System.out.println(i);
        }
    }
}
</pre>

<p>Mimochodem, interně, tedy na úrovni bajtkódu, vypadá <i>boxing</i>
následovně (volá se statická metoda <strong>Integer.valueOf</strong>):</p>

<pre>
32: bipush        42
34: invokestatic  #7                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
37: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
</pre>

<p>Výše uvedené řešení má mnoho nevýhod. Překladač (nikoli ovšem runtime)
ztrácí informace o tom, jaké typy objektů jsou vlastně v&nbsp;seznamu uloženy.
Proto například není možné přeložit následující program, a to přesto, že
sémanticky je zdánlivě v&nbsp;pořádku &ndash; do seznamu jsme uložili pouze
řetězce, takže by mělo být možné volat pro všechny prvky seznamu metodu
<strong>length()</strong>. Ovšem z&nbsp;pohledu překladače jsou všechny prvky
(netypového) seznamu typu <strong>Object</strong>, takže to přímo možné
není:</p>

<pre>
import java.util.List;
import java.util.ArrayList;
import java.awt.Color;
&nbsp;
public class <strong>Test2</strong> {
    public static void <strong>main</strong>(String[] args) {
        List l = new ArrayList();
        l.add("foo");
        l.add("bar");
        l.add("baz");
&nbsp;
        String s = l.get(0);
        System.out.println(s.length());
    }
}
</pre>

<p>Výsledek pokusu o překlad dopadne neslavně:</p>

<pre>
Test2.java:8: warning: [unchecked] unchecked call to add(E) as a member of the raw type List
        l.add("foo");
             ^
  where E is a type-variable:
    E extends Object declared in interface List
Test2.java:9: warning: [unchecked] unchecked call to add(E) as a member of the raw type List
        l.add("bar");
             ^
  where E is a type-variable:
    E extends Object declared in interface List
Test2.java:10: warning: [unchecked] unchecked call to add(E) as a member of the raw type List
        l.add("baz");
             ^
  where E is a type-variable:
    E extends Object declared in interface List
Test2.java:12: error: incompatible types
        String s = l.get(0);
                        ^
  required: String
  found:    Object
1 error
3 warnings
</pre>

<p><div class="rs-tip-major">Poznámka: navíc je ještě nutné počítat s&nbsp;tím,
že namísto objektu může být do seznamu uložena hodnota <strong>null</strong>,
takže v&nbsp;takovém případě by příklad zhavaroval na populární výjimce typu
<strong>java.lang.NullPointerException</strong>.</div></p>

<p>Jedno z&nbsp;řešení, které pochází z&nbsp;prehistorické doby Javy 1.4, je
založeno na explicitním přetypování prvku:</p>

<pre>
import java.util.List;
import java.util.ArrayList;
import java.awt.Color;
&nbsp;
public class <strong>Test3</strong> {
    public static void <strong>main</strong>(String[] args) {
        List l = new ArrayList();
        l.add("foo");
        l.add("bar");
        l.add("baz");
&nbsp;
        String s = (String)l.get(0);
        System.out.println(s.length());
    }
}
</pre>

<p>Na úrovni bajtkódu vypadá načtení prvku, kontrola jeho typu a vytištění
délky řetězce následovně:</p>

<pre>
<i>// získání prvku z kolekce, kontrola typu objektu</i>
35: aload_1       
36: iconst_0      
37: invokeinterface #8,  2            <i>// InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</i>
42: checkcast     #9                  <i>// class java/lang/String</i>
45: astore_2      
&nbsp;
<i>// metoda, která se bude volat</i>
46: getstatic     #10                 <i>// Field java/lang/System.out:Ljava/io/PrintStream;</i>
&nbsp;
// získání délky řetězce s jeho výpisem
49: aload_2       
50: invokevirtual #11                 <i>// Method java/lang/String.length:()I</i>
53: invokevirtual #12                 <i>// Method java/io/PrintStream.println:(I)V</i>
</pre>

<p>Mnohem lepší řešení spočívá ve specifikaci typu prvků kolekce. Jedná se o
informaci použitou překladačem, která mj.&nbsp;umožňuje provádět lepší typovou
kontrolu:</p>

<pre>
import java.util.List;
import java.util.ArrayList;
import java.awt.Color;
&nbsp;
public class <strong>Test4</strong> {
    public static void main(String[] args) {
        List&lt;String&gt; l = new ArrayList&lt;String&gt;();
        l.add(new Object());
        l.add("foobar");
        l.add(42);
        l.add(Color.green);
&nbsp;
        for (String s : l) {
            System.out.println(s.length());
        }
    }
}
</pre>

<p>Tento demonstrační příklad se ovšem opět nepřeloží, a to z&nbsp;toho důvodu,
že se do seznamu, který má obsahovat pouze řetězce, snažíme přidat prvky
odlišných typů. Chybové hlášení vypadá na starší verzi Javy následovně:</p>

<pre>
Test4.java:8: error: no suitable method found for add(Object)
        l.add(new Object());
         ^
    method List.add(int,String) is not applicable
      (actual and formal argument lists differ in length)
    method List.add(String) is not applicable
      (actual argument Object cannot be converted to String by method invocation conversion)
    method Collection.add(String) is not applicable
      (actual argument Object cannot be converted to String by method invocation conversion)
Test4.java:10: error: no suitable method found for add(int)
        l.add(42);
         ^
    method List.add(int,String) is not applicable
      (actual and formal argument lists differ in length)
    method List.add(String) is not applicable
      (actual argument int cannot be converted to String by method invocation conversion)
    method Collection.add(String) is not applicable
      (actual argument int cannot be converted to String by method invocation conversion)
Test4.java:11: error: no suitable method found for add(Color)
        l.add(Color.green);
         ^
    method List.add(int,String) is not applicable
      (actual and formal argument lists differ in length)
    method List.add(String) is not applicable
      (actual argument Color cannot be converted to String by method invocation conversion)
    method Collection.add(String) is not applicable
      (actual argument Color cannot be converted to String by method invocation conversion)
3 errors
</pre>

<p>V&nbsp;korektně zapsaném zdrojovém kódu jsou do seznamu ukládány pouze
řetězce:</p>

<pre>
import java.util.List;
import java.util.ArrayList;
import java.awt.Color;
&nbsp;
public class <strong>Test5</strong> {
    public static void <strong>main</strong>(String[] args) {
        List&lt;String&gt; l = new ArrayList&lt;String&gt;();
        l.add("foo");
        l.add("bar");
        l.add("baz");
        l.add(Integer.toString(42));
&nbsp;
        for (String s : l) {
            System.out.println(s.length());
        }
    }
}
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;novějších verzích Javy je možné
zdrojový kód ještě nepatrně zkrátit a zpřehlednit s&nbsp;využitím
&bdquo;diamantu&ldquo; &ndash; druhá specifikace typu seznamu se nahradí pouze
zápisem &lt;&gt;.</div></p>

<p>Díky tomu, že překladač zná typ kolekce (a tedy i typ prvků ukládaných do
seznamu), je možné programovou smyčku, která vytiskne délky všech řetězců
v&nbsp;seznamu, přeložit do bajtkódu následujícím způsobem:</p>

<pre>
47: aload_1       
48: invokeinterface #9,  1            <i>// InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator;</i>
53: astore_2
&nbsp;
<i>// začátek programové smyčky</i>
54: aload_2
&nbsp;
// test, zda kolekce obsahuje další prvek
55: invokeinterface #10,  1           <i>// InterfaceMethod java/util/Iterator.hasNext:()Z</i>
&nbsp;
<i>// pokud prvek neexistuje, ukončení programové smyčky</i>
60: ifeq          86
63: aload_2
&nbsp;
// získání prvku z kolekce, kontrola typu objektu
64: invokeinterface #11,  1           <i>// InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;</i>
69: checkcast     #12                 <i>// class java/lang/String</i>
72: astore_3
&nbsp;
<i>// metoda, která se bude volat</i>
73: getstatic     #13                 <i>// Field java/lang/System.out:Ljava/io/PrintStream;</i>
&nbsp;
<i>// získání délky řetězce s jeho výpisem</i>
76: aload_3       
77: invokevirtual #14                 <i>// Method java/lang/String.length:()I</i>
80: invokevirtual #15                 <i>// Method java/io/PrintStream.println:(I)V</i>
&nbsp;
<i>// pokračování smyčky (začátek další iterace s testem na začátku)</i>
83: goto          54
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Type erasure v&nbsp;Javě</h2>

<p>V&nbsp;Javě se navíc setkáme s&nbsp;takzvaným <i>type erasure</i>. Jedná se
o odstranění informace o generickém typu překladačem při vytváření bajtkódu. To
má několik důsledků &ndash; striktní typová kontrola je prováděna v&nbsp;době
překladu (<i>compile time</i>), ovšem typová informace (například o typu prvků
kontejneru) je v&nbsp;čase běhu (<i>runtime</i>) ztracena. Ověřit si to ostatně
můžeme na následujícím jednoduchém příkladu, v&nbsp;němž jsou vytvořeny dvě
kolekce, každá s&nbsp;prvky jiného typu. Následně si necháme vypsat jména
kolekcí a dokonce můžeme porovnat, zda jsou kolekce implementovány stejnou
třídou či nikoli:</p>

<pre>
import java.util.Collection;
import java.util.ArrayList;
import java.awt.Color;
&nbsp;
public class <strong>Test6</strong> {
    public static void main(String[] args) {
        Collection&lt;String&gt; l1 = new ArrayList&lt;String&gt;();
        Collection&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;();
&nbsp;
        System.out.println(l1.getClass().getName());
        System.out.println(l2.getClass().getName());
&nbsp;
        System.out.println(l1.getClass() == l2.getClass());
    }
}
</pre>

<p>Po spuštění tohoto demonstračního příkladu získáme dvakrát stejné jméno
třídy. Na posledním řádku je patrné, že jsou třídy (z&nbsp;pohledu virtuálního
stroje v&nbsp;Runtime) skutečně shodné:</p>

<pre>
java.util.ArrayList
java.util.ArrayList
true
</pre>

<p>Jen pro úplnost si ukažme, jak je takové porovnání tříd dvou objektů (tedy
využití RTTI) realizováno v&nbsp;bajtkódu:</p>

<pre>
<i>// zavolání <strong>getClass</strong> u prvního objektu</i>
45: aload_1       
46: invokevirtual #5                  <i>// Method java/lang/Object.getClass:()Ljava/lang/Class;</i>
&nbsp;
<i>// zavolání <strong>getClass</strong> u prvního objektu</i>
49: aload_2       
50: invokevirtual #5                  <i>// Method java/lang/Object.getClass:()Ljava/lang/Class;</i>
&nbsp;
<i>// porovnání se skokem</i>
53: if_acmpne     60
56: iconst_1      
<i>// skok za "else"</i>
57: goto          61
60: iconst_0      
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Generické datové typy v&nbsp;programovacím jazyku Rust</h2>

<p>Generické datové typy jsou podporovány i dalším (i když mnohdy nepřímým)
konkurentem Go &ndash; programovacím jazykem Rust. Generické typy v&nbsp;Rustu
mohou při správném použití zjednodušit tvorbu znovupoužitelného programového
kódu a současně zajistit silnou typovou kontrolu při překladu (což jsou bez
použití generických typů mnohdy současně nesplnitelné požadavky). Podívejme se
nejprve na jednoduchý motivační příklad, v&nbsp;němž prozatím
<strong>nejsou</strong> použity generické datové typy. Jedná se o implementaci
datového typu (struktury) představujícího komplexní čísla. První verze vypadá
takto &ndash; <strong>Complex</strong> je zde skutečně pouhá datová
struktura:</p>

<pre>
struct <strong>Complex</strong> {
    real: f32,
    imag: f32,
}
&nbsp;
fn <strong>main</strong>() {
    let c1 = Complex{real:10.0, imag:20.0};
    let c2 = Complex{real:10.1, imag:20.1};
    let c3 = Complex{real:10.2, imag:20.2};
    let c4 = Complex{real:1., imag:2.};
&nbsp;
    println!("{}+{}i", c1.real, c1.imag);
    println!("{}+{}i", c2.real, c2.imag);
    println!("{}+{}i", c3.real, c3.imag);
    println!("{}+{}i", c4.real, c4.imag);
}
</pre>

<p>V&nbsp;tomto zdrojovém kódu je deklarováno, že reálná a imaginární složka je
představována datovým typem <i>float/single</i>, což je překladačem striktně
hlídáno (a to mnohem silněji, než například v&nbsp;céčku, podobně silně, jako
je tomu v&nbsp;Go). Pokud se například pokusíme do reálné či imaginární složky
vložit celé číslo, dojde k&nbsp;chybě při překladu:</p>

<pre>
struct <strong>Complex</strong> {
    real: f32,
    imag: f32,
}
&nbsp;
fn <strong>main</strong>() {
    let c1 = Complex{real:10, imag:20};
    let c2 = Complex{real:10.1, imag:20.1};
    let c3 = Complex{real:10.2, imag:20.2};
    let c4 = Complex{real:1, imag:2};
&nbsp;
    println!("{}+{}i", c1.real, c1.imag);
    println!("{}+{}i", c2.real, c2.imag);
    println!("{}+{}i", c3.real, c3.imag);
    println!("{}+{}i", c4.real, c4.imag);
}
</pre>

<p>Při pokusu o překlad tohoto příkladu by se mělo vypsat následující chybové
hlášení, a to pro všechny výskyty hodnoty odlišného datového typu:</p>

<pre>
error[E0308]: mismatched types
 --&gt; test.rs:7:27
  |
7 |     let c1 = Complex{real:10, imag:20};
  |                           ^^ expected f32, found integral variable
  |
  = note: expected type `f32`
  = note:    found type `{integer}`
&nbsp;
error[E0308]: mismatched types
 --&gt; test.rs:7:36
  |
7 |     let c1 = Complex{real:10, imag:20};
  |                                    ^^ expected f32, found integral variable
  |
  = note: expected type `f32`
  = note:    found type `{integer}`
&nbsp;
error[E0308]: mismatched types
  --&gt; test.rs:10:27
   |
10 |     let c4 = Complex{real:1, imag:2};
   |                           ^ expected f32, found integral variable
   |
   = note: expected type `f32`
   = note:    found type `{integer}`
&nbsp;
error[E0308]: mismatched types
  --&gt; test.rs:10:35
   |
10 |     let c4 = Complex{real:1, imag:2};
   |                                   ^ expected f32, found integral variable
   |
   = note: expected type `f32`
   = note:    found type `{integer}`
&nbsp;
error: aborting due to 4 previous errors
</pre>

<p><div class="rs-tip-major">Poznámka: podle očekávání nebude překlad dokončen
ani ve chvíli, kdy se namísto typu <i>float/single</i> použijí konstanty
datového typu <i>double</i>.</div></p>

<p>Předchozí demonstrační příklad sice fungoval korektně a podle všech
předpokladů, ovšem jen ve chvíli, kdy nám postačovalo použití komplexních
čísel, jejichž složky byly reprezentovány typem <i>float/single</i>. Ovšem je
jen otázkou času, kdy nějaký vývojář bude chtít použít podobný kód, ovšem
například pro datový typ <i>double</i>, pro typ &bdquo;zlomek&ldquo; atd.
V&nbsp;takovém případě může být nejvýhodnější deklaraci datové struktury
upravit takovým způsobem, aby se konkrétní typ složek komplexního čísla
rozpoznal až v&nbsp;době překladu na základě typů konkrétních hodnot či výrazů
použitých pro konstrukci datové struktury.</p>

<p><div class="rs-tip-major">Poznámka: pokud vám příklad s&nbsp;komplexními
čísly připadá příliš umělý, představte si místo něho například vektor nebo
matici a funkce pro jejich zpracování.</div></p>

<p>Programovací jazyk Rust tento přístup podporuje, protože umožňuje
následující styl deklarace (znak <strong>T</strong> není klíčovým slovem, ovšem
je v&nbsp;kontextu generických datových typů často používán, takže tento úzus
taktéž dodržíme):</p>

<pre>
struct <strong>Complex&lt;T&gt;</strong> {
    real: <strong>T</strong>,
    imag: <strong>T</strong>,
}
</pre>

<p>Tento zápis znamená, že se za <strong>T</strong> při překladu doplní
konkrétní rozpoznaný datový typ, což si ostatně můžeme snadno vyzkoušet:</p>

<pre>
fn <strong>main</strong>() {
    let c1 = Complex{real:10, imag:20};
    let c2 = Complex{real:10.1, imag:20.1};
    let c3 = Complex{real:10.2f64, imag:20.2f64};
    let c4 = Complex{real:true, imag:false};
&nbsp;
    println!("{}+{}i", c1.real, c1.imag);
    println!("{}+{}i", c2.real, c2.imag);
    println!("{}+{}i", c3.real, c3.imag);
    println!("{}+{}i", c4.real, c4.imag);
}
</pre>

<p>Ve chvíli, kdy se pokusíme o kombinaci různých typů, budeme na to upozorněni
překladačem, protože typ reálné i imaginární složky musí být totožný:</p>

<pre>
fn <strong>main</strong>() {
    let c1 = Complex{real:10, imag:true};
&nbsp;
    println!("{}+{}i", c1.real, c1.imag);
}
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
error[E0308]: mismatched types
 --&gt; test.rs:7:36
  |
7 |     let c1 = Complex{real:10, imag:true};
  |                                    ^^^^ expected integral variable, found bool
  |
  = note: expected type `{integer}`
  = note:    found type `bool`

error: aborting due to previous error
</pre>

<p>Jinými slovy &ndash; typ datové struktury <strong>Complex</strong> je
parametrizovatelný, ovšem současně je stále zajištěna typová kontrola (nejedná
se tedy o nic ve smyslu Complex(Object, Object), tedy o řešení, které jsme
viděli ve světě Javy 1.4 :-).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Generické funkce v&nbsp;Rustu</h2>

<p>V&nbsp;programovacím jazyku Rust je možné kromě deklarace generických
datových typů vytvářet i generické funkce, tj.&nbsp;funkce, u nichž lze
specifikovat parametrizovatelné typy argumentů i návratový typ. Podívejme se
nyní na sice poněkud umělý, ale o to kratší demonstrační příklad. V&nbsp;tomto
příkladu nejprve deklarujeme výčtový typ a následně funkci, která akceptuje dva
parametry typu <strong>i32</strong> (celé číslo se znaménkem) a třetí parametr,
na základě jehož hodnoty funkce vrátí buď první či druhý parametr. Nejprve si
povšimněte, jak se používá výčtový typ (má vlastní jmenný prostor, proto se
zapisuje stylem <strong>Item::First</strong> a nikoli pouze
<strong>First</strong>).  Použití konstrukce <strong>match</strong> je
v&nbsp;tomto případě idiomatické a mnohem lepší, než pokus o použití
<strong>if</strong>, a to z&nbsp;toho důvodu, že překladač sám zkontroluje, zda
v&nbsp;konstrukci <strong>match</strong> korektně reagujeme na všechny možné
vstupy (což samozřejmě děláme :-):</p>

<pre>
enum <strong>Item</strong> {
    First,
    Second,
}
&nbsp;
fn <strong>select_item</strong>(first_item:i32, second_item:i32, item:Item) -&gt; i32 {
    match item {
        Item::First  =&gt; first_item,
        Item::Second =&gt; second_item,
    }
}
&nbsp;
fn <strong>main</strong>() {
    let x = 10;
    let y = 20;
    println!("1st item = {}", select_item(x, y, Item::First));
    println!("2nd item = {}", select_item(x, y, Item::Second));
    
}
</pre>

<p>Po překladu a spuštění by se na standardní výstup měly vypsat následující
dva řádky znamenající, že poprvé funkce <strong>select_item</strong> vybrala a
vrátila první argument (resp.&nbsp;zde jeho kopii!) a podruhé druhý
argument:</p>

<pre>
1st item = 10
2nd item = 20
</pre>

<p>Funkce <strong>select_item</strong> v&nbsp;podobě, v&nbsp;jaké jsme si ji
ukázali, není příliš použitelná ani obecná, protože ji ve skutečnosti lze volat
pouze s&nbsp;parametry typu <strong>i32</strong>. Pokusme se tedy vytvořit
podobnou funkci, ovšem generickou. V&nbsp;tomto případě to znamená, že typy
prvních dvou parametrů musí být shodné a musí odpovídat návratovému typu funkce
&ndash; ta totiž nemá provádět žádné konverze, pouze vybírat mezi prvním a
druhým argumentem. Takto navržená generická funkce může vypadat následovně
(povšimněte si především zápisu &lt;T&gt; za jménem funkce):</p>

<pre>
fn <strong>select_item&lt;T&gt;</strong>(first_item:<strong>T</strong>, second_item:<strong>T</strong>, item:Item) -&gt; <strong>T</strong> {
    match item {
        Item::First  =&gt; first_item,
        Item::Second =&gt; second_item,
    }
}
</pre>

<p>Nově deklarovanou funkci je následně možné použít pro různé typy argumentů,
samozřejmě za předpokladu, že oba dva argumenty budou stejného typu. Opět si to
ukažme:</p>

<pre>
enum <strong>Item</strong> {
    First,
    Second,
}
&nbsp;
fn <strong>select_item&lt;T&gt;</strong>(first_item:<strong>T</strong>, second_item:<strong>T</strong>, item:Item) -&gt; <strong>T</strong> {
    match item {
        Item::First  =&gt; first_item,
        Item::Second =&gt; second_item,
    }
}
&nbsp;
fn <strong>main</strong>() {
    let x = 10.1;
    let y = 20.2;
    println!("1st item = {}", select_item(x, y, Item::First));
    println!("2nd item = {}", select_item(x, y, Item::Second));
&nbsp;
    let z:i32 = 10;
    let w:i32 = 20;
    println!("1st item = {}", select_item(z, w, Item::First));
    println!("2nd item = {}", select_item(z, w, Item::Second));
&nbsp;
    let a = true;
    let b = false;
    println!("1st item = {}", select_item(a, b, Item::First));
    println!("2nd item = {}", select_item(a, b, Item::Second));
}
</pre>

<p>Po spuštění tohoto demonstračního příkladu získáme následující řádky vypsané
na standardní výstup:</p>

<pre>
1st item = 10.1
2nd item = 20.2
1st item = 10
2nd item = 20
1st item = true
2nd item = false
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Generické funkce a silná typová kontrola v&nbsp;Rustu</h2>

<p><a href="#k08">V&nbsp;předchozí kapitole</a> jsme si řekli, že překladač pro
novou podobu funkce <strong>select_item</strong> skutečně kontroluje, zda jsou
typy prvních dvou argumentů shodné. Pojďme si toto tvrzení ověřit: </p>

<pre>
enum <strong>Item</strong> {
    First,
    Second,
}
&nbsp;
fn <strong>select_item&lt;T&gt;</strong>(first_item:<strong>T</strong>, second_item:<strong>T</strong>, item:Item) -&gt; <strong>T</strong> {
    match item {
        Item::First  =&gt; first_item,
        Item::Second =&gt; second_item,
    }
}
&nbsp;
fn <strong>main</strong>() {
    let x = 10.1;
    let y = 20;
    println!("1st item = {}", select_item(x, y, Item::First));
    println!("2nd item = {}", select_item(x, y, Item::Second));
&nbsp;
    let z:f32 = 10;
    let w:i32 = 20;
    println!("1st item = {}", select_item(z, w, Item::First));
    println!("2nd item = {}", select_item(z, w, Item::Second));
&nbsp;
    let a = 10;
    let b = false;
    println!("1st item = {}", select_item(a, b, Item::First));
    println!("2nd item = {}", select_item(a, b, Item::Second));
}
</pre>

<p>Spusťme nyní překladač na tento zdrojový kód, aby bylo patrné, jak pracuje
statická typová kontrola (navíc je ukázána i kontrola typů proměnných a hodnot
přiřazovaných do proměnných, což je ostatně jedna ze základních činností
překladače Rustu):</p>

<pre>
error[E0308]: mismatched types
  --&gt; test.rs:16:46
   |
16 |     println!("1st item = {}", select_item(x, y, Item::First));
   |                                              ^ expected floating-point variable, found integral variable
&lt;std macros&gt;:2:27: 2:58 note: in this expansion of format_args!
&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)
test.rs:16:5: 16:63 note: in this expansion of println! (defined in &lt;std macros&gt;)
   |
   = note: expected type `{float}`
   = note:    found type `{integer}`
&nbsp;
error[E0308]: mismatched types
  --&gt; test.rs:17:46
   |
17 |     println!("2nd item = {}", select_item(x, y, Item::Second));
   |                                              ^ expected floating-point variable, found integral variable
&lt;std macros&gt;:2:27: 2:58 note: in this expansion of format_args!
&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)
test.rs:17:5: 17:64 note: in this expansion of println! (defined in &lt;std macros&gt;)
   |
   = note: expected type `{float}`
   = note:    found type `{integer}`
&nbsp;
error[E0308]: mismatched types
  --&gt; test.rs:19:17
   |
19 |     let z:f32 = 10;
   |                 ^^ expected f32, found integral variable
   |
   = note: expected type `f32`
   = note:    found type `{integer}`
&nbsp;
error[E0308]: mismatched types
  --&gt; test.rs:21:46
   |
21 |     println!("1st item = {}", select_item(z, w, Item::First));
   |                                              ^ expected f32, found i32
&lt;std macros&gt;:2:27: 2:58 note: in this expansion of format_args!
&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)
test.rs:21:5: 21:63 note: in this expansion of println! (defined in &lt;std macros&gt;)
&nbsp;
error[E0308]: mismatched types
  --&gt; test.rs:22:46
   |
22 |     println!("2nd item = {}", select_item(z, w, Item::Second));
   |                                              ^ expected f32, found i32
&lt;std macros&gt;:2:27: 2:58 note: in this expansion of format_args!
&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)
test.rs:22:5: 22:64 note: in this expansion of println! (defined in &lt;std macros&gt;)
&nbsp;
error[E0308]: mismatched types
  --&gt; test.rs:26:46
   |
26 |     println!("1st item = {}", select_item(a, b, Item::First));
   |                                              ^ expected integral variable, found bool
&lt;std macros&gt;:2:27: 2:58 note: in this expansion of format_args!
&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)
test.rs:26:5: 26:63 note: in this expansion of println! (defined in &lt;std macros&gt;)
   |
   = note: expected type `{integer}`
   = note:    found type `bool`
&nbsp;
error[E0308]: mismatched types
  --&gt; test.rs:27:46
   |
27 |     println!("2nd item = {}", select_item(a, b, Item::Second));
   |                                              ^ expected integral variable, found bool
&lt;std macros&gt;:2:27: 2:58 note: in this expansion of format_args!
&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)
test.rs:27:5: 27:64 note: in this expansion of println! (defined in &lt;std macros&gt;)
   |
   = note: expected type `{integer}`
   = note:    found type `bool`
&nbsp;
error: aborting due to 7 previous errors
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Stav podpory generických datových typů v&nbsp;jazyce Go</h2>

<p>V&nbsp;současnosti nejsou generické datové typy ani generické funkce
v&nbsp;programovacím jazyce Go přímo podporovány, i když existuje <a
href="https://github.com/golang/go/issues?q=is%3Aissue+is%3Aopen+generic+label%3AProposal+label%3AGo2">hned
několik návrhů</a> na jejich zavedení do nové verze jazyka, která nese
prozatímní označení Go 2. Zkusme se podívat, jaké problémy neexistence
generických typů může přinášet. Začněme zcela jednoduchou funkcí určenou pro
součet dvou celých čísel. Tu lze zapsat takto:</p>

<pre>
func <strong>add</strong>(x int, y int) int {
    return x + y
}
</pre>

<p>Pokud budeme chtít tuto funkci zobecnit, aby sečetla numerické hodnoty
libovolného typu a vrátila typově správný výsledek, brzy narazíme. Už jen
z&nbsp;toho důvodu, že funkce (jejich názvy) nelze v&nbsp;Go přetěžovat, takže
v&nbsp;jednom modulu nemůžeme vytvořit funkci stejného jména, pouze
s&nbsp;jinými typy parametrů a návratové hodnoty:</p>

<pre>
func <strong>add</strong>(x float32, y float32) float32 {
    return x + y
}
</pre>

<p>To si ostatně můžeme velmi snadno otestovat:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
func <strong>add</strong>(x int, y int) int {
        return x + y
}
&nbsp;
func <strong>add</strong>(x float32, y float32) float32 {
        return x + y
}
&nbsp;
func <strong>main</strong>() {
        fmt.Println(add(1, 2))
        fmt.Println(add(1.1, 2.2))
}
</pre>

<p>Pokus o překlad tohoto demonstračního příkladu skončí s&nbsp;chybou:</p>

<pre>
$ <strong>go build add2.go </strong>
&nbsp;
# command-line-arguments
./add2.go:9:6: add redeclared in this block
        previous declaration at ./add2.go:5:24
</pre>

<p><div class="rs-tip-major">Poznámka: na druhou stranu lze toto omezení
chápat. To, že funkce lze přetěžovat (například v&nbsp;C++) přináší i mnohé
problémy související mj.&nbsp;se jmény funkcí (<a
href="https://en.wikipedia.org/wiki/Name_mangling#C++">Name mangling</a>) a tím
pádem i s&nbsp;podporou takových funkcí a metod v&nbsp;IDE, debuggerech apod.
To stejné lze říci i o generických datových typech, pokud se jejich jména
exportují.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Příklad omezení současné verze Go</h2>

<p>Pro příklady omezení, které nám současná verze programovacího jazyka Go
v&nbsp;některých případech klade, nemusíme chodit daleko. Připomeňme si
například články o frameworku Gonum, který do určité míry reflektuje možnosti
balíčku Numpy pro Python. Zatímco v&nbsp;Numpy lze pracovat s&nbsp;vektory a
maticemi, jejichž prvky jsou různých typů, v&nbsp;balíčcích Gonum je tomu jinak
&ndash; zde se primárně pracuje s&nbsp;prvky typu <strong>float64</strong>, a
to i v&nbsp;případech, kdy by z&nbsp;různých důvodů postačovalo použít prvky
<strong>float32</strong> nebo naopak <strong>complex64</strong>
popř.&nbsp;<strong>complex128</strong>.</p>

<p>Takto se pracuje s&nbsp;vektory, jejichž prvky jsou striktně omezeny na typ
<strong>float64</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "gonum.org/v1/gonum/mat"
)
&nbsp;
func <strong>main</strong>() {
        v1 := mat.NewVecDense(5, nil)
        v2 := mat.NewVecDense(5, []float64{1, 0, 2, 0, 3})
&nbsp;
        fmt.Printf("dot(v1, v1): %f\n", mat.Dot(v1, v1))
        fmt.Printf("dot(v1, v2): %f\n", mat.Dot(v1, v2))
        fmt.Printf("dot(v2, v2): %f\n", mat.Dot(v2, v2))
        fmt.Printf("max(v2):     %f\n", mat.Max(v2))
        fmt.Printf("min(v2):     %f\n", mat.Min(v2))
        fmt.Printf("sum(v2):     %f\n", mat.Sum(v2))
}
</pre>

<p>A takto s&nbsp;maticemi:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "gonum.org/v1/gonum/mat"
)
&nbsp;
func <strong>main</strong>() {
        d := mat.NewDiagDense(10, []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})
        fmt.Printf("Value:\n%v\n\n", mat.Formatted(d))
&nbsp;
        d.SetDiag(1, 100)
        fmt.Printf("Value:\n%v\n\n", mat.Formatted(d))
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Projekt Genny</h2>

<p>Jak již víme, generické datové typy ani generické funkce nejsou jazykem Go
přímo podporovány. Dokonce ani nemůžeme použít systém maker, protože ten Go
neobsahuje. Zbývá nám tedy poslední možnost &ndash; nahradit makra a jejich
expanze externím nástrojem, který (v&nbsp;ideálním případě) přečte korektní
zdrojový kód naprogramovaný v&nbsp;Go a vygeneruje nový kód, v&nbsp;němž dojde
k&nbsp;náhradě generického typu za konkrétní datový typ nebo typy.</p>

<p>Tento nástroj se jmenuje <i>Genny</i> a nainstalovat ho můžeme následujícím
způsobem:</p>

<pre>
go get github.com/cheekybits/genny
</pre>

<p>Po instalaci by měl být k&nbsp;dispozici příkaz <strong>genny</strong>:</p>

<pre>
$ <strong>genny</strong>
&nbsp;
usage: genny [{flags}] gen "{types}"
&nbsp;
gen - generates type specific code from generic code.
get &lt;package/file&gt; - fetch a generic template from the online library and gen it.
&nbsp;
{flags}  - (optional) Command line flags (see below)
{types}  - (required) Specific types for each generic type in the source
{types} format:  {generic}={specific}[,another][ {generic2}={specific2}]
&nbsp;
Examples:
  Generic=Specific
  Generic1=Specific1 Generic2=Specific2
  Generic1=Specific1,Specific2 Generic2=Specific3,Specific4
&nbsp;
Flags:
  -in string
        file to parse instead of stdin
  -out string
        file to save output to instead of stdout
  -pkg string
        package name for generated files
</pre>

<p>Tento nástroj nám umožňuje například z&nbsp;následujícího kódu (obsahujícího
generický typ):</p>

<pre>
type <strong>NumberType</strong> generic.Number
&nbsp;
func <strong>NumberTypeMax</strong>(a, b NumberType) NumberType {
        if a &gt; b {
                return a
        }
        return b
}
</pre>

<p>Vygenerovat například:</p>

<pre>
package <strong>numbers</strong>
&nbsp;
func <strong>IntMax</strong>(a, b int) int {
        if a &gt; b {
                return a
        }
        return b
}
</pre>

<p>nebo:</p>

<pre>
package <strong>numbers</strong>
&nbsp;
func <strong>Float64Max</strong>(a, b float64) float64 {
        if a &gt; b {
                return a
        }
        return b
}
</pre>

<p>atd.</p>

<p>K&nbsp;dispozici jsou dva generické datové typy, jejichž výchozí typy (před
expanzí) vypadají takto:</p>

<pre>
<i>// Type is the placeholder type that indicates a generic value.</i>
<i>// When genny is executed, variables of this type will be replaced with</i>
<i>// references to the specific types.</i>
<i>//      var GenericType generic.Type</i>
type <strong>Type</strong> interface{}
&nbsp;
<i>// Number is the placehoder type that indiccates a generic numerical value.</i>
<i>// When genny is executed, variables of this type will be replaced with</i>
<i>// references to the specific types.</i>
<i>//      var GenericType generic.Number</i>
type <strong>Number</strong> float64
</pre>

<p><div class="rs-tip-major">Poznámka: existence těchto dvou typů znamená, že
zdrojové kódy budou přeložitelné i ve chvíli, kdy vůbec nástroj <i>Genny</i>
nespustíme!</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Vygenerování kódu pro funkci pro součet dvou čísel projektem Genny</h2>

<p>Ukažme si nyní základní vlastnosti nástroje <i>Genny</i> na velmi
jednoduchém příkladu &ndash; na zobecněné funkci pro součet libovolných
numerických hodnot. Celý podbalíček s&nbsp;touto funkcí může vypadat následovně
(nový datový typ je vyžadován, samozřejmě se může jmenovat jinak než
<strong>NumberType</strong>):</p>

<pre>
package <strong>adder</strong>
&nbsp;
import "github.com/cheekybits/genny/generic"
&nbsp;
type <strong>NumberType</strong> generic.Number
&nbsp;
func <strong>Add</strong>(x NumberType, y NumberType) NumberType {
        return x + y
}
</pre>

<p>Výsledek budeme chtít otestovat takto:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
import "add3/adder"
&nbsp;
func <strong>main</strong>() {
        fmt.Println(adder.Add(1, 2))
        fmt.Println(adder.Add(1.1, 2.2))
}
</pre>

<p>Nyní si můžeme nechat vygenerovat variantu funkce <strong>Add</strong> pro
všechny numerické datové typy:</p>

<pre>
$ <strong>cat adder.go  | genny gen "NumberType=NUMBERS" &gt; adder_generic.go</strong>
</pre>

<p>S&nbsp;tímto výsledkem:</p>

<pre>
<i>// This file was automatically generated by genny.</i>
<i>// Any changes will be lost if this file is regenerated.</i>
<i>// see https://github.com/cheekybits/genny</i>
&nbsp;
package <strong>adder</strong>
&nbsp;
func <strong>Add</strong>(x float32, y float32) float32 {
        return x + y
}
&nbsp;
func <strong>Add</strong>(x float64, y float64) float64 {
        return x + y
}
&nbsp;
func <strong>Add</strong>(x int, y int) int {
        return x + y
}
&nbsp;
func <strong>Add</strong>(x int16, y int16) int16 {
        return x + y
}
&nbsp;
func <strong>Add</strong>(x int32, y int32) int32 {
        return x + y
}
&nbsp;
func <strong>Add</strong>(x int64, y int64) int64 {
        return x + y
}
&nbsp;
func <strong>Add</strong>(x int8, y int8) int8 {
        return x + y
}
&nbsp;
func <strong>Add</strong>(x uint, y uint) uint {
        return x + y
}
&nbsp;
func <strong>Add</strong>(x uint16, y uint16) uint16 {
        return x + y
}
&nbsp;
func <strong>Add</strong>(x uint32, y uint32) uint32 {
        return x + y
}
&nbsp;
func <strong>Add</strong>(x uint64, y uint64) uint64 {
        return x + y
}
&nbsp;
func <strong>Add</strong>(x uint8, y uint8) uint8 {
        return x + y
}
</pre>

<p><div class="rs-tip-major">Poznámka: vidíme, že se funkce vygenerovala pro
všechny numerické typy, kde došlo k&nbsp;náhradě <strong>NumberType</strong> za
konkrétní typ. Ovšem samotné jméno funkce změněno nebylo, což vede
k&nbsp;nepřeložitelnému kódu (přetěžování funkcí v&nbsp;Go není povoleno, což
již ostatně víme).</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Změna názvu funkce s&nbsp;generickým numerickým datovým typem</h2>

<p>Zdrojový kód, který bude transformován nástrojem <i>Genny</i>, je tedy nutné
upravit, a to takovým způsobem, že jméno generického datového typu
(<strong>NumberType</strong>) vložíme i do názvu funkce:</p>

<pre>
package <strong>adder</strong>
&nbsp;
import "github.com/cheekybits/genny/generic"
&nbsp;
type <strong>NumberType</strong> generic.Number
&nbsp;
func <strong>NumberTypeAdd</strong>(x NumberType, y NumberType) NumberType {
        return x + y
}
</pre>

<p>Nyní bude kód vygenerovaný nástrojem <i>Genny</i> vypadat odlišně &ndash;
především bude přeložitelný a bude obsahovat všechny typové kontroly:</p>

<pre>
<i>// This file was automatically generated by genny.</i>
<i>// Any changes will be lost if this file is regenerated.</i>
<i>// see https://github.com/cheekybits/genny</i>
&nbsp;
package <strong>adder</strong>
&nbsp;
func <strong>Float32Add</strong>(x float32, y float32) float32 {
        return x + y
}
&nbsp;
func <strong>Float64Add</strong>(x float64, y float64) float64 {
        return x + y
}
&nbsp;
func <strong>IntAdd</strong>(x int, y int) int {
        return x + y
}
&nbsp;
func <strong>Int16Add</strong>(x int16, y int16) int16 {
        return x + y
}
&nbsp;
func <strong>Int32Add</strong>(x int32, y int32) int32 {
        return x + y
}
&nbsp;
func <strong>Int64Add</strong>(x int64, y int64) int64 {
        return x + y
}
&nbsp;
func <strong>Int8Add</strong>(x int8, y int8) int8 {
        return x + y
}
&nbsp;
func <strong>UintAdd</strong>(x uint, y uint) uint {
        return x + y
}
&nbsp;
func <strong>Uint16Add</strong>(x uint16, y uint16) uint16 {
        return x + y
}
&nbsp;
func <strong>Uint32Add</strong>(x uint32, y uint32) uint32 {
        return x + y
}
&nbsp;
func <strong>Uint64Add</strong>(x uint64, y uint64) uint64 {
        return x + y
}
&nbsp;
func <strong>Uint8Add</strong>(x uint8, y uint8) uint8 {
        return x + y
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Vygenerování testů generické funkce pro součet</h2>

<p>I testy pro generickou funkci pro součet lze vygenerovat. Opět si to ukažme
na příkladu. Nejprve samotná deklarace generického datového typu a generické
funkce:</p>

<pre>
package <strong>adder</strong>
&nbsp;
import "github.com/cheekybits/genny/generic"
&nbsp;
type <strong>NumberType</strong> generic.Number
&nbsp;
func <strong>NumberTypeAdd</strong>(x NumberType, y NumberType) NumberType {
        return x + y
}
</pre>

<p>Hlavní modul s&nbsp;testem &ndash; funkcí
<strong>CheckNumberTypeAdd</strong>. Povšimněte si, že se ve jméně této funkce
opět objevuje jméno generického datového typu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
import "add5/adder"
&nbsp;
func <strong>CheckNumberTypeAdd</strong>() {
        var x NumberType
        x = adder.NumberTypeAdd(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>main</strong>() {
        CheckNumberTypeAdd()
}
</pre>

<p>Vygenerovaná podoba testů &ndash; zde se opakuje deklarace funkce
<strong>main</strong> a program je tedy nepřeložitelný:</p>


<pre>
<i>// This file was automatically generated by genny.</i>
<i>// Any changes will be lost if this file is regenerated.</i>
<i>// see https://github.com/cheekybits/genny</i>
&nbsp;
package <strong>main</strong>
&nbsp;
import (
        "add5/adder"
        "fmt"
)
&nbsp;
func <strong>CheckFloat32Add</strong>() {
        var x float32
        x = adder.Float32Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>main</strong>() {
        CheckFloat32Add()
}
&nbsp;
func <strong>CheckFloat64Add</strong>() {
        var x float64
        x = adder.Float64Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>main</strong>() {
        CheckFloat64Add()
}
&nbsp;
func <strong>CheckIntAdd</strong>() {
        var x int
        x = adder.IntAdd(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>main</strong>() {
        CheckIntAdd()
}
&nbsp;
func <strong>CheckInt16Add</strong>() {
        var x int16
        x = adder.Int16Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>main</strong>() {
        CheckInt16Add()
}
&nbsp;
func <strong>CheckInt32Add</strong>() {
        var x int32
        x = adder.Int32Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>main</strong>() {
        CheckInt32Add()
}
&nbsp;
func <strong>CheckInt64Add</strong>() {
        var x int64
        x = adder.Int64Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>main</strong>() {
        CheckInt64Add()
}
&nbsp;
func <strong>CheckInt8Add</strong>() {
        var x int8
        x = adder.Int8Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>main</strong>() {
        CheckInt8Add()
}
&nbsp;
func <strong>CheckUintAdd</strong>() {
        var x uint
        x = adder.UintAdd(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>main</strong>() {
        CheckUintAdd()
}
&nbsp;
func <strong>CheckUint16Add</strong>() {
        var x uint16
        x = adder.Uint16Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>main</strong>() {
        CheckUint16Add()
}
&nbsp;
func <strong>CheckUint32Add</strong>() {
        var x uint32
        x = adder.Uint32Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>main</strong>() {
        CheckUint32Add()
}
&nbsp;
func <strong>CheckUint64Add</strong>() {
        var x uint64
        x = adder.Uint64Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>main</strong>() {
        CheckUint64Add()
}
&nbsp;
func <strong>CheckUint8Add</strong>() {
        var x uint8
        x = adder.Uint8Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>main</strong>() {
        CheckUint8Add()
}
</pre>

<p>Je tedy vyžadována ruční úprava!:</p>

<pre>
<i>// This file was automatically generated by genny.</i>
<i>// Any changes will be lost if this file is regenerated.</i>
<i>// see https://github.com/cheekybits/genny</i>
&nbsp;
package <strong>main</strong>
&nbsp;
import (
        "add5/adder"
        "fmt"
)
&nbsp;
func <strong>CheckFloat32Add</strong>() {
        var x float32
        x = adder.Float32Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>CheckFloat64Add</strong>() {
        var x float64
        x = adder.Float64Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>CheckIntAdd</strong>() {
        var x int
        x = adder.IntAdd(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>CheckInt16Add</strong>() {
        var x int16
        x = adder.Int16Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>CheckInt32Add</strong>() {
        var x int32
        x = adder.Int32Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>CheckInt64Add</strong>() {
        var x int64
        x = adder.Int64Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>CheckInt8Add</strong>() {
        var x int8
        x = adder.Int8Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>CheckUintAdd</strong>() {
        var x uint
        x = adder.UintAdd(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>CheckUint16Add</strong>() {
        var x uint16
        x = adder.Uint16Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>CheckUint32Add</strong>() {
        var x uint32
        x = adder.Uint32Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>CheckUint64Add</strong>() {
        var x uint64
        x = adder.Uint64Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>CheckUint8Add</strong>() {
        var x uint8
        x = adder.Uint8Add(1, 2)
        fmt.Println(x)
}
&nbsp;
func <strong>main</strong>() {
        CheckIntAdd()
        CheckInt8Add()
        CheckInt16Add()
        CheckInt32Add()
        CheckInt64Add()
        CheckUintAdd()
        CheckUint8Add()
        CheckUint16Add()
        CheckUint32Add()
        CheckUint64Add()
        CheckFloat32Add()
        CheckFloat64Add()
}
</pre>

<p><div class="rs-tip-major">Poznámka: tento program &ndash; i když vyžadoval
ruční zásahy &ndash; je již plně přeložitelný a spustitelný.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Anonymní funkce v&nbsp;expandovaném kódu</h2>

<p>Předchozí příklad byl dosti umělý, ovšem ukažme si praktičtější zadání,
tentokrát s&nbsp;anonymní funkcí, která bude implementovat porovnání dvou
numerických hodnot. Na základě výsledku porovnání se vrátí buď první hodnota
nebo hodnota druhá.</p>

<p><div class="rs-question">Otázka: proč nemůžeme použít přímo operátor
&lt;?</div></p>

<p>Implementace může vypadat následovně:</p>

<pre>
package <strong>math</strong>
&nbsp;
import "github.com/cheekybits/genny/generic"
&nbsp;
type <strong>ThisNumberType</strong> generic.Number
&nbsp;
func <strong>ThisNumberTypeMax</strong>(fn func(a, b ThisNumberType) bool, a, b ThisNumberType) ThisNumberType {
        if fn(a, b) {
                return a
        }
        return b
}
</pre>

<p>A expanze nástroje <i>Genny</i> pro všechny numerické datové typy:</p>

<pre>
<i>// This file was automatically generated by genny.</i>
<i>// Any changes will be lost if this file is regenerated.</i>
<i>// see https://github.com/cheekybits/genny</i>
&nbsp;
package <strong>math</strong>
&nbsp;
func <strong>Float32Max</strong>(fn func(a, b float32) bool, a, b float32) float32 {
        if fn(a, b) {
                return a
        }
        return b
}
&nbsp;
func <strong>Float64Max</strong>(fn func(a, b float64) bool, a, b float64) float64 {
        if fn(a, b) {
                return a
        }
        return b
}
&nbsp;
func <strong>IntMax</strong>(fn func(a, b int) bool, a, b int) int {
        if fn(a, b) {
                return a
        }
        return b
}
&nbsp;
func <strong>Int16Max</strong>(fn func(a, b int16) bool, a, b int16) int16 {
        if fn(a, b) {
                return a
        }
        return b
}
&nbsp;
func <strong>Int32Max</strong>(fn func(a, b int32) bool, a, b int32) int32 {
        if fn(a, b) {
                return a
        }
        return b
}
&nbsp;
func <strong>Int64Max</strong>(fn func(a, b int64) bool, a, b int64) int64 {
        if fn(a, b) {
                return a
        }
        return b
}
&nbsp;
func <strong>Int8Max</strong>(fn func(a, b int8) bool, a, b int8) int8 {
        if fn(a, b) {
                return a
        }
        return b
}
&nbsp;
func <strong>UintMax</strong>(fn func(a, b uint) bool, a, b uint) uint {
        if fn(a, b) {
                return a
        }
        return b
}
&nbsp;
func <strong>Uint16Max</strong>(fn func(a, b uint16) bool, a, b uint16) uint16 {
        if fn(a, b) {
                return a
        }
        return b
}
&nbsp;
func <strong>Uint32Max</strong>(fn func(a, b uint32) bool, a, b uint32) uint32 {
        if fn(a, b) {
                return a
        }
        return b
}
&nbsp;
func <strong>Uint64Max</strong>(fn func(a, b uint64) bool, a, b uint64) uint64 {
        if fn(a, b) {
                return a
        }
        return b
}
&nbsp;
func <strong>Uint8Max</strong>(fn func(a, b uint8) bool, a, b uint8) uint8 {
        if fn(a, b) {
                return a
        }
        return b
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Negenerický binární strom (s&nbsp;konkrétními typy hodnot uzlů)</h2>

<p>Plná síla nástroje <i>Genny</i> se projeví při implementaci různých
kontejnerů (seznamů, zásobníků, front, stromů, grafů atd.). Ukažme si nejprve
implementaci binárního stromu, který je negenerický, tj.&nbsp;jeho uzly mají
předem daný konkrétní typ hodnot uzlů:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
)
&nbsp;
type <strong>Item</strong> int
&nbsp;
type <strong>Node</strong> struct {
        Value Item
        Left  *Node
        Right *Node
}
&nbsp;
type <strong>BinaryTree</strong> struct {
        Root *Node
}
&nbsp;
func (bt *BinaryTree) <strong>Insert</strong>(value Item) {
        node := &amp;Node{value, nil, nil}
        if bt.Root == nil {
                bt.Root = node
        } else {
                insertNode(bt.Root, node)
        }
}
&nbsp;
func <strong>insertNode</strong>(node, newNode *Node) {
        if newNode.Value &lt; node.Value {
                if node.Left == nil {
                        node.Left = newNode
                } else {
                        insertNode(node.Left, newNode)
                }
        } else {
                if node.Right == nil {
                        node.Right = newNode
                } else {
                        insertNode(node.Right, newNode)
                }
        }
}
&nbsp;
func <strong>printTree</strong>(node *Node, level int) {
        if node != nil {
                format := ""
                for i := 0; i &lt; level; i++ {
                        format += "       "
                }
                format += "---[ "
                level++
                printTree(node.Left, level)
                fmt.Printf(format+"%v\n", node.Value)
                printTree(node.Right, level)
        }
}
&nbsp;
func <strong>main</strong>() {
        var bt BinaryTree
        bt.Insert(8)
&nbsp;
        bt.Insert(3)
        bt.Insert(11)
&nbsp;
        bt.Insert(1)
        bt.Insert(0)
        bt.Insert(2)
&nbsp;
        bt.Insert(5)
        bt.Insert(4)
        bt.Insert(6)
&nbsp;
        bt.Insert(9)
        bt.Insert(8)
        bt.Insert(10)
&nbsp;
        bt.Insert(13)
        bt.Insert(12)
        bt.Insert(14)
&nbsp;
        printTree(bt.Root, 0)
}
</pre>

<p>Tento příklad je plně funkční &ndash; vytvoří vyvážený binární strom
s&nbsp;patnácti uzly:</p>

<pre>
                     ---[ 0
              ---[ 1
                     ---[ 2
       ---[ 3
                     ---[ 4
              ---[ 5
                     ---[ 6
---[ 8
                     ---[ 8
              ---[ 9
                     ---[ 10
       ---[ 11
                     ---[ 12
              ---[ 13
                     ---[ 14
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Generický binární strom</h2>

<p>Zkusme si nyní předchozí příklad přepsat takovým způsobem, aby byl binární
strom generický, tj.&nbsp;aby ho bylo možné použít pro různé typy uzlů a přitom
se zachovala typová bezpečnost:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/cheekybits/genny/generic"
)
&nbsp;
type <strong>Item</strong> generic.Number
&nbsp;
type <strong>ItemNode</strong> struct {
        Value Item
        Left  *ItemNode
        Right *ItemNode
}
&nbsp;
type <strong>ItemBinaryTree</strong> struct {
        Root *ItemNode
}
&nbsp;
func (bt *ItemBinaryTree) <strong>Insert</strong>(value Item) {
        node := &amp;ItemNode{value, nil, nil}
        if bt.Root == nil {
                bt.Root = node
        } else {
                insertItemNode(bt.Root, node)
        }
}
&nbsp;
func <strong>insertItemNode</strong>(node, newNode *ItemNode) {
        if newNode.Value &lt; node.Value {
                if node.Left == nil {
                        node.Left = newNode
                } else {
                        insertItemNode(node.Left, newNode)
                }
        } else {
                if node.Right == nil {
                        node.Right = newNode
                } else {
                        insertItemNode(node.Right, newNode)
                }
        }
}
&nbsp;
func <strong>printItemTree</strong>(node *ItemNode, level int) {
        if node != nil {
                format := ""
                for i := 0; i &lt; level; i++ {
                        format += "       "
                }
                format += "---[ "
                level++
                printItemTree(node.Left, level)
                fmt.Printf(format+"%v\n", node.Value)
                printItemTree(node.Right, level)
        }
}
</pre>

<p>Vygenerovat si můžeme například variantu pro hodnoty typu
<strong>float32</strong>:</p>

<pre>
$ <strong>cat binary_tree_generic.go | genny gen "Item=float32 &gt; b.go</strong>
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
<i>// This file was automatically generated by genny.</i>
<i>// Any changes will be lost if this file is regenerated.</i>
<i>// see https://github.com/cheekybits/genny</i>
&nbsp;
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
type <strong>Float32Node</strong> struct {
        Value float32
        Left  *Float32Node
        Right *Float32Node
}
&nbsp;
type <strong>Float32BinaryTree</strong> struct {
        Root *Float32Node
}
&nbsp;
func (bt *Float32BinaryTree) <strong>Insert</strong>(value float32) {
        node := &amp;Float32Node{value, nil, nil}
        if bt.Root == nil {
                bt.Root = node
        } else {
                insertFloat32Node(bt.Root, node)
        }
}
&nbsp;
func <strong>insertFloat32Node</strong>(node, newNode *Float32Node) {
        if newNode.Value &lt; node.Value {
                if node.Left == nil {
                        node.Left = newNode
                } else {
                        insertFloat32Node(node.Left, newNode)
                }
        } else {
                if node.Right == nil {
                        node.Right = newNode
                } else {
                        insertFloat32Node(node.Right, newNode)
                }
        }
}
&nbsp;
func <strong>printFloat32Tree</strong>(node *Float32Node, level int) {
        if node != nil {
                format := ""
                for i := 0; i &lt; level; i++ {
                        format += "       "
                }
                format += "---[ "
                level++
                printFloat32Tree(node.Left, level)
                fmt.Printf(format+"%v\n", node.Value)
                printFloat32Tree(node.Right, level)
        }
}
</pre>

<p>Výsledek při volbě typu <strong>Int64</strong>:</p>

<pre>
type <strong>Int64Node</strong> struct {
        Value int64
        Left  *Int64Node
        Right *Int64Node
}
&nbsp;
type <strong>Int64BinaryTree</strong> struct {
        Root *Int64Node
}
&nbsp;
func (bt *Int64BinaryTree) <strong>Insert</strong>(value int64) {
        node := &amp;Int64Node{value, nil, nil}
        if bt.Root == nil {
                bt.Root = node
        } else {
                insertInt64Node(bt.Root, node)
        }
}
&nbsp;
func <strong>insertInt64Node</strong>(node, newNode *Int64Node) {
        if newNode.Value &lt; node.Value {
                if node.Left == nil {
                        node.Left = newNode
                } else {
                        insertInt64Node(node.Left, newNode)
                }
        } else {
                if node.Right == nil {
                        node.Right = newNode
                } else {
                        insertInt64Node(node.Right, newNode)
                }
        }
}
&nbsp;
func <strong>printInt64Tree</strong>(node *Int64Node, level int) {
        if node != nil {
                format := ""
                for i := 0; i &lt; level; i++ {
                        format += "       "
                }
                format += "---[ "
                level++
                printInt64Tree(node.Left, level)
                fmt.Printf(format+"%v\n", node.Value)
                printInt64Tree(node.Right, level)
        }
}
</pre>

<p>A konečně &ndash; nemusí se jednat o binární strom, jehož prvky jsou čísla.
Vyzkoušejme si variantu s&nbsp;řetězci:</p>

<pre>
<i>// This file was automatically generated by genny.</i>
<i>// Any changes will be lost if this file is regenerated.</i>
<i>// see https://github.com/cheekybits/genny</i>
&nbsp;
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
type <strong>StringNode</strong> struct {
        Value string
        Left  *StringNode
        Right *StringNode
}
&nbsp;
type <strong>StringBinaryTree</strong> struct {
        Root *StringNode
}
&nbsp;
func (bt *StringBinaryTree) <strong>Insert</strong>(value string) {
        node := &amp;StringNode{value, nil, nil}
        if bt.Root == nil {
                bt.Root = node
        } else {
                insertStringNode(bt.Root, node)
        }
}
&nbsp;
func <strong>insertStringNode</strong>(node, newNode *StringNode) {
        if newNode.Value &lt; node.Value {
                if node.Left == nil {
                        node.Left = newNode
                } else {
                        insertStringNode(node.Left, newNode)
                }
        } else {
                if node.Right == nil {
                        node.Right = newNode
                } else {
                        insertStringNode(node.Right, newNode)
                }
        }
}
&nbsp;
func <strong>printStringTree</strong>(node *StringNode, level int) {
        if node != nil {
                format := ""
                for i := 0; i &lt; level; i++ {
                        format += "       "
                }
                format += "---[ "
                level++
                printStringTree(node.Left, level)
                fmt.Printf(format+"%v\n", node.Value)
                printStringTree(node.Right, level)
        }
}
&nbsp;
func <strong>main</strong>() {
        var bt StringBinaryTree
        bt.Insert("8")
&nbsp;
        bt.Insert("3")
        bt.Insert("11")
&nbsp;
        bt.Insert("1")
        bt.Insert("0")
        bt.Insert("2")
&nbsp;
        bt.Insert("5")
        bt.Insert("4")
        bt.Insert("6")
&nbsp;
        bt.Insert("9")
        bt.Insert("8")
        bt.Insert("10")

        bt.Insert("13")
        bt.Insert("12")
        bt.Insert("14")
&nbsp;
        printStringTree(bt.Root, 0)
}
</pre>

<p><div class="rs-question">Po spuštění posledního příkladu dostaneme
nevyvážený strom, což je zajímavé, když se původně jednalo o strom vyvážený
(při použití čísel). Proč tomu tak je?</div></p>

<pre>
                            ---[ 0
                     ---[ 1
                            ---[ 10
              ---[ 11
                                   ---[ 12
                            ---[ 13
                                   ---[ 14
                     ---[ 2
       ---[ 3
                     ---[ 4
              ---[ 5
                     ---[ 6
---[ 8
              ---[ 8
       ---[ 9
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně šest až sedm megabajtů), můžete namísto toho použít odkazy na
jednotlivé demonstrační příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>Test1.java</td><td>netypovaný seznam implementovaný v&nbsp;Javě</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_59/Test1.java">https://github.com/tisnik/go-root/blob/master/article_59/Test1.java</a></td></tr>
<tr><td> 2</td><td>Test2.java</td><td>nepřeložitelný příklad &ndash; ztráta informace o typu prvků seznamu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_59/Test2.java">https://github.com/tisnik/go-root/blob/master/article_59/Test2.java</a></td></tr>
<tr><td> 3</td><td>Test3.java</td><td>explicitní přetypování prvků přímo ve zdrojovém kódu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_59/Test3.java">https://github.com/tisnik/go-root/blob/master/article_59/Test3.java</a></td></tr>
<tr><td> 4</td><td>Test4.java</td><td>typovaný seznam implementovaný v&nbsp;Javě</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_59/Test4.java">https://github.com/tisnik/go-root/blob/master/article_59/Test4.java</a></td></tr>
<tr><td> 5</td><td>Test5.java</td><td>vylepšená a přeložitelná varianta předchozího příkladu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_59/Test5.java">https://github.com/tisnik/go-root/blob/master/article_59/Test5.java</a></td></tr>
<tr><td> 6</td><td>Test6.java</td><td><i>type erasure</i> v&nbsp;Javě</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_59/Test6.java">https://github.com/tisnik/go-root/blob/master/article_59/Test6.java</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>generic_struct.rs</td><td>generická datová struktura v&nbsp;Rustu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_59/generic_struct.rs">https://github.com/tisnik/go-root/blob/master/article_59/generic_struct.rs</a></td></tr>
<tr><td> 8</td><td>generic_function.rs</td><td>generická funkce v&nbsp;Rustu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_59/generic_function.rs">https://github.com/tisnik/go-root/blob/master/article_59/generic_function.rs</a></td></tr>
<tr><td> 9</td><td>generic_function_type_error.rs</td><td>test kontrol prováděných překladačem</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_59/generic_function_type_error.rs">https://github.com/tisnik/go-root/blob/master/article_59/generic_function_type_error.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>add1.go</td><td>negenerická funkce v&nbsp;Go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_59/add1.go">https://github.com/tisnik/go-root/blob/master/article_59/add1.go</a></td></tr>
<tr><td>11</td><td>add2.go</td><td>pokus o přetížení funkcí v&nbsp;Go</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_59/add2.go">https://github.com/tisnik/go-root/blob/master/article_59/add2.go</a></td></tr>
<tr><td>12</td><td>add3</td><td>generická funkce (Genny)</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_59/add3">https://github.com/tisnik/go-root/blob/master/article_59/add3</a></td></tr>
<tr><td>13</td><td>add4</td><td>vylepšení generické funkce (Genny)</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_59/add4">https://github.com/tisnik/go-root/blob/master/article_59/add4</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>binary_tree.go</td><td>implementace konkrétního binárního stromu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_59/binary_tree.go">https://github.com/tisnik/go-root/blob/master/article_59/binary_tree.go</a></td></tr>
<tr><td>15</td><td>binary_tree_generic.go</td><td>generický binární strom</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_59/binary_tree_generic.go">https://github.com/tisnik/go-root/blob/master/article_59/binary_tree_generic.go</a></td></tr>
<tr><td>16</td><td>binary_tree_generated.go</td><td>vygenerovaný kód z&nbsp;generické varianty stromu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_59/binary_tree_generated.go">https://github.com/tisnik/go-root/blob/master/article_59/binary_tree_generated.go</a></td></tr>
<tr><td>17</td><td>binary_tree_string.go</td><td>vygenerovaný kód z&nbsp;generické varianty stromu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_59/binary_tree_string.go">https://github.com/tisnik/go-root/blob/master/article_59/binary_tree_string.go</a></td></tr>
<tr><td>18</td><td>binary_tree_generic_2.go</td><td>alternativní způsob implementace generického binárního stromu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_59/binary_tree_generic_2.go">https://github.com/tisnik/go-root/blob/master/article_59/binary_tree_generic_2.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Go Data Structures: Binary Search Tree<br />
<a href="https://flaviocopes.com/golang-data-structure-binary-search-tree/">https://flaviocopes.com/golang-data-structure-binary-search-tree/</a>
</li>

<li>Gobs of data<br />
<a href="https://blog.golang.org/gobs-of-data">https://blog.golang.org/gobs-of-data</a>
</li>

<li>Formát BSON<br />
<a href="http://bsonspec.org/">http://bsonspec.org/</a>
</li>

<li>Golang Guide: A List of Top Golang Frameworks, IDEs &amp; Tools<br />
<a href="https://blog.intelligentbee.com/2017/08/14/golang-guide-list-top-golang-frameworks-ides-tools/">https://blog.intelligentbee.com/2017/08/14/golang-guide-list-top-golang-frameworks-ides-tools/</a>
</li>

<li>Tvorba univerzálních projevů<br />
<a href="http://www.kyblsoft.cz/projevy">http://www.kyblsoft.cz/projevy</a>
</li>

<li>Repositář projektu Gift<br />
<a href="https://github.com/disintegration/gift">https://github.com/disintegration/gift</a>
</li>

<li>Dokumentace k&nbsp;projektu Gift<br />
<a href="https://godoc.org/github.com/disintegration/gift">https://godoc.org/github.com/disintegration/gift</a>
</li>

<li>Online x86 / x64 Assembler and Disassembler<br />
<a href="https://defuse.ca/online-x86-assembler.htm#disassembly2">https://defuse.ca/online-x86-assembler.htm#disassembly2</a>
</li>

<li>The Design of the Go Assembler<br />
<a href="https://talks.golang.org/2016/asm.slide#1">https://talks.golang.org/2016/asm.slide#1</a>
</li>

<li>A Quick Guide to Go's Assembler<br />
<a href="https://golang.org/doc/asm">https://golang.org/doc/asm</a>
</li>

<li>AssemblyPolicy<br />
<a href="https://github.com/golang/go/wiki/AssemblyPolicy">https://github.com/golang/go/wiki/AssemblyPolicy</a>
</li>

<li>Geohash in Golang Assembly<br />
<a href="https://mmcloughlin.com/posts/geohash-assembly">https://mmcloughlin.com/posts/geohash-assembly</a>
</li>

<li>Command objdump<br />
<a href="https://golang.org/cmd/objdump/">https://golang.org/cmd/objdump/</a>
</li>

<li>Assembly<br />
<a href="https://goroutines.com/asm">https://goroutines.com/asm</a>
</li>

<li>Go &amp; Assembly<br />
<a href="http://www.doxsey.net/blog/go-and-assembly">http://www.doxsey.net/blog/go-and-assembly</a>
</li>

<li>A Foray Into Go Assembly Programming<br />
<a href="https://blog.sgmansfield.com/2017/04/a-foray-into-go-assembly-programming/">https://blog.sgmansfield.com/2017/04/a-foray-into-go-assembly-programming/</a>
</li>

<li>Golang Capturing log.Println And fmt.Println Output<br />
<a href="https://medium.com/@hau12a1/golang-capturing-log-println-and-fmt-println-output-770209c791b4">https://medium.com/@hau12a1/golang-capturing-log-println-and-fmt-println-output-770209c791b4</a>
</li>

<li>Stránka projektu plotly<br />
<a href="https://plot.ly/">https://plot.ly/</a>
</li>

<li>Plotly JavaScript Open Source Graphing Library<br />
<a href="https://plot.ly/javascript/">https://plot.ly/javascript/</a>
</li>

<li>Domain coloring<br />
<a href="https://en.wikipedia.org/wiki/Domain_coloring">https://en.wikipedia.org/wiki/Domain_coloring</a>
</li>

<li>Michael Fogleman's projects<br />
<a href="https://www.michaelfogleman.com/projects/tagged/graphics/">https://www.michaelfogleman.com/projects/tagged/graphics/</a>
</li>

<li>Color Graphs of Complex Functions<br />
<a href="https://web.archive.org/web/20120511021419/http://w.american.edu/cas/mathstat/lcrone/ComplexPlot.html">https://web.archive.org/web/20120511021419/http://w.american.edu/cas/mathstat/lcrone/ComplexPlot.html</a>
</li>

<li>A Gallery of Complex Functions<br />
<a href="http://wismuth.com/complex/gallery.html">http://wismuth.com/complex/gallery.html</a>
</li>

<li>package glot<br />
<a href="https://godoc.org/github.com/Arafatk/glot">https://godoc.org/github.com/Arafatk/glot</a>
</li>

<li>Gnuplotting: Output terminals<br />
<a href="http://www.gnuplotting.org/output-terminals/">http://www.gnuplotting.org/output-terminals/</a>
</li>

<li>Introducing Glot the plotting library for Golang<br />
<a href="https://medium.com/@Arafat./introducing-glot-the-plotting-library-for-golang-3133399948a1">https://medium.com/@Arafat./introducing-glot-the-plotting-library-for-golang-3133399948a1</a>
</li>

<li>Introducing Glot the plotting library for Golang<br />
<a href="https://blog.gopheracademy.com/advent-2018/introducing-glot/">https://blog.gopheracademy.com/advent-2018/introducing-glot/</a>
</li>

<li>Glot is a plotting library for Golang built on top of gnuplot<br />
<a href="https://github.com/Arafatk/glot">https://github.com/Arafatk/glot</a>
</li>

<li>Example plots (gonum/plot)<br />
<a href="https://github.com/gonum/plot/wiki/Example-plots">https://github.com/gonum/plot/wiki/Example-plots</a>
</li>

<li>A repository for plotting and visualizing data (gonum/plot)<br />
<a href="https://github.com/gonum/plot">https://github.com/gonum/plot</a>
</li>

<li>golang library to make https://chartjs.org/ plots<br />
<a href="https://github.com/brentp/go-chartjs">https://github.com/brentp/go-chartjs</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>The Gonum Numerical Computing Package<br />
<a href="https://www.gonum.org/post/introtogonum/">https://www.gonum.org/post/introtogonum/</a>
</li>

<li>Gomacro na GitHubu<br />
<a href="https://github.com/cosmos72/gomacro">https://github.com/cosmos72/gomacro</a>
</li>

<li>gophernotes - Use Go in Jupyter notebooks and nteract<br />
<a href="https://github.com/gopherdata/gophernotes">https://github.com/gopherdata/gophernotes</a>
</li>

<li>gonum<br />
<a href="https://github.com/gonum">https://github.com/gonum</a>
</li>

<li>go-gota/gota -  DataFrames and data wrangling in Go (Golang)<br />
<a href="https://porter.io/github.com/go-gota/gota">https://porter.io/github.com/go-gota/gota</a>
</li>

<li>A repository for plotting and visualizing data <br />
<a href="https://github.com/gonum/plot">https://github.com/gonum/plot</a>
</li>

<li>Gonum Numerical Packages<br />
<a href="https://www.gonum.org/">https://www.gonum.org/</a>
</li>

<li>Stránky projektu MinIO<br />
<a href="https://min.io/">https://min.io/</a>
</li>

<li>MinIO Quickstart Guide<br />
<a href="https://docs.min.io/docs/minio-quickstart-guide.html">https://docs.min.io/docs/minio-quickstart-guide.html</a>
</li>

<li>MinIO Go Client API Reference<br />
<a href="https://docs.min.io/docs/golang-client-api-reference">https://docs.min.io/docs/golang-client-api-reference</a>
</li>

<li>MinIO Python Client API Reference<br />
<a href="https://docs.min.io/docs/python-client-api-reference.html">https://docs.min.io/docs/python-client-api-reference.html</a>
</li>

<li>Performance at Scale: MinIO Pushes Past 1.4 terabits per second with 256 NVMe Drives<br />
<a href="https://blog.min.io/performance-at-scale-minio-pushes-past-1-3-terabits-per-second-with-256-nvme-drives/">https://blog.min.io/performance-at-scale-minio-pushes-past-1-3-terabits-per-second-with-256-nvme-drives/</a>
</li>

<li>Benchmarking MinIO vs. AWS S3 for Apache Spark<br />
<a href="https://blog.min.io/benchmarking-apache-spark-vs-aws-s3/">https://blog.min.io/benchmarking-apache-spark-vs-aws-s3/</a>
</li>

<li>MinIO Client Quickstart Guide<br />
<a href="https://docs.min.io/docs/minio-client-quickstart-guide.html">https://docs.min.io/docs/minio-client-quickstart-guide.html</a>
</li>

<li>Analýza kvality zdrojových kódů Minia<br />
<a href="https://goreportcard.com/report/github.com/minio/minio">https://goreportcard.com/report/github.com/minio/minio</a>
</li>

<li>This is MinIO<br />
<a href="https://www.youtube.com/watch?v=vF0lQh0XOCs">https://www.youtube.com/watch?v=vF0lQh0XOCs</a>
</li>

<li>Running MinIO Standalone<br />
<a href="https://www.youtube.com/watch?v=dIQsPCHvHoM">https://www.youtube.com/watch?v=dIQsPCHvHoM</a>
</li>

<li>"Amazon S3 Compatible Storage in Kubernetes" - Rob Girard, Principal Tech Marketing Engineer, Minio<br />
<a href="https://www.youtube.com/watch?v=wlpn8K0jJ4U">https://www.youtube.com/watch?v=wlpn8K0jJ4U</a>
</li>

<li>Ginkgo<br />
<a href="http://onsi.github.io/ginkgo/">http://onsi.github.io/ginkgo/</a>
</li>

<li>Gomega<br />
<a href="https://onsi.github.io/gomega/">https://onsi.github.io/gomega/</a>
</li>

<li>Ginkgo's Preferred Matcher Library na GitHubu<br />
<a href="https://github.com/onsi/gomega/">https://github.com/onsi/gomega/</a>
</li>

<li>Provided Matchers<br />
<a href="http://onsi.github.io/gomega/#provided-matchers">http://onsi.github.io/gomega/#provided-matchers</a>
</li>

<li>Dokumentace k&nbsp;balíčku goexpect<br />
<a href="https://godoc.org/github.com/google/goexpect">https://godoc.org/github.com/google/goexpect</a>
</li>

<li>Balíček goexpect<br />
<a href="https://github.com/google/goexpect">https://github.com/google/goexpect</a>
</li>

<li>Balíček go-expect<br />
<a href="https://github.com/Netflix/go-expect">https://github.com/Netflix/go-expect</a>
</li>

<li>Balíček gexpect<br />
<a href="https://github.com/ThomasRooney/gexpect">https://github.com/ThomasRooney/gexpect</a>
</li>

<li>Expect (originál naprogramovaný v&nbsp;TCL)<br />
<a href="https://core.tcl-lang.org/expect/index">https://core.tcl-lang.org/expect/index</a>
</li>

<li>Expect (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Expect">https://en.wikipedia.org/wiki/Expect</a>
</li>

<li>Pexpect<br />
<a href="https://pexpect.readthedocs.io/en/stable/">https://pexpect.readthedocs.io/en/stable/</a>
</li>

<li>Golang SSH Client: Multiple Commands, Crypto &amp; Goexpect Examples<br />
<a href="http://networkbit.ch/golang-ssh-client/">http://networkbit.ch/golang-ssh-client/</a>
</li>

<li>goblin na GitHubu<br />
<a href="https://github.com/franela/goblin">https://github.com/franela/goblin</a>
</li>

<li>Mocha framework<br />
<a href="https://mochajs.org/">https://mochajs.org/</a>
</li>

<li>frisby na GitHubu<br />
<a href="https://github.com/verdverm/frisby">https://github.com/verdverm/frisby</a>
</li>

<li>package frisby<br />
<a href="https://godoc.org/github.com/verdverm/frisby">https://godoc.org/github.com/verdverm/frisby</a>
</li>

<li>Frisby alternatives and similar packages (generováno)<br />
<a href="https://go.libhunt.com/frisby-alternatives">https://go.libhunt.com/frisby-alternatives</a>
</li>

<li>Cucumber for golang<br />
<a href="https://github.com/DATA-DOG/godog">https://github.com/DATA-DOG/godog</a>
</li>

<li>How to Use Godog for Behavior-driven Development in Go<br />
<a href="https://semaphoreci.com/community/tutorials/how-to-use-godog-for-behavior-driven-development-in-go">https://semaphoreci.com/community/tutorials/how-to-use-godog-for-behavior-driven-development-in-go</a>
</li>

<li>Comparative Analysis Of GoLang Testing Frameworks<br />
<a href="https://www.slideshare.net/DushyantBhalgami/comparative-analysis-of-golang-testing-frameworks">https://www.slideshare.net/DushyantBhalgami/comparative-analysis-of-golang-testing-frameworks</a>
</li>

<li>A Quick Guide to Testing in Golang<br />
<a href="https://caitiem.com/2016/08/18/a-quick-guide-to-testing-in-golang/">https://caitiem.com/2016/08/18/a-quick-guide-to-testing-in-golang/</a>
</li>

<li>Tom's Obvious, Minimal Language.<br />
<a href="https://github.com/toml-lang/toml">https://github.com/toml-lang/toml</a>
</li>

<li>xml.org<br />
<a href="http://www.xml.org/">http://www.xml.org/</a>
</li>

<li>Soubory .properties<br />
<a href="https://en.wikipedia.org/wiki/.properties">https://en.wikipedia.org/wiki/.properties</a>
</li>

<li>Soubory INI<br />
<a href="https://en.wikipedia.org/wiki/INI_file">https://en.wikipedia.org/wiki/INI_file</a>
</li>

<li>JSON to YAML<br />
<a href="https://www.json2yaml.com/">https://www.json2yaml.com/</a>
</li>

<li>Data Format Converter<br />
<a href="https://toolkit.site/format.html">https://toolkit.site/format.html</a>
</li>

<li>Viper na GitHubu<br />
<a href="https://github.com/spf13/viper">https://github.com/spf13/viper</a>
</li>

<li>GoDotEnv na GitHubu<br />
<a href="https://github.com/joho/godotenv">https://github.com/joho/godotenv</a>
</li>

<li>The fantastic ORM library for Golang<br />
<a href="http://gorm.io/">http://gorm.io/</a>
</li>

<li>Dokumentace k&nbsp;balíčku <strong>gorilla/mux</strong><br />
<a href="https://godoc.org/github.com/gorilla/mux">https://godoc.org/github.com/gorilla/mux</a>
</li>

<li>Gorilla web toolkitk<br />
<a href="http://www.gorillatoolkit.org/">http://www.gorillatoolkit.org/</a>
</li>

<li>Metric types<br />
<a href="https://prometheus.io/docs/concepts/metric_types/">https://prometheus.io/docs/concepts/metric_types/</a>
</li>

<li>Histograms with Prometheus: A Tale of Woe<br />
<a href="http://linuxczar.net/blog/2017/06/15/prometheus-histogram-2/">http://linuxczar.net/blog/2017/06/15/prometheus-histogram-2/</a>
</li>

<li>Why are Prometheus histograms cumulative?<br />
<a href="https://www.robustperception.io/why-are-prometheus-histograms-cumulative">https://www.robustperception.io/why-are-prometheus-histograms-cumulative</a>
</li>

<li>Histograms and summaries<br />
<a href="https://prometheus.io/docs/practices/histograms/">https://prometheus.io/docs/practices/histograms/</a>
</li>

<li>Instrumenting Golang server in 5 min<br />
<a href="https://medium.com/@gsisimogang/instrumenting-golang-server-in-5-min-c1c32489add3">https://medium.com/@gsisimogang/instrumenting-golang-server-in-5-min-c1c32489add3</a>
</li>

<li>Semantic Import Versioning in Go<br />
<a href="https://www.aaronzhuo.com/semantic-import-versioning-in-go/">https://www.aaronzhuo.com/semantic-import-versioning-in-go/</a>
</li>

<li>Sémantické verzování<br />
<a href="https://semver.org/">https://semver.org/</a>
</li>

<li>Getting started with Go modules<br />
<a href="https://medium.com/@fonseka.live/getting-started-with-go-modules-b3dac652066d">https://medium.com/@fonseka.live/getting-started-with-go-modules-b3dac652066d</a>
</li>

<li>Create projects independent of $GOPATH using Go Modules<br />
<a href="https://medium.com/mindorks/create-projects-independent-of-gopath-using-go-modules-802260cdfb51o">https://medium.com/mindorks/create-projects-independent-of-gopath-using-go-modules-802260cdfb51o</a>
</li>

<li>Anatomy of Modules in Go<br />
<a href="https://medium.com/rungo/anatomy-of-modules-in-go-c8274d215c16">https://medium.com/rungo/anatomy-of-modules-in-go-c8274d215c16</a>
</li>

<li>Modules<br />
<a href="https://github.com/golang/go/wiki/Modules">https://github.com/golang/go/wiki/Modules</a>
</li>

<li>Go Modules Tutorial<br />
<a href="https://tutorialedge.net/golang/go-modules-tutorial/">https://tutorialedge.net/golang/go-modules-tutorial/</a>
</li>

<li>Module support<br />
<a href="https://golang.org/cmd/go/#hdr-Module_support">https://golang.org/cmd/go/#hdr-Module_support</a>
</li>

<li>Go Lang: Memory Management and Garbage Collection<br />
<a href="https://vikash1976.wordpress.com/2017/03/26/go-lang-memory-management-and-garbage-collection/">https://vikash1976.wordpress.com/2017/03/26/go-lang-memory-management-and-garbage-collection/</a>
</li>

<li>Golang Internals, Part 4: Object Files and Function Metadata<br />
<a href="https://blog.altoros.com/golang-part-4-object-files-and-function-metadata.html">https://blog.altoros.com/golang-part-4-object-files-and-function-metadata.html</a>
</li>

<li>What is REPL?<br />
<a href="https://pythonprogramminglanguage.com/repl/">https://pythonprogramminglanguage.com/repl/</a>
</li>

<li>What is a REPL?<br />
<a href="https://codewith.mu/en/tutorials/1.0/repl">https://codewith.mu/en/tutorials/1.0/repl</a>
</li>

<li>Programming at the REPL: Introduction<br />
<a href="https://clojure.org/guides/repl/introduction">https://clojure.org/guides/repl/introduction</a>
</li>

<li>What is REPL? (Quora)<br />
<a href="https://www.quora.com/What-is-REPL">https://www.quora.com/What-is-REPL</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Read-eval-print loop (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>Vim as a Go (Golang) IDE using LSP and vim-go<br />
<a href="https://octetz.com/posts/vim-as-go-ide">https://octetz.com/posts/vim-as-go-ide</a>
</li>

<li>gopls<br />
<a href="https://github.com/golang/go/wiki/gopls">https://github.com/golang/go/wiki/gopls</a>
</li>

<li>IDE Integration Guide<br />
<a href="https://github.com/stamblerre/gocode/blob/master/docs/IDE_integration.md">https://github.com/stamblerre/gocode/blob/master/docs/IDE_integration.md</a>
</li>

<li>How to instrument Go code with custom expvar metrics<br />
<a href="https://sysdig.com/blog/golang-expvar-custom-metrics/">https://sysdig.com/blog/golang-expvar-custom-metrics/</a>
</li>

<li>Golang expvar metricset (Metricbeat Reference)<br />
<a href="https://www.elastic.co/guide/en/beats/metricbeat/7.x/metricbeat-metricset-golang-expvar.html">https://www.elastic.co/guide/en/beats/metricbeat/7.x/metricbeat-metricset-golang-expvar.html</a>
</li>

<li>Package expvar<br />
<a href="https://golang.org/pkg/expvar/#NewInt">https://golang.org/pkg/expvar/#NewInt</a>
</li>

<li>Java Platform Debugger Architecture: Overview<br />
<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jpda/jpda.html">https://docs.oracle.com/en/java/javase/11/docs/specs/jpda/jpda.html</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="https://www.oracle.com/technetwork/articles/javase/index-140680.html">https://www.oracle.com/technetwork/articles/javase/index-140680.html</a>
</li>

<li>JVM Tool Interface Version 11.0<br />
<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html">https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>Go &amp; cgo: integrating existing C code with Go<br />
<a href="http://akrennmair.github.io/golang-cgo-slides/#1">http://akrennmair.github.io/golang-cgo-slides/#1</a>
</li>

<li>Using cgo to call C code from within Go code<br />
<a href="https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/">https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/</a>
</li>

<li>Package trace<br />
<a href="https://golang.org/pkg/runtime/trace/">https://golang.org/pkg/runtime/trace/</a>
</li>

<li>Introducing HTTP Tracing<br />
<a href="https://blog.golang.org/http-tracing">https://blog.golang.org/http-tracing</a>
</li>

<li>Command trace<br />
<a href="https://golang.org/cmd/trace/">https://golang.org/cmd/trace/</a>
</li>

<li>A StreamLike, Immutable, Lazy Loading and smart Golang Library to deal with slices<br />
<a href="https://github.com/wesovilabs/koazee">https://github.com/wesovilabs/koazee</a>
</li>

<li>Funkce vyššího řádu v knihovně Underscore<br />
<a href="https://www.root.cz/clanky/funkce-vyssiho-radu-v-knihovne-underscore/">https://www.root.cz/clanky/funkce-vyssiho-radu-v-knihovne-underscore/</a>
</li>

<li>Delve: a debugger for the Go programming language.<br />
<a href="https://github.com/go-delve/delve">https://github.com/go-delve/delve</a>
</li>

<li>Příkazy debuggeru Delve<br />
<a href="https://github.com/go-delve/delve/tree/master/Documentation/cli">https://github.com/go-delve/delve/tree/master/Documentation/cli</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (2. část)<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v&nbsp;editorech Emacs a Vim<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Debugging Go Code with GDB<br />
<a href="https://golang.org/doc/gdb">https://golang.org/doc/gdb</a>
</li>

<li>Debugging Go (golang) programs with gdb <br />
<a href="https://thornydev.blogspot.com/2014/01/debugging-go-golang-programs-with-gdb.html">https://thornydev.blogspot.com/2014/01/debugging-go-golang-programs-with-gdb.html</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>GDB - Supported Languages<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>13 Linux Debuggers for C++ Reviewed<br />
<a href="http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817">http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817</a>
</li>

<li>Go is on a Trajectory to Become the Next Enterprise Programming Language<br />
<a href="https://hackernoon.com/go-is-on-a-trajectory-to-become-the-next-enterprise-programming-language-3b75d70544e">https://hackernoon.com/go-is-on-a-trajectory-to-become-the-next-enterprise-programming-language-3b75d70544e</a>
</li>

<li>Go Proverbs: Simple, Poetic, Pithy<br />
<a href="https://go-proverbs.github.io/">https://go-proverbs.github.io/</a>
</li>

<li>Handling Sparse Files on Linux<br />
<a href="https://www.systutorials.com/136652/handling-sparse-files-on-linux/">https://www.systutorials.com/136652/handling-sparse-files-on-linux/</a>
</li>

<li>Gzip (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Gzip">https://en.wikipedia.org/wiki/Gzip</a>
</li>

<li>Deflate<br />
<a href="https://en.wikipedia.org/wiki/DEFLATE">https://en.wikipedia.org/wiki/DEFLATE</a>
</li>

<li>10 tools written in Go that every developer needs to know<br />
<a href="https://gustavohenrique.net/en/2019/01/10-tools-written-in-go-that-every-dev-needs-to-know/">https://gustavohenrique.net/en/2019/01/10-tools-written-in-go-that-every-dev-needs-to-know/</a>
</li>

<li>Hexadecimální prohlížeče a editory s textovým uživatelským rozhraním<br />
<a href="https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/">https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/</a>
</li>

<li>Hex dump<br />
<a href="https://en.wikipedia.org/wiki/Hex_dump">https://en.wikipedia.org/wiki/Hex_dump</a>
</li>

<li>Rozhraní io.ByteReader<br />
<a href="https://golang.org/pkg/io/#ByteReader">https://golang.org/pkg/io/#ByteReader</a>
</li>

<li>Rozhraní io.RuneReader<br />
<a href="https://golang.org/pkg/io/#RuneReader">https://golang.org/pkg/io/#RuneReader</a>
</li>

<li>Rozhraní io.ByteScanner<br />
<a href="https://golang.org/pkg/io/#ByteScanner">https://golang.org/pkg/io/#ByteScanner</a>
</li>

<li>Rozhraní io.RuneScanner<br />
<a href="https://golang.org/pkg/io/#RuneScanner">https://golang.org/pkg/io/#RuneScanner</a>
</li>

<li>Rozhraní io.Closer<br />
<a href="https://golang.org/pkg/io/#Closer">https://golang.org/pkg/io/#Closer</a>
</li>

<li>Rozhraní io.Reader<br />
<a href="https://golang.org/pkg/io/#Reader">https://golang.org/pkg/io/#Reader</a>
</li>

<li>Rozhraní io.Writer<br />
<a href="https://golang.org/pkg/io/#Writer">https://golang.org/pkg/io/#Writer</a>
</li>

<li>Typ Strings.Reader<br />
<a href="https://golang.org/pkg/strings/#Reader">https://golang.org/pkg/strings/#Reader</a>
</li>

<li>VACUUM (SQL)<br />
<a href="https://www.sqlite.org/lang_vacuum.html">https://www.sqlite.org/lang_vacuum.html</a>
</li>

<li>VACUUM (Postgres)<br />
<a href="https://www.postgresql.org/docs/8.4/sql-vacuum.html">https://www.postgresql.org/docs/8.4/sql-vacuum.html</a>
</li>

<li>go-cron<br />
<a href="https://github.com/rk/go-cron">https://github.com/rk/go-cron</a>
</li>

<li>gocron<br />
<a href="https://github.com/jasonlvhit/gocron">https://github.com/jasonlvhit/gocron</a>
</li>

<li>clockwork<br />
<a href="https://github.com/whiteShtef/clockwork">https://github.com/whiteShtef/clockwork</a>
</li>

<li>clockwerk<br />
<a href="https://github.com/onatm/clockwerk">https://github.com/onatm/clockwerk</a>
</li>

<li>JobRunner<br />
<a href="https://github.com/bamzi/jobrunner">https://github.com/bamzi/jobrunner</a>
</li>

<li>Rethinking Cron<br />
<a href="https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/">https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/</a>
</li>

<li>In the Beginning was the Command Line<br />
<a href="https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html">https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html</a>
</li>

<li>repl.it (REPL pro různé jazyky)<br />
<a href="https://repl.it/languages">https://repl.it/languages</a>
</li>

<li>GOCUI - Go Console User Interface (celé uživatelské prostředí, nejenom input box)<br />
<a href="https://github.com/jroimartin/gocui">https://github.com/jroimartin/gocui</a>
</li>

<li>Read–eval–print loop<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>go-prompt<br />
<a href="https://github.com/c-bata/go-prompt">https://github.com/c-bata/go-prompt</a>
</li>

<li>readline<br />
<a href="https://github.com/chzyer/readline">https://github.com/chzyer/readline</a>
</li>

<li>A pure golang implementation for GNU-Readline kind library<br />
<a href="https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/">https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/</a>
</li>

<li>go-readline<br />
<a href="https://github.com/fiorix/go-readline">https://github.com/fiorix/go-readline</a>
</li>

<li>4 Python libraries for building great command-line user interfaces<br />
<a href="https://opensource.com/article/17/5/4-practical-python-libraries">https://opensource.com/article/17/5/4-practical-python-libraries</a>
</li>

<li>prompt_toolkit 2.0.3 na PyPi<br />
<a href="https://pypi.org/project/prompt_toolkit/">https://pypi.org/project/prompt_toolkit/</a>
</li>

<li>python-prompt-toolkit na GitHubu<br />
<a href="https://github.com/jonathanslenders/python-prompt-toolkit">https://github.com/jonathanslenders/python-prompt-toolkit</a>
</li>

<li>The GNU Readline Library<br />
<a href="https://tiswww.case.edu/php/chet/readline/rltop.html">https://tiswww.case.edu/php/chet/readline/rltop.html</a>
</li>

<li>GNU Readline (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Readline">https://en.wikipedia.org/wiki/GNU_Readline</a>
</li>

<li>readline — GNU readline interface (Python 3.x)<br />
<a href="https://docs.python.org/3/library/readline.html">https://docs.python.org/3/library/readline.html</a>
</li>

<li>readline — GNU readline interface (Python 2.x)<br />
<a href="https://docs.python.org/2/library/readline.html">https://docs.python.org/2/library/readline.html</a>
</li>

<li>GNU Readline Library - command line editing<br />
<a href="https://tiswww.cwru.edu/php/chet/readline/readline.html">https://tiswww.cwru.edu/php/chet/readline/readline.html</a>
</li>

<li>gnureadline 6.3.8 na PyPi<br />
<a href="https://pypi.org/project/gnureadline/">https://pypi.org/project/gnureadline/</a>
</li>

<li>Editline Library (libedit)<br />
<a href="http://thrysoee.dk/editline/">http://thrysoee.dk/editline/</a>
</li>

<li>Comparing Python Command-Line Parsing Libraries – Argparse, Docopt, and Click<br />
<a href="https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/">https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/</a>
</li>

<li>libedit or editline<br />
<a href="http://www.cs.utah.edu/~bigler/code/libedit.html">http://www.cs.utah.edu/~bigler/code/libedit.html</a>
</li>

<li>WinEditLine<br />
<a href="http://mingweditline.sourceforge.net/">http://mingweditline.sourceforge.net/</a>
</li>

<li>rlcompleter — Completion function for GNU readline<br />
<a href="https://docs.python.org/3/library/rlcompleter.html">https://docs.python.org/3/library/rlcompleter.html</a>
</li>

<li>rlwrap na GitHubu<br />
<a href="https://github.com/hanslub42/rlwrap">https://github.com/hanslub42/rlwrap</a>
</li>

<li>rlwrap(1) - Linux man page<br />
<a href="https://linux.die.net/man/1/rlwrap">https://linux.die.net/man/1/rlwrap</a>
</li>

<li>readline(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/readline">https://linux.die.net/man/3/readline</a>
</li>

<li>history(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/history">https://linux.die.net/man/3/history</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>oglematchers</i><br />
<a href="https://godoc.org/github.com/jacobsa/oglematchers">https://godoc.org/github.com/jacobsa/oglematchers</a>
</li>

<li>Balíček <i>oglematchers</i><br />
<a href="https://github.com/jacobsa/oglematchers">https://github.com/jacobsa/oglematchers</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>ogletest</i><br />
<a href="https://godoc.org/github.com/jacobsa/ogletest">https://godoc.org/github.com/jacobsa/ogletest</a>
</li>

<li>Balíček <i>ogletest</i><br />
<a href="https://github.com/jacobsa/ogletest">https://github.com/jacobsa/ogletest</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>assert</i><br />
<a href="https://godoc.org/github.com/stretchr/testify/assert">https://godoc.org/github.com/stretchr/testify/assert</a>
</li>

<li>Testify - Thou Shalt Write Tests<br />
<a href="https://github.com/stretchr/testify/">https://github.com/stretchr/testify/</a>
</li>

<li>package testing<br />
<a href="https://golang.org/pkg/testing/">https://golang.org/pkg/testing/</a>
</li>

<li>Golang basics - writing unit tests<br />
<a href="https://blog.alexellis.io/golang-writing-unit-tests/">https://blog.alexellis.io/golang-writing-unit-tests/</a>
</li>

<li>An Introduction to Programming in Go / Testing<br />
<a href="https://www.golang-book.com/books/intro/12">https://www.golang-book.com/books/intro/12</a>
</li>

<li>An Introduction to Testing in Go<br />
<a href="https://tutorialedge.net/golang/intro-testing-in-go/">https://tutorialedge.net/golang/intro-testing-in-go/</a>
</li>

<li>Advanced Go Testing Tutorial<br />
<a href="https://tutorialedge.net/golang/advanced-go-testing-tutorial/">https://tutorialedge.net/golang/advanced-go-testing-tutorial/</a>
</li>

<li>GoConvey<br />
<a href="http://goconvey.co/">http://goconvey.co/</a>
</li>

<li>Testing Techniques<br />
<a href="https://talks.golang.org/2014/testing.slide">https://talks.golang.org/2014/testing.slide</a>
</li>

<li>5 simple tips and tricks for writing unit tests in #golang<br />
<a href="https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742">https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742</a>
</li>

<li>Afinní transformace<br />
<a href="https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic">https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic</a>
</li>

<li>package gg<br />
<a href="https://godoc.org/github.com/fogleman/gg">https://godoc.org/github.com/fogleman/gg</a>
</li>

<li>Generate an animated GIF with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/">http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/</a>
</li>

<li>Generate an image programmatically with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/">http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/</a>
</li>

<li>The Go image package<br />
<a href="https://blog.golang.org/go-image-package">https://blog.golang.org/go-image-package</a>
</li>

<li>Balíček draw2D: 2D rendering for different output (raster, pdf, svg)<br />
<a href="https://github.com/llgcode/draw2d">https://github.com/llgcode/draw2d</a>
</li>

<li>Draw a rectangle in Golang?<br />
<a href="https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang">https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang</a>
</li>

<li>YAML<br />
<a href="https://yaml.org/">https://yaml.org/</a>
</li>

<li>edn<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Smile<br />
<a href="https://github.com/FasterXML/smile-format-specification">https://github.com/FasterXML/smile-format-specification</a>
</li>

<li>Protocol-Buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>Marshalling (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
</li>

<li>Unmarshalling<br />
<a href="https://en.wikipedia.org/wiki/Unmarshalling">https://en.wikipedia.org/wiki/Unmarshalling</a>
</li>

<li>Introducing JSON<br />
<a href="http://json.org/">http://json.org/</a>
</li>

<li>Package json<br />
<a href="https://golang.org/pkg/encoding/json/">https://golang.org/pkg/encoding/json/</a>
</li>

<li>The Go Blog: JSON and Go<br />
<a href="https://blog.golang.org/json-and-go">https://blog.golang.org/json-and-go</a>
</li>

<li>Go by Example: JSON<br />
<a href="https://gobyexample.com/json">https://gobyexample.com/json</a>
</li>

<li>Writing Web Applications<br />
<a href="https://golang.org/doc/articles/wiki/">https://golang.org/doc/articles/wiki/</a>
</li>

<li>Golang Web Apps<br />
<a href="https://www.reinbach.com/blog/golang-webapps-1/">https://www.reinbach.com/blog/golang-webapps-1/</a>
</li>

<li>Build web application with Golang<br />
<a href="https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details">https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details</a>
</li>

<li>Golang Templates - Golang Web Pages<br />
<a href="https://www.youtube.com/watch?v=TkNIETmF-RU">https://www.youtube.com/watch?v=TkNIETmF-RU</a>
</li>

<li>Simple Golang HTTPS/TLS Examples<br />
<a href="https://github.com/denji/golang-tls">https://github.com/denji/golang-tls</a>
</li>

<li>Playing with images in HTTP response in golang<br />
<a href="https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang">https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang</a>
</li>

<li>MIME Types List<br />
<a href="https://www.freeformatter.com/mime-types-list.html">https://www.freeformatter.com/mime-types-list.html</a>
</li>

<li>Go Mutex Tutorial<br />
<a href="https://tutorialedge.net/golang/go-mutex-tutorial/">https://tutorialedge.net/golang/go-mutex-tutorial/</a>
</li>

<li>Creating A Simple Web Server With Golang<br />
<a href="https://tutorialedge.net/golang/creating-simple-web-server-with-golang/">https://tutorialedge.net/golang/creating-simple-web-server-with-golang/</a>
</li>

<li>Building a Web Server in Go<br />
<a href="https://thenewstack.io/building-a-web-server-in-go/">https://thenewstack.io/building-a-web-server-in-go/</a>
</li>

<li>How big is the pipe buffer?<br />
<a href="https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer">https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer</a>
</li>

<li>How to turn off buffering of stdout in C<br />
<a href="https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c">https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c</a>
</li>

<li>setbuf(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/setbuf">https://linux.die.net/man/3/setbuf</a>
</li>

<li>setvbuf(3) - Linux man page (stejný obsah jako předchozí stránka)<br />
<a href="https://linux.die.net/man/3/setvbuf">https://linux.die.net/man/3/setvbuf</a>
</li>

<li>Select waits on a group of channels<br />
<a href="https://yourbasic.org/golang/select-explained/">https://yourbasic.org/golang/select-explained/</a>
</li>

<li>Rob Pike: Simplicity is Complicated (video)<br />
<a href="http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893">http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893</a>
</li>

<li>Algorithms to Go<br />
<a href="https://yourbasic.org/">https://yourbasic.org/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů: vlastní filtry a lexery<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/</a>
</li>

<li>Go Defer Simplified with Practical Visuals<br />
<a href="https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff">https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff</a>
</li>

<li>5 More Gotchas of Defer in Go — Part II<br />
<a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa">https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa</a>
</li>

<li>The Go Blog: Defer, Panic, and Recover<br />
<a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a>
</li>

<li>The defer keyword in Swift 2: try/finally done right<br />
<a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer">https://www.hackingwithswift.com/new-syntax-swift-2-defer</a>
</li>

<li>Swift Defer Statement<br />
<a href="https://andybargh.com/swift-defer-statement/">https://andybargh.com/swift-defer-statement/</a>
</li>

<li>Modulo operation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Modulo_operation">https://en.wikipedia.org/wiki/Modulo_operation</a>
</li>

<li>Node.js vs Golang: Battle of the Next-Gen Languages<br />
<a href="https://www.hostingadvice.com/blog/nodejs-vs-golang/">https://www.hostingadvice.com/blog/nodejs-vs-golang/</a>
</li>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go<br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>JavaScript vs. Golang for IoT: Is Gopher Winning?<br />
<a href="https://www.iotforall.com/javascript-vs-golang-iot/">https://www.iotforall.com/javascript-vs-golang-iot/</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

<li>Printf Format Strings<br />
<a href="https://www.cprogramming.com/tutorial/printf-format-strings.html">https://www.cprogramming.com/tutorial/printf-format-strings.html</a>
</li>

<li>Java: String.format<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-</a>
</li>

<li>Java: format string syntax<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a>
</li>

<li>Selectors<br />
<a href="https://golang.org/ref/spec#Selectors">https://golang.org/ref/spec#Selectors</a>
</li>

<li>Calling Go code from Python code<br />
<a href="http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/">http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/</a>
</li>

<li>Go Data Structures: Interfaces <br />
<a href="https://research.swtch.com/interfaces">https://research.swtch.com/interfaces</a>
</li>

<li>How to use interfaces in Go<br />
<a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go</a>
</li>

<li>Interfaces in Go (part I)<br />
<a href="https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c">https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c</a>
</li>

<li>Part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>What about Trait support in Golang?<br />
<a href="https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/">https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/</a>
</li>

<li>Don't Get Bitten by Pointer vs Non-Pointer Method Receivers in Golang<br />
<a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/">https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/</a>
</li>

<li>Control Flow<br />
<a href="https://en.wikipedia.org/wiki/Control_flow">https://en.wikipedia.org/wiki/Control_flow</a>
</li>

<li>Structured programming<br />
<a href="https://en.wikipedia.org/wiki/Structured_programming">https://en.wikipedia.org/wiki/Structured_programming</a>
</li>

<li>Control Structures<br />
<a href="https://www.golang-book.com/books/intro/5">https://www.golang-book.com/books/intro/5</a>
</li>

<li>Control structures - Go if else statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html">http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html</a>
</li>

<li>Control structures - Go switch case statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html</a>
</li>

<li>Control structures - Go for loop, break, continue, range<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html</a>
</li>

<li>Goroutine IDs<br />
<a href="https://blog.sgmansfield.com/2015/12/goroutine-ids/">https://blog.sgmansfield.com/2015/12/goroutine-ids/</a>
</li>

<li>Different ways to pass channels as arguments in function in go (golang)<br />
<a href="https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang">https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang</a>
</li>

<li>justforfunc #22: using the Go execution tracer<br />
<a href="https://www.youtube.com/watch?v=ySy3sR1LFCQ">https://www.youtube.com/watch?v=ySy3sR1LFCQ</a>
</li>

<li>Single Function Exit Point<br />
<a href="http://wiki.c2.com/?SingleFunctionExitPoint">http://wiki.c2.com/?SingleFunctionExitPoint</a>
</li>

<li>Entry point<br />
<a href="https://en.wikipedia.org/wiki/Entry_point">https://en.wikipedia.org/wiki/Entry_point</a>
</li>

<li>Why does Go have a GOTO statement?!<br />
<a href="https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/">https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/</a>
</li>

<li>Effective Go<br />
<a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a>
</li>

<li>GoClipse: an Eclipse IDE for the Go programming language<br />
<a href="http://goclipse.github.io/">http://goclipse.github.io/</a>
</li>

<li>GoClipse Installation<br />
<a href="https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation">https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation</a>
</li>

<li>The zero value of a slice is not nil<br />
<a href="https://stackoverflow.com/questions/30806931/the-zero-value-of-a-slice-is-not-nil">https://stackoverflow.com/questions/30806931/the-zero-value-of-a-slice-is-not-nil</a>
</li>

<li>Go-tcha: When nil != nil<br />
<a href="https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic">https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic</a>
</li>

<li>Nils in Go<br />
<a href="https://www.doxsey.net/blog/nils-in-go">https://www.doxsey.net/blog/nils-in-go</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

