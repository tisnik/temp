<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Sledování vybraných metrik služeb naprogramovaných v jazyku Go</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Sledování vybraných metrik služeb naprogramovaných v jazyku Go</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve třicáté první části seriálu o programovacím jazyku Go si na několika demonstračních příkladech ukážeme, jakým způsobem je možné zařídit, aby dlouhodobě běžící aplikace (webové servery, služby či démoni) poskytovaly dalším nástrojům různé metriky i ostatní užitečné údaje.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Sledování vybraných metrik služeb naprogramovaných v&nbsp;jazyku Go</a></p>
<p><a href="#k02">2. Nativní aplikace vytvořená v&nbsp;Go versus aplikace běžící ve virtuálních strojích</a></p>
<p><a href="#k03">3. Zopakování z&nbsp;minula: jednoduchý HTTP server s&nbsp;dynamicky generovaným obsahem</a></p>
<p><a href="#k04">4. Zveřejnění obsahu čítačů přes explicitně naprogramované koncové body API</a></p>
<p><a href="#k05">5. Mutex pro synchronizaci změny obsahu čítače</a></p>
<p><a href="#k06">6. Použití funkcí zajišťujících atomickou změnou hodnoty pro realizaci čítačů</a></p>
<p><a href="#k07">7. Úprava HTTP serveru s&nbsp;čítači s&nbsp;atomickou změnou hodnoty</a></p>
<p><a href="#k08">8. Balíček <strong>expvar</strong></a></p>
<p><a href="#k09">9. Úprava HTTP serveru tak, aby byly čítače dostupné přes standardní rozhraní</a></p>
<p><a href="#k10">10. Úprava předchozího příkladu a odstranění globálních proměnných ze zdrojového kódu</a></p>
<p><a href="#k11">11. Současné zveřejnění metrik i profilovacích informací</a></p>
<p><a href="#k12">12. Nový demonstrační příklad: vykreslování Mandelbrotovy množiny se zaznamenáváním důležitých statistických informací</a></p>
<p><a href="#k13">13. Sledování činnosti HTTP serveru</a></p>
<p><a href="#k14">14. Zpracování metrik programově</a></p>
<p><a href="#k15">15. Složitější skript: uložení výsledků do tabulky ve formátu CSV</a></p>
<p><a href="#k16">16. Kumulativní časy</a></p>
<p><a href="#k17">17. Další datové typy podporované modulem <strong>expvar</strong></a></p>
<p><a href="#k18">18. Dodatek: různé metody práce s&nbsp;čítačem zvyšovaným v&nbsp;gorutinách</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Sledování vybraných metrik služeb naprogramovaných v&nbsp;jazyku Go</h2>

<p><a
href="https://www.root.cz/clanky/trasovani-a-profilovani-aplikaci-naprogramovanych-v-go-dokonceni/">V&nbsp;předchozí
části</a> <a href="https://www.root.cz/serialy/programovaci-jazyk-go/">seriálu
o programovacím jazyku Go</a> jsme si mj.&nbsp;řekli, že virtuální stroje,
v&nbsp;nichž běží takzvané <i>managed</i> aplikace, dokážou dalším nástrojům
(profilerům, debuggerům, monitorovacím aplikacím atd.) poskytovat důležité
metriky a dokonce umožňují, aby aplikace sama zveřejňovala ty údaje, které jsou
nutné například pro její korektní monitoring (počet aktuálně přihlášených
uživatelů, stav připojení do databází apod.). Jako velmi dobrý příklad
z&nbsp;praxe jsme si uvedli virtuální stroj programovacího jazyka Java (JVM),
který pro poskytování podobných informací nabízí hned několik rozhraní
spadajících pod obecný název <i>JPDA</i> neboli <i>Java Platform Debugger
Architecture</i>; patří sem především rozhraní <i>JVM TI (Java Virtual Machine
Tools Interface)</i>, <i>JDWP (Java Debug Wire Protocol)</i> a <i>JDI (Java
Debug Interface)</i>. Kromě toho může sama aplikace zveřejňovat prakticky
libovolné údaje přes rozhraní <i>JMX</i>, které lze využít například ze
standardního nástroje <i>JConsole</i>.</p>

<a href="https://www.root.cz/obrazek/352784/"><img src="https://i.iinfo.cz/images/284/amq1-9-prev.png" class="image-352784" alt="*" width="324" height="270"></a>
<p><i>Obrázek 1: Ovládání front message brokera Apache Active MQ (AMQ) ze
standardního nástroje JConsole. Povšimněte si, že je možné mj.&nbsp;i přímo
ovládat samotné fronty a jejich obsah.</i></p>

<p><div class="rs-tip-major">Poznámka: možnosti rozhraní <i>JMX</i> jsou ve
skutečnosti mnohem rozsáhlejší, protože lze velmi snadno zajistit, aby se
atributy zveřejněných objektů mohly měnit a aby bylo dokonce možné volat jejich
metody, a to přímo z&nbsp;již zmíněné <i>JConsole</i> nebo podobného nástroje.
Tento přístup se používá při ovládání některých služeb, například <i>Apache
Active MQ (AMQ)</i> (viz předchozí screenshot), s&nbsp;níž jsme se <a
href="https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/">seznámili</a>
v&nbsp;<a href="https://www.root.cz/serialy/message-brokery/">seriálu o message
brokerech</a>.</div></p>

<a href="https://www.root.cz/obrazek/352785/"><img src="https://i.iinfo.cz/images/284/amq1-10-prev.png" class="image-352785" alt="*" width="324" height="270"></a>
<p><i>Obrázek 2: Vpravo nahoře jsou vypsány všechny dostupné fronty běžícího
serveru Apache Active MQ, přesněji řečeno datové typy, kterými jsou
reprezentovány.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nativní aplikace vytvořená v&nbsp;Go versus aplikace běžící ve virtuálních strojích</h2>

<p>Programovací jazyk Go se v&nbsp;mnoha ohledech odlišuje od jazyků
umožňujících běh aplikací ve specializovaných virtuálních strojích. Je tomu tak
především z&nbsp;toho důvodu, že výsledkem překladu (s&nbsp;následným
linkováním) je v&nbsp;případě jazyka Go binární spustitelná nativní aplikace
obsahující i všechny potřebné knihovny, a to včetně modulu pro automatickou
správu paměti apod. (naopak aplikace naprogramované v&nbsp;Javě jsou přeloženy
do bajtkódu, který je JITovaný ve virtuálním stroji). Proto asi nebude velkým
překvapením zjištění, že možnosti Go jsou odlišné, ovšem pokud je skutečně
nutné, aby byla dlouhodobě běžící aplikace nějakým způsobem sledována, je to
možné zařídit, a to dokonce relativně jednoduchým způsobem. Již minule jsme si
řekli, jakým způsobem je možné zajistit, aby aplikace (například webové server
nebo jiná síťová služba) poskytovala všechny profilovací informace. Připomeňme
si, že dostačuje, aby taková aplikace provedla import balíčku
<strong>net/http/pprof</strong> a popř.&nbsp;nastartovala webový server (pokud
ovšem taková služba sama není webovým serverem, potom už se pochopitelně další
HTTP server spouštět nemusí):</p>

<pre>
import (
        _ "net/http/pprof"
)
</pre>

<p>Profilovací informace takto nastavené aplikace budou dostupné z&nbsp;každého
webového prohlížeče po zadání cesty <strong>/debug/pprof</strong>, což jsme si
již ukázali minule na několika demonstračních příkladech. Příklad výsledku:</p>

<a href="https://www.root.cz/obrazek/363615/"><img src="https://i.iinfo.cz/images/403/go30-3-prev.png" class="image-363615" alt="&#160;" width="370" height="179" /></a>
<p><i>Obrázek 3: Úvodní stránka s&nbsp;profilovacími informacemi běžícího HTTP
serveru.</i></p>

<p>Příklad informací o paměťovém subsystému běžící aplikace:</p>

<pre>
# runtime.MemStats
# Alloc = 1568912
# TotalAlloc = 7938176
# Sys = 72022264
# Lookups = 0
# Mallocs = 136375
# Frees = 134637
# HeapAlloc = 1568912
# HeapSys = 66617344
# HeapIdle = 64028672
# HeapInuse = 2588672
# HeapReleased = 0
# HeapObjects = 1738
# Stack = 491520 / 491520
# MSpan = 24776 / 49152
# MCache = 6912 / 16384
# BuckHashSys = 1444585
# GCSys = 2371584
# OtherSys = 1031695
# NextGC = 4194304
# LastGC = 1560699375977620410
...
...
...
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zopakování z&nbsp;minula: jednoduchý HTTP server s&nbsp;dynamicky generovaným obsahem</h2>

<p>Dnes si ukážeme druhou důležitou část celého řešení &ndash; zveřejnění těch
údajů, které budou nastavovány samotnou aplikací. Nejprve si (znovu) ukažme
velmi jednoduchý webový server, který po svém spuštění uživatelům poskytuje
jedinou dynamicky generovanou stránku a v&nbsp;ní zobrazí taktéž dynamicky
generovaný rastrový obrázek s&nbsp;náhodně obarvenými pixely. Následující
příklad vznikl úpravou (vylepšením) příkladu, s&nbsp;nímž jsme se již seznámili
<a
href="https://www.root.cz/clanky/trasovani-a-profilovani-aplikaci-naprogramovanych-v-go-dokonceni/">v&nbsp;předchozím článku</a>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "image"
        "image/color"
        "image/png"
        "io"
        "math/rand"
        "net/http"
)
&nbsp;
func <strong>indexPageHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "text/html")
        response := `
&lt;body&gt;
    &lt;h1&gt;Enterprise image renderer&lt;/h1&gt;
    &lt;img src="/image" width=256 height=256 /&gt;
&lt;/body&gt;`
        io.WriteString(writer, response)
}
&nbsp;
func <strong>calculateColor</strong>() color.RGBA {
        return color.RGBA{uint8(rand.Intn(255)),
                uint8(rand.Intn(255)),
                uint8(rand.Intn(255)), 255}
}
&nbsp;
func <strong>imageHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        const ImageWidth = 256
        const ImageHeight = 256
        outputimage := image.NewRGBA(image.Rectangle{image.Point{0, 0},
                image.Point{ImageWidth, ImageHeight}})
&nbsp;
        for y := 0; y &lt; ImageHeight; y++ {
                for x := 0; x &lt; ImageWidth; x++ {
                        c := calculateColor()
                        outputimage.Set(x, y, c)
                }
        }
        png.Encode(writer, outputimage)
}
&nbsp;
func <strong>main</strong>() {
        http.HandleFunc("/", indexPageHandler)
        http.HandleFunc("/image", imageHandler)
        http.ListenAndServe(":8080", nil)
}
</pre>

<img src="https://i.iinfo.cz/images/403/go30-1.png" class="image-363613" alt="&#160;" width="491" height="364" />
<p><i>Obrázek 4: Stránka s&nbsp;obrázkem generovaná HTTP serverem
implementovaným v&nbsp;předchozím demonstračním příkladu.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zveřejnění obsahu čítačů přes explicitně naprogramované koncové body API</h2>

<p>Jak by bylo možné postupovat v&nbsp;případě, že budeme chtít získat
informaci o tom, kolikrát byl vlastně obrázek vygenerován? Nic nám samozřejmě
nebrání si do aplikace přidat čítač (proměnnou typu <strong>int</strong>):</p>

<pre>
var counter int
</pre>

<p>Čítač se bude při každém překreslení obrázku zvyšovat o jedničku:</p>

<pre>
func <strong>imageHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        ...
        ...
        ...
        counter++
}
</pre>

<p>Obsah tohoto čítače můžeme zveřejnit například přes specializovaný koncový
bod (<i>endpoint</i>) rozhraní HTTP serveru. V&nbsp;tom nejjednodušším případě
může být koncový bod naprogramován zcela primitivním způsobem:</p>

<pre>
func <strong>counterHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "text/plain")
        fmt.Fprintf(writer, "Counter: %d\n", counter)
}
</pre>

<p>Navíc je samozřejmě nutné nový handler zaregistrovat při inicializaci HTTP
serveru:</p>

<pre>
http.HandleFunc("/counter", counterHandler)
</pre>

<p>Nová podoba HTTP serveru s&nbsp;implementovaným čítačem může vypadat
takto:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "image"
        "image/color"
        "image/png"
        "io"
        "math/rand"
        "net/http"
)
&nbsp;
var counter int
&nbsp;
func <strong>indexPageHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "text/html")
        response := `
&lt;body&gt;
    &lt;h1&gt;Enterprise image renderer&lt;/h1&gt;
    &lt;img src="/image" width=256 height=256 /&gt;
&lt;/body&gt;`
        io.WriteString(writer, response)
}
&nbsp;
func <strong>calculateColor</strong>() color.RGBA {
        return color.RGBA{uint8(rand.Intn(255)),
                uint8(rand.Intn(255)),
                uint8(rand.Intn(255)), 255}
}
&nbsp;
func <strong>imageHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        const ImageWidth = 256
        const ImageHeight = 256
        outputimage := image.NewRGBA(image.Rectangle{image.Point{0, 0},
                image.Point{ImageWidth, ImageHeight}})
&nbsp;
        for y := 0; y &lt; ImageHeight; y++ {
                for x := 0; x &lt; ImageWidth; x++ {
                        c := calculateColor()
                        outputimage.Set(x, y, c)
                }
        }
        png.Encode(writer, outputimage)
        counter++
}
&nbsp;
func <strong>counterHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "text/plain")
        fmt.Fprintf(writer, "Counter: %d\n", counter)
}
&nbsp;
func <strong>main</strong>() {
        http.HandleFunc("/", indexPageHandler)
        http.HandleFunc("/image", imageHandler)
        http.HandleFunc("/counter", counterHandler)
        http.ListenAndServe(":8080", nil)
}
</pre>

<p>Po spuštění serveru nám nic nebrání se dotázat na obsah čítače. Můžeme
využít například standardní nástroj <strong>curl</strong>:</p>

<pre>
$ <strong>curl localhost:8080/counter</strong>
&nbsp;
Counter: 0
</pre>

<p>A po dvojím překreslení stránky v&nbsp;prohlížeči by se měl stejným způsobem
změnit i obsah čítače:</p>

<pre>
$ <strong>curl localhost:8080/counter</strong>
&nbsp;
Counter: 2
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Mutex pro synchronizaci změny obsahu čítače</h2>

<p>Musíme však mít na paměti, že funkce s&nbsp;implementací odpovědí na
jednotlivé požadavky jsou spouštěny v&nbsp;samostatných gorutinách, takže je
nutné změnu obsahu čítače provádět takovým způsobem, aby byly změny mezi
gorutinami synchronizovány (což ovšem obecně dělat moc často nechceme, protože
se snižuje výkon aplikace) a dokonce aby změny byly dalšími gorutinami vůbec
viditelné, protože u běžných proměnných (i globálních) není viditelnost změn
v&nbsp;ostatních gorutinách nijak garantována (viz též <a
href="https://golang.org/ref/mem#tmp_6">The Go Memory Model </a>). Jedno
z&nbsp;možných řešení spočívá v&nbsp;použití klasických <i>mutexů</i>:</p>

<pre>
var counter int
var mutex = &amp;sync.Mutex{}
</pre>

<p>Čítač se bude zvyšovat v&nbsp;sekci, která bude vždy vykonána maximálně
jednou gorutinou:</p>

<pre>
mutex.Lock()
counter++
mutex.Unlock()
</pre>

<p>Celý demonstrační příklad bude po příslušných úpravách vypadat takto:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "image"
        "image/color"
        "image/png"
        "io"
        "math/rand"
        "net/http"
        "sync"
)
&nbsp;
var counter int
var mutex = &amp;sync.Mutex{}
&nbsp;
func <strong>indexPageHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "text/html")
        response := `
&lt;body&gt;
    &lt;h1&gt;Enterprise image renderer&lt;/h1&gt;
    &lt;img src="/image" width=256 height=256 /&gt;
&lt;/body&gt;`
        io.WriteString(writer, response)
}
&nbsp;
func <strong>calculateColor</strong>() color.RGBA {
        return color.RGBA{uint8(rand.Intn(255)),
                uint8(rand.Intn(255)),
                uint8(rand.Intn(255)), 255}
}
&nbsp;
func <strong>imageHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        const ImageWidth = 256
        const ImageHeight = 256
        outputimage := image.NewRGBA(image.Rectangle{image.Point{0, 0},
                image.Point{ImageWidth, ImageHeight}})
&nbsp;
        for y := 0; y &lt; ImageHeight; y++ {
                for x := 0; x &lt; ImageWidth; x++ {
                        c := calculateColor()
                        outputimage.Set(x, y, c)
                }
        }
        png.Encode(writer, outputimage)
        mutex.Lock()
        counter++
        mutex.Unlock()
}
&nbsp;
func <strong>counterHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "text/plain")
        fmt.Fprintf(writer, "Counter: %d\n", counter)
}
&nbsp;
func <strong>main</strong>() {
        http.HandleFunc("/", indexPageHandler)
        http.HandleFunc("/image", imageHandler)
        http.HandleFunc("/counter", counterHandler)
        http.ListenAndServe(":8080", nil)
}
</pre>

<p><div class="rs-tip-major">Poznámka: porovnání různých řešení synchronizace a
atomicity čítače si ukážeme <a href="#k18">v&nbsp;osmnácté
kapitole</a>.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Použití funkcí zajišťujících atomickou změnou hodnoty pro realizaci čítačů</h2>

<p>Existuje samozřejmě i další řešení, které se spoléhá na speciální funkce
zaručující, že provedou atomickou změnu hodnoty. Tyto funkce určené pro některé
základní datové typy nalezneme ve standardním balíčku
<strong>sync/atomic</strong>:</p>

<table>
<tr><th>#</th><th>Datový typ</th><th>Uložení hodnoty</th><th>Změna hodnoty</th><th>Operace CAS</th></tr>
<tr><td>1</td><td>int32</td><td>StoreInt32(addr *int32, val int32)</td><td>AddInt32(addr *int32, delta int32) (new int32)</td><td>CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</td></tr>
<tr><td>2</td><td>int64</td><td>StoreInt64(addr *int64, val int64)</td><td>AddInt64(addr *int64, delta int64) (new int64)</td><td>CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)</td></tr>
<tr><td>3</td><td>uint32</td><td>StoreUint32(addr *uint32, val uint32)</td><td>AddUint32(addr *uint32, delta uint32) (new uint32)</td><td>CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)</td></tr>
<tr><td>4</td><td>uint64</td><td>StoreUint64(addr *uint64, val uint64)</td><td>AddUint64(addr *uint64, delta uint64) (new uint64)</td><td>CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)</td></tr>
<tr><td>5</td><td>uintptr</td><td>StoreUintptr(addr *uintptr, val uintptr)</td><td>AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td><td>CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Úprava HTTP serveru s&nbsp;čítači s&nbsp;atomickou změnou hodnoty</h2>

<p>Úprava našeho HTTP serveru takovým způsobem, aby používat čítače měněné
atomickou operací (z&nbsp;pohledu ostatních gorutin), je snadná. Nejprve čítač
vytvoříme; bude se jednat o běžnou globální proměnnou:</p>

<pre>
var counter uint32
</pre>

<p>Zvýšení čítače v&nbsp;gorutině vytvořené pro obsluhu události, se provede
takto:</p>

<pre>
func <strong>imageHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        ...
        ...
        ...
        atomic.AddUint32(&amp;counter, 1)
}
</pre>

<p>Úplný zdrojový kód upraveného příkladu bude vypadat následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "image"
        "image/color"
        "image/png"
        "io"
        "math/rand"
        "net/http"
        "sync/atomic"
)
&nbsp;
var counter uint32
&nbsp;
func <strong>indexPageHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "text/html")
        response := `
&lt;body&gt;
    &lt;h1&gt;Enterprise image renderer&lt;/h1&gt;
    &lt;img src="/image" width=256 height=256 /&gt;
&lt;/body&gt;`
        io.WriteString(writer, response)
}
&nbsp;
func <strong>calculateColor</strong>() color.RGBA {
        return color.RGBA{uint8(rand.Intn(255)),
                uint8(rand.Intn(255)),
                uint8(rand.Intn(255)), 255}
}
&nbsp;
func <strong>imageHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        const ImageWidth = 256
        const ImageHeight = 256
        outputimage := image.NewRGBA(image.Rectangle{image.Point{0, 0},
                image.Point{ImageWidth, ImageHeight}})
&nbsp;
        for y := 0; y &lt; ImageHeight; y++ {
                for x := 0; x &lt; ImageWidth; x++ {
                        c := calculateColor()
                        outputimage.Set(x, y, c)
                }
        }
        png.Encode(writer, outputimage)
&nbsp;
        atomic.AddUint32(&amp;counter, 1)
}
&nbsp;
func <strong>counterHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "text/plain")
        fmt.Fprintf(writer, "Counter: %d\n", counter)
}
&nbsp;
func <strong>main</strong>() {
        http.HandleFunc("/", indexPageHandler)
        http.HandleFunc("/image", imageHandler)
        http.HandleFunc("/counter", counterHandler)
        http.ListenAndServe(":8080", nil)
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Balíček <strong>expvar</strong></h2>

<p>Ovšem nejlepší (a především i standardní) řešení spočívá v&nbsp;použití
balíčku nazvaného <strong>expvar</strong>. Tento balíček umožňuje definovat ty
proměnné, jejichž obsah bude zveřejněn interním HTTP serverem aplikace, a to na
standardní adrese <strong>/debug/vars</strong>. U těchto proměnných je
zaručeno, že jejich modifikace bude synchronizována mezi gorutinami, takže
nebudeme muset ručně pracovat s&nbsp;mutexy ani s&nbsp;atomickými datovými
typy.</p>

<p>V&nbsp;balíčku <strong>expvar</strong> je implementována podpora pro několik
datových typů <i>exportovaných proměnných</i>:</p>

<table>
<tr><th>#</th><th>Datový typ</th><th>Typ exportované proměnné</th></tr>
<tr><td>1</td><td>Int</td><td>int64</td></tr>
<tr><td>2</td><td>Float</td><td>float64</td></tr>
<tr><td>3</td><td>String</td><td>string</td></tr>
<tr><td>4</td><td>Map</td><td>Map</td></tr>
<tr><td>5</td><td>Func</td><td>funkce vracející řetězec</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: jak uvidíme dále, jedná se o uživatelské
datové typy, u nichž je mj.&nbsp;definováno i několik metod pro modifikaci
hodnot. Příkladem mohou být metody pro typ <strong>Int</strong>:</div></p>

<table>
<tr><th>#</th><th>Funkce/metoda</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>func NewInt(name string) *Int </td><td>konstruktor datového typu</td></tr>
<tr><td>2</td><td>func (v *Int) Add(delta int64)</td><td>zvýšení či snížení hodnoty o zadaný <i>offset</i></td></tr>
<tr><td>3</td><td>func (v *Int) Set(value int64)</td><td>nastavení nové hodnoty</td></tr>
<tr><td>4</td><td>func (v *Int) String() string </td><td>převod na tisknutelný řetězec</td></tr>
<tr><td>5</td><td>func (v *Int) Value() int64</td><td>získání aktuální hodnoty proměnné</td></tr>
</table>

<a href="https://www.root.cz/obrazek/364334/"><img src="https://i.iinfo.cz/images/496/go31-1-prev.png" class="image-364334" alt="&#160;" width="242" height="270" /></a>
<p><i>Obrázek 5: Hodnota čítače získaná přes standardní rozhraní runtime jazyka Go.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Úprava HTTP serveru tak, aby byly čítače dostupné přes standardní rozhraní</h2>

<p>Ukažme si nyní, jakým způsobem je nutné předělat předchozí demonstrační
příklady takovým způsobem, aby bylo počitadlo překreslení obrázku exportováno
standardním způsobem. Ve skutečnosti to není vůbec nic těžkého. Nejprve je
samozřejmě nutné importovat balíček <strong>expvar</strong> společně se všemi
ostatními balíčky, které aplikace pro svůj běh vyžaduje:</p>

<pre>
import (
        "expvar"
)
</pre>

<p>Následně můžeme vytvořit globální exportovanou proměnnou typu
<strong>Int</strong> a pojmenovat ji (pod daným jménem bude obsah proměnné
zveřejněn):</p>

<pre>
var counter = expvar.NewInt("counter")
</pre>

<p><div class="rs-tip-major">Poznámka: používání globálních proměnných je
z&nbsp;pochopitelných důvodů považováno za špatný přístup, ovšem v&nbsp;tomto
případě se jedná o nejjednodušší řešení, které umožňuje, že nemusíme obalovat
handlery HTTP serveru do <i>uzávěrů</i>. Pokud přesto budete preferovat čistší
přístup, uvedeme si příklad alternativního řešení <a
href="#k10">v&nbsp;navazující kapitole</a>.</div></p>

<p>Změnu hodnoty této proměnné můžeme provést přímo v&nbsp;handleru, který je
zavolán ve chvíli, kdy je zapotřebí vykreslit obrázek (na základě uživatelského
požadavku &ndash; <i>requestu</i>). Povšimněte si způsobu změny hodnoty
počitadla pomocí metody:</p>

<pre>
func <strong>imageHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        ...
        ...
        ...
        counter.Add(1)
}
</pre>

<p>Následuje výpis úplného zdrojového kódu upraveného demonstračního
příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "expvar"
        "fmt"
        "image"
        "image/color"
        "image/png"
        "io"
        "math/rand"
        "net/http"
)
&nbsp;
var counter = expvar.NewInt("counter")
&nbsp;
func <strong>indexPageHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "text/html")
        response := `
&lt;body&gt;
    &lt;h1&gt;Enterprise image renderer&lt;/h1&gt;
    &lt;img src="/image" width=256 height=256 /&gt;
&lt;/body&gt;`
        io.WriteString(writer, response)
}
&nbsp;
func <strong>calculateColor</strong>() color.RGBA {
        return color.RGBA{uint8(rand.Intn(255)),
                uint8(rand.Intn(255)),
                uint8(rand.Intn(255)), 255}
}
&nbsp;
func <strong>imageHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        const ImageWidth = 256
        const ImageHeight = 256
        outputimage := image.NewRGBA(image.Rectangle{image.Point{0, 0},
                image.Point{ImageWidth, ImageHeight}})
&nbsp;
        for y := 0; y &lt; ImageHeight; y++ {
                for x := 0; x &lt; ImageWidth; x++ {
                        c := calculateColor()
                        outputimage.Set(x, y, c)
                }
        }
        png.Encode(writer, outputimage)
        counter.Add(1)
}
&nbsp;
func <strong>counterHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "text/plain")
        fmt.Fprintf(writer, "Counter: %d\n", counter.Value())
}
&nbsp;
func <strong>main</strong>() {
        http.HandleFunc("/", indexPageHandler)
        http.HandleFunc("/image", imageHandler)
        http.HandleFunc("/counter", counterHandler)
        http.ListenAndServe(":8080", nil)
}
</pre>

<p>Zveřejněné proměnné a jejich obsah bude dostupný na adrese
<strong>/debug/vars</strong>, takže ho můžeme přečíst například standardní
utilitou <strong>curl</strong>:</p>

<pre>
$ <strong>curl localhost:8080/debug/vars</strong>
&nbsp;
{
"cmdline": ["/tmp/go-build196872790/b001/exe/05_image_server_expvar"],
"counter": 0,
"memstats":
{"Alloc":285976,"TotalAlloc":285976,"Sys":70189056,"Lookups":0,"Mallocs":859,"Frees":69,"HeapAlloc":285976,"HeapSys":66715648,"HeapIdle":65724416,"HeapInuse":991232,"HeapReleased":0,"HeapObjects":790,"StackInuse":393216,"StackSys":393216,"MSpanInuse":15808,"MSpanSys":16384,"MCacheInuse":6912,"MCacheSys":16384,"BuckHashSys":2689,"GCSys":2234368,"OtherSys":810367,"NextGC":4473924,"LastGC
...
...
...
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že kromě obsahu samotného
čítače (atribut <strong>counter</strong>) se vrátily i informace o činnosti
paměťového subsystému celé aplikace, resp.&nbsp;přesněji řečeno její <i>běhové
(runtime)</i> části.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Úprava předchozího příkladu a odstranění globálních proměnných ze zdrojového kódu</h2>

<p>Předchozí demonstrační příklad ještě upravíme takovým způsobem, aby se
v&nbsp;něm nepoužívaly globální proměnné. To znamená, že do gorutin budeme
muset předávat i samotný čítač, takže se handlery upraví takto:</p>

<pre>
func <strong>imageHandler</strong>(writer http.ResponseWriter, request *http.Request, counter *expvar.Int) {
        ...
        ...
        ...
        counter.Add(1)
}
</pre>

<p>Aby bylo možné do handlerů přidat další parametr, musíme vytvořit buď
pomocnou funkci nebo uzávěr (<i>closure</i>). Ukažeme si způsob použití
uzávěru, tj.&nbsp;(zde anonymní) funkce, na kterou je navázána lokální proměnná
<strong>counter</strong> definovaná v&nbsp;nadřazené funkci
<strong>main</strong>:</p>

<pre>
http.HandleFunc("/image",
        func(writer http.ResponseWriter, request *http.Request) { imageHandler(writer, request, counter) })
</pre>

<p>Úplný zdrojový kód příkladu vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "expvar"
        "fmt"
        "image"
        "image/color"
        "image/png"
        "io"
        "math/rand"
        "net/http"
)
&nbsp;
func <strong>indexPageHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "text/html")
        response := `
&lt;body&gt;
    &lt;h1&gt;Enterprise image renderer&lt;/h1&gt;
    &lt;img src="/image" width=256 height=256 /&gt;
&lt;/body&gt;`
        io.WriteString(writer, response)
}
&nbsp;
func <strong>calculateColor</strong>() color.RGBA {
        return color.RGBA{uint8(rand.Intn(255)),
                uint8(rand.Intn(255)),
                uint8(rand.Intn(255)), 255}
}
&nbsp;
func <strong>imageHandler</strong>(writer http.ResponseWriter, request *http.Request, counter *expvar.Int) {
        const ImageWidth = 256
        const ImageHeight = 256
        outputimage := image.NewRGBA(image.Rectangle{image.Point{0, 0},
                image.Point{ImageWidth, ImageHeight}})
&nbsp;
        for y := 0; y &lt; ImageHeight; y++ {
                for x := 0; x &lt; ImageWidth; x++ {
                        c := calculateColor()
                        outputimage.Set(x, y, c)
                }
        }
        png.Encode(writer, outputimage)
        counter.Add(1)
}
&nbsp;
func <strong>counterHandler</strong>(writer http.ResponseWriter, request *http.Request, counter *expvar.Int) {
        writer.Header().Set("Content-Type", "text/plain")
        fmt.Fprintf(writer, "Counter: %d\n", counter.Value())
}
&nbsp;
func <strong>main</strong>() {
        counter := expvar.NewInt("counter")
&nbsp;
        http.HandleFunc("/", indexPageHandler)
        http.HandleFunc("/image",
                func(writer http.ResponseWriter, request *http.Request) { imageHandler(writer, request, counter) })
        http.HandleFunc("/counter",
                func(writer http.ResponseWriter, request *http.Request) { counterHandler(writer, request, counter) })
        http.ListenAndServe(":8080", nil)
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Současné zveřejnění metrik i profilovacích informací</h2>

<p>Nic nám ovšem nebrání, aby aplikace zveřejňovala jak své metriky, tak i
profilovací informace (popsané minule). Řešení je jednoduché &ndash; do
předchozího příkladu pouze přidáme import balíčku
<strong>net/http/pprof</strong>. Žádné další změny není nutné v&nbsp;příkladu
dělat:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "expvar"
        "fmt"
        "image"
        "image/color"
        "image/png"
        "io"
        "math/rand"
        "net/http"
        _ "net/http/pprof"
)
&nbsp;
var counter = expvar.NewInt("counter")
&nbsp;
func <strong>indexPageHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "text/html")
        response := `
&lt;body&gt;
    &lt;h1&gt;Enterprise image renderer&lt;/h1&gt;
    &lt;img src="/image" width=256 height=256 /&gt;
&lt;/body&gt;`
        io.WriteString(writer, response)
}
&nbsp;
func <strong>calculateColor</strong>() color.RGBA {
        return color.RGBA{uint8(rand.Intn(255)),
                uint8(rand.Intn(255)),
                uint8(rand.Intn(255)), 255}
}
&nbsp;
func <strong>imageHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        const ImageWidth = 256
        const ImageHeight = 256
        outputimage := image.NewRGBA(image.Rectangle{image.Point{0, 0},
                image.Point{ImageWidth, ImageHeight}})
&nbsp;
        for y := 0; y &lt; ImageHeight; y++ {
                for x := 0; x &lt; ImageWidth; x++ {
                        c := calculateColor()
                        outputimage.Set(x, y, c)
                }
        }
        png.Encode(writer, outputimage)
        counter.Add(1)
}
&nbsp;
func <strong>counterHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "text/plain")
        fmt.Fprintf(writer, "Counter: %d\n", counter.Value())
}
&nbsp;
func <strong>main</strong>() {
        http.HandleFunc("/", indexPageHandler)
        http.HandleFunc("/image", imageHandler)
        http.HandleFunc("/counter", counterHandler)
        http.ListenAndServe(":8080", nil)
}
</pre>

<a href="https://www.root.cz/obrazek/364335/"><img src="https://i.iinfo.cz/images/496/go31-2-prev.png" class="image-364335" alt="&#160;" width="274" height="270" /></a>
<p><i>Obrázek 6: Zveřejněné profilovací informace.</i></p>

<a href="https://www.root.cz/obrazek/364336/"><img src="https://i.iinfo.cz/images/496/go31-3-prev.png" class="image-364336" alt="&#160;" width="247" height="270" /></a>
<p><i>Obrázek 7: Současně zveřejněné metriky aplikace.</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Nový demonstrační příklad: vykreslování Mandelbrotovy množiny se zaznamenáváním důležitých statistických informací</h2>

<p>V&nbsp;dalším příkladu, který vychází ze zdrojového kódu zveřejněného
minule, je zveřejněno hned několik údajů o běžící aplikaci:</p>

<ol>
<li>Počet překreslení Mandelbrotovy množiny</li>
<li>Celkový čas, který CPU strávil výpočtem Mandelbrotových množin</li>
<li>Počet překreslených (vybarvených) pixelů</li>
<li>Čas výpočtu, ovšem ve formátu čitelném člověkem</li>
</ol>

<p>Jedná se o tyto proměnné:</p>

<pre>
var renderingCounter = expvar.NewInt("renderingCounter")
var renderingDuration = expvar.NewInt("renderingDuration")
var pixelsColored = expvar.NewInt("pixelsColored")
var humanReadableDuration = expvar.NewString("humanReadableDuration")
</pre>

<p>Upravený zdrojový kód tohoto příkladu vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "expvar"
        "image"
        "image/png"
        "io"
        "net/http"
        _ "net/http/pprof"
        "time"
)
&nbsp;
var renderingCounter = expvar.NewInt("renderingCounter")
var renderingDuration = expvar.NewInt("renderingDuration")
var pixelsColored = expvar.NewInt("pixelsColored")
var humanReadableDuration = expvar.NewString("humanReadableDuration")
&nbsp;
func <strong>indexPageHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "text/html")
        response := `
&lt;body&gt;
    &lt;h1&gt;Enterprise image renderer&lt;/h1&gt;
    &lt;img src="/image" width=256 height=256 /&gt;
&lt;/body&gt;`
        io.WriteString(writer, response)
}
&nbsp;
func <strong>iterCount</strong>(cx float64, cy float64, maxiter uint) uint {
        var zx float64 = 0.0
        var zy float64 = 0.0
        var i uint = 0
        for i &lt; maxiter {
                zx2 := zx * zx
                zy2 := zy * zy
                if zx2+zy2 &gt; 4.0 {
                        break
                }
                zy = 2.0*zx*zy + cy
                zx = zx2 - zy2 + cx
                i++
        }
        return i
}
&nbsp;
func <strong>calcMandelbrot</strong>(width uint, height uint, maxiter uint, palette [][3]byte, image []byte, cy float64, done chan bool) {
        var cx float64 = -2.0
        for x := uint(0); x &lt; width; x++ {
                i := iterCount(cx, cy, maxiter)
                color := palette[i]
                image[3*x] = color[0]
                image[3*x+1] = color[1]
                image[3*x+2] = color[2]
                cx += 3.0 / float64(width)
        }
        done &lt;- true
}
&nbsp;
func <strong>writeImage</strong>(width uint, height uint, pixels []byte) *image.NRGBA {
        img := image.NewNRGBA(image.Rect(0, 0, int(width), int(height)))
        pixel := 0
&nbsp;
        for y := 0; y &lt; int(height); y++ {
                offset := img.PixOffset(0, y)
                for x := uint(0); x &lt; width; x++ {
                        img.Pix[offset] = pixels[pixel]
                        img.Pix[offset+1] = pixels[pixel+1]
                        img.Pix[offset+2] = pixels[pixel+2]
                        img.Pix[offset+3] = 0xff
                        pixel += 3
                        offset += 4
                }
        }
        return img
}
&nbsp;
func <strong>calculateFractal</strong>(width int, height int, maxiter int) []byte {
        done := make(chan bool, height)
&nbsp;
        pixels := make([]byte, width*height*3)
        offset := 0
        delta := width * 3
&nbsp;
        var cy float64 = -1.5
        for y := 0; y &lt; height; y++ {
                go calcMandelbrot(uint(width), uint(height), uint(maxiter), mandmap[:], pixels[offset:offset+delta], cy, done)
                offset += delta
                cy += 3.0 / float64(height)
        }
        for i := 0; i &lt; height; i++ {
                &lt;-done
        }
&nbsp;
        return pixels
}
&nbsp;
func <strong>imageHandler</strong>(writer http.ResponseWriter, request *http.Request) {
        const ImageWidth = 256
        const ImageHeight = 256
&nbsp;
        t1 := time.Now()
&nbsp;
        pixels := calculateFractal(ImageWidth, ImageHeight, 255)
        outputimage := writeImage(ImageWidth, ImageHeight, pixels)
        png.Encode(writer, outputimage)
&nbsp;
        t2 := time.Now()
        elapsed := t2.Sub(t1)
&nbsp;
        renderingCounter.Add(1)
        renderingDuration.Set(int64(elapsed))
        pixelsColored.Set(ImageWidth * ImageHeight)
        humanReadableDuration.Set(elapsed.String())
}
&nbsp;
func <strong>main</strong>() {
        http.HandleFunc("/", indexPageHandler)
        http.HandleFunc("/image", imageHandler)
        http.ListenAndServe(":8080", nil)
}
&nbsp;
/* taken from Fractint */
&nbsp;
var mandmap = [...][3]byte{
        {255, 255, 255}, {224, 224, 224}, {216, 216, 216}, {208, 208, 208},
        {200, 200, 200}, {192, 192, 192}, {184, 184, 184}, {176, 176, 176},
        {168, 168, 168}, {160, 160, 160}, {152, 152, 152}, {144, 144, 144},
        ...
        ...
        ...
        {240, 240, 140}, {244, 244, 152}, {244, 244, 168}, {244, 244, 180},
        {244, 244, 196}, {248, 248, 208}, {248, 248, 224}, {248, 248, 236},
        {252, 252, 252}, {248, 248, 248}, {240, 240, 240}, {232, 232, 232}}
</pre>

<img src="https://i.iinfo.cz/images/403/go30-5.png" class="image-363617" alt="&#160;" width="491" height="380" />
<p><i>Obrázek 8: Nový HTTP server v&nbsp;akci.</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Sledování činnosti HTTP serveru</h2>

<p>Pro sledování činnosti HTTP serveru, který počítá a zobrazuje rastrový
obrázek Mandelbrotovy množiny můžeme v&nbsp;tom nejjednodušším případě opět
použít nástroj <strong>curl</strong>.</p>

<p>Před prvním překreslením:</p>

<pre>
$ <strong>curl localhost:8080/debug/vars</strong>
&nbsp;
{
"cmdline": ["/tmp/go-build480851913/b001/exe/08_image_server_fractal"],
"humanReadableDuration": "",
"memstats": {"Alloc":308736,"TotalAlloc":308736,"Sys":69926912,"Lookups":0,"Mall
...
...
...
"pixelsColored": 0,
"renderingCounter": 0,
"renderingDuration": 0
}
</pre>

<p>Po dvou překresleních:</p>

<pre>
$ <strong>curl localhost:8080/debug/vars</strong>
&nbsp;
{
...
...
...
"humanReadableDuration": "44.726908ms",
...
...
...
"pixelsColored": 65536,
"renderingCounter": 2,
"renderingDuration": 44726908
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Zpracování metrik programově</h2>

<p>V&nbsp;tomto okamžiku již víme, jakým způsobem můžeme metriky popisující
aktuální stav běžící aplikace získat. Nyní nám vlastně zbývá jen
&bdquo;maličkost&ldquo; &ndash; umět získaná data zpracovat a následně nějakým
způsobem interpretovat. K&nbsp;tomuto účelu je možné použít buď již hotové
nástroje (<i>Prometheus</i> aj.), nebo data zpracovat vlastními silami, což je
samozřejmě mnohem zajímavější. Podívejme se tedy na způsob přečtení metrik
jednoduchým skriptem naprogramovaným v&nbsp;Pythonu. Pro samotný přenos dat
z&nbsp;aplikace do skriptu použijeme populární knihovnu <a
href="https://mojefedora.cz/uzitecne-knihovny-pro-python-requests-1/">Requests</a>.
První verze skriptu pouze data přečte a vypíše je na standardní výstup, bez
jejich dalšího zpracování:</p>

<pre>
import requests
&nbsp;
response = requests.get("http://localhost:8080/debug/vars")
&nbsp;
assert response.status_code == 200, "Chyba při čtení metrik: neočekávaný HTTP kód odpovědi"
&nbsp;
payload = response.json()
&nbsp;
print("Počet překreslení: ", payload["renderingCounter"])
print("Celkový čas výpočtu: ", payload["humanReadableDuration"])
</pre>

<p>Příklad výsledku činnosti tohoto skriptu:</p>

<pre>
Počet překreslení:  1
Celkový čas výpočtu:  46.758702ms
Počet obarvených pixelů:  65536
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Složitější skript: uložení výsledků do tabulky ve formátu CSV</h2>

<p>Pochopitelně nám ovšem nic nebrání v&nbsp;tom, aby skript se získanými daty
prováděl další manipulace. Jeho druhá varianta přečtená data uloží do datového
souboru <strong>mandelbrot.csv</strong>; přesněji řečeno po každém spuštění se
do tohoto souboru přidá další řádek s&nbsp;výsledky měření. Pokud tedy skript
budeme spouštět v&nbsp;pravidelných intervalech (<i>cron</i> apod.), bude
výsledkem tabulka obsahující postupný vývoj všech měřených hodnot:</p>

<pre>
import requests
import os
import csv
&nbsp;
filename = "mandelbrot.csv"
&nbsp;
response = requests.get("http://localhost:8080/debug/vars")
&nbsp;
assert response.status_code == 200, "Chyba při čtení metrik: neočekávaný HTTP kód odpovědi"
&nbsp;
payload = response.json()
&nbsp;
mode = None
write_header = False
&nbsp;
if os.path.exists(filename):
    mode = "a"
else:
    mode = "w"
    write_header = True
&nbsp;
with open(filename, mode) as csv_file:
    writer = csv.writer(csv_file, delimiter=',')
    if write_header:
        writer.writerow(("Počet překreslení", "Čas výpočtu", "Obarvených pixelů"))
    writer.writerow((payload["renderingCounter"],
                     payload["humanReadableDuration"],
                     payload["pixelsColored"]))
</pre>

<p>Příklad výstupu postupně generovaného předchozím skriptem:</p>

<pre>
Počet překreslení,Čas výpočtu,Obarvených pixelů
0,,0
1,43.446635ms,65536
2,40.86645ms,65536
6,41.091674ms,65536
</pre>

<img src="https://i.iinfo.cz/images/496/go31-4.png" class="image-364337" alt="&#160;" width="440" height="344" />
<p><i>Obrázek 9: Zobrazení tabulky v&nbsp;tabulkovém procesoru.</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Kumulativní časy</h2>

<p>Příklad samozřejmě můžeme upravit tak, aby se počítaly kumulativní časy,
obarvené pixely atd.:</p>

<pre>
renderingCounter.Add(1)
renderingDuration.Add(int64(elapsed))
pixelsColored.Add(ImageWidth * ImageHeight)
humanReadableDuration.Set(elapsed.String())
</pre>

<pre>
import requests
import os
import csv
&nbsp;
filename = "mandelbrot.csv"
&nbsp;
response = requests.get("http://localhost:8080/debug/vars")
&nbsp;
assert response.status_code == 200, "Chyba při čtení metrik: neočekávaný HTTP kód odpovědi"
&nbsp;
payload = response.json()
&nbsp;
mode = None
write_header = False
&nbsp;
if os.path.exists(filename):
    mode = "a"
else:
    mode = "w"
    write_header = True
&nbsp;
with open(filename, mode) as csv_file:
    writer = csv.writer(csv_file, delimiter=',')
    if write_header:
        writer.writerow(("Počet překreslení", "Čas výpočtu", "Obarvených pixelů", "Poslední výpočet"))
    writer.writerow((payload["renderingCounter"],
                     payload["renderingDuration"],
                     payload["pixelsColored"],
                     payload["humanReadableDuration"]))
</pre>

<p>Výsledek pěti měření (CSV formát):</p>

<pre>
Počet překreslení,Čas výpočtu,Obarvených pixelů,Poslední výpočet
0,0,0,
1,41073963,65536,41.073963ms
2,83259556,131072,42.185593ms
3,126872642,196608,43.613086ms
4,173997267,262144,47.124625ms
</pre>

<img src="https://i.iinfo.cz/images/496/go31-5.png" class="image-364338" alt="&#160;" width="534" height="328" />
<p><i>Obrázek 10: Zobrazení tabulky s&nbsp;výsledky v&nbsp;tabulkovém procesoru.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Další datové typy podporované modulem <strong>expvar</strong></h2>

<p>Při popisu možností balíčku <strong>expvar</strong> jsme se mj.&nbsp;zmínili
i o podporovaných datových typech proměnných, které může aplikace
&bdquo;zviditelnit&ldquo;. Použití datových typů <strong>Int</strong>,
<strong>Float</strong> a <strong>String</strong> je pravděpodobně zřejmé, ovšem
zajímavější je situace u zbývajících dvou typů: funkcí a map. Funkce, pokud je
použita jako typ &bdquo;zviditelněné proměnné&ldquo;, je zavolána ve chvíli,
kdy je zapotřebí získat metriky. Výsledkem této funkce jsou data, která mají
být zveřejněna:</p>

<pre>
type <strong>Metrics</strong> struct {
        Counter  int
        Duration int
}

func <strong>MetricsFunc</strong>() interface{} {
        return Metrics{
                Counter:  1,
                Duration: -1,
        }
}
</pre>

<p>Zveřejnění metriky zajistí zavolání:</p>

<pre>
expvar.Publish("metrics", expvar.Func(MetricsFunc))
</pre>

<img src="https://i.iinfo.cz/images/496/go31-6.png" class="image-364339" alt="&#160;" width="341" height="947" />
<p><i>Obrázek 11: Nově zveřejněná metrika.</i></p>


<p><a name="k18"></a></p>
<h2 id="k18">18. Dodatek: různé metody práce s&nbsp;čítačem zvyšovaným v&nbsp;gorutinách</h2>

<p>V&nbsp;předchozích kapitolách jsme se mj.&nbsp;zabývali i problémem práce
s&nbsp;obsahem proměnné, která je používána větším množstvím gorutin.
Programovací jazyk Go neobsahuje žádnou obdobu klíčového slova
<strong>volatile</strong>, což je ostatně dobře, protože význam tohoto slova je
v&nbsp;různých programovacích jazycích dosti odlišný (v&nbsp;první skupině jsou
jazyky C a C++, ve druhé pak Java a .NET). Pokud například budeme v&nbsp;Go
měnit obsah globální proměnné, a to v&nbsp;mnoha gorutinách, nebudou výsledky
odpovídat očekávání, protože operace čtení a zápisu nebudou synchronizovány. O
tom se můžeme snadno přesvědčit po spuštění následujícího příkladu, v&nbsp;němž
se obsah globálního čítače zvýší 1000&times;, ovšem výsledkem nebude hodnota
1000, ale hodnota nižší (protože dojde k&nbsp;překryvu operací čtení hodnoty
proměnné a jejího zápisu &ndash; více gorutin bude zvyšovat stejnou hodnotu
popř.&nbsp;provede zápis výsledku, který již ovšem byl jinou gorutinou
změněn):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "time"
)
&nbsp;
func <strong>main</strong>() {
        var cnt int = 0
&nbsp;
        for i := 0; i &lt; 1000; i++ {
                go func() {
                        cnt++
                }()
        }
        time.Sleep(1000 * time.Millisecond)
        fmt.Printf("%d\n", cnt)
}
</pre>

<p>Výsledek běhu tohoto programu (bude se obecně lišit s&nbsp;každým spuštěním aplikace):</p>

<pre>
952
</pre>

<p><div class="rs-tip-major">Poznámka: dokonce může dojít k&nbsp;tomu, že čítač
bude obsahovat zcela nesmyslné hodnoty, protože není zaručeno, že na všech
architekturách se vždy zapíšou současně všechny bity čítače.</div></p>

<p>Jedno z&nbsp;možných řešení tohoto problému spočívá v&nbsp;použití
synchronizace gorutin s&nbsp;využitím <i>mutexu</i> (jedna z&nbsp;forem zámku).
Před změnou obsahu čítače se gorutina pokusí o získání mutexu a pokud uspěje,
provede změnu obsahu čítače (přečtení hodnoty, zvýšení o jedničku, zápis
výsledku) a zámek opět uvolní. V&nbsp;případě, že bude zámek držen jinou
gorutinou, musí se počkat (takže se původní paralelní běh kódu v&nbsp;tomto
místě opět &bdquo;serializuje&ldquo;):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "sync"
        "time"
)
&nbsp;
func <strong>main</strong>() {
        var cnt int32 = 0
        var mutex = &amp;sync.Mutex{}
&nbsp;
        for i := 0; i &lt; 1000; i++ {
                go func() {
                        mutex.Lock()
                        cnt++
                        mutex.Unlock()
                }()
        }
        time.Sleep(1000 * time.Millisecond)
        fmt.Printf("%d\n", cnt)
}
</pre>

<p>Výsledek běhu tohoto programu:</p>

<pre>
1000
</pre>

<p>Použití mutexů ovšem není zcela bez problémů, protože při špatném
naprogramování může docházet k&nbsp;deadlockům.</p>

<p>V&nbsp;případě jednoduchého čítače je výhodnější využít spíše již zmíněný
balíček <strong>sync/atom</strong> s&nbsp;implementací atomických operací.
Interně se samozřejmě opět musí řešit nějaký typ zámku, ovšem tato činnost je
před programátorem skryta. A hlavně &ndash; nedojde k&nbsp;situaci, kdy by
programátor zapomněl zámek uvolnit nebo uvolňoval zámky ve špatném pořadí;
tudíž se eliminuje možnost vzniku deadlocku:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "sync/atomic"
        "time"
)
&nbsp;
func <strong>main</strong>() {
        var cnt int32 = 0
&nbsp;
        for i := 0; &lt; 1000; i++ {
                go func() {
                        atomic.AddInt32(&amp;cnt, 1)
                }()
        }
        time.Sleep(1000 * time.Millisecond)
        fmt.Printf("%d\n", cnt)
}
</pre>

<p>Výsledek běhu tohoto programu:</p>

<pre>
1000
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně dva megabajty), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td>1</td><td>01_image_server.go</td><td>jednoduchý HTTP server, který generuje dynamickou HTML stránku a rastrový obrázek s&nbsp;náhodnými barvami pixelů</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_31/01_image_server.go">https://github.com/tisnik/go-root/blob/master/article_31/01_image_server.go</a></td></tr>
<tr><td>2</td><td>02_image_server_counter.go</td><td>úprava HTTP serveru takovým způsobem, že je možné zobrazit i stav čítačů</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_31/02_image_server_counter.go">https://github.com/tisnik/go-root/blob/master/article_31/02_image_server_counter.go</a></td></tr>
<tr><td>3</td><td>03_image_server_counter_mutex.go</td><td>čítač je zvyšován v&nbsp;sekci synchronizované s&nbsp;ostatními gorutinami</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_31/03_image_server_counter_mutex.go">https://github.com/tisnik/go-root/blob/master/article_31/03_image_server_counter_mutex.go</a></td></tr>
<tr><td>4</td><td>04_image_server_counter_atom.go</td><td>čítač je zvyšován funkcí umožňující atomické změny proměnné</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_31/04_image_server_counter_atom.go">https://github.com/tisnik/go-root/blob/master/article_31/04_image_server_counter_atom.go</a></td></tr>
<tr><td>5</td><td>05_image_server_expvar.go</td><td>zveřejnění informací o běžící aplikaci</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_31/05_image_server_expvar.go">https://github.com/tisnik/go-root/blob/master/article_31/05_image_server_expvar.go</a></td></tr>
<tr><td>6</td><td>06_image_server_expvar_closure.go</td><td>použití uzávěrů a eliminace globálních proměnných</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_31/06_image_server_expvar_closure.go">https://github.com/tisnik/go-root/blob/master/article_31/06_image_server_expvar_closure.go</a></td></tr>
<tr><td>7</td><td>07_image_server_expvar_pprof.go</td><td>zveřejnění informací o běžící aplikaci a současně i profilovacích záznamů</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_31/07_image_server_expvar_pprof.go">https://github.com/tisnik/go-root/blob/master/article_31/07_image_server_expvar_pprof.go</a></td></tr>
<tr><td>8</td><td>08_image_server_fractal.go</td><td>generování Mandelbrotovy množiny se zveřejněním metrik</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_31/08_image_server_fractal.go">https://github.com/tisnik/go-root/blob/master/article_31/08_image_server_fractal.go</a></td></tr>
<tr><td>9</td><td>09_counter.go</td><td>čítač zvyšovaný v&nbsp;několika gorutinách</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_31/09_counter.go">https://github.com/tisnik/go-root/blob/master/article_31/09_counter.go</a></td></tr>
<tr><td>10</td><td>10_counter_lock.go</td><td>použití mutexu při přístupu k&nbsp;obsahu čítače</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_31/10_counter_lock.go">https://github.com/tisnik/go-root/blob/master/article_31/10_counter_lock.go</a></td></tr>
<tr><td>11</td><td>11_counter_atomic.go</td><td>použití funkce pro atomické zvýšení hodnoty čítače</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_31/11_counter_atomic.go">https://github.com/tisnik/go-root/blob/master/article_31/11_counter_atomic.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>get_metrics_1.py</td><td>přečtení metrik jednoduchým skriptem psaným v&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_31/get_metrics_1.py">https://github.com/tisnik/go-root/blob/master/article_31/get_metrics_1.py</a></td></tr>
<tr><td>13</td><td>get_metrics_2.py</td><td>přečtení metrik jednoduchým skriptem psaným v&nbsp;Pythonu s&nbsp;exportem do CSV</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_31/get_metrics_2.py">https://github.com/tisnik/go-root/blob/master/article_31/get_metrics_2.py</a></td></tr>
<tr><td>14</td><td>get_metrics_3.py</td><td>přečtení metrik jednoduchým skriptem psaným v&nbsp;Pythonu s&nbsp;exportem do CSV</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_31/get_metrics_3.py">https://github.com/tisnik/go-root/blob/master/article_31/get_metrics_3.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>How to instrument Go code with custom expvar metrics<br />
<a href="https://sysdig.com/blog/golang-expvar-custom-metrics/">https://sysdig.com/blog/golang-expvar-custom-metrics/</a>
</li>

<li>Golang expvar metricset (Metricbeat Reference)<br />
<a href="https://www.elastic.co/guide/en/beats/metricbeat/7.x/metricbeat-metricset-golang-expvar.html">https://www.elastic.co/guide/en/beats/metricbeat/7.x/metricbeat-metricset-golang-expvar.html</a>
</li>

<li>Package expvar<br />
<a href="https://golang.org/pkg/expvar/#NewInt">https://golang.org/pkg/expvar/#NewInt</a>
</li>

<li>Java Platform Debugger Architecture: Overview<br />
<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jpda/jpda.html">https://docs.oracle.com/en/java/javase/11/docs/specs/jpda/jpda.html</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="https://www.oracle.com/technetwork/articles/javase/index-140680.html">https://www.oracle.com/technetwork/articles/javase/index-140680.html</a>
</li>

<li>JVM Tool Interface Version 11.0<br />
<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html">https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>Go &amp; cgo: integrating existing C code with Go<br />
<a href="http://akrennmair.github.io/golang-cgo-slides/#1">http://akrennmair.github.io/golang-cgo-slides/#1</a>
</li>

<li>Using cgo to call C code from within Go code<br />
<a href="https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/">https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/</a>
</li>

<li>Package trace<br />
<a href="https://golang.org/pkg/runtime/trace/">https://golang.org/pkg/runtime/trace/</a>
</li>

<li>Introducing HTTP Tracing<br />
<a href="https://blog.golang.org/http-tracing">https://blog.golang.org/http-tracing</a>
</li>

<li>Command trace<br />
<a href="https://golang.org/cmd/trace/">https://golang.org/cmd/trace/</a>
</li>

<li>A StreamLike, Immutable, Lazy Loading and smart Golang Library to deal with slices<br />
<a href="https://github.com/wesovilabs/koazee">https://github.com/wesovilabs/koazee</a>
</li>

<li>Funkce vyššího řádu v knihovně Underscore<br />
<a href="https://www.root.cz/clanky/funkce-vyssiho-radu-v-knihovne-underscore/">https://www.root.cz/clanky/funkce-vyssiho-radu-v-knihovne-underscore/</a>
</li>

<li>Delve: a debugger for the Go programming language.<br />
<a href="https://github.com/go-delve/delve">https://github.com/go-delve/delve</a>
</li>

<li>Příkazy debuggeru Delve<br />
<a href="https://github.com/go-delve/delve/tree/master/Documentation/cli">https://github.com/go-delve/delve/tree/master/Documentation/cli</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (2. část)<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v&nbsp;editorech Emacs a Vim<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Debugging Go Code with GDB<br />
<a href="https://golang.org/doc/gdb">https://golang.org/doc/gdb</a>
</li>

<li>Debugging Go (golang) programs with gdb <br />
<a href="https://thornydev.blogspot.com/2014/01/debugging-go-golang-programs-with-gdb.html">https://thornydev.blogspot.com/2014/01/debugging-go-golang-programs-with-gdb.html</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>GDB - Supported Languages<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>13 Linux Debuggers for C++ Reviewed<br />
<a href="http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817">http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817</a>
</li>

<li>Go is on a Trajectory to Become the Next Enterprise Programming Language<br />
<a href="https://hackernoon.com/go-is-on-a-trajectory-to-become-the-next-enterprise-programming-language-3b75d70544e">https://hackernoon.com/go-is-on-a-trajectory-to-become-the-next-enterprise-programming-language-3b75d70544e</a>
</li>

<li>Go Proverbs: Simple, Poetic, Pithy<br />
<a href="https://go-proverbs.github.io/">https://go-proverbs.github.io/</a>
</li>

<li>Handling Sparse Files on Linux<br />
<a href="https://www.systutorials.com/136652/handling-sparse-files-on-linux/">https://www.systutorials.com/136652/handling-sparse-files-on-linux/</a>
</li>

<li>Gzip (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Gzip">https://en.wikipedia.org/wiki/Gzip</a>
</li>

<li>Deflate<br />
<a href="https://en.wikipedia.org/wiki/DEFLATE">https://en.wikipedia.org/wiki/DEFLATE</a>
</li>

<li>10 tools written in Go that every developer needs to know<br />
<a href="https://gustavohenrique.net/en/2019/01/10-tools-written-in-go-that-every-dev-needs-to-know/">https://gustavohenrique.net/en/2019/01/10-tools-written-in-go-that-every-dev-needs-to-know/</a>
</li>

<li>Hexadecimální prohlížeče a editory s textovým uživatelským rozhraním<br />
<a href="https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/">https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/</a>
</li>

<li>Hex dump<br />
<a href="https://en.wikipedia.org/wiki/Hex_dump">https://en.wikipedia.org/wiki/Hex_dump</a>
</li>

<li>Rozhraní io.ByteReader<br />
<a href="https://golang.org/pkg/io/#ByteReader">https://golang.org/pkg/io/#ByteReader</a>
</li>

<li>Rozhraní io.RuneReader<br />
<a href="https://golang.org/pkg/io/#RuneReader">https://golang.org/pkg/io/#RuneReader</a>
</li>

<li>Rozhraní io.ByteScanner<br />
<a href="https://golang.org/pkg/io/#ByteScanner">https://golang.org/pkg/io/#ByteScanner</a>
</li>

<li>Rozhraní io.RuneScanner<br />
<a href="https://golang.org/pkg/io/#RuneScanner">https://golang.org/pkg/io/#RuneScanner</a>
</li>

<li>Rozhraní io.Closer<br />
<a href="https://golang.org/pkg/io/#Closer">https://golang.org/pkg/io/#Closer</a>
</li>

<li>Rozhraní io.Reader<br />
<a href="https://golang.org/pkg/io/#Reader">https://golang.org/pkg/io/#Reader</a>
</li>

<li>Rozhraní io.Writer<br />
<a href="https://golang.org/pkg/io/#Writer">https://golang.org/pkg/io/#Writer</a>
</li>

<li>Typ Strings.Reader<br />
<a href="https://golang.org/pkg/strings/#Reader">https://golang.org/pkg/strings/#Reader</a>
</li>

<li>VACUUM (SQL)<br />
<a href="https://www.sqlite.org/lang_vacuum.html">https://www.sqlite.org/lang_vacuum.html</a>
</li>

<li>VACUUM (Postgres)<br />
<a href="https://www.postgresql.org/docs/8.4/sql-vacuum.html">https://www.postgresql.org/docs/8.4/sql-vacuum.html</a>
</li>

<li>go-cron<br />
<a href="https://github.com/rk/go-cron">https://github.com/rk/go-cron</a>
</li>

<li>gocron<br />
<a href="https://github.com/jasonlvhit/gocron">https://github.com/jasonlvhit/gocron</a>
</li>

<li>clockwork<br />
<a href="https://github.com/whiteShtef/clockwork">https://github.com/whiteShtef/clockwork</a>
</li>

<li>clockwerk<br />
<a href="https://github.com/onatm/clockwerk">https://github.com/onatm/clockwerk</a>
</li>

<li>JobRunner<br />
<a href="https://github.com/bamzi/jobrunner">https://github.com/bamzi/jobrunner</a>
</li>

<li>Rethinking Cron<br />
<a href="https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/">https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/</a>
</li>

<li>In the Beginning was the Command Line<br />
<a href="https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html">https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html</a>
</li>

<li>repl.it (REPL pro různé jazyky)<br />
<a href="https://repl.it/languages">https://repl.it/languages</a>
</li>

<li>GOCUI - Go Console User Interface (celé uživatelské prostředí, nejenom input box)<br />
<a href="https://github.com/jroimartin/gocui">https://github.com/jroimartin/gocui</a>
</li>

<li>Read–eval–print loop<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>go-prompt<br />
<a href="https://github.com/c-bata/go-prompt">https://github.com/c-bata/go-prompt</a>
</li>

<li>readline<br />
<a href="https://github.com/chzyer/readline">https://github.com/chzyer/readline</a>
</li>

<li>A pure golang implementation for GNU-Readline kind library<br />
<a href="https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/">https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/</a>
</li>

<li>go-readline<br />
<a href="https://github.com/fiorix/go-readline">https://github.com/fiorix/go-readline</a>
</li>

<li>4 Python libraries for building great command-line user interfaces<br />
<a href="https://opensource.com/article/17/5/4-practical-python-libraries">https://opensource.com/article/17/5/4-practical-python-libraries</a>
</li>

<li>prompt_toolkit 2.0.3 na PyPi<br />
<a href="https://pypi.org/project/prompt_toolkit/">https://pypi.org/project/prompt_toolkit/</a>
</li>

<li>python-prompt-toolkit na GitHubu<br />
<a href="https://github.com/jonathanslenders/python-prompt-toolkit">https://github.com/jonathanslenders/python-prompt-toolkit</a>
</li>

<li>The GNU Readline Library<br />
<a href="https://tiswww.case.edu/php/chet/readline/rltop.html">https://tiswww.case.edu/php/chet/readline/rltop.html</a>
</li>

<li>GNU Readline (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Readline">https://en.wikipedia.org/wiki/GNU_Readline</a>
</li>

<li>readline — GNU readline interface (Python 3.x)<br />
<a href="https://docs.python.org/3/library/readline.html">https://docs.python.org/3/library/readline.html</a>
</li>

<li>readline — GNU readline interface (Python 2.x)<br />
<a href="https://docs.python.org/2/library/readline.html">https://docs.python.org/2/library/readline.html</a>
</li>

<li>GNU Readline Library - command line editing<br />
<a href="https://tiswww.cwru.edu/php/chet/readline/readline.html">https://tiswww.cwru.edu/php/chet/readline/readline.html</a>
</li>

<li>gnureadline 6.3.8 na PyPi<br />
<a href="https://pypi.org/project/gnureadline/">https://pypi.org/project/gnureadline/</a>
</li>

<li>Editline Library (libedit)<br />
<a href="http://thrysoee.dk/editline/">http://thrysoee.dk/editline/</a>
</li>

<li>Comparing Python Command-Line Parsing Libraries – Argparse, Docopt, and Click<br />
<a href="https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/">https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/</a>
</li>

<li>libedit or editline<br />
<a href="http://www.cs.utah.edu/~bigler/code/libedit.html">http://www.cs.utah.edu/~bigler/code/libedit.html</a>
</li>

<li>WinEditLine<br />
<a href="http://mingweditline.sourceforge.net/">http://mingweditline.sourceforge.net/</a>
</li>

<li>rlcompleter — Completion function for GNU readline<br />
<a href="https://docs.python.org/3/library/rlcompleter.html">https://docs.python.org/3/library/rlcompleter.html</a>
</li>

<li>rlwrap na GitHubu<br />
<a href="https://github.com/hanslub42/rlwrap">https://github.com/hanslub42/rlwrap</a>
</li>

<li>rlwrap(1) - Linux man page<br />
<a href="https://linux.die.net/man/1/rlwrap">https://linux.die.net/man/1/rlwrap</a>
</li>

<li>readline(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/readline">https://linux.die.net/man/3/readline</a>
</li>

<li>history(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/history">https://linux.die.net/man/3/history</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>oglematchers</i><br />
<a href="https://godoc.org/github.com/jacobsa/oglematchers">https://godoc.org/github.com/jacobsa/oglematchers</a>
</li>

<li>Balíček <i>oglematchers</i><br />
<a href="https://github.com/jacobsa/oglematchers">https://github.com/jacobsa/oglematchers</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>ogletest</i><br />
<a href="https://godoc.org/github.com/jacobsa/ogletest">https://godoc.org/github.com/jacobsa/ogletest</a>
</li>

<li>Balíček <i>ogletest</i><br />
<a href="https://github.com/jacobsa/ogletest">https://github.com/jacobsa/ogletest</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>assert</i><br />
<a href="https://godoc.org/github.com/stretchr/testify/assert">https://godoc.org/github.com/stretchr/testify/assert</a>
</li>

<li>Testify - Thou Shalt Write Tests<br />
<a href="https://github.com/stretchr/testify/">https://github.com/stretchr/testify/</a>
</li>

<li>package testing<br />
<a href="https://golang.org/pkg/testing/">https://golang.org/pkg/testing/</a>
</li>

<li>Golang basics - writing unit tests<br />
<a href="https://blog.alexellis.io/golang-writing-unit-tests/">https://blog.alexellis.io/golang-writing-unit-tests/</a>
</li>

<li>An Introduction to Programming in Go / Testing<br />
<a href="https://www.golang-book.com/books/intro/12">https://www.golang-book.com/books/intro/12</a>
</li>

<li>An Introduction to Testing in Go<br />
<a href="https://tutorialedge.net/golang/intro-testing-in-go/">https://tutorialedge.net/golang/intro-testing-in-go/</a>
</li>

<li>Advanced Go Testing Tutorial<br />
<a href="https://tutorialedge.net/golang/advanced-go-testing-tutorial/">https://tutorialedge.net/golang/advanced-go-testing-tutorial/</a>
</li>

<li>GoConvey<br />
<a href="http://goconvey.co/">http://goconvey.co/</a>
</li>

<li>Testing Techniques<br />
<a href="https://talks.golang.org/2014/testing.slide">https://talks.golang.org/2014/testing.slide</a>
</li>

<li>5 simple tips and tricks for writing unit tests in #golang<br />
<a href="https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742">https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742</a>
</li>

<li>Afinní transformace<br />
<a href="https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic">https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic</a>
</li>

<li>package gg<br />
<a href="https://godoc.org/github.com/fogleman/gg">https://godoc.org/github.com/fogleman/gg</a>
</li>

<li>Generate an animated GIF with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/">http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/</a>
</li>

<li>Generate an image programmatically with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/">http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/</a>
</li>

<li>The Go image package<br />
<a href="https://blog.golang.org/go-image-package">https://blog.golang.org/go-image-package</a>
</li>

<li>Balíček draw2D: 2D rendering for different output (raster, pdf, svg)<br />
<a href="https://github.com/llgcode/draw2d">https://github.com/llgcode/draw2d</a>
</li>

<li>Draw a rectangle in Golang?<br />
<a href="https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang">https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang</a>
</li>

<li>YAML<br />
<a href="https://yaml.org/">https://yaml.org/</a>
</li>

<li>edn<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Smile<br />
<a href="https://github.com/FasterXML/smile-format-specification">https://github.com/FasterXML/smile-format-specification</a>
</li>

<li>Protocol-Buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>Marshalling (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
</li>

<li>Unmarshalling<br />
<a href="https://en.wikipedia.org/wiki/Unmarshalling">https://en.wikipedia.org/wiki/Unmarshalling</a>
</li>

<li>Introducing JSON<br />
<a href="http://json.org/">http://json.org/</a>
</li>

<li>Package json<br />
<a href="https://golang.org/pkg/encoding/json/">https://golang.org/pkg/encoding/json/</a>
</li>

<li>The Go Blog: JSON and Go<br />
<a href="https://blog.golang.org/json-and-go">https://blog.golang.org/json-and-go</a>
</li>

<li>Go by Example: JSON<br />
<a href="https://gobyexample.com/json">https://gobyexample.com/json</a>
</li>

<li>Writing Web Applications<br />
<a href="https://golang.org/doc/articles/wiki/">https://golang.org/doc/articles/wiki/</a>
</li>

<li>Golang Web Apps<br />
<a href="https://www.reinbach.com/blog/golang-webapps-1/">https://www.reinbach.com/blog/golang-webapps-1/</a>
</li>

<li>Build web application with Golang<br />
<a href="https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details">https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details</a>
</li>

<li>Golang Templates - Golang Web Pages<br />
<a href="https://www.youtube.com/watch?v=TkNIETmF-RU">https://www.youtube.com/watch?v=TkNIETmF-RU</a>
</li>

<li>Simple Golang HTTPS/TLS Examples<br />
<a href="https://github.com/denji/golang-tls">https://github.com/denji/golang-tls</a>
</li>

<li>Playing with images in HTTP response in golang<br />
<a href="https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang">https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang</a>
</li>

<li>MIME Types List<br />
<a href="https://www.freeformatter.com/mime-types-list.html">https://www.freeformatter.com/mime-types-list.html</a>
</li>

<li>Go Mutex Tutorial<br />
<a href="https://tutorialedge.net/golang/go-mutex-tutorial/">https://tutorialedge.net/golang/go-mutex-tutorial/</a>
</li>

<li>Creating A Simple Web Server With Golang<br />
<a href="https://tutorialedge.net/golang/creating-simple-web-server-with-golang/">https://tutorialedge.net/golang/creating-simple-web-server-with-golang/</a>
</li>

<li>Building a Web Server in Go<br />
<a href="https://thenewstack.io/building-a-web-server-in-go/">https://thenewstack.io/building-a-web-server-in-go/</a>
</li>

<li>How big is the pipe buffer?<br />
<a href="https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer">https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer</a>
</li>

<li>How to turn off buffering of stdout in C<br />
<a href="https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c">https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c</a>
</li>

<li>setbuf(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/setbuf">https://linux.die.net/man/3/setbuf</a>
</li>

<li>setvbuf(3) - Linux man page (stejný obsah jako předchozí stránka)<br />
<a href="https://linux.die.net/man/3/setvbuf">https://linux.die.net/man/3/setvbuf</a>
</li>

<li>Select waits on a group of channels<br />
<a href="https://yourbasic.org/golang/select-explained/">https://yourbasic.org/golang/select-explained/</a>
</li>

<li>Rob Pike: Simplicity is Complicated (video)<br />
<a href="http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893">http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893</a>
</li>

<li>Algorithms to Go<br />
<a href="https://yourbasic.org/">https://yourbasic.org/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů: vlastní filtry a lexery<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/</a>
</li>

<li>Go Defer Simplified with Practical Visuals<br />
<a href="https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff">https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff</a>
</li>

<li>5 More Gotchas of Defer in Go — Part II<br />
<a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa">https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa</a>
</li>

<li>The Go Blog: Defer, Panic, and Recover<br />
<a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a>
</li>

<li>The defer keyword in Swift 2: try/finally done right<br />
<a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer">https://www.hackingwithswift.com/new-syntax-swift-2-defer</a>
</li>

<li>Swift Defer Statement<br />
<a href="https://andybargh.com/swift-defer-statement/">https://andybargh.com/swift-defer-statement/</a>
</li>

<li>Modulo operation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Modulo_operation">https://en.wikipedia.org/wiki/Modulo_operation</a>
</li>

<li>Node.js vs Golang: Battle of the Next-Gen Languages<br />
<a href="https://www.hostingadvice.com/blog/nodejs-vs-golang/">https://www.hostingadvice.com/blog/nodejs-vs-golang/</a>
</li>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go<br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>JavaScript vs. Golang for IoT: Is Gopher Winning?<br />
<a href="https://www.iotforall.com/javascript-vs-golang-iot/">https://www.iotforall.com/javascript-vs-golang-iot/</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

<li>Printf Format Strings<br />
<a href="https://www.cprogramming.com/tutorial/printf-format-strings.html">https://www.cprogramming.com/tutorial/printf-format-strings.html</a>
</li>

<li>Java: String.format<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-</a>
</li>

<li>Java: format string syntax<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a>
</li>

<li>Selectors<br />
<a href="https://golang.org/ref/spec#Selectors">https://golang.org/ref/spec#Selectors</a>
</li>

<li>Calling Go code from Python code<br />
<a href="http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/">http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/</a>
</li>

<li>Go Data Structures: Interfaces <br />
<a href="https://research.swtch.com/interfaces">https://research.swtch.com/interfaces</a>
</li>

<li>How to use interfaces in Go<br />
<a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go</a>
</li>

<li>Interfaces in Go (part I)<br />
<a href="https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c">https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c</a>
</li>

<li>Part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>What about Trait support in Golang?<br />
<a href="https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/">https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/</a>
</li>

<li>Don't Get Bitten by Pointer vs Non-Pointer Method Receivers in Golang<br />
<a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/">https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/</a>
</li>

<li>Control Flow<br />
<a href="https://en.wikipedia.org/wiki/Control_flow">https://en.wikipedia.org/wiki/Control_flow</a>
</li>

<li>Structured programming<br />
<a href="https://en.wikipedia.org/wiki/Structured_programming">https://en.wikipedia.org/wiki/Structured_programming</a>
</li>

<li>Control Structures<br />
<a href="https://www.golang-book.com/books/intro/5">https://www.golang-book.com/books/intro/5</a>
</li>

<li>Control structures - Go if else statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html">http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html</a>
</li>

<li>Control structures - Go switch case statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html</a>
</li>

<li>Control structures - Go for loop, break, continue, range<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html</a>
</li>

<li>Goroutine IDs<br />
<a href="https://blog.sgmansfield.com/2015/12/goroutine-ids/">https://blog.sgmansfield.com/2015/12/goroutine-ids/</a>
</li>

<li>Different ways to pass channels as arguments in function in go (golang)<br />
<a href="https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang">https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang</a>
</li>

<li>justforfunc #22: using the Go execution tracer<br />
<a href="https://www.youtube.com/watch?v=ySy3sR1LFCQ">https://www.youtube.com/watch?v=ySy3sR1LFCQ</a>
</li>

<li>Single Function Exit Point<br />
<a href="http://wiki.c2.com/?SingleFunctionExitPoint">http://wiki.c2.com/?SingleFunctionExitPoint</a>
</li>

<li>Entry point<br />
<a href="https://en.wikipedia.org/wiki/Entry_point">https://en.wikipedia.org/wiki/Entry_point</a>
</li>

<li>Why does Go have a GOTO statement?!<br />
<a href="https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/">https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/</a>
</li>

<li>Effective Go<br />
<a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a>
</li>

<li>GoClipse: an Eclipse IDE for the Go programming language<br />
<a href="http://goclipse.github.io/">http://goclipse.github.io/</a>
</li>

<li>GoClipse Installation<br />
<a href="https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation">https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation</a>
</li>

<li>The zero value of a slice is not nil<br />
<a href="https://stackoverflow.com/questions/30806931/the-zero-value-of-a-slice-is-not-nil">https://stackoverflow.com/questions/30806931/the-zero-value-of-a-slice-is-not-nil</a>
</li>

<li>Go-tcha: When nil != nil<br />
<a href="https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic">https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic</a>
</li>

<li>Nils in Go<br />
<a href="https://www.doxsey.net/blog/nils-in-go">https://www.doxsey.net/blog/nils-in-go</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

