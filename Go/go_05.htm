<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Konstrukce pro řízení běhu programu v jazyce Go</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Konstrukce pro řízení běhu programu v jazyce Go</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V páté části seriálu o programovacím jazyce Go si popíšeme všechny základní syntaktické konstrukce určené pro řízení běhu programu. Jedná se o různé formy větvení a samozřejmě taktéž o programové smyčky. Některé z dále popisovaných konstrukcí jsou překvapivě flexibilní.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Konstrukce pro řízení běhu programu v&nbsp;jazyce Go</a></p>
<p><a href="#k02">2. Volání funkcí a příkaz <strong>return</strong></a></p>
<p><a href="#k03">3. Příkaz <strong>return</strong> umístěný před koncem těla funkce</a></p>
<p><a href="#k04">4. Jednoduchá rozhodovací konstrukce typu <strong>if</strong></a></p>
<p><a href="#k05">5. Rozvětvení s&nbsp;využitím konstrukce <strong>if-else</strong></a></p>
<p><a href="#k06">6. Příkaz zapsaný za klíčovým slovem <strong>if</strong></a></p>
<p><a href="#k07">7. Rozvětvení běhu programu s&nbsp;využitím konstrukce <strong>switch</strong></a></p>
<p><a href="#k08">8. Porovnání výrazu s&nbsp;konstantami a vypočtenými hodnotami v&nbsp;konstrukci <strong>switch</strong></a></p>
<p><a href="#k09">9. Vyhodnocení a porovnání výsledků podmínek zapsaných ve větvích <strong>case</strong></a></p>
<p><a href="#k10">10. Větší množství větví <strong>case</strong> se společným tělem: klíčové slovo <strong>fallthrough</strong></a></p>
<p><a href="#k11">11. Další příklady použití rozvětvení typu <strong>switch</strong></a></p>
<p><a href="#k12">12. Programové smyčky v&nbsp;jazyku Go: příkaz <strong>for</strong></a></p>
<p><a href="#k13">13. Příkaz <strong>for</strong> s&nbsp;podmínkou na začátku</a></p>
<p><a href="#k14">14. Varianta programové smyčky převzatá z&nbsp;jazyka C</a></p>
<p><a href="#k15">15. Iterace nad datovými strukturami s&nbsp;využitím <strong>for</strong> a <strong>range</strong></a></p>
<p><a href="#k16">16. Ovlivnění programových smyček příkazy <strong>break</strong> a <strong>continue</strong></a></p>
<p><a href="#k17">17. Příkazy <strong>break</strong> a <strong>continue</strong> ve vnořených smyčkách</a></p>
<p><a href="#k18">18. Návrat do minulosti: příkaz <strong>goto</strong></a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Konstrukce pro řízení běhu programu v&nbsp;jazyce Go</h2>

<p>Většina informací, které jsme si prozatím o Go řekli, se týkala především
typového systému tohoto programovacího jazyka. Typový systém totiž hraje
v&nbsp;této skupině jazyků (silné typování hlídané již v&nbsp;době překladu a
doplněné o dynamickou &bdquo;implementaci&ldquo; rozhraní kontrolovanou
v&nbsp;runtime) velmi důležitou roli. Dokonce by se mohlo říci, že u
rozsáhlejších aplikací jsou právě vlastnosti typového systému významnější, než
například syntaxe jazyka, která poněkud ustupuje do pozadí (ještě do větší míry
je to patrné u <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">programovacího
jazyku Rust</a>, v&nbsp;němž se od typového systému odvíjí například i správa
paměti).</p>

<p>Nicméně pro tvorbu reálných aplikací samozřejmě nevystačíme pouze se
znalostí typového systému jazyka. Musíme mj.&nbsp;i vědět, jak je v&nbsp;něm
řešeno větvení (rozhodovací konstrukce) a popř.&nbsp;i programové smyčky (pokud
nejsou vyřešeny <a
href="https://cs.wikipedia.org/wiki/Rekurze_(programov%C3%A1n%C3%AD)">rekurzí</a>
a popř.&nbsp;i koncovou rekurzí <a
href="https://cs.wikipedia.org/wiki/Koncov%C3%A1_rekurze">TCO</a>, což je ovšem
většinou doména funkcionálních programovacích jazyků). Z&nbsp;tohoto důvodu se
dnes seznámíme s&nbsp;těmi jazykovými konstrukcemi, které slouží pro takzvané
<i>řízení běhu programu</i>.</p>

<p>V&nbsp;případě programovacího jazyka Go se konkrétně jedná o implementaci
rozhodovacích konstrukcí a taktéž o implementaci různých typů programových
smyček. To, že konstrukce sloužící pro řízení běhu programu neodmyslitelně ke
Go patří, je dobře ilustrováno i na seznamu klíčových slov tohoto jazyka, které
jsou vypsány v&nbsp;tabulce umístěné pod tímto odstavcem. Všechna klíčová
slova, která se k&nbsp;tomuto tématu vztahují, jsou zvýrazněna odkazem (na
příslušnou kapitolu):</p>

<table>
<tr><td><a href="#k16">break</a></td><td><a href="#k07">default</a></td><td>func</td><td>interface</td><td>select</td></tr>
<tr><td><a href="#k07">case</a></td><td>defer</td><td>go</td><td>map</td><td>struct</td></tr>
<tr><td>chan</td><td><a href="#k05">else</a></td><td><a href="#k18">goto</a></td><td>package</td><td><a href="#k07">switch</a></td></tr>
<tr><td>const</td><td><a href="#k10">fallthrough</a></td><td><a href="#k04">if</a></td><td><a href="#k15">range</a></td><td>type</td></tr>
<tr><td><a href="#k16">continue</a></td><td><a href="#k12">for</a></td><td>import</td><td><a href="#k02">return</a></td><td>var</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: na tomto místě je vhodné již dopředu
upozornit na fakt, že i když se v&nbsp;jazyce Go používají konstrukce, které
mohou připomínat příkazy v&nbsp;programovacích jazycích C, C++, Java atd., je
sémantika některých konstrukcí od céčkovských jazyků odlišná! Týká se to
především konstrukce <strong>switch</strong>, v&nbsp;níž je zapotřebí
explicitně určit ty větve <strong>case</strong>, které mají společné tělo.
V&nbsp;C/C++/Javě a dalších jazycích je to přesně naopak &ndash; tam se naopak
musí jednotlivé větve, které nemají mít společné příkazy, explicitně ukončovat
příkazem <strong>break</strong>! Podrobnosti si samozřejmě ukážeme i na
demonstračních příkladech. Taktéž je již dopředu dobré upozornit na to, že
některé řídicí konstrukce v&nbsp;Go zdánlivě či zcela záměrně chybí. Jedná se
konkrétně o programové smyčky <strong>while</strong> (je nahrazena
univerzálnějším příkazem <strong>for</strong>) a taktéž o smyčku
<strong>do-while</strong>.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Volání funkcí a příkaz <strong>return</strong></h2>

<p>Připomeňme si jen ve stručnosti, že základním stavebním prvkem, z&nbsp;něhož
je možné v&nbsp;jazyce Go skládat složitější algoritmy, jsou funkce. Ty mají
jeden vstupní bod (<i>entry point</i>) a pokud ve funkci explicitně nepoužijeme
příkaz <strong>return</strong> (a funkce tudíž nevrací žádnou hodnotu), mají i
jediný bod výstupní (<i>exit point</i>). Deklarace funkce začíná klíčovým
slovem <strong>func</strong>, za kterým následuje nepovinné označení příjemce
(<i>receiver</i>), povinné jméno funkce, parametry funkce (pokud je funkce bez
parametrů, použijí se prázdné kulaté závorky), návratový typ a konečně tělo
funkce umístěné do složených závorek:</p>

<pre>
package main
&nbsp;
func emptyFunction() {
        fmt.Println(message)
}
&nbsp;
func printMessage(message string) {
        fmt.Println(message)
}
&nbsp;
func swap(a int, b int) (int, int) {
        return b, a
}
&nbsp;
func (line Line) length() float64 {
        return math.Hypot(line.x1-line.x2, line.y1-line.y2)
}
&nbsp;
func (line Line) translate(dx, dy float64) {
        fmt.Printf("Translating line %v by %f %f\n", line, dx, dy)
        line.x1 += dx
        line.y1 += dy
        line.x2 += dx
        line.y2 += dy
}
&nbsp;
func main() {
        println("Hello world!")
        emptyFunction()
        printMessage("pokus")
&nbsp;
        x := 1
        y := 2
&nbsp;
        var z int
        var w int
&nbsp;
        z, w = swap(x, y)
        fmt.Println("z =", z)
        fmt.Println("w =", w)
        ...
        ...
        ...
}
</pre>

<p>S&nbsp;prvním příkazem sloužícím pro řízení běhu programu jsme se již
vlastně setkali <a
href="https://www.root.cz/clanky/go-minimalisticky-a-prekvapive-vykonny-programovaci-jazyk/">v&nbsp;úvodním článku</a>. Jedná se o příkaz <strong>return</strong>, který provádí dvě
související operace:</p>

<ol>

<li>Ukončuje právě prováděnou funkci a vrací řízení zpět volajícímu bloku.</li>

<li>Výrazy zapsané za příkaz <strong>return</strong> jsou vyhodnoceny a
vypočtené hodnoty jsou vráceny volající funkci (již víme, že návratových hodnot
může být více, což se ostatně v&nbsp;jazyku Go velmi často využívá).</li>

</ol>

<p><a
href="https://github.com/tisnik/go-fedora/blob/master/article_05/02_return_statement.go">V&nbsp;dnešním
druhém demonstračním příkladu</a> je ukázán základní způsob použití příkazu
<strong>return</strong> ve chvíli, kdy funkce, ve které je
<strong>return</strong> použit, nevrací žádné hodnoty:</p>

<pre>
package main
&nbsp;
func f1() {
        println("f1")
        <strong>return</strong>
}
&nbsp;
func main() {
        println("Hello world!")
        f1()
}
</pre>

<p><div class="rs-tip-major">Poznámka: někteří vývojáři preferují použití
takového stylu programování, v&nbsp;němž má každá funkce jeden vstupní a
jediným výstupní bod, blíže viz například diskuse <a
href="http://wiki.c2.com/?SingleFunctionExitPoint">zde</a>. V&nbsp;takovém
případě se příkaz <strong>return</strong> použije vždy až na konci funkce,
ovšem samotná logika může být složitější oproti situaci, kdy se
<strong>return</strong> použije například uvnitř podmínky či v&nbsp;programové
smyčce.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Příkaz <strong>return</strong> umístěný před koncem těla funkce</h2>

<p>Zajímavé je, že překladači programovacího jazyka Go nebude vadit ani funkce,
v&nbsp;níž se vyskytuje větší množství příkazů <strong>return</strong> ve
stejném bloku, i když je zřejmé, že už první <strong>return</strong> běh funkce
ukončí a další příkazy z&nbsp;tohoto důvodu nebudou vykonány. Opět si můžeme
toto chování vyzkoušet na <a
href="https://github.com/tisnik/go-root/blob/master/article_05/03_return_statement_no_value.go">dalším
demonstračním příkladu</a>:</p>

<pre>
package main
&nbsp;
func f1() {
        println("f1() před příkazem return")
        <strong>return</strong>
        println("f1() po příkazu return")
}
&nbsp;
func main() {
        println("Hello world!")
        f1()
}
</pre>

<p>Překlad tohoto příkladu kupodivu proběhne bez toho, že by se vypsalo
jakékoli varování. Chování programu v&nbsp;runtime je následující:</p>

<pre>
Hello world!
f1() před příkazem return
</pre>

<p>Z&nbsp;tohoto výpisu je patrné, že se skutečně běh funkce ukončil na prvním
příkazu <strong>return</strong>, takže se druhé volání funkce
<strong>println</strong> nikdy neuskutečnilo.</p>

<p>Z&nbsp;předchozího popisu by se mohlo zdát, že překladač programovacího
jazyka Go neprovádí při překladu funkcí s&nbsp;příkazem <strong>return</strong>
žádnou kontrolu chyb. Ve skutečnosti to ovšem není pravda, protože ve chvíli,
kdy budeme překládat funkci s&nbsp;návratovou hodnotou (nebo hodnotami), bude
překladač zjišťovat, jestli funkce ve všech možných případech vrátí deklarovaný
počet a typ hodnot. To znamená, že se testují příkazy <strong>return</strong>
ve všech větvích, na nedosažitelných řádcích(!) atd.</p>

<p>Ukažme si nyní &ndash; prozatím na <a
href="https://github.com/tisnik/go-root/blob/master/article_05/04_return_statement_int_value.go">velmi
jednoduchém příkladu</a> &ndash; jak taková kontrola probíhá v&nbsp;praxi.
V&nbsp;následujícím zdrojovém kódu sice funkce s&nbsp;návratovým typem
<strong>int</strong> skutečně obsahuje příkaz <strong>return</strong>
s&nbsp;celočíselným výrazem, ovšem za tímto příkazem se nachází další
příkaz(y). Ty jsou sice (v&nbsp;daný okamžik) nedosažitelné, překladač ovšem i
přesto bude vyžadovat, aby se tato část programového bloku ukončila pomocí
<strong>return</strong> s&nbsp;celočíselným výrazem:</p>

<pre>
package main
&nbsp;
func f2() int {
        println("f2() před příkazem return")
        <strong>return 42</strong>
        println("f2() po příkazu return")
}
&nbsp;
func main() {
        println("Hello world!")
        println(f2())
}
</pre>

<p>Pokus o překlad tedy skončí s&nbsp;chybou:</p>

<pre>
./04_return_statement_int_value.go:14:1: missing return at end of function
</pre>

<p>Oprava této chyby (popř.&nbsp;její ukrytí před překladačem!) je samozřejmě
<a
href="https://github.com/tisnik/go-root/blob/master/article_05/05_return_statement_int_value.go">velmi
snadné</a>:</p>

<pre>
package main
&nbsp;
func f2() int {
        println("f2() před příkazem return")
        <strong>return 42</strong>
        println("f2() po příkazu return")
        <strong>return -1</strong>
}
&nbsp;
func main() {
        println("Hello world!")
        println(f2())
}
</pre>

<p><div class="rs-tip-major">Poznámka: otázkou samozřejmě zůstává, proč vlastně
překladač umožňuje konstrukci <strong>return</strong> tímto způsobem používat.
Jedním z&nbsp;důvodů je snadné &bdquo;zakomentování&ldquo; části funkce při
ladění programu (funkce se nahradí nějakým jednodušším ekvivalentem). Dále musí
překladač počítat s&nbsp;konstrukcí <strong>goto</strong> (<a href="#k18">i ta
v&nbsp;Go existuje</a>). Teoreticky by ovšem nástroje pro statickou analýzu
kódu mohly tyto minimálně podezřelé části detekovat.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Jednoduchá rozhodovací konstrukce typu <strong>if</strong></h2>

<p>Základní konstrukcí programovacího jazyka Go určenou pro rozvětvení běhu
programu na základě nějaké podmínky je &ndash; podobně jako v&nbsp;prakticky
všech ostatních vysokoúrovňových jazycích &ndash; příkaz <strong>if</strong>.
Chování tohoto příkazu i způsob jeho zápisu je ovšem v&nbsp;Go odlišný, než je
tomu v&nbsp;C/C++/Javě. První změna je patrná na první pohled &ndash; okolo
výrazu, jehož hodnota rozhodne o rozvětvení, se nemusí psát závorky.</p>

<p>Naopak je však nutné (a to na stejném řádku) zapsat <i>levou složenou
závorku</i> za tímto výrazem, protože v&nbsp;případě, že je podmínka splněna,
se vždy vykoná celý blok příkazů. Tento blok samozřejmě může obsahovat jen
jediný příkaz, ovšem i v&nbsp;tomto případě je nutné blok použít. Toto je velmi
dobrá vlastnost Go, protože umožnění zápisu pouze jediného příkazu za
<strong>if</strong> bez použití bloku může vést k&nbsp;těžko odhalitelným
chybám (pravděpodobně nejznámější chybou tohoto typu je <a
href="https://dwheeler.com/essays/apple-goto-fail.html">Apple goto fail</a>). A
konečně: výraz zapsaný za <strong>if</strong> musí být typu <i>boolean</i>, což
je striktně kontrolováno překladačem.</p>

<p>Samozřejmě si ukážeme příklady použití konstrukce <strong>if</strong>. Její
nejjednodušší podoby <a
href="https://github.com/tisnik/go-root/blob/master/article_05/06_if_statement.go">vypadají
následovně</a>:</p>

<pre>
package main
&nbsp;
func main() {
        <strong>if</strong> true {
                println("true")
        }
&nbsp;
        <strong>if</strong> false {
                println("false")
        }
&nbsp;
        <strong>if</strong> !true {
                println("false")
        }
&nbsp;
        <strong>if</strong> !false {
                println("true")
        }
&nbsp;
        var b1 bool = true
&nbsp;
        <strong>if</strong> b1 {
                println("true")
        }
        <strong>if</strong> !b1 {
                println("false")
        }
&nbsp;
        b2 := true
&nbsp;
        if b2 {
                println("true")
        }
        if !b2 {
                println("false")
        }
}
</pre>

<p>Jak jsme si již řekli v&nbsp;předchozích odstavcích, musí být výraz zapsaný
za <strong>if</strong> striktně typu <i>boolean</i>. Navíc typový systém
programovacího jazyka Go neumožňuje automatické (implicitní) přetypování
hodnot/výrazů jiného typu na <i>boolean</i>, takže <a
href="https://github.com/tisnik/go-root/blob/master/article_05/07_if_statement_bad_type.go">příklad
zobrazený níže</a> se nepodaří přeložit (což je z&nbsp;pohledu rozsáhlejších
aplikací jen dobře):</p>

<pre>
package main
&nbsp;
func main() {
        <strong>if</strong> 1 {
                println("true")
        }
&nbsp;
        <strong>if</strong> 0 {
                println("false")
        }
&nbsp;
        <strong>if</strong> !1 {
                println("false")
        }
&nbsp;
        <strong>if</strong> !0 {
                println("true")
        }
&nbsp;
        var b1 int = 1
&nbsp;
        <strong>if</strong> b1 {
                println("true")
        }
        <strong>if</strong> !b1 {
                println("false")
        }
&nbsp;
        b2 := 1
&nbsp;
        <strong>if</strong> b2 {
                println("true")
        }
        <strong>if</strong> !b2 {
                println("false")
        }
}
</pre>

<p>Překladač si v&nbsp;této chvíli správně postěžuje na to, že výraz za
příkazem <strong>if</strong> není typu <i>boolean</i>:</p>

<pre>
./07_if_statement_bad_type.go:11:2: non-bool 1 (type int) used as if condition
./07_if_statement_bad_type.go:15:2: non-bool 0 (type int) used as if condition
./07_if_statement_bad_type.go:19:5: invalid operation: ! untyped number
./07_if_statement_bad_type.go:23:5: invalid operation: ! untyped number
./07_if_statement_bad_type.go:29:2: non-bool b1 (type int) used as if condition
./07_if_statement_bad_type.go:32:5: invalid operation: ! int
./07_if_statement_bad_type.go:38:2: non-bool b2 (type int) used as if condition
./07_if_statement_bad_type.go:41:5: invalid operation: ! int
</pre>

<p>Totéž ovšem platí i pro hodnotu <strong>nil</strong>, která se v&nbsp;Go
<i>nedá</i> automaticky přetypovat na <strong>false</strong> (v&nbsp;mnoha
dalších jazycích, včetně C, Luy, Pythonu, Lispu či Clojure, je chování
odlišné):</p>

<pre>
package main
&nbsp;
func main() {
        if nil {
                println("true")
        }
&nbsp;
        if !nil {
                println("false")
        }
&nbsp;
        if "" {
                println("true")
        }
&nbsp;
        if !"" {
                println("false")
        }
&nbsp;
        var b1 bool = nil
&nbsp;
        if b1 {
                println("true")
        }
&nbsp;
        if !b1 {
                println("false")
        }
}
</pre>

<p>Opět si ukažme výsledek pokusu o překlad <a
href="https://github.com/tisnik/go-root/blob/master/article_05/08_if_statement_nil.go">tohoto
příkladu</a>:</p>

<pre>
./08_if_statement_nil.go:11:2: use of untyped nil
./08_if_statement_nil.go:15:5: invalid operation: ! nil
./08_if_statement_nil.go:19:2: non-bool "" (type string) used as if condition
./08_if_statement_nil.go:23:5: invalid operation: ! untyped string
./08_if_statement_nil.go:27:6: cannot use nil as type bool in assignment
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Rozvětvení s&nbsp;využitím konstrukce <strong>if-else</strong></h2>

<p>Podobně jako v&nbsp;dalších programovacích jazycích je možné i v&nbsp;jazyce
Go doplnit příkaz <strong>if</strong> o větev <strong>else</strong>, takže se
namísto jednoduchého větvení může provést úplné rozvětvení. Pro větev
<strong>else</strong> platí stejná pravidla, jako pro samotný
<strong>if</strong>: vždy se používá blok příkazů uzavřený mezi složené závorky
a navíc by se levá (otevírací) složená závorka měla zapsat na stejný řádek,
jako samotné klíčové slovo <strong>else</strong>. Opět si vše <a
href="https://github.com/tisnik/go-root/blob/master/article_05/09_if_else_construct.go">ukážeme
na jednoduchém příkladu</a>. V&nbsp;první funkci je provedeno rozhodnutí na
základě dvou podmínek a došlo zde tedy k&nbsp;zřetězení <strong>else</strong>
s&nbsp;dalším <strong>if</strong>, ve funkci <strong>main</strong> se používá
pouze úplné rozvětvení <strong>if-else</strong>:</p>

<pre>
package main
&nbsp;
func classify_char(c rune) string {
        <strong>if</strong> c &gt;= 'a' &amp;&amp; c &lt;= 'z' {
                return "male pismeno"
        } <strong>else if</strong> c &gt;= 'A' &amp;&amp; c &lt;= 'Z' {
                return "velke pismeno"
        } <strong>else</strong> {
                return "neco jineho"
        }
}
&nbsp;
func main() {
        <strong>if</strong> true {
                println("true")
        } <strong>else</strong> {
                println("false")
        }
&nbsp;
        <strong>if</strong> !true {
                println("false")
        } <strong>else</strong> {
                println("true")
        }
&nbsp;
        println(classify_char('a'))
        println(classify_char('Z'))
        println(classify_char('?'))
}
</pre>

<p>Zajímavé je, že v&nbsp;Go zdánlivě neexistuje konstrukce určená pro
explicitní zřetězení několika podmínek, která je obvykle zapisovaná klíčovým
slovem <strong>elif</strong> nebo <strong>elseif</strong>. Pokud budeme chtít
provést rozvětvení na základě několika podmínek, máme k&nbsp;dispozici dvě
základní možnosti:</p>

<ol>

<li>Použít již výše zmíněnou a ukázanou sekvenci
<strong>if</strong>-<strong>else if</strong>-<strong>else
if</strong>-<strong>else</strong></li>

<li>Nebo můžeme použít jednu z&nbsp;variant konstrukce
<strong>switch-case</strong>, s&nbsp;níž se seznámíme v&nbsp;dalších
kapitolách. Možnosti této konstrukce jsou totiž v&nbsp;jazyce Go mnohem větší,
než je tomu v&nbsp;již několikrát zmiňované trojici C/C++/Java.</li>

</ol>

<p><div class="rs-tip-major">Poznámka: překladač programovacího jazyka Go chápe
celý řetězec if-else if-else atd. jako jediný složený příkaz, což má vliv
především na oblast platnosti (viditelnosti) proměnné deklarované v&nbsp;rámci
nepovinného příkazu uvedeného za prvním <strong>if</strong> (což je téma,
kterému se budeme věnovat <a href="#k06">v&nbsp;navazující
kapitole</a>).</div></p>

<p>Při zápisu zdrojového kódu musíme dodržovat pravidla kontrolovaná
překladačem jazyka Go. Mezi jedno takové pravidlo patří i to, že klíčové slovo
<strong>else</strong> musí být zapsáno za pravou uzavírací závorku větve
<strong>if</strong>. To například znamená, že se <a
href="https://github.com/tisnik/go-root/blob/master/article_05/10_bad_syntax.go">následující
kód</a> &ndash; který je sémanticky naprosto totožný <a
href="https://github.com/tisnik/go-root/blob/master/article_05/09_if_else_construct.go">s&nbsp;předchozím
příkladem</a> &ndash;, ve skutečnosti nepodaří přeložit:</p>

<pre>
package main
&nbsp;
func classify_char(c rune) string {
        if c &gt;= 'a' &amp;&amp; c &lt;= 'z'
        {
                return "male pismeno"
        }
        else if c &gt;= 'A' &amp;&amp; c &lt;= 'Z' {
                return "velke pismeno"
        }
        else
        {
                return "neco jineho"
        }
}
&nbsp;
func main() {
        println(classify_char('a'))
        println(classify_char('Z'))
        println(classify_char('?'))
}
</pre>

<p>Překladač by měl vypsat následující chyby (nikoli pouhé varování):</p>

<pre>
./10_bad_syntax.go:11:25: syntax error: unexpected newline, expecting { after if clause
./10_bad_syntax.go:15:2: syntax error: unexpected else, expecting }
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Příkaz zapsaný za klíčovým slovem <strong>if</strong></h2>

<p>V&nbsp;programovacím jazyku Go je možné ještě před vlastní podmínku vložit
nějaký <i>příkaz</i>, který je od podmínky oddělen středníkem. V&nbsp;tomto
příkazu se typicky deklaruje a inicializuje nějaká lokální proměnná. Celý zápis
může vypadat následovně:</p>

<pre>
package main
&nbsp;
func funkce() int {
        return -1
}
&nbsp;
func x() string {
        if <strong>value := funkce();</strong> value &lt; 0 {
                return "záporná hodnota"
        } else if value &gt; 0 {
                return "kladná hodnota"
        } else {
                return "nula"
        }
}
&nbsp;
func main() {
        println(x())
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že hodnota
<strong>value</strong> je dostupná i ve druhé větvi <strong>if</strong>,
protože se jedná o jediný blok příkazů. Není ovšem viditelná <i>za</i> příkazem
<strong>if</strong>:</div></p>

<pre>
package main
&nbsp;
func funkce() int {
        return -1
}
&nbsp;
func x() string {
        if <strong>value := funkce();</strong> value &lt; 0 {
                return "záporná hodnota"
        } else if value &gt; 0 {
                return "kladná hodnota"
        } else {
                return "nula"
        }
        <strong>println(value)</strong>
        return ""
}
&nbsp;
func main() {
        println(x())
}
</pre>

<p>Překladač nyní správně vypíše chybu:</p>

<pre>
prog.go:21:10: undefined: value
./10C_statement_in_if_not_visible.go:21:10: undefined: value
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Rozvětvení běhu programu s&nbsp;využitím konstrukce <strong>switch</strong></h2>

<p>V&nbsp;programovacím jazyce Go nalezneme i konstrukci
<strong>switch</strong> s&nbsp;větvemi, které začínají klíčovým slovem
<strong>case</strong>. Tato konstrukce vývojářům nabízí mnohem větší možnosti
využití, než je tomu v C/C++ či Javě, což ostatně bude patrné i při pohledu na
demonstrační příklady. Prvním vylepšením je fakt, že se za klíčové slovo
<strong>switch</strong> nemusí zapisovat žádný výraz. V&nbsp;takovém případě se
předpokládá, že (neexistující) výraz je vyhodnocen na hodnotu
<strong>true</strong>. Poněkud umělý příklad, který této vlastnosti využívá,
může vypadat následovně:</p>

<pre>
package main
&nbsp;
func main() {
        switch {
        }
&nbsp;
        switch {
        default:
                println("proč jsem vlastně použil switch?")
        }
&nbsp;
        switch {
        case true:
                println("true")
        case false:
                println("false")
        }
&nbsp;
        switch {
        case false:
                println("false")
        case true:
                println("true")
        default:
                println("default")
        }
&nbsp;
        switch {
        case false:
                println("false")
        default:
                println("default")
        case true:
                println("true")
        }
}
</pre>

<p>První <strong>switch</strong> je zcela prázdný, což je povoleno. Druhý
<strong>switch</strong> obsahuje pouze větev uvozenou klíčovým slovem
<strong>default</strong>, která je v&nbsp;tomto případě spuštěna. Zajímavý je
poslední příklad, který ukazuje, že větve není (většinou) zapotřebí za sebe
řadit takovým způsobem, aby <strong>default</strong> byla až na konci.</p>

<p><div class="rs-tip-major">Poznámka: všimněte si chybějících příkazů
<strong>break</strong>. Důvod, proč tyto příkazy ve větvích chybí, si popíšeme
v&nbsp;navazujícím textu.</div></p>

<p>Výsledek, který získáme po spuštění tohoto příkladu:</p>

<pre>
proč jsem vlastně použil switch?
true
true
true
</pre>

<p><div class="rs-tip-major">Poznámka: chybějící výraz za
<strong>switch</strong> umožňuje zápis podmínek u jednotlivých větví
<strong>case</strong>, což je velmi užitečné.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Porovnání výrazu s&nbsp;konstantami a vypočtenými hodnotami v&nbsp;konstrukci <strong>switch</strong></h2>

<p>Příklad z&nbsp;předchozí kapitoly ve skutečnosti nebyl vůbec praktický,
takže si ukažme některé skutečně užitečné vlastnosti konstrukce
<strong>switch</strong>. V&nbsp;jazyce Go je možné u každé větve
<strong>case</strong> specifikovat výčet hodnot, pro které se má daná větev
provést. Můžeme tedy bez problémů určit nulovou hodnotu, sudá čísla a lichá
čísla pro všechna přirozená čísla od 0 do 9 (což je opět spíše umělý příklad,
který by se v&nbsp;praxi řešil jinak):</p>

<pre>
package main
&nbsp;
func classify(x int) string {
        switch x {
        case 0:
                return "nula"
        case 2, 4, 6, 8:
                return "sudé číslo"
        case 1, 3, 5, 7, 9:
                return "liché číslo"
        default:
                return "?"
        }
}
&nbsp;
func main() {
        for x := 0; x &lt;= 10; x++ {
                println(x, classify(x))
        }
}
</pre>

<p>Výsledky:</p>

<pre>
0 nula
1 liché číslo
2 sudé číslo
3 liché číslo
4 sudé číslo
5 liché číslo
6 sudé číslo
7 liché číslo
8 sudé číslo
9 liché číslo
10 ?
</pre>

<p>Dále je umožněno, aby se u větví <strong>case</strong> nepoužívaly pouze
konstanty. V&nbsp;níže uvedeném zdrojovém kódu je namísto konstanty 0 použit
parametr <strong>zero_value</strong>, což je zcela legální:</p>

<pre>
package main
&nbsp;
func classify(x int, <strong>zero_value</strong> int) string {
        switch x {
        case <strong>zero_value</strong>:
                return "nula"
        case 2, 4, 6, 8:
                return "sudé číslo"
        case 1, 3, 5, 7, 9:
                return "liché číslo"
        default:
                return "?"
        }
}
&nbsp;
func main() {
        for x := 0; x &lt;= 10; x++ {
                println(x, classify(x, 0))
        }
}
</pre>

<p>Výsledky:</p>

<pre>
0 nula
1 liché číslo
2 sudé číslo
3 liché číslo
4 sudé číslo
5 liché číslo
6 sudé číslo
7 liché číslo
8 sudé číslo
9 liché číslo
10 ?
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vyhodnocení a porovnání výsledků podmínek zapsaných ve větvích <strong>case</strong></h2>

<p>Možnosti konstrukce <strong>switch</strong> jdou ovšem ještě dále, a to
z&nbsp;toho důvodu, že se <strong>switch</strong> v&nbsp;Go spíše podobá <a
href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-zakladni-konstrukce-jazyka/#k11">formě
cond</a> známé z&nbsp;lispovských jazyků. U jednotlivých větví
<strong>else</strong> totiž můžeme zapsat výrazy s&nbsp;typem <i>boolean</i>.
V&nbsp;takovém případě se ovšem žádný výraz naopak nezapisuje přímo za
<strong>switch</strong>. Předchozí příklady můžeme přepsat tak, aby byly
obecnější a neomezovaly se jen na malá přirozená čísla:</p>

<pre>
package main
&nbsp;
func classify(x int) string {
        switch {
        case x == 0:
                return "nula"
        case x%2 == 0:
                return "sudé číslo"
        case x%2 == 1:
                return "liché číslo"
        default:
                return "?"
        }
}
&nbsp;
func main() {
        for x := 0; x &lt;= 10; x++ {
                println(x, classify(x))
        }
}
</pre>

<p>Výsledky po spuštění:</p>

<pre>
0 nula
1 liché číslo
2 sudé číslo
3 liché číslo
4 sudé číslo
5 liché číslo
6 sudé číslo
7 liché číslo
8 sudé číslo
9 liché číslo
10 sudé číslo
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto konkrétním případě se nikdy
nevykoná větev <strong>default</strong>.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Větší množství větví <strong>case</strong> se společným tělem: klíčové slovo <strong>fallthrough</strong></h2>

<p>V&nbsp;sedmé kapitole jsme se zmínili o tom, že se v&nbsp;konstrukci
<strong>switch-case</strong> jednotlivé větve neukončují pomocí
<strong>break</strong>. Je tomu tak z&nbsp;toho důvodu, že větve jsou ukončeny
zcela automaticky, což je odlišné chování, než jaké známe
z&nbsp;C/C++/Javy!</p>

<p>Výsledkem je, že následující program se nebude chovat přesně tak, jak by
tomu bylo ve zmíněných jazycích:</p>

<pre>
package main
&nbsp;
func classify(x int) string {
        switch x {
        case 0:
                return "nula"
        case 2:
        case 4:
        case 6:
        case 8:
                return "sudé číslo"
        case 1:
        case 3:
        case 5:
        case 7:
        case 9:
                return "liché číslo"
        default:
                return "?"
        }
        return "X"
}
&nbsp;
func main() {
        for x := 0; x &lt;= 10; x++ {
                println(x, classify(x))
        }
}
</pre>

<p>Výsledek po spuštění:</p>

<pre>
0 nula
1 X
2 X
3 X
4 X
5 X
6 X
7 X
8 sudé číslo
9 liché číslo
10 ?
</pre>

<p>Pokud naopak budeme vyžadovat, aby některé větve měly společné tělo, musíme
použít klíčové slovo <strong>fallthrough</strong>, které je přesným opakem
<strong>break</strong> &ndash; zaručuje, že se bude pokračovat v&nbsp;dalších
příkazech z&nbsp;navazující větve:</p>

<pre>
package main
&nbsp;
func classify(x int) string {
        switch x {
        case 0:
                return "nula"
        case 2:
                fallthrough
        case 4:
                fallthrough
        case 6:
                fallthrough
        case 8:
                return "sudé číslo"
        case 1:
                fallthrough
        case 3:
                fallthrough
        case 5:
                fallthrough
        case 7:
                fallthrough
        case 9:
                return "liché číslo"
        default:
                return "?"
        }
}
&nbsp;
func main() {
        for x := 0; x &lt;= 10; x++ {
                println(x, classify(x))
        }
}
</pre>

<p>Výsledek po spuštění tohoto příkladu je již přijatelnější:</p>

<pre>
0 nula
1 liché číslo
2 sudé číslo
3 liché číslo
4 sudé číslo
5 liché číslo
6 sudé číslo
7 liché číslo
8 sudé číslo
9 liché číslo
10 ?
</pre>

<p><div class="rs-tip-major">Poznámka: nejsem si zcela jistý, ale mám pocit, že
<strong>fallthrough</strong> je schválně zapisován takto dlouhým klíčovým
slovem z&nbsp;toho důvodu, aby se příliš často nepoužíval.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Další příklady použití rozvětvení typu <strong>switch</strong></h2>

<p>Příkaz <strong>fallthrough</strong> je samozřejmě možné použít i ve chvíli,
kdy se používají větve <strong>case</strong> s&nbsp;podmínkami:</p>

<pre>
package main
&nbsp;
func classify(x int) string {
        switch {
        case x == 0:
                return "nula"
        case x%2 == 1:
                return "liché číslo"
        case x%2 == 0:
                fallthrough
        default:
                return "sudé číslo"
        }
}
&nbsp;
func main() {
        for x := 0; x &lt;= 10; x++ {
                println(x, classify(x))
        }
}
</pre>

<p>Jen pro úplnost se zmiňme o tom, že pro řetězce je funkční operátor
porovnání a tudíž můžeme provést rozeskok i na základě hodnoty řetězce (což
například v&nbsp;C není takto přímo možné):</p>

<pre>
package main

func command(x string) string {
        switch x {
        case "":
                return "missing command"
        case "help":
        case "info":
                return "help"
        case "bye":
                fallthrough
        case "exit":
                fallthrough
        case "quit":
                return "quit"
        default:
                return "unknown command"
        }
        return "unknown command"
}

func main() {
        println(command(""))
        println(command("bzz bzz bzz"))
        println(command("bye"))
        println(command("quit"))
        println(command("exit"))
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Programové smyčky v&nbsp;jazyku Go: příkaz <strong>for</strong></h2>

<p>Po popisu jazykových konstrukcí určených pro větvení a rozvětvení běhu
programu se (konečně) dostáváme k&nbsp;popisu programových smyček.
V&nbsp;programovacím jazyku Go jsou sice všechny typy smyček realizovány
jediným klíčovým slovem <strong>for</strong>, ovšem ve skutečnosti lze toto
(doslova) klíčové slovo použít pro implementaci čtyř typů smyček:</p>

<ol>

<li>Nekonečná smyčka (zdánlivě neužitečná konstrukce se ovšem může použít
společně s&nbsp;příkazy <strong>break</strong> nebo
<strong>return</strong>).</li>

<li>Smyčka s&nbsp;testem prováděným na začátku každé iterace (tedy typická
smyčka typu <strong>while</strong>).</li>

<li>Iterace nad zvoleným datovým typem (pole, řez, řetězec, mapa apod.) přičemž
&ndash; což je velmi užitečné &ndash; je v&nbsp;každé iteraci dostupný i
příslušný <i>selektor</i> (index u polí, klíč u map).</li>

<li>A konečně je podporován typ zápisu smyčky, který je odvozen od klasického
céčka &ndash; za klíčové slovo <strong>for</strong> se zapisuje inicializační
příkaz, výraz vyhodnocovaný pro ukončení smyčky a iterační příkaz. Tímto
způsobem se v&nbsp;jazyce Go realizují počítané smyčky (což sice může vypadat
jako určitý návrat do historie, ovšem jde o univerzální popis smyčky
s&nbsp;počitadlem).</li>

</ol>

<p><div class="rs-tip-major">Poznámka: klíčové slovo <strong>for</strong> bylo
s&nbsp;velkou pravděpodobností použito z&nbsp;toho důvodu, aby byl umožněn
snadnější přechod vývojářů z&nbsp;mainstreamových jazyků na Go. Ovšem
z&nbsp;dlouhodobějšího hlediska by možná bylo lepší a přesnější použít spíše
klíčové slovo <strong>loop</strong>, zejména pro první dva typy programových
smyček.</div></p>

<p>Vyzkoušejme si nejprve nekonečnou programovou smyčku. Tato smyčka se
v&nbsp;jazyce Go zapisuje <a
href="https://github.com/tisnik/go-root/blob/master/article_05/19_simplest_for_loop.go">následujícím
způsobem</a>:</p>

<pre>
package main
&nbsp;
func main() {
        <strong>for</strong> {
                println("Diamonds are forever")
        }
}
</pre>

<p>Programová smyčka zapsaná tímto způsobem je skutečně nekonečná,
tj.&nbsp;řízení programu v&nbsp;ní zůstane tak dlouho, dokud není program
zastaven nějakým zásahem zvenku. V&nbsp;našem případě je nejjednodušší stisknut
klávesovou zkratku <strong>Ctrl+C</strong>, popř.&nbsp;použít příkaz
<strong>kill</strong>. K&nbsp;čemu je však tento typ smyčky vhodný? Použijeme
ji ve chvíli, kdy je podmínka pro ukončení iterací zjišťována nikoli na
samotném začátku smyčky (před vstupem do bloku s&nbsp;příkazy), ale buď na
konci smyčky nebo někde uprostřed. V&nbsp;takovém případě se smyčka ukončí
s&nbsp;využitím konstrukce:</p>

<pre>
<strong>for {</strong>
        ...
        ...
        ...
        <strong>if</strong> podmínka <strong>{</strong>
            <strong>break</strong>
        <strong>}</strong>
        ...
        ...
        ...
<strong>}</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je tento typ smyčky
odvozen od dále popsaného &bdquo;céčkovského&ldquo; typu smyčky, kde ovšem
došlo k&nbsp;odstranění nepovinných výrazů. Z&nbsp;pohledu překladače se tedy
jedná o ekvivalent tohoto zápisu (viz další text s&nbsp;podrobnějším popisem
této smyčky):</div></p>

<pre>
<strong>for</strong> ; ; {
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Příkaz <strong>for</strong> s&nbsp;podmínkou na začátku</h2>

<p>Druhá varianta programové smyčky <strong>for</strong> obsahuje výraz, který
se vyhodnocuje vždy před začátkem každé iterace, tj.&nbsp;před každým vstupem
do bloku představujícího tělo smyčky. Jedná se tedy o reimplementaci standardní
řídicí konstrukce typu <strong>while</strong>. V&nbsp;programovacím jazyku Go
se tento typ smyčky zapisuje následujícím způsobem:</p>

<pre>
<strong>for</strong> podmínka <strong>{</strong>
        ...
        ...
        ...
<strong>}</strong>
</pre>

<p><a
href="https://github.com/tisnik/go-root/blob/master/article_05/19_simplest_for_loop.go">Předchozí
příklad</a> tedy můžeme <a
href="https://github.com/tisnik/go-root/blob/master/article_05/20_basic_for_loop.go">nepatrně
přepsat</a> do explicitního tvaru:</p>

<pre>
package main
&nbsp;
func main() {
        <strong>for true</strong> {
                println("Diamonds are forever")
        }
}
</pre>

<p><a
href="https://github.com/tisnik/go-root/blob/master/article_05/21_for_loop_with_condition.go">Opět
si ukažme</a>, jak se tato smyčka použije v&nbsp;praxi při testování, zda se má
provést další iterace či nikoli. V&nbsp;následujícím příkladu se odpočítává od
desíti do jedné:</p>

<pre>
package main

func main() {
        i := 10
        <strong>for i != 0</strong> {
                println(i)
                i--
        }
}
</pre>

<p>Výsledek po spuštění:</p>

<pre>
10
9
8
7
6
5
4
3
2
1
</pre>

<p><div class="rs-tip-major">Poznámka: striktně řečeno se opět jedná &bdquo;pouze&ldquo; o zkrácený zápis tohoto typu smyčky:</div></p>

<pre>
for ; podmínka ; {
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Varianta programové smyčky převzatá z&nbsp;jazyka C</h2>

<p>Třetí varianta programové smyčky je odvozena od <a
href="https://www.tutorialspoint.com/cprogramming/c_for_loop.htm">céčkové
konstrukce</a> se shodným názvem <strong>for</strong>. Tato konstrukce
vyžaduje, aby za klíčovým slovem <strong>for</strong> byla zapsána následující
trojice:</p>

<ol>

<li>Inicializační příkaz; typicky se jedná o inicializaci nějaké existující
proměnné, nebo &ndash; a to častěji &ndash; deklaraci nové lokální proměnné
spojené s&nbsp;její inicializací (to se provádí operátorem :=).</li>

<li>Výraz, který je vyhodnocen před každou iterací. Na základě hodnoty tohoto
výrazu se zjišťuje, zda se má skutečně provést další iterace či nikoli. Tento
výraz musí být typu <i>boolean</i>.</li>

<li>Příkaz provedený na konci každé iterace. Typicky se v&nbsp;něm snižuje či
zvyšuje (obecně mění) hodnota lokální proměnné využité ve funkci
počitadla.</li>

</ol>

<p>Mezi tyto tři syntaktické prvky se vkládá středník. Navíc pokud není
zapotřebí provést inicializaci proměnné před spuštěním smyčky, je možné první
prvek zcela vynechat. Podobně lze vynechat prvek třetí v&nbsp;případě, že
nepotřebujeme provádět nějaký příkaz na konci každé iterace. A konečně &ndash;
vynechat je možné i samotnou podmínku &ndash; v&nbsp;tomto případě je použita
výchozí podmínka, která je vždy splněna (jakoby se namísto výrazu doplnila
hodnota <strong>true</strong> &ndash; v&nbsp;tomto případě je však vhodnější
vynechat i samotné středníky a realizovat tak vlastně <a href="#k12">první
popsaný typ</a> programové smyčky, který je mnohem čitelnější).</p>

<p>Podívejme se nyní, jakým způsobem je možné v&nbsp;programovacím jazyce Go
realizovat jednoduchou smyčku s&nbsp;počitadlem. <a
href="https://github.com/tisnik/go-root/blob/master/article_05/22_c_like_loop.go">První
varianta příkladu</a> používá lokální proměnnou deklarovanou <i>před</i>
vlastní smyčkou a tudíž platnou i po doběhnutí smyčky:</p>

<pre>
package main
&nbsp;
func main() {
        var i int
        for i = 0; i &lt; 10; i++ {
                println(i)
        }
        println()
        println(i)
}
</pre>

<p><a
href="https://github.com/tisnik/go-root/blob/master/article_05/23_better_for.go">Druhá
varianta příkladu</a>, v&nbsp;níž je lokální proměnná (takzvaná řídicí proměnná
smyčky) deklarována a inicializována přímo v&nbsp;rámci příkazu
<strong>for</strong>, je v&nbsp;praxi používána mnohem častěji:</p>

<pre>
package main
&nbsp;
func main() {
        for i := 0; i &lt; 10; i++ {
                println(i)
        }
}
</pre>

<p>Důležité je, že v&nbsp;tomto případě se skutečně jedná o proměnnou
viditelnou pouze v&nbsp;rámci programové smyčky. To znamená, že za vlastní
smyčkou již tato proměnná nebude dostupná (a bude tedy například možné vytvořit
druhou smyčku používající stejnou proměnnou). <a
href="https://github.com/tisnik/go-root/blob/master/article_05/24_better_for_local_variable.go">Přesvědčíme se o tom snadno</a>:</p>

<pre>
package main
&nbsp;
func main() {
        for i := 0; i &lt; 10; i++ {
                println(i)
        }
        println(i)
}
</pre>

<p>Proměnná <strong>i</strong> skutečně přestane být po doběhnutí smyčky
viditelná:</p>

<pre>
./24_better_for_local_variable.go:14:10: undefined: i
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Iterace nad datovými strukturami s&nbsp;využitím <strong>for</strong> a <strong>range</strong></h2>

<p>Nyní si již konečně dostáváme ke čtvrtému a současně i poslednímu typu
programové smyčky nabízené jazykem Go. Tato programová smyčka je zapisována
s&nbsp;využitím dvojice klíčových slov <strong>for</strong> a
<strong>range</strong>, což je možná trošku matoucí, protože čtvrtý typ smyčky
se používá pro průchod všemi prvky nějaké datové struktury (pole, řezu,
řetězce, mapy atd.).</p>

<p>Kromě zpracování nějakého sekvenčního datového typu se tento typ programové
smyčky používá i ve chvíli, kdy potřebujeme opakovaně načítat data
z&nbsp;nějakého <i>kanálu</i>.</p>

<p>Podívejme se nyní, jaké dvojice hodnot se vrací v&nbsp;každé iteraci smyčky
<strong>for range</strong> v&nbsp;závislosti na objektu, přes který se
iteruje:</p>

<table>
<tr><th>Typ</th><th>První hodnota</th><th>Druhá hodnota</th></tr>
<tr><td>pole</td><td>index (int)</td><td>hodnota i-tého prvku pole</td></tr>
<tr><td>řez</td><td>index (int)</td><td>hodnota i-tého prvku řezu</td></tr>
<tr><td>řetězec</td><td>index (int)</td><td>i-tý znak (runa)</td></tr>
<tr><td>mapa</td><td>klíč (podle typu mapy)</td><td>hodnota přiřazená ke klíči</td></tr>
<tr><td>kanál</td><td>položka umístěná do kanálu</td><td>&times;</td></tr>
</table>

<p>Nejprve si ukažme, jakým způsobem je možné procházet polem, řezem
(<i>slice</i>) a taktéž řetězcem. V&nbsp;tomto případě se mezi klíčová slova
<strong>for</strong> a <strong>range</strong> zapisuje dvojice identifikátorů,
které reprezentují lokální proměnné platné pouze uvnitř těla smyčky. První
z&nbsp;proměnných bude obsahovat <i>selektor</i>, v&nbsp;tomto konkrétním
případě index prvku pole/řezu, druhá proměnná pak bude obsahovat přímo hodnotu
prvku z&nbsp;datové struktury, přes kterou se iteruje. <a
href="https://github.com/tisnik/go-root/blob/master/article_05/25_for_range.go">Příklad
vypadá následovně</a>:</p>

<pre>
package main
&nbsp;
func main() {
        a := [...]int{1, 2, 10, -1, 42}
&nbsp;
        <strong>for</strong> index, item := <strong>range</strong> a {
                println(index, item)
        }
&nbsp;
        println()
&nbsp;
        s := "Hello world ěščř Σ"
&nbsp;
        <strong>for</strong> index, character := <strong>range</strong> s {
                println(index, character)
        }
}
</pre>

<p>Povšimněte si, že existence selektoru může být v&nbsp;mnoha případech velmi
užitečná (číslování řádků v&nbsp;generované tabulce atd.), ovšem selektor
taktéž můžeme ignorovat, pokud ho nutně nebudeme v&nbsp;programu potřebovat.
Musíme ovšem myslet na to, že nám Go nepovolí deklarovat proměnnou, která se
nikde nepožije:</p>

<pre>
package main
&nbsp;
func main() {
        a := [...]int{1, 2, 10, -1, 42}
&nbsp;
        for <strong>i</strong>, item := range a {
                println(item)
        }
&nbsp;
        println()
&nbsp;
        s := "Hello world ěščř Σ"
&nbsp;
        for <strong>i</strong>, character := range s {
                println(character)
        }
}
</pre>

<p>Pokus o překlad <a
href="https://github.com/tisnik/go-root/blob/master/article_05/25B_for_range_without_index.go">tohoto
příkladu</a> skončí s&nbsp;chybami:</p>

<pre>
./25B_for_range_without_index.go:13:6: i declared and not used
./25B_for_range_without_index.go:21:6: i declared and not used
</pre>

<p>Korektní je použití identifikátoru _ namísto skutečného jména proměnné,
takže <a
href="https://github.com/tisnik/go-root/blob/master/article_05/25C_for_range_without_index.go">další
příklad</a> již půjde přeložit bez chyby:</p>

<pre>
package main
&nbsp;
func main() {
        a := [...]int{1, 2, 10, -1, 42}
&nbsp;
        for <strong>_</strong>, item := range a {
                println(item)
        }
&nbsp;
        println()
&nbsp;
        s := "Hello world ěščř Σ"
&nbsp;
        for <strong>_</strong>, character := range s {
                println(character)
        }
}
</pre>

<p><div class="rs-tip-major">Poznámka: s&nbsp;identifikátorem _, který označuje
nevýznamnou hodnotu použitou pouze kvůli syntaktickým pravidlům, se můžeme
setkat i v&nbsp;některých dalších programovacích jazycích. Jedná se například o
jazyk Rust, s&nbsp;nímž jsme se na stránkách Rootu <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">již
setkali</a>.</div></p>

<p>Průchod mapou s&nbsp;využitím programové smyčky <strong>for</strong> si
můžeme otestovat na dalším demonstračním příkladu. Po spuštění příkladu si
povšimněte, že u map není obecně zachováno pořadí vkládání prvků, takže dvojice
klíč-hodnota jsou procházeny v&nbsp;jiném pořadí, než v&nbsp;jakém byly do mapy
vloženy:</p>

<pre>
package main
&nbsp;
func main() {
        var m1 map[int]string = make(map[int]string)
        m1[0] = "nula"
        m1[1] = "jedna"
        m1[2] = "dva"
        m1[3] = "tri"
        m1[4] = "ctyri"
        m1[5] = "pet"
        m1[6] = "sest"
&nbsp;
        for key, val := range m1 {
                println(key, val)
        }
}
</pre>

<p>Výsledek může vypadat následovně:</p>

<pre>
5 pet
6 sest
0 nula
1 jedna
2 dva
3 tri
4 ctyri
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Ovlivnění programových smyček příkazy <strong>break</strong> a <strong>continue</strong></h2>

<p>Libovolnou variantu programové smyčky <strong>for</strong> je možné kdykoli
ukončit příkazem <strong>break</strong>. Ten se typicky používá v&nbsp;bloku
vykonaném při splnění nějaké podmínky, takže je například možné realizovat
smyčku s&nbsp;druhým (či dalším) testem na konci každé iterace či dokonce
uprostřed provádění iterace:</p>

<pre>
package main

func main() {
        for i := 0; i &lt; 10; i++ {
                println(i)
                if i == 5 {
                        <strong>break</strong>
                }
        }
}
</pre>

<p>Tento příklad má sice smyčku vytvořenou takovým způsobem, aby počitadlo
dosáhlo hodnot v&nbsp;rozsahu 0 až 9, ve skutečnosti ovšem běh smyčky skončí
dříve:</p>

<pre>
0
1
2
3
4
5
</pre>

<p>Druhý příkaz ovlivňující provádění programových smyček se jmenuje
<strong>continue</strong>. V&nbsp;případě, že se tento příkaz vykoná, dojde
k&nbsp;okamžitému přeskoku na další iteraci, ovšem u počítané smyčky se navíc
ještě modifikuje obsah počitadla:</p>

<pre>
package main
&nbsp;
func main() {
        for i := 0; i &lt; 10; i++ {
                if i%2 == 0 {
                        <strong>continue</strong>
                }
                println(i)
        }
}
</pre>

<p>Tento příklad vypíše pouze liché hodnoty, i když se ve smyčce počitadlo
naplňuje všemi přirozenými čísly od 0 do 9:</p>

<pre>
1
3
5
7
9
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Příkazy <strong>break</strong> a <strong>continue</strong> ve vnořených smyčkách</h2>

<p>V&nbsp;jazyce Go samozřejmě můžeme smyčky vkládat do sebe. Příkladem může
být výpočet tabulky s&nbsp;malou násobilkou:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        for i := 1; i &lt;= 10; i++ {
                for j := 1; j &lt;= 10; j++ {
                        fmt.Printf("%3d ", i*j)
                }
                fmt.Println()
        }
}
</pre>

<p>Ten by měl vypsat:</p>

<pre>
  1   2   3   4   5   6   7   8   9  10
  2   4   6   8  10  12  14  16  18  20
  3   6   9  12  15  18  21  24  27  30
  4   8  12  16  20  24  28  32  36  40
  5  10  15  20  25  30  35  40  45  50
  6  12  18  24  30  36  42  48  54  60
  7  14  21  28  35  42  49  56  63  70
  8  16  24  32  40  48  56  64  72  80
  9  18  27  36  45  54  63  72  81  90
 10  20  30  40  50  60  70  80  90 100
</pre>

<p>Pokud budeme například chtít najít, která dvojice čísel dá po svém součinu
hodnotu 42, můžeme použít stejnou dvojici vnořených smyček, ovšem ve vnitřní
smyčce je nutné zapsat podmínku, po jejímž splnění se ukončí jak vnitřní, tak i
vnější smyčka. V&nbsp;tomto případě musíme použít příkaz <strong>break</strong>
s&nbsp;takzvaným <i>návěštím</i>. To se zapisuje před tu smyčku, která se má
ukončit (můžeme mít prakticky libovolné množství vnořených smyček). Za návěštím
se vždy zapisuje dvojtečka:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
<strong>Exit</strong>:
        for i := 1; i &lt;= 10; i++ {
                for j := 1; j &lt;= 10; j++ {
                        fmt.Printf("%3d ", i*j)
                        if i*j == 42 {
                                fmt.Println("\nodpověď nalezena!\n")
                                <strong>break Exit</strong>
                        }
                }
                fmt.Println()
        }
}
</pre>

<p>Výsledek bude vypadat takto:</p>

<pre>
  1   2   3   4   5   6   7   8   9  10
  2   4   6   8  10  12  14  16  18  20
  3   6   9  12  15  18  21  24  27  30
  4   8  12  16  20  24  28  32  36  40
  5  10  15  20  25  30  35  40  45  50
  6  12  18  24  30  36  42
odpověď nalezena!
</pre>

<p>Alternativně je samozřejmě možné použít i příkaz <strong>continue</strong>
s&nbsp;návěštím:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
<strong>Exit:</strong>
        for i := 1; i &lt;= 10; i++ {
                for j := 1; j &lt;= 10; j++ {
                        fmt.Printf("%3d ", i*j)
                        if i*j == 42 {
                                fmt.Println("\nodpověď nalezena!\nzkusím další řadu")
                                <strong>continue Exit</strong>
                        }
                }
                fmt.Println()
        }
}
</pre>

<p>Nyní bude výstup programu samozřejmě zcela odlišný:</p>

<pre>
  1   2   3   4   5   6   7   8   9  10 
  2   4   6   8  10  12  14  16  18  20 
  3   6   9  12  15  18  21  24  27  30 
  4   8  12  16  20  24  28  32  36  40 
  5  10  15  20  25  30  35  40  45  50 
  6  12  18  24  30  36  42 
odpověď nalezena!
zkusím další řadu
  7  14  21  28  35  42 
odpověď nalezena!
zkusím další řadu
  8  16  24  32  40  48  56  64  72  80 
  9  18  27  36  45  54  63  72  81  90 
 10  20  30  40  50  60  70  80  90 100 
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Návrat do minulosti: příkaz <strong>goto</strong></h2>

<p>Zbývá nám popsat si ještě dvě řídicí konstrukce. První z&nbsp;nich se
&ndash; což je pro moderní programovací jazyk alespoň na první pohled
překvapivé &ndash; vytváří pomocí klíčového slova <strong>goto</strong>.
Použitím tohoto klíčového slova je možné realizovat nepodmíněný skok
v&nbsp;rámci jedné funkce nebo jednoho vybraného bloku. Příkaz
<strong>goto</strong> je sice obecně považován za škodlivý (ostatně ho
v&nbsp;novějších jazycích vůbec nenalezneme), ale existuje několik situací, kdy
může jeho použití algoritmus zpřehlednit [<a
href="https://web.archive.org/web/20051128093253/http://kerneltrap.org/node/553/2131">1</a>].
Jedná se například o implementaci konečného automatu, reakce na některé stavy
programu apod. S&nbsp;<strong>goto</strong> se v&nbsp;jazyce Go setkáme jen
málokdy, a to mj.&nbsp;i z&nbsp;toho důvodu, že je možné použít výskok
z&nbsp;vnitřní smyčky (viz předchozí kapitolu) a pro zpracování chyb se
používají odlišné konstrukce. Prozatím si tedy ani neukážeme žádný příklad,
protože by byl umělý a spíše by ukazoval, jak se <strong>goto</strong> používat
nemá :-)</p>

<p>Poslední jazyková konstrukce, která umožňuje (i když nepřímo) měnit běh
programu, je realizována příkazem <strong>defer</strong>. Se způsobem použití
tohoto příkazu se podrobněji seznámíme v&nbsp;navazující části seriálu.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
doslova několik kilobajtů), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_main_function_only.go</td><td>kostra programu s&nbsp;funkcí main</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/01_main_function_only.go">https://github.com/tisnik/go-fedora/blob/master/article_05/01_main_function_only.go</a></td></tr>
<tr><td> 2</td><td>02_return_statement.go</td><td>příkaz return bez návratové hodnoty</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/02_return_statement.go">https://github.com/tisnik/go-fedora/blob/master/article_05/02_return_statement.go</a></td></tr>
<tr><td> 3</td><td>03_return_statement_no_value.go</td><td>více příkazů return</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/03_return_statement_no_value.go">https://github.com/tisnik/go-fedora/blob/master/article_05/03_return_statement_no_value.go</a></td></tr>
<tr><td> 4</td><td>04_return_statement_int_value.go</td><td>více příkazů return u funkce vracející int</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/04_return_statement_int_value.go">https://github.com/tisnik/go-fedora/blob/master/article_05/04_return_statement_int_value.go</a></td></tr>
<tr><td> 5</td><td>05_return_statement_int_value.go</td><td>více příkazů return u funkce vracející int</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/05_return_statement_int_value.go">https://github.com/tisnik/go-fedora/blob/master/article_05/05_return_statement_int_value.go</a></td></tr>
<tr><td> 6</td><td>06_if_statement.go</td><td>použití příkazu if</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/06_if_statement.go">https://github.com/tisnik/go-fedora/blob/master/article_05/06_if_statement.go</a></td></tr>
<tr><td> 7</td><td>07_if_statement_bad_type.go</td><td>příkaz if se špatným typem výrazu</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/07_if_statement_bad_type.go">https://github.com/tisnik/go-fedora/blob/master/article_05/07_if_statement_bad_type.go</a></td></tr>
<tr><td> 8</td><td>08_if_statement_nil.go</td><td>příkaz if se špatným typem výrazu</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/08_if_statement_nil.go">https://github.com/tisnik/go-fedora/blob/master/article_05/08_if_statement_nil.go</a></td></tr>
<tr><td> 9</td><td>09_if_else_construct.go</td><td>úplná konstrukce if-else</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/09_if_else_construct.go">https://github.com/tisnik/go-fedora/blob/master/article_05/09_if_else_construct.go</a></td></tr>
<tr><td>10</td><td>10_bad_syntax.go</td><td>špatné umístění závorky u else</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/10_bad_syntax.go">https://github.com/tisnik/go-fedora/blob/master/article_05/10_bad_syntax.go</a></td></tr>
<tr><td>11</td><td>11_switch_statement.go</td><td>použití příkazu switch</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/11_switch_statement.go">https://github.com/tisnik/go-fedora/blob/master/article_05/11_switch_statement.go</a></td></tr>
<tr><td>12</td><td>12_constants_in_switch.go</td><td>konstanty v&nbsp;konstrukci switch</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/12_constants_in_switch.go">https://github.com/tisnik/go-fedora/blob/master/article_05/12_constants_in_switch.go</a></td></tr>
<tr><td>13</td><td>13_variables_in_switch.go</td><td>proměnné v&nbsp;konstrukci switch</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/13_variables_in_switch.go">https://github.com/tisnik/go-fedora/blob/master/article_05/13_variables_in_switch.go</a></td></tr>
<tr><td>14</td><td>14_conditions_in_switch.go</td><td>konstrukce switch a podmínky u case</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/14_conditions_in_switch.go">https://github.com/tisnik/go-fedora/blob/master/article_05/14_conditions_in_switch.go</a></td></tr>
<tr><td>15</td><td>15_no_fallthrough_in_switch.go</td><td>chybějící klíčové slovo fallthrough</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/15_no_fallthrough_in_switch.go">https://github.com/tisnik/go-fedora/blob/master/article_05/15_no_fallthrough_in_switch.go</a></td></tr>
<tr><td>16</td><td>16_fallthrough_in_switch.go</td><td>použití klíčového slova fallthrough</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/16_fallthrough_in_switch.go">https://github.com/tisnik/go-fedora/blob/master/article_05/16_fallthrough_in_switch.go</a></td></tr>
<tr><td>17</td><td>17_switch_combinations.go</td><td>kombinace různých možností switch</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/17_switch_combinations.go">https://github.com/tisnik/go-fedora/blob/master/article_05/17_switch_combinations.go</a></td></tr>
<tr><td>18</td><td>18_switch_on_string.go</td><td>switch a řetězce</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/18_switch_on_string.go">https://github.com/tisnik/go-fedora/blob/master/article_05/18_switch_on_string.go</a></td></tr>
<tr><td>19</td><td>19_simplest_for_loop.go</td><td>nekonečná smyčka</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/19_simplest_for_loop.go">https://github.com/tisnik/go-fedora/blob/master/article_05/19_simplest_for_loop.go</a></td></tr>
<tr><td>20</td><td>20_basic_for_loop.go</td><td>druhá forma nekonečné smyčky</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/20_basic_for_loop.go">https://github.com/tisnik/go-fedora/blob/master/article_05/20_basic_for_loop.go</a></td></tr>
<tr><td>21</td><td>21_for_loop_with_condition.go</td><td>smyčka s testem na začátku</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/21_for_loop_with_condition.go">https://github.com/tisnik/go-fedora/blob/master/article_05/21_for_loop_with_condition.go</a></td></tr>
<tr><td>22</td><td>22_c_like_loop.go</td><td>céčkovská varianta smyčky</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/22_c_like_loop.go">https://github.com/tisnik/go-fedora/blob/master/article_05/22_c_like_loop.go</a></td></tr>
<tr><td>23</td><td>23_better_for.go</td><td>vylepšení předchozího příkladu</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/23_better_for.go">https://github.com/tisnik/go-fedora/blob/master/article_05/23_better_for.go</a></td></tr>
<tr><td>24</td><td>24_better_for_local_variable.go</td><td>lokální řídicí proměnná smyčky</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/24_better_for_local_variable.go">https://github.com/tisnik/go-fedora/blob/master/article_05/24_better_for_local_variable.go</a></td></tr>
<tr><td>25</td><td>25_for_range.go</td><td>programová smyčka for-range</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/25_for_range.go">https://github.com/tisnik/go-fedora/blob/master/article_05/25_for_range.go</a></td></tr>
<tr><td>26</td><td>26_for_range_map.go</td><td>iterace přes hodnoty uložené do mapy</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/26_for_range_map.go">https://github.com/tisnik/go-fedora/blob/master/article_05/26_for_range_map.go</a></td></tr>
<tr><td>27</td><td>27_break_statement.go</td><td>použití příkazu break</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/27_break_statement.go">https://github.com/tisnik/go-fedora/blob/master/article_05/27_break_statement.go</a></td></tr>
<tr><td>28</td><td>28_continue_statement.go</td><td>použití příkazu continue</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/28_continue_statement.go">https://github.com/tisnik/go-fedora/blob/master/article_05/28_continue_statement.go</a></td></tr>
<tr><td>29</td><td>29_nested_loops.go</td><td>vnořené smyčky</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/29_nested_loops.go">https://github.com/tisnik/go-fedora/blob/master/article_05/29_nested_loops.go</a></td></tr>
<tr><td>30</td><td>30_break_from_inner_loop.go</td><td>příkaz break s návěštím</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/30_break_from_inner_loop.go">https://github.com/tisnik/go-fedora/blob/master/article_05/30_break_from_inner_loop.go</a></td></tr>
<tr><td>31</td><td>31_continue_from_inner_loop.go</td><td>příkaz continue s návěštím</td><td><a href="https://github.com/tisnik/go-fedora/blob/master/article_05/31_continue_from_inner_loop.go">https://github.com/tisnik/go-fedora/blob/master/article_05/31_continue_from_inner_loop.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go <br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

<li>Printf Format Strings<br />
<a href="https://www.cprogramming.com/tutorial/printf-format-strings.html">https://www.cprogramming.com/tutorial/printf-format-strings.html</a>
</li>

<li>Java: String.format<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-</a>
</li>

<li>Java: format string syntax<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a>
</li>

<li>Selectors<br />
<a href="https://golang.org/ref/spec#Selectors">https://golang.org/ref/spec#Selectors</a>
</li>

<li>Calling Go code from Python code<br />
<a href="http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/">http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/</a>
</li>

<li>Go Data Structures: Interfaces <br />
<a href="https://research.swtch.com/interfaces">https://research.swtch.com/interfaces</a>
</li>

<li>How to use interfaces in Go<br />
<a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go</a>
</li>

<li>Interfaces in Go (part I)<br />
<a href="https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c">https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c</a>
</li>

<li>Part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>What about Trait support in Golang?<br />
<a href="https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/">https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/</a>
</li>

<li>Don't Get Bitten by Pointer vs Non-Pointer Method Receivers in Golang<br />
<a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/">https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/</a>
</li>

<li>Control Flow<br />
<a href="https://en.wikipedia.org/wiki/Control_flow">https://en.wikipedia.org/wiki/Control_flow</a>
</li>

<li>Structured programming<br />
<a href="https://en.wikipedia.org/wiki/Structured_programming">https://en.wikipedia.org/wiki/Structured_programming</a>
</li>

<li>Control Structures<br />
<a href="https://www.golang-book.com/books/intro/5">https://www.golang-book.com/books/intro/5</a>
</li>

<li>Control structures - Go if else statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html">http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html</a>
</li>

<li>Control structures - Go switch case statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html</a>
</li>

<li>Control structures - Go for loop, break, continue, range<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html</a>
</li>

<li>Single Function Exit Point<br />
<a href="http://wiki.c2.com/?SingleFunctionExitPoint">http://wiki.c2.com/?SingleFunctionExitPoint</a>
</li>

<li>Entry point<br />
<a href="https://en.wikipedia.org/wiki/Entry_point">https://en.wikipedia.org/wiki/Entry_point</a>
</li>

<li>Why does Go have a GOTO statement?!<br />
<a href="https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/">https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>
