<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Serializace a deserializace datových struktur v programovacím jazyce Go (2.část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Serializace a deserializace datových struktur v programovacím jazyce Go (2.část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Popisem problematiky serializace datových struktur se budeme zabývat i dnes. Mj. si ukážeme, jakým způsobem lze BSON zapsaný v Go přečíst v Pythonu a jakou katastrofou mohou být při serializaci grafy obsahující cyklus.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Serializace a deserializace datových struktur v&nbsp;programovacím jazyce Go (2.část)</a></p>
<p><a href="#k02">2. Uložení jednoduchých datových typů do formátu <i>gob</i></a></p>
<p><a href="#k03">3. Serializace celých čísel bez znaménka</a></p>
<p><a href="#k04">4. Serializace celých čísel se znaménkem</a></p>
<p><a href="#k05">5. Uložení složitějších datových struktur &ndash; řezů celých čísel</a></p>
<p><a href="#k06">6. Datové struktury s&nbsp;ukazateli &ndash; binární stromy</a></p>
<p><a href="#k07">7. Serializace binárního stromu do formátu <i>gob</i></a></p>
<p><a href="#k08">8. Serializace a deserializace binárního stromu s&nbsp;využitím formátu <i>gob</i></a></p>
<p><a href="#k09">9. Serializace a deserializace binárního stromu s&nbsp;využitím formátu <i>JSON</i></a></p>
<p><a href="#k10">10. Serializace a deserializace binárního stromu s&nbsp;využitím formátu <i>BSON</i></a></p>
<p><a href="#k11">11. Porovnání velikosti výsledných souborů se serializovanými daty</a></p>
<p><a href="#k12">12. Vektor obsahující hodnoty s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k13">13. Serializovaná struktura obsahující jediný atribut &ndash; dlouhý řetězec</a></p>
<p><a href="#k14">14. Serializovaný strom s&nbsp;255 uzly</a></p>
<p><a href="#k15">15. Výsledek porovnání, vliv komprimace dat</a></p>
<p><a href="#k16">16. Problematika serializace grafových struktur</a></p>
<p><a href="#k17">17. Graf po deserialiaci</a></p>
<p><a href="#k18">18. Cyklus v&nbsp;datových strukturách (grafu atd.)</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Serializace a deserializace datových struktur v&nbsp;programovacím jazyce Go (2.část)</h2>

<p>V&nbsp;dnešní části <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">seriálu o
programovacím jazyce Go</a> budeme pokračovat v&nbsp;popisu problematiky, které
jsme se začali zabývat <a
href="https://www.root.cz/clanky/serializace-a-deserializace-datovych-struktur-v-programovacim-jazyce-go/">minule</a>.
Připomeňme si, že se jedná o serializaci i deserializaci datových struktur.
Jedná se o velmi často používanou operaci, neboť mnohdy je nutné datové
struktury ukládat (ať již do běžných souborů, nebo do (post)relačních databází)
a taktéž přenášet. Přes serializaci a deserializaci datových struktur lze
poměrně jednoduše realizovat i vzdálené volání procedur neboli <i>RPC (Remote
Procedure Call)</i> (použít lze i balíček <a
href="https://golang.org/pkg/net/rpc/">net/rpc</a>, popř.&nbsp;v&nbsp;případě
potřeby složitější mechanismy). Dnes se naposledy budeme zabývat použitím
binárního formátu <i>BSON</i> i nativního formátu jazyka Go &ndash; <i>gob</i>.
Navíc provedeme porovnání velikosti souborů se serializovanými daty, protože
právě snahy o zmenšení objemu dat vedou k&nbsp;používání binárních formátů
oproti formátům textovým (další snahou je snížení doby serializace a
deserializace).</p>

<p><div class="rs-tip-major">Poznámka: při serializaci složitějších datových
struktur, například grafů, může docházet k&nbsp;některých neočekávaným
situacím. I na ty v&nbsp;dnešním článku upozorníme.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Uložení jednoduchých datových typů do formátu <i>gob</i></h2>

<p>Už minule jsme se zmínili o formátu <i>gob</i> neboli <i>Go Object(s)</i>.
Jak již z&nbsp;názvu tohoto formátu vyplývá, je primárně určen pro použití
v&nbsp;programovacím jazyku Go pro serializaci a deserializaci prakticky
libovolné datové struktury popř.&nbsp;struktur, které mohou být propojeny přes
reference (neboli ukazatele). Zajímavé je, jak jsou serializovány celočíselné
hodnoty &ndash; zde nezáleží na použitém datovém typu (<i>int8</i>,
<i>int16</i>, <i>int32</i>, <i>int64</i> atd.), ale na velikosti ukládané
konstanty. V&nbsp;dnešním prvním demonstračním příkladu si toto chování
ověříme, neboť budeme provádět serializaci hodnot různých typů (tedy i bitové
šířky):</p>

<pre>
var b bool = true
var x uint8 = 42
var y uint16 = 42
var z uint32 = 42
</pre>

<p>Demonstrační příklad, v&nbsp;němž je serializace provedena (lokálně do
bufferu) může vypadat následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "encoding/gob"
        "encoding/hex"
        "fmt"
)
&nbsp;
func <strong>encodeAndDecode</strong>(msg string, value interface{}) {
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
&nbsp;
        err := encoder.Encode(value)
        if err != nil {
                fmt.Println(err)
        } else {
                content := buffer.Bytes()
                fmt.Printf("%s value encoded into %d bytes\n", msg, len(content))
                encoded := hex.EncodeToString(content)
                fmt.Println(encoded)
        }
}
&nbsp;
func <strong>main</strong>() {
        var b bool = true
        encodeAndDecode("Boolean", b)
&nbsp;
        var x uint8 = 42
        encodeAndDecode("Uint8", x)
&nbsp;
        var y uint16 = 42
        encodeAndDecode("Uint16", y)
&nbsp;
        var z uint32 = 42
        encodeAndDecode("Uint32", z)
}
</pre>

<p>Z&nbsp;výsledků je patrné, že nezávisle na velikosti datové struktury jsou
data serializována do stejně dlouhé sekvence, zde konkrétně do čtyř bajtů.
První bajt obsahuje délku sekvence (3 bajty), další typ, poté index
v&nbsp;rámci datové pseudostruktury a konečně následuje ukládaná hodnota:</p>

<pre>
Boolean value encoded into 4 bytes
03020001
Uint8 value encoded into 4 bytes
0306002a
Uint16 value encoded into 4 bytes
0306002a
Uint32 value encoded into 4 bytes
0306002a
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Serializace celých čísel bez znaménka</h2>

<p>S&nbsp;celými čísly se při použití formátu <i>gob</i> pracuje podobně jako
s&nbsp;celočíselnými konstantami. Jedná se o abstraktní typ bez explicitní
specifikace velikosti, protože velikost čísla (v&nbsp;bajtech) je odvozena od
jeho konkrétní hodnoty a nikoli od datového typu. Způsob uložení je přitom
následující:</p>

<ul>

<li>Pokud je hodnota menší než 128, je přímo uložena jako jeden bajt do
<i>gob</i>u.</li>

<li>U větší hodnoty je zjištěn počet potřebných bajtů. Následně je tento počet
uložen do <i>gob</i>u v&nbsp;negované podobě (aby se nespletl s&nbsp;malým
číslem) a poté je uložena sekvence bajtů představující ono číslo (v&nbsp;pořadí
big endian).</li>

</ul>

<p>Příkladem může být hodnota 256, která je uložena do sekvence bajtů
<strong>FE 01 00</strong></p>

<p>Ukažme si nyní způsob uložení hodnot, které &bdquo;překlenují&ldquo; celý
64bitový prostor datového typu <strong>uint64</strong>:</p>

<pre>
var value uint64 = 1
for i := 0; i &lt; 64; i++ {
        encodeAndDecodeUint(value)
        value &lt;&lt;= 1
}
</pre>

<p>Realizace demonstračního příkladu vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "encoding/gob"
        "encoding/hex"
        "fmt"
)
&nbsp;
func <strong>encodeAndDecodeUint</strong>(value uint64) {
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
&nbsp;
        err := encoder.Encode(value)
        if err != nil {
                fmt.Println(err)
        } else {
                content := buffer.Bytes()
                fmt.Printf("%20d value encoded into %d bytes: ", value, len(content))
                encoded := hex.EncodeToString(content)
                fmt.Println(encoded)
        }
}
&nbsp;
func <strong>main</strong>() {
        var value uint64 = 1
        for i := 0; i &lt; 64; i++ {
                encodeAndDecodeUint(value)
                value &lt;&lt;= 1
        }
}
</pre>

<p>Z&nbsp;výsledků je patrné, jak se postupně se zvyšující se hodnotou mění i
počet potřebných bajtů:</p>

<pre>
                   1 value encoded into 4 bytes: 03060001
                   2 value encoded into 4 bytes: 03060002
                   4 value encoded into 4 bytes: 03060004
                   8 value encoded into 4 bytes: 03060008
                  16 value encoded into 4 bytes: 03060010
                  32 value encoded into 4 bytes: 03060020
                  64 value encoded into 4 bytes: 03060040
                 128 value encoded into 5 bytes: 040600ff80
                 256 value encoded into 6 bytes: 050600fe0100
                 512 value encoded into 6 bytes: 050600fe0200
                1024 value encoded into 6 bytes: 050600fe0400
                2048 value encoded into 6 bytes: 050600fe0800
                4096 value encoded into 6 bytes: 050600fe1000
                8192 value encoded into 6 bytes: 050600fe2000
               16384 value encoded into 6 bytes: 050600fe4000
               32768 value encoded into 6 bytes: 050600fe8000
               65536 value encoded into 7 bytes: 060600fd010000
              131072 value encoded into 7 bytes: 060600fd020000
              262144 value encoded into 7 bytes: 060600fd040000
              524288 value encoded into 7 bytes: 060600fd080000
             1048576 value encoded into 7 bytes: 060600fd100000
             2097152 value encoded into 7 bytes: 060600fd200000
             4194304 value encoded into 7 bytes: 060600fd400000
             8388608 value encoded into 7 bytes: 060600fd800000
            16777216 value encoded into 8 bytes: 070600fc01000000
            33554432 value encoded into 8 bytes: 070600fc02000000
            67108864 value encoded into 8 bytes: 070600fc04000000
           134217728 value encoded into 8 bytes: 070600fc08000000
           268435456 value encoded into 8 bytes: 070600fc10000000
           536870912 value encoded into 8 bytes: 070600fc20000000
          1073741824 value encoded into 8 bytes: 070600fc40000000
          2147483648 value encoded into 8 bytes: 070600fc80000000
          4294967296 value encoded into 9 bytes: 080600fb0100000000
          8589934592 value encoded into 9 bytes: 080600fb0200000000
         17179869184 value encoded into 9 bytes: 080600fb0400000000
         34359738368 value encoded into 9 bytes: 080600fb0800000000
         68719476736 value encoded into 9 bytes: 080600fb1000000000
        137438953472 value encoded into 9 bytes: 080600fb2000000000
        274877906944 value encoded into 9 bytes: 080600fb4000000000
        549755813888 value encoded into 9 bytes: 080600fb8000000000
       1099511627776 value encoded into 10 bytes: 090600fa010000000000
       2199023255552 value encoded into 10 bytes: 090600fa020000000000
       4398046511104 value encoded into 10 bytes: 090600fa040000000000
       8796093022208 value encoded into 10 bytes: 090600fa080000000000
      17592186044416 value encoded into 10 bytes: 090600fa100000000000
      35184372088832 value encoded into 10 bytes: 090600fa200000000000
      70368744177664 value encoded into 10 bytes: 090600fa400000000000
     140737488355328 value encoded into 10 bytes: 090600fa800000000000
     281474976710656 value encoded into 11 bytes: 0a0600f901000000000000
     562949953421312 value encoded into 11 bytes: 0a0600f902000000000000
    1125899906842624 value encoded into 11 bytes: 0a0600f904000000000000
    2251799813685248 value encoded into 11 bytes: 0a0600f908000000000000
    4503599627370496 value encoded into 11 bytes: 0a0600f910000000000000
    9007199254740992 value encoded into 11 bytes: 0a0600f920000000000000
   18014398509481984 value encoded into 11 bytes: 0a0600f940000000000000
   36028797018963968 value encoded into 11 bytes: 0a0600f980000000000000
   72057594037927936 value encoded into 12 bytes: 0b0600f80100000000000000
  144115188075855872 value encoded into 12 bytes: 0b0600f80200000000000000
  288230376151711744 value encoded into 12 bytes: 0b0600f80400000000000000
  576460752303423488 value encoded into 12 bytes: 0b0600f80800000000000000
 1152921504606846976 value encoded into 12 bytes: 0b0600f81000000000000000
 2305843009213693952 value encoded into 12 bytes: 0b0600f82000000000000000
 4611686018427387904 value encoded into 12 bytes: 0b0600f84000000000000000
 9223372036854775808 value encoded into 12 bytes: 0b0600f88000000000000000
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;nejhorším případě je použito
dvanáct bajtů, protože musíme započítat celkovou délku (jeden bajt), typ (druhý
bajt), index v&nbsp;rámci datové pseudostruktury (třetí bajt), negovanou šířku
čísla (čtvrtý bajt) a následně osm bajtů s&nbsp;vlastní hodnotou.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Serializace celých čísel se znaménkem</h2>

<p>Podobným způsobem, tedy s&nbsp;proměnnou bajtovou šířkou, jsou serializovány
i hodnoty se znaménkem. Bude se pochopitelně lišit datový typ položky (druhý
bajt) i samotné kódování, kde poslední bit (s&nbsp;nejnižší vahou) nese hodnotu
znaménka. Opět si toto chování ověřme na demonstračním příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "encoding/gob"
        "encoding/hex"
        "fmt"
)
&nbsp;
func <strong>encodeAndDecodeInt</strong>(value int64) {
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
&nbsp;
        err := encoder.Encode(value)
        if err != nil {
                fmt.Println(err)
        } else {
                content := buffer.Bytes()
                fmt.Printf("%20d value encoded into %d bytes: ", value, len(content))
                encoded := hex.EncodeToString(content)
                fmt.Println(encoded)
        }
}
&nbsp;
func <strong>main</strong>() {
        var value int64 = -1
        for i := 0; i &lt; 63; i++ {
                encodeAndDecodeInt(value)
                value &lt;&lt;= 1
        }
}
</pre>

<p>Výsledky budou v&nbsp;tomto případě vypadat podobně jako u demonstračního
příkladu popsaného <a href="#k03">v&nbsp;předchozí kapitole</a>:</p>

<pre>
                  -1 value encoded into 4 bytes: 03040001
                  -2 value encoded into 4 bytes: 03040003
                  -4 value encoded into 4 bytes: 03040007
                  -8 value encoded into 4 bytes: 0304000f
                 -16 value encoded into 4 bytes: 0304001f
                 -32 value encoded into 4 bytes: 0304003f
                 -64 value encoded into 4 bytes: 0304007f
                -128 value encoded into 5 bytes: 040400ffff
                -256 value encoded into 6 bytes: 050400fe01ff
                -512 value encoded into 6 bytes: 050400fe03ff
               -1024 value encoded into 6 bytes: 050400fe07ff
               -2048 value encoded into 6 bytes: 050400fe0fff
               -4096 value encoded into 6 bytes: 050400fe1fff
               -8192 value encoded into 6 bytes: 050400fe3fff
              -16384 value encoded into 6 bytes: 050400fe7fff
              -32768 value encoded into 6 bytes: 050400feffff
              -65536 value encoded into 7 bytes: 060400fd01ffff
             -131072 value encoded into 7 bytes: 060400fd03ffff
             -262144 value encoded into 7 bytes: 060400fd07ffff
             -524288 value encoded into 7 bytes: 060400fd0fffff
            -1048576 value encoded into 7 bytes: 060400fd1fffff
            -2097152 value encoded into 7 bytes: 060400fd3fffff
            -4194304 value encoded into 7 bytes: 060400fd7fffff
            -8388608 value encoded into 7 bytes: 060400fdffffff
           -16777216 value encoded into 8 bytes: 070400fc01ffffff
           -33554432 value encoded into 8 bytes: 070400fc03ffffff
           -67108864 value encoded into 8 bytes: 070400fc07ffffff
          -134217728 value encoded into 8 bytes: 070400fc0fffffff
          -268435456 value encoded into 8 bytes: 070400fc1fffffff
          -536870912 value encoded into 8 bytes: 070400fc3fffffff
         -1073741824 value encoded into 8 bytes: 070400fc7fffffff
         -2147483648 value encoded into 8 bytes: 070400fcffffffff
         -4294967296 value encoded into 9 bytes: 080400fb01ffffffff
         -8589934592 value encoded into 9 bytes: 080400fb03ffffffff
        -17179869184 value encoded into 9 bytes: 080400fb07ffffffff
        -34359738368 value encoded into 9 bytes: 080400fb0fffffffff
        -68719476736 value encoded into 9 bytes: 080400fb1fffffffff
       -137438953472 value encoded into 9 bytes: 080400fb3fffffffff
       -274877906944 value encoded into 9 bytes: 080400fb7fffffffff
       -549755813888 value encoded into 9 bytes: 080400fbffffffffff
      -1099511627776 value encoded into 10 bytes: 090400fa01ffffffffff
      -2199023255552 value encoded into 10 bytes: 090400fa03ffffffffff
      -4398046511104 value encoded into 10 bytes: 090400fa07ffffffffff
      -8796093022208 value encoded into 10 bytes: 090400fa0fffffffffff
     -17592186044416 value encoded into 10 bytes: 090400fa1fffffffffff
     -35184372088832 value encoded into 10 bytes: 090400fa3fffffffffff
     -70368744177664 value encoded into 10 bytes: 090400fa7fffffffffff
    -140737488355328 value encoded into 10 bytes: 090400faffffffffffff
    -281474976710656 value encoded into 11 bytes: 0a0400f901ffffffffffff
    -562949953421312 value encoded into 11 bytes: 0a0400f903ffffffffffff
   -1125899906842624 value encoded into 11 bytes: 0a0400f907ffffffffffff
   -2251799813685248 value encoded into 11 bytes: 0a0400f90fffffffffffff
   -4503599627370496 value encoded into 11 bytes: 0a0400f91fffffffffffff
   -9007199254740992 value encoded into 11 bytes: 0a0400f93fffffffffffff
  -18014398509481984 value encoded into 11 bytes: 0a0400f97fffffffffffff
  -36028797018963968 value encoded into 11 bytes: 0a0400f9ffffffffffffff
  -72057594037927936 value encoded into 12 bytes: 0b0400f801ffffffffffffff
 -144115188075855872 value encoded into 12 bytes: 0b0400f803ffffffffffffff
 -288230376151711744 value encoded into 12 bytes: 0b0400f807ffffffffffffff
 -576460752303423488 value encoded into 12 bytes: 0b0400f80fffffffffffffff
-1152921504606846976 value encoded into 12 bytes: 0b0400f81fffffffffffffff
-2305843009213693952 value encoded into 12 bytes: 0b0400f83fffffffffffffff
-4611686018427387904 value encoded into 12 bytes: 0b0400f87fffffffffffffff
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jak jsou záporná čísla
ukládána &ndash; poslední bit vždy obsahuje znaménko.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Uložení složitějších datových struktur &ndash; řezů celých čísel</h2>

<p>Velmi často se setkáme s&nbsp;potřebou uložení mnohdy velmi dlouhých řezů
s&nbsp;celočíselnými hodnotami popř.&nbsp;hodnotami typu <i>float32</i> a
<i>float64</i>. Samotný řez je přitom přenesen relativně komplikovaným způsobem
&ndash; jako explicitně popsaný datový typ s&nbsp;délkou a vlastními daty.
Konkrétní chování si opět můžeme ukázat na příkladu, nyní na následujících
řezech, které jsou sice stejného typu, ovšem liší se počtem položek i jejich
rozsahem:</p>

<pre>
values1 := []int64{}
values2 := []int64{1, 2, 3, 4}
values3 := []int64{1, 2, 3, 4, 5}
values4 := []int64{1000000, 2000000, 3000000, 4000000}
</pre>

<p>Výsledek bude po spuštění tohoto demonstračního příkladu vypadat
následovně:</p>

<pre>
Slice with 0 values encoded into 18 bytes: 0cff81020102ff82000104000004ff820000
Slice with 4 values encoded into 22 bytes: 0cff81020102ff82000104000008ff82000402040608
Slice with 5 values encoded into 23 bytes: 0cff81020102ff82000104000009ff820005020406080a
Slice with 4 values encoded into 34 bytes: 0cff81020102ff82000104000014ff820004fd1e8480fd3d0900fd5b8d80fd7a1200
</pre>

<p>Povšimněte si naprosto stejného prefixu u všech čtyř řezů (13 bajtů):</p>

<pre>
0cff81020102ff820001040000
</pre>

<p>Liší se obsah řezu, tedy jeho délka (v&nbsp;bajtech), počet položek a jejich
konkrétní hodnoty zakódované způsobem popsaným v&nbsp;předchozích dvou
kapitolách.</p>

<p><div class="rs-tip-major">Poznámka: přeneseny jsou i nulové hodnoty, na
rozdíl od situace, kdy se jedná o nulovou hodnotu primitivního datového
typu.</div></p>

<p>Úplný zdrojový kód takto připraveného demonstračního příkladu vypadá
následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "encoding/gob"
        "encoding/hex"
        "fmt"
)
&nbsp;
func <strong>encodeAndDecodeSliceOfInts</strong>(values []int64) {
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
&nbsp;
        err := encoder.Encode(values)
        if err != nil {
                fmt.Println(err)
        } else {
                content := buffer.Bytes()
                fmt.Printf("Slice with %d values encoded into %d bytes: ", len(values), len(content))
                encoded := hex.EncodeToString(content)
                fmt.Println(encoded)
        }
}
&nbsp;
func <strong>main</strong>() {
        values1 := []int64{}
        encodeAndDecodeSliceOfInts(values1)
&nbsp;
        values2 := []int64{1, 2, 3, 4}
        encodeAndDecodeSliceOfInts(values2)
&nbsp;
        values3 := []int64{1, 2, 3, 4, 5}
        encodeAndDecodeSliceOfInts(values3)
&nbsp;
        values4 := []int64{1000000, 2000000, 3000000, 4000000}
        encodeAndDecodeSliceOfInts(values4)
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Datové struktury s&nbsp;ukazateli &ndash; binární stromy</h2>

<p>Už v&nbsp;předchozím textu jsme si řekli, že do formátu <i>gob</i> lze
ukládat i datové struktury obsahující ukazatele. Ukažme si tuto velmi užitečnou
vlastnost na velmi známé datové struktuře založené na ukazatelích. Jedná se o
binární stromy (<i>binary tree</i>), konkrétně o binární stromy, do nichž se
prvky ukládají takovým způsobem, aby se u vyváženého stromu zajistilo vyhledání
prvku v&nbsp;logaritmickém čase (<i>binary search tree</i>). Dále uvedená
implementace binárních stromů je podrobněji popsána v&nbsp;článku <a
href="https://flaviocopes.com/golang-data-structure-binary-search-tree/">Go
Data Structures: Binary Search Tree</a>. Uzel je popsán strukturou
<strong>Node</strong>, vlastní uložená hodnota pak datovým typem
<strong>Item</strong>:</p>

<pre>
type <strong>Item</strong> int
&nbsp;
type <strong>Node</strong> struct {
        value Item
        left  *Node
        right *Node
}
&nbsp;
type <strong>BinaryTree</strong> struct {
        root *Node
}
</pre>

<p>Důležitá je metoda <strong>Insert</strong>, která společně s&nbsp;pomocnou
funkcí <strong>insertNode</strong> zajistí vložení nového uzlu do stromu na
správné místo (uzly nalevo obsahují menší hodnotu, uzly napravo hodnotu
větší):</p>

<pre>
func (bt *BinaryTree) <strong>Insert</strong>(value Item) {
        node := &amp;Node{value, nil, nil}
        if bt.root == nil {
                bt.root = node
        } else {
                insertNode(bt.root, node)
        }
}
&nbsp;
func <strong>insertNode</strong>(node, newNode *Node) {
        if newNode.value &lt; node.value {
                if node.left == nil {
                        node.left = newNode
                } else {
                        insertNode(node.left, newNode)
                }
        } else {
                if node.right == nil {
                        node.right = newNode
                } else {
                        insertNode(node.right, newNode)
                }
        }
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jak je implementace
v&nbsp;Go jednoduchá například v&nbsp;porovnání s&nbsp;céčkovou implementací
&ndash; jednoduchost je zajištěna automatickým správcem paměti, kdy se nemusíme
starat o alokaci a dealokaci celé struktury binárního stromu.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Serializace binárního stromu do formátu <i>gob</i></h2>

<p>Samozřejmě nám nic nebrání pokusit se o serializaci binárního stromu do
formátu <i>gob</i>. Pokusíme se nejprve o zobrazení serializovaných dat
v&nbsp;hexadecimálním tvaru i o uložení bufferu do externího souboru:</p>

<pre>
func <strong>encodeAndDecodeBinaryTree</strong>(bt BinaryTree) {
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
&nbsp;
        err := encoder.Encode(bt)
        if err != nil {
                fmt.Println(err)
        } else {
                content := buffer.Bytes()
                fmt.Printf("Binary tree encoded into %d bytes: ", len(content))
                encoded := hex.EncodeToString(content)
                fmt.Println(encoded)
&nbsp;
                err = ioutil.WriteFile("tree1.gob", content, 0644)
                if err != nil {
                        fmt.Println(err)
                } else {
                        fmt.Println("And stored into file")
                }
        }
}
</pre>

<p>Celý zdrojový soubor vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "encoding/gob"
        "encoding/hex"
        "fmt"
        "io/ioutil"
)
&nbsp;
type <strong>Item</strong> int
&nbsp;
type <strong>Node</strong> struct {
        value Item
        left  *Node
        right *Node
}
&nbsp;
type <strong>BinaryTree</strong> struct {
        root *Node
}
&nbsp;
func (bt *BinaryTree) <strong>Insert</strong>(value Item) {
        node := &amp;Node{value, nil, nil}
        if bt.root == nil {
                bt.root = node
        } else {
                insertNode(bt.root, node)
        }
}
&nbsp;
func <strong>insertNode</strong>(node, newNode *Node) {
        if newNode.value &lt; node.value {
                if node.left == nil {
                        node.left = newNode
                } else {
                        insertNode(node.left, newNode)
                }
        } else {
                if node.right == nil {
                        node.right = newNode
                } else {
                        insertNode(node.right, newNode)
                }
        }
}
&nbsp;
func <strong>encodeAndDecodeBinaryTree</strong>(bt BinaryTree) {
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
&nbsp;
        err := encoder.Encode(bt)
        if err != nil {
                fmt.Println(err)
        } else {
                content := buffer.Bytes()
                fmt.Printf("Binary tree encoded into %d bytes: ", len(content))
                encoded := hex.EncodeToString(content)
                fmt.Println(encoded)
&nbsp;
                err = ioutil.WriteFile("tree1.gob", content, 0644)
                if err != nil {
                        fmt.Println(err)
                } else {
                        fmt.Println("And stored into file")
                }
        }
}
&nbsp;
func <strong>main</strong>() {
        var bt BinaryTree
        bt.Insert(5)
        bt.Insert(3)
        bt.Insert(7)
        bt.Insert(1)
        bt.Insert(4)
        bt.Insert(6)
        bt.Insert(8)
        bt.Insert(9)
        bt.Insert(10)
        bt.Insert(0)
&nbsp;
        encodeAndDecodeBinaryTree(bt)
}
</pre>

<p>Při pokusu o serializaci však dojde k&nbsp;chybě způsobené tím, že žádný
prvek struktury nezačíná velkým písmenem a není ho tedy možné exportovat:</p>

<pre>
gob: type main.BinaryTree has no exported fields
</pre>

<p>Úprava je snadná &ndash; pouze změníme jména všech prvků ve struktuře
<strong>Node</strong> a <strong>BinaryTree</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "encoding/gob"
        "encoding/hex"
        "fmt"
        "io/ioutil"
)
&nbsp;
type <strong>Item</strong> int
&nbsp;
type <strong>Node</strong> struct {
        Value Item
        Left  *Node
        Right *Node
}
&nbsp;
type <strong>BinaryTree</strong> struct {
        Root *Node
}
&nbsp;
func (bt *BinaryTree) <strong>Insert</strong>(value Item) {
        node := &amp;Node{value, nil, nil}
        if bt.Root == nil {
                bt.Root = node
        } else {
                insertNode(bt.Root, node)
        }
}
&nbsp;
func <strong>insertNode</strong>(node, newNode *Node) {
        if newNode.Value &lt; node.Value {
                if node.Left == nil {
                        node.Left = newNode
                } else {
                        insertNode(node.Left, newNode)
                }
        } else {
                if node.Right == nil {
                        node.Right = newNode
                } else {
                        insertNode(node.Right, newNode)
                }
        }
}
&nbsp;
func <strong>encodeAndDecodeBinaryTree</strong>(bt BinaryTree) {
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
&nbsp;
        err := encoder.Encode(bt)
        if err != nil {
                fmt.Println(err)
        } else {
                content := buffer.Bytes()
                fmt.Printf("Binary tree encoded into %d bytes: ", len(content))
                encoded := hex.EncodeToString(content)
                fmt.Println(encoded)
&nbsp;
                err = ioutil.WriteFile("tree1.gob", content, 0644)
                if err != nil {
                        fmt.Println(err)
                } else {
                        fmt.Println("And stored into file")
                }
        }
}
&nbsp;
func <strong>main</strong>() {
        var bt BinaryTree
        bt.Insert(5)
        bt.Insert(3)
        bt.Insert(7)
        bt.Insert(1)
        bt.Insert(4)
        bt.Insert(6)
        bt.Insert(8)
        bt.Insert(9)
        bt.Insert(10)
        bt.Insert(0)
&nbsp;
        encodeAndDecodeBinaryTree(bt)
}
</pre>

<p>Nyní již bude možné strom vytvořit, výsledek bude mít délku pouze 127 bajtů,
což je relativně málo (jak uvidíme dále):</p>

<pre>
Binary tree encoded into 127 bytes: 22ff810301010a42696e6172795472656501ff820001010104526f6f7401ff8400000031ff83030101044e6f646501ff84000103010556616c756501040001044c65667401ff84000105526967687401ff8400000029ff8201010a010106010102010000010108000001010e01010c00010110020112020114000000000000
And stored into file
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Serializace a deserializace binárního stromu s&nbsp;využitím formátu <i>gob</i></h2>

<p>Nyní již máme k&nbsp;dispozici všechny potřebné informace nutné pro
serializaci stromu do formátu <i>gob</i> a k&nbsp;jeho opětovné deserializaci.
Strukturu binárního stromu zobrazíme touto pomocnou funkcí (ta zobrazuje strom
&bdquo;naležato&ldquo;, což je implementačně jednodušší):</p>

<pre>
func <strong>printTree</strong>(node *Node, level int) {
        if node != nil {
                format := ""
                for i := 0; i &lt; level; i++ {
                        format += "       "
                }
                format += "---[ "
                level++
                printTree(node.Left, level)
                fmt.Printf(format+"%d\n", node.Value)
                printTree(node.Right, level)
        }
}
</pre>

<p>Implementace serializace a opětovné deserializace vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "encoding/gob"
        "fmt"
        "io/ioutil"
)
&nbsp;
type <strong>Item</strong> int
&nbsp;
type <strong>Node</strong> struct {
        Value Item
        Left  *Node
        Right *Node
}
&nbsp;
type <strong>BinaryTree</strong> struct {
        Root *Node
}
&nbsp;
func (bt *BinaryTree) <strong>Insert</strong>(value Item) {
        node := &amp;Node{value, nil, nil}
        if bt.Root == nil {
                bt.Root = node
        } else {
                insertNode(bt.Root, node)
        }
}
&nbsp;
func <strong>insertNode</strong>(node, newNode *Node) {
        if newNode.Value &lt; node.Value {
                if node.Left == nil {
                        node.Left = newNode
                } else {
                        insertNode(node.Left, newNode)
                }
        } else {
                if node.Right == nil {
                        node.Right = newNode
                } else {
                        insertNode(node.Right, newNode)
                }
        }
}
&nbsp;
func <strong>printTree</strong>(node *Node, level int) {
        if node != nil {
                format := ""
                for i := 0; i &lt; level; i++ {
                        format += "       "
                }
                format += "---[ "
                level++
                printTree(node.Left, level)
                fmt.Printf(format+"%d\n", node.Value)
                printTree(node.Right, level)
        }
}
&nbsp;
func <strong>encodeBinaryTree</strong>(bt BinaryTree) (bytes.Buffer, error) {
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
&nbsp;
        err := encoder.Encode(bt)
        if err != nil {
                return buffer, err
        } else {
                return buffer, nil
        }
}
&nbsp;
func <strong>decodeBinaryTree</strong>(encodedTree bytes.Buffer) (BinaryTree, error) {
        var newTree BinaryTree
        decoder := gob.NewDecoder(&amp;encodedTree)
        err := decoder.Decode(&amp;newTree)
        return newTree, err
}
&nbsp;
func <strong>saveBinaryTree</strong>(encodedTree bytes.Buffer, filename string) {
        err := ioutil.WriteFile(filename, encodedTree.Bytes(), 0644)
        if err != nil {
                fmt.Println(err)
        } else {
                fmt.Println("Stored into file\n")
        }
}
&nbsp;
func <strong>main</strong>() {
        var bt BinaryTree
        bt.Insert(5)
        bt.Insert(3)
        bt.Insert(7)
        bt.Insert(1)
        bt.Insert(4)
        bt.Insert(6)
        bt.Insert(8)
        bt.Insert(9)
        bt.Insert(10)
        bt.Insert(0)
&nbsp;
        printTree(bt.Root, 0)
&nbsp;
        encodedTree, err := encodeBinaryTree(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
&nbsp;
        fmt.Println("\nBuffer with encoded tree: ", encodedTree.Len(), "\n")
&nbsp;
        saveBinaryTree(encodedTree, "tree2.gob")
&nbsp;
        decodedTree, err := decodeBinaryTree(encodedTree)
        if err != nil {
                fmt.Println(err)
                return
        } else {
                printTree(decodedTree.Root, 0)
        }
}
</pre>

<p>Výsledek po spuštění naznačuje, že jsme vše provedli korektně:</p>

<pre>
                     ---[ 0
              ---[ 1
       ---[ 3
              ---[ 4
---[ 5
              ---[ 6
       ---[ 7
              ---[ 8
                     ---[ 9
                            ---[ 10
&nbsp;
Buffer with encoded tree:  127 
&nbsp;
Stored into file
&nbsp;
                     ---[ 0
              ---[ 1
       ---[ 3
              ---[ 4
---[ 5
              ---[ 6
       ---[ 7
              ---[ 8
                     ---[ 9
                            ---[ 10
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Serializace a deserializace binárního stromu s&nbsp;využitím formátu <i>JSON</i></h2>

<p>Na binární strom (popř.&nbsp;i na lineárně vázaný seznam) se můžeme dívat i
jinak, než na klasický orientovaný graf. Uzel stromu může obsahovat dva přímo
navázané synovské uzly (poduzly), což mj.&nbsp;znamená, že jak strom, tak i
seznam je s&nbsp;určitými problémy reprezentovatelný i ve formátu JSON a XML.
Tyto formáty sice neumožňují používat ukazatele (v&nbsp;XML teoreticky ano, ale
komplikovaně), ovšem na druhou stranu dokážou strom uložit jako jediný kořenový
uzel, který obsahuje dva poduzly, jež mohou rekurzivně obsahovat další dva
poduzly atd. Serializace stromu do JSONu je tedy možná, na rozdíl od jiných
typů grafů (s&nbsp;kružnicí, s&nbsp;více cestami mezi uzly atd.). Můžeme se o
tom snadno přesvědčit:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/json"
        "fmt"
        "io/ioutil"
)
&nbsp;
type <strong>Item</strong> int
&nbsp;
type <strong>Node</strong> struct {
        Value Item
        Left  *Node
        Right *Node
}
&nbsp;
type <strong>BinaryTree</strong> struct {
        Root *Node
}
&nbsp;
func (bt *BinaryTree) <strong>Insert</strong>(value Item) {
        node := &amp;Node{value, nil, nil}
        if bt.Root == nil {
                bt.Root = node
        } else {
                insertNode(bt.Root, node)
        }
}
&nbsp;
func <strong>insertNode</strong>(node, newNode *Node) {
        if newNode.Value &lt; node.Value {
                if node.Left == nil {
                        node.Left = newNode
                } else {
                        insertNode(node.Left, newNode)
                }
        } else {
                if node.Right == nil {
                        node.Right = newNode
                } else {
                        insertNode(node.Right, newNode)
                }
        }
}
&nbsp;
func <strong>printTree</strong>(node *Node, level int) {
        if node != nil {
                format := ""
                for i := 0; i &lt; level; i++ {
                        format += "       "
                }
                format += "---[ "
                level++
                printTree(node.Left, level)
                fmt.Printf(format+"%d\n", node.Value)
                printTree(node.Right, level)
        }
}
&nbsp;
func <strong>encodeBinaryTree</strong>(bt BinaryTree) ([]byte, error) {
        jsonOutput, err := json.Marshal(bt)

        if err != nil {
                return jsonOutput, err
        } else {
                return jsonOutput, nil
        }
}
&nbsp;
func <strong>decodeBinaryTree</strong>(encodedTree []byte) (BinaryTree, error) {
        var newTree BinaryTree
        err := json.Unmarshal(encodedTree, &amp;newTree)
        return newTree, err
}
&nbsp;
func <strong>saveBinaryTree</strong>(encodedTree []byte, filename string) {
        err := ioutil.WriteFile(filename, encodedTree, 0644)
        if err != nil {
                fmt.Println(err)
        } else {
                fmt.Println("Stored into file\n")
        }
}
&nbsp;
func <strong>main</strong>() {
        var bt BinaryTree
        bt.Insert(5)
        bt.Insert(3)
        bt.Insert(7)
        bt.Insert(1)
        bt.Insert(4)
        bt.Insert(6)
        bt.Insert(8)
        bt.Insert(9)
        bt.Insert(10)
        bt.Insert(0)
&nbsp;
        printTree(bt.Root, 0)
&nbsp;
        encodedTree, err := encodeBinaryTree(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
&nbsp;
        fmt.Println("\nBuffer with encoded tree: ", len(encodedTree), "\n")
&nbsp;
        saveBinaryTree(encodedTree, "tree.json")
&nbsp;
        decodedTree, err := decodeBinaryTree(encodedTree)
        if err != nil {
                fmt.Println(err)
                return
        } else {
                printTree(decodedTree.Root, 0)
        }
}
</pre>

<p>Test funkčnosti předchozího příkladu:</p>

<pre>
                     ---[ 0
              ---[ 1
       ---[ 3
              ---[ 4
---[ 5
              ---[ 6
       ---[ 7
              ---[ 8
                     ---[ 9
                            ---[ 10
&nbsp;
Buffer with encoded tree:  334 
&nbsp;
Stored into file
&nbsp;
                     ---[ 0
              ---[ 1
       ---[ 3
              ---[ 4
---[ 5
              ---[ 6
       ---[ 7
              ---[ 8
                     ---[ 9
                            ---[ 10
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Serializace a deserializace binárního stromu s&nbsp;využitím formátu <i>BSON</i></h2>

<p>Prakticky naprosto stejným způsobem můžeme provést serializaci a
deserializaci binárního stromu do binárního formátu BSON, s&nbsp;nímž jsme se
seznámili v&nbsp;předchozí části tohoto seriálu. Podobnost dále uvedeného
příkladu s&nbsp;příkladem z&nbsp;deváté kapitoly není náhodná &ndash; rozhraní
knihoven <strong>encoding/json</strong> a <strong>gopkg.in/mgo.v2/bson</strong>
je z&nbsp;pohledu vývojáře takřka totožné:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "gopkg.in/mgo.v2/bson"
        "io/ioutil"
)
&nbsp;
type <strong>Item</strong> int
&nbsp;
type <strong>Node</strong> struct {
        Value Item
        Left  *Node
        Right *Node
}
&nbsp;
type <strong>BinaryTree</strong> struct {
        Root *Node
}
&nbsp;
func (bt *BinaryTree) <strong>Insert</strong>(value Item) {
        node := &amp;Node{value, nil, nil}
        if bt.Root == nil {
                bt.Root = node
        } else {
                insertNode(bt.Root, node)
        }
}
&nbsp;
func <strong>insertNode</strong>(node, newNode *Node) {
        if newNode.Value &lt; node.Value {
                if node.Left == nil {
                        node.Left = newNode
                } else {
                        insertNode(node.Left, newNode)
                }
        } else {
                if node.Right == nil {
                        node.Right = newNode
                } else {
                        insertNode(node.Right, newNode)
                }
        }
}
&nbsp;
func <strong>printTree</strong>(node *Node, level int) {
        if node != nil {
                format := ""
                for i := 0; i &lt; level; i++ {
                        format += "       "
                }
                format += "---[ "
                level++
                printTree(node.Left, level)
                fmt.Printf(format+"%d\n", node.Value)
                printTree(node.Right, level)
        }
}
&nbsp;
func <strong>encodeBinaryTree</strong>(bt BinaryTree) ([]byte, error) {
        bsonOutput, err := bson.Marshal(bt)

        if err != nil {
                return bsonOutput, err
        } else {
                return bsonOutput, nil
        }
}
&nbsp;
func <strong>decodeBinaryTree</strong>(encodedTree []byte) (BinaryTree, error) {
        var newTree BinaryTree
        err := bson.Unmarshal(encodedTree, &amp;newTree)
        return newTree, err
}
&nbsp;
func <strong>saveBinaryTree</strong>(encodedTree []byte, filename string) {
        err := ioutil.WriteFile(filename, encodedTree, 0644)
        if err != nil {
                fmt.Println(err)
        } else {
                fmt.Println("Stored into file\n")
        }
}
&nbsp;
func <strong>main</strong>() {
        var bt BinaryTree
        bt.Insert(5)
        bt.Insert(3)
        bt.Insert(7)
        bt.Insert(1)
        bt.Insert(4)
        bt.Insert(6)
        bt.Insert(8)
        bt.Insert(9)
        bt.Insert(10)
        bt.Insert(0)
&nbsp;
        printTree(bt.Root, 0)
&nbsp;
        encodedTree, err := encodeBinaryTree(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
&nbsp;
        fmt.Println("\nBuffer with encoded tree: ", len(encodedTree), "\n")
&nbsp;
        saveBinaryTree(encodedTree, "tree.bson")
&nbsp;
        decodedTree, err := decodeBinaryTree(encodedTree)
        if err != nil {
                fmt.Println(err)
                return
        } else {
                printTree(decodedTree.Root, 0)
        }
}
</pre>

<p>Výsledek běhu tohoto příkladu:</p>

<pre>
                     ---[ 0
              ---[ 1
       ---[ 3
              ---[ 4
---[ 5
              ---[ 6
       ---[ 7
              ---[ 8
                     ---[ 9
                            ---[ 10
&nbsp;
Buffer with encoded tree:  301 
&nbsp;
Stored into file
&nbsp;
                     ---[ 0
              ---[ 1
       ---[ 3
              ---[ 4
---[ 5
              ---[ 6
       ---[ 7
              ---[ 8
                     ---[ 9
                            ---[ 10
</pre>

<p>Pro zajímavost si vyzkoušejme soubor vytvořený předchozím příkladem načíst
do skriptu naprogramovaného v&nbsp;Pythonu s&nbsp;použitím knihovny <a
href="https://pypi.org/project/bson/">BSON</a>, jejíž zdrojové kódy lze nalézt
na adrese <a
href="https://github.com/py-bson/bson">https://github.com/py-bson/bson</a>.
Nejprve knihovnu BSON nainstalujeme pomocí nástroje <strong>pip</strong>:</p>

<pre>
$ <strong>pip3 install --user bson</strong>
&nbsp;
Downloading/unpacking bson
  Downloading bson-0.5.9.tar.gz
  Running setup.py (path:/tmp/ramdisk/pip_build_tester/bson/setup.py) egg_info for package bson
&nbsp;   
Downloading/unpacking python-dateutil&gt;=2.4.0 (from bson)
  Downloading python_dateutil-2.8.1-py2.py3-none-any.whl (227kB): 227kB downloaded
Requirement already satisfied (use --upgrade to upgrade): six&gt;=1.9.0 in ./.local/lib/python3.4/site-packages (from bson)
Installing collected packages: bson, python-dateutil
  Running setup.py install for bson
&nbsp;
Successfully installed bson python-dateutil
Cleaning up...
</pre>

<p>První skript pro načtení serializovaného stromu používá pro zobrazení metodu
<strong>PrettyPrinter.pprint</strong>:</p>

<pre>
import pprint
import bson
&nbsp;
with open("tree.bson", "rb") as fin:
    content = fin.read()
    binary_tree = bson.loads(content)
    pp = pprint.PrettyPrinter(indent=4)
    pp.pprint(binary_tree)
</pre>

<p>Výsledek je ovšem poněkud nečitelný:</p>

<pre>
{   'root': {   'left': {   'left': {   'left': {   'left': None,
                                                    'right': None,
                                                    'value': 0},
                                        'right': None,
                                        'value': 1},
                            'right': {   'left': None,
                                         'right': None,
                                         'value': 4},
                            'value': 3},
                'right': {   'left': {   'left': None,
                                         'right': None,
                                         'value': 6},
                             'right': {   'left': None,
                                          'right': {   'left': None,
                                                       'right': {   'left': None,
                                                                    'right': None,
                                                                    'value': 10},
                                                       'value': 9},
                                          'value': 8},
                             'value': 7},
                'value': 5}}
</pre>

<p>Z&nbsp;tohoto důvodu funkci <strong>printTree</strong>, kterou jsme již
implementovali v&nbsp;jazyce Go, přepíšeme do Pythonu a použijeme ji pro
vypsání obsahu deserializovaného stromu:</p>

<pre>
import bson
&nbsp;
def printTree(node, level):
    if node is not None:
        format = level * "       "
        format += "---[ "
        level += 1
        printTree(node["left"], level)
        print(format+str(node["value"]))
        printTree(node["right"], level)
    pass
&nbsp;
with open("tree.bson", "rb") as fin:
    content = fin.read()
    binary_tree = bson.loads(content)
    printTree(binary_tree["root"], 0)
</pre>

<p>Z&nbsp;výsledku je patrné, že deserializovaný strom má v&nbsp;Pythonu
stejnou strukturu, jako v&nbsp;jazyce Go (samozřejmě až na zcela odlišný typový
systém obou jazyků):</p>

<pre>
                     ---[ 0
              ---[ 1
       ---[ 3
              ---[ 4
---[ 5
              ---[ 6
       ---[ 7
              ---[ 8
                     ---[ 9
                            ---[ 10
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Porovnání velikosti výsledných souborů se serializovanými daty</h2>

<p>K&nbsp;binárním přenosovým formátům se většinou uchylujeme v&nbsp;těchto
případech:</p>

<ol>
<li>Je nutné zajistit větší rychlost serializace a/nebo deserializace</li>
<li>Z&nbsp;různých důvodů potřebujeme, aby serializovaná data byla uložena
úsporněji, než v&nbsp;čistě textových formátech.</li>
</ol>

<p>V&nbsp;následujících kapitolách si ukážeme trojici příkladů, na nichž
zjistíme, do jaké míry zajišťují binární formáty menší objem serializovaných (a
tím pádem i přenášených) dat. Zaměříme se na:</p>

<ul>
<li><a href="#k12">Serializaci vektoru obsahujícího hodnoty s&nbsp;plovoucí řádovou čárkou (konkrétně typ <i>float64</i>)</a></li>
<li><a href="#k13">Serializaci struktury s&nbsp;jediným delším řetězcem</a></li>
<li><a href="#k14">Serializaci binárního stromu, nyní s&nbsp;více uzly (255) a tudíž i větší hloubkou</a></li>
</ul>

<p>Použity budou textové formáty XML a JSON i binární formáty BSON a gob. Navíc
všechny soubory následně zkomprimujeme a porovnáme i komprimované
velikosti.</p>

<p>Výsledky budou shrnuty <a href="#k15">v&nbsp;patnácté kapitole</a>.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vektor obsahující hodnoty s&nbsp;plovoucí řádovou čárkou</h2>

<p>V&nbsp;prvním příkladu vytvoříme vektor s&nbsp;jedním tisícem položek typu
<i>float64</i>, které budou následně serializovány do všech podporovaných
formátů:</p>

<pre>
var array [1000]float64
</pre>

<p>Úplný zdrojový kód tohoto příkladu vypadá následovně (výsledky budou ukázány
<a href="#k15">v&nbsp;patnácté kapitole</a>):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "encoding/gob"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "gopkg.in/mgo.v2/bson"
        "io/ioutil"
)
&nbsp;
type <strong>Vector</strong> []float64
&nbsp;
func <strong>encodeVectorIntoBSON</strong>(vector Vector) ([]byte, error) {
        bsonOutput, err := bson.Marshal(vector)
&nbsp;
        if err != nil {
                return bsonOutput, err
        } else {
                return bsonOutput, nil
        }
}
&nbsp;
func <strong>encodeVectorIntoJSON</strong>(vector Vector) ([]byte, error) {
        jsonOutput, err := json.Marshal(vector)
&nbsp;
        if err != nil {
                return jsonOutput, err
        } else {
                return jsonOutput, nil
        }
}
&nbsp;
func <strong>encodeVectorIntoIndentedJSON</strong>(vector Vector) ([]byte, error) {
        jsonOutput, err := json.MarshalIndent(vector, "", "    ")
&nbsp;
        if err != nil {
                return jsonOutput, err
        } else {
                return jsonOutput, nil
        }
}
&nbsp;
func <strong>encodeVectorIntoXML</strong>(vector Vector) ([]byte, error) {
        xmlOutput, err := xml.Marshal(vector)
&nbsp;
        if err != nil {
                return xmlOutput, err
        } else {
                return xmlOutput, nil
        }
}
&nbsp;
func <strong>encodeVectorIntoIndentedXML</strong>(vector Vector) ([]byte, error) {
        xmlOutput, err := xml.MarshalIndent(vector, "", "    ")
&nbsp;
        if err != nil {
                return xmlOutput, err
        } else {
                return xmlOutput, nil
        }
}
&nbsp;
func <strong>encodeVectorIntoGob</strong>(vector Vector) ([]byte, error) {
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
&nbsp;
        err := encoder.Encode(vector)
        if err != nil {
                return buffer.Bytes(), err
        } else {
                return buffer.Bytes(), nil
        }
}
&nbsp;
func <strong>saveVector</strong>(encodedVector []byte, filename string) {
        err := ioutil.WriteFile(filename, encodedVector, 0644)
        if err != nil {
                fmt.Println(err)
        } else {
                fmt.Println("Stored into file", filename)
        }
}
&nbsp;
func <strong>printBufferInfo</strong>(buffer []byte) {
        fmt.Println("\nBuffer with encoded vector: ", len(buffer))
}
&nbsp;
func <strong>main</strong>() {
        var array [1000]float64
&nbsp;
        for i := 0; i &lt; len(array); i++ {
                if i == 0 {
                        array[i] = 1.0
                } else {
                        array[i] = 1.0 / float64(i)
                }
        }
&nbsp;
        var vector Vector = array[:]
&nbsp;
        encodedVector, err := encodeVectorIntoXML(vector)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedVector)
        saveVector(encodedVector, "vector1.xml")
&nbsp;
        encodedVector, err = encodeVectorIntoIndentedXML(vector)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedVector)
        saveVector(encodedVector, "vector2.xml")
&nbsp;
        encodedVector, err = encodeVectorIntoJSON(vector)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedVector)
        saveVector(encodedVector, "vector1.json")
&nbsp;
        encodedVector, err = encodeVectorIntoIndentedJSON(vector)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedVector)
        saveVector(encodedVector, "vector2.json")
&nbsp;
        encodedVector, err = encodeVectorIntoBSON(vector)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedVector)
        saveVector(encodedVector, "vector1.bson")
&nbsp;
        encodedVector, err = encodeVectorIntoGob(vector)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedVector)
        saveVector(encodedVector, "vector1.gob")
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Serializovaná struktura obsahující jediný atribut &ndash; dlouhý řetězec</h2>

<p>Ve druhém příkladu bude serializována jednoduchá struktura obsahující jediný
atribut, kterým je řetězec:</p>

<pre>
type <strong>Item</strong> struct {
        Value string
}
</pre>

<p><div class="rs-tip-major">Poznámka: musíme použít datovou strukturu, protože
formát BSON nedokáže serializovat jediný (samotný) řetězec.</div></p>

<p>Testovací řetězec byl vytvořen <a
href="http://www.kyblsoft.cz/projevy">známým generátorem náhodných
proslovů</a>:</p>

&bdquo;Další rozvoj různých forem činnosti vyzaduje rozšiřování logistických
prostředků a nových návrhů. Pestré a bohaté zkušenosti jasně říkají, že
konzultace se širokým aktivem dostatečně oddaluje propad odpovídajících
podmínek aktivizace. Ideové úvahy nejvyššího řádu a rovněž stabilní a
kvantitativní vzrůst a sféra naší aktivity ve značné míře podmiňuje vytvoření
systému výchovy pracovníků odpovídajících aktuálním potřebám. Nesmíme však
zapomínat, že navržená struktura organizace zvyšuje potřebu aplikace
existujících finančních a administrativních podmínek. Poslání organizace,
zejména pak stálé, informačně-propagandistické zabezpečení naší práce pomáhá
udržovat kumulativní progresi pozic jednotlivých účastníků k zadaným úkolům.
Tímto způsobem realizace plánovaných vytyčených úkolů vyvolává proces zavádění
a modernizace systému masové účasti. Naše dlouhodobé ambice, stejně jako nový
model organizační činnosti přetváří strukturu vedení směru progresivního
rozvoje&ldquo;

<p>Opět si pro jistotu ukažme úplný zdrojový kód tohoto demonstračního
příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "encoding/gob"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "gopkg.in/mgo.v2/bson"
        "io/ioutil"
)
&nbsp;
type <strong>Item</strong> struct {
        Value string
}
&nbsp;
func <strong>encodeStringIntoBSON</strong>(item Item) ([]byte, error) {
        bsonOutput, err := bson.Marshal(item)
&nbsp;
        if err != nil {
                return bsonOutput, err
        } else {
                return bsonOutput, nil
        }
}
&nbsp;
func <strong>encodeStringIntoJSON</strong>(item Item) ([]byte, error) {
        jsonOutput, err := json.Marshal(item)
&nbsp;
        if err != nil {
                return jsonOutput, err
        } else {
                return jsonOutput, nil
        }
}
&nbsp;
func <strong>encodeStringIntoIndentedJSON</strong>(item Item) ([]byte, error) {
        jsonOutput, err := json.MarshalIndent(item, "", "    ")
&nbsp;
        if err != nil {
                return jsonOutput, err
        } else {
                return jsonOutput, nil
        }
}
&nbsp;
func <strong>encodeStringIntoXML</strong>(item Item) ([]byte, error) {
        xmlOutput, err := xml.Marshal(item)
&nbsp;
        if err != nil {
                return xmlOutput, err
        } else {
                return xmlOutput, nil
        }
}
&nbsp;
func <strong>encodeStringIntoIndentedXML</strong>(item Item) ([]byte, error) {
        xmlOutput, err := xml.MarshalIndent(item, "", "    ")
&nbsp;
        if err != nil {
                return xmlOutput, err
        } else {
                return xmlOutput, nil
        }
}
&nbsp;
func <strong>encodeStringIntoGob</strong>(item Item) ([]byte, error) {
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
&nbsp;
        err := encoder.Encode(item)
        if err != nil {
                return buffer.Bytes(), err
        } else {
                return buffer.Bytes(), nil
        }
}
&nbsp;
func <strong>saveString</strong>(encodedString []byte, filename string) {
        err := ioutil.WriteFile(filename, encodedString, 0644)
        if err != nil {
                fmt.Println(err)
        } else {
                fmt.Println("Stored into file", filename)
        }
}
&nbsp;
func <strong>printBufferInfo</strong>(buffer []byte) {
        fmt.Println("\nBuffer with encoded string: ", len(buffer))
}
&nbsp;
func <strong>main</strong>() {
        var item Item
        item.Value = `Další rozvoj různých forem činnosti vyžaduje rozšiřování logistických prostředků a nových návrhů. Pestré a bohaté zkušenosti jasně říkají, že konzultace se širokým aktivem dostatečně oddaluje propad odpovídajících podmínek aktivizace. Ideové úvahy nejvyššího řádu a rovněž stabilní a kvantitativní vzrůst a sféra naší aktivity ve značné míře podmiňuje vytvoření systému výchovy pracovníků odpovídajících aktuálním potřebám. Nesmíme však zapomínat, že navržená struktura organizace zvyšuje potřebu aplikace existujících finančních a administrativních podmínek. Poslání organizace, zejména pak stálé, informačně-propagandistické zabezpečení naší práce pomáhá udržovat kumulativní progresi pozic jednotlivých účastníků k zadaným úkolům. Tímto způsobem realizace plánovaných vytyčených úkolů vyvolává proces zavádění a modernizace systému masové účasti. Naše dlouhodobé ambice, stejně jako nový model organizační činnosti přetváří strukturu vedení směru progresivního rozvoje.`
&nbsp;
        encodedString, err := encodeStringIntoXML(item)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedString)
        saveString(encodedString, "string1.xml")
&nbsp;
        encodedString, err = encodeStringIntoIndentedXML(item)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedString)
        saveString(encodedString, "string2.xml")
&nbsp;
        encodedString, err = encodeStringIntoJSON(item)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedString)
        saveString(encodedString, "string1.json")
&nbsp;
        encodedString, err = encodeStringIntoIndentedJSON(item)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedString)
        saveString(encodedString, "string2.json")
&nbsp;
        encodedString, err = encodeStringIntoBSON(item)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedString)
        saveString(encodedString, "string1.bson")
&nbsp;
        encodedString, err = encodeStringIntoGob(item)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedString)
        saveString(encodedString, "string1.gob")
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Serializovaný strom s&nbsp;255 uzly</h2>

<p>Poslední benchmark je založen na serializaci binárního stromu s&nbsp;255
uzly. Samotnou konstrukci tohoto stromu (tak, aby byl vyvážený) zajišťuje tato
rekurzivní funkce:</p>

<pre>
func <strong>constructTree</strong>(bt *BinaryTree, min int, max int) {
        middle := (min + max) / 2
        if min &lt; middle &amp;&amp; middle &lt; max {
                fmt.Println(middle)
                bt.Insert(Item(middle))
                constructTree(bt, min, middle)
                constructTree(bt, middle, max)
        }
}
</pre>

<p>Opět si pochopitelně ukážeme celý zdrojový kód příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "encoding/gob"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "gopkg.in/mgo.v2/bson"
        "io/ioutil"
)
&nbsp;
type <strong>Item</strong> int
&nbsp;
type <strong>Node</strong> struct {
        Value Item
        Left  *Node
        Right *Node
}
&nbsp;
type <strong>BinaryTree</strong> struct {
        Root *Node
}
&nbsp;
func (bt *BinaryTree) <strong>Insert</strong>(value Item) {
        node := &amp;Node{value, nil, nil}
        if bt.Root == nil {
                bt.Root = node
        } else {
                insertNode(bt.Root, node)
        }
}
&nbsp;
func <strong>insertNode</strong>(node, newNode *Node) {
        if newNode.Value &lt; node.Value {
                if node.Left == nil {
                        node.Left = newNode
                } else {
                        insertNode(node.Left, newNode)
                }
        } else {
                if node.Right == nil {
                        node.Right = newNode
                } else {
                        insertNode(node.Right, newNode)
                }
        }
}
&nbsp;
func <strong>printTree</strong>(node *Node, level int) {
        if node != nil {
                format := ""
                for i := 0; i &lt; level; i++ {
                        format += "       "
                }
                format += "---[ "
                level++
                printTree(node.Left, level)
                fmt.Printf(format+"%d\n", node.Value)
                printTree(node.Right, level)
        }
}
&nbsp;
func <strong>encodeBinaryTreeIntoBSON</strong>(bt BinaryTree) ([]byte, error) {
        bsonOutput, err := bson.Marshal(bt)
&nbsp;
        if err != nil {
                return bsonOutput, err
        } else {
                return bsonOutput, nil
        }
}
&nbsp;
func <strong>encodeBinaryTreeIntoJSON</strong>(bt BinaryTree) ([]byte, error) {
        jsonOutput, err := json.Marshal(bt)
&nbsp;
        if err != nil {
                return jsonOutput, err
        } else {
                return jsonOutput, nil
        }
}
&nbsp;
func <strong>encodeBinaryTreeIntoIndentedJSON</strong>(bt BinaryTree) ([]byte, error) {
        jsonOutput, err := json.MarshalIndent(bt, "", "    ")
&nbsp;
        if err != nil {
                return jsonOutput, err
        } else {
                return jsonOutput, nil
        }
}
&nbsp;
func <strong>encodeBinaryTreeIntoXML</strong>(bt BinaryTree) ([]byte, error) {
        xmlOutput, err := xml.Marshal(bt)
&nbsp;
        if err != nil {
                return xmlOutput, err
        } else {
                return xmlOutput, nil
        }
}
&nbsp;
func <strong>encodeBinaryTreeIntoIndentedXML</strong>(bt BinaryTree) ([]byte, error) {
        xmlOutput, err := xml.MarshalIndent(bt, "", "    ")
&nbsp;
        if err != nil {
                return xmlOutput, err
        } else {
                return xmlOutput, nil
        }
}
&nbsp;
func <strong>encodeBinaryTreeIntoGob</strong>(bt BinaryTree) ([]byte, error) {
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
&nbsp;
        err := encoder.Encode(bt)
        if err != nil {
                return buffer.Bytes(), err
        } else {
                return buffer.Bytes(), nil
        }
}
&nbsp;
func <strong>saveBinaryTree</strong>(encodedTree []byte, filename string) {
        err := ioutil.WriteFile(filename, encodedTree, 0644)
        if err != nil {
                fmt.Println(err)
        } else {
                fmt.Println("Stored into file", filename)
        }
}
&nbsp;
func <strong>constructTree</strong>(bt *BinaryTree, min int, max int) {
        middle := (min + max) / 2
        if min &lt; middle &amp;&amp; middle &lt; max {
                fmt.Println(middle)
                bt.Insert(Item(middle))
                constructTree(bt, min, middle)
                constructTree(bt, middle, max)
        }
}
&nbsp;
func <strong>printBufferInfo</strong>(buffer []byte) {
        fmt.Println("\nBuffer with encoded tree: ", len(buffer))
}
&nbsp;
func <strong>main</strong>() {
        var bt BinaryTree
        constructTree(&amp;bt, 0, 256)
&nbsp;
        printTree(bt.Root, 0)
&nbsp;
        encodedTree, err := encodeBinaryTreeIntoXML(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "tree1.xml")
&nbsp;
        encodedTree, err = encodeBinaryTreeIntoIndentedXML(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "tree2.xml")
&nbsp;
        encodedTree, err = encodeBinaryTreeIntoJSON(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "tree1.json")
&nbsp;
        encodedTree, err = encodeBinaryTreeIntoIndentedJSON(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "tree2.json")
&nbsp;
        encodedTree, err = encodeBinaryTreeIntoBSON(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "tree1.bson")
&nbsp;
        encodedTree, err = encodeBinaryTreeIntoGob(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "tree1.gob")
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Výsledek porovnání, vliv komprimace dat</h2>

<p>Nyní se tedy podívejme na slibované výsledky:</p>

<table>
<tr><th>Data/formát</th><th>JSON</th><th>JSON indent.</th><th>BSON</th><th>XML</th><th>XML indent</th><th>gob</th></tr>
<tr><td>[]float64  </td><td>21017</td><td>26018</td><td>12895</td><td>39016</td><td>40015</td><td>8960</td></tr>
<tr><td>string     </td><td>1118</td><td>1125</td><td>1123</td><td>1134</td><td>1140</td><td>1145</td></tr>
<tr><td>binary tree</td><td>8575</td><td>42115</td><td>7406</td><td>8076</td><td>31378</td><td>1431</td></tr>
</table>

<p>Vidíme, že formát gob je většinou nejúspornější, a to přesto, že nese plné
informace o vlastnostech původní datové struktury (což se projevilo
v&nbsp;případě řetězce). Přednosti formátu BSON se nejvíce projevily u
jednoduché, ale rozsáhlé struktury, tj.&nbsp;u prvního vektoru hodnot typu
<i>float64</i>.</p>

<p>A jaký vliv bude mít následná komprimace dat? Použijeme bzip2:</p>

<table>
<tr><th>Data/formát</th><th>JSON</th><th>JSON indent.</th><th>BSON</th><th>XML</th><th>XML indent</th><th>gob</th></tr>
<tr><td>[]float64  </td><td>7161</td><td>7175</td><td>7246</td><td>7226</td><td>7227</td><td>6223</td></tr>
<tr><td>string     </td><td>681</td><td>683</td><td>670</td><td>675</td><td>693</td><td>702</td></tr>
<tr><td>binary tree</td><td>587</td><td>684</td><td>906</td><td>551</td><td>721</td><td>653</td></tr>
</table>

<p>Zde podle očekávání komprimace nejvíce pomohla textovým formátům, které se
prakticky zcela přiblížily formátům binárním (taktéž po komprimaci) a někdy se
dokonce dosáhlo ještě menšího objemu dat.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Problematika serializace grafových struktur</h2>

<p>Ještě se krátce zmiňme o problematice serializace grafových struktur.
Nejprve se uvedeme příklad grafu, v&nbsp;němž každý uzel může ukazovat na další
dva uzly (jedním z&nbsp;příkladů takto navrženého grafu je binární strom):</p>

<pre>
type <strong>Item</strong> int
&nbsp;
type <strong>Node</strong> struct {
        Value Item
        Left  *Node
        Right *Node
}
</pre>

<p>Dále vytvoříme trojici uzlů, které jsou spojeny hranami tak, že mezi uzlem A
a C existují dvě cesty &ndash; jedna přímá, druhá přes uzel B:</p>

<pre>
var a, b, c Node
&nbsp;
a.Value = 1
b.Value = 2
c.Value = 3
a.Left = &amp;b
a.Right = &amp;c
b.Left = nil
b.Right = &amp;c
c.Left = nil
c.Right = nil
</pre>

<p>Tyto původně <strong>tři</strong> jsou serializovány následujícím způsobem:</p>

<pre>
{
    "Value": 1,
    "Left": {
        "Value": 2,
        "Left": null,
        "Right": {
            "Value": 3,
            "Left": null,
            "Right": null
        }
    },
    "Right": {
        "Value": 3,
        "Left": null,
        "Right": null
    }
}
</pre>

<p>a:</p>

<pre>
&lt;Node&gt;
    &lt;Value&gt;1&lt;/Value&gt;
    &lt;Left&gt;
        &lt;Value&gt;2&lt;/Value&gt;
        &lt;Right&gt;
            &lt;Value&gt;3&lt;/Value&gt;
        &lt;/Right&gt;
    &lt;/Left&gt;
    &lt;Right&gt;
        &lt;Value&gt;3&lt;/Value&gt;
    &lt;/Right&gt;
&lt;/Node&gt;
</pre>

<p>Vidíme tedy, že se uzel číslo 3 (C) uložil dvakrát! Rekonstrukce původního
grafu tedy nebude jednoduchá a formáty JSON, BSON či XML nám to (přímo)
neumožní.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Graf po deserialiaci</h2>

<p>Mohlo by se zdát, že výše zmíněnou grafovou strukturu bude možné korektně
uložit na následně obnovit s&nbsp;využitím formátu <i>gob</i>, který dokáže
pracovat s&nbsp;ukazateli. Pojďme si tedy tuto domněnku ověřit následujícím
demonstračním příkladem:</p>

<pre>
package main
&nbsp;
import (
        "bytes"
        "encoding/gob"
        "fmt"
)
&nbsp;
type Item int
&nbsp;
type Node struct {
        Value Item
        Left  *Node
        Right *Node
}
&nbsp;
func <strong>main</strong>() {
        var a, b, c Node
&nbsp;
        a.Value = 1
        b.Value = 2
        c.Value = 3
        a.Left = &amp;b
        a.Right = &amp;c
        b.Left = nil
        b.Right = &amp;c
        c.Left = nil
        c.Right = nil
&nbsp;
        var x Node
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
        err := encoder.Encode(&amp;a)
        decoder := gob.NewDecoder(&amp;buffer)
        err = decoder.Decode(&amp;x)
        if err != nil {
                fmt.Println(err)
                return
        }
        fmt.Printf("Node:        %p %v\n", &amp;x, x)
        fmt.Printf("Left:        %p %v\n", x.Left, *x.Left)
        fmt.Printf("Right:       %p %v\n", x.Right, *x.Right)
        fmt.Printf("Left/Right:  %p %v\n", x.Left.Right, *x.Left.Right)
}
</pre>

<p>Po spuštění příkladu však získáme informaci o čtyřech uzlech na adresách
končících a8a0, ae80, aec0 a aea0, i když by měly existovat jen tři uzly:</p>

<pre>
Node:        0xc00000a8a0 {1 0xc00000ae80 0xc00000aec0}
Left:        0xc00000ae80 {2 &lt;nil&gt; 0xc00000aea0}
Right:       0xc00000aec0 {3 &lt;nil&gt; &lt;nil&gt;}
Left/Right:  0xc00000aea0 {3 &lt;nil&gt; &lt;nil&gt;}
</pre>

<p><div class="rs-tip-major">Poznámka: i zde tedy došlo k&nbsp;duplikaci uzlu
číslo 3 (C).</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Cyklus v&nbsp;datových strukturách (grafu atd.)</h2>

<p>Zdaleka největší problém však nastane ve chvíli, kdy uzel obsahuje cyklu (kružnici):</p>

<pre>
type <strong>Item</strong> int
&nbsp;
type <strong>Node</strong> struct {
        Value Item
        Next  *Node
}
&nbsp;
var a, b Node
&nbsp;
a.Value = 1
b.Value = 2
a.Next = &amp;b
b.Next = &amp;a
</pre>

<p>Tento fakt není detekován (v&nbsp;žádném serializačním formátu!) a proto
následující demonstrační příklad skončí po delší době chybou &ndash; tato doba
bude tím delší, čím více paměti je k&nbsp;dispozici:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "encoding/gob"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "gopkg.in/mgo.v2/bson"
        "io/ioutil"
)
&nbsp;
type <strong>Item</strong> int
&nbsp;
type <strong>Node</strong> struct {
        Value Item
        Next  *Node
}
&nbsp;
func <strong>encodeStructureIntoBSON</strong>(s Node) ([]byte, error) {
        bsonOutput, err := bson.Marshal(s)
&nbsp;
        if err != nil {
                return bsonOutput, err
        } else {
                return bsonOutput, nil
        }
}
&nbsp;
func <strong>encodeStructureIntoJSON</strong>(s Node) ([]byte, error) {
        jsonOutput, err := json.Marshal(s)
&nbsp;
        if err != nil {
                return jsonOutput, err
        } else {
                return jsonOutput, nil
        }
}
&nbsp;
func <strong>encodeStructureIntoIndentedJSON</strong>(s Node) ([]byte, error) {
        jsonOutput, err := json.MarshalIndent(s, "", "    ")
&nbsp;
        if err != nil {
                return jsonOutput, err
        } else {
                return jsonOutput, nil
        }
}
&nbsp;
func <strong>encodeStructureIntoXML</strong>(s Node) ([]byte, error) {
        xmlOutput, err := xml.Marshal(s)
&nbsp;
        if err != nil {
                return xmlOutput, err
        } else {
                return xmlOutput, nil
        }
}
&nbsp;
func <strong>encodeStructureIntoIndentedXML</strong>(s Node) ([]byte, error) {
        xmlOutput, err := xml.MarshalIndent(s, "", "    ")
&nbsp;
        if err != nil {
                return xmlOutput, err
        } else {
                return xmlOutput, nil
        }
}
&nbsp;
func <strong>encodeStructureIntoGob</strong>(s Node) ([]byte, error) {
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
&nbsp;
        err := encoder.Encode(s)
        if err != nil {
                return buffer.Bytes(), err
        } else {
                return buffer.Bytes(), nil
        }
}
&nbsp;
func <strong>save</strong>(encodedStructure []byte, filename string) {
        err := ioutil.WriteFile(filename, encodedStructure, 0644)
        if err != nil {
                fmt.Println(err)
        } else {
                fmt.Println("Stored into file", filename)
        }
}
&nbsp;
func <strong>printBufferInfo</strong>(buffer []byte) {
        fmt.Println("\nBuffer with encoded structure: ", len(buffer))
}
&nbsp;
func <strong>main</strong>() {
        var a, b Node
&nbsp;
        a.Value = 1
        b.Value = 2
        a.Next = &amp;b
        b.Next = &amp;a
&nbsp;
        encodedStructure, err := encodeStructureIntoXML(a)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedStructure)
        save(encodedStructure, "structure1.xml")
&nbsp;
        encodedStructure, err = encodeStructureIntoIndentedXML(a)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedStructure)
        save(encodedStructure, "structure2.xml")
&nbsp;
        encodedStructure, err = encodeStructureIntoJSON(a)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedStructure)
        save(encodedStructure, "structure1.json")
&nbsp;
        encodedStructure, err = encodeStructureIntoIndentedJSON(a)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedStructure)
        save(encodedStructure, "structure2.json")
&nbsp;
        encodedStructure, err = encodeStructureIntoBSON(a)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedStructure)
        save(encodedStructure, "structure1.bson")
&nbsp;
        encodedStructure, err = encodeStructureIntoGob(a)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedStructure)
        save(encodedStructure, "structure1.gob")
}
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně šest až sedm megabajtů), můžete namísto toho použít odkazy na
jednotlivé demonstrační příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_gob_marshal_basic_types.go</td><td>rozšířený příklad z&nbsp;minula &ndash; serializace základních typů do <i>gob</i></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_58/01_gob_marshal_basic_types.go">https://github.com/tisnik/go-root/blob/master/article_58/01_gob_marshal_basic_types.go</a></td></tr>
<tr><td> 2</td><td>02_gob_unsigned_integers.go</td><td>uložení celých čísel bez znaménka do binárního formátu <i>gob</i></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_58/02_gob_unsigned_integers.go">https://github.com/tisnik/go-root/blob/master/article_58/02_gob_unsigned_integers.go</a></td></tr>
<tr><td> 3</td><td>03_gob_signed_integers.go</td><td>uložení celých čísel se znaménkem do binárního formátu <i>gob</i></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_58/03_gob_signed_integers.go">https://github.com/tisnik/go-root/blob/master/article_58/03_gob_signed_integers.go</a></td></tr>
<tr><td> 4</td><td>04_gob_slice_of_integers.go</td><td>uložení řezu celých čísel do binárního formátu <i>gob</i></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_58/04_gob_slice_of_integers.go">https://github.com/tisnik/go-root/blob/master/article_58/04_gob_slice_of_integers.go</a></td></tr>
<tr><td> 5</td><td>05_gob_binary_tree.go</td><td>práce s&nbsp;binárním stromem, jeho uložení do formátu <i>gob</i></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_58/05_gob_binary_tree.go">https://github.com/tisnik/go-root/blob/master/article_58/05_gob_binary_tree.go</a></td></tr>
<tr><td> 6</td><td>06_gob_binary_tree_2.go</td><td>vylepšení předchozího demonstračního příkladu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_58/06_gob_binary_tree_2.go">https://github.com/tisnik/go-root/blob/master/article_58/06_gob_binary_tree_2.go</a></td></tr>
<tr><td> 7</td><td>07_gob_binary_tree_decode.go</td><td>serializace a deserializace binárního stromu (položky jsou exportovány)</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_58/07_gob_binary_tree_decode.go">https://github.com/tisnik/go-root/blob/master/article_58/07_gob_binary_tree_decode.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>08_json_binary_tree_decode.go</td><td>serializace binárního stromu do formátu JSON</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_58/08_json_binary_tree_decode.go">https://github.com/tisnik/go-root/blob/master/article_58/08_json_binary_tree_decode.go</a></td></tr>
<tr><td> 9</td><td>09_bson_binary_tree_decode.go</td><td>serializace binárního stromu do formátu BSON</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_58/09_bson_binary_tree_decode.go">https://github.com/tisnik/go-root/blob/master/article_58/09_bson_binary_tree_decode.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>bson_decode_pprint.py</td><td>načtení binárního souboru ve formátu BSON do Pythonu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_58/bson_decode_pprint.py">https://github.com/tisnik/go-root/blob/master/article_58/bson_decode_pprint.py</a></td></tr>
<tr><td>11</td><td>bson_decode_better_output.py</td><td>vylepšená varianta předchozího příkladu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_58/bson_decode_better_output.py">https://github.com/tisnik/go-root/blob/master/article_58/bson_decode_better_output.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>10_size_comparison_A.go</td><td>porovnání velikosti serializovaných dat &ndash; vektor obsahující hodnoty s&nbsp;plovoucí řádovou čárkou</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_58/10_size_comparison_A.go">https://github.com/tisnik/go-root/blob/master/article_58/10_size_comparison_A.go</a></td></tr>
<tr><td>13</td><td>11_size_comparison_B.go</td><td>porovnání velikosti serializovaných dat &ndash; serializovaná struktura obsahující jediný atribut &ndash; dlouhý řetězec</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_58/11_size_comparison_B.go">https://github.com/tisnik/go-root/blob/master/article_58/11_size_comparison_B.go</a></td></tr>
<tr><td>14</td><td>12_size_comparison_C.go</td><td>porovnání velikosti serializovaných dat &ndash; serializovaný strom s&nbsp;255 uzly</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_58/12_size_comparison_C.go">https://github.com/tisnik/go-root/blob/master/article_58/12_size_comparison_C.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>13_graph.go</td><td>serializace jednoduchého grafu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_58/13_graph.go">https://github.com/tisnik/go-root/blob/master/article_58/13_graph.go</a></td></tr>
<tr><td>16</td><td>14_graph_encode_decode.go</td><td>serializace grafu s&nbsp;více cestami do jednoho uzlu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_58/14_graph_encode_decode.go">https://github.com/tisnik/go-root/blob/master/article_58/14_graph_encode_decode.go</a></td></tr>
<tr><td>17</td><td>15_cycle_in_graph.go</td><td>serializace grafu s&nbsp;cyklem (kružnicí)</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_58/15_cycle_in_graph.go">https://github.com/tisnik/go-root/blob/master/article_58/15_cycle_in_graph.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Go Data Structures: Binary Search Tree<br />
<a href="https://flaviocopes.com/golang-data-structure-binary-search-tree/">https://flaviocopes.com/golang-data-structure-binary-search-tree/</a>
</li>

<li>Gobs of data<br />
<a href="https://blog.golang.org/gobs-of-data">https://blog.golang.org/gobs-of-data</a>
</li>

<li>Formát BSON<br />
<a href="http://bsonspec.org/">http://bsonspec.org/</a>
</li>

<li>Golang Guide: A List of Top Golang Frameworks, IDEs &amp; Tools<br />
<a href="https://blog.intelligentbee.com/2017/08/14/golang-guide-list-top-golang-frameworks-ides-tools/">https://blog.intelligentbee.com/2017/08/14/golang-guide-list-top-golang-frameworks-ides-tools/</a>
</li>

<li>Tvorba univerzálních projevů<br />
<a href="http://www.kyblsoft.cz/projevy">http://www.kyblsoft.cz/projevy</a>
</li>

<li>Repositář projektu Gift<br />
<a href="https://github.com/disintegration/gift">https://github.com/disintegration/gift</a>
</li>

<li>Dokumentace k&nbsp;projektu Gift<br />
<a href="https://godoc.org/github.com/disintegration/gift">https://godoc.org/github.com/disintegration/gift</a>
</li>

<li>Online x86 / x64 Assembler and Disassembler<br />
<a href="https://defuse.ca/online-x86-assembler.htm#disassembly2">https://defuse.ca/online-x86-assembler.htm#disassembly2</a>
</li>

<li>The Design of the Go Assembler<br />
<a href="https://talks.golang.org/2016/asm.slide#1">https://talks.golang.org/2016/asm.slide#1</a>
</li>

<li>A Quick Guide to Go's Assembler<br />
<a href="https://golang.org/doc/asm">https://golang.org/doc/asm</a>
</li>

<li>AssemblyPolicy<br />
<a href="https://github.com/golang/go/wiki/AssemblyPolicy">https://github.com/golang/go/wiki/AssemblyPolicy</a>
</li>

<li>Geohash in Golang Assembly<br />
<a href="https://mmcloughlin.com/posts/geohash-assembly">https://mmcloughlin.com/posts/geohash-assembly</a>
</li>

<li>Command objdump<br />
<a href="https://golang.org/cmd/objdump/">https://golang.org/cmd/objdump/</a>
</li>

<li>Assembly<br />
<a href="https://goroutines.com/asm">https://goroutines.com/asm</a>
</li>

<li>Go &amp; Assembly<br />
<a href="http://www.doxsey.net/blog/go-and-assembly">http://www.doxsey.net/blog/go-and-assembly</a>
</li>

<li>A Foray Into Go Assembly Programming<br />
<a href="https://blog.sgmansfield.com/2017/04/a-foray-into-go-assembly-programming/">https://blog.sgmansfield.com/2017/04/a-foray-into-go-assembly-programming/</a>
</li>

<li>Golang Capturing log.Println And fmt.Println Output<br />
<a href="https://medium.com/@hau12a1/golang-capturing-log-println-and-fmt-println-output-770209c791b4">https://medium.com/@hau12a1/golang-capturing-log-println-and-fmt-println-output-770209c791b4</a>
</li>

<li>Stránka projektu plotly<br />
<a href="https://plot.ly/">https://plot.ly/</a>
</li>

<li>Plotly JavaScript Open Source Graphing Library<br />
<a href="https://plot.ly/javascript/">https://plot.ly/javascript/</a>
</li>

<li>Domain coloring<br />
<a href="https://en.wikipedia.org/wiki/Domain_coloring">https://en.wikipedia.org/wiki/Domain_coloring</a>
</li>

<li>Michael Fogleman's projects<br />
<a href="https://www.michaelfogleman.com/projects/tagged/graphics/">https://www.michaelfogleman.com/projects/tagged/graphics/</a>
</li>

<li>Color Graphs of Complex Functions<br />
<a href="https://web.archive.org/web/20120511021419/http://w.american.edu/cas/mathstat/lcrone/ComplexPlot.html">https://web.archive.org/web/20120511021419/http://w.american.edu/cas/mathstat/lcrone/ComplexPlot.html</a>
</li>

<li>A Gallery of Complex Functions<br />
<a href="http://wismuth.com/complex/gallery.html">http://wismuth.com/complex/gallery.html</a>
</li>

<li>package glot<br />
<a href="https://godoc.org/github.com/Arafatk/glot">https://godoc.org/github.com/Arafatk/glot</a>
</li>

<li>Gnuplotting: Output terminals<br />
<a href="http://www.gnuplotting.org/output-terminals/">http://www.gnuplotting.org/output-terminals/</a>
</li>

<li>Introducing Glot the plotting library for Golang<br />
<a href="https://medium.com/@Arafat./introducing-glot-the-plotting-library-for-golang-3133399948a1">https://medium.com/@Arafat./introducing-glot-the-plotting-library-for-golang-3133399948a1</a>
</li>

<li>Introducing Glot the plotting library for Golang<br />
<a href="https://blog.gopheracademy.com/advent-2018/introducing-glot/">https://blog.gopheracademy.com/advent-2018/introducing-glot/</a>
</li>

<li>Glot is a plotting library for Golang built on top of gnuplot<br />
<a href="https://github.com/Arafatk/glot">https://github.com/Arafatk/glot</a>
</li>

<li>Example plots (gonum/plot)<br />
<a href="https://github.com/gonum/plot/wiki/Example-plots">https://github.com/gonum/plot/wiki/Example-plots</a>
</li>

<li>A repository for plotting and visualizing data (gonum/plot)<br />
<a href="https://github.com/gonum/plot">https://github.com/gonum/plot</a>
</li>

<li>golang library to make https://chartjs.org/ plots<br />
<a href="https://github.com/brentp/go-chartjs">https://github.com/brentp/go-chartjs</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>The Gonum Numerical Computing Package<br />
<a href="https://www.gonum.org/post/introtogonum/">https://www.gonum.org/post/introtogonum/</a>
</li>

<li>Gomacro na GitHubu<br />
<a href="https://github.com/cosmos72/gomacro">https://github.com/cosmos72/gomacro</a>
</li>

<li>gophernotes - Use Go in Jupyter notebooks and nteract<br />
<a href="https://github.com/gopherdata/gophernotes">https://github.com/gopherdata/gophernotes</a>
</li>

<li>gonum<br />
<a href="https://github.com/gonum">https://github.com/gonum</a>
</li>

<li>go-gota/gota -  DataFrames and data wrangling in Go (Golang)<br />
<a href="https://porter.io/github.com/go-gota/gota">https://porter.io/github.com/go-gota/gota</a>
</li>

<li>A repository for plotting and visualizing data <br />
<a href="https://github.com/gonum/plot">https://github.com/gonum/plot</a>
</li>

<li>Gonum Numerical Packages<br />
<a href="https://www.gonum.org/">https://www.gonum.org/</a>
</li>

<li>Stránky projektu MinIO<br />
<a href="https://min.io/">https://min.io/</a>
</li>

<li>MinIO Quickstart Guide<br />
<a href="https://docs.min.io/docs/minio-quickstart-guide.html">https://docs.min.io/docs/minio-quickstart-guide.html</a>
</li>

<li>MinIO Go Client API Reference<br />
<a href="https://docs.min.io/docs/golang-client-api-reference">https://docs.min.io/docs/golang-client-api-reference</a>
</li>

<li>MinIO Python Client API Reference<br />
<a href="https://docs.min.io/docs/python-client-api-reference.html">https://docs.min.io/docs/python-client-api-reference.html</a>
</li>

<li>Performance at Scale: MinIO Pushes Past 1.4 terabits per second with 256 NVMe Drives<br />
<a href="https://blog.min.io/performance-at-scale-minio-pushes-past-1-3-terabits-per-second-with-256-nvme-drives/">https://blog.min.io/performance-at-scale-minio-pushes-past-1-3-terabits-per-second-with-256-nvme-drives/</a>
</li>

<li>Benchmarking MinIO vs. AWS S3 for Apache Spark<br />
<a href="https://blog.min.io/benchmarking-apache-spark-vs-aws-s3/">https://blog.min.io/benchmarking-apache-spark-vs-aws-s3/</a>
</li>

<li>MinIO Client Quickstart Guide<br />
<a href="https://docs.min.io/docs/minio-client-quickstart-guide.html">https://docs.min.io/docs/minio-client-quickstart-guide.html</a>
</li>

<li>Analýza kvality zdrojových kódů Minia<br />
<a href="https://goreportcard.com/report/github.com/minio/minio">https://goreportcard.com/report/github.com/minio/minio</a>
</li>

<li>This is MinIO<br />
<a href="https://www.youtube.com/watch?v=vF0lQh0XOCs">https://www.youtube.com/watch?v=vF0lQh0XOCs</a>
</li>

<li>Running MinIO Standalone<br />
<a href="https://www.youtube.com/watch?v=dIQsPCHvHoM">https://www.youtube.com/watch?v=dIQsPCHvHoM</a>
</li>

<li>"Amazon S3 Compatible Storage in Kubernetes" - Rob Girard, Principal Tech Marketing Engineer, Minio<br />
<a href="https://www.youtube.com/watch?v=wlpn8K0jJ4U">https://www.youtube.com/watch?v=wlpn8K0jJ4U</a>
</li>

<li>Ginkgo<br />
<a href="http://onsi.github.io/ginkgo/">http://onsi.github.io/ginkgo/</a>
</li>

<li>Gomega<br />
<a href="https://onsi.github.io/gomega/">https://onsi.github.io/gomega/</a>
</li>

<li>Ginkgo's Preferred Matcher Library na GitHubu<br />
<a href="https://github.com/onsi/gomega/">https://github.com/onsi/gomega/</a>
</li>

<li>Provided Matchers<br />
<a href="http://onsi.github.io/gomega/#provided-matchers">http://onsi.github.io/gomega/#provided-matchers</a>
</li>

<li>Dokumentace k&nbsp;balíčku goexpect<br />
<a href="https://godoc.org/github.com/google/goexpect">https://godoc.org/github.com/google/goexpect</a>
</li>

<li>Balíček goexpect<br />
<a href="https://github.com/google/goexpect">https://github.com/google/goexpect</a>
</li>

<li>Balíček go-expect<br />
<a href="https://github.com/Netflix/go-expect">https://github.com/Netflix/go-expect</a>
</li>

<li>Balíček gexpect<br />
<a href="https://github.com/ThomasRooney/gexpect">https://github.com/ThomasRooney/gexpect</a>
</li>

<li>Expect (originál naprogramovaný v&nbsp;TCL)<br />
<a href="https://core.tcl-lang.org/expect/index">https://core.tcl-lang.org/expect/index</a>
</li>

<li>Expect (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Expect">https://en.wikipedia.org/wiki/Expect</a>
</li>

<li>Pexpect<br />
<a href="https://pexpect.readthedocs.io/en/stable/">https://pexpect.readthedocs.io/en/stable/</a>
</li>

<li>Golang SSH Client: Multiple Commands, Crypto &amp; Goexpect Examples<br />
<a href="http://networkbit.ch/golang-ssh-client/">http://networkbit.ch/golang-ssh-client/</a>
</li>

<li>goblin na GitHubu<br />
<a href="https://github.com/franela/goblin">https://github.com/franela/goblin</a>
</li>

<li>Mocha framework<br />
<a href="https://mochajs.org/">https://mochajs.org/</a>
</li>

<li>frisby na GitHubu<br />
<a href="https://github.com/verdverm/frisby">https://github.com/verdverm/frisby</a>
</li>

<li>package frisby<br />
<a href="https://godoc.org/github.com/verdverm/frisby">https://godoc.org/github.com/verdverm/frisby</a>
</li>

<li>Frisby alternatives and similar packages (generováno)<br />
<a href="https://go.libhunt.com/frisby-alternatives">https://go.libhunt.com/frisby-alternatives</a>
</li>

<li>Cucumber for golang<br />
<a href="https://github.com/DATA-DOG/godog">https://github.com/DATA-DOG/godog</a>
</li>

<li>How to Use Godog for Behavior-driven Development in Go<br />
<a href="https://semaphoreci.com/community/tutorials/how-to-use-godog-for-behavior-driven-development-in-go">https://semaphoreci.com/community/tutorials/how-to-use-godog-for-behavior-driven-development-in-go</a>
</li>

<li>Comparative Analysis Of GoLang Testing Frameworks<br />
<a href="https://www.slideshare.net/DushyantBhalgami/comparative-analysis-of-golang-testing-frameworks">https://www.slideshare.net/DushyantBhalgami/comparative-analysis-of-golang-testing-frameworks</a>
</li>

<li>A Quick Guide to Testing in Golang<br />
<a href="https://caitiem.com/2016/08/18/a-quick-guide-to-testing-in-golang/">https://caitiem.com/2016/08/18/a-quick-guide-to-testing-in-golang/</a>
</li>

<li>Tom's Obvious, Minimal Language.<br />
<a href="https://github.com/toml-lang/toml">https://github.com/toml-lang/toml</a>
</li>

<li>xml.org<br />
<a href="http://www.xml.org/">http://www.xml.org/</a>
</li>

<li>Soubory .properties<br />
<a href="https://en.wikipedia.org/wiki/.properties">https://en.wikipedia.org/wiki/.properties</a>
</li>

<li>Soubory INI<br />
<a href="https://en.wikipedia.org/wiki/INI_file">https://en.wikipedia.org/wiki/INI_file</a>
</li>

<li>JSON to YAML<br />
<a href="https://www.json2yaml.com/">https://www.json2yaml.com/</a>
</li>

<li>Data Format Converter<br />
<a href="https://toolkit.site/format.html">https://toolkit.site/format.html</a>
</li>

<li>Viper na GitHubu<br />
<a href="https://github.com/spf13/viper">https://github.com/spf13/viper</a>
</li>

<li>GoDotEnv na GitHubu<br />
<a href="https://github.com/joho/godotenv">https://github.com/joho/godotenv</a>
</li>

<li>The fantastic ORM library for Golang<br />
<a href="http://gorm.io/">http://gorm.io/</a>
</li>

<li>Dokumentace k&nbsp;balíčku <strong>gorilla/mux</strong><br />
<a href="https://godoc.org/github.com/gorilla/mux">https://godoc.org/github.com/gorilla/mux</a>
</li>

<li>Gorilla web toolkitk<br />
<a href="http://www.gorillatoolkit.org/">http://www.gorillatoolkit.org/</a>
</li>

<li>Metric types<br />
<a href="https://prometheus.io/docs/concepts/metric_types/">https://prometheus.io/docs/concepts/metric_types/</a>
</li>

<li>Histograms with Prometheus: A Tale of Woe<br />
<a href="http://linuxczar.net/blog/2017/06/15/prometheus-histogram-2/">http://linuxczar.net/blog/2017/06/15/prometheus-histogram-2/</a>
</li>

<li>Why are Prometheus histograms cumulative?<br />
<a href="https://www.robustperception.io/why-are-prometheus-histograms-cumulative">https://www.robustperception.io/why-are-prometheus-histograms-cumulative</a>
</li>

<li>Histograms and summaries<br />
<a href="https://prometheus.io/docs/practices/histograms/">https://prometheus.io/docs/practices/histograms/</a>
</li>

<li>Instrumenting Golang server in 5 min<br />
<a href="https://medium.com/@gsisimogang/instrumenting-golang-server-in-5-min-c1c32489add3">https://medium.com/@gsisimogang/instrumenting-golang-server-in-5-min-c1c32489add3</a>
</li>

<li>Semantic Import Versioning in Go<br />
<a href="https://www.aaronzhuo.com/semantic-import-versioning-in-go/">https://www.aaronzhuo.com/semantic-import-versioning-in-go/</a>
</li>

<li>Sémantické verzování<br />
<a href="https://semver.org/">https://semver.org/</a>
</li>

<li>Getting started with Go modules<br />
<a href="https://medium.com/@fonseka.live/getting-started-with-go-modules-b3dac652066d">https://medium.com/@fonseka.live/getting-started-with-go-modules-b3dac652066d</a>
</li>

<li>Create projects independent of $GOPATH using Go Modules<br />
<a href="https://medium.com/mindorks/create-projects-independent-of-gopath-using-go-modules-802260cdfb51o">https://medium.com/mindorks/create-projects-independent-of-gopath-using-go-modules-802260cdfb51o</a>
</li>

<li>Anatomy of Modules in Go<br />
<a href="https://medium.com/rungo/anatomy-of-modules-in-go-c8274d215c16">https://medium.com/rungo/anatomy-of-modules-in-go-c8274d215c16</a>
</li>

<li>Modules<br />
<a href="https://github.com/golang/go/wiki/Modules">https://github.com/golang/go/wiki/Modules</a>
</li>

<li>Go Modules Tutorial<br />
<a href="https://tutorialedge.net/golang/go-modules-tutorial/">https://tutorialedge.net/golang/go-modules-tutorial/</a>
</li>

<li>Module support<br />
<a href="https://golang.org/cmd/go/#hdr-Module_support">https://golang.org/cmd/go/#hdr-Module_support</a>
</li>

<li>Go Lang: Memory Management and Garbage Collection<br />
<a href="https://vikash1976.wordpress.com/2017/03/26/go-lang-memory-management-and-garbage-collection/">https://vikash1976.wordpress.com/2017/03/26/go-lang-memory-management-and-garbage-collection/</a>
</li>

<li>Golang Internals, Part 4: Object Files and Function Metadata<br />
<a href="https://blog.altoros.com/golang-part-4-object-files-and-function-metadata.html">https://blog.altoros.com/golang-part-4-object-files-and-function-metadata.html</a>
</li>

<li>What is REPL?<br />
<a href="https://pythonprogramminglanguage.com/repl/">https://pythonprogramminglanguage.com/repl/</a>
</li>

<li>What is a REPL?<br />
<a href="https://codewith.mu/en/tutorials/1.0/repl">https://codewith.mu/en/tutorials/1.0/repl</a>
</li>

<li>Programming at the REPL: Introduction<br />
<a href="https://clojure.org/guides/repl/introduction">https://clojure.org/guides/repl/introduction</a>
</li>

<li>What is REPL? (Quora)<br />
<a href="https://www.quora.com/What-is-REPL">https://www.quora.com/What-is-REPL</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Read-eval-print loop (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>Vim as a Go (Golang) IDE using LSP and vim-go<br />
<a href="https://octetz.com/posts/vim-as-go-ide">https://octetz.com/posts/vim-as-go-ide</a>
</li>

<li>gopls<br />
<a href="https://github.com/golang/go/wiki/gopls">https://github.com/golang/go/wiki/gopls</a>
</li>

<li>IDE Integration Guide<br />
<a href="https://github.com/stamblerre/gocode/blob/master/docs/IDE_integration.md">https://github.com/stamblerre/gocode/blob/master/docs/IDE_integration.md</a>
</li>

<li>How to instrument Go code with custom expvar metrics<br />
<a href="https://sysdig.com/blog/golang-expvar-custom-metrics/">https://sysdig.com/blog/golang-expvar-custom-metrics/</a>
</li>

<li>Golang expvar metricset (Metricbeat Reference)<br />
<a href="https://www.elastic.co/guide/en/beats/metricbeat/7.x/metricbeat-metricset-golang-expvar.html">https://www.elastic.co/guide/en/beats/metricbeat/7.x/metricbeat-metricset-golang-expvar.html</a>
</li>

<li>Package expvar<br />
<a href="https://golang.org/pkg/expvar/#NewInt">https://golang.org/pkg/expvar/#NewInt</a>
</li>

<li>Java Platform Debugger Architecture: Overview<br />
<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jpda/jpda.html">https://docs.oracle.com/en/java/javase/11/docs/specs/jpda/jpda.html</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="https://www.oracle.com/technetwork/articles/javase/index-140680.html">https://www.oracle.com/technetwork/articles/javase/index-140680.html</a>
</li>

<li>JVM Tool Interface Version 11.0<br />
<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html">https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>Go &amp; cgo: integrating existing C code with Go<br />
<a href="http://akrennmair.github.io/golang-cgo-slides/#1">http://akrennmair.github.io/golang-cgo-slides/#1</a>
</li>

<li>Using cgo to call C code from within Go code<br />
<a href="https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/">https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/</a>
</li>

<li>Package trace<br />
<a href="https://golang.org/pkg/runtime/trace/">https://golang.org/pkg/runtime/trace/</a>
</li>

<li>Introducing HTTP Tracing<br />
<a href="https://blog.golang.org/http-tracing">https://blog.golang.org/http-tracing</a>
</li>

<li>Command trace<br />
<a href="https://golang.org/cmd/trace/">https://golang.org/cmd/trace/</a>
</li>

<li>A StreamLike, Immutable, Lazy Loading and smart Golang Library to deal with slices<br />
<a href="https://github.com/wesovilabs/koazee">https://github.com/wesovilabs/koazee</a>
</li>

<li>Funkce vyššího řádu v knihovně Underscore<br />
<a href="https://www.root.cz/clanky/funkce-vyssiho-radu-v-knihovne-underscore/">https://www.root.cz/clanky/funkce-vyssiho-radu-v-knihovne-underscore/</a>
</li>

<li>Delve: a debugger for the Go programming language.<br />
<a href="https://github.com/go-delve/delve">https://github.com/go-delve/delve</a>
</li>

<li>Příkazy debuggeru Delve<br />
<a href="https://github.com/go-delve/delve/tree/master/Documentation/cli">https://github.com/go-delve/delve/tree/master/Documentation/cli</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (2. část)<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v&nbsp;editorech Emacs a Vim<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Debugging Go Code with GDB<br />
<a href="https://golang.org/doc/gdb">https://golang.org/doc/gdb</a>
</li>

<li>Debugging Go (golang) programs with gdb <br />
<a href="https://thornydev.blogspot.com/2014/01/debugging-go-golang-programs-with-gdb.html">https://thornydev.blogspot.com/2014/01/debugging-go-golang-programs-with-gdb.html</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>GDB - Supported Languages<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>13 Linux Debuggers for C++ Reviewed<br />
<a href="http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817">http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817</a>
</li>

<li>Go is on a Trajectory to Become the Next Enterprise Programming Language<br />
<a href="https://hackernoon.com/go-is-on-a-trajectory-to-become-the-next-enterprise-programming-language-3b75d70544e">https://hackernoon.com/go-is-on-a-trajectory-to-become-the-next-enterprise-programming-language-3b75d70544e</a>
</li>

<li>Go Proverbs: Simple, Poetic, Pithy<br />
<a href="https://go-proverbs.github.io/">https://go-proverbs.github.io/</a>
</li>

<li>Handling Sparse Files on Linux<br />
<a href="https://www.systutorials.com/136652/handling-sparse-files-on-linux/">https://www.systutorials.com/136652/handling-sparse-files-on-linux/</a>
</li>

<li>Gzip (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Gzip">https://en.wikipedia.org/wiki/Gzip</a>
</li>

<li>Deflate<br />
<a href="https://en.wikipedia.org/wiki/DEFLATE">https://en.wikipedia.org/wiki/DEFLATE</a>
</li>

<li>10 tools written in Go that every developer needs to know<br />
<a href="https://gustavohenrique.net/en/2019/01/10-tools-written-in-go-that-every-dev-needs-to-know/">https://gustavohenrique.net/en/2019/01/10-tools-written-in-go-that-every-dev-needs-to-know/</a>
</li>

<li>Hexadecimální prohlížeče a editory s textovým uživatelským rozhraním<br />
<a href="https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/">https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/</a>
</li>

<li>Hex dump<br />
<a href="https://en.wikipedia.org/wiki/Hex_dump">https://en.wikipedia.org/wiki/Hex_dump</a>
</li>

<li>Rozhraní io.ByteReader<br />
<a href="https://golang.org/pkg/io/#ByteReader">https://golang.org/pkg/io/#ByteReader</a>
</li>

<li>Rozhraní io.RuneReader<br />
<a href="https://golang.org/pkg/io/#RuneReader">https://golang.org/pkg/io/#RuneReader</a>
</li>

<li>Rozhraní io.ByteScanner<br />
<a href="https://golang.org/pkg/io/#ByteScanner">https://golang.org/pkg/io/#ByteScanner</a>
</li>

<li>Rozhraní io.RuneScanner<br />
<a href="https://golang.org/pkg/io/#RuneScanner">https://golang.org/pkg/io/#RuneScanner</a>
</li>

<li>Rozhraní io.Closer<br />
<a href="https://golang.org/pkg/io/#Closer">https://golang.org/pkg/io/#Closer</a>
</li>

<li>Rozhraní io.Reader<br />
<a href="https://golang.org/pkg/io/#Reader">https://golang.org/pkg/io/#Reader</a>
</li>

<li>Rozhraní io.Writer<br />
<a href="https://golang.org/pkg/io/#Writer">https://golang.org/pkg/io/#Writer</a>
</li>

<li>Typ Strings.Reader<br />
<a href="https://golang.org/pkg/strings/#Reader">https://golang.org/pkg/strings/#Reader</a>
</li>

<li>VACUUM (SQL)<br />
<a href="https://www.sqlite.org/lang_vacuum.html">https://www.sqlite.org/lang_vacuum.html</a>
</li>

<li>VACUUM (Postgres)<br />
<a href="https://www.postgresql.org/docs/8.4/sql-vacuum.html">https://www.postgresql.org/docs/8.4/sql-vacuum.html</a>
</li>

<li>go-cron<br />
<a href="https://github.com/rk/go-cron">https://github.com/rk/go-cron</a>
</li>

<li>gocron<br />
<a href="https://github.com/jasonlvhit/gocron">https://github.com/jasonlvhit/gocron</a>
</li>

<li>clockwork<br />
<a href="https://github.com/whiteShtef/clockwork">https://github.com/whiteShtef/clockwork</a>
</li>

<li>clockwerk<br />
<a href="https://github.com/onatm/clockwerk">https://github.com/onatm/clockwerk</a>
</li>

<li>JobRunner<br />
<a href="https://github.com/bamzi/jobrunner">https://github.com/bamzi/jobrunner</a>
</li>

<li>Rethinking Cron<br />
<a href="https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/">https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/</a>
</li>

<li>In the Beginning was the Command Line<br />
<a href="https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html">https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html</a>
</li>

<li>repl.it (REPL pro různé jazyky)<br />
<a href="https://repl.it/languages">https://repl.it/languages</a>
</li>

<li>GOCUI - Go Console User Interface (celé uživatelské prostředí, nejenom input box)<br />
<a href="https://github.com/jroimartin/gocui">https://github.com/jroimartin/gocui</a>
</li>

<li>Read–eval–print loop<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>go-prompt<br />
<a href="https://github.com/c-bata/go-prompt">https://github.com/c-bata/go-prompt</a>
</li>

<li>readline<br />
<a href="https://github.com/chzyer/readline">https://github.com/chzyer/readline</a>
</li>

<li>A pure golang implementation for GNU-Readline kind library<br />
<a href="https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/">https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/</a>
</li>

<li>go-readline<br />
<a href="https://github.com/fiorix/go-readline">https://github.com/fiorix/go-readline</a>
</li>

<li>4 Python libraries for building great command-line user interfaces<br />
<a href="https://opensource.com/article/17/5/4-practical-python-libraries">https://opensource.com/article/17/5/4-practical-python-libraries</a>
</li>

<li>prompt_toolkit 2.0.3 na PyPi<br />
<a href="https://pypi.org/project/prompt_toolkit/">https://pypi.org/project/prompt_toolkit/</a>
</li>

<li>python-prompt-toolkit na GitHubu<br />
<a href="https://github.com/jonathanslenders/python-prompt-toolkit">https://github.com/jonathanslenders/python-prompt-toolkit</a>
</li>

<li>The GNU Readline Library<br />
<a href="https://tiswww.case.edu/php/chet/readline/rltop.html">https://tiswww.case.edu/php/chet/readline/rltop.html</a>
</li>

<li>GNU Readline (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Readline">https://en.wikipedia.org/wiki/GNU_Readline</a>
</li>

<li>readline — GNU readline interface (Python 3.x)<br />
<a href="https://docs.python.org/3/library/readline.html">https://docs.python.org/3/library/readline.html</a>
</li>

<li>readline — GNU readline interface (Python 2.x)<br />
<a href="https://docs.python.org/2/library/readline.html">https://docs.python.org/2/library/readline.html</a>
</li>

<li>GNU Readline Library - command line editing<br />
<a href="https://tiswww.cwru.edu/php/chet/readline/readline.html">https://tiswww.cwru.edu/php/chet/readline/readline.html</a>
</li>

<li>gnureadline 6.3.8 na PyPi<br />
<a href="https://pypi.org/project/gnureadline/">https://pypi.org/project/gnureadline/</a>
</li>

<li>Editline Library (libedit)<br />
<a href="http://thrysoee.dk/editline/">http://thrysoee.dk/editline/</a>
</li>

<li>Comparing Python Command-Line Parsing Libraries – Argparse, Docopt, and Click<br />
<a href="https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/">https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/</a>
</li>

<li>libedit or editline<br />
<a href="http://www.cs.utah.edu/~bigler/code/libedit.html">http://www.cs.utah.edu/~bigler/code/libedit.html</a>
</li>

<li>WinEditLine<br />
<a href="http://mingweditline.sourceforge.net/">http://mingweditline.sourceforge.net/</a>
</li>

<li>rlcompleter — Completion function for GNU readline<br />
<a href="https://docs.python.org/3/library/rlcompleter.html">https://docs.python.org/3/library/rlcompleter.html</a>
</li>

<li>rlwrap na GitHubu<br />
<a href="https://github.com/hanslub42/rlwrap">https://github.com/hanslub42/rlwrap</a>
</li>

<li>rlwrap(1) - Linux man page<br />
<a href="https://linux.die.net/man/1/rlwrap">https://linux.die.net/man/1/rlwrap</a>
</li>

<li>readline(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/readline">https://linux.die.net/man/3/readline</a>
</li>

<li>history(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/history">https://linux.die.net/man/3/history</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>oglematchers</i><br />
<a href="https://godoc.org/github.com/jacobsa/oglematchers">https://godoc.org/github.com/jacobsa/oglematchers</a>
</li>

<li>Balíček <i>oglematchers</i><br />
<a href="https://github.com/jacobsa/oglematchers">https://github.com/jacobsa/oglematchers</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>ogletest</i><br />
<a href="https://godoc.org/github.com/jacobsa/ogletest">https://godoc.org/github.com/jacobsa/ogletest</a>
</li>

<li>Balíček <i>ogletest</i><br />
<a href="https://github.com/jacobsa/ogletest">https://github.com/jacobsa/ogletest</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>assert</i><br />
<a href="https://godoc.org/github.com/stretchr/testify/assert">https://godoc.org/github.com/stretchr/testify/assert</a>
</li>

<li>Testify - Thou Shalt Write Tests<br />
<a href="https://github.com/stretchr/testify/">https://github.com/stretchr/testify/</a>
</li>

<li>package testing<br />
<a href="https://golang.org/pkg/testing/">https://golang.org/pkg/testing/</a>
</li>

<li>Golang basics - writing unit tests<br />
<a href="https://blog.alexellis.io/golang-writing-unit-tests/">https://blog.alexellis.io/golang-writing-unit-tests/</a>
</li>

<li>An Introduction to Programming in Go / Testing<br />
<a href="https://www.golang-book.com/books/intro/12">https://www.golang-book.com/books/intro/12</a>
</li>

<li>An Introduction to Testing in Go<br />
<a href="https://tutorialedge.net/golang/intro-testing-in-go/">https://tutorialedge.net/golang/intro-testing-in-go/</a>
</li>

<li>Advanced Go Testing Tutorial<br />
<a href="https://tutorialedge.net/golang/advanced-go-testing-tutorial/">https://tutorialedge.net/golang/advanced-go-testing-tutorial/</a>
</li>

<li>GoConvey<br />
<a href="http://goconvey.co/">http://goconvey.co/</a>
</li>

<li>Testing Techniques<br />
<a href="https://talks.golang.org/2014/testing.slide">https://talks.golang.org/2014/testing.slide</a>
</li>

<li>5 simple tips and tricks for writing unit tests in #golang<br />
<a href="https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742">https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742</a>
</li>

<li>Afinní transformace<br />
<a href="https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic">https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic</a>
</li>

<li>package gg<br />
<a href="https://godoc.org/github.com/fogleman/gg">https://godoc.org/github.com/fogleman/gg</a>
</li>

<li>Generate an animated GIF with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/">http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/</a>
</li>

<li>Generate an image programmatically with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/">http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/</a>
</li>

<li>The Go image package<br />
<a href="https://blog.golang.org/go-image-package">https://blog.golang.org/go-image-package</a>
</li>

<li>Balíček draw2D: 2D rendering for different output (raster, pdf, svg)<br />
<a href="https://github.com/llgcode/draw2d">https://github.com/llgcode/draw2d</a>
</li>

<li>Draw a rectangle in Golang?<br />
<a href="https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang">https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang</a>
</li>

<li>YAML<br />
<a href="https://yaml.org/">https://yaml.org/</a>
</li>

<li>edn<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Smile<br />
<a href="https://github.com/FasterXML/smile-format-specification">https://github.com/FasterXML/smile-format-specification</a>
</li>

<li>Protocol-Buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>Marshalling (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
</li>

<li>Unmarshalling<br />
<a href="https://en.wikipedia.org/wiki/Unmarshalling">https://en.wikipedia.org/wiki/Unmarshalling</a>
</li>

<li>Introducing JSON<br />
<a href="http://json.org/">http://json.org/</a>
</li>

<li>Package json<br />
<a href="https://golang.org/pkg/encoding/json/">https://golang.org/pkg/encoding/json/</a>
</li>

<li>The Go Blog: JSON and Go<br />
<a href="https://blog.golang.org/json-and-go">https://blog.golang.org/json-and-go</a>
</li>

<li>Go by Example: JSON<br />
<a href="https://gobyexample.com/json">https://gobyexample.com/json</a>
</li>

<li>Writing Web Applications<br />
<a href="https://golang.org/doc/articles/wiki/">https://golang.org/doc/articles/wiki/</a>
</li>

<li>Golang Web Apps<br />
<a href="https://www.reinbach.com/blog/golang-webapps-1/">https://www.reinbach.com/blog/golang-webapps-1/</a>
</li>

<li>Build web application with Golang<br />
<a href="https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details">https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details</a>
</li>

<li>Golang Templates - Golang Web Pages<br />
<a href="https://www.youtube.com/watch?v=TkNIETmF-RU">https://www.youtube.com/watch?v=TkNIETmF-RU</a>
</li>

<li>Simple Golang HTTPS/TLS Examples<br />
<a href="https://github.com/denji/golang-tls">https://github.com/denji/golang-tls</a>
</li>

<li>Playing with images in HTTP response in golang<br />
<a href="https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang">https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang</a>
</li>

<li>MIME Types List<br />
<a href="https://www.freeformatter.com/mime-types-list.html">https://www.freeformatter.com/mime-types-list.html</a>
</li>

<li>Go Mutex Tutorial<br />
<a href="https://tutorialedge.net/golang/go-mutex-tutorial/">https://tutorialedge.net/golang/go-mutex-tutorial/</a>
</li>

<li>Creating A Simple Web Server With Golang<br />
<a href="https://tutorialedge.net/golang/creating-simple-web-server-with-golang/">https://tutorialedge.net/golang/creating-simple-web-server-with-golang/</a>
</li>

<li>Building a Web Server in Go<br />
<a href="https://thenewstack.io/building-a-web-server-in-go/">https://thenewstack.io/building-a-web-server-in-go/</a>
</li>

<li>How big is the pipe buffer?<br />
<a href="https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer">https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer</a>
</li>

<li>How to turn off buffering of stdout in C<br />
<a href="https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c">https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c</a>
</li>

<li>setbuf(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/setbuf">https://linux.die.net/man/3/setbuf</a>
</li>

<li>setvbuf(3) - Linux man page (stejný obsah jako předchozí stránka)<br />
<a href="https://linux.die.net/man/3/setvbuf">https://linux.die.net/man/3/setvbuf</a>
</li>

<li>Select waits on a group of channels<br />
<a href="https://yourbasic.org/golang/select-explained/">https://yourbasic.org/golang/select-explained/</a>
</li>

<li>Rob Pike: Simplicity is Complicated (video)<br />
<a href="http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893">http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893</a>
</li>

<li>Algorithms to Go<br />
<a href="https://yourbasic.org/">https://yourbasic.org/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů: vlastní filtry a lexery<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/</a>
</li>

<li>Go Defer Simplified with Practical Visuals<br />
<a href="https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff">https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff</a>
</li>

<li>5 More Gotchas of Defer in Go — Part II<br />
<a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa">https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa</a>
</li>

<li>The Go Blog: Defer, Panic, and Recover<br />
<a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a>
</li>

<li>The defer keyword in Swift 2: try/finally done right<br />
<a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer">https://www.hackingwithswift.com/new-syntax-swift-2-defer</a>
</li>

<li>Swift Defer Statement<br />
<a href="https://andybargh.com/swift-defer-statement/">https://andybargh.com/swift-defer-statement/</a>
</li>

<li>Modulo operation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Modulo_operation">https://en.wikipedia.org/wiki/Modulo_operation</a>
</li>

<li>Node.js vs Golang: Battle of the Next-Gen Languages<br />
<a href="https://www.hostingadvice.com/blog/nodejs-vs-golang/">https://www.hostingadvice.com/blog/nodejs-vs-golang/</a>
</li>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go<br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>JavaScript vs. Golang for IoT: Is Gopher Winning?<br />
<a href="https://www.iotforall.com/javascript-vs-golang-iot/">https://www.iotforall.com/javascript-vs-golang-iot/</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

<li>Printf Format Strings<br />
<a href="https://www.cprogramming.com/tutorial/printf-format-strings.html">https://www.cprogramming.com/tutorial/printf-format-strings.html</a>
</li>

<li>Java: String.format<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-</a>
</li>

<li>Java: format string syntax<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a>
</li>

<li>Selectors<br />
<a href="https://golang.org/ref/spec#Selectors">https://golang.org/ref/spec#Selectors</a>
</li>

<li>Calling Go code from Python code<br />
<a href="http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/">http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/</a>
</li>

<li>Go Data Structures: Interfaces <br />
<a href="https://research.swtch.com/interfaces">https://research.swtch.com/interfaces</a>
</li>

<li>How to use interfaces in Go<br />
<a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go</a>
</li>

<li>Interfaces in Go (part I)<br />
<a href="https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c">https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c</a>
</li>

<li>Part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>What about Trait support in Golang?<br />
<a href="https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/">https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/</a>
</li>

<li>Don't Get Bitten by Pointer vs Non-Pointer Method Receivers in Golang<br />
<a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/">https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/</a>
</li>

<li>Control Flow<br />
<a href="https://en.wikipedia.org/wiki/Control_flow">https://en.wikipedia.org/wiki/Control_flow</a>
</li>

<li>Structured programming<br />
<a href="https://en.wikipedia.org/wiki/Structured_programming">https://en.wikipedia.org/wiki/Structured_programming</a>
</li>

<li>Control Structures<br />
<a href="https://www.golang-book.com/books/intro/5">https://www.golang-book.com/books/intro/5</a>
</li>

<li>Control structures - Go if else statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html">http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html</a>
</li>

<li>Control structures - Go switch case statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html</a>
</li>

<li>Control structures - Go for loop, break, continue, range<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html</a>
</li>

<li>Goroutine IDs<br />
<a href="https://blog.sgmansfield.com/2015/12/goroutine-ids/">https://blog.sgmansfield.com/2015/12/goroutine-ids/</a>
</li>

<li>Different ways to pass channels as arguments in function in go (golang)<br />
<a href="https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang">https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang</a>
</li>

<li>justforfunc #22: using the Go execution tracer<br />
<a href="https://www.youtube.com/watch?v=ySy3sR1LFCQ">https://www.youtube.com/watch?v=ySy3sR1LFCQ</a>
</li>

<li>Single Function Exit Point<br />
<a href="http://wiki.c2.com/?SingleFunctionExitPoint">http://wiki.c2.com/?SingleFunctionExitPoint</a>
</li>

<li>Entry point<br />
<a href="https://en.wikipedia.org/wiki/Entry_point">https://en.wikipedia.org/wiki/Entry_point</a>
</li>

<li>Why does Go have a GOTO statement?!<br />
<a href="https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/">https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/</a>
</li>

<li>Effective Go<br />
<a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a>
</li>

<li>GoClipse: an Eclipse IDE for the Go programming language<br />
<a href="http://goclipse.github.io/">http://goclipse.github.io/</a>
</li>

<li>GoClipse Installation<br />
<a href="https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation">https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation</a>
</li>

<li>The zero value of a slice is not nil<br />
<a href="https://stackoverflow.com/questions/30806931/the-zero-value-of-a-slice-is-not-nil">https://stackoverflow.com/questions/30806931/the-zero-value-of-a-slice-is-not-nil</a>
</li>

<li>Go-tcha: When nil != nil<br />
<a href="https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic">https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic</a>
</li>

<li>Nils in Go<br />
<a href="https://www.doxsey.net/blog/nils-in-go">https://www.doxsey.net/blog/nils-in-go</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

