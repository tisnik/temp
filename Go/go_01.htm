<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Go - minimalistický a překvapivě výkonný programovací jazyk</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Go - minimalistický a překvapivě výkonný programovací jazyk</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V novém seriálu, který dnes začíná na Rootu vycházet, se seznámíme s programovacím jazykem Go. Jedná se o jazyk umožňující překlad zdrojových kódů do nativního kódu, takže výsledkem by měly být rychlé aplikace srovnatelné s výsledky dalších překladačů. Současně se ovšem Go v některých ohledech od nízkoúrovňových jazyků liší.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Go &ndash; minimalistický a překvapivě výkonný programovací jazyk</a></p>
<p><a href="#k02">2. Go není &bdquo;pouze&ldquo; vylepšený programovací jazyk C</a></p>
<p><a href="#k03">3. Popularita programovacího jazyka Go mezi vývojáři</a></p>
<p><a href="#k04">4. Instalace základních nástrojů pro jazyk Go do Fedory</a></p>
<p><a href="#k05">5. Nastavení proměnné prostředí <strong>GOPATH</strong></a></p>
<p><a href="#k06">6. Základní kontrola instalace</a></p>
<p><a href="#k07">7. První demonstrační příklad &ndash; klasický &bdquo;Hello world!&ldquo; ve dvou variantách</a></p>
<p><a href="#k08">8. Jak pracovat s&nbsp;dokumentací</a></p>
<p><a href="#k09">9. Doporučovaný styl zápisu programů</a></p>
<p><a href="#k10">10. Nástroj <strong>gofmt</strong> určený pro přeformátování zdrojových kódů</a></p>
<p><a href="#k11">11. Kontrola použití importovaných modulů</a></p>
<p><a href="#k12">12. Plná podpora Unicode v&nbsp;programech</a></p>
<p><a href="#k13">13. Základy typového systému &ndash; odvození typu proměnné z&nbsp;hodnoty</a></p>
<p><a href="#k14">14. Kontrola typu hodnoty přiřazované do proměnné</a></p>
<p><a href="#k15">15. Deklarace funkcí</a></p>
<p><a href="#k16">16. Specifikace typu argumentů funkcí</a></p>
<p><a href="#k17">17. Příkaz <strong>return</strong></a></p>
<p><a href="#k18">18. Vrácení většího množství hodnot z&nbsp;funkce
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Go &ndash; minimalistický a překvapivě výkonný programovací jazyk</h2>

<p>Jak jsme se již zmínili v&nbsp;perexu, začíná dnes na <a
href="https://www.root.cz">Rootu</a> vycházet nový seriál, v&nbsp;němž se
postupně seznámíme se zajímavým a relativně novým programovacím jazykem
nazvaným Go. Jedná se o programovací jazyk umožňující překlad zdrojových kódů
do nativního (strojového) kódu, takže výsledkem by měly být rychlé a paměťově
efektivní aplikace (alespoň teoreticky) srovnatelné s&nbsp;výsledky, které jsou
produkované překladači jazyků C, C++, D či Rust (popř.&nbsp;Fortran, FreePascal
apod.). Současně ovšem Go používá automatickou správu paměti (<i>GC &ndash;
garbage collector</i>), takzvané <i>gorutiny</i> a kanály a současně i poměrně
minimalistickou syntaxi, čímž se od dvojice C a C++ dosti podstatným způsobem
odlišuje (Rust, s&nbsp;nímž jsme se <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">na Rootu již
seznámili</a>, je ovšem koncipován odlišným způsobem, i když je s&nbsp;jazykem
Go poměrně často srovnáván, například <a
href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">v&nbsp;tomto
pěkném článečku</a>).</p>

<p>Tento programovací jazyk krátce po svém oficiálním uvedení v&nbsp;roce 2009
vzbudil poměrně velký ohlas, neboť se jedná o staticky typovaný jazyk
kompilovaný do nativního kódu &ndash; mohlo by se tedy zdát, že je určen pro
oblast doposud ovládanou programovacími jazyky C a C++. Jak si však řekneme
v&nbsp;dalším textu, byla praxe poněkud složitější a Go začal být &ndash; možná
poněkud překvapivě i pro jeho samotné tvůrce &ndash; používán těmi vývojáři,
kteří tvořili aplikace založené na technologiích typu Node.js, Pythonu či Ruby
(viz též <a href="#k03">třetí kapitolu</a>). Využíván je též pro psaní síťových
utilit atd. Mezi větší a známější aplikace naprogramované v&nbsp;Go patří
především <a href="https://www.openshift.com/">OpenShift</a>, <a
href="https://kubernetes.io/">Kubernetes</a> a zapomenout nesmíme ani na <a
href="https://www.docker.com/">Docker</a>.</p>

<p><div class="rs-tip-major">Poznámka: na tomto místě je nutné upozornit na to,
že Go vzbudil ohlas nejenom kvůli svým technickým vlastnostem, ale i díky tomu,
že pochází z &bdquo;dílny&ldquo; Google a taktéž proto, že za jeho designem
stojí mj.&nbsp;i dvě slavné osobnosti z&nbsp;oblasti IT: Rob
&bdquo;Commander&ldquo; Pike a Ken Thompson. Poněkud zvláštní je fakt, že jazyk
vytvořený v&nbsp;Googlu má jméno, které není unikátní a tak se špatně hledá
&ndash; většinou je nutné kombinovat &bdquo;go&ldquo; a
&bdquo;golang&ldquo;.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Go není &bdquo;pouze&ldquo; vylepšený programovací jazyk C</h2>

<p>Víme již, že mezi autory návrhu i první implementace programovacího jazyka
Go patří mj.&nbsp;i Ken Thompson. Když si uvědomíme, že Ken vytvořil i (dnes
prehistorický) <a
href="https://www.root.cz/clanky/vznik-unixu-a-jazyka-b-na-pocitacich-pdp/">programovací
jazyk B</a>, který je předchůdcem slavného jazyka C, mohlo by se zdát, že Go
bude pouhým vylepšením programovacího jazyka C. Je sice pravda, že Go alespoň
částečně z&nbsp;jazyka C vychází, ovšem z&nbsp;hlediska syntaxe jsou si mnohem
bližší například jazyky C a Java, než C a Go. Tvůrci programovacího jazyka Go
se navíc snažili poučit se z&nbsp;některých problematických rysů jazyků C a
taktéž C++ a navrhli Go takovým způsobem, aby byla jeho syntaxe jednodušší a
snáze pochopitelná (sami se po prohlédnutí zdrojových kódů můžete rozhodnout,
do jaké míry se to splnilo). Samotný jazyk je velmi konzervativní a někteří
kritici dokonce (s&nbsp;nadsázkou) tvrdí, že zcela ignoruje všechny novinky,
které se na poli programovacích jazyků za posledních dvacet let objevily.</p>

<p>Navíc se tvůrci jazyka Go zaměřili i na další typické problémy, s&nbsp;nimiž
se musí vypořádat prakticky všichni programátoři používající jazyky C, C++ a
vlastně i uživatelé Rustu (ti nepřímo): jedná se o problematiku správy paměti a
uvolňování zdrojů (<i>resources</i>) a v&nbsp;neposlední řadě i o podporu pro
paralelní běh částí programů, například částí komunikujících přes síť,
pracujících se souborovým systémem atd. Z&nbsp;tohoto důvodu byly přímo do
jazyka Go přidány dvě technologie: automatický správce paměti a takzvané
<i>gorutiny</i> (<i>goroutines</i>). S&nbsp;oběma těmito technologiemi se
seznámíme v&nbsp;navazujících částech tohoto seriálu. Některé technologie
naopak do Go přidány <strong>nebyly</strong> (<a
href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">slova
autorů o filozofii jazyka</a>), a to z&nbsp;toho důvodu, aby byl jazyk snadno
použitelný a snadno implementovatelný. Právě fakt, že se v&nbsp;Go
<i>zpočátku</i> neobjevily dnes již široce akceptované technologie, jako je
obsluha výjimek či práce s&nbsp;generickými datovými typy, byl kritizován;
ovšem Go se postupně mění a přidávají se do něj další vlastnosti (ovšem poměrně
konzervativním způsobem, což je podle mého názoru v&nbsp;této oblasti jen
dobře). Viz též <a
href="https://golang.org/doc/faq#Why_doesnt_Go_have_feature_X">https://golang.org/doc/faq#Why_doesnt_Go_have_feature_X</a>.</p>

<p><div class="rs-tip-major">Poznámka: na tomto místě je vhodné si uvědomit, že
použití automatického správce paměti přenáší část problémů (které by jinak
musel řešit programátor) do runtime, což se může negativně projevit na výkonu
aplikace (zpomalení aplikace, větší nároky na kapacitu haldy, musí se počítat i
s&nbsp;okamžiky, kdy je aplikace pozastavena apod.). Vlivem správce paměti na
výkon se budeme zabývat v&nbsp;samostatném článku, takže zde jen bez dalších
důkazů uveďme, že automatický správce paměti implementovaný v&nbsp;jazyku Go
nemá větší negativní vliv na dobu startu aplikací (ostatně, nemusí se například
spouštět ani virtuální stroj ani inicializovat interpret), spotřeba paměti je
však průměrně větší, než v&nbsp;případě C/C++, ale na druhou stranu menší, než
je tomu u Javy [<a
href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/go-gcc.html">1</a>]
[<a
href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/go.html">2</a>].</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Popularita programovacího jazyka Go mezi vývojáři</h2>

<p>Programovací jazyk Go a jeho základní knihovny byly původně navrženy takovým
způsobem, aby se v&nbsp;tomto jazyku daly efektivně psát různé síťové aplikace,
které by navíc netrpěly na potenciální problémy typu &bdquo;buffer
overflow&ldquo; atd. Právě z&nbsp;toho důvodu, že síťové a serverové aplikace
musí v&nbsp;typické konfiguraci obsluhovat velké množství paralelně běžících
požadavků, byly do jazyka Go přidány již výše zmíněné <i>gorutiny</i>. A nutno
říci, že Go se v&nbsp;této oblasti skutečně používá. Taktéž se předpokládalo,
že se Go bude používat pro vývoj těch aplikací, které jsou nyní psány v&nbsp;C
či C++. Tento přechod sice skutečně nastal, ovšem prozatím ne v&nbsp;příliš
velké míře (a to se bavíme o použití v&nbsp;serverových a desktopových
aplikacích, protože v&nbsp;oblasti mikrořadičů se s&nbsp;Go sice laboruje, ale
především u relativně výkonných MCU typicky založených na čipech <a
href="https://www.root.cz/clanky/architektura-mikroradicu-s-jadry-arm-cortex-m4/">Cortex-M</a>,
nikoli na malých osmibitových a šestnáctibitových mikrořadičích).</p>

<p>Nastala ovšem zajímavější situace, o níž jsme se krátce zmínili v&nbsp;úvodu
&ndash; programovací jazyk Go a jeho možnosti objevili programátoři, kteří
psali své síťové a speciálně pak webové aplikace v&nbsp;Pythonu, Ruby či
Java/TypeScriptu. Přepis do jazyka Go mnohdy znamenal řádový a někdy i
dvouřádový (100&times;) nárůst výkonu těchto aplikací. Do jisté míry je nárůst
výkonu způsobem překladem do nativního kódu, ovšem nesmíme zapomenout na
gorutiny, které nejsou (na rozdíl od klasických vláken) příliš náročné na
paměť, takže se můžeme setkat s&nbsp;aplikacemi, v&nbsp;nichž bez větších
problémů běží stovky či dokonce tisíce gorutin.</p>

<p><div class="rs-tip-major">Poznámka: pokud si chcete vyzkoušet provozovat Go
na mikrořadičích Cortex-M, můžete využít projekt <a
href="https://github.com/ziutek/emgo">Emgo</a></div> Další MCU ovšem nejsou
prozatím podporovány. Dalším zajímavým projektem je <a
href="https://github.com/golang/mobile">Go on Mobile</a>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instalace základních nástrojů pro jazyk Go do Fedory</h2>

<p>Popišme si nyní instalaci základních nástrojů programovacího jazyka Go do
distribuce Fedora. Instalace bude na všech třech posledních vydáních Fedory
prakticky totožná, takže se zaměřme na Fedoru 29, pro niž byl vytvořen balíček
s&nbsp;Go verze 1.11 (což je v&nbsp;současnosti nejnovější stabilní verze
tohoto jazyka). Instalaci provedeme buď přímo z&nbsp;terminálu
s&nbsp;přihlášeným superuživatelem (rootem):</p>

<pre>
# <strong>dnf install golang</strong>
</pre>

<p>Alternativně samozřejmě můžeme použít instalaci s&nbsp;využitím nástroje
<strong>sudo</strong>, pokud má ovšem přihlášený uživatel příslušná práva:</p>

<pre>
$ <strong>sudo dnf install golang</strong>
</pre>

<p>V&nbsp;obou případech by měla instalace proběhnout prakticky totožným
způsobem:</p>

<pre>
Last metadata expiration check: 3:00:43 ago on Thu Nov 15 01:24:13 2018.
Dependencies resolved.
================================================================================
 Package                 Arch   Version          Repository                Size
================================================================================
Installing:
 golang                  x86_64 1.11.2-1.fc29    updates                  625 k
Installing dependencies:
 golang-bin              x86_64 1.11.2-1.fc29    updates                   90 M
 golang-src              noarch 1.11.2-1.fc29    updates                  6.4 M
...
...
...
Transaction Summary
================================================================================
Install  35 Packages
&nbsp;
Total download size: 163 M
Installed size: 541 M
Is this ok [y/N]:
</pre>

<p>Povšimněte si, že se po nainstalování rozbalí přibližně 514 MB dat, což by
pro základní sadu nástrojů byla poměrně vysoká hodnota, ovšem Fedora 29, na níž
si práci s&nbsp;jazykem Go ukazujeme, byla nainstalována s&nbsp;minimální sadou
balíčků a tudíž neobsahovala ani základní vývojové nástroje (Go například
vyžaduje Git atd.). Samotné Go se všemi svými nástroji vyžaduje necelých 200
MB diskového prostoru, přičemž <a href="https://golang.org/dl/">tarball má
zhruba poloviční velikost</a>.</p>

<p>Po odpovědi &bdquo;Y&ldquo; se instalace rozběhne a pochopitelně se nijak
zásadně neliší od instalace jakéhokoli jiného balíčku:</p>

<pre>
Downloading Packages:
(1/35): apr-util-bdb-1.6.1-8.fc29.x86_64.rpm                        75 kB/s |  12 kB     00:00
(2/35): apr-util-1.6.1-8.fc29.x86_64.rpm                           543 kB/s |  90 kB     00:00
(3/35): apr-util-openssl-1.6.1-8.fc29.x86_64.rpm                   3.9 MB/s |  14 kB     00:00
...
(10/35): go-srpm-macros-2-18.fc29.noarch.rpm                       442 kB/s |  11 kB     00:00
...
(24/35): golang-1.11.2-1.fc29.x86_64.rpm                           401 kB/s | 625 kB     00:01
(35/35): golang-bin-1.11.2-1.fc29.x86_64.rpm                       653 kB/s |  90 MB     02:21
---------------------------------------------------------------------------------------------------
Total                                                              1.1 MB/s | 163 MB     02:29
...
...
...
Complete!
</pre>

<p>Pro jistotu se ještě přesvědčíme, že jsou k&nbsp;dispozici příkazy
<strong>go</strong> a <strong>gofmt</strong>:</p>

<pre>
$ <strong>whereis -b go</strong>
go: /usr/bin/go
&nbsp;
$ <strong>whereis -b gofmt</strong>
go: /usr/bin/gofmt
</pre>

<p><div class="rs-tip-major">Poznámka<sup>1</sup>: v&nbsp;této kapitole jsme si
ukázali instalaci jazyka Go ve verzi 1.11. Ve skutečnosti budou všechny
demonstrační příklady pracovat i ve starší verzi 1.9 a 1.10, protože například
mezi verzí 1.10 a 1.11 nebyly do samotného jazyka přidány žádné nové vlastnosti
a neproběhly ani změny stávajících vlastností.</div></p>

<p><div class="rs-tip-major">Poznámka<sup>2</sup>: alternativně si můžeme
vyzkoušet instalaci Go přímo ze zdrojových kódů. Pro bootstraping však budete
stejně potřebovat funkční překladač Go nebo gccgo (GCC s&nbsp;frontendem pro
Go). Viz podrobnější informace, které naleznete na stránce <a
href="https://golang.org/doc/install/source">https://golang.org/doc/install/source</a>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Nastavení proměnné prostředí <strong>GOPATH</strong></h2>

<p>Po instalaci je vhodné nastavit proměnnou prostředí (<i>environment
variable</i>) nazvanou <strong>GOPATH</strong>. Tato proměnná bude použita pro
určení cíle překladu, pro hledání zdrojových kódů modulů atd. Dnes ji sice
ještě nebudeme nutně potřebovat, ale je vhodné si tuto proměnnou připravit pro
další části tohoto seriálu, kde již budeme pracovat s&nbsp;větším množstvím
projektů a knihoven. Proměnná bude nastavována při startu BASHe, takže pokud
používáte jiný shell, budete si muset upravit následující příkazy:</p>

<pre>
$ <strong>mkdir -p $HOME/go</strong>
$ <strong>echo 'export GOPATH=$HOME/go' &gt;&gt; $HOME/.bashrc</strong>
$ <strong>source $HOME/.bashrc</strong>
</pre>

<p>Nyní by již měla být proměnná nastavena, o čemž se můžeme snadno přesvědčit
(shell není zapotřebí spouštět znovu, protože jsme použili příkaz
<strong>source</strong>):</p>

<pre>
$ <strong>echo $GOPATH</strong>
&nbsp;
/home/tester/go
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Základní kontrola instalace</h2>

<p>Po instalaci základních nástrojů programovacího jazyka Go můžeme odzkoušet,
zda jsou tyto nástroje skutečně použitelné. Většina funkcí je dostupná přes
&bdquo;univerzální&ldquo; příkaz <strong>go</strong>, takže si pro začátek
vypíšeme, která verze jazyka je vlastně aktuálně dostupná. K&nbsp;tomu slouží
tato varianta příkazu:</p>

<pre>
$ <strong>go version</strong>
</pre>

<p>V&nbsp;našem případě by se měla vypsat verze 1.11.2:</p>

<pre>
go version go1.11.2 linux/amd64
</pre>

<p>Při instalaci starší verze (například na Fedoru 27) se samozřejmě vypíše
odlišná verze jazyka:</p>

<pre>
go version go1.9.7 linux/amd64
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;současnosti jsou v&nbsp;praxi
používány verze 1.8 (skutečně!), 1.9, 1.10 a 1.11. Novinky, opravy a případné
známé chyby jsou shrnuty v&nbsp;dokumentech Release Notes, které naleznete na
adresách <a
href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>, <a
href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>, <a
href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a> a
samozřejmě též <a
href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.10">https://golang.org/doc/go1.10">https://golang.org/doc/go1.11</a>.</div></p>

<p>Vraťme se však k&nbsp;popisu základních nástrojů, které mají vývojáři
k&nbsp;dispozici. Po spuštění samotného nástroje <strong>go</strong> bez
dalších parametrů by se měly vypsat všechny dostupné příkazy:</p>

<pre>
$ <strong>go</strong>
</pre>

<p>Výstup zobrazený na terminálu/konzoli by měl u verze 1.11 vypadat přibližně
následovně:</p>

<pre>
Go is a tool for managing Go source code.
&nbsp;
Usage:
&nbsp;
        go <command> [arguments]
&nbsp;
The commands are:
&nbsp;
        bug         start a bug report
        build       compile packages and dependencies
        clean       remove object files and cached files
        doc         show documentation for package or symbol
        env         print Go environment information
        fix         update packages to use new APIs
        fmt         gofmt (reformat) package sources
        generate    generate Go files by processing source
        get         download and install packages and dependencies
        install     compile and install packages and dependencies
        list        list packages or modules
        mod         module maintenance
        run         compile and run Go program
        test        test packages
        tool        run specified go tool
        version     print Go version
        vet         report likely mistakes in packages
&nbsp;
Use "go help &lt;command&gt;" for more information about a command.
&nbsp;
Additional help topics:
&nbsp;
        buildmode   build modes
        c           calling between Go and C
        cache       build and test caching
        environment environment variables
        filetype    file types
        go.mod      the go.mod file
        gopath      GOPATH environment variable
        gopath-get  legacy GOPATH go get
        goproxy     module proxy protocol
        importpath  import path syntax
        modules     modules, module versions, and more
        module-get  module-aware go get
        packages    package lists and patterns
        testflag    testing flags
        testfunc    testing functions
&nbsp;
Use "go help &lt;topic&gt;" for more information about that topic.
</pre>

<p>Poslední základní kontrola, kterou dnes provedeme, se týká nastavení
proměnné prostředí <strong>GOPATH</strong>, o níž jsme se zmínili výše.
Zobrazení aktuálně nastavené hodnoty této proměnné prostředí tak, jak ji vidí
nástroje Go, zajistí příkaz:</p>

<pre>
$ <strong>go env GOPATH</strong>
</pre>

<p>Pro uživatele &bdquo;tester&ldquo; dostaneme tento výstup:</p>

<pre>
/home/tester/go
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. První demonstrační příklad &ndash; klasický &bdquo;Hello world!&ldquo; ve dvou variantách</h2>

<p><div class="rs-tip-major">Důležitá poznámka: ve zdrojových kódech pro Go je
zvykem pro odsazení používat znaky <strong>Tab</strong> (tabulační zarážky).
Ovšem vzhledem k&nbsp;omezením redakčního systému serveru Root
(resp.&nbsp;celého Internet Infa) nemusí být tyto znaky ve výpisech zdrojových
kódů zachovány. Z&nbsp;tohoto důvodu je vhodné buď zdrojové kódy po jejich
zkopírování z&nbsp;dnešního článku &bdquo;prohnat&ldquo; nástrojem
<strong>gofmt</strong> popsaným <a href="#k10">v&nbsp;desáté kapitole</a> nebo
&ndash; což je vhodnější &ndash; si naklonovat Git repositář se všemi
demonstračními příklady a jejich případnými opravami. Více informací o tomto
repositáři zjistíte <a href="#k19">v&nbsp;devatenácté kaptiole</a>.</div></p>

<p>Konečně se dostáváme k&nbsp;popisu samotné syntaxe a sémantiky
programovacího jazyka Go. Již tradičně začínají podobně koncipované články a
knihy programem, který po svém spuštění vypíše na terminál řetězec &bdquo;Hello
world!&ldquo; a následně se ukončí. V&nbsp;Go je možné tento příklad napsat
následujícím způsobem (úplný a naformátovaný zdrojový kód získáte z&nbsp;adresy
<a
href="https://github.com/tisnik/go-root/blob/master/article_01/01_hello_world.go">https://github.com/tisnik/go-root/blob/master/article_01/01_hello_world.go</a>):</p>

<pre>
package main
&nbsp;
func main() {
        println("Hello world!")
}
</pre>

<p>Povšimněte si, že v&nbsp;programu explicitně specifikujeme jméno balíčku
(zde &bdquo;main&ldquo;). Dále se ve zdrojovém kódu programu s&nbsp;využitím
klíčového slova <strong>func</strong> deklaruje funkce nazvaná taktéž
&bdquo;main&ldquo;. Tato funkce, která je současně vstupním bodem do aplikace,
nemá žádné parametry ani návratovou hodnotu (více se o návratových hodnotách
dozvíme v&nbsp;navazujících kapitolách) a voláme z&nbsp;ní funkci nazvanou
<strong>println()</strong>. Jedná se o funkci dostupnou ze základní knihovny,
jejíž možnosti jsou sice dosti zásadním způsobem omezeny, ovšem pro programy
typu &bdquo;Hello world!&ldquo; mohou být dostačující. A na závěr &ndash; za
příkazem volání funkce není nutné psát středník (ve skutečnosti bude středník
při přeformátování zdrojového kódu odstraněn).</p>

<p>První příklad si můžeme spustit a to konkrétně příkazem <strong>go
run</strong>. Před samotným spuštěním se sice (potichu) provede překlad,
přičemž spustitelná verze programu je uložena do dočasného souboru:</p>

<pre>
$ <strong>go run 01_hello_world.go</strong>
Hello world!
</pre>

<p>Pokud si budeme přát program explicitně přeložit a zachovat výsledný binární
soubor, použijeme namísto <strong>go run</strong> příkaz <strong>go
build</strong>:</p>

<pre>
$ <strong>go build 01_hello_world.go</strong>
</pre>

<p>Výsledkem bude soubor pojmenovaný stejně jako soubor zdrojový, ovšem bez
koncovky &bdquo;.go&ldquo; (na Unixových systémech):</p>

<pre>
$ <strong>ls -l</strong>

total 1072
-rwxrwxr-x. 1 tester tester 1067905 Nov  8 12:45 01_hello_world
-rw-rw-r--. 1 tester tester      55 Nov  7 09:02 01_hello_world.go
</pre>

<p>Nově vytvořený soubor nazvaný &bdquo;01_hello_world&ldquo; obsahuje jak
přeložený nativní kód naší aplikace, tak i všechny potřebné funkce nutné pro
spuštění aplikace (včetně automatického správce paměti). Právě kvůli tomu, že
se v&nbsp;tomto binárním souboru nachází i všechny potřebné runtime funkce, je
soubor tak velký (cca 1,1MB, oproti tomu aplikace se stejnou funkcí
naprogramovaná v&nbsp;C bude mít po překladu velikost 6 až 14 kB
v&nbsp;závislosti na architektuře, <a
href="https://github.com/tisnik/presentations/blob/master/assembler/03_gas_hello_world/hello_world.s">v&nbsp;assembleru
se na platformě x86-64</a> dostaneme na 504 bajtů).</p>

<p>Právě přeloženou aplikaci si můžeme velmi snadno spustit následujícím
příkazem:</p>

<pre>
$ <strong>./01_hello_world</strong>
Hello world!
</pre>

<p>Pokud budete chtít prozkoumat, jaké symboly se vlastně v&nbsp;souboru
&bdquo;01_hello_world&ldquo; nachází (je jich zhruba 1300!, protože je zde
skutečně celý runtime), můžeme použít příkaz <strong>objdump</strong>:</p>

<pre>
$ <strong>objdump -t 01_hello_world</strong>
</pre>

<p>Ve druhém příkladu, který naleznete na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_01/02_better_hello_world.go">https://github.com/tisnik/go-root/blob/master/article_01/02_better_hello_world.go</a>,
používáme namísto dosti primitivní funkce <strong>println</strong>
univerzálnější funkci <strong>Println</strong>. Tato funkce se nachází
v&nbsp;balíčku <strong>fmt</strong>, který je nutné explicitně naimportovat a
funkci plně kvalifikovat:</p>

<pre>
package main
&nbsp;
<strong>import "fmt"</strong>
&nbsp;
func main() {
        <strong>fmt.Println</strong>("Hello world!")
}
</pre>

<p>Opět si ukažme způsob tichého překladu a spuštění tohoto příkladu:</p>

<pre>
$ <strong>go run 02_better_hello_world.go </strong>
Hello world!
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Jak pracovat s&nbsp;dokumentací</h2>

<p>Dokumentace k&nbsp;jazyku Go i ke standardním knihovnám je umístěna na
adrese <a href="https://godoc.org/">https://godoc.org/</a>. V&nbsp;předchozích
příkladech jsme používali balíček &bdquo;fmt&ldquo;, který je součástí
standardní knihovny jazyka Go a je samozřejmě taktéž na výše zmíněných
stránkách popsán: <a
href="https://godoc.org/fmt">https://godoc.org/fmt</a>.</p>

<p>Kromě toho je však možné si nechat dokumentaci zobrazit přímo
v&nbsp;terminálu při vývoji. K&nbsp;tomu slouží příkaz <strong>go doc</strong>,
kterému se jako další parametr předá jméno balíčku popř.&nbsp;přímo jméno
funkce, jejíž popis potřebujeme získat:</p>

<pre>
$ <strong>go doc builtin</strong>
</pre>

<p>Výsledek bude na terminálu zobrazen následujícím způsobem:</p>

<pre>
package builtin // import "builtin"
&nbsp;
Package builtin provides documentation for Go's predeclared identifiers. The
items documented here are not actually in package builtin but their
descriptions here allow godoc to present documentation for the language's
special identifiers.
...
...
...
func print(args ...Type)
func println(args ...Type)
</pre>

<p>Samozřejmě je možné použít utility pro stránkování &ndash;
<strong>less</strong>, <strong>more</strong> atd.:</p>

<pre>
$ <strong>go doc fmt | less</strong>
</pre>

<p>S&nbsp;výstupem:</p>

<pre>
package fmt // import "fmt"
&nbsp;
Package fmt implements formatted I/O with functions analogous to C's printf
and scanf. The format 'verbs' are derived from C's but are simpler.
&nbsp;
&nbsp;
Printing
&nbsp;
The verbs:
&nbsp;
General:
&nbsp;
    %v  the value in a default format
        when printing structs, the plus flag (%+v) adds field names
    %#v a Go-syntax representation of the value
    %T  a Go-syntax representation of the type of the value
    %%  a literal percent sign; consumes no value
</pre>

<p>Pokud je zapotřebí zobrazit dokumentaci k&nbsp;funkci z&nbsp;nějakého
balíčku, použije se následující styl zápisu:</p>

<pre>
$ <strong>go doc fmt.Println</strong>
</pre>

<p>S&nbsp;výstupem:</p>

<pre>
func Println(a ...interface{}) (n int, err error)
    Println formats using the default formats for its operands and writes to
    standard output. Spaces are always added between operands and a newline is
    appended. It returns the number of bytes written and any write error
    encountered.
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Doporučovaný styl zápisu programů</h2>

<p>Tvůrci programovacího jazyka Go navrhli, jakým způsobem se mají formátovat
zdrojové kódy. Nezůstalo ovšem pouze u doporučení, protože přímo
v&nbsp;základní sadě nástrojů jazyka Go nalezneme i utilitku nazvanou příznačně
<strong>gofmt</strong>. Tento nástroj slouží k&nbsp;přeformátování zdrojových
kódů takovým způsobem, aby jejich výsledný tvar odpovídal specifikaci. Díky
tomu mají (nebo by alespoň měly mít) všechny zdrojové kódy napsané v&nbsp;Go
jednotný standardní formát a například diskuze o použití tabů nebo mezer,
popř.&nbsp;o kolik znaků se má provést odsazení bloků, přestávají mít smysl (o
to jsou ale <a
href="https://www.youtube.com/watch?v=SsoOG6ZeyUI">zábavnější</a>).

<p><div class="rs-tip-major">Ve zkratce autoři Go vlastně říkají: namísto
dlouhých popisů standardů formátování zdrojových kódů, které známe například
z&nbsp;<a href="https://www.python.org/dev/peps/pep-0008/">PEP-8</a>, <a
href="https://www.gnu.org/prep/standards/standards.html">GNU Coding
Standards</a> či <a
href="https://www.kernel.org/doc/html/v4.10/process/coding-style.html">Linux
kernel coding style</a> se v&nbsp;Go formátováním programátoři příliš zabývat
nemusí, protože za ně většinu práce odvede nástroj <strong>gofmt</strong>,
který má navíc (z&nbsp;definice) vždycky pravdu :-)</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Nástroj <strong>gofmt</strong> určený pro přeformátování zdrojových kódů</h2>

<p>Pokud jste provedli instalaci Go a jeho nástrojů podle pokynů <a
href="#k04">ze čtvrté kapitoly</a>, bude nástroj <strong>gofmt</strong>
jednoduše použitelný:</p>

<pre>
$ <strong>gofmt --help</strong>
</pre>

<p>Tento nástroj podporuje různé volby, ovšem v&nbsp;praxi využijete
pravděpodobně především volbu <strong>-w</strong> pro zápis přeformátovaného
zdrojového kódu do jiného souboru:</p>

<pre>
usage: gofmt [flags] [path ...]
  -cpuprofile string
        write cpu profile to this file
  -d    display diffs instead of rewriting files
  -e    report all errors (not just the first 10 on different lines)
  -l    list files whose formatting differs from gofmt's
  -r string
        rewrite rule (e.g., 'a[b:len(a)] -&gt; a[b:]')
  -s    simplify code
  -w    write result to (source) file instead of stdout
</pre>

<p>Zkusme například formátovači předat následující zdrojový kód se středníky,
špatným odsazením, prázdnými řádky atd.:</p>

<pre>
package main
&nbsp;
&nbsp;
&nbsp;
&nbsp;
import "fmt";
func main() {
  fmt.Println("Hello, playground");
}
</pre>

<p>Po naformátování získáme tento obsah, který plně odpovídá specifikaci:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
	fmt.Println("Hello, playground")
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Kontrola použití importovaných modulů</h2>

<p>Ve třetím příkladu, jehož zdrojový kód naleznete na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_01/03_unused_imports.go">https://github.com/tisnik/go-root/blob/master/article_01/03_unused_imports.go</a>,
je předchozí zdrojový kód upraven takovým způsobem, že namísto funkce
<strong>fmt.Println</strong> opět použijeme standardní funkci
<strong>println</strong>, ovšem ponecháme deklaraci importu
&bdquo;fmt&ldquo;:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        println("Hello world!")
}
</pre>

<p>Z&nbsp;pohledu překladače programovacího jazyka Go se jedná o potenciální
chybu, na kterou taktéž standardním způsobem upozorní:</p>

<pre>
$ <strong>go run 03_unused_imports.go</strong>
&nbsp;
# command-line-arguments
./03_unused_imports.go:3:8: imported and not used: "fmt"
</pre>

<p><div class="rs-tip-major">Poznámka: navíc ještě překladač hlídá, zda
nedochází k&nbsp;cyklickým importům. Podrobnosti si uvedeme příště.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Plná podpora Unicode v&nbsp;programech</h2>

<p>Další vlastnost programovacího jazyka Go by nás neměla překvapit. Jedná se o
plnohodnotnou podporu Unicode a taktéž kódování UTF-8. Proč není tato vlastnost
překvapivá? <a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">Za
vznikem UTF-8</a> totiž stojí právě Rob Pike a Ken Thompson, shodou okolností
dva ze tří návrhářů programovacího jazyka Go. Ukažme si, že se UTF-8 může
používat přímo <a
href="https://github.com/tisnik/go-root/blob/master/article_01/04_hello_unicode.go">ve
zdrojovém kódu</a> čtvrtého demonstračního příkladu:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        fmt.Println("╭─────────────────────╮")
        fmt.Println("│ příλiš žλuťΩučký kůň│")
        fmt.Println("╰─────────────────────╯")
}

</pre>

<p>Tento program půjde bez problémů přeložit i spustit (za předpokladu, že je
správně nastavený terminál, což by snad v&nbsp;21.století nemusel být
problém):</p>

<pre>
$ <strong>go run 04_hello_unicode.go </strong>
&nbsp;
╭─────────────────────╮
│ příλiš žλuťΩučký kůň│
╰─────────────────────╯
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je přímo definováno, že
zdrojové kódy Go jsou reprezentovány v&nbsp;UTF-8 (ASCII je podmnožinou UTF-8).
Nevznikají zde tedy tak problematické situace, jako například v&nbsp;Javě, kdy
je možné zdrojový kód reprezentovat v&nbsp;různých kódováních a formátech.
Můžeme zde opět vidět stejný pragmatismus, jaký jsme již zažili u formátování
zdrojových kódů.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Základy typového systému &ndash; odvození typu proměnné z&nbsp;hodnoty</h2>

<p>Podobně jako v&nbsp;mnoha dalších kompilovaných programovacích jazycích
nalezneme i v&nbsp;jazyce Go velké množství základních datových typů, které do
určité míry odráží vlastnosti mikroprocesorů, na kterých budou aplikace
provozovány (předpokládají se dnes převažující architektury
s&nbsp;osmibitovými, 16bitovými, 32bitovými a 64bitovými slovy, ne některé
speciální DSP atd.). Kromě numerických typů patří mezi základní datové typy i
řetězce (ty jsou neměnitelné &ndash; <i>immutable</i>), pole (<i>array</i>),
takzvané řezy (<i>slice</i>) a mapy (<i>map</i>). V&nbsp;Go nalezneme i
ukazatele, ovšem jejich význam je oproti C či C++ do značné míry omezen. Nové
datové typy jsou samozřejmě uživatelsky definovatelné, což je téma, kterému se
budeme podrobněji věnovat příště.</p>

<p>Zajímavé a velmi užitečné je, že Go dokáže odvodit typ proměnné
z&nbsp;hodnoty, která je proměnné přiřazena <i>při její deklaraci</i>. Pro
přiřazení se v&nbsp;takovém případě používá operátor <strong>:=</strong>
(<i>short variable declaration</i>) a u proměnné se nemusí deklarovat její typ
(<a
href="https://github.com/tisnik/go-root/blob/master/article_01/05_basic_type_inference.go">úplný
zdrojový kód</a>):</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        <strong>a := 10</strong>
        fmt.Println(a)
        <strong>b := "hello"</strong>
        fmt.Println(b)
        <strong>c := true</strong>
        fmt.Println(c)
}
</pre>

<p>Výsledek po spuštění programu:</p>

<pre>
$ <strong>go run 05_basic_type_inference.go</strong>
&nbsp;
10
hello
true
</pre>

<p><div class="rs-tip-major">Poznámka: Go používá silný a především statický
typový systém, v&nbsp;němž odvození typu proměnné na základě přiřazované
hodnoty je jen syntaktický cukr, nikoli snaha o vytvoření dynamického
typování.</div></p>

<p>Jakmile je proměnná deklarována, není ji možné v&nbsp;daném bloku deklarovat
znovu, tudíž ani není možné použít znovu přiřazení zapisované operátorem :=.
Můžeme si to snadno otestovat <a
href="https://github.com/tisnik/go-root/blob/master/article_01/06_variable_redeclaration.go">na
dalším příkladu</a>:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        a := 10
        fmt.Println(a)
        b := "hello"
        fmt.Println(b)
        c := true
        fmt.Println(c)
&nbsp;
        <strong>a := "world"</strong>
        fmt.Println(a)
        <strong>b := 0</strong>
        fmt.Println(b)
        <strong>c := nil</strong>
        fmt.Println(c)
}
</pre>

<p>V&nbsp;tomto případě dojde k&nbsp;chybě při překladu:</p>

<pre>
$ <strong>go run 06_variable_redeclaration.go</strong>
&nbsp;
# command-line-arguments
./06_variable_redeclaration.go:13:4: no new variables on left side of :=
./06_variable_redeclaration.go:15:4: no new variables on left side of :=
./06_variable_redeclaration.go:17:4: no new variables on left side of :=
</pre>

<p>Pokud ovšem namísto operátoru := použijeme běžné přiřazení, bude zdrojový
kód <a
href="https://github.com/tisnik/go-root/blob/master/article_01/07_variable_reassign.go">bez
problému přeložitelný</a> (a bude samozřejmě korektní i po stránce
sémantiky):</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        <strong>a := 10</strong>
        fmt.Println(a)
        <strong>b := "hello"</strong>
        fmt.Println(b)
        <strong>c := true</strong>
        fmt.Println(c)
&nbsp;
        <strong>a = 20</strong>
        fmt.Println(a)
        <strong>b = "world"</strong>
        fmt.Println(b)
        <strong>c = false</strong>
        fmt.Println(c)
}
</pre>

<p>Výsledek po překladu a spuštění:</p>

<pre>
$ <strong>go run 07_variable_reassign.go </strong>
&nbsp;
10
hello
true
20
world
false
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Kontrola typu hodnoty přiřazované do proměnné</h2>

<p>Díky silnému typovému systému je pochopitelně odhalena snaha o přiřazení
hodnoty jiného typu do již deklarované proměnné, což si ověříme <a
href="https://github.com/tisnik/go-root/blob/master/article_01/08_no_true_dynamic_type.go">na
dalším příkladu</a>:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        <strong>a := 10</strong>
        fmt.Println(a)
        <strong>b := "hello"</strong>
        fmt.Println(b)
        <strong>c := true</strong>
        fmt.Println(c)
&nbsp;
        <strong>a = "world"</strong>
        fmt.Println(a)
        <strong>b = 0</strong>
        fmt.Println(b)
        <strong>c = nil</strong>
        fmt.Println(c)
}
</pre>

<p>Výsledek snahy o překlad:</p>

<pre>
$ <strong>go run 08_no_true_dynamic_type.go </strong>
&nbsp;
# command-line-arguments
./08_no_true_dynamic_type.go:13:6: cannot use "world" (type string) as type int in assignment
./08_no_true_dynamic_type.go:15:4: cannot use 0 (type int) as type string in assignment
./08_no_true_dynamic_type.go:17:4: cannot use nil as type bool in assignment
</pre>

<p>Tento příklad byl sice velmi jednoduchý, ale podobně bude typová kontrola
fungovat i při použití uživatelských typů, polí, řezů atd.</p>

<p><div class="rs-tip-major">Poznámka: možná jste si všimli přiřazení řetězce
(řetězcového literálu) do proměnné. Z&nbsp;pohledu programátora se
s&nbsp;řetězci pracuje stejně, jako s&nbsp;dalšími hodnotami nějakého
primitivního typu (celé číslo, znak, číslo s&nbsp;plovoucí řádovou čárkou).
Interně je samozřejmě nutné provést alokaci na haldě, to je pro nás ovšem
většinou zcela skryto.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Deklarace funkcí</h2>

<p>S&nbsp;deklarací funkce jsme se již setkali (jednalo se o funkci
<strong>main</strong>), takže si jen krátce ukážeme, jak je možné nadeklarovat
další funkci bez parametrů a bez návratové hodnoty. Testovaná funkce se bude
jmenovat <strong>printHello</strong>. Vzhledem k&nbsp;tomu, že funkce
neakceptuje žádné parametry, uvedou se za jejím názvem pouze prázdné kulaté
závorky a za nimi již začíná tělo funkce uvozené levou složenou závorkou. Při
volání funkce bez parametrů se opět použijí prázdné kulaté závorky:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func <strong>printHello</strong>() {
        fmt.Println("Hello world!")
}
&nbsp;
func main() {
        <strong>printHello()</strong>
}
</pre>

<p>Tato funkce je volána z&nbsp;funkce <strong>main</strong>, pochopitelně bez
parametrů:</p>

<pre>
$ <strong>go run 09_simple_function.go </strong>
&nbsp;
Hello world!
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Specifikace typu argumentů funkcí</h2>

<p>Ukažme si nyní, jak se specifikuje typ parametru či parametrů funkce. Na
rozdíl od jazyků C, C++ či Java se pro specifikaci parametrů používá zápis
&bdquo;jméno parametru [mezera] datový typ&ldquo;. Volání funkce
s&nbsp;parametrem/parametry se již nijak výrazně neodlišuje od jiných
mainstreamových programovacích jazyků:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func printMessage(<strong>message string</strong>) {
        fmt.Println(message)
}
&nbsp;
func main() {
        <strong>printMessage("Hello world!")</strong>
}
</pre>

<p>Překlad a spuštění <a
href="https://github.com/tisnik/go-root/blob/master/article_01/10_function_with_params.go">tohoto
demonstračního příkladu</a>:</p>

<pre>
$ <strong>go run 10_function_with_params.go </strong>
&nbsp;
Hello world!
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Příkaz <strong>return</strong></h2>

<p>Funkce, které tvoří základní stavební prvek programů psaných v&nbsp;Go
(ostatně i metody jsou zde chápány jako funkce), samozřejmě mohou vracet
nějakou návratovou hodnotu. Její typ se uvede za pravou uzavírací kulatou
závorku se specifikací parametrů funkce. Přímo ve funkci je možné použít příkaz
<strong>return</strong>, ovšem existují i další možnosti, s&nbsp;nimiž se
seznámíme později. Podívejme se, jak může vypadat deklarace funkce bez
parametrů, která ovšem vrací hodnotu typu řetězec (<i>string</i>):</p>

<pre>
func getMessage() <strong>string</strong> {
        <strong>return</strong> "Hello world!"
}
</pre>

<p>Příklad s&nbsp;voláním takové funkce:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func getMessage() string {
        return "Hello world!"
}
&nbsp;
func printMessage(message string) {
        fmt.Println(message)
}
&nbsp;
func main() {
        printMessage(getMessage())
}
</pre>

<p>Tento demonstrační příklad po svém spuštění opět vypíše zprávu &bdquo;Hello
world!&ldquo;:</p>

<pre>
$ <strong>go run 11_return_statement.go</strong>
&nbsp;
Hello world!
</pre>

<p>Alternativně je možné pojmenovat výstupní parametr (parametry) a vlastní
určení, jaká hodnota se má vrátit, bude provedeno prostým přiřazením (což se
vzdáleně podobná způsobu, jakým pracují funkce v&nbsp;Pascalu):</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func getMessage() (<strong>message string</strong>) {
        <strong>message = </strong>"Hello world!"
        return
}
&nbsp;
func printMessage(message string) {
        fmt.Println(message)
}
&nbsp;
func main() {
        printMessage(getMessage())
}
</pre>

<p>Po příkazu <strong>return</strong> by se již neměl použít žadný další
příkaz, což je kontrolováno překladačem:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func getMessage() (message string) {
        message = "Hello world!"
        return
        <strong>x := 42</strong>
}
&nbsp;
func printMessage(message string) {
        fmt.Println(message)
}
&nbsp;
func main() {
        printMessage(getMessage())
}
</pre>

<p>Otestujme si, zda překladač skutečně ohlídá, že se za
<strong>return</strong> už žádný další příkaz nepoužije:</p>

<pre>
$ go <strong>run 16_return_at_the_end_of_function.go </strong>
&nbsp;
# command-line-arguments
./16_return_at_the_end_of_function.go:9:1: missing return at end of function
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Vrácení většího množství hodnot z&nbsp;funkce</h2>

<p>V&nbsp;programovacím jazyce Go se velmi často setkáme s&nbsp;tím, že funkce
vrací volajícímu kódu větší množství návratových hodnot. Mnoho funkcí ze
standardní knihovny například vrací vlastní požadovanou hodnotu a taktéž kód
chyby; toto chování je ovšem doporučeno používat i v&nbsp;ostatních modulech.
Podívejme se na základní příklad, v&nbsp;němž funkce <strong>swap</strong>
akceptuje dva parametry a vrací je, ovšem v&nbsp;opačném pořadí. Kód pracující
s&nbsp;oběma návratovými hodnotami je zvýrazněn:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func swap(a int, b int) <strong>(int, int)</strong> {
        return <strong>b, a</strong>
}
&nbsp;
func main() {
        x := 1
        y := 2
&nbsp;
        var z int
        var w int
&nbsp;
        <strong>z, w</strong> = swap(x, y)
        fmt.Println("z =", z)
        fmt.Println("w =", w)
}
</pre>

<p>Výsledek po překladu a spuštění <a
href="https://github.com/tisnik/go-root/blob/master/article_01/14_swap_function.go">tohoto
demonstračního příkladu</a>:</p>

<pre>
$ <strong>go run 14_swap_function.go </strong>
&nbsp;
z = 2
w = 1
</pre>

<p>Zajímavé bude propojení dvou vlastností programovacího jazyka Go:
automatického určení typu proměnné při její deklaraci na základě přiřazované
hodnoty a možnosti vrátit větší množství hodnot z&nbsp;volané funkce.
Povšimněte si zejména zvýrazněného řádku, na němž jsou deklarovány dvě lokální
proměnné <strong>z</strong> a <strong>w</strong>, je jim přiřazen typ a taktéž
přímo hodnota získaná voláním funkce <strong>swap</strong>:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func swap(a int, b int) (int, int) {
        return b, a
}
&nbsp;
func main() {
        x := 1
        y := 2
        z, w := swap(x, y)
&nbsp;
        fmt.Println("z =", z)
        fmt.Println("w =", w)
}
</pre>

<p>Opět si ukažme výsledek po překladu a spuštění <a
href="https://github.com/tisnik/go-root/blob/master/article_01/15_swap_function_B.go">upraveného
demonstračního příkladu</a>:</p>

<pre>
$ <strong>go run 15_swap_function_B.go </strong>
&nbsp;
z = 2
w = 1
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
doslova několik kilobajtů), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_hello_world.go</td><td>klasický &bdquo;Hello world!&ldquo;</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_01/01_hello_world.go">https://github.com/tisnik/go-root/blob/master/article_01/01_hello_world.go</a></td></tr>
<tr><td> 2</td><td>02_better_hello_world.go</td><td>upravená verze předchozího příkladu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_01/02_better_hello_world.go">https://github.com/tisnik/go-root/blob/master/article_01/02_better_hello_world.go</a></td></tr>
<tr><td> 3</td><td>03_unused_imports.go</td><td>chybný příklad: nepoužívaný import</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_01/03_unused_imports.go">https://github.com/tisnik/go-root/blob/master/article_01/03_unused_imports.go</a></td></tr>
<tr><td> 4</td><td>04_hello_unicode.go</td><td>použití Unicode ve zdrojovém kódu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_01/04_hello_unicode.go">https://github.com/tisnik/go-root/blob/master/article_01/04_hello_unicode.go</a></td></tr>
<tr><td> 5</td><td>05_basic_type_inference.go</td><td>deklarace proměnné s odvozením typu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_01/05_basic_type_inference.go">https://github.com/tisnik/go-root/blob/master/article_01/05_basic_type_inference.go</a></td></tr>
<tr><td> 6</td><td>06_variable_redeclaration.go</td><td>snaha o deklaraci existující proměnné</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_01/06_variable_redeclaration.go">https://github.com/tisnik/go-root/blob/master/article_01/06_variable_redeclaration.go</a></td></tr>
<tr><td> 7</td><td>07_variable_reassign.go</td><td>přiřazení hodnoty již existující proměnné</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_01/07_variable_reassign.go">https://github.com/tisnik/go-root/blob/master/article_01/07_variable_reassign.go</a></td></tr>
<tr><td> 8</td><td>08_no_true_dynamic_type.go</td><td>přiřazení hodnoty špatného typu již existující proměnné</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_01/08_no_true_dynamic_type.go">https://github.com/tisnik/go-root/blob/master/article_01/08_no_true_dynamic_type.go</a></td></tr>
<tr><td> 9</td><td>09_simple_function.go</td><td>uživatelská funkce</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_01/09_simple_function.go">https://github.com/tisnik/go-root/blob/master/article_01/09_simple_function.go</a></td></tr>
<tr><td>10</td><td>10_function_with_params.go</td><td>funkce s&nbsp;parametry</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_01/10_function_with_params.go">https://github.com/tisnik/go-root/blob/master/article_01/10_function_with_params.go</a></td></tr>
<tr><td>11</td><td>11_return_statement.go</td><td>návratová hodnota funkce</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_01/11_return_statement.go">https://github.com/tisnik/go-root/blob/master/article_01/11_return_statement.go</a></td></tr>
<tr><td>12</td><td>12_named_return_variable.go</td><td>pojmenovaná návratová hodnota</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_01/12_named_return_variable.go">https://github.com/tisnik/go-root/blob/master/article_01/12_named_return_variable.go</a></td></tr>
<tr><td>13</td><td>13_sum_function.go</td><td>parametry funkce</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_01/13_sum_function.go">https://github.com/tisnik/go-root/blob/master/article_01/13_sum_function.go</a></td></tr>
<tr><td>14</td><td>14_swap_function.go</td><td>funkce vracející dvě hodnoty</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_01/14_swap_function.go">https://github.com/tisnik/go-root/blob/master/article_01/14_swap_function.go</a></td></tr>
<tr><td>15</td><td>15_swap_function_B.go</td><td>alternativa předchozího příkladu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_01/15_swap_function_B.go">https://github.com/tisnik/go-root/blob/master/article_01/15_swap_function_B.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go <br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>
