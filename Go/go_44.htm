<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve čtyřicáté čtvrté části seriálu o programovacím jazyce Go dokončíme téma, kterému jsme se začali věnovat minule. Jedná se o popis možností knihoven nahrazujících nástroj expect původně naprogramovaný Tcl. Dnes si popíšeme knihovnu goexpect pocházejících přímo od Googlu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití Go pro automatizaci práce s&nbsp;aplikacemi s&nbsp;interaktivním příkazovým řádkem (dokončení)</a></p>
<p><a href="#k02">2. Nejdůležitější vlastnosti knihovny <strong>goexpect</strong></a></p>
<p><a href="#k03">3. Základní způsob použití knihovny <strong>goexpect</strong></a></p>
<p><a href="#k04">4. Informace vracené metodou <strong>Expect</strong></a></p>
<p><a href="#k05">5. Chování skriptu ve chvíli, kdy se na výstupu aplikace neobjeví očekávaný text</a></p>
<p><a href="#k06">6. Ovládání interaktivní hry skriptem</a></p>
<p><a href="#k07">7. Dávkové příkazy</a></p>
<p><a href="#k08">8. Zpracování výsledků činnosti metody <strong>ExpectBatch</strong></a></p>
<p><a href="#k09">9. Ovládání interpretru Pythonu pomocí dávkových příkazů</a></p>
<p><a href="#k10">10. Zjištění, která verze Pythonu je spuštěna</a></p>
<p><a href="#k11">11. Objekt <strong>Caser</strong> &ndash; rozvětvení na základě vstupu</a></p>
<p><a href="#k12">12. Složitější příklad založený na objektu <strong>Caser</strong></a></p>
<p><a href="#k13">13. Kanál obsahující stav aplikace po jejím ukončení</a></p>
<p><a href="#k14">14. Interpret ukončený s&nbsp;návratovou hodnotou odlišnou od nuly</a></p>
<p><a href="#k15">15. Využití knihovny <strong>goexpect</strong> v&nbsp;jednotkových testech</a></p>
<p><a href="#k16">16. Složitější test založený na dávkové úloze a testu návratové hodnoty testované aplikace</a></p>
<p><a href="#k17">17. Chování jednotkového testu ve chvíli, kdy je interpret ukončen s&nbsp;návratovou hodnotou odlišnou od nuly</a></p>
<p><a href="#k18">18. Obsah následující části seriálu</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití Go pro automatizaci práce s&nbsp;aplikacemi s&nbsp;interaktivním příkazovým řádkem (dokončení)</h2>

<p><a
href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/">V&nbsp;předchozí
části</a> <a href="https://www.root.cz/serialy/programovaci-jazyk-go/">seriálu
o programovacím jazyku Go</a> jsme se seznámili s&nbsp;dvojicí knihoven
určených právě pro Go. Jednalo se o knihovny nazvané <strong>go-expect</strong>
a <strong>gexpect</strong>. Jak již název těchto knihoven naznačuje, slouží pro
automatizaci práce s&nbsp;aplikacemi ovládanými interaktivně z&nbsp;příkazového
řádku (konzole); pro tento účel byl původně vyvinut nástroj <a
href="https://core.tcl-lang.org/expect/index">expect</a> naprogramovaný <a
href="https://www.root.cz/serialy/programovaci-jazyk-tcl/">v&nbsp;jazyku
Tcl</a> (ten je již mnoho let za vrcholem své popularity). Nástrojů
využívajících interaktivní dialog na příkazové řádce pochopitelně existuje celá
řada; mezi typické zástupce patří <strong>ssh</strong>, <strong>ftp</strong>,
<strong>telnet</strong>, <strong>gdb</strong>, ale i prakticky všechny
interpretry programovacích jazyků. Kromě automatizace různých procesů je možné
knihovny <strong>go-expect</strong> a <strong>gexpect</strong> použít i pro
testování aplikací, protože je možné ověřit, jak aplikace odpovídají na předem
známý vstup či naopak na vstup náhodně či spíše pseudonáhodně generovaný
(<i>fuzzy testy</i>).</p>

<p>Dnes se seznámíme se třetí a současně i poslední knihovnou spadající do
stejné kategorie, jako obě knihovny předchozí. Popíšeme si totiž základní
způsoby použití knihovny nazvané <strong>goexpect</strong>, kterou naleznete na
adrese <a
href="https://github.com/google/goexpect">https://github.com/google/goexpect</a>
a za jejímž vývojem částečně stojí přímo společnost Google (podobně jako za
vznikem a podporou samotného <a href="https://golang.org/">programovacího
jazyka Go</a>).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nejdůležitější vlastnosti knihovny <strong>goexpect</strong></h2>

<p>Ze všech tří popisovaných knihoven se právě <strong>goexpect</strong>
nejvíce přibližuje možnostem původního nástroje <a
href="https://core.tcl-lang.org/expect/index">expect</a> (který je podle mého
názoru dosti nedoceněný, za což pravděpodobně může zvolený programovací jazyk).
V&nbsp;knihovně <strong>goexpect</strong> totiž nalezneme jak základní funkce
typu &bdquo;očekávám výstup z&nbsp;aplikace&ldquo; a &bdquo;pošli text na vstup
aplikace&ldquo;, tak i například podporu pro rozvětvení na základě toho, jaké
texty aplikace vytiskla a dokonce i podporu pro dávkové příkazy (většinou
sekvenci operací pro kontrolu vypsaných textů a zápis nových příkazů). I
s&nbsp;těmito možnostmi se postupně seznámíme v&nbsp;navazujících
kapitolách.</p>

<p>Knihovnu <strong>goexpect</strong> nainstalujeme naprosto stejným způsobem,
jako jiné balíčky určené pro ekosystém programovacího jazyka Go &ndash;
použitím příkazu <strong>go get</strong>:</p>

<pre>
$ <strong>go get github.com/google/goexpect</strong>
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Základní způsob použití knihovny <strong>goexpect</strong></h2>

<p>Podívejme se nyní ve stručnosti na základní způsob použití knihovny
<strong>goexpect</strong>. Aby bylo možné porovnat přístupy použité ve všech
třech popisovaných knihovnách, bude dnešní první demonstrační příklad odvozen
od příkladů, které jsme si ukázali minule. Spustíme v&nbsp;něm standardní
nástroj <strong>uname</strong> a zjistíme, zda se na jeho výstupu objevil
řetězec &bdquo;Linux&ldquo;. Celý postup je relativně přímočarý.</p>

<p>Nejprve je nutné nástroj <strong>uname</strong> spustit, což se provede
jediným příkazem <strong>Spawn</strong> (následovaným pochopitelně běžnou
kontrolou chyb, které při spouštění mohou nastat):</p>

<pre>
child, _, err := expect.Spawn("uname", -1)
if err != nil {
        log.Fatal(err)
}
</pre>

<p><div class="rs-tip-major">Poznámka: druhá hodnota -1 značí, že se nebude
explicitně nastaveno čekání na text, který má aplikace vypsat (<i>timeout</i>).
V&nbsp;dalších příkladech však čekání použijeme.</div></p>

<p>Dále je důležité zajistit, aby se proces uzavřel na konci celého testu.
V&nbsp;tomto případě nám velmi dobře poslouží blok <strong>defer</strong>:</p>

<pre>
defer child.Close()
</pre>

<p>Samotný test, jaký výstup aplikace vyprodukovala, se provádí metodou
nazvanou přímočaře <strong>Expect</strong>, ovšem s&nbsp;tím rozdílem (oproti
oběma předchozím knihovnám), že se nespecifikuje holý text, ale regulární
výraz. Ten se sestaví a přeloží funkcí <strong>regexp.MustCompile</strong>
(pochopitelně nesmíme zapomenout na import příslušného balíčku):</p>

<pre>
linuxRe := regexp.MustCompile("Linux")
child.Expect(linuxRe, time.Second)
</pre>

<p>Úplný zdrojový kód dnešního prvního demonstračního příkladu naleznete na
adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_44/01_check_uname_linux.go">https://github.com/tisnik/go-root/blob/master/article_44/01_check_uname_linux.go</a>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "regexp"
        "time"
&nbsp;
        "github.com/google/goexpect"
)
&nbsp;
func <strong>main</strong>() {
        child, _, err := expect.Spawn("uname", -1)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        defer child.Close()
&nbsp;
        linuxRe := regexp.MustCompile("Linux")
        child.Expect(linuxRe, time.Second)
}
</pre>

<p><div class="rs-tip-major">Poznámka: příklady ukázané minule byly, alespoň co
se týká počtu zapsaných řádků, poněkud delší a komplikovanější. Ostatně si
můžeme porovnat přímočaré zavolání <strong>goexpect.Spawn</strong>
s&nbsp;inicializací vyžadovanou knihovnou <strong>go-expect</strong>:</div></p>

<pre>
console, err := expect.NewConsole(expect.WithStdout(os.Stdout))
if err != nil {
        log.Fatal(err)
}
defer console.Close()
&nbsp;
command := exec.Command("python")
command.Stdin = console.Tty()
command.Stdout = console.Tty()
command.Stderr = console.Tty()
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Informace vracené metodou <strong>Expect</strong></h2>

<p>V&nbsp;předchozím demonstračním příkladu jsme volali metodu
<strong>Expect</strong> bez toho, aby došlo k&nbsp;ověření jejích návratových
hodnot:</p>

<pre>
child.Expect(linuxRe, time.Second)
</pre>

<p>Ve skutečnosti je však prakticky vždy nutné návratové hodnoty nějakým
způsobem zpracovat. Tato funkce vrací tři hodnoty &ndash; nalezený řetězec, řez
(<i>slice</i>) se všemi odpovídajícími částmi textu (využijeme ho u
složitějších regulárních výrazů se skupinami &ndash; <i>groups</i>) a objekt
představující chybu. Pokud k&nbsp;chybě nedošlo, bude poslední vrácená hodnota
rovna <strong>nil</strong>. Tu můžeme snadno zpracovat a pokud k&nbsp;chybě
nedošlo vypsat první dvě návratové hodnoty:</p>

<pre>
s, match, err := child.Expect(linuxRe, time.Second)
if err != nil {
        log.Fatal(err)
}
&nbsp;
log.Printf("Found: %s", s)
log.Printf("Matches: %v", match)
</pre>

<p>Výsledkem by po spuštění mělo být:</p>

<pre>
2019/11/26 21:30:08 Found: Linux
2019/11/26 21:30:08 Matches: [Linux]
</pre>

<p>Podobného výsledku dosáhneme i při použití složitějšího regulárního
výrazu:</p>

<pre>
linuxRe := regexp.MustCompile("[Ll][Ii][Nn][Uu][Xx]")
s, match, err := child.Expect(linuxRe, time.Second)
if err != nil {
        log.Fatal(err)
}
</pre>

<p>Popř.:</p>

<pre>
linuxRe := regexp.MustCompile("[A-Za-z]+")
s, match, err := child.Expect(linuxRe, time.Second)
if err != nil {
        log.Fatal(err)
}
</pre>

<p>Výsledek by měl být ve všech případech podobný:</p>

<pre>
2019/11/26 21:48:52 Found: Linux
2019/11/26 21:48:52 Matches: [Linux]
</pre>

<p>Opět si ukažme úplný zdrojový kód druhého demonstračního příkladu, který
naleznete na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_44/02_check_uname_linux_2.go">https://github.com/tisnik/go-root/blob/master/article_44/02_check_uname_linux_2.go</a>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "regexp"
        "time"
&nbsp;
        "github.com/google/goexpect"
)
&nbsp;
func <strong>main</strong>() {
        child, _, err := expect.Spawn("uname", -1)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        defer child.Close()
&nbsp;
        linuxRe := regexp.MustCompile("Linux")
        s, match, err := child.Expect(linuxRe, time.Second)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        log.Printf("Found: %s", s)
        log.Printf("Matches: %v", match)
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Chování skriptu ve chvíli, kdy se na výstupu aplikace neobjeví očekávaný text</h2>

<p>Můžeme si pochopitelně vyzkoušet, co se stane ve chvíli, kdy na výstupu
spuštěné aplikace očekáváme nějaký text, který se ovšem vůbec neobjeví. Podobně
jako minule upravíme předchozí příklad takovým způsobem, aby se očekával text
&bdquo;BSD&ldquo; a nikoli &bdquo;Linux&ldquo;:</p>

<pre>
linuxRe := regexp.MustCompile("BSD")
s, match, err := child.Expect(linuxRe, time.Second)
</pre>

<p>Po přibližně sekundovém čekání by se měla vypsat zpráva:</p>

<pre>
expect: Process not running
</pre>

<p>Tato zpráva nám říká, že testovaný proces (nástroj <strong>uname</strong>)
byl ukončen, ale knihovna <strong>goexpect</strong> stále nemá k&nbsp;dispozici
požadovaný text, což znamená, že ho aplikace ve skutečnosti vůbec
nevypsala.</p>

<p>Takto upravený demonstrační příklad naleznete na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_44/03_check_uname_bsd.go">https://github.com/tisnik/go-root/blob/master/article_44/03_check_uname_bsd.go</a>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "regexp"
        "time"

        "github.com/google/goexpect"
)
&nbsp;
func <strong>main</strong>() {
        child, _, err := expect.Spawn("uname", -1)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        defer child.Close()
&nbsp;
        linuxRe := regexp.MustCompile("BSD")
        s, match, err := child.Expect(linuxRe, time.Second)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        log.Printf("Found: %s", s)
        log.Printf("Matches: %v", match)
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Ovládání interaktivní hry skriptem</h2>

<p>Zjištění, zda se na výstupu aplikace objevil zadaný text, již umíme
naprogramovat. Zbývá maličkost &ndash; poslat aplikaci (na její standardní
vstup) nějaký text. V&nbsp;knihovně <strong>goexpect</strong> pro tento účel
slouží metoda nazvaná <strong>Send</strong>. Nesmíme přitom zapomenout, že
v&nbsp;mnoha aplikacích je nutné příkazy ukončit Enterem, což je
v&nbsp;unixových systémech znak "\n":</p>

<pre>
child.Send("d\n")
</pre>

<p>Jednoduchý skript pro ovládání minule zmíněné hry <i>Zombie MUD</i> lze
vytvořit takto (viz též <a
href="https://github.com/tisnik/go-root/blob/master/article_44/04_telnet_game_A.go">https://github.com/tisnik/go-root/blob/master/article_44/04_telnet_game_A.go</a>):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "regexp"
        "time"
&nbsp;
        "github.com/google/goexpect"
)
&nbsp;
func <strong>main</strong>() {
        child, _, err := expect.Spawn("telnet zombiemud.org", -1)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        defer child.Close()
&nbsp;
        s, _, err := child.Expect(regexp.MustCompile("Your choice or name:"), 2*time.Second)
        if err != nil {
                log.Fatal(err)
        }
        log.Println(s)
&nbsp;
        <i>// ukonceni hry</i>
        child.Send("d\n")
&nbsp;
        s, _, err = child.Expect(regexp.MustCompile("Ok, see you later!"), 2*time.Second)
        if err != nil {
                log.Fatal(err)
        }
        log.Println(s)
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Dávkové příkazy</h2>

<p>Další užitečnou součástí knihovny <strong>goexpect</strong> jsou takzvané
&bdquo;dávkové příkazy&ldquo; (<i>batch</i>), které nám umožňují zjednodušit
sérii volání metod <strong>Expect</strong> a <strong>Send</strong>. Namísto
toho lze zapsat:</p>

<pre>
...
...
...
&amp;expect.BExp{R: "Your choice or name:"},
&amp;expect.BSnd{S: "d\n"},
&amp;expect.BExp{R: "Ok, see you later!"},
...
...
...
</pre>

<p>První řádek odpovídá volání metody <strong>Expect</strong>, druhý volání
metody <strong>Send</strong> atd. Celá série takto vytvořených příkazů je typu
řez (<i>slice</i>) hodnot <strong>expect.Batcher</strong>, kterou spustíme
metodou <strong>ExpectBatch</strong>:</p>

<pre>
_, err = child.ExpectBatch([]expect.Batcher{
        &amp;expect.BExp{R: "Your choice or name:"},
        &amp;expect.BSnd{S: "d\n"},
        &amp;expect.BExp{R: "Ok, see you later!"}}, 1*time.Second)
</pre>

<p>Testovat je nutné především druhou návratovou hodnotu, která buď obsahuje
<strong>nil</strong> nebo objekt představující chybu:</p>

<pre>
if err != nil {
        log.Fatal(err)
}
</pre>

<p>Příklad <a href="#k06">z&nbsp;předchozí kapitoly</a> lze tedy zkrátit
takto:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "time"

        "github.com/google/goexpect"
)
&nbsp;
func <strong>main</strong>() {
        child, _, err := expect.Spawn("telnet zombiemud.org", 1*time.Second)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        defer child.Close()
&nbsp;
        _, err = child.ExpectBatch([]expect.Batcher{
                &amp;expect.BExp{R: "Your choice or name:"},
                &amp;expect.BSnd{S: "d\n"},
                &amp;expect.BExp{R: "Ok, see you later!"}}, 1*time.Second)
&nbsp;
        if err != nil {
                log.Fatal(err)
        }
        log.Println("OK")
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zpracování výsledků činnosti metody <strong>ExpectBatch</strong></h2>

<p>Z&nbsp;předchozího textu již víme, že druhou návratovou hodnotou metody
<strong>ExpectBatch</strong> je <strong>nil</strong> nebo struktura
představující chybový stav. První návratová hodnota je však zajímavější,
protože obsahuje (zjednodušeně řečeno) historii všech příkazů volaných
v&nbsp;rámci jednoho dávkového procesu. Můžeme si to snadno odzkoušet:</p>

<pre>
br, err := child.ExpectBatch([]expect.Batcher{
        &amp;expect.BExp{R: "Your choice or name:"},
        &amp;expect.BSnd{S: "d\n"},
        &amp;expect.BExp{R: "Ok, see you later!"}}, 2*time.Second)
</pre>

<p>Hodnota uložená do proměnné <strong>br</strong> je řez struktur
s&nbsp;výsledky volání jednotlivých příkazů. Zobrazit si můžeme některý
z&nbsp;prvků těchto struktur, především samotný výstup zachycený
z&nbsp;testované/řízené aplikace:</p>

<pre>
for _, b := range br {
        log.Println(b.Idx, b.Output)
}
</pre>

<p>Výstup z&nbsp;příkladu může vypadat například takto:</p>

<pre>
2019/11/26 21:43:10 OK
2019/11/26 21:43:10 0 Trying 85.23.110.31...
Connected to zombiemud.org.
Escape character is '^]'.
      Welcome to ...
          ___                       __     __) __     __) ______   
         (,   )          /)  ,     (, /|  /|  (, /   /   (, /    ) 
             / ______   (/_     _    / | / |    /   /      /    /  
           _/_(_) // (_/_) _(__(/_) /  |/  |_  /   /     _/___ /_  
       )   /                     (_/   '      (___(_   (_/___ /    
      (__ /
                 ... online since 1994.
&nbsp;
      There are currently 57 mortals and 6 wizards online.
&nbsp;
            Give me your name or choose one of the following:
&nbsp;
            [C]reate a new character     [W]ho is playing
            [V]isit the game             [S]tatus of the game
            [D]isconnect
&nbsp;
            Your choice or name: 
2019/11/26 21:43:10 2 d
Ok, see you later! 
</pre>

<p>Vždy je zobrazen index (0, 2, ...) a příslušný text.</p>

<p>Opět si pro úplnost ukažme úplný kód příkladu, který jsme použili pro
získání předchozího výsledku:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "time"

        "github.com/google/goexpect"
)
&nbsp;
func <strong>main</strong>() {
        child, _, err := expect.Spawn("telnet zombiemud.org", 2*time.Second)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        defer child.Close()
&nbsp;
        br, err := child.ExpectBatch([]expect.Batcher{
                &amp;expect.BExp{R: "Your choice or name:"},
                &amp;expect.BSnd{S: "d\n"},
                &amp;expect.BExp{R: "Ok, see you later!"}}, 2*time.Second)

        if err != nil {
                log.Fatal(err)
        }
        log.Println("OK")
        for _, b := range br {
                log.Println(b.Idx, b.Output)
        }
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Ovládání interpretru Pythonu pomocí dávkových příkazů</h2>

<p>V&nbsp;předchozím článku jsme si mj.&nbsp;ukázali ovládání interpretru
Pythonu s&nbsp;využitím následujících příkazů (resp.&nbsp;jejich sekvencí):</p>

<pre>
console.SendLine("1+2")
console.ExpectString("3")
console.ExpectString("&gt;&gt;&gt; ")
&nbsp;
console.SendLine("6*7")
console.ExpectString("42")
console.ExpectString("&gt;&gt;&gt; ")
&nbsp;
console.SendLine("quit()")
</pre>

<p>Tuto sekvenci lze s&nbsp;využitím knihovny <strong>goexpect</strong> zkrátit
na:</p>

<pre>
&amp;expect.BSnd{S: "1+2\n"},
&amp;expect.BExp{R: "3"},
&amp;expect.BExp{R: "&gt;&gt;&gt; "},
&amp;expect.BSnd{S: "6*7\n"},
&amp;expect.BExp{R: "42"},
&amp;expect.BExp{R: "&gt;&gt;&gt; "},
&amp;expect.BSnd{S: "quit()\n"}},
</pre>

<p><div class="rs-tip-major">Poznámka: zda  se jedná o řešení jednodušší či
naopak méně čitelné, již ponechám na zvážení samotnému čtenáři. Výhodou druhého
řešení je, že očekávané řetězce jsou zapsány formou regulárních
výrazů.</div></p>

<p>Zařazení výše uvedené sekvence příkazů do skriptu může vypadat
následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "time"
&nbsp;
        "github.com/google/goexpect"
)
&nbsp;
func <strong>main</strong>() {
        child, _, err := expect.Spawn("python", 2*time.Second)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        defer child.Close()
&nbsp;
        br, err := child.ExpectBatch([]expect.Batcher{
                &amp;expect.BExp{R: "&gt;&gt;&gt; "},
                &amp;expect.BSnd{S: "1+2\n"},
                &amp;expect.BExp{R: "3"},
                &amp;expect.BExp{R: "&gt;&gt;&gt; "},
                &amp;expect.BSnd{S: "6*7\n"},
                &amp;expect.BExp{R: "42"},
                &amp;expect.BExp{R: "&gt;&gt;&gt; "},
                &amp;expect.BSnd{S: "quit()\n"}},
                2*time.Second)
&nbsp;
        if err != nil {
                log.Fatal(err)
        }
        log.Println("OK")
        for _, b := range br {
                log.Println(b.Output)
        }
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zjištění, která verze Pythonu je spuštěna</h2>

<p>V&nbsp;dalším demonstračním příkladu je ukázán jeden ze způsobů zjištění,
jaká verze Pythonu (Python 2, Python 3) je aktuálně spuštěna, což je opět
varianta na příklady prezentované minule. Nyní ovšem můžeme využít regulární
výrazy a navíc lze přímo zpracovat jejich výsledek (<i>capture</i>). Povšimněte
si, že v&nbsp;regulárním výrazu je definovaná skupina (<i>group</i>) okolo
předpokládaného čísla verze:</p>

<pre>
_, m, err := child.Expect(regexp.MustCompile(<strong>"Python ([23])"</strong>), 2*time.Second)
</pre>

<p>V&nbsp;případě, že je verze Pythonu nalezena (<strong>err</strong> ==
<strong>nil</strong>), pak bude v&nbsp;proměnné <strong>m</strong> uložena
dvojice řetězců: celý text odpovídající regulárnímu výrazu a text s&nbsp;číslem
verze. Pak tedy můžeme přímo přistoupit ke druhému řetězci:</p>

<pre>
version := m[1]
log.Println("Python version:", version)
</pre>

<p>Úplný kód skriptu, který verzi detekuje, lze napsat následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "regexp"
        "time"
&nbsp;
        "github.com/google/goexpect"
)
&nbsp;
func <strong>main</strong>() {
        child, _, err := expect.Spawn("python", 2*time.Second)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        defer child.Close()
&nbsp;
        _, m, err := child.Expect(regexp.MustCompile("Python ([23])"), 2*time.Second)
&nbsp;
        err = child.Send("quit()\n")
        if err != nil {
                log.Fatal(err)
        }
        version := m[1]
        log.Println("Python version:", version)
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Objekt <strong>Caser</strong> &ndash; rozvětvení na základě vstupu</h2>

<p>V&nbsp;původní knihovně <strong>expect</strong> bylo relativně snadné
provést rozvětvení na základě vstupu přečteného z&nbsp;terminálu běžící
aplikace. Podobnou funkcionalitu nám nabízí i knihovna
<strong>goexpect</strong>, ovšem ne v&nbsp;tak čitelné podobě, což je mimo jiné
způsobeno i silným typovým systémem programovacího jazyka Go (oproti netypovému
TCL). Rozvětvení na základě toho, zda se na terminálu objevil text
&bdquo;Python 2&ldquo; nebo &bdquo;Python 3&ldquo;, může být zapsáno takto:</p>

<pre>
&amp;expect.BCas{[]expect.Caser{
        &amp;expect.Case{R: regexp.MustCompile("Python 2"), T: expect.OK()},
        &amp;expect.Case{R: regexp.MustCompile("Python 3"), T: expect.OK()}}}}, time.Second)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se neuvádí pouze
podmínka (regulární výraz), ale i operace, která se má provést při splnění této
podmínky.</div></p>

<p>Tento test je možné relativně snadno zakomponovat do skriptu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "regexp"
        "time"
&nbsp;
        "github.com/google/goexpect"
)
&nbsp;
func <strong>main</strong>() {
        child, _, err := expect.Spawn("python", 2*time.Second)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        defer child.Close()
&nbsp;
        br, err := child.ExpectBatch([]expect.Batcher{
                &amp;expect.BCas{[]expect.Caser{
                        &amp;expect.Case{R: regexp.MustCompile("Python 2"), T: expect.OK()},
                        &amp;expect.Case{R: regexp.MustCompile("Python 3"), T: expect.OK()}}}}, time.Second)
&nbsp;
        err = child.Send("quit()\n")
        if err != nil {
                log.Fatal(err)
        }
        log.Println("OK")
        for _, b := range br {
                log.Println(b.Output)
        }
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Složitější příklad založený na objektu <strong>Caser</strong></h2>

<p>Skript ovšem může být složitější a kromě podmínek (i vnořených!) může
obsahovat nám již známé příkazy pro očekávání textu na terminálu aplikace a pro
poslání jiného textu na její vstup. Ostatně si to můžeme ukázat na dalším
příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "regexp"
        "time"

        "github.com/google/goexpect"
)
&nbsp;
func <strong>main</strong>() {
        child, _, err := expect.Spawn("python", 2*time.Second)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        defer child.Close()
&nbsp;
        br, err := child.ExpectBatch([]expect.Batcher{
                &amp;expect.BCas{[]expect.Caser{
                        &amp;expect.Case{R: regexp.MustCompile("Python 2"), T: expect.OK()},
                        &amp;expect.Case{R: regexp.MustCompile("Python 3"), T: expect.OK()}}},
                &amp;expect.BExp{R: "&gt;&gt;&gt; "},
                &amp;expect.BSnd{S: "6*7\n"},
                &amp;expect.BExp{R: "42"},
                &amp;expect.BExp{R: "&gt;&gt;&gt; "},
                &amp;expect.BSnd{S: "quit()\n"}},
                2*time.Second)
&nbsp;
        log.Println("OK")
        for _, b := range br {
                log.Println(b.Output)
        }
}
</pre>

<p>Díky tomu, že tento příklad vypisuje výsledek volání
<strong>ExpectBatch</strong>, budeme moci sledovat činnost celého skriptu:</p>

<pre>
2019/11/27 20:08:37 OK
2019/11/27 20:08:37 Python 2.7.6 (default, Nov 23 2017, 15:49:48) 
[GCC 4.8.4] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&nbsp;
2019/11/27 20:08:37 &gt;&gt;&gt; 
2019/11/27 20:08:37 42
&nbsp;
2019/11/27 20:08:37 &gt;&gt;&gt; 
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Kanál obsahující stav aplikace po jejím ukončení</h2>

<p>Prozatím jsme používali metodu <strong>Spawn</strong> takovým způsobem, že
jsme ignorovali její druhou návratovou hodnotu:</p>

<pre>
child, _, err := expect.Spawn("python", 2*time.Second)
</pre>

<p>Ve druhé hodnotě je ve skutečnosti vrácen kanál, z&nbsp;něhož je možné
přečíst stav aplikace po jejím ukončení. Připomeňme si, že čtení z&nbsp;kanálu
(bez kapacity) je blokující operací, takže se dá využít i pro čekání na
ukončení aplikace. Ovšem nás dnes bude zajímat především informace, která je do
kanálu poslána ve chvíli, kdy se aplikace ukončila. Kanál tedy uložíme do
proměnné:</p>

<pre>
child, errChannel, err := expect.Spawn("python", 2*time.Second)
</pre>

<p>A na konci (po ukončení interpretru) data z&nbsp;kanálu přečteme a
zpracujeme:</p>

<pre>
err = &lt;-errChannel
if err != nil {
        log.Fatal(err)
}
log.Println("Exit: success")
</pre>

<p>Výsledek by měl vypadat následovně:</p>

<pre>
2019/11/26 21:41:36 OK
2019/11/26 21:41:36 Exit: success
</pre>

<p>Pro úplnost si ukažme celý zdrojový kód takto upraveného demonstračního
příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "regexp"
        "time"

        "github.com/google/goexpect"
)
&nbsp;
func <strong>main</strong>() {
        child, errChannel, err := expect.Spawn("python", 2*time.Second)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        defer child.Close()
&nbsp;
        _, err = child.ExpectBatch([]expect.Batcher{
                &amp;expect.BCas{[]expect.Caser{
                        &amp;expect.Case{R: regexp.MustCompile("Python 2"), T: expect.OK()},
                        &amp;expect.Case{R: regexp.MustCompile("Python 3"), T: expect.OK()}}},
                &amp;expect.BExp{R: "&gt;&gt;&gt; "},
                &amp;expect.BSnd{S: "import sys\n"},
                &amp;expect.BExp{R: "&gt;&gt;&gt; "},
                &amp;expect.BSnd{S: "sys.exit(0)\n"}},
                2*time.Second)
&nbsp;
        log.Println("OK")
&nbsp;
        err = &lt;-errChannel
        if err != nil {
                log.Fatal(err)
        }
        log.Println("Exit: success")
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Interpret ukončený s&nbsp;návratovou hodnotou odlišnou od nuly</h2>

<p>Nyní interpret Pythonu ukončíme zavoláním funkce
<strong>sys.exit(1)</strong>:</p>

<pre>
        ...
        ...
        ...
        &amp;expect.BSnd{S: "sys.exit(1)\n"}},
        ...
        ...
        ...
</pre>

<p>V&nbsp;tomto případě by se měl náš skript chovat odlišně:</p>

<pre>
2019/11/26 21:41:48 OK
2019/11/26 21:41:48 exit status 1
exit status 1
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se v&nbsp;kanálu
objevil nejenom numerický kód (1), ale i celá zpráva &bdquo;exit status
1&ldquo;.</div></p>

<p>Opět si pro úplnost ukažme zdrojový kód celého příkladu, který vypadá
takto:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "regexp"
        "time"

        "github.com/google/goexpect"
)
&nbsp;
func <strong>main</strong>() {
        child, errChannel, err := expect.Spawn("python", 2*time.Second)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        defer child.Close()
&nbsp;
        _, err = child.ExpectBatch([]expect.Batcher{
                &amp;expect.BCas{[]expect.Caser{
                        &amp;expect.Case{R: regexp.MustCompile("Python 2"), T: expect.OK()},
                        &amp;expect.Case{R: regexp.MustCompile("Python 3"), T: expect.OK()}}},
                &amp;expect.BExp{R: "&gt;&gt;&gt; "},
                &amp;expect.BSnd{S: "import sys\n"},
                &amp;expect.BExp{R: "&gt;&gt;&gt; "},
                &amp;expect.BSnd{S: "sys.exit(1)\n"}},
                2*time.Second)
&nbsp;
        log.Println("OK")
&nbsp;
        err = &lt;-errChannel
        if err != nil {
                log.Fatal(err)
        }
        log.Println("Exit: success")
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Využití knihovny <strong>goexpect</strong> v&nbsp;jednotkových testech</h2>

<p>Velmi užitečné může být využití knihovny <strong>goexpect</strong>
v&nbsp;jednotkových testech, které jsou většinou postaveny přímo na standardním
balíčku <strong>testing</strong> (ovšem pochopitelně je možné v&nbsp;případě
potřeby použít i další balíčky). Podívejme se, jak snadno je možné přepsat
příklad, v&nbsp;němž se komunikuje s&nbsp;interpretrem programovacího jazyka
Python, do podoby jednotkového testu. Namísto funkce <strong>main</strong>
použijeme libovolnou funkci, jejíž název odpovídá požadavkům jednotkových testů
(jméno začíná <strong>Text</strong> a parametrem je hodnota typu
<strong>*testing.T</strong>):</p>

<pre>
func <strong>TestPythonInterpreter</strong>(t *testing.T) {
        ...
        ...
        ...
}
</pre>

<p>Poté již můžeme volat metody implementované typem
<strong>testing.T</strong>, tj.&nbsp;<strong>t.Fatal()</strong>,
<strong>t.Error()</strong> či <strong>t.Log()</strong>.</p>

<p>Úplný zdrojový text takto přepsaného příkladu vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "regexp"
        "testing"
        "time"
&nbsp;
        "github.com/google/goexpect"
)
&nbsp;
func <strong>TestPythonInterpreter</strong>(t *testing.T) {
        child, _, err := expect.Spawn("python", 2*time.Second)
        if err != nil {
                t.Fatal(err)
        }
        t.Log("Python interpreter has been started")
&nbsp;
        defer child.Close()
&nbsp;
        _, m, err := child.Expect(regexp.MustCompile("Python ([23])"), 2*time.Second)
&nbsp;
        err = child.Send("quit()\n")
        if err != nil {
                t.Fatal(err)
        }
&nbsp;
        if len(m) &lt; 1 {
                t.Fatal("No match (should not happen")
        }
        version := m[1]
        t.Log("Detected Python version:", version)
}
</pre>

<p>Po spuštění příkladu by se na výstupu měly objevit informace o tom, jaká
verze Pythonu byla detekována; následně se jen zobrazí <strong>PASS</strong>
značící, že byl test úspěšně dokončen:</p>

<pre>
=== RUN   TestPythonInterpreter
--- PASS: TestPythonInterpreter (0.02s)
    13_python_test.go:16: Python interpreter has been started
    13_python_test.go:31: Detected Python version: 2
PASS
ok      command-line-arguments  0.029s
</pre>

<p><div class="rs-tip-major">Poznámka: pro spuštění je nutné použít příkaz
<strong>go test</strong>, ideálně s&nbsp;přepínačem <strong>-v</strong>, aby se
vypisovaly i podrobnější informace o průběhu testu.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Složitější test založený na dávkové úloze a testu návratové hodnoty testované aplikace</h2>

<p>Naprosto stejným způsobem, jaký byl uveden <a href="#k15">v&nbsp;předchozí
kapitole</a>, lze přepsat i výše uvedený příklad, který po spuštění interpretru
Pythonu provede několik aritmetických výpočtů a následně interpret ukončí
zavoláním funkce <strong>sys.exit(0)</strong>. Opět při implementaci využijeme
standardní balíček <strong>testing</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "regexp"
        "testing"
        "time"
&nbsp;
        "github.com/google/goexpect"
)
&nbsp;
func <strong>TestPythonInterpreter</strong>(t *testing.T) {
        child, errChannel, err := expect.Spawn("python", 2*time.Second)
        if err != nil {
                t.Fatal(err)
        }
        t.Log("Python interpreter has been started")
&nbsp;
        defer child.Close()
&nbsp;
        _, err = child.ExpectBatch([]expect.Batcher{
                &amp;expect.BCas{[]expect.Caser{
                        &amp;expect.Case{R: regexp.MustCompile("Python 2"), T: expect.OK()},
                        &amp;expect.Case{R: regexp.MustCompile("Python 3"), T: expect.OK()}}},
                &amp;expect.BExp{R: "&gt;&gt;&gt; "},
                &amp;expect.BSnd{S: "import sys\n"},
                &amp;expect.BExp{R: "&gt;&gt;&gt; "},
                &amp;expect.BSnd{S: "sys.exit(0)\n"}},
                2*time.Second)
&nbsp;
        t.Log("OK")
&nbsp;
        err = &lt;-errChannel
        if err != nil {
                t.Fatal(err)
        }
        t.Log("Exit: success")
}
</pre>

<p>Test je nutné spustit příkazem <strong>go test -v</strong>. Po spuštění by
se měly na terminálu objevit následující zprávy ukazující jak průběh celého
testu, tak i jeho konečný výsledek:</p>

<pre>
=== RUN   TestPythonInterpreter
--- PASS: TestPythonInterpreter (0.03s)
    14_error_channel_test.go:16: Python interpreter has been started
    14_error_channel_test.go:30: OK
    14_error_channel_test.go:36: Exit: success
PASS
ok      command-line-arguments  (cached)
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Chování jednotkového testu ve chvíli, kdy je interpret ukončen s&nbsp;návratovou hodnotou odlišnou od nuly</h2>

<p>Ukažme si ještě pro úplnost, jak se chování jednotkového testu změní
v&nbsp;případě, že testovaná aplikace (konkrétně interpret Pythonu) skončí
s&nbsp;návratovým kódem odlišným od nuly. V&nbsp;kódu příkladu provedeme
následující minimální změnu:</p>

<pre>
        ...
        ...
        ...
        &amp;expect.BSnd{S: "sys.exit(1)\n"}},
        ...
        ...
        ...
</pre>

<p>Výsledek získaný po spuštění jednotkového testu:</p>

<pre>
=== RUN   TestPythonInterpreter
--- FAIL: TestPythonInterpreter (0.03s)
    15_error_channel_test.go:16: Python interpreter has been started
    15_error_channel_test.go:30: OK
    15_error_channel_test.go:34: exit status 1
FAIL
FAIL    command-line-arguments  0.036s
</pre>

<p>Úplný zdrojový kód tohoto demonstračního příkladu naleznete na adrese <a
href="https://github.com/tisnik/go-root/blob/master/article_44/15_error_channel_test.go">https://github.com/tisnik/go-root/blob/master/article_44/15_error_channel_test.go</a>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "regexp"
        "testing"
        "time"
&nbsp;
        "github.com/google/goexpect"
)
&nbsp;
func <strong>TestPythonInterpreter</strong>(t *testing.T) {
        child, errChannel, err := expect.Spawn("python", 2*time.Second)
        if err != nil {
                t.Fatal(err)
        }
        t.Log("Python interpreter has been started")
&nbsp;
        defer child.Close()
&nbsp;
        _, err = child.ExpectBatch([]expect.Batcher{
                &amp;expect.BCas{[]expect.Caser{
                        &amp;expect.Case{R: regexp.MustCompile("Python 2"), T: expect.OK()},
                        &amp;expect.Case{R: regexp.MustCompile("Python 3"), T: expect.OK()}}},
                &amp;expect.BExp{R: "&gt;&gt;&gt; "},
                &amp;expect.BSnd{S: "import sys\n"},
                &amp;expect.BExp{R: "&gt;&gt;&gt; "},
                &amp;expect.BSnd{S: "sys.exit(1)\n"}},
                2*time.Second)
&nbsp;
        t.Log("OK")
&nbsp;
        err = &lt;-errChannel
        if err != nil {
                t.Fatal(err)
        }
        t.Log("Exit: success")
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah následující části seriálu</h2>

<p>Již několik částí tohoto seriálu bylo věnováno problematice testování, ať
již přímo psaní testů pro aplikace vyvinuté v&nbsp;jazyku Go (<a
href="https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/">jednotkové
testy</a>, <a
href="https://www.root.cz/clanky/tvorba-bdd-testu-s-vyuzitim-jazyka-go-a-nastroje-godog/">BDD</a>),
nebo použití Go pro testování <a
href="https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/">REST
API</a>, <a
href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/">testování
aplikací s&nbsp;textovým uživatelským rozhraním</a> atd. Tomuto důležitému
tématu se budeme věnovat i příště, protože si popíšeme velmi zajímavý nástroj
nazvaný <a href="https://onsi.github.io/gomega/">G&Omega;mega</a>.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně pět až šest megabajtů), můžete namísto toho použít odkazy na
jednotlivé příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_check_uname_linux.go</td><td>spuštění příkazu <strong>uname</strong> a otestování jeho textového výstupu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_44/01_check_uname_linux.go">https://github.com/tisnik/go-root/blob/master/article_44/01_check_uname_linux.go</a></td></tr>
<tr><td> 2</td><td>02_check_uname_linux_2.go</td><td>podobné předchozímu příkladu, ovšem současně se vytisknou i návratové hodnoty metody <strong>Expect</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_44/02_check_uname_linux_2.go">https://github.com/tisnik/go-root/blob/master/article_44/02_check_uname_linux_2.go</a></td></tr>
<tr><td> 3</td><td>03_check_uname_bsd.go</td><td>příklad shodný s&nbsp;příkladem předchozím, ovšem tentokrát se vytiskne neočekávaný text</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_44/03_check_uname_bsd.go">https://github.com/tisnik/go-root/blob/master/article_44/03_check_uname_bsd.go</a></td></tr>
<tr><td> 4</td><td>04_telnet_game_A.go</td><td>hra (MUD) ovládaná přes telnet</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_44/04_telnet_game_A.go">https://github.com/tisnik/go-root/blob/master/article_44/04_telnet_game_A.go</a></td></tr>
<tr><td> 5</td><td>05_telnet_game_B.go</td><td>vylepšení předchozího příkladu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_44/05_telnet_game_B.go">https://github.com/tisnik/go-root/blob/master/article_44/05_telnet_game_B.go</a></td></tr>
<tr><td> 6</td><td>06_telnet_game_C.go</td><td>další vylepšení předchozího příkladu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_44/06_telnet_game_C.go">https://github.com/tisnik/go-root/blob/master/article_44/06_telnet_game_C.go</a></td></tr>
<tr><td> 7</td><td>07_python_interpreter.go</td><td>ovládání interpretru Pythonu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_44/07_python_interpreter.go">https://github.com/tisnik/go-root/blob/master/article_44/07_python_interpreter.go</a></td></tr>
<tr><td> 8</td><td>08_python_version.go</td><td>detekce verze Pythonu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_44/08_python_version.go">https://github.com/tisnik/go-root/blob/master/article_44/08_python_version.go</a></td></tr>
<tr><td> 9</td><td>09_caser.go</td><td>rozvětvení realizované objektem <strong>Caser</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_44/09_caser.go">https://github.com/tisnik/go-root/blob/master/article_44/09_caser.go</a></td></tr>
<tr><td>10</td><td>10_caser_etc.go</td><td>rozvětvení realizované objektem <strong>Caser</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/article_44/10_caser_etc.go">https://github.com/tisnik/go-root/blob/master/article_44/10_caser_etc.go</a></td></tr>
<tr><td>11</td><td>11_error_channel.go</td><td>kontrola návratového kódu aplikace</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_44/11_error_channel.go">https://github.com/tisnik/go-root/blob/master/article_44/11_error_channel.go</a></td></tr>
<tr><td>12</td><td>12_error_channel.go</td><td>kontrola návratového kódu aplikace</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_44/12_error_channel.go">https://github.com/tisnik/go-root/blob/master/article_44/12_error_channel.go</a></td></tr>
<tr><td>13</td><td>13_python_test.go</td><td>přepis příkladu číslo 7 do formy jednotkového testu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_44/13_python_test.go">https://github.com/tisnik/go-root/blob/master/article_44/13_python_test.go</a></td></tr>
<tr><td>14</td><td>14_error_channel_test.go</td><td>přepis příkladu číslo 11 do formy jednotkového testu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_44/14_error_channel_test.go">https://github.com/tisnik/go-root/blob/master/article_44/14_error_channel_test.go</a></td></tr>
<tr><td>15</td><td>15_error_channel_test.go</td><td>přepis příkladu číslo 12 do formy jednotkového testu</td><td><a href="https://github.com/tisnik/go-root/blob/master/article_44/15_error_channel_test.go">https://github.com/tisnik/go-root/blob/master/article_44/15_error_channel_test.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Dokumentace k&nbsp;balíčku goexpect<br />
<a href="https://godoc.org/github.com/google/goexpect">https://godoc.org/github.com/google/goexpect</a>
</li>

<li>Balíček goexpect<br />
<a href="https://github.com/google/goexpect">https://github.com/google/goexpect</a>
</li>

<li>Balíček go-expect<br />
<a href="https://github.com/Netflix/go-expect">https://github.com/Netflix/go-expect</a>
</li>

<li>Balíček gexpect<br />
<a href="https://github.com/ThomasRooney/gexpect">https://github.com/ThomasRooney/gexpect</a>
</li>

<li>Expect (originál naprogramovaný v&nbsp;TCL)<br />
<a href="https://core.tcl-lang.org/expect/index">https://core.tcl-lang.org/expect/index</a>
</li>

<li>Expect (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Expect">https://en.wikipedia.org/wiki/Expect</a>
</li>

<li>Pexpect<br />
<a href="https://pexpect.readthedocs.io/en/stable/">https://pexpect.readthedocs.io/en/stable/</a>
</li>

<li>Golang SSH Client: Multiple Commands, Crypto &amp; Goexpect Examples<br />
<a href="http://networkbit.ch/golang-ssh-client/">http://networkbit.ch/golang-ssh-client/</a>
</li>

<li>goblin na GitHubu<br />
<a href="https://github.com/franela/goblin">https://github.com/franela/goblin</a>
</li>

<li>Mocha framework<br />
<a href="https://mochajs.org/">https://mochajs.org/</a>
</li>

<li>frisby na GitHubu<br />
<a href="https://github.com/verdverm/frisby">https://github.com/verdverm/frisby</a>
</li>

<li>package frisby<br />
<a href="https://godoc.org/github.com/verdverm/frisby">https://godoc.org/github.com/verdverm/frisby</a>
</li>

<li>Frisby alternatives and similar packages (generováno)<br />
<a href="https://go.libhunt.com/frisby-alternatives">https://go.libhunt.com/frisby-alternatives</a>
</li>

<li>Cucumber for golang<br />
<a href="https://github.com/DATA-DOG/godog">https://github.com/DATA-DOG/godog</a>
</li>

<li>How to Use Godog for Behavior-driven Development in Go<br />
<a href="https://semaphoreci.com/community/tutorials/how-to-use-godog-for-behavior-driven-development-in-go">https://semaphoreci.com/community/tutorials/how-to-use-godog-for-behavior-driven-development-in-go</a>
</li>

<li>Comparative Analysis Of GoLang Testing Frameworks<br />
<a href="https://www.slideshare.net/DushyantBhalgami/comparative-analysis-of-golang-testing-frameworks">https://www.slideshare.net/DushyantBhalgami/comparative-analysis-of-golang-testing-frameworks</a>
</li>

<li>A Quick Guide to Testing in Golang<br />
<a href="https://caitiem.com/2016/08/18/a-quick-guide-to-testing-in-golang/">https://caitiem.com/2016/08/18/a-quick-guide-to-testing-in-golang/</a>
</li>

<li>Tom's Obvious, Minimal Language.<br />
<a href="https://github.com/toml-lang/toml">https://github.com/toml-lang/toml</a>
</li>

<li>xml.org<br />
<a href="http://www.xml.org/">http://www.xml.org/</a>
</li>

<li>Soubory .properties<br />
<a href="https://en.wikipedia.org/wiki/.properties">https://en.wikipedia.org/wiki/.properties</a>
</li>

<li>Soubory INI<br />
<a href="https://en.wikipedia.org/wiki/INI_file">https://en.wikipedia.org/wiki/INI_file</a>
</li>

<li>JSON to YAML<br />
<a href="https://www.json2yaml.com/">https://www.json2yaml.com/</a>
</li>

<li>Data Format Converter<br />
<a href="https://toolkit.site/format.html">https://toolkit.site/format.html</a>
</li>

<li>Viper na GitHubu<br />
<a href="https://github.com/spf13/viper">https://github.com/spf13/viper</a>
</li>

<li>GoDotEnv na GitHubu<br />
<a href="https://github.com/joho/godotenv">https://github.com/joho/godotenv</a>
</li>

<li>The fantastic ORM library for Golang<br />
<a href="http://gorm.io/">http://gorm.io/</a>
</li>

<li>Dokumentace k&nbsp;balíčku <strong>gorilla/mux</strong><br />
<a href="https://godoc.org/github.com/gorilla/mux">https://godoc.org/github.com/gorilla/mux</a>
</li>

<li>Gorilla web toolkitk<br />
<a href="http://www.gorillatoolkit.org/">http://www.gorillatoolkit.org/</a>
</li>

<li>Metric types<br />
<a href="https://prometheus.io/docs/concepts/metric_types/">https://prometheus.io/docs/concepts/metric_types/</a>
</li>

<li>Histograms with Prometheus: A Tale of Woe<br />
<a href="http://linuxczar.net/blog/2017/06/15/prometheus-histogram-2/">http://linuxczar.net/blog/2017/06/15/prometheus-histogram-2/</a>
</li>

<li>Why are Prometheus histograms cumulative?<br />
<a href="https://www.robustperception.io/why-are-prometheus-histograms-cumulative">https://www.robustperception.io/why-are-prometheus-histograms-cumulative</a>
</li>

<li>Histograms and summaries<br />
<a href="https://prometheus.io/docs/practices/histograms/">https://prometheus.io/docs/practices/histograms/</a>
</li>

<li>Instrumenting Golang server in 5 min<br />
<a href="https://medium.com/@gsisimogang/instrumenting-golang-server-in-5-min-c1c32489add3">https://medium.com/@gsisimogang/instrumenting-golang-server-in-5-min-c1c32489add3</a>
</li>

<li>Semantic Import Versioning in Go<br />
<a href="https://www.aaronzhuo.com/semantic-import-versioning-in-go/">https://www.aaronzhuo.com/semantic-import-versioning-in-go/</a>
</li>

<li>Sémantické verzování<br />
<a href="https://semver.org/">https://semver.org/</a>
</li>

<li>Getting started with Go modules<br />
<a href="https://medium.com/@fonseka.live/getting-started-with-go-modules-b3dac652066d">https://medium.com/@fonseka.live/getting-started-with-go-modules-b3dac652066d</a>
</li>

<li>Create projects independent of $GOPATH using Go Modules<br />
<a href="https://medium.com/mindorks/create-projects-independent-of-gopath-using-go-modules-802260cdfb51o">https://medium.com/mindorks/create-projects-independent-of-gopath-using-go-modules-802260cdfb51o</a>
</li>

<li>Anatomy of Modules in Go<br />
<a href="https://medium.com/rungo/anatomy-of-modules-in-go-c8274d215c16">https://medium.com/rungo/anatomy-of-modules-in-go-c8274d215c16</a>
</li>

<li>Modules<br />
<a href="https://github.com/golang/go/wiki/Modules">https://github.com/golang/go/wiki/Modules</a>
</li>

<li>Go Modules Tutorial<br />
<a href="https://tutorialedge.net/golang/go-modules-tutorial/">https://tutorialedge.net/golang/go-modules-tutorial/</a>
</li>

<li>Module support<br />
<a href="https://golang.org/cmd/go/#hdr-Module_support">https://golang.org/cmd/go/#hdr-Module_support</a>
</li>

<li>Go Lang: Memory Management and Garbage Collection<br />
<a href="https://vikash1976.wordpress.com/2017/03/26/go-lang-memory-management-and-garbage-collection/">https://vikash1976.wordpress.com/2017/03/26/go-lang-memory-management-and-garbage-collection/</a>
</li>

<li>Golang Internals, Part 4: Object Files and Function Metadata<br />
<a href="https://blog.altoros.com/golang-part-4-object-files-and-function-metadata.html">https://blog.altoros.com/golang-part-4-object-files-and-function-metadata.html</a>
</li>

<li>What is REPL?<br />
<a href="https://pythonprogramminglanguage.com/repl/">https://pythonprogramminglanguage.com/repl/</a>
</li>

<li>What is a REPL?<br />
<a href="https://codewith.mu/en/tutorials/1.0/repl">https://codewith.mu/en/tutorials/1.0/repl</a>
</li>

<li>Programming at the REPL: Introduction<br />
<a href="https://clojure.org/guides/repl/introduction">https://clojure.org/guides/repl/introduction</a>
</li>

<li>What is REPL? (Quora)<br />
<a href="https://www.quora.com/What-is-REPL">https://www.quora.com/What-is-REPL</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Read-eval-print loop (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>Vim as a Go (Golang) IDE using LSP and vim-go<br />
<a href="https://octetz.com/posts/vim-as-go-ide">https://octetz.com/posts/vim-as-go-ide</a>
</li>

<li>gopls<br />
<a href="https://github.com/golang/go/wiki/gopls">https://github.com/golang/go/wiki/gopls</a>
</li>

<li>IDE Integration Guide<br />
<a href="https://github.com/stamblerre/gocode/blob/master/docs/IDE_integration.md">https://github.com/stamblerre/gocode/blob/master/docs/IDE_integration.md</a>
</li>

<li>How to instrument Go code with custom expvar metrics<br />
<a href="https://sysdig.com/blog/golang-expvar-custom-metrics/">https://sysdig.com/blog/golang-expvar-custom-metrics/</a>
</li>

<li>Golang expvar metricset (Metricbeat Reference)<br />
<a href="https://www.elastic.co/guide/en/beats/metricbeat/7.x/metricbeat-metricset-golang-expvar.html">https://www.elastic.co/guide/en/beats/metricbeat/7.x/metricbeat-metricset-golang-expvar.html</a>
</li>

<li>Package expvar<br />
<a href="https://golang.org/pkg/expvar/#NewInt">https://golang.org/pkg/expvar/#NewInt</a>
</li>

<li>Java Platform Debugger Architecture: Overview<br />
<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jpda/jpda.html">https://docs.oracle.com/en/java/javase/11/docs/specs/jpda/jpda.html</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="https://www.oracle.com/technetwork/articles/javase/index-140680.html">https://www.oracle.com/technetwork/articles/javase/index-140680.html</a>
</li>

<li>JVM Tool Interface Version 11.0<br />
<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html">https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>Go &amp; cgo: integrating existing C code with Go<br />
<a href="http://akrennmair.github.io/golang-cgo-slides/#1">http://akrennmair.github.io/golang-cgo-slides/#1</a>
</li>

<li>Using cgo to call C code from within Go code<br />
<a href="https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/">https://wenzr.wordpress.com/2018/06/07/using-cgo-to-call-c-code-from-within-go-code/</a>
</li>

<li>Package trace<br />
<a href="https://golang.org/pkg/runtime/trace/">https://golang.org/pkg/runtime/trace/</a>
</li>

<li>Introducing HTTP Tracing<br />
<a href="https://blog.golang.org/http-tracing">https://blog.golang.org/http-tracing</a>
</li>

<li>Command trace<br />
<a href="https://golang.org/cmd/trace/">https://golang.org/cmd/trace/</a>
</li>

<li>A StreamLike, Immutable, Lazy Loading and smart Golang Library to deal with slices<br />
<a href="https://github.com/wesovilabs/koazee">https://github.com/wesovilabs/koazee</a>
</li>

<li>Funkce vyššího řádu v knihovně Underscore<br />
<a href="https://www.root.cz/clanky/funkce-vyssiho-radu-v-knihovne-underscore/">https://www.root.cz/clanky/funkce-vyssiho-radu-v-knihovne-underscore/</a>
</li>

<li>Delve: a debugger for the Go programming language.<br />
<a href="https://github.com/go-delve/delve">https://github.com/go-delve/delve</a>
</li>

<li>Příkazy debuggeru Delve<br />
<a href="https://github.com/go-delve/delve/tree/master/Documentation/cli">https://github.com/go-delve/delve/tree/master/Documentation/cli</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (2. část)<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v&nbsp;editorech Emacs a Vim<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Debugging Go Code with GDB<br />
<a href="https://golang.org/doc/gdb">https://golang.org/doc/gdb</a>
</li>

<li>Debugging Go (golang) programs with gdb <br />
<a href="https://thornydev.blogspot.com/2014/01/debugging-go-golang-programs-with-gdb.html">https://thornydev.blogspot.com/2014/01/debugging-go-golang-programs-with-gdb.html</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>GDB - Supported Languages<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>13 Linux Debuggers for C++ Reviewed<br />
<a href="http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817">http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817</a>
</li>

<li>Go is on a Trajectory to Become the Next Enterprise Programming Language<br />
<a href="https://hackernoon.com/go-is-on-a-trajectory-to-become-the-next-enterprise-programming-language-3b75d70544e">https://hackernoon.com/go-is-on-a-trajectory-to-become-the-next-enterprise-programming-language-3b75d70544e</a>
</li>

<li>Go Proverbs: Simple, Poetic, Pithy<br />
<a href="https://go-proverbs.github.io/">https://go-proverbs.github.io/</a>
</li>

<li>Handling Sparse Files on Linux<br />
<a href="https://www.systutorials.com/136652/handling-sparse-files-on-linux/">https://www.systutorials.com/136652/handling-sparse-files-on-linux/</a>
</li>

<li>Gzip (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Gzip">https://en.wikipedia.org/wiki/Gzip</a>
</li>

<li>Deflate<br />
<a href="https://en.wikipedia.org/wiki/DEFLATE">https://en.wikipedia.org/wiki/DEFLATE</a>
</li>

<li>10 tools written in Go that every developer needs to know<br />
<a href="https://gustavohenrique.net/en/2019/01/10-tools-written-in-go-that-every-dev-needs-to-know/">https://gustavohenrique.net/en/2019/01/10-tools-written-in-go-that-every-dev-needs-to-know/</a>
</li>

<li>Hexadecimální prohlížeče a editory s textovým uživatelským rozhraním<br />
<a href="https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/">https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/</a>
</li>

<li>Hex dump<br />
<a href="https://en.wikipedia.org/wiki/Hex_dump">https://en.wikipedia.org/wiki/Hex_dump</a>
</li>

<li>Rozhraní io.ByteReader<br />
<a href="https://golang.org/pkg/io/#ByteReader">https://golang.org/pkg/io/#ByteReader</a>
</li>

<li>Rozhraní io.RuneReader<br />
<a href="https://golang.org/pkg/io/#RuneReader">https://golang.org/pkg/io/#RuneReader</a>
</li>

<li>Rozhraní io.ByteScanner<br />
<a href="https://golang.org/pkg/io/#ByteScanner">https://golang.org/pkg/io/#ByteScanner</a>
</li>

<li>Rozhraní io.RuneScanner<br />
<a href="https://golang.org/pkg/io/#RuneScanner">https://golang.org/pkg/io/#RuneScanner</a>
</li>

<li>Rozhraní io.Closer<br />
<a href="https://golang.org/pkg/io/#Closer">https://golang.org/pkg/io/#Closer</a>
</li>

<li>Rozhraní io.Reader<br />
<a href="https://golang.org/pkg/io/#Reader">https://golang.org/pkg/io/#Reader</a>
</li>

<li>Rozhraní io.Writer<br />
<a href="https://golang.org/pkg/io/#Writer">https://golang.org/pkg/io/#Writer</a>
</li>

<li>Typ Strings.Reader<br />
<a href="https://golang.org/pkg/strings/#Reader">https://golang.org/pkg/strings/#Reader</a>
</li>

<li>VACUUM (SQL)<br />
<a href="https://www.sqlite.org/lang_vacuum.html">https://www.sqlite.org/lang_vacuum.html</a>
</li>

<li>VACUUM (Postgres)<br />
<a href="https://www.postgresql.org/docs/8.4/sql-vacuum.html">https://www.postgresql.org/docs/8.4/sql-vacuum.html</a>
</li>

<li>go-cron<br />
<a href="https://github.com/rk/go-cron">https://github.com/rk/go-cron</a>
</li>

<li>gocron<br />
<a href="https://github.com/jasonlvhit/gocron">https://github.com/jasonlvhit/gocron</a>
</li>

<li>clockwork<br />
<a href="https://github.com/whiteShtef/clockwork">https://github.com/whiteShtef/clockwork</a>
</li>

<li>clockwerk<br />
<a href="https://github.com/onatm/clockwerk">https://github.com/onatm/clockwerk</a>
</li>

<li>JobRunner<br />
<a href="https://github.com/bamzi/jobrunner">https://github.com/bamzi/jobrunner</a>
</li>

<li>Rethinking Cron<br />
<a href="https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/">https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/</a>
</li>

<li>In the Beginning was the Command Line<br />
<a href="https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html">https://web.archive.org/web/20180218045352/http://www.cryptonomicon.com/beginning.html</a>
</li>

<li>repl.it (REPL pro různé jazyky)<br />
<a href="https://repl.it/languages">https://repl.it/languages</a>
</li>

<li>GOCUI - Go Console User Interface (celé uživatelské prostředí, nejenom input box)<br />
<a href="https://github.com/jroimartin/gocui">https://github.com/jroimartin/gocui</a>
</li>

<li>Read–eval–print loop<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>go-prompt<br />
<a href="https://github.com/c-bata/go-prompt">https://github.com/c-bata/go-prompt</a>
</li>

<li>readline<br />
<a href="https://github.com/chzyer/readline">https://github.com/chzyer/readline</a>
</li>

<li>A pure golang implementation for GNU-Readline kind library<br />
<a href="https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/">https://golangexample.com/a-pure-golang-implementation-for-gnu-readline-kind-library/</a>
</li>

<li>go-readline<br />
<a href="https://github.com/fiorix/go-readline">https://github.com/fiorix/go-readline</a>
</li>

<li>4 Python libraries for building great command-line user interfaces<br />
<a href="https://opensource.com/article/17/5/4-practical-python-libraries">https://opensource.com/article/17/5/4-practical-python-libraries</a>
</li>

<li>prompt_toolkit 2.0.3 na PyPi<br />
<a href="https://pypi.org/project/prompt_toolkit/">https://pypi.org/project/prompt_toolkit/</a>
</li>

<li>python-prompt-toolkit na GitHubu<br />
<a href="https://github.com/jonathanslenders/python-prompt-toolkit">https://github.com/jonathanslenders/python-prompt-toolkit</a>
</li>

<li>The GNU Readline Library<br />
<a href="https://tiswww.case.edu/php/chet/readline/rltop.html">https://tiswww.case.edu/php/chet/readline/rltop.html</a>
</li>

<li>GNU Readline (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Readline">https://en.wikipedia.org/wiki/GNU_Readline</a>
</li>

<li>readline — GNU readline interface (Python 3.x)<br />
<a href="https://docs.python.org/3/library/readline.html">https://docs.python.org/3/library/readline.html</a>
</li>

<li>readline — GNU readline interface (Python 2.x)<br />
<a href="https://docs.python.org/2/library/readline.html">https://docs.python.org/2/library/readline.html</a>
</li>

<li>GNU Readline Library - command line editing<br />
<a href="https://tiswww.cwru.edu/php/chet/readline/readline.html">https://tiswww.cwru.edu/php/chet/readline/readline.html</a>
</li>

<li>gnureadline 6.3.8 na PyPi<br />
<a href="https://pypi.org/project/gnureadline/">https://pypi.org/project/gnureadline/</a>
</li>

<li>Editline Library (libedit)<br />
<a href="http://thrysoee.dk/editline/">http://thrysoee.dk/editline/</a>
</li>

<li>Comparing Python Command-Line Parsing Libraries – Argparse, Docopt, and Click<br />
<a href="https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/">https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/</a>
</li>

<li>libedit or editline<br />
<a href="http://www.cs.utah.edu/~bigler/code/libedit.html">http://www.cs.utah.edu/~bigler/code/libedit.html</a>
</li>

<li>WinEditLine<br />
<a href="http://mingweditline.sourceforge.net/">http://mingweditline.sourceforge.net/</a>
</li>

<li>rlcompleter — Completion function for GNU readline<br />
<a href="https://docs.python.org/3/library/rlcompleter.html">https://docs.python.org/3/library/rlcompleter.html</a>
</li>

<li>rlwrap na GitHubu<br />
<a href="https://github.com/hanslub42/rlwrap">https://github.com/hanslub42/rlwrap</a>
</li>

<li>rlwrap(1) - Linux man page<br />
<a href="https://linux.die.net/man/1/rlwrap">https://linux.die.net/man/1/rlwrap</a>
</li>

<li>readline(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/readline">https://linux.die.net/man/3/readline</a>
</li>

<li>history(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/history">https://linux.die.net/man/3/history</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>oglematchers</i><br />
<a href="https://godoc.org/github.com/jacobsa/oglematchers">https://godoc.org/github.com/jacobsa/oglematchers</a>
</li>

<li>Balíček <i>oglematchers</i><br />
<a href="https://github.com/jacobsa/oglematchers">https://github.com/jacobsa/oglematchers</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>ogletest</i><br />
<a href="https://godoc.org/github.com/jacobsa/ogletest">https://godoc.org/github.com/jacobsa/ogletest</a>
</li>

<li>Balíček <i>ogletest</i><br />
<a href="https://github.com/jacobsa/ogletest">https://github.com/jacobsa/ogletest</a>
</li>

<li>Dokumentace k&nbsp;balíčku <i>assert</i><br />
<a href="https://godoc.org/github.com/stretchr/testify/assert">https://godoc.org/github.com/stretchr/testify/assert</a>
</li>

<li>Testify - Thou Shalt Write Tests<br />
<a href="https://github.com/stretchr/testify/">https://github.com/stretchr/testify/</a>
</li>

<li>package testing<br />
<a href="https://golang.org/pkg/testing/">https://golang.org/pkg/testing/</a>
</li>

<li>Golang basics - writing unit tests<br />
<a href="https://blog.alexellis.io/golang-writing-unit-tests/">https://blog.alexellis.io/golang-writing-unit-tests/</a>
</li>

<li>An Introduction to Programming in Go / Testing<br />
<a href="https://www.golang-book.com/books/intro/12">https://www.golang-book.com/books/intro/12</a>
</li>

<li>An Introduction to Testing in Go<br />
<a href="https://tutorialedge.net/golang/intro-testing-in-go/">https://tutorialedge.net/golang/intro-testing-in-go/</a>
</li>

<li>Advanced Go Testing Tutorial<br />
<a href="https://tutorialedge.net/golang/advanced-go-testing-tutorial/">https://tutorialedge.net/golang/advanced-go-testing-tutorial/</a>
</li>

<li>GoConvey<br />
<a href="http://goconvey.co/">http://goconvey.co/</a>
</li>

<li>Testing Techniques<br />
<a href="https://talks.golang.org/2014/testing.slide">https://talks.golang.org/2014/testing.slide</a>
</li>

<li>5 simple tips and tricks for writing unit tests in #golang<br />
<a href="https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742">https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742</a>
</li>

<li>Afinní transformace<br />
<a href="https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic">https://cs.wikibooks.org/wiki/Geometrie/Afinn%C3%AD_transformace_sou%C5%99adnic</a>
</li>

<li>package gg<br />
<a href="https://godoc.org/github.com/fogleman/gg">https://godoc.org/github.com/fogleman/gg</a>
</li>

<li>Generate an animated GIF with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/">http://tech.nitoyon.com/en/blog/2016/01/07/go-animated-gif-gen/</a>
</li>

<li>Generate an image programmatically with Golang<br />
<a href="http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/">http://tech.nitoyon.com/en/blog/2015/12/31/go-image-gen/</a>
</li>

<li>The Go image package<br />
<a href="https://blog.golang.org/go-image-package">https://blog.golang.org/go-image-package</a>
</li>

<li>Balíček draw2D: 2D rendering for different output (raster, pdf, svg)<br />
<a href="https://github.com/llgcode/draw2d">https://github.com/llgcode/draw2d</a>
</li>

<li>Draw a rectangle in Golang?<br />
<a href="https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang">https://stackoverflow.com/questions/28992396/draw-a-rectangle-in-golang</a>
</li>

<li>YAML<br />
<a href="https://yaml.org/">https://yaml.org/</a>
</li>

<li>edn<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Smile<br />
<a href="https://github.com/FasterXML/smile-format-specification">https://github.com/FasterXML/smile-format-specification</a>
</li>

<li>Protocol-Buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>Marshalling (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
</li>

<li>Unmarshalling<br />
<a href="https://en.wikipedia.org/wiki/Unmarshalling">https://en.wikipedia.org/wiki/Unmarshalling</a>
</li>

<li>Introducing JSON<br />
<a href="http://json.org/">http://json.org/</a>
</li>

<li>Package json<br />
<a href="https://golang.org/pkg/encoding/json/">https://golang.org/pkg/encoding/json/</a>
</li>

<li>The Go Blog: JSON and Go<br />
<a href="https://blog.golang.org/json-and-go">https://blog.golang.org/json-and-go</a>
</li>

<li>Go by Example: JSON<br />
<a href="https://gobyexample.com/json">https://gobyexample.com/json</a>
</li>

<li>Writing Web Applications<br />
<a href="https://golang.org/doc/articles/wiki/">https://golang.org/doc/articles/wiki/</a>
</li>

<li>Golang Web Apps<br />
<a href="https://www.reinbach.com/blog/golang-webapps-1/">https://www.reinbach.com/blog/golang-webapps-1/</a>
</li>

<li>Build web application with Golang<br />
<a href="https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details">https://legacy.gitbook.com/book/astaxie/build-web-application-with-golang/details</a>
</li>

<li>Golang Templates - Golang Web Pages<br />
<a href="https://www.youtube.com/watch?v=TkNIETmF-RU">https://www.youtube.com/watch?v=TkNIETmF-RU</a>
</li>

<li>Simple Golang HTTPS/TLS Examples<br />
<a href="https://github.com/denji/golang-tls">https://github.com/denji/golang-tls</a>
</li>

<li>Playing with images in HTTP response in golang<br />
<a href="https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang">https://www.sanarias.com/blog/1214PlayingwithimagesinHTTPresponseingolang</a>
</li>

<li>MIME Types List<br />
<a href="https://www.freeformatter.com/mime-types-list.html">https://www.freeformatter.com/mime-types-list.html</a>
</li>

<li>Go Mutex Tutorial<br />
<a href="https://tutorialedge.net/golang/go-mutex-tutorial/">https://tutorialedge.net/golang/go-mutex-tutorial/</a>
</li>

<li>Creating A Simple Web Server With Golang<br />
<a href="https://tutorialedge.net/golang/creating-simple-web-server-with-golang/">https://tutorialedge.net/golang/creating-simple-web-server-with-golang/</a>
</li>

<li>Building a Web Server in Go<br />
<a href="https://thenewstack.io/building-a-web-server-in-go/">https://thenewstack.io/building-a-web-server-in-go/</a>
</li>

<li>How big is the pipe buffer?<br />
<a href="https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer">https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer</a>
</li>

<li>How to turn off buffering of stdout in C<br />
<a href="https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c">https://stackoverflow.com/questions/7876660/how-to-turn-off-buffering-of-stdout-in-c</a>
</li>

<li>setbuf(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/setbuf">https://linux.die.net/man/3/setbuf</a>
</li>

<li>setvbuf(3) - Linux man page (stejný obsah jako předchozí stránka)<br />
<a href="https://linux.die.net/man/3/setvbuf">https://linux.die.net/man/3/setvbuf</a>
</li>

<li>Select waits on a group of channels<br />
<a href="https://yourbasic.org/golang/select-explained/">https://yourbasic.org/golang/select-explained/</a>
</li>

<li>Rob Pike: Simplicity is Complicated (video)<br />
<a href="http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893">http://www.golang.to/posts/dotgo-2015-rob-pike-simplicity-is-complicated-youtube-16893</a>
</li>

<li>Algorithms to Go<br />
<a href="https://yourbasic.org/">https://yourbasic.org/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů: vlastní filtry a lexery<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu-vlastni-filtry-a-lexery/</a>
</li>

<li>Go Defer Simplified with Practical Visuals<br />
<a href="https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff">https://blog.learngoprogramming.com/golang-defer-simplified-77d3b2b817ff</a>
</li>

<li>5 More Gotchas of Defer in Go — Part II<br />
<a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa">https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa</a>
</li>

<li>The Go Blog: Defer, Panic, and Recover<br />
<a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a>
</li>

<li>The defer keyword in Swift 2: try/finally done right<br />
<a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer">https://www.hackingwithswift.com/new-syntax-swift-2-defer</a>
</li>

<li>Swift Defer Statement<br />
<a href="https://andybargh.com/swift-defer-statement/">https://andybargh.com/swift-defer-statement/</a>
</li>

<li>Modulo operation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Modulo_operation">https://en.wikipedia.org/wiki/Modulo_operation</a>
</li>

<li>Node.js vs Golang: Battle of the Next-Gen Languages<br />
<a href="https://www.hostingadvice.com/blog/nodejs-vs-golang/">https://www.hostingadvice.com/blog/nodejs-vs-golang/</a>
</li>

<li>The Go Programming Language (home page)<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>GoDoc<br />
<a href="https://godoc.org/">https://godoc.org/</a>
</li>

<li>Go (programming language), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</li>

<li>Go Books (kniha o jazyku Go)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language Specification<br />
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
</li>

<li>Go: the Good, the Bad and the Ugly<br />
<a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/">https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/</a>
</li>

<li>Package builtin<br />
<a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a>
</li>

<li>Package fmt<br />
<a href="https://golang.org/pkg/fmt/">https://golang.org/pkg/fmt/</a>
</li>

<li>The Little Go Book (další kniha)<br />
<a href="https://github.com/dariubs/GoBooks">https://github.com/dariubs/GoBooks</a>
</li>

<li>The Go Programming Language by Brian W. Kernighan, Alan A. A. Donovan<br />
<a href="https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html">https://www.safaribooksonline.com/library/view/the-go-programming/9780134190570/ebook_split_010.html</a>
</li>

<li>Learning Go<br />
<a href="https://www.miek.nl/go/">https://www.miek.nl/go/</a>
</li>

<li>Go Bootcamp<br />
<a href="http://www.golangbootcamp.com/">http://www.golangbootcamp.com/</a>
</li>

<li>Programming in Go: Creating Applications for the 21st Century (další kniha o jazyku Go)<br />
<a href="http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637">http://www.informit.com/store/programming-in-go-creating-applications-for-the-21st-9780321774637</a>
</li>

<li>Introducing Go (Build Reliable, Scalable Programs)<br />
<a href="http://shop.oreilly.com/product/0636920046516.do">http://shop.oreilly.com/product/0636920046516.do</a>
</li>

<li>Learning Go Programming<br />
<a href="https://www.packtpub.com/application-development/learning-go-programming">https://www.packtpub.com/application-development/learning-go-programming</a>
</li>

<li>The Go Blog<br />
<a href="https://blog.golang.org/">https://blog.golang.org/</a>
</li>

<li>Getting to Go: The Journey of Go's Garbage Collector<br />
<a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a>
</li>

<li>Go (programovací jazyk, Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)">https://cs.wikipedia.org/wiki/Go_(programovac%C3%AD_jazyk)</a>
</li>

<li>Rychle, rychleji až úplně nejrychleji s jazykem Go<br />
<a href="https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/">https://www.root.cz/clanky/rychle-rychleji-az-uplne-nejrychleji-s-jazykem-go/</a>
</li>

<li>Installing Go on the Raspberry Pi<br />
<a href="https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">https://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi</a>
</li>

<li>How the Go runtime implements maps efficiently (without generics)<br />
<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a>
</li>

<li>Niečo málo o Go - Golang (slovensky)<br />
<a href="http://golangsk.logdown.com/">http://golangsk.logdown.com/</a>
</li>

<li>How Many Go Developers Are There?<br />
<a href="https://research.swtch.com/gophercount">https://research.swtch.com/gophercount</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2018)<br />
<a href="https://insights.stackoverflow.com/survey/2018/#most-popular-technologies">https://insights.stackoverflow.com/survey/2018/#most-popular-technologies</a>
</li>

<li>Most Popular Technologies (Stack Overflow Survery 2017)<br />
<a href="https://insights.stackoverflow.com/survey/2017#technology">https://insights.stackoverflow.com/survey/2017#technology</a>
</li>

<li>JavaScript vs. Golang for IoT: Is Gopher Winning?<br />
<a href="https://www.iotforall.com/javascript-vs-golang-iot/">https://www.iotforall.com/javascript-vs-golang-iot/</a>
</li>

<li>The Go Programming Language: Release History<br />
<a href="https://golang.org/doc/devel/release.html">https://golang.org/doc/devel/release.html</a>
</li>

<li>Go 1.11 Release Notes<br />
<a href="https://golang.org/doc/go1.11">https://golang.org/doc/go1.11</a>
</li>

<li>Go 1.10 Release Notes<br />
<a href="https://golang.org/doc/go1.10">https://golang.org/doc/go1.10</a>
</li>

<li>Go 1.9 Release Notes (tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.9">https://golang.org/doc/go1.9</a>
</li>

<li>Go 1.8 Release Notes (i tato verze je stále používána)<br />
<a href="https://golang.org/doc/go1.8">https://golang.org/doc/go1.8</a>
</li>

<li>Go on Fedora<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-installation.html">https://developer.fedoraproject.org/tech/languages/go/go-installation.html</a>
</li>

<li>Writing Go programs<br />
<a href="https://developer.fedoraproject.org/tech/languages/go/go-programs.html">https://developer.fedoraproject.org/tech/languages/go/go-programs.html</a>
</li>

<li>The GOPATH environment variable<br />
<a href="https://tip.golang.org/doc/code.html#GOPATH">https://tip.golang.org/doc/code.html#GOPATH</a>
</li>

<li>Command gofmt<br />
<a href="https://tip.golang.org/cmd/gofmt/">https://tip.golang.org/cmd/gofmt/</a>
</li>

<li>The Go Blog: go fmt your code<br />
<a href="https://blog.golang.org/go-fmt-your-code">https://blog.golang.org/go-fmt-your-code</a>
</li>

<li>C? Go? Cgo!<br />
<a href="https://blog.golang.org/c-go-cgo">https://blog.golang.org/c-go-cgo</a>
</li>

<li>Spaces vs. Tabs: A 20-Year Debate Reignited by Google’s Golang<br />
<a href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/">https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/</a>
</li>

<li>400,000 GitHub repositories, 1 billion files, 14 terabytes of code: Spaces or Tabs?<br />
<a href="https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd">https://medium.com/@hoffa/400-000-github-repositories-1-billion-files-14-terabytes-of-code-spaces-or-tabs-7cfe0b5dd7fd</a>
</li>

<li>Gofmt No Longer Allows Spaces. Tabs Only<br />
<a href="https://news.ycombinator.com/item?id=7914523">https://news.ycombinator.com/item?id=7914523</a>
</li>

<li>Why does Go "go fmt" uses tabs instead of whitespaces?<br />
<a href="https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces">https://www.quora.com/Why-does-Go-go-fmt-uses-tabs-instead-of-whitespaces</a>
</li>

<li>Interactive: The Top Programming Languages 2018<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018</a>
</li>

<li>Go vs. Python<br />
<a href="https://www.peterbe.com/plog/govspy">https://www.peterbe.com/plog/govspy</a>
</li>

<li>PackageManagementTools<br />
<a href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a>
</li>

<li>A Tour of Go: Type inference<br />
<a href="https://tour.golang.org/basics/14">https://tour.golang.org/basics/14</a>
</li>

<li>Go Slices: usage and internals<br />
<a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a>
</li>

<li>Go by Example: Slices<br />
<a href="https://gobyexample.com/slices">https://gobyexample.com/slices</a>
</li>

<li>What is the point of slice type in Go?<br />
<a href="https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go">https://stackoverflow.com/questions/2098874/what-is-the-point-of-slice-type-in-go</a>
</li>

<li>The curious case of Golang array and slices<br />
<a href="https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335">https://medium.com/@hackintoshrao/the-curious-case-of-golang-array-and-slices-2565491d4335</a>
</li>

<li>Introduction to Slices in Golang<br />
<a href="https://www.callicoder.com/golang-slices/">https://www.callicoder.com/golang-slices/</a>
</li>

<li>Golang: Understanding 'null' and nil<br />
<a href="https://newfivefour.com/golang-null-nil.html">https://newfivefour.com/golang-null-nil.html</a>
</li>

<li>What does nil mean in golang?<br />
<a href="https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang">https://stackoverflow.com/questions/35983118/what-does-nil-mean-in-golang</a>
</li>

<li>nils In Go<br />
<a href="https://go101.org/article/nil.html">https://go101.org/article/nil.html</a>
</li>

<li>Go slices are not dynamic arrays<br />
<a href="https://appliedgo.net/slices/">https://appliedgo.net/slices/</a>
</li>

<li>Go-is-no-good (nelze brát doslova)<br />
<a href="https://github.com/ksimka/go-is-not-good">https://github.com/ksimka/go-is-not-good</a>
</li>

<li>Rust vs. Go<br />
<a href="https://news.ycombinator.com/item?id=13430108">https://news.ycombinator.com/item?id=13430108</a>
</li>

<li>Seriál Programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Modern garbage collection: A look at the Go GC strategy<br />
<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a>
</li>

<li>Go GC: Prioritizing low latency and simplicity<br />
<a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a>
</li>

<li>Is Golang a good language for embedded systems?<br />
<a href="https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems">https://www.quora.com/Is-Golang-a-good-language-for-embedded-systems</a>
</li>

<li>Running GoLang on an STM32 MCU. A quick tutorial.<br />
<a href="https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial">https://www.mickmake.com/post/running-golang-on-an-mcu-a-quick-tutorial</a>
</li>

<li>Go, Robot, Go! Golang Powered Robotics<br />
<a href="https://gobot.io/">https://gobot.io/</a>
</li>

<li>Emgo: Bare metal Go (language for programming embedded systems)<br />
<a href="https://github.com/ziutek/emgo">https://github.com/ziutek/emgo</a>
</li>

<li>UTF-8 history<br />
<a href="https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a>
</li>

<li>Less is exponentially more<br />
<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a>
</li>

<li>Should I Rust, or Should I Go<br />
<a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9">https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9</a>
</li>

<li>Setting up and using gccgo<br />
<a href="https://golang.org/doc/install/gccgo">https://golang.org/doc/install/gccgo</a>
</li>

<li>Elastic Tabstops<br />
<a href="http://nickgravgaard.com/elastic-tabstops/">http://nickgravgaard.com/elastic-tabstops/</a>
</li>

<li>Strings, bytes, runes and characters in Go<br />
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>
</li>

<li>Datový typ<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%BD_typ">https://cs.wikipedia.org/wiki/Datov%C3%BD_typ</a>
</li>

<li>Seriál o programovacím jazyku Rust: Základní (primitivní) datové typy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09">https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/#k09</a>
</li>

<li>Seriál o programovacím jazyku Rust: Vytvoření „řezu“ z pole<br />
<a href="https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06">https://www.root.cz/clanky/prace-s-poli-v-programovacim-jazyku-rust/#k06</a>
</li>

<li>Seriál o programovacím jazyku Rust: Řezy (slice) vektoru<br />
<a href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05">https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/#k05</a>
</li>

<li>Printf Format Strings<br />
<a href="https://www.cprogramming.com/tutorial/printf-format-strings.html">https://www.cprogramming.com/tutorial/printf-format-strings.html</a>
</li>

<li>Java: String.format<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-</a>
</li>

<li>Java: format string syntax<br />
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a>
</li>

<li>Selectors<br />
<a href="https://golang.org/ref/spec#Selectors">https://golang.org/ref/spec#Selectors</a>
</li>

<li>Calling Go code from Python code<br />
<a href="http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/">http://savorywatt.com/2015/09/18/calling-go-code-from-python-code/</a>
</li>

<li>Go Data Structures: Interfaces <br />
<a href="https://research.swtch.com/interfaces">https://research.swtch.com/interfaces</a>
</li>

<li>How to use interfaces in Go<br />
<a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go</a>
</li>

<li>Interfaces in Go (part I)<br />
<a href="https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c">https://medium.com/golangspec/interfaces-in-go-part-i-4ae53a97479c</a>
</li>

<li>Part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>What about Trait support in Golang?<br />
<a href="https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/">https://www.reddit.com/r/golang/comments/8mfykl/what_about_trait_support_in_golang/</a>
</li>

<li>Don't Get Bitten by Pointer vs Non-Pointer Method Receivers in Golang<br />
<a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/">https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/</a>
</li>

<li>Control Flow<br />
<a href="https://en.wikipedia.org/wiki/Control_flow">https://en.wikipedia.org/wiki/Control_flow</a>
</li>

<li>Structured programming<br />
<a href="https://en.wikipedia.org/wiki/Structured_programming">https://en.wikipedia.org/wiki/Structured_programming</a>
</li>

<li>Control Structures<br />
<a href="https://www.golang-book.com/books/intro/5">https://www.golang-book.com/books/intro/5</a>
</li>

<li>Control structures - Go if else statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html">http://golangtutorials.blogspot.com/2011/06/control-structures-if-else-statement.html</a>
</li>

<li>Control structures - Go switch case statement<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-switch-case.html</a>
</li>

<li>Control structures - Go for loop, break, continue, range<br />
<a href="http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html">http://golangtutorials.blogspot.com/2011/06/control-structures-go-for-loop-break.html</a>
</li>

<li>Goroutine IDs<br />
<a href="https://blog.sgmansfield.com/2015/12/goroutine-ids/">https://blog.sgmansfield.com/2015/12/goroutine-ids/</a>
</li>

<li>Different ways to pass channels as arguments in function in go (golang)<br />
<a href="https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang">https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang</a>
</li>

<li>justforfunc #22: using the Go execution tracer<br />
<a href="https://www.youtube.com/watch?v=ySy3sR1LFCQ">https://www.youtube.com/watch?v=ySy3sR1LFCQ</a>
</li>

<li>Single Function Exit Point<br />
<a href="http://wiki.c2.com/?SingleFunctionExitPoint">http://wiki.c2.com/?SingleFunctionExitPoint</a>
</li>

<li>Entry point<br />
<a href="https://en.wikipedia.org/wiki/Entry_point">https://en.wikipedia.org/wiki/Entry_point</a>
</li>

<li>Why does Go have a GOTO statement?!<br />
<a href="https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/">https://www.reddit.com/r/golang/comments/kag5q/why_does_go_have_a_goto_statement/</a>
</li>

<li>Effective Go<br />
<a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a>
</li>

<li>GoClipse: an Eclipse IDE for the Go programming language<br />
<a href="http://goclipse.github.io/">http://goclipse.github.io/</a>
</li>

<li>GoClipse Installation<br />
<a href="https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation">https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation</a>
</li>

<li>The zero value of a slice is not nil<br />
<a href="https://stackoverflow.com/questions/30806931/the-zero-value-of-a-slice-is-not-nil">https://stackoverflow.com/questions/30806931/the-zero-value-of-a-slice-is-not-nil</a>
</li>

<li>Go-tcha: When nil != nil<br />
<a href="https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic">https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic</a>
</li>

<li>Nils in Go<br />
<a href="https://www.doxsey.net/blog/nils-in-go">https://www.doxsey.net/blog/nils-in-go</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

