<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Instrukční sada AArch64</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Instrukční sada AArch64</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na předchozí článek, v němž jsme si řekli základní informace o stále relativně nové architektuře AArch64, dnes navážeme, protože se budeme věnovat popisu instrukční sady těchto čipů. Popíšeme si i některé rozdíly mezi instrukcemi AArch64 a původní instrukční sadou ARM 32 (A32).</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Instrukční sada AArch64</a></p>
<p><a href="#k02">*** 2. Operační kódy instrukcí</a></p>
<p><a href="#k03">3. Instrukce typu Load-Store</a></p>
<p><a href="#k04">*** 4. Load-Store pro dvojici registrů</a></p>
<p><a href="#k05">5. Nepodmíněné skoky a skoky do subrutiny (branch and link)</a></p>
<p><a href="#k06">6. Podmíněné skoky</a></p>
<p><a href="#k07">7. Základní aritmetické instrukce</a></p>
<p><a href="#k08">8. Násobení a dělení</a></p>
<p><a href="#k09">9. Logické instrukce</a></p>
<p><a href="#k10">10. Znaménkové rozšíření operandu či rozšíření o nuly</a></p>
<p><a href="#k11">11. Aritmetické a bitové posuny, bitová rotace</a></p>
<p><a href="#k12">12. Podmíněné zpracování dat</a></p>
<p><a href="#k13">13. Podmíněný výběr operandu</a></p>
<p><a href="#k14">14. Další instrukce s&nbsp;podmínkou</a></p>
<p><a href="#k15">*** 15. Extrakce dat</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Instrukční sada AArch64</h2>

<table>
<tr><th>Skupina</th><th>Další dělení</th></tr>
<tr><td>Load-Store</td><td><a href="#k03">Load-Store pro jeden registr</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#k04">Load-Store pro dvojici registrů</a></td></tr>
<tr><td>&nbsp;</td><td>Prefetch</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Skoky</td><td><a href="#k05">Nepodmíněné skoky</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#k05">Skoky do subrutiny</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#k05">Nepodmíněný skok na adresu v&nbsp;registru</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#k06">Podmíněné skoky</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ALU operace</td><td><a href="#k07">Základní aritmetické instrukce</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#k08">Násobení a dělení</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#k09">Logické instrukce</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#k10">Znaménkové rozšíření operandu či rozšíření o nuly</a></td></tr>
<tr><td>&nbsp;</td><td>Bitové operace</td></tr>
<tr><td>&nbsp;</td><td><a href="#k11">Bitové posuny</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#k11">Aritmetické posuny</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#k12">Podmíněné zpracování dat</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#k13">Podmíněný výběr operandu</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#k14">Další instrukce s&nbsp;podmínkou</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#k15">Extrakce dat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>FP operace</td><td>Přenos operandů mezi registry</td></tr>
<tr><td>&nbsp;</td><td>Konverze mezi různými formáty</td></tr>
<tr><td>&nbsp;</td><td>Převod na celá čísla (zaokrouhlení)</td></tr>
<tr><td>&nbsp;</td><td>Základní aritmetické operace</td></tr>
<tr><td>&nbsp;</td><td>Výpočet minima a maxima</td></tr>
<tr><td>&nbsp;</td><td>MAC (Multiply Accumulate)</td></tr>
<tr><td>&nbsp;</td><td>Porovnání operandů</td></tr>
<tr><td>&nbsp;</td><td>Podmíněný výběr operandu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>SIMD operace</td><td>Aritmetické operace se skaláry</td></tr>
<tr><td>&nbsp;</td><td>Aritmetické operace s&nbsp;vektory</td></tr>
<tr><td>&nbsp;</td><td>Permutace vektorů</td></tr>
<tr><td>&nbsp;</td><td>Konverze dat</td></tr>
<tr><td>&nbsp;</td><td>Instrukce z&nbsp;crypto extension (patří do SIMD)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Systémové instrukce</td><td>Zpracování výjimek</td></tr>
<tr><td>&nbsp;</td><td>Přístup k&nbsp;systémovým registrům</td></tr>
<tr><td>&nbsp;</td><td>Implementace bariér</td></tr>
<tr><td>&nbsp;</td><td>Instrukce pro jádro systému</td></tr>
</table>


<p><a name="k02"></a></p>
<h2 id="k02">2. Operační kódy instrukcí</h2>

<p></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instrukce typu Load-Store</h2>

<p>Jak je u RISCové architektury obvyklé, nalezneme v&nbsp;instrukční sadě i
několik instrukcí určených pro načítání dat z&nbsp;paměti do registrů a naopak
pro ukládání obsahu registrů do paměti. Navíc některé instrukce umožňují práci
nejenom s&nbsp;32bitovými a 64bitovými slovy, ale i s&nbsp;menšími bloky dat
&ndash; s&nbsp;bajty a šestnáctibitovými &bdquo;půlslovy&ldquo;:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>LDR</td><td>načtení 32bitového či 64bitového registru z&nbsp;paměti</td></tr>
<tr><td>2</td><td>LDRB</td><td>načtení bajtu a s&nbsp;rozšířením na slovo (doplňují se nuly)</td></tr>
<tr><td>3</td><td>LDRSB</td><td>načtení bajtu se znaménkovým rozšířením</td></tr>
<tr><td>4</td><td>LDRH</td><td>načtení šestnáctibitového &bdquo;půlslova&ldquo; s&nbsp;rozšířením o nuly</td></tr>
<tr><td>5</td><td>LDRSH</td><td>načtení šestnáctibitového &bdquo;půlslova&ldquo; se znaménkovým rozšířením</td></tr>
<tr><td>6</td><td>LDRSW</td><td>načtení 32bitového slova se znaménkovým rozšířením do 64bitového registru</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>STR</td><td>uložení 32bitového či 64bitového registru do paměti</td></tr>
<tr><td>8</td><td>STRB</td><td>uložení bajtu z&nbsp;vybraného 32bitového registru</td></tr>
<tr><td>9</td><td>STRH</td><td>uložení šestnáctibitového &bdquo;půlslova&ldquo; z&nbsp;vybraného 32bitového registru</td></tr>
</table>

<p>Poznámka: zdánlivě chybějící instrukce <strong>LDRW</strong> a
<strong>STRW</strong> jsou již obsaženy v&nbsp;základních instrukcích
<strong>LDR</strong> a <strong>STR</strong> pokud použijeme 32bitový registr (u
<strong>LDR</strong> se horních 32 bitů vynuluje).</p>

<p>Mezi podporované adresovací režimy patří i použití offsetu vůči vybranému
registru či SP.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Load-Store pro dvojici registrů</h2>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>LDP</td><td>načtení registrového páru</td></tr>
<tr><td>2</td><td>LDPSW</td><td>načtení dvou 32bitových slov, jejich znaménkové rozšíření a uložení do dvojice registrů</td></tr>
<tr><td>3</td><td>STP</td><td>uložení registrového páru</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>LDNP</td><td>jako LDP, ale paměťová oblast není považována za dočasnou (temporal)</td></tr>
<tr><td>5</td><td>STNP</td><td>jako STP, ale paměťová oblast není považována za dočasnou (temporal)</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Nepodmíněné skoky a skoky do subrutiny (branch with link)</h2>

<p>U instrukční sady AArch64 je zajímavé (a současně i velmi užitečné), že
základní skoková instrukce <strong>B</strong> neprovádí skok na zadanou
absolutní adresu, ale na adresu relativní vůči aktuální hodnotě PC. Rozsah
skoku je v&nbsp;takovém případě &pm;128 MB; větší konstantu není možné
v&nbsp;dané konfiguraci instrukčního slova uložit. Dále pak instrukční soubor
obsahuje instrukci pro skok do podprogramu s&nbsp;uložením návratové adresy do
registru X30 (nikoli na zásobník, používáme RISCový čip) a skok na absolutní
adresu uloženou ve vybraném registru. Tato instrukce existuje ve dvou
variantách, které se od sebe odlišují pouze hintem pro CPU, zda se právě
realizuje návrat z&nbsp;podprogramu (subrutiny) či obyčejný skok:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>B</td><td>skok na adresu vypočtenou z&nbsp;offsetu vůči PC v&nbsp;rozsahu &pm;128 MB</td></tr>
<tr><td>2</td><td>BL</td><td>branch and link, stejné jako předchozí instrukce, ovšem původní hodnota PC se uloží do X30</td></tr>
<tr><td>3</td><td>BR</td><td>skok na adresu uloženou v&nbsp;registru s&nbsp;hintem, že se nejedná o výskok z&nbsp;podprogramu</td></tr>
<tr><td>4</td><td>RET</td><td>jako BR, ovšem s&nbsp;hintem, že se jedná o výskok z&nbsp;podprogramu</td></tr>
<tr><td>5</td><td>BRL</td><td>kombinace BR + BL, tj.&nbsp;skok na adresu uloženou v&nbsp;registru + původní PC do X30</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Podmíněné skoky</h2>

<p>Jak jsme se již dozvěděli <a
href="https://www.root.cz/clanky/64bitove-mikroprocesory-s-architekturou-aarch64/">v&nbsp;předchozí
části</a> <a href="https://www.root.cz/serialy/co-se-deje-v-pocitaci/">tohoto
seriálu</a>, je instrukční sada AArch64 hned v&nbsp;několika ohledech odlišná
od původní 32bitové RISCové instrukční sady ARM32 (či zkráceně pouze A32).
Zásadní a na první pohled viditelná odlišnost spočívá v&nbsp;tom, že se
zredukoval počet těch strojových instrukcí, u nichž je možné použít podmínkové
bity. Jen ve stručnosti si připomeňme, že v&nbsp;instrukční sadě ARM32 jsou
v&nbsp;každém instrukčním slovu (každé má bez výjimky konstantní šířku třiceti
dvou bitů) rezervovány čtyři nejvyšší bity, v&nbsp;nichž je zapsán kód
podmínky, při jejímž splnění se instrukce provede. Díky této vlastnosti bylo
možné v&nbsp;mnoha algoritmech zredukovat počet podmíněných skoků, což je
v&nbsp;případě (dnes už nejenom) RISCových procesorů poměrně důležité.</p>

*** image ***
<p><i>Obrázek 1: Formáty instrukčních slov u původní 32bitové architektury ARM.
Povšimněte si, že v&nbsp;každém instrukčním slovu jsou nejvyšší čtyři bity
vyhrazeny pro uložení kódu podmínky.</i></p>

<p>Všechny podmínky jsou vyhodnoceny na základě hodnoty jednoho či (častěji)
kombinací většího množství příznaků (<i>flags</i>). První sada podmínkových
kódů se používá pro provedení či naopak neprovedení instrukce na základě
hodnoty jednoho z&nbsp;příznakových bitů <strong>Z (zero)</strong>, <strong>V
(overflow)</strong> či <strong>N (negative)</strong>. Poslední podmínkový kód
z&nbsp;této skupiny má název <strong>AL</strong> (<i>Any/Always</i>) a značí,
že se instrukce provede v&nbsp;každém případě. Tento podmínkový kód se tudíž
většinou v&nbsp;assembleru ani nezapisuje, protože je považován za
implicitní:</p>

<table>
<tr><th>Kód</th><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>0000</td><td>EQ</td><td>Z == 1</td><td>rovnost při porovnání či nulový výsledek poslední ALU operace</td></tr>
<tr><td>0001</td><td>NE</td><td>Z == 0</td><td>nerovnost při porovnání či nenulový výsledek poslední ALU operace</td></tr>
<tr><td>0100</td><td>MI</td><td>N == 1</td><td>výsledek je záporný</td></tr>
<tr><td>0101</td><td>PL</td><td>N == 0</td><td>výsledek je kladný či 0</td></tr>
<tr><td>0110</td><td>VS</td><td>V == 1</td><td>nastalo přetečení</td></tr>
<tr><td>0111</td><td>VC</td><td>V == 0</td><td>nenastalo přetečení</td></tr>
<tr><td>1110</td><td>AL</td><td>Any/Always</td><td>většinou se nezapisuje, implicitní podmínka</td></tr>
</table>

<p>Další čtyři podmínkové kódy se většinou používají při porovnávání dvou
celých hodnot bez znaménka (<i>unsigned integer</i>). V&nbsp;těchto případech
se testují stavy příznakových bitů <strong>C (carry)</strong> a <strong>Z
(zero)</strong>, přesněji řečeno kombinace těchto bitů:</p>

<table>
<tr><th>Kód </th><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>0010</td><td>CS/HS</td><td>C == 1</td><td>&ge;</td></tr>
<tr><td>0011</td><td>CC/LO</td><td>C == 0</td><td>&lt;</td></tr>
<tr><td>1000</td><td>HI</td><td>C == 1 &amp; Z == 0</td><td>&gt;</td></tr>
<tr><td>1001</td><td>LS</td><td>C == 0 | Z == 1 </td><td>&le;</td></tr>
</table>

<p>Poslední čtyři podmínkové kódy se používají pro porovnávání hodnot se
znaménkem (signed). V&nbsp;těchto případech se namísto příznakových bitů
<strong>(C) carry</strong> a <strong>(Z) zero</strong> testují kombinace bitů
<strong>(N) negative</strong>, <strong>(V) overflow</strong> a <strong>(Z)
zero</strong>:</p>

<table>
<tr><th>Kód </th><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>1010</td><td>GE</td><td>N == V</td><td>&ge;</td></tr>
<tr><td>1011</td><td>LT</td><td>N &ne; V </td><td>&lt;</td></tr>
<tr><td>1100</td><td>GT</td><td>Z = 0, N = V </td><td>&gt;</td></tr>
<tr><td>1101</td><td>LE</td><td>Z = 1, N &ne; V</td><td>&le;</td></tr>
</table>

<p>Procesory s&nbsp;architekturou AArch64 sice používají shodné podmínkové
bity, ty jsou ovšem použity jen v&nbsp;několika pečlivě vybraných instrukcích.
Příznak přetečení je, podobně jako u mnoha dalších typů procesorů, používán při
aritmetických operacích (ovšem ne implicitně &ndash; jen u instrukcí končících
na <strong>S</strong> &ndash; set) a testy podmínkových bitů lze provádět
především u podmíněných skoků, tj.&nbsp;u instrukcí, jejichž mnemotechnická
zkratka začíná znakem <strong>B</strong> od slova &bdquo;Branch&ldquo;.
Rozeznáváme následující typy nepodmíněných podmíněných skoků:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Alternativní zápis</th></tr>
<tr><td>1</td><td>B</td><td>BAL</td></tr>
<tr><td>2</td><td>B.EQ</td><td>BEQ</td></tr>
<tr><td>3</td><td>B.NE</td><td>BNE</td></tr>
<tr><td>4</td><td>B.MI</td><td>BMI</td></tr>
<tr><td>5</td><td>B.PL</td><td>BPL</td></tr>
<tr><td>6</td><td>B.VS</td><td>BVS</td></tr>
<tr><td>7</td><td>B.VC</td><td>BVC</td></tr>
<tr><td>8</td><td>B.CS</td><td>BCS</td></tr>
<tr><td>9</td><td>B.CC</td><td>BCC</td></tr>
<tr><td>10</td><td>B.HI</td><td>BHI</td></tr>
<tr><td>11</td><td>B.LS</td><td>BLS</td></tr>
<tr><td>12</td><td>B.GE</td><td>BGE</td></tr>
<tr><td>13</td><td>B.LT</td><td>BLT</td></tr>
<tr><td>14</td><td>B.GT</td><td>BGT</td></tr>
<tr><td>15</td><td>B.LE</td><td>BLE</td></tr>
</table>

<p>Poznámka: alternativní zápis je podporován například GNU Assemblerem,
většinou však můžete používat obě varianty zápisu.</p>

<p>Další dva typy skoků jsou odvozeny od instrukcí, které známe
z&nbsp;instrukční sady Thumb. Dochází zde k&nbsp;porovnání vybraného pracovního
registru s&nbsp;nulou:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>CBZ </td><td>Compare and Branch if Zero</td></tr>
<tr><td>2</td><td>CBNZ</td><td>Compare and Branch if Not Zero</td></tr>
</table>

<p>Existují ještě další dvě instrukce pro podmíněné skoky, které se jmenují
<strong>TBZ</strong> (<i>Test and Branch if Zero</i>) a <strong>TBNZ</strong>
(<i>Test and Branch if Not Zero</i>). Ty provádí test hodnoty vybraného bitu
registru na nulu:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>TBZ </td><td>Test and Branch if Zero</td></tr>
<tr><td>2</td><td>TBNZ</td><td>Test and Branch if Not Zero</td></tr>
</table>

<p>Způsob zápisu těchto instrukcí je následující:</p>

<pre>
TBZ  Xn, #konstanta, návěští
TBZ  Wn, #konstanta, návěští
TBNZ Xn, #konstanta, návěští
TBNZ Wn, #konstanta, návěští
</pre>

<p>Konstanta má šířku pouze šest bitů, protože je v&nbsp;ní uložen index bitu
pracovního registru, který se testuje na nulu či jedničku (u registrů Wn by
stačilo jen pět bitů). V&nbsp;případě instrukce <strong>TBZ</strong> &ndash;
pokud je n-tý bit registru <strong>Xn/Wn</strong> nastavený na nulu, provede se
skok, v&nbsp;opačném případě se řízení přenese na další instrukci.
V&nbsp;případě instrukce <strong>TBNZ</strong> je bit testován na jedničku.
Vzhledem k&nbsp;tomu, že v&nbsp;instrukčním slovu je nutné kromě adresy cíle
(návěští) specifikovat i číslo pracovního registru a index bitu, je tento typ
skoku omezen na rozsah &pm;32kB, což by ovšem v&nbsp;praxi mělo být více než
dostačující (v&nbsp;opačném případě lze <strong>TBZ/TBNZ</strong> zkombinovat
s&nbsp;absolutním skokem <strong>B</strong>).</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Základní aritmetické instrukce</h2>

<p>Mezi základní aritmetické instrukce samozřejmě patří součet a rozdíl.
Existují vždy čtyři varianty každé z&nbsp;těchto operací, které se od sebe liší
podle toho, zda se při výpočtu nastavují příznaky (všechny čtyři) a zda se po
součtu či rozdílu ještě k&nbsp;výsledku přičte předchozí hodnota příznaku
<i>carry</i>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>ADD</td><td>32bitový či 64bitový součet</td></tr>
<tr><td>2</td><td>ADC</td><td>32bitový či 64bitový součet s&nbsp;carry</td></tr>
<tr><td>3</td><td>ADDS</td><td>jako ADD, ovšem navíc nastaví příznakové bity</td></tr>
<tr><td>4</td><td>ADCS</td><td>jako ADC, ovšem navíc nastaví příznakové bity</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>SUB</td><td>32bitový či 64bitový rozdíl</td></tr>
<tr><td>6</td><td>SBC</td><td>rozdíl s&nbsp;přičtením carry a odečtením jedničky</td></tr>
<tr><td>7</td><td>SUBS</td><td>jako SUB, ovšem navíc nastaví příznakové bity</td></tr>
<tr><td>8</td><td>SBCS</td><td>jako SBC, ovšem navíc nastaví příznakové bity</td></tr>
</table>

<p>Kromě toho existuje hned několik instrukčních aliasů, které je možné
používat v&nbsp;assemblerech a které jsou rozpoznány i v&nbsp;disassemblerech a
debuggerech. Tyto aliasy využívají registr <strong>WZR</strong> (32 bitů) či
<strong>XZR</strong> (64 bitů). Připomeňme si, že tento registr je při čtení
vždy nulový, což je v&nbsp;tomto případě výhodné, protože vlastně zadarmo
získáme velké množství užitečných instrukcí:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>NEG</td><td>alias pro SUB op1, xZR, op2 (op1 = 0 - op2)</td></tr>
<tr><td>2</td><td>NEGS</td><td>alias pro SUBS op1, xZR, op2 (op1 = 0 - op2 + nastavení příznaků)</td></tr>
<tr><td>3</td><td>NGC</td><td>alias pro SBC op1, xZR, op2 (op1 = 0 - op2 + carry - 1)</td></tr>
<tr><td>4</td><td>NGCS</td><td>kombinace předchozích dvou instrukcí</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>CMP</td><td>alias pro SUBS xZR, op1, op2 (tj.výsledek se zahodí, protože do registrů WZR/XZR se nezapisuje)</td></tr>
<tr><td>6</td><td>CMN</td><td>alias pro ADDS xZR, op1, op2 (dtto jako předchozí instrukce)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<td><td>7</td><td>MOV</td><td>alias pro ADD reg1, reg2, #0 (platí je při přesunu dat mezi registry)</td></td>
</table>

<p>Poznámka: v&nbsp;praxi se setkáte především s&nbsp;aliasy
<strong>CMP</strong>, <strong>CMN</strong> a hlavně pak <strong>MOV</strong>
(resp.&nbsp;přesněji řečeno je toto jedna z&nbsp;mnoha variant pseudoinstrukce
<strong>MOV</strong>).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Násobení a dělení</h2>

<p>U čipů AArch64 nalezneme násobičku a děličku, která dokáže vynásobit jak
32bitové, tak i 64bitové operandy. Mezi podporovanými instrukcemi najdeme i
obdobu DSP instrukcí Multiply-Accumulate, ovšem s&nbsp;tím rozdílem, že se
namísto akumulátoru může použít odlišný vstupní a odlišný výstupní registr, což
konkrétně znamená, že DSP operace:</p>

<pre>
acc += op2 &times; op3
</pre>

<p>dokáže AArch64 provést:</p>

<pre>
op1 = op2 &times; op3 + op4
</pre>

<p>Podívejme se nyní, které instrukce provádí násobička a dělička:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>MUL</td><td>32bitové či 64bitové násobení</td></tr>
<tr><td>2</td><td>MADD</td><td>výsledek = op2 &times; op3 + op4</td></tr>
<tr><td>3</td><td>MSUB</td><td>výsledek = op4 - op2 &times; op3</td></tr>
<tr><td>4</td><td>MNEG</td><td>výsledek = - op2 &times; op3</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>SMULL</td><td>násobení hodnot se znaménkem (32&times;32 &rarr; 64)</td></tr>
<tr><td>6</td><td>SMADDL</td><td>MADD hodnot se znaménkem pro (32&times;32 &rarr; 64)</td></tr>
<tr><td>7</td><td>SMSUBL</td><td>MSUB hodnot se znaménkem pro (32&times;32 &rarr; 64)</td></tr>
<tr><td>8</td><td>SMNEGL</td><td>MNEG hodnot se znaménkem pro (32&times;32 &rarr; 64)</td></tr>
<tr><td>9</td><td>SMULH</td><td>násobení 64&times;64, z&nbsp;výsledku se vezme jen horních 64 bitů ze 128</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>UMULL</td><td>násobení hodnot bez znaménka (32&times;32 &rarr; 64)</td></tr>
<tr><td>11</td><td>UMADDL</td><td>MADD hodnot bez znaménka pro (32&times;32 &rarr; 64)</td></tr>
<tr><td>12</td><td>UMSUBL</td><td>MSUB hodnot bez znaménka pro (32&times;32 &rarr; 64)</td></tr>
<tr><td>13</td><td>UMNEGL</td><td>MNEG hodnot bez znaménka pro (32&times;32 &rarr; 64)</td></tr>
<tr><td>14</td><td>UMULH</td><td>násobení 64&times;64, z&nbsp;výsledku se vezme jen horních 64 bitů ze 128</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>SDIV</td><td>32bitové či 64bitové dělení hodnot se znaménkem</td></tr>
<tr><td>16</td><td>UDIV</td><td>32bitové či 64bitové dělení hodnot bez znaménka</td></tr>
</table>

<p>Poznámka: ve skutečnosti je instrukce <strong>MUL</strong>, tedy
&bdquo;běžné násobení&ldquo; aliasem pro instrukci <strong>MADD</strong>,
v&nbsp;níž je třetím vstupním operandem registr <strong>WZR</strong> či
<strong>XZR</strong>, tedy &bdquo;konstantní nula&ldquo;. Totéž platí pro
instrukci <strong>MNEG</strong>, která vznikla z&nbsp;instrukce
<strong>MSUB</strong>, u níž je opět posledním vstupním operandem nulový
registr.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Logické instrukce</h2>

<p>Nesmíme samozřejmě zapomenout ani na instrukce pro provedení logických
operací. Nalezneme zde klasickou trojici instrukcí pro logický součin bit po
bitu, logický součet bit po bitu i logickou nonekvivalenci a navíc i instrukce,
v&nbsp;nichž je druhý vstupní operand negován. Navíc se u všech instrukcí možné
druhý operand i posunout o konstantu uloženou v&nbsp;instrukčním slovu:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>AND</td><td>logický součin bit po bitu</td></tr>
<tr><td>2</td><td>ANDS</td><td>logický součin bit po bitu + nastavení příznaků N a Z, vynulování C a V</td></tr>
<tr><td>3</td><td>ORR</td><td>logický součet bit po bitu</td></tr>
<tr><td>4</td><td>EOR</td><td>logická nonekvivalence bit po bitu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>ORN</td><td>logický součet bit po bitu, druhý vstupní operand je však negován</td></tr>
<tr><td>6</td><td>EON</td><td>logická nonekvivalence bit po bitu, druhý vstupní operand je však negován</td></tr>
</table>

<p>Povšimněte si, že pouze instrukce <strong>ANDS</strong> nastavuje
příznaky.</p>

<p>Podobně jako u aritmetických operací, i u operací logických lze využít
registru <strong>WZR</strong> a <strong>XZR</strong> pro vytvoření instrukčních
aliasů, například druhého aliasu <strong>MOV</strong> (první byl implementován
přes <strong>ADD</strong>), instrukce <strong>MOVI</strong> (načtení malé
konstanty) a zejména pak užitečné pseudoinstrukce <strong>TST</strong> známé i
z&nbsp;dalších architektur:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>MOVI</td><td>alias pro ORR reg, xZR, konstanta (tj.&nbsp;provede se 0 or konstanta)</td></tr>
<tr><td>2</td><td>MOV</td><td>alias pro ORR reg, xZR, reg (tj.&nbsp;provede se 0 or registr)</td></tr>
<tr><td>3</td><td>TST</td><td>alias pro ANDS xZR, .., .. (výsledek AND se nikam neuloží, pouze se nastaví příznaky)</td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Znaménkové rozšíření operandu či rozšíření o nuly</h2>

<p>Některé instrukce slouží k&nbsp;manipulaci se šestnáctibitovými konstantami,
které se musí nějakým způsobem rozšířit na konstanty 32bitové a 64bitové. Jedná
se o následující trojici instrukcí, které vždy obsahují jak již zmíněnou
šestnáctibitovou konstantu, tak i druhou konstantu reprezentující posun
doleva:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>MOVZ</td><td>16bitová konstanta může být posunuta doleva a uložena do registru</td></tr>
<tr><td>2</td><td>MOVN</td><td>jako předchozí instrukce, ale pracuje se s&nbsp;negací konstanty (po posunutí)</td></tr>
<tr><td>3</td><td>MOVK</td><td>načtení 16bitové konstanty, její posun a umístění do registru (bez ovlivnění dalších bitů)</td></tr>
</table>

<p>Poznámka: při práci v&nbsp;assembleru většinou stačí použít pseudoinstrukci
<strong>MOV</strong>, kterou assembler sám dokáže rozložit na ty instrukce,
které CPU skutečně dokáže zpracovat.</p>

<p>Další šestice instrukcí dokáže provést znaménkové či naopak bezznaménkové
rozšíření bajtu, šestnáctibitového slova (u AArch64 se používá termín
<i>halfword</i>) či 32bitového slova (<i>word</i>) na 64bitovou hodnotu.
Bezznaménkové rozšíření pouze vynuluje horní bity registru:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>SXTB</td><td>alias pro SBFM, znaménkové rozšíření bajtu (B=byte)</td></tr>
<tr><td>2</td><td>SXTH</td><td>alias pro SBFH, znaménkové rozšíření 16bitového slova (H=halfword)</td></tr>
<tr><td>3</td><td>SXTW</td><td>alias pro SBFH, znaménkové rozšíření 32bitového slova (W=word)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>UXTB</td><td>alias pro UBFM, bezznaménkové rozšíření bajtu (B=byte)</td></tr>
<tr><td>5</td><td>UXTH</td><td>alias pro UBFH, bezznaménkové rozšíření 16bitového slova (H=halfword)</td></tr>
<tr><td>6</td><td>UXTW</td><td>alias pro UBFH, bezznaménkové rozšíření 32bitového slova (W=word)</td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Aritmetické a bitové posuny, bitová rotace</h2>

<p>Množina instrukcí navržených pro provedení operací aritmetického či bitového
(logického) posunu je celkem přehledná. Povšimněte si navíc poslední instrukce
<strong>ROR</strong> určené pro bitovou rotaci. Neexistuje zde rotace vlevo,
protože ta samozřejmě odpovídá rotaci vpravo, ovšem o odlišnou hodnotu
(odečtenou od 63 či 31):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>ASR</td><td>aritmetický posun doprava až o 31/63 bitů</td></tr>
<tr><td>2</td><td>LSL</td><td>logický posun doleva až o 31/63 bitů</td></tr>
<tr><td>3</td><td>LSR</td><td>logický posun doprava až o 31/63 bitů</td></tr>
<tr><td>4</td><td>ROR</td><td>rotace doprava až o 31/63 bitů</td></tr>
</table>

<p>U všech předchozích instrukcí byl posun specifikován konstantou, zatímco u
dalších čtyř instrukcí je posun uložen v&nbsp;registru (druhý vstupní operand).
Hodnota tohoto registru však není použita přímo, protože se v&nbsp;úvahu bere
jen posledních pět či šest bitů podle toho, zda se jedná o 32bitovou či
64bitovou operaci:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>ASRV</td><td>aritmetický posun doprava až o 31/63 bitů</td></tr>
<tr><td>2</td><td>LSLV</td><td>logický posun doleva až o 31/63 bitů</td></tr>
<tr><td>3</td><td>LSRV</td><td>logický posun doprava až o 31/63 bitů</td></tr>
<tr><td>4</td><td>RORV</td><td>rotace doprava až o 31/63 bitů</td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Podmíněné zpracování dat</h2>

<p>V&nbsp;této kapitole se seznámíme s&nbsp;následujícími instrukcemi:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>CSET </td><td>Conditional Set</td></tr>
<tr><td>2</td><td>CSETM</td><td>Conditional Set Mask</td></tr>
</table>

<p>První zcela novou instrukcí uvedenou až na architektuře AArch64, je
instrukce nazvaná <strong>CSET</strong> neboli <i>Conditional Set</i>. Tato
instrukce vlastně přímo odpovídá požadavkům kladeným na datový typ
<i>boolean</i> v&nbsp;mnoha programovacích jazycích, v&nbsp;nichž je hodnota
<i>true</i> interně reprezentována jedničkou a hodnota <i>false</i> nulou. Tato
instrukce existuje ve dvou variantách, přičemž první varianta pracuje
s&nbsp;32bitovým a druhá varianta s&nbsp;64bitovým operandem):</p>

<pre>
CSET Wd, condition
CSET Xd, condition
</pre>

<p>Například:</p>

<pre>
CSET W3, EQ
CSET W4, MI
CSET X5, HI
</pre>

<p>Tato instrukce pracuje následujícím způsobem &ndash; v&nbsp;případě, že je
podmínka zapsaná ve druhém operandu <i>cond</i> splněna, uloží se do cílového
registru <strong>Wd</strong> či do registru <strong>Xd</strong> hodnota 1.
Pokud podmínka naopak splněna není, uloží se do registru <strong>Wd</strong> či
<strong>Xd</strong> hodnota 0:</p>

<pre>
cíl = condition ? 1 : 0;
</pre>

<p>Ve skutečnosti se v&nbsp;případě <strong>CSET</strong> jedná o alias pro
instrukci <strong>CSINC</strong> popsanou dále (podmínka ovšem musí být
v&nbsp;tomto případě negována):</p>

<pre>
CSINC Wd, WZR, WZR, invert(condition)
CSINC Xd, XZR, XZR, invert(condition)
</pre>

<p>neboli:</p>

<pre>
cíl = invert(condition) ? 0 : 0+1;
</pre>

<p>Opět zde tedy využíváme vlastnosti registru <strong>WZR</strong> a
<strong>XZR</strong>.</p>

<p>V&nbsp;některých případech je však nutné ukládat pravdivostní hodnoty
odlišným způsobem &ndash; <i>true</i> bude reprezentováno hodnotou, v&nbsp;níž
jsou všechny bity 32bitového či 64bitového slova nastaveny na jedničku
(v&nbsp;případě celých čísel se znaménkem to odpovídá hodnotě -1), <i>false</i>
naopak hodnotou, v&nbsp;níž jsou všechny bity nulové. V&nbsp;tomto případě lze
pro nastavení namísto <strong>CSET</strong> použít instrukci
<strong>CSETM</strong>:</p>

<pre>
CSETM Wd, condition
CSETM Xd, condition
</pre>

<p>Ve vyšším programovacím jazyce by bylo možné napsat:</p>

<pre>
cíl = condition ? -1 : 0;
</pre>

<p>Poznámka: u 32bitového registru odpovídá -1 hodnotě 0xffff&nbsp;ffff, u
64bitového registru pak hodnotě 0xffff&nbsp;ffff&nbsp;ffff&nbsp;ffff.</p>

<p>Opět se v&nbsp;tomto případě jedná o aliasy, tentokrát ovšem na instrukci
<strong>CSINV</strong>:</p>

<pre>
CSINV Wd, WZR, WZR, invert(condition)
CSINV Xd, XZR, XZR, invert(condition)
</pre>

<p>Poznámka: slovo &bdquo;mask&ldquo; v&nbsp;názvu instrukce skutečně poměrně
přesně odpovídá jednomu způsobu použití, protože pokud platí <i>true=-1</i> a
<i>false=0</i>, lze s&nbsp;těmito hodnotami provádět logický součin a součet
bit po bitu, a to i v&nbsp;případě, kdy je druhým operandem odlišná
hodnota.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Podmíněný výběr operandu</h2>

<p>Mezi další instrukce, v&nbsp;nichž se vyhodnocuje podmínka, patří:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>CSEL </td><td>Conditional Select</td></tr>
<tr><td>2</td><td>CSINV</td><td>Conditional Select Invert</td></tr>
<tr><td>3</td><td>CSINC</td><td>Conditional Select Increment</td></tr>
<tr><td>4</td><td>CSNEG</td><td>Conditional Select Negate</td></tr>
</table>

<p>Užitečnou instrukcí s&nbsp;podmínkou je instrukce zapisovaná mnemotechnickým
kódem <strong>CSEL</strong> neboli <i>Conditional Select</i>. I tato instrukce
existuje ve dvou variantách &ndash; 32bitové a 64bitové:</p>

<pre>
CSEL Wd, Wn, Wm, condition
CSEL Xd, Xn, Xm, condition
</pre>

<p>Tato instrukce pracuje následovně: pokud je podmínka splněna, uloží se do
cílového registru <strong>Wd</strong> či <strong>Xd</strong> hodnota
z&nbsp;prvního zdrojového registru <strong>Wn</strong> nebo
<strong>Xn</strong>. Pokud podmínka splněna není, je do cílového registru
<strong>Wd/Xd</strong> uložena hodnota z&nbsp;druhého zdrojového registru
<strong>Wm/Xm</strong>.</p>

<p>Instrukce <strong>CSEL</strong> tedy nahrazuje programovou konstrukci
typu:</p>

<pre>
cíl = condition ? zdroj1 : zdroj2;
</pre>

<p>Alternativní formou instrukce <strong>CSEL</strong> je instrukce
<strong>CSINV</strong> neboli <i>Conditional Select Invert</i>:</p>

<pre>
CSINV Wd, Wn, Wm, condition
CSINV Xd, Xn, Xm, condition
</pre>

<p>Tato instrukce pracuje následovně: pokud je podmínka splněna, uloží se do
cílového registru <strong>Wd</strong> či <strong>Xd</strong> hodnota
z&nbsp;prvního zdrojového registru <strong>Wn</strong> nebo
<strong>Xn</strong>. Pokud podmínka splněna není, je do cílového registru
<strong>Wd/Xd</strong> uložena negovaná hodnota přečtená z&nbsp;druhého
zdrojového registru <strong>Wm/Xm</strong>.</p>

<p>Instrukce <strong>CSINV</strong> tedy nahrazuje programovou konstrukci
typu:</p>

<pre>
cíl = condition ? zdroj1 : ~zdroj2;
</pre>

<p>Poznámka: znak ~ je používán v&nbsp;programovacím jazyku C a od něj
odvozených jazycích pro zápis unárního operátoru negace všech bitů (jedničkový
doplněk).</p>

<p>Zajímavá je instrukce <strong>CSINC</strong>, která kombinuje možnosti
instrukce <strong>CINC</strong> a <strong>CSEL</strong>:</p>

<pre>
CSINC Wd, Wn, Wm, condition
CSINC Xd, Xn, Xm, condition
</pre>

<p>Tato instrukce provádí následující činnost:</p>

<pre>
Wd = condition ? Wn : Wm+1;
Xd = condition ? Xn : Xm+1;
</pre>

<p>Touto instrukcí realizována již popsaná pseudoinstrukce
<strong>CSET</strong>, a to tehdy, pokud jsou oba zdrojové registry nulové
(<strong>WZR</strong> a <strong>XZR</strong>). V&nbsp;tomto případě se do
cílového registru dosadí 0 či 0+1=1:</p>

<pre>
CSINC Wd, WZR, WZR, invert(condition)
CSINC Xd, XZR, XZR, invert(condition)
</pre>

<p>Instrukce nazvaná <strong>CSNEG</strong> se do jisté míry podobá instrukci
<strong>CSINV</strong>, ovšem s&nbsp;tím rozdílem, že se namísto jedničkového
doplňku (negace) používá při nesplnění podmínky dvojkový doplněk:</p>

<pre>
CSNEG Wd, Wn, Wm, condition
CSNEG Xd, Xn, Xm, condition
</pre>

<p>Tato instrukce pracuje následovně: pokud je podmínka splněna, uloží se do
cílového registru <strong>Wd</strong> či <strong>Xd</strong> hodnota
z&nbsp;prvního zdrojového registru <strong>Wn</strong> nebo
<strong>Xn</strong>. Pokud podmínka splněna není, je do cílového registru
<strong>Wd/Xd</strong> uložena hodnota přečtená z&nbsp;druhého zdrojového
registru <strong>Wm/Xm</strong>, u které se nejdříve změní znaménko (onen
zmíněný dvojkový doplněk).</p>

<p>Tato instrukce tedy nahrazuje programovou konstrukci typu:</p>

<pre>
cíl = condition ? zdroj1 : -zdroj2;
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Další instrukce s&nbsp;podmínkou</h2>

<p>Poslední tři instrukce ze sady AArch64, v&nbsp;nichž se vyhodnocuje
podmínka, jsou vypsány v&nbsp;tabulce pod tímto odstavcem:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>CINC</td><td>Conditional Increment</td></tr>
<tr><td>2</td><td>CINV</td><td>Conditional Invert</td></tr>
<tr><td>3</td><td>CNEG</td><td>Conditional Negate</td></tr>
</table>

<p>Instrukce <strong>CINC</strong> je aliasem pro instrukci
<strong>CSINC</strong>, ovšem s&nbsp;převrácenou podmínkou a shodnými
zdrojovými registry:</p>

<pre>
CINC Wd, Wn, condition
CINC Xd, Xn, condition
</pre>

<p>Tato instrukce provádí následující činnost (je zde jen jediný zdrojový
registr):</p>

<pre>
Wd = condition ? Wn+1 : Wn;
Xd = condition ? Xn+1 : Xn;
</pre>

<p>Použití této instrukce je různé, může se například použít pro realizaci
příkazu <strong>continue</strong> v&nbsp;programovacím jazyku C.</p>

<p>Podobná instrukce taktéž s&nbsp;jedním zdrojovým registrem se jmenuje
<strong>CINV</strong>:</p>

<pre>
CINV Wd, Wn, condition
CINV Xd, Xn, condition
</pre>

<p>Prováděná činnost je následující (tilda znamená negaci bit po bitu):</p>

<pre>
Wd = condition ? ~Wn : Wn;
Xd = condition ? ~Xn : Xn;
</pre>

<p>Ve skutečnosti se opět jedná o instrukční alias rozpoznávaný assemblery.
V&nbsp;tomto případě lze <strong>CINV</strong> nahradit instrukcí
<strong>CSINV</strong> s&nbsp;oběma zdrojovými registry totožnými:</p>

<pre>
CSINV Wd, Wn, Wn, invert(condition)
CSINV Xd, Xn, Xn, invert(condition)
</pre>

<p>Poslední instrukce, přesněji řečeno (opět) instrukční alias se jmenuje
<strong>CNEG</strong>:</p>

<pre>
CNEG Wd, Wn, condition
CNEG Xd, Xn, condition
</pre>

<p>Prováděná činnost:</p>

<pre>
Wd = condition ? -Wn : Wn;
Xd = condition ? -Xn : Xn;
</pre>

<p>Tento alias je možné nahradit za <strong>CSNEG</strong> s&nbsp;totožnými
zdrojovými registry a opačně zapsanou podmínkou:</p>

<pre>
CSNEG Wd, Wn, Wn, invert(condition)
CSNEG Xd, Xn, Xn, invert(condition)
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Extrakce dat</h2>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>EXTR Wd, Wn, Wm, #lsb</td><td>Wd = Wn:Wm<lsb+31,lsb></td></tr>
<tr><td>2</td><td>EXTR Xd, Xn, Xm, #lsb</td><td>Xd = Xn:Xm<lsb+31,lsb></td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Comparison of ARMv8-A cores<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores">https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores</a>
</li>

<li>A64 General Instructions<br />
<a href="http://www.keil.com/support/man/docs/armclang_asm/armclang_asm_pge1427898258836.htm">http://www.keil.com/support/man/docs/armclang_asm/armclang_asm_pge1427898258836.htm</a>
</li>

<li>ARMv8 (AArch64) Instruction Encoding<br />
<a href="http://kitoslab-eng.blogspot.cz/2012/10/armv8-aarch64-instruction-encoding.html">http://kitoslab-eng.blogspot.cz/2012/10/armv8-aarch64-instruction-encoding.html</a>
</li>

<li>Cortex-A32 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php</a>
</li>

<li>Cortex-A35 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>Apple A7 (SoC založen na CPU Cyclone)<br />
<a href="https://en.wikipedia.org/wiki/Apple_A7">https://en.wikipedia.org/wiki/Apple_A7</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>DSP for Cortex-M<br />
<a href="https://developer.arm.com/technologies/dsp/dsp-for-cortex-m">https://developer.arm.com/technologies/dsp/dsp-for-cortex-m</a>
</li>

<li>Cortex-M processors in DSP applications? Why not?!<br />
<a href="https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not">https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not</a>
</li>

<li>White Paper - DSP capabilities of Cortex-M4 and Cortex-M7<br />
<a href="https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7">https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7</a>
</li>

<li>Q (number format)<br />
<a href="https://en.wikipedia.org/wiki/Q_%28number_format%29">https://en.wikipedia.org/wiki/Q_%28number_format%29</a>
</li>

<li>TriCore Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837">http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837</a>
</li>

<li>TriCoreTM V1.6 Instruction Set: 32-bit Unified Processor Core<br />
<a href="http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352">http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352</a>
</li>

<li>TriCore v2.2 C Compiler, Assembler, Linker Reference Manual<br />
<a href="http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf">http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf</a>
</li>

<li>Infineon TriCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Infineon_TriCore">https://en.wikipedia.org/wiki/Infineon_TriCore</a>
</li>

<li>C166®S V2 Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae">http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální stránky projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky o projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

