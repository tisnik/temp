<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Dyon - spojení předností Rustu a dynamicky typovaných programovacích jazyků (2.část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Dyon - spojení předností Rustu a dynamicky typovaných programovacích jazyků (2.část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>I v dnešním článku budeme pokračovat v popisu základních vlastností neobvyklého programovacího jazyka Dyon s dynamickým typovým systémem. Zabývat se budeme zejména smyčkami ∃ (any) a ∀ (all), datovými typy Result a Option, zpracováním chyb, kontrolou životnosti objektů atd.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Krátké zopakování z&nbsp;první části článku &ndash; speciální typy programových smyček</a></p>
<p><a href="#k02">2. Smyčky konstruované pomocí ∃ a ∀</a></p>
<p><a href="#k03">3. Získání přesnějších informací o výsledcích smyček: klauzule where, why a why not</a></p>
<p><a href="#k04">4. Použití klauzule where u smyček <strong>min</strong> a <strong>max</strong></a></p>
<p><a href="#k05">5. Použití klauzulí why a why not u smyček ∃ a ∀</a></p>
<p><a href="#k06">6. Datový typ <strong>Option</strong></a></p>
<p><a href="#k07">7. Datový typ <strong>Result</strong></a></p>
<p><a href="#k08">8. Operátor ?</a></p>
<p><a href="#k09">9. &bdquo;Probublávání&ldquo; hodnot none() a err(x) při použití operátoru ?</a></p>
<p><a href="#k10">10. Kontrola modifikátoru <strong>mut</strong> u parametrů a argumentů funkcí</a></p>
<p><a href="#k11">11. Uživatelsky definované objekty</a></p>
<p><a href="#k12">12. Uživatelsky definované ad-hoc typy</a></p>
<p><a href="#k13">13. Životnost objektů</a></p>
<p><a href="#k14">14. Použití funkce <strong>clone</strong></a></p>
<p><a href="#k15">15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Krátké zopakování z&nbsp;první části článku &ndash; speciální typy programových smyček</h2>

<p>Již <a
href="https://www.root.cz/clanky/dyon-spojeni-prednosti-rustu-a-dynamicky-typovanych-programovacich-jazyku/">minule</a>
jsme se seznámili s&nbsp;tím, že kromě dvou univerzálních smyček nazvaných
<strong>loop</strong> (nekonečná smyčka) a <strong>for</strong> (několik forem
počítané smyčky i smyčky typu for-each) existují v&nbsp;jazyku Dyon i další
varianty programových smyček, které se typicky používají pro zpracování polí
(ostatně práce s&nbsp;poli tvoří základ pro většinu skriptů, které jsou
v&nbsp;Dyonu psány). Připomeňme si, že můžeme použít tyto smyčky:</p>

<table>
<tr><th>Konstrukce</th><th>Alternativní zápis</th><th>Význam</th></tr>
<tr><td>sift</td><td>&nbsp;</td><td>vytvoření pole z&nbsp;předávaných hodnot</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>sum</td><td>∑</td><td>suma prvků</td></tr>
<tr><td>prod</td><td>∏</td><td>výsledek vynásobení všech prvků</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>min</td><td>&nbsp;</td><td>zjištění minima</td></tr>
<tr><td>max</td><td>&nbsp;</td><td>zjištění maxima</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>any</td><td>∃</td><td>test, zda je výraz pravdivý alespoň pro jeden prvek</td></tr>
<tr><td>all</td><td>∀</td><td>test, zda je výraz pravdivý pro všechny prvky</td></tr>
</table>

<p>Příklad použití:</p>

<pre>
a := [3,2,1,10,1]
&nbsp;
minimum := min i { a[i] }
println(minimum)
&nbsp;
maximum := max i { a[i] }
println(maximum)
&nbsp;
suma := sum i len(a) { a[i] }
println(suma)
&nbsp;
product := prod i len(a) { a[i] }
println(product)
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
1
10
17
60
</pre>


<p><a name="k02"></a></p>
<h2 id="k02">2. Smyčky konstruované pomocí ∃ a ∀</h2>

<p>Ve skutečnosti je možné většinu těchto smyček chápat jako specializovanou
formu <strong>reduce</strong> s&nbsp;počáteční hodnotou akumulátoru a funkcí
aplikovanou postupně na prvky, kterými se iteruje. Viditelné je to zejména u
těchto šesti smyček:</p>

<table>
<tr><th>Smyčka</th><th>Prováděná operace</th><th>Počáteční hodnota</th></tr>
<tr><td>sum</td><td>+</td><td>0</td></tr>
<tr><td>prod</td><td>*</td><td>1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>min</td><td>&lt; acc</td><td>none()</td></tr>
<tr><td>max</td><td>&gt; acc</td><td>none()</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>any</td><td>logický součet</td><td>false</td></tr>
<tr><td>all</td><td>logický součin</td><td>true</td></tr>
</table>

<p>Podívejme se nyní na způsob použití programových smyček <strong>all</strong>
a <strong>any</strong> pro zjištění, zda nějaké jednorozměrné pole obsahuje
alespoň jednu zápornou hodnotu či zda jsou všechny hodnoty kladné. Můžeme
použít obou typů smyček. Povšimněte si způsobu zápisu podmínky do složených
závorek:</p>

<pre>
fn special_loops_all_any() {
    println("Special loops: all, any")
&nbsp;
    a := [3,2,1,10,1]
    println(a)
&nbsp;
    has_negative_values := any i { a[i] &lt; 0 }
    println(has_negative_values)
&nbsp;
    all_values_positive := all i { a[i] &gt; 0 }
    println(all_values_positive)
&nbsp;
    a := [3,2,-1,10,1]
    println(a)
&nbsp;
    has_negative_values := any i { a[i] &lt; 0 }
    println(has_negative_values)
&nbsp;
    all_values_positive := all i { a[i] &gt; 0 }
    println(all_values_positive)
&nbsp;
    println("")
}
</pre>

<p>Výsledek běhu této funkce:</p>

<pre>
Special loops: all, any
[3, 2, 1, 10, 1]
false
true
[3, 2, -1, 10, 1]
true
false
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Získání přesnějších informací o výsledcích smyček: klauzule where, why a why not</h2>

<p>Programovací jazyk Dyon dokáže k&nbsp;hodnotám typu <strong>bool</strong> a
<strong>f64</strong> (což jsou dva základní a vlastně i jediné primitivní
datové typy) navázat nepovinné pole obsahující další metainformace o dané
hodnotě. Toto nepovinné pole se jmenuje <i>secrets</i> a lze ho použít
k&nbsp;zápisu uživatelských dat (pokud to má význam). U některých programových
smyček se <i>secrets</i> používá pro uložení informace do výsledné hodnoty
produkované programovou smyčkou:</p>

<table>
<tr><th>Smyčka</th><th>Secrets</th><th>Získání secrets</th></tr>
<tr><td>min</td><td>index minimálního prvku</td><td><strong>where()</strong></td></tr>
<tr><td>max</td><td>index maximálního prvku</td><td><strong>where()</strong></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>any</td><td>index prvku, který první splnil podmínku</td><td><strong>why()</strong></td></tr>
<tr><td>all</td><td>index prvku, který první nesplnil podmínku</td><td><strong>why()</strong></td></tr>
</table>

<p>Z&nbsp;předchozí tabulky je patrné, že u smyček <strong>min</strong> a
<strong>max</strong> použijeme klauzuli <strong>where()</strong>. Tato klauzule
se sice zapisuje jako funkce, ale jedná se o prvek jazyka. U smyčky
<strong>any</strong> se pomocí <strong>why()</strong> získá index prvku, který
první <i>splnil</i> podmínku &ndash; to ovšem platí jen u návratové hodnoty
<strong>true</strong>. U smyčky <strong>all</strong> se naopak pomocí
<strong>why not/(why(!....))</strong> získá index prvního prvku, který podmínku
<i>nesplnil</i>. Platné je to ovšem jen v&nbsp;případě, že smyčka
<strong>all</strong> vrátila hodnotu <strong>false</strong>. To
mj.&nbsp;znamená, že u těchto dvou smyček budeme zápis
<strong>why(...)</strong> či <strong>why(!...)</strong> prakticky vždy používat
v&nbsp;podmínce.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Použití klauzule where u smyček <strong>min</strong> a <strong>max</strong></h2>

<p>Klauzuli <strong>where</strong> použijeme především u programových smyček
<strong>min</strong> a <strong>max</strong>, protože tak můžeme velmi snadno
získat index prvku s&nbsp;minimální či naopak maximální hodnotou. Použití je
velmi jednoduché, jak je to ostatně patrné z&nbsp;následující funkce, kde je
<strong>where</strong> zvýrazněno:</p>

<pre>
fn special_loops_min_max_secrets() {
    println("Special loops: min max, secrets")
&nbsp;
    a := [3,2,1,10,1]
    println(a)
&nbsp;
    minimum := min i { a[i] }
    print("Min: ")
    print(minimum)
    print(" at index: ")
    println(<strong>where(minimum)</strong>)
&nbsp;
    maximum := max i { a[i] }
    print("Max: ")
    print(maximum)
    print(" at index: ")
    println(<strong>where(maximum)</strong>)
&nbsp;
    println("")
}
</pre>

<p>Výsledek běhu této funkce:</p>

<pre>
Special loops: min max, secrets
[3, 2, 1, 10, 1]
Min: 1 at index: [2]
Max: 10 at index: [3]
</pre>

<p>Poznámka: povšimněte si, že pokud vstupní pole obsahuje alespoň jeden prvek,
je zajištěno, že <strong>where</strong> vrátí index prvku, na rozdíl od dále
popsané klauzule <strong>why</strong>. To znamená, že v&nbsp;kódu nemusíme
používat žádné podmínky a přímo přistupovat k&nbsp;výsledkům smyčky a
metainformacím navázaným na tyto výsledky.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Použití klauzulí why a why not u smyček ∃ a ∀</h2>

<p>Zatímco u klauze <strong>where</strong> jsme měli jistotu, že vrátí index
prvku s&nbsp;minimální či maximální hodnotou, je tomu u klauzulí
<strong>why</strong> a <strong>why not</strong> poněkud jinak, protože tyto
klauzule jsou použity v&nbsp;kombinaci s&nbsp;programovými smyčkami ∃ a ∀. U
smyčky <strong>any</strong> lze <strong>why()</strong> použít jen u návratové
hodnoty <strong>true</strong>. U smyčky <strong>all</strong> se naopak používá
<strong>why not</strong> (zapisované <strong>(why(!....))</strong>, ovšem jen
v&nbsp;případě, že smyčka <strong>all</strong> vrátila hodnotu
<strong>false</strong>. Opět se podívejme na příklady:</p>

<pre>
fn special_loops_any_secrets() {
    println("Special loops: any, secrets")
&nbsp;
    a := [3,2,1,10,1]
    println(a)
&nbsp;
    has_negative_values := any i { a[i] &lt; 0 }
    print("Has negative values: ")
    if has_negative_values {
        print("Yes, at index: ")
        println(<strong>why(has_negative_values)</strong>)
    } else {
        println("No")
    }
&nbsp;
    a := [3,2,-1,10,-1]
    println(a)
&nbsp;
    has_negative_values := any i { a[i] &lt; 0 }
    print("Has negative values: ")
    if has_negative_values {
        print("Yes, at index: ")
        println(<strong>why(has_negative_values)</strong>)
    } else {
        println("No")
    }
&nbsp;
    println("")
}
</pre>

<p>Výsledek běhu této funkce:</p>

<pre>
Special loops: any, secrets
[3, 2, 1, 10, 1]
Has negative values: No
[3, 2, -1, 10, -1]
Has negative values: Yes, at index: [2]
</pre>

<pre>
fn special_loops_all_secrets() {
    println("Special loops: all, secrets")
&nbsp;
    a := [3,2,1,10,1]
    println(a)
&nbsp;
    all_values_positive := all i { a[i] &gt; 0 }
    print("All values are positive: ")
    if all_values_positive {
        println("Yes")
    } else {
        print("No, 1st non-positive value found at index: ")
        println(<strong>why(!all_values_positive)</strong>)
    }
&nbsp;
    a := [3,2,-1,10,-1]
    println(a)
&nbsp;
    all_values_positive := all i { a[i] &gt; 0 }
    print("All values are positive: ")
    if all_values_positive {
        println("Yes")
    } else {
        print("No, 1st non-positive value found at index: ")
        println(<strong>why(!all_values_positive)</strong>)
    }
&nbsp;
    println("")
}
</pre>

<p>Výsledek běhu této funkce:</p>

<pre>
Special loops: all, secrets
[3, 2, 1, 10, 1]
All values are positive: Yes
[3, 2, -1, 10, -1]
All values are positive: No, 1st non-positive value found at index: [2]
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Datový typ <strong>Option</strong></h2>

<p>S&nbsp;datovým typem <strong>Option</strong> jsme se již <a
href="https://www.root.cz/clanky/datovy-typ-option-v-programovacim-jazyku-rust/">setkali
při popisu vlastností programovacího jazyka Rust</a>. Připomeňme si tedy, že
díky existenci tohoto typu je možné elegantně obejít většinu nectností
speciálních hodnot (někde ukazatelů, jinde zase pro změnu referencí) typu
<strong>None</strong>, <strong>null</strong> či <strong>nil</strong>. Při
použití typu <strong>Option</strong> je totiž explicitně specifikováno, že je
nějaká hodnota nepovinná popř.&nbsp;volitelná (podle kontextu). Navíc jsme jako
programátoři přinuceni se explicitně zpracováním nepovinné/volitelné hodnoty
zabývat. Datový typ <strong>Option</strong> tvoří obálku nad samotnou
reprezentovanou hodnotou popř.&nbsp;reprezentuje prázdnou obálku. S&nbsp;tímto
typem jsou spojeny především tři funkce:</p>

<table>
<tr><th>Funkce</th><th>Význam</th></tr>
<tr><td>some(any)</td><td>vytvoří obálku s&nbsp;hodnotou libovolného typu</td></tr>
<tr><td>none()</td><td>vytvoří prázdnou obálku (jedná se o jedináčka)</td></tr>
<tr><td>unwrap(option)</td><td>(rozbalení) vrátí hodnotu uloženou v&nbsp;obálce</td></tr>
</table>

<p>Podívejme se na použití těchto tří funkcí. Je to velmi snadné:</p>

<pre>
o := some(42)
println(o)
&nbsp;
o = none()
println(o)
&nbsp;
o = some(2)
println(unwrap(o))
&nbsp;
o = none()
//println(unwrap(o))
&nbsp;
if o != none() {
    println(unwrap(o))
}
</pre>

<p>Povšimněte si zejména testu, zda je obálka prázdná (zde se kód odlišuje od
Rustu).</p>

<p>Výsledek běhu příkladu:</p>

<pre>
some(42)
none()
2
false
</pre>

<p><strong>unwrap()</strong> nelze volat pro hodnotu
<strong>none()</strong>:</p>

<pre>
 --- ERROR --- 
main (src/main.dyon)
test_option_type (src/main.dyon)
unwrap
&nbsp;
Expected `some(_)`
12,20:     println(unwrap(o))
12,20:                    ^
</pre>

<p>Poznámka: prozatím nelze použít pattern matching, který by se zde hodil.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Datový typ <strong>Result</strong></h2>

<p>I další užitečný datový typ nazvaný <strong>Result</strong> jsme si již <a
href="https://www.root.cz/clanky/reakce-na-chyby-v-programovacim-jazyku-rust/">v&nbsp;tomto
seriálu popsali</a>, ovšem v&nbsp;kontextu Rustu a nikoli Dyonu. Připomeňme si
tedy, že v&nbsp;mnoha případech nemusí být použití datového typu
<strong>Option</strong> tím nejlepším řešením. Pro příklad nemusíme chodit
daleko &ndash; předpokládejme, že budeme chtít, aby například funkce pro dělení
celých čísel vracela v&nbsp;případě pokusu o dělení nulou chybové hlášení a
nikoli nicneříkající hodnotu <strong>none()</strong>. K&nbsp;tomuto účelu se
v&nbsp;programovacím jazyku Rust a nyní i Dyon používá datová struktura nazvaná
příhodně <strong>Result</strong>. Tato datová struktura se podobá Option, ovšem
s&nbsp;tím rozdílem, že obaluje buď výsledek (třeba návratovou hodnotu volané
funkce) nebo informaci o chybě. K&nbsp;dispozici jsou následující pomocné
funkce:</p>

<table>
<tr><th>Funkce</th><th>Význam</th></tr>
<tr><td>ok(any)</td><td>vytvoří obálku s&nbsp;hodnotou libovolného typu</td></tr>
<tr><td>err(any)</td><td>vytvoří obálku s&nbsp;hodnotou reprezentující chybu (například chybové hlášení)</td></tr>
<tr><td>is_ok(result)</td><td>dotaz (predikát), zda pracujeme s&nbsp;bezchybnou hodnotou</td></tr>
<tr><td>is_err(result)</td><td>dotaz (predikát), zda pracujeme s&nbsp;informací o chybě</td></tr>
<tr><td>unwrap(result)</td><td>(rozbalení) vrátí hodnotu uloženou v&nbsp;obálce</td></tr>
<tr><td>unwrap_err(result)</td><td>(rozbalení) vrátí hodnotu reprezentující chybu</td></tr>
</table>

<p>Opět se podívejme na jednoduchý příklad:</p>

<pre>
r := ok(42)
println(r)
println(is_ok(r))
println(is_err(r))
&nbsp;
r = err("Very serious")
println(r)
println(is_ok(r))
println(is_err(r))
&nbsp;
r = ok(2)
println(unwrap(r))
//println(unwrap_err(r))
&nbsp;
r = err("Very serious")
//println(unwrap(r))
println(unwrap_err(r))
&nbsp;
r = ok(42)
if is_ok(r) {
    println(unwrap(r))
} else {
    println(unwrap_err(r))
}
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
ok(42)
true
false
err("Very serious")
false
true
2
Very serious
42
</pre>

<p>Poznámka: opět platí, že prozatím nelze použít pattern matching, který by se
zde hodil.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Operátor ?</h2>

<p>Pokud vytvoříme funkci <strong>div</strong> počítající podíl dvou čísel,
která bude vracet typ <strong>Result</strong>, můžeme jednoduše zabezpečit, že
nikdy nedojde k&nbsp;dělení nulou:</p>

<pre>
fn div(x,y) -&gt; {
    if y == 0 {
        return err("Div by 0")
    } else {
        return ok(x/y)
    }
}
</pre>

<p>Popř.&nbsp;můžeme použít idiomatičtější zápis:</p>

<pre>
fn div(x,y) -&gt; {
    return if y == 0 { err("Div by 0") }
           else { ok(x/y) }
}
</pre>

<p>Tuto funkci si můžeme snadno otestovat:</p>

<pre>
fn test_div() {
    d := div(10, 5)
    println(d)
    e := div(1, 0)
    println(e)
}
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
ok(2)
err("Div by 0")
</pre>

<p>Co se ovšem stane v&nbsp;případě, že budeme mít několik vzájemně se
volajících funkcí, které si budou výsledek <strong>div()</strong> předávat a
používat ho? Nebylo by asi praktické stále volat <strong>is_ok(...)</strong> a
<strong>is_err(...)</strong>, navíc by se kvůli množství podmínek do zápisu
algoritmu zbytečně vneslo mnoho kontrol speciálních (chybových) stavů. Řešení
samozřejmě existuje a spočívá v&nbsp;použití operátoru ?. Tento operátor se
zapisuje za jméno volané funkce a umožňuje provést kontrolu, zda je výsledek
volání (typu <strong>Result</strong>) roven <strong>ok(hodnota)</strong>. Pokud
tomu tak <i>není</i>, je funkce ihned ukončena a návratovou hodnotou je
<strong>err(zpráva)</strong>. Operátor ? tedy slouží k&nbsp;tomu, aby se
v&nbsp;kódu nemuselo explicitně zapisovat:</p>

<pre>
r := nějaká_funkce()
if is_err(r) {
    return r
}
...
...
...
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. &bdquo;Probublávání&ldquo; hodnot none() a err(x) při použití operátoru ?</h2>

<p>Podívejme se nyní na to, jak je možné elegantně vyřešit volání funkce
<strong>div()</strong> uvnitř jiné funkce, která používá výsledek dělení a
tudíž i potenciální chybový stav. Funkce <strong>div()</strong> je stále
stejná:</p>

<pre>
fn div(x,y) -&gt; {
    if y == 0 {
        return err("Div by 0")
    } else {
        return ok(x/y)
    }
}
</pre>

<p>Další funkce je určena k&nbsp;přičtení nějakého offsetu k&nbsp;výsledku
dělení. Ovšem ve chvíli, kdy by se mělo dělit nulou, budeme chtít výpočet ihned
ukončit a vrátit původní chybu. Toho docílíme snadno právě díky použití
operátoru ? (ten je zapsán za uzavírací kulatou závorku):</p>

<pre>
fn div_add(x, y, z) -&gt; {
    r := div(x, y)<strong>?</strong>
    println(r)
    return ok(r + z)
}
</pre>

<p>Poslední dva příkazy <strong>println+return</strong> se provedou jen ve
chvíli, kdy se nedělilo nulou. Ostatně se o tom můžeme velmi snadno
přesvědčit:</p>

<pre>
fn test_div_question_op() {
    r1 := div_add(10, 5, 100)
    println(r1)
&nbsp;
    r2 := div_add(10, 0, 100)
    println(r2)
}
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
2
ok(102)
err("Div by 0")
</pre>

<p>První dvojka vznikla byla vypsána ve funkci <strong>div_add</strong>.</p>

<p>Poznámka: operátor ? tedy nemá nic společného s&nbsp;ternárním céčkovým
operátorem, který není nutné do jazyka Dyon implementovat, protože si
<strong>if-else</strong> používá ve výrazech.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Kontrola modifikátoru <strong>mut</strong> u parametrů a argumentů funkcí</h2>

<p>Již minule jsme se zmínili o tom, že pokud má funkce modifikovat hodnoty
svých argumentů, musí se u těchto argumentů zapsat modifikátor
<strong>mut</strong>. Stejný modifikátor je nutné použít i při volání funkce,
čímž dává programátor najevo, že je srozuměn s&nbsp;tím, že se daný parametr
může měnit. Kontrola přítomnosti tohoto modifikátoru ale ve skutečnosti probíhá
v&nbsp;celém řetězci volání. Ostatně podívejme se na jednoduchý příklad,
v&nbsp;němž se funkce <strong>inc</strong> volá z&nbsp;jiné funkce
<strong>call_inc</strong> volané ze třetí funkce
<strong>functions</strong>:</p>

<pre>
fn inc(<strong>mut</strong> x) {
    x += 1
}
&nbsp;
fn call_inc(<strong>mut</strong> x) {
    inc(<strong>mut</strong> x)
}
&nbsp;
fn functions() {
    x := 1
    println(x)
    call_inc(<strong>mut</strong> x)
    println(x)
}
</pre>

<p>Modifikátor <strong>mut</strong> je skutečně nutné použít na všech čtyřech
zvýrazněných místech, nemůžeme se ho tedy &bdquo;zbavit&ldquo; například uvnitř
<strong>call_inc</strong>:</p>

<pre>
fn inc(<strong>mut</strong> x) {
    x += 1
}
&nbsp;
fn call_inc(<strong>mut</strong> x) {
    inc(x)
}
&nbsp;
fn functions() {
    x := 1
    println(x)
    call_inc(<strong>mut</strong> x)
    println(x)
}
</pre>

<pre>
 --- ERROR --- 
In `src/main.dyon`:
&nbsp;
Could not find function `inc`
&nbsp;
Did you mean:
- inc(mut)
&nbsp;
6,5:     inc(x)
6,5:     ^
</pre>

<p>A už vůbec ne při volání <strong>call_inc</strong>:</p>

<pre>
fn inc(<strong>mut</strong> x) {
    x += 1
}
&nbsp;
fn call_inc(<strong>mut</strong> x) {
    inc(<strong>mut</strong> x)
}
&nbsp;
fn functions() {
    x := 1
    println(x)
    call_inc( x)
    println(x)
}
</pre>

<pre>
 --- ERROR --- 
In `src/main.dyon`:
&nbsp;
Could not find function `call_inc`
&nbsp;
Did you mean:
- call_inc(mut)
&nbsp;
12,5:     call_inc(x)
12,5:     ^
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Uživatelsky definované objekty</h2>

<p>Uživatelsky definované objekty jsou postavené na klasických asociativních
polích (slovnících, hash mapách), takže se jedná o přístup, který můžeme znát
z&nbsp;programovacího jazyka Lua. Pro přístup k&nbsp;atributům objektů se
používá buď tečková notace či alternativně přístup přes klíč, jehož jméno je
v&nbsp;uvozovkách (jde o řetězec). Opět se zde nabízí srovnání
s&nbsp;programovacím jazykem Lua:</p>

<pre>
fn test_objects() {
    c := {real:10, imag:20}
    println(c)
&nbsp;
    c.real = 1000
    println(c)
&nbsp;
    c["real"] = 0
    println(c)
}
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
{imag: 20, real: 10}
{imag: 20, real: 1000}
{imag: 20, real: 0}
</pre>

<p>Podobně jako v&nbsp;případě běžných proměnných, i při modifikaci atributů se
provádí kontrola, zda nedochází ke změně typu ukládané hodnoty:</p>

<pre>
fn test_objects() {
    c := {real:10, imag:20}
    println(c)
&nbsp;
    c.real = 1000
    println(c)
&nbsp;
    c["real"] = "x"
    println(c)
}
</pre>

<pre>
 --- ERROR --- 
main (src/main.dyon)
test_objects (src/main.dyon)
&nbsp;
Expected assigning to text
23,5:     c["real"] = "x"
23,5:     ^
</pre>

<p>Atributy lze k&nbsp;objektu přidávat za běhu, a to tečkovou notací a
současně operátorem := (nikoli pouze =, což by nebylo konzistentní):</p>

<pre>
fn test_objects() {
    c := {real:10, imag:20}
    println(c)
&nbsp;
    c.real = 1000
    println(c)
&nbsp;
    c["real"] = 0
    println(c)
&nbsp;
    <strong>c.name := "komplexni cislo"</strong>
    println(c)
}
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
{real: 10, imag: 20}
{real: 1000, imag: 20}
{real: 0, imag: 20}
{real: 0, name: "komplexni cislo", imag: 20}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Uživatelsky definované ad-hoc typy</h2>

<p>Programovací jazyk Dyon podporuje deklaraci takzvaných ad-hoc typů, díky
nimž lze vytvářet struktury podobné třídám. Podívejme se na jednoduchý příklad,
v&nbsp;němž nejdříve vytvoříme &bdquo;konstruktor&ldquo; pro třídu Complex
(musíme si však uvědomit, že termín &bdquo;konstruktor&ldquo; a
&bdquo;třída&ldquo; je zde uveden pouze pro sémantickou podobnost
s&nbsp;podobnými konstrukcemi známými z&nbsp;některých jiných jazyků):</p>

<pre>
fn new_complex(real, imag) -&gt; <strong>Complex</strong> {
    return {real: clone(real),
            imag: clone(imag)}
}
</pre>

<p>V&nbsp;tomto konstruktoru jsme pouze pojmenovali slovník, který je výsledkem
volání funkce.</p>

<p>Ve skutečnosti můžeme nové pojmenování <strong>Complex</strong> použít ve
chvíli, kdy je nutné určit typ parametrů funkce (někdy to nutné není a můžeme
se spolehnout na dynamický typový systém):</p>

<pre>
fn print_complex(c: <strong>Complex</strong>) {
    print(c.real)
    print("+j")
    print(c.imag)
}
</pre>

<p>Chování konstruktoru <strong>new_complex</strong> i funkce
<strong>print_complex</strong> si můžeme snadno odzkoušet:</p>

<pre>
fn main() {
    cplx := new_complex(10, 20)
    print_complex(cplx)
}
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
10+j20
</pre>

<p>Poznámka: žádnou další podporu pro práci s&nbsp;objekty v&nbsp;sémantice
programovacího jazyka Dyon (prozatím) nenajdeme, dokonce ani nejsou přímo
podporovány traity.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Životnost objektů</h2>

<p>Jednou z&nbsp;velmi důležitých vlastností programovacího jazyka Dyon je
kontrola životnosti (častěji se možná používá termín viditelnosti) objektů.
Díky této kontrole je možné se obejít bez klasického garbage collectoru,
protože objekt je možné z&nbsp;paměti odstranit ve chvíli, kdy je již zřejmé,
že není viditelný (živý). Na druhou stranu to však klade poněkud větší nároky
na programátora, který na některých místech programu musí explicitně určit,
jaká je životnost proměnné či parametru funkce.</p>

<p>V&nbsp;následujícím programu je vše v&nbsp;pořádku, protože životnost
parametrů funkcí je omezena jen na těla funkcí. Je tomu tak z&nbsp;toho důvodu,
že vynásobením vzniká nová hodnota:</p>

<pre>
fn foo(a) -&gt; {
    return a*2
}
&nbsp;
fn bar(a) -&gt; {
    return 3*foo(a)
}
&nbsp;
fn test_lifetimes() {
    x := bar(10)
    println(x)
}
</pre>

<p>Co když však budeme chtít přímo vrátit parametr předaný do funkce?
V&nbsp;tomto případě <i>nevzniká</i> nová hodnota a současně je
<i>životnost</i> parametru delší než je oblast platnosti funkce:</p>

<pre>
fn foo(<strong>a</strong>) -&gt; {
    return <strong>a</strong>
}
&nbsp;
fn bar(a) -&gt; {
    return 3*foo(a)
}
&nbsp;
fn test_lifetimes() {
    x := bar(10)
    println(x)
}
</pre>

<p>Program se tedy nepřeloží, ovšem z&nbsp;chybového hlášení je zřejmé, jak
provést nápravu:</p>

<pre>
 --- ERROR --- 
In `src/main.dyon`:
&nbsp;
Requires `a: 'return`
47,12:     return a
47,12:            ^
</pre>

<p>Úpravou <strong>a: 'return</strong> specifikujeme, že životnost parametru
<strong>a</strong> má být větší &ndash; má se rozšířit i na volající
funkci:</p>

<pre>
fn foo(<strong>a: 'return</strong>) -&gt; {
    return a
}
&nbsp;
fn bar(a) -&gt; {
    return 3*foo(a)
}
&nbsp;
fn test_lifetimes() {
    x := bar(10)
    println(x)
}
</pre>

<p>Podobně můžeme zvětšovat životnost i přes funkci <strong>bar</strong> do
funkce <strong>test_lifetimes</strong>:</p>

<pre>
fn foo(a: 'return) -&gt; {
    return a
}
&nbsp;
fn bar(a: 'return) -&gt; {
    return foo(a)
}
&nbsp;
fn test_lifetimes() {
    b := 10
    x := bar(b)
    println(x)
}
</pre>

<p>Ve skutečnosti se při deklaraci může použít zápis <strong>x: 'y</strong>,
který znamená, že proměnná <strong>x</strong> má mít minimálně takovou
životnost, jako proměnná <strong>y</strong>. Zápis
s&nbsp;<strong>'return</strong> je speciálním případem (ostatně žádná proměnná
se <strong>return</strong> jmenovat nemůže :-)</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Použití funkce <strong>clone</strong></h2>

<p>Většinou je explicitní deklarace životnosti objektů pro programátory
zbytečně pracné a namísto rozšiřování životnosti použijí funkci
<strong>clone()</strong>, která danou hodnotu naklonuje. Po naklonování nás již
nemusí zajímat, jaká byla životnost původní hodnoty. Příklad jsme si vlastně
již ukázali u konstruktoru komplexních čísel, kde jsme explicitně naklonovali
parametry funkce a klony jsme použili v&nbsp;atributech nového objektu
(slovníku):</p>

<pre>
fn new_complex(real, imag) -&gt; <strong>Complex</strong> {
    return {real: clone(real),
            imag: clone(imag)}
}
</pre>

<p>Pokud volání <strong>clone()</strong> vynecháme:</p>

<pre>
fn new_complex(real, imag) -&gt; <strong>Complex</strong> {
    return {real: real,
            imag: imag}
}
</pre>

<p>Dojde při překladu zdrojového kódu k&nbsp;chybě:</p>

<pre>
 --- ERROR --- 
In `src/main.dyon`:
&nbsp;
Requires `real: 'return`
31,12:     return {real: real,
31,12:            ^
32,1:             imag: imag}

</pre>

<p>A právě v&nbsp;této kontrole podle mého názoru spočívá největší přednost
celé technologie kontroly životnosti &ndash; programátor je překladačem
umozorněn na potenciální problémy a může program adekvátně změnit, většinou
defenzivní kopií. Pěkně to shrnuje <a
href="https://github.com/PistonDevelopers/dyon/issues/173#issuecomment-266516678">tento
komentář</a>.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Většina ukázek z&nbsp;předchozích kapitol byla přidána do několika
demonstračních příkladů, které byly uloženy do Git repositáře dostupného na
adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě
bez nutnosti klonovat celý repositář (ovšem u projektů je lepší mít celý
repositář, abyste nemuseli pracně stahovat všechny potřebné soubory):</p>

<table>
<tr><th>Příklad</th><th>Adresa</th></tr>
<tr><td>dyon-more-loops</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-more-loops/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-more-loops/Cargo.toml</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-more-loops/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-more-loops/src/main.rs</a></td></tr>
<tr><td>main.dyon</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-more-loops/src/main.dyon">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-more-loops/src/main.dyon</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>dyon-option-result</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-option-result/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-option-result/Cargo.toml</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-option-result/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-option-result/src/main.rs</a></td></tr>
<tr><td>main.dyon</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-option-result/src/main.dyon">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-option-result/src/main.dyon</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>dyon-demo-2</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-demo-2/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-demo-2/Cargo.toml</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-demo-2/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-demo-2/src/main.rs</a></td></tr>
<tr><td>main.dyon</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-demo-2/src/main.dyon">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-demo-2/src/main.dyon</a></td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Secrets design - optional information in `bool` and `f64`<br />
<a href="https://github.com/PistonDevelopers/dyon/issues/266">https://github.com/PistonDevelopers/dyon/issues/266</a>
</li>

<li>Option value design<br />
<a href="https://github.com/PistonDevelopers/dyon/issues/172">https://github.com/PistonDevelopers/dyon/issues/172</a>
</li>

<li>Result value design (`err(x)/ok(x)`)<br />
<a href="https://github.com/PistonDevelopers/dyon/issues/82">https://github.com/PistonDevelopers/dyon/issues/82</a>
</li>

<li>∑/sum, ∏/prod, min, max, sift, ∃/any, ∀/all loops<br />
<a href="https://github.com/PistonDevelopers/dyon/issues/119">https://github.com/PistonDevelopers/dyon/issues/119</a>
</li>

<li>Dyon: tutoriál<br />
<a href="http://www.piston.rs/dyon-tutorial/">http://www.piston.rs/dyon-tutorial/</a>
</li>

<li>Repositář s&nbsp;programovacím jazykem Dyon<br />
<a href="https://github.com/PistonDevelopers/dyon">https://github.com/PistonDevelopers/dyon</a>
</li>

<li>Dyon: A rusty dynamically typed scripting language<br />
<a href="https://rust.libhunt.com/project/dyon">https://rust.libhunt.com/project/dyon</a>
</li>

<li>Dyon snippets<br />
<a href="https://github.com/PistonDevelopers/dyon_snippets">https://github.com/PistonDevelopers/dyon_snippets</a>
</li>

<li>Scripting without garbage collector<br />
<a href="http://blog.piston.rs/2016/02/21/scripting-without-garbage-collector/">http://blog.piston.rs/2016/02/21/scripting-without-garbage-collector/</a>
</li>

<li>Podpora pro &bdquo;matematické&ldquo; smyčky<br />
<a href="https://github.com/PistonDevelopers/dyon/issues/119">https://github.com/PistonDevelopers/dyon/issues/119</a>
</li>

<li>Rust-clippy Wiki<br />
<a href="https://github.com/rust-lang-nursery/rust-clippy/wiki">https://github.com/rust-lang-nursery/rust-clippy/wiki</a>
</li>

<li>Rust-clippy<br />
<a href="https://rust.libhunt.com/project/rust-clippy">https://rust.libhunt.com/project/rust-clippy</a>
</li>

<li>ndarray - dokumentace k&nbsp;modulu<br />
<a href="https://bluss.github.io/rust-ndarray/master/ndarray/index.html">https://bluss.github.io/rust-ndarray/master/ndarray/index.html</a>
</li>

<li>ndarray - Crate<br />
<a href="https://crates.io/crates/ndarray">https://crates.io/crates/ndarray</a>
</li>

<li>rustup<br />
<a href="https://www.rustup.rs/">https://www.rustup.rs/</a>
</li>

<li>rustup: the Rust toolchain installer (Git repositář + dokumentace)<br />
<a href="https://github.com/rust-lang-nursery/rustup.rs">https://github.com/rust-lang-nursery/rustup.rs</a>
</li>

<li>The Rust FFI Omnibus<br />
<a href="http://jakegoulding.com/rust-ffi-omnibus/">http://jakegoulding.com/rust-ffi-omnibus/</a>
</li>

<li>Build Script Support<br />
<a href="http://doc.crates.io/build-script.html">http://doc.crates.io/build-script.html</a>
</li>

<li>Calling Rust From Python<br />
<a href="https://bheisler.github.io/post/calling-rust-in-python/">https://bheisler.github.io/post/calling-rust-in-python/</a>
</li>

<li>Calling Rust in Python (komentáře k předchozímu článku)<br />
<a href="https://www.reddit.com/r/rust/comments/63iy5a/calling_rust_in_python/">https://www.reddit.com/r/rust/comments/63iy5a/calling_rust_in_python/</a>
</li>

<li>CFFI Documentation<br />
<a href="https://cffi.readthedocs.io/en/latest/">https://cffi.readthedocs.io/en/latest/</a>
</li>

<li>Build Script Support<br />
<a href="http://doc.crates.io/build-script.html">http://doc.crates.io/build-script.html</a>
</li>

<li>Creating a shared and static library with the gnu compiler [gcc]<br />
<a href="http://www.adp-gmbh.ch/cpp/gcc/create_lib.html">http://www.adp-gmbh.ch/cpp/gcc/create_lib.html</a>
</li>

<li>ctypes — A foreign function library for Python<br />
<a href="https://docs.python.org/2/library/ctypes.html">https://docs.python.org/2/library/ctypes.html</a>
</li>

<li>FFI: Foreign Function Interface<br />
<a href="https://doc.rust-lang.org/book/ffi.html">https://doc.rust-lang.org/book/ffi.html</a>
</li>

<li>Primitive Type pointer<br />
<a href="https://doc.rust-lang.org/std/primitive.pointer.html">https://doc.rust-lang.org/std/primitive.pointer.html</a>
</li>

<li>Cargo: správce projektů a balíčků pro programovací jazyk Rust<br />
<a href="https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/">https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/</a>
</li>

<li>Network Communication and Serialization in Rust<br />
<a href="https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/">https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/</a>
</li>

<li>Crate bincode<br />
<a href="http://tyoverby.com/bincode/bincode/index.html">http://tyoverby.com/bincode/bincode/index.html</a>
</li>

<li>Struct std::fs::File<br />
<a href="https://doc.rust-lang.org/std/fs/struct.File.html">https://doc.rust-lang.org/std/fs/struct.File.html</a>
</li>

<li>Trait std::io::Seek<br />
<a href="https://doc.rust-lang.org/std/io/trait.Seek.html">https://doc.rust-lang.org/std/io/trait.Seek.html</a>
</li>

<li>Trait std::io::Read<br />
<a href="https://doc.rust-lang.org/std/io/trait.Read.html">https://doc.rust-lang.org/std/io/trait.Read.html</a>
</li>

<li>Trait std::io::Write<br />
<a href="https://doc.rust-lang.org/std/io/trait.Write.html">https://doc.rust-lang.org/std/io/trait.Write.html</a>
</li>

<li>Trait std::io::BufRead<br />
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html">https://doc.rust-lang.org/std/io/trait.BufRead.html</a>
</li>

<li>Module std::io::prelude<br />
<a href="https://doc.rust-lang.org/std/io/prelude/index.html">https://doc.rust-lang.org/std/io/prelude/index.html</a>
</li>

<li>std::net::IpAddr<br />
<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">https://doc.rust-lang.org/std/net/enum.IpAddr.html</a>
</li>

<li>std::net::Ipv4Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html</a>
</li>

<li>std::net::Ipv6Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html</a>
</li>

<li>TcpListener<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">https://doc.rust-lang.org/std/net/struct.TcpListener.html</a>
</li>

<li>TcpStream<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html">https://doc.rust-lang.org/std/net/struct.TcpStream.html</a>
</li>

<li>Binary heap (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Binary_heap">https://en.wikipedia.org/wiki/Binary_heap</a>
</li>

<li>Binární halda (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda">https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda</a>
</li>

<li>Halda (datová struktura)<br />
<a href="https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29">https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29</a>
</li>

<li>Struct std::collections::HashSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">https://doc.rust-lang.org/std/collections/struct.HashSet.html</a>
</li>

<li>Struct std::collections::BTreeSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">https://doc.rust-lang.org/std/collections/struct.BTreeSet.html</a>
</li>

<li>Struct std::collections::BinaryHeap<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html">https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html</a>
</li>

<li>Set (abstract data type)<br />
<a href="https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support">https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support</a>
</li>

<li>Associative array<br />
<a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a>
</li>

<li>Hash Table<br />
<a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a>
</li>

<li>B-tree<br />
<a href="https://en.wikipedia.org/wiki/B-tree">https://en.wikipedia.org/wiki/B-tree</a>
</li>

<li>Pedro Celis: Robin Hood Hashing (naskenované PDF!)<br />
<a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf</a>
</li>

<li>Robin Hood hashing<br />
<a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">http://codecapsule.com/2013/11/11/robin-hood-hashing/</a>
</li>

<li>Robin Hood hashing: backward shift deletion<br />
<a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/</a>
</li>

<li>Module std::collections<br />
<a href="https://doc.rust-lang.org/std/collections/">https://doc.rust-lang.org/std/collections/</a>
</li>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Struct std::collections::VecDeque<br />
<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">https://doc.rust-lang.org/std/collections/struct.VecDeque.html</a>
</li>

<li>Struct std::collections::LinkedList<br />
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">https://doc.rust-lang.org/std/collections/struct.LinkedList.html</a>
</li>

<li>Module std::fmt<br />
<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>
</li>

<li>Macro std::println<br />
<a href="https://doc.rust-lang.org/std/macro.println.html">https://doc.rust-lang.org/std/macro.println.html</a>
</li>

<li>Enum std::result::Result<br />
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">https://doc.rust-lang.org/std/result/enum.Result.html</a>
</li>

<li>Module std::result<br />
<a href="https://doc.rust-lang.org/std/result/">https://doc.rust-lang.org/std/result/</a>
</li>

<li>Result<br />
<a href="http://rustbyexample.com/std/result.html">http://rustbyexample.com/std/result.html</a>
</li>

<li>Rust stdlib: Option<br />
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">https://doc.rust-lang.org/std/option/enum.Option.html</a>
</li>

<li>Module std::option<br />
<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>
</li>

<li>Rust by example: option<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>Rust by example: if-let<br />
<a href="http://rustbyexample.com/flow_control/if_let.html">http://rustbyexample.com/flow_control/if_let.html</a>
</li>

<li>Rust by example: while let<br />
<a href="http://rustbyexample.com/flow_control/while_let.html">http://rustbyexample.com/flow_control/while_let.html</a>
</li>

<li>Rust by example: Option&lt;i32&gt;<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

