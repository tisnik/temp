<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Dyon - spojení předností Rustu a dynamicky typovaných programovacích jazyků (2.část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Dyon - spojení předností Rustu a dynamicky typovaných programovacích jazyků (2.část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>I v dnešním článku budeme pokračovat v popisu základních vlastností neobvyklého programovacího jazyka Dyon s dynamickým typovým systémem. Zabývat se budeme zejména smyčkami ∃ (any) a ∀ (all), datovými typy Result a Option, zpracováním chyb, kontrolou životnosti objektů atd.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Dyon - spojení předností Rustu a dynamicky typovaných programovacích jazyků (dokončení)</a></p>
<p><a href="#k02">2. Smyčky konstruované pomocí ∃ a ∀</a></p>
<p><a href="#k03">*** 3. Získání přesnějších informací o výsledcích smyček: klauzule where, why a why not</a></p>
<p><a href="#k04">4. Použití klauzule where u smyček <strong>min</strong> a <strong>max</strong></a></p>
<p><a href="#k05">*** 5. Použití klauzulí why a why not u smyček ∃ a ∀</a></p>
<p><a href="#k06">6. Datový typ <strong>Option</strong></a></p>
<p><a href="#k07">7. Datový typ <strong>Result</strong></a></p>
<p><a href="#k08">*** 8. Operátor ?</a></p>
<p><a href="#k09">*** 9. &bdquo;Probublávání&ldquo; hodnot none() a err(x) při použití operátoru ?</a></p>
<p><a href="#k10">*** 10. Kontrola modifikátoru <strong>mut</strong> u parametrů a argumentů funkcí</a></p>
<p><a href="#k11">*** 11. Uživatelsky definované objekty</a></p>
<p><a href="#k12">*** 12. Uživatelsky definované ad-hoc typy</a></p>
<p><a href="#k13">*** 13. Kontrola hodnot atributů</a></p>
<p><a href="#k14">*** 14. Pojmenované argumenty funkcí</a></p>
<p><a href="#k15">*** 15. Životnost objektů</a></p>
<p><a href="#k16">*** 16. Použití funkce <strong>clone</strong></a></p>
<p><a href="#k17">*** 17. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k18">18. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Dyon - spojení předností Rustu a dynamicky typovaných programovacích jazyků (dokončení)</h2>

<p></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Smyčky konstruované pomocí ∃ a ∀</h2>

<p>Již <a
href="https://www.root.cz/clanky/dyon-spojeni-prednosti-rustu-a-dynamicky-typovanych-programovacich-jazyku/">minule</a>
jsme se seznámili s&nbsp;tím, že kromě dvou univerzálních smyček nazvaných
<strong>loop</strong> (nekonečná smyčka) a <strong>for</strong> (několik forem
počítané smyčky i smyčky typu for-each) existují v&nbsp;jazyku Dyon i další
varianty programových smyček, které se typicky používají pro zpracování polí
(ostatně práce s&nbsp;poli tvoří základ pro většinu skriptů, které jsou
v&nbsp;Dyonu psány). Připomeňme si, že můžeme použít tyto smyčky:</p>

<table>
<tr><th>Konstrukce</th><th>Alternativní zápis</th><th>Význam</th></tr>
<tr><td>sift</td><td>&nbsp;</td><td>vytvoření pole z&nbsp;předávaných hodnot</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>sum</td><td>∑</td><td>suma prvků</td></tr>
<tr><td>prod</td><td>∏</td><td>výsledek vynásobení všech prvků</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>min</td><td>&nbsp;</td><td>zjištění minima</td></tr>
<tr><td>max</td><td>&nbsp;</td><td>zjištění maxima</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>any</td><td>∃</td><td>test, zda je výraz pravdivý alespoň pro jeden prvek</td></tr>
<tr><td>all</td><td>∀</td><td>test, zda je výraz pravdivý pro všechny prvky</td></tr>
</table>

<p>Ve skutečnosti je možné většinu těchto smyček chápat jako specializovanou
formu <strong>reduce</strong> s&nbsp;počáteční hodnotou akumulátoru a funkcí
aplikovanou postupně na prvky, kterými se iteruje. Viditelné je to zejména u
těchto šesti smyček:</p>

<table>
<tr><th>Smyčka</th><th>Prováděná operace</th><th>Počáteční hodnota</th></tr>
<tr><td>sum</td><td>+</td><td>0</td></tr>
<tr><td>prod</td><td>*</td><td>1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>min</td><td>&lt; acc</td><td>none()</td></tr>
<tr><td>max</td><td>&gt; acc</td><td>none()</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>any</td><td>logický součet</td><td>false</td></tr>
<tr><td>all</td><td>logický součin</td><td>true</td></tr>
</table>

<p>Podívejme se nyní na způsob použití programových smyček <strong>all</strong>
a <strong>any</strong> pro zjištění, zda nějaké jednorozměrné pole obsahuje
alespoň jednu zápornou hodnotu či zda jsou všechny hodnoty kladné. Můžeme
použít obou typů smyček. Povšimněte si způsobu zápisu podmínky do složených
závorek:</p>

<pre>
fn special_loops_all_any() {
    println("Special loops: all, any")
&nbsp;
    a := [3,2,1,10,1]
    println(a)
&nbsp;
    has_negative_values := any i { a[i] &lt; 0 }
    println(has_negative_values)
&nbsp;
    all_values_positive := all i { a[i] &gt; 0 }
    println(all_values_positive)
&nbsp;
    a := [3,2,-1,10,1]
    println(a)
&nbsp;
    has_negative_values := any i { a[i] &lt; 0 }
    println(has_negative_values)
&nbsp;
    all_values_positive := all i { a[i] &gt; 0 }
    println(all_values_positive)
&nbsp;
    println("")
}
</pre>

<p>Výsledek běhu této funkce:</p>

<pre>
Special loops: all, any
[3, 2, 1, 10, 1]
false
true
[3, 2, -1, 10, 1]
true
false
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Získání přesnějších informací o výsledcích smyček: klauzule where, why a why not</h2>

<p></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Použití klauzule where u smyček <strong>min</strong> a <strong>max</strong></h2>

<p>Klauzuli <strong>where</strong> použijeme především u programových smyček
<strong>min</strong> a <strong>max</strong>, protože tak můžeme velmi snadno
získat index prvku s&nbsp;minimální či naopak maximální hodnotou. Použití je
velmi jednoduché, jak je to ostatně patrné z&nbsp;následující funkce, kde je
<strong>where</strong> zvýrazněno:</p>

<pre>
fn special_loops_min_max_secrets() {
    println("Special loops: min max, secrets")
&nbsp;
    a := [3,2,1,10,1]
    println(a)
&nbsp;
    minimum := min i { a[i] }
    print("Min: ")
    print(minimum)
    print(" at index: ")
    println(<strong>where(minimum)</strong>)
&nbsp;
    maximum := max i { a[i] }
    print("Max: ")
    print(maximum)
    print(" at index: ")
    println(<strong>where(maximum)</strong>)
&nbsp;
    println("")
}
</pre>

<p>Výsledek běhu této funkce:</p>

<pre>
Special loops: min max, secrets
[3, 2, 1, 10, 1]
Min: 1 at index: [2]
Max: 10 at index: [3]
</pre>

<p>Poznámka: povšimněte si, že pokud vstupní pole obsahuje alespoň jeden prvek,
je zajištěno, že <strong>where</strong> vrátí index prvku, na rozdíl od dále
popsané klauzule <strong>why</strong>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Použití klauzulí why a why not u smyček ∃ a ∀</h2>

<p>Zatímco u klauze <strong>where</strong> jsme měli jistotu, že vrátí index prvku s&nbsp;minimální či maximální hodnotou, je tomu u klauzulí <strong>why</strong> a <strong>why not</strong> poněkud jinak, protože tyto klauzule jsou použity v&nbsp;kombinaci s&nbsp;programovými smyčkami ∃ a ∀. U smyčky </p>

<pre>
fn special_loops_any_secrets() {
    println("Special loops: any, secrets")
&nbsp;
    a := [3,2,1,10,1]
    println(a)
&nbsp;
    has_negative_values := any i { a[i] &lt; 0 }
    print("Has negative values: ")
    if has_negative_values {
        print("Yes, at index: ")
        println(why(has_negative_values))
    } else {
        println("No")
    }
&nbsp;
    a := [3,2,-1,10,-1]
    println(a)
&nbsp;
    has_negative_values := any i { a[i] &lt; 0 }
    print("Has negative values: ")
    if has_negative_values {
        print("Yes, at index: ")
        println(why(has_negative_values))
    } else {
        println("No")
    }
&nbsp;
    println("")
}
</pre>

<p>Výsledek běhu této funkce:</p>

<pre>
Special loops: any, secrets
[3, 2, 1, 10, 1]
Has negative values: No
[3, 2, -1, 10, -1]
Has negative values: Yes, at index: [2]
</pre>

<pre>
fn special_loops_all_secrets() {
    println("Special loops: all, secrets")
&nbsp;
    a := [3,2,1,10,1]
    println(a)
&nbsp;
    all_values_positive := all i { a[i] &gt; 0 }
    print("All values are positive: ")
    if all_values_positive {
        println("Yes")
    } else {
        print("No, 1st non-positive value found at index: ")
        println(why(!all_values_positive))
    }
&nbsp;
    a := [3,2,-1,10,-1]
    println(a)
&nbsp;
    all_values_positive := all i { a[i] &gt; 0 }
    print("All values are positive: ")
    if all_values_positive {
        println("Yes")
    } else {
        print("No, 1st non-positive value found at index: ")
        println(why(!all_values_positive))
    }

    println("")
}
</pre>

<p>Výsledek běhu této funkce:</p>

<pre>
Special loops: all, secrets
[3, 2, 1, 10, 1]
All values are positive: Yes
[3, 2, -1, 10, -1]
All values are positive: No, 1st non-positive value found at index: [2]
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Datový typ <strong>Option</strong></h2>

<p>S&nbsp;datovým typem <strong>Option</strong> jsme se již <a
href="https://www.root.cz/clanky/datovy-typ-option-v-programovacim-jazyku-rust/">setkali
při popisu vlastností programovacího jazyka Rust</a>. Připomeňme si tedy, že
díky existenci tohoto typu je možné elegantně obejít většinu nectností
speciálních hodnot (někde ukazatelů, jinde zase pro změnu referencí) typu
<strong>None</strong>, <strong>null</strong> či <strong>nil</strong>. Při
použití typu <strong>Option</strong> je totiž explicitně specifikováno, že je
nějaká hodnota nepovinná popř.&nbsp;volitelná (podle kontextu). Navíc jsme jako
programátoři přinuceni se explicitně zpracováním nepovinné/volitelné hodnoty
zabývat. Datový typ <strong>Option</strong> tvoří obálku nad samotnou
reprezentovanou hodnotou popř.&nbsp;reprezentuje prázdnou obálku. S&nbsp;tímto
typem jsou spojeny především tři funkce:</p>

<table>
<tr><th>Funkce</th><th>Význam</th></tr>
<tr><td>some(any)</td><td>vytvoří obálku s&nbsp;hodnotou libovolného typu</td></tr>
<tr><td>none()</td><td>vytvoří prázdnou obálku (jedná se o jedináčka)</td></tr>
<tr><td>unwrap(option)</td><td>(rozbalení) vrátí hodnotu uloženou v&nbsp;obálce</td></tr>
</table>

<p>Podívejme se na použití těchto tří funkcí. Je to velmi snadné:</p>

<pre>
o := some(42)
println(o)
&nbsp;
o = none()
println(o)
&nbsp;
o = some(2)
println(unwrap(o))
&nbsp;
o = none()
//println(unwrap(o))
&nbsp;
if o != none() {
    println(unwrap(o))
}
</pre>

<p>Povšimněte si zejména testu, zda je obálka prázdná (zde se kód odlišuje od
Rustu).</p>

<p>Výsledek běhu příkladu:</p>

<pre>
some(42)
none()
2
false
</pre>

<p><strong>unwrap()</strong> nelze volat pro hodnotu
<strong>none()</strong>:</p>

<pre>
 --- ERROR --- 
main (src/main.dyon)
test_option_type (src/main.dyon)
unwrap
&nbsp;
Expected `some(_)`
12,20:     println(unwrap(o))
12,20:                    ^
</pre>

<p>Poznámka: prozatím nelze použít pattern matching, který by se zde hodil.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Datový typ <strong>Result</strong></h2>

<p>I další užitečný datový typ nazvaný <strong>Result</strong> jsme si již <a
href="https://www.root.cz/clanky/reakce-na-chyby-v-programovacim-jazyku-rust/">v&nbsp;tomto
seriálu popsali</a>, ovšem v&nbsp;kontextu Rustu a nikoli Dyonu. Připomeňme si
tedy, že v&nbsp;mnoha případech nemusí být použití datového typu
<strong>Option</strong> tím nejlepším řešením. Pro příklad nemusíme chodit
daleko &ndash; předpokládejme, že budeme chtít, aby například funkce pro dělení
celých čísel vracela v&nbsp;případě pokusu o dělení nulou chybové hlášení a
nikoli nicneříkající hodnotu <strong>none()</strong>. K&nbsp;tomuto účelu se
v&nbsp;programovacím jazyku Rust a nyní i Dyon používá datová struktura nazvaná
příhodně <strong>Result</strong>. Tato datová struktura se podobá Option, ovšem
s&nbsp;tím rozdílem, že obaluje buď výsledek (třeba návratovou hodnotu volané
funkce) nebo informaci o chybě. K&nbsp;dispozici jsou následující pomocné
funkce:</p>

<table>
<tr><th>Funkce</th><th>Význam</th></tr>
<tr><td>ok(any)</td><td>vytvoří obálku s&nbsp;hodnotou libovolného typu</td></tr>
<tr><td>err(any)</td><td>vytvoří obálku s&nbsp;hodnotou reprezentující chybu (například chybové hlášení)</td></tr>
<tr><td>is_ok(result)</td><td>dotaz (predikát), zda pracujeme s&nbsp;bezchybnou hodnotou</td></tr>
<tr><td>is_err(result)</td><td>dotaz (predikát), zda pracujeme s&nbsp;informací o chybě</td></tr>
<tr><td>unwrap(result)</td><td>(rozbalení) vrátí hodnotu uloženou v&nbsp;obálce</td></tr>
<tr><td>unwrap_err(result)</td><td>(rozbalení) vrátí hodnotu reprezentující chybu</td></tr>
</table>

<p>Opět se podívejme na jednoduchý příklad:</p>

<pre>
r := ok(42)
println(r)
println(is_ok(r))
println(is_err(r))
&nbsp;
r = err("Very serious")
println(r)
println(is_ok(r))
println(is_err(r))
&nbsp;
r = ok(2)
println(unwrap(r))
//println(unwrap_err(r))
&nbsp;
r = err("Very serious")
//println(unwrap(r))
println(unwrap_err(r))
&nbsp;
r = ok(42)
if is_ok(r) {
    println(unwrap(r))
} else {
    println(unwrap_err(r))
}
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
ok(42)
true
false
err("Very serious")
false
true
2
Very serious
42
</pre>

<p>Poznámka: opět platí, že prozatím nelze použít pattern matching, který by se
zde hodil.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Operátor ?</h2>

<p></p>

<pre>
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. &bdquo;Probublávání&ldquo; hodnot none() a err(x) při použití operátoru ?</h2>

<p></p>

<pre>
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Kontrola modifikátoru <strong>mut</strong> u parametrů a argumentů funkcí</h2>

<p></p>

<pre>
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Uživatelsky definované objekty</h2>

<p></p>

<pre>
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Uživatelsky definované ad-hoc typy</h2>

<p></p>

<pre>
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Kontrola hodnot atributů</h2>

<p></p>

<pre>
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Pojmenované argumenty funkcí</h2>

<p></p>

<pre>
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Životnost objektů</h2>

<p></p>

<pre>
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Použití funkce <strong>clone</strong></h2>

<p></p>

<pre>
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Repositář s&nbsp;demonstračními příklady</h2>

<p>Většina ukázek z&nbsp;předchozích kapitol byla přidána do několika
demonstračních příkladů, které byly uloženy do Git repositáře dostupného na
adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě
bez nutnosti klonovat celý repositář (ovšem u projektů je lepší mít celý
repositář, abyste nemuseli pracně stahovat všechny potřebné soubory):</p>

<table>
<tr><th>Příklad</th><th>Adresa</th></tr>
<tr><td>dyon-more-loops</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-more-loops/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-more-loops/Cargo.toml</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-more-loops/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-more-loops/src/main.rs</a></td></tr>
<tr><td>main.dyon</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-more-loops/src/main.dyon">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-more-loops/src/main.dyon</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>dyon-option-result</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-option-result/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-option-result/Cargo.toml</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-option-result/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-option-result/src/main.rs</a></td></tr>
<tr><td>main.dyon</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-option-result/src/main.dyon">https://github.com/tisnik/presentations/blob/master/rust/projects/dyon-option-result/src/main.dyon</a></td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Odkazy na Internetu</h2>

<ol>

<li>Secrets design - optional information in `bool` and `f64`<br />
<a href="https://github.com/PistonDevelopers/dyon/issues/266">https://github.com/PistonDevelopers/dyon/issues/266</a>
</li>

<li>Option value design<br />
<a href="https://github.com/PistonDevelopers/dyon/issues/172">https://github.com/PistonDevelopers/dyon/issues/172</a>
</li>

<li>Result value design (`err(x)/ok(x)`)<br />
<a href="https://github.com/PistonDevelopers/dyon/issues/82">https://github.com/PistonDevelopers/dyon/issues/82</a>
</li>

<li>∑/sum, ∏/prod, min, max, sift, ∃/any, ∀/all loops<br />
<a href="https://github.com/PistonDevelopers/dyon/issues/119">https://github.com/PistonDevelopers/dyon/issues/119</a>
</li>

<li>Dyon: tutoriál<br />
<a href="http://www.piston.rs/dyon-tutorial/">http://www.piston.rs/dyon-tutorial/</a>
</li>

<li>Repositář s&nbsp;programovacím jazykem Dyon<br />
<a href="https://github.com/PistonDevelopers/dyon">https://github.com/PistonDevelopers/dyon</a>
</li>

<li>Dyon: A rusty dynamically typed scripting language<br />
<a href="https://rust.libhunt.com/project/dyon">https://rust.libhunt.com/project/dyon</a>
</li>

<li>Dyon snippets<br />
<a href="https://github.com/PistonDevelopers/dyon_snippets">https://github.com/PistonDevelopers/dyon_snippets</a>
</li>

<li>Scripting without garbage collector<br />
<a href="http://blog.piston.rs/2016/02/21/scripting-without-garbage-collector/">http://blog.piston.rs/2016/02/21/scripting-without-garbage-collector/</a>
</li>

<li>Podpora pro &bdquo;matematické&ldquo; smyčky<br />
<a href="https://github.com/PistonDevelopers/dyon/issues/119">https://github.com/PistonDevelopers/dyon/issues/119</a>
</li>

<li>Rust-clippy Wiki<br />
<a href="https://github.com/rust-lang-nursery/rust-clippy/wiki">https://github.com/rust-lang-nursery/rust-clippy/wiki</a>
</li>

<li>Rust-clippy<br />
<a href="https://rust.libhunt.com/project/rust-clippy">https://rust.libhunt.com/project/rust-clippy</a>
</li>

<li>ndarray - dokumentace k&nbsp;modulu<br />
<a href="https://bluss.github.io/rust-ndarray/master/ndarray/index.html">https://bluss.github.io/rust-ndarray/master/ndarray/index.html</a>
</li>

<li>ndarray - Crate<br />
<a href="https://crates.io/crates/ndarray">https://crates.io/crates/ndarray</a>
</li>

<li>rustup<br />
<a href="https://www.rustup.rs/">https://www.rustup.rs/</a>
</li>

<li>rustup: the Rust toolchain installer (Git repositář + dokumentace)<br />
<a href="https://github.com/rust-lang-nursery/rustup.rs">https://github.com/rust-lang-nursery/rustup.rs</a>
</li>

<li>The Rust FFI Omnibus<br />
<a href="http://jakegoulding.com/rust-ffi-omnibus/">http://jakegoulding.com/rust-ffi-omnibus/</a>
</li>

<li>Build Script Support<br />
<a href="http://doc.crates.io/build-script.html">http://doc.crates.io/build-script.html</a>
</li>

<li>Calling Rust From Python<br />
<a href="https://bheisler.github.io/post/calling-rust-in-python/">https://bheisler.github.io/post/calling-rust-in-python/</a>
</li>

<li>Calling Rust in Python (komentáře k předchozímu článku)<br />
<a href="https://www.reddit.com/r/rust/comments/63iy5a/calling_rust_in_python/">https://www.reddit.com/r/rust/comments/63iy5a/calling_rust_in_python/</a>
</li>

<li>CFFI Documentation<br />
<a href="https://cffi.readthedocs.io/en/latest/">https://cffi.readthedocs.io/en/latest/</a>
</li>

<li>Build Script Support<br />
<a href="http://doc.crates.io/build-script.html">http://doc.crates.io/build-script.html</a>
</li>

<li>Creating a shared and static library with the gnu compiler [gcc]<br />
<a href="http://www.adp-gmbh.ch/cpp/gcc/create_lib.html">http://www.adp-gmbh.ch/cpp/gcc/create_lib.html</a>
</li>

<li>ctypes — A foreign function library for Python<br />
<a href="https://docs.python.org/2/library/ctypes.html">https://docs.python.org/2/library/ctypes.html</a>
</li>

<li>FFI: Foreign Function Interface<br />
<a href="https://doc.rust-lang.org/book/ffi.html">https://doc.rust-lang.org/book/ffi.html</a>
</li>

<li>Primitive Type pointer<br />
<a href="https://doc.rust-lang.org/std/primitive.pointer.html">https://doc.rust-lang.org/std/primitive.pointer.html</a>
</li>

<li>Cargo: správce projektů a balíčků pro programovací jazyk Rust<br />
<a href="https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/">https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/</a>
</li>

<li>Network Communication and Serialization in Rust<br />
<a href="https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/">https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/</a>
</li>

<li>Crate bincode<br />
<a href="http://tyoverby.com/bincode/bincode/index.html">http://tyoverby.com/bincode/bincode/index.html</a>
</li>

<li>Struct std::fs::File<br />
<a href="https://doc.rust-lang.org/std/fs/struct.File.html">https://doc.rust-lang.org/std/fs/struct.File.html</a>
</li>

<li>Trait std::io::Seek<br />
<a href="https://doc.rust-lang.org/std/io/trait.Seek.html">https://doc.rust-lang.org/std/io/trait.Seek.html</a>
</li>

<li>Trait std::io::Read<br />
<a href="https://doc.rust-lang.org/std/io/trait.Read.html">https://doc.rust-lang.org/std/io/trait.Read.html</a>
</li>

<li>Trait std::io::Write<br />
<a href="https://doc.rust-lang.org/std/io/trait.Write.html">https://doc.rust-lang.org/std/io/trait.Write.html</a>
</li>

<li>Trait std::io::BufRead<br />
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html">https://doc.rust-lang.org/std/io/trait.BufRead.html</a>
</li>

<li>Module std::io::prelude<br />
<a href="https://doc.rust-lang.org/std/io/prelude/index.html">https://doc.rust-lang.org/std/io/prelude/index.html</a>
</li>

<li>std::net::IpAddr<br />
<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">https://doc.rust-lang.org/std/net/enum.IpAddr.html</a>
</li>

<li>std::net::Ipv4Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html</a>
</li>

<li>std::net::Ipv6Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html</a>
</li>

<li>TcpListener<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">https://doc.rust-lang.org/std/net/struct.TcpListener.html</a>
</li>

<li>TcpStream<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html">https://doc.rust-lang.org/std/net/struct.TcpStream.html</a>
</li>

<li>Binary heap (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Binary_heap">https://en.wikipedia.org/wiki/Binary_heap</a>
</li>

<li>Binární halda (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda">https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda</a>
</li>

<li>Halda (datová struktura)<br />
<a href="https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29">https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29</a>
</li>

<li>Struct std::collections::HashSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">https://doc.rust-lang.org/std/collections/struct.HashSet.html</a>
</li>

<li>Struct std::collections::BTreeSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">https://doc.rust-lang.org/std/collections/struct.BTreeSet.html</a>
</li>

<li>Struct std::collections::BinaryHeap<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html">https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html</a>
</li>

<li>Set (abstract data type)<br />
<a href="https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support">https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support</a>
</li>

<li>Associative array<br />
<a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a>
</li>

<li>Hash Table<br />
<a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a>
</li>

<li>B-tree<br />
<a href="https://en.wikipedia.org/wiki/B-tree">https://en.wikipedia.org/wiki/B-tree</a>
</li>

<li>Pedro Celis: Robin Hood Hashing (naskenované PDF!)<br />
<a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf</a>
</li>

<li>Robin Hood hashing<br />
<a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">http://codecapsule.com/2013/11/11/robin-hood-hashing/</a>
</li>

<li>Robin Hood hashing: backward shift deletion<br />
<a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/</a>
</li>

<li>Module std::collections<br />
<a href="https://doc.rust-lang.org/std/collections/">https://doc.rust-lang.org/std/collections/</a>
</li>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Struct std::collections::VecDeque<br />
<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">https://doc.rust-lang.org/std/collections/struct.VecDeque.html</a>
</li>

<li>Struct std::collections::LinkedList<br />
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">https://doc.rust-lang.org/std/collections/struct.LinkedList.html</a>
</li>

<li>Module std::fmt<br />
<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>
</li>

<li>Macro std::println<br />
<a href="https://doc.rust-lang.org/std/macro.println.html">https://doc.rust-lang.org/std/macro.println.html</a>
</li>

<li>Enum std::result::Result<br />
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">https://doc.rust-lang.org/std/result/enum.Result.html</a>
</li>

<li>Module std::result<br />
<a href="https://doc.rust-lang.org/std/result/">https://doc.rust-lang.org/std/result/</a>
</li>

<li>Result<br />
<a href="http://rustbyexample.com/std/result.html">http://rustbyexample.com/std/result.html</a>
</li>

<li>Rust stdlib: Option<br />
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">https://doc.rust-lang.org/std/option/enum.Option.html</a>
</li>

<li>Module std::option<br />
<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>
</li>

<li>Rust by example: option<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>Rust by example: if-let<br />
<a href="http://rustbyexample.com/flow_control/if_let.html">http://rustbyexample.com/flow_control/if_let.html</a>
</li>

<li>Rust by example: while let<br />
<a href="http://rustbyexample.com/flow_control/while_let.html">http://rustbyexample.com/flow_control/while_let.html</a>
</li>

<li>Rust by example: Option&lt;i32&gt;<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

