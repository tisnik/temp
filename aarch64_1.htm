<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>64bitové mikroprocesory s architekturou AArch64</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>64bitové mikroprocesory s architekturou AArch64</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. 64bitové mikroprocesory s&nbsp;architekturou AArch64</a></p>
<p><a href="#k02">2. Proč vlastně architektura AArch64 vznikla?</a></p>
<p><a href="#k03">3. Od 32bitových RISCových ARMů k&nbsp;architektuře AArch64</a></p>
<p><a href="#k04">4. Rodina jader ARMv8-A</a></p>
<p><a href="#k05">5. Odlišnosti mezi původní 32bitovou architekturou ARM a AArch64</a></p>
<p><a href="#k06">6. AArch64 a další RISCové i CISCové architektury</a></p>
<p><a href="#k07">7. Prediktory skoků</a></p>
<p><a href="#k08">8. Provádění instrukcí mimo pořadí (out of order)</a></p>
<p><a href="#k09">9. Aritmeticko-logická jednotka a matematický koprocesor</a></p>
<p><a href="#k10">10. Sada pracovních registrů</a></p>
<p><a href="#k11">11. Speciální význam třicátého druhého registru</a></p>
<p><a href="#k12">12. Operace s&nbsp;32bitovými a 64bitovými operandy</a></p>
<p><a href="#k13">13. Rozšířené možnosti adresování</a></p>
<p><a href="#k14">14. Zjednodušení instrukční sady v&nbsp;porovnání s&nbsp;32bitovými ARMy</a></p>
<p><a href="#k15">*** 15. Instrukční sada AArch64</a></p>
<p><a href="#k16">*** 16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. 64bitové mikroprocesory s&nbsp;architekturou AArch64</h2>

<p>V&nbsp;poměrně velkém množství moderních elektronických zařízení, ať již se
jedná o tablety či o jednodeskové mikropočítače, se můžeme setkat
s&nbsp;mikroprocesory založenými na 64bitové architektuře <i>AArch64</i>
vyvinuté ve společnosti ARM. Tato architektura je sice do jisté míry odvozena
od původní &bdquo;klasické&ldquo; 32bitové RISCové architektury ARM (dnes pro
odlišení nazývané ARM32 či dokonce jen A32), ovšem při přechodu na 64bitový
systém došlo k&nbsp;mnoha podstatným změnám, které se týkají jak počtu a funkce
pracovních registrů, tak i instrukční sady, jež se v&nbsp;některých ohledech od
původní RISCové sady dosti podstatným způsobem odlišuje. Čipy s&nbsp;jádry
AArch64 dnes patří ve &bdquo;světě ARM&ldquo; mezi nejvýkonnější a licenci pro
jejich použití už získala řada společností, včetně Apple (nejznámější je
pravděpodobně její SoC/system on chip nazvaný Apple A7, který je použitý
v&nbsp;iPhone 5S), NVidie, Qualcommu či Samsungu. Zajímavé ovšem je, že
například TI sice používá kombinaci DSP+ARM, ovšem prozatím se drží spíše
32bitových ARMovských jader, protože výpočetně náročné části jsou prováděny
právě na DSP.</p>

<a href="http://i.iinfo.cz/images/605/pc118sada1-3.jpg"><img src="http://i.iinfo.cz/images/605/pc118sada1-3-prev.jpg" width="370" height="257" alt=" " /></a>
<p><i>Obrázek 1: Osmibitový mikropočítač Acorn BBC Micro založený na slavném
osmibitovém mikroprocesoru MOS 6502. Ve chvíli, kdy výkon tohoto mikroprocesoru
přestal dostačovat pro další modely počítače, se firma ARM rozhodla, že vyvine
vlastní mikroprocesor.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Proč vlastně architektura AArch64 vznikla?</h2>

<p>Existuje hned několik dobrých důvodů, proč se společnost ARM Holdings
odhodlala k&nbsp;poměrně rizikovému a velmi pravděpodobně i finančně náročnému
kroku, tj.&nbsp;k&nbsp;vývoji zcela nové a zpětně nekompatibilní architektury.
Mikroprocesory ARM se totiž začaly používat v&nbsp;nových oblastech, například
pro některé servery, kde již možnosti 32bitových adres nemusely být
dostačující. Navíc původní 32bitová architektura začala vykazovat určité známky
zastaralosti, což pravděpodobně není až tak překvapivé, zvláště když si
uvědomíme, že první RISCové ARMy začaly být testovány již v&nbsp;roce 1985,
tj.&nbsp;prakticky před 32 roky. Bylo tedy jen logické, že se vylepšení původní
architektury a současně přechod na 64bitovou aritmeticko-logickou jednotku a
adresování, provede v&nbsp;jednom kroku a současně se zachová původní portfolia
mikroprocesorů a mikrořadičů. Nová architektura i s&nbsp;ní spojená instrukční
sada byly navrženy s&nbsp;ohledem na moderní překladače a virtuální stroje.
Společnost ARM se v&nbsp;tomto ohledu mohla opřít o mnohaleté studium chování
existujících aplikací (ostatně právě na základě tohoto studia byly
v&nbsp;minulosti vytvořeny instrukční sady Thumb a Thumb-2).</p>

<img src="http://i.iinfo.cz/images/605/pc118sada1-2.jpg" width="400" height="463" alt=" " />
<p><i>Obrázek 2: Dobový plakát s&nbsp;počítačem Acorn BBC Micro.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Od 32bitových RISCových ARMů k&nbsp;architektuře AArch64</h2>

<p>Mikroprocesory a mikrořadiče ARM za sebou mají dlouhou dobu vývoje, takže
není divu, že postupně vznikaly různé generace těchto čipů, které se od sebe
odlišovaly jak svým výpočetním výkonem, tak i různými změnami v&nbsp;instrukční
sadě (obecně lze říci, že jednotlivá jádra mezi sebou nejsou binárně
kompatibilní), uspořádáním cache, počtem řezů (pipeline), použitými submoduly
(hardwarová násobička, dělička, jednotka pro SIMD operace, matematický
koprocesor, DSP) atd. Čipy ARM je možné rozlišit podle architektury, přičemž
základní dělení je naznačeno v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Architektura</th><th>Adresová/datová sběrnice</th><th>Jádro</th><th>Poznámka/profil (u Cortex)</th></tr>
<tr><td>1</td><td>ARMv1</td><td>26/32 bitů</td><td>ARM1</td><td>první implementace, technologické demo</td></tr>
<tr><td>2</td><td>ARMv2</td><td>26/32 bitů</td><td>ARM2, ARM3</td><td>přidána HW násobička a MMU</td></tr>
<tr><td>3</td><td>ARMv3</td><td>26/32 bitů</td><td>ARM6, ARM7</td><td></td></tr>
<tr><td>4</td><td>ARMv4</td><td>26/32 bitů</td><td>ARM8</td><td>patří sem mj.&nbsp;i řada čipů StrongARM</td></tr>
<tr><td>5</td><td>ARMv5</td><td>32 bitů</td><td>ARM7EJ, ARM9E, ARM10E</td><td>lze najít ve starších zařízeních</td></tr>
<tr><td>6</td><td>ARMv6</td><td>32 bitů</td><td>ARM11</td><td>dodnes používaná jádra</td></tr>
<tr><td>7</td><td>ARMv6-M</td><td>32 bitů</td><td>Cortex-M0, Cortex-M0+, Cortex-M1</td><td>mikrořadiče (M v&nbsp;názvu)</td></tr>
<tr><td>8</td><td>ARMv7-M</td><td>32 bitů</td><td>Cortex-M3</td><td>mikrořadiče (poznáme podle M v&nbsp;názvu)</td></tr>
<tr><td>9</td><td>ARMv7E-M</td><td>32 bitů</td><td>Cortex-M4, Cortex-M7</td><td>mikrořadiče (M v&nbsp;názvu)</td></tr>
<tr><td>10</td><td>ARMv7-R</td><td>32 bitů</td><td>Cortex-R4, Cortex-R5, Cortex-R7</td><td>realtime aplikace (R v&nbsp;názvu)</td></tr>
<tr><td>11</td><td>ARMv7-A </td><td>32 bitů</td><td>Cortex-A5, Cortex-A7, Cortex-A8, Cortex-A9, Cortex-A12, Cortex-A15, Cortex-A17</td><td>smartphony atd.</td></tr>
<tr><td>12</td><td>ARMv8-A </td><td>32/64 bitů</td><td>Cortex-A35, Cortex-A53, A57, A72 a A73</td><td>smartphony atd.</td></tr>
</table>

<img src="http://i.iinfo.cz/images/491/pc148-1.jpg" width="451" height="338" alt=" " />
<p><i>Obrázek 3: Osobní počítač firmy Acorn, který byl vybavený mikroprocesorem
ARM s&nbsp;architekturou RISC. Minimálně v&nbsp;Británii se jednalo o jeden
z&nbsp;přelomových počítačů.</i></p>

<p>V&nbsp;dalším textu nás budou zajímat především čipy s&nbsp;architekturou
<strong>ARMv8-A</strong>, která je vypsána na posledním řádku předchozí
tabulky. Jader s&nbsp;architekturou ARMv8-8A existuje hned několik; liší se od
sebe především tím, zda se u nich preferuje spíše vysoký výpočetní výkon či zda
se naopak jedná o jádra s&nbsp;vyváženým poměrem spotřeba energie/výpočetní
výkon. Mimochodem &ndash; povšimněte si koncovky A u jména mikroprocesorového
jádra. Ta značí, že tato jádra jsou určena pro běžnou aplikační elektroniku,
smartphony, počítače atd. Jádra s&nbsp;koncovkou M jsou určena pro mikrořadiče
a jádra s&nbsp;koncovkou R pro realtime aplikace. Číslování jader ARMv8-A může
vést ke zmatkům, proto jsou tato jádra v&nbsp;další tabulce rozdělena podle
toho, jaká vlastnost u nich převažuje. Povšimněte si, že i přes relativní
modernost ARMv8-A už existují jádra starší, která jsou postupně nahrazována
vylepšenými variantami:</p>

<table>
<tr><th>Priorita</th><th>Jádro ARMv7-A</th><th>Jádro ARMv8-A</th><th>Novější model</th></tr>
<tr><td>vysoký výkon</td><td>Cortex-A17</td><td>Cortex-A72</td><td>Cortex-A73, Cortex-A75</td></tr>
<tr><td>vysoký výkon</td><td>Cortex-A15</td><td>Cortex-A57</td><td>&times;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>el.&nbsp;efektivita</td><td>Cortex-A9</td><td>Cortex-A53</td><td>Cortex-A55</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>vysoká efektivita</td><td>Cortex-A7</td><td>Cortex-A35</td><td>&times;</td></tr>
<tr><td>vysoká efektivita</td><td>Cortex-A5</td><td>Cortex-A35</td><td>&times;</td></tr>
</table>

<img src="http://i.iinfo.cz/images/491/pc148-2.png" width="320" height="256" alt=" " />
<p><i>Obrázek 4: Hra Zarch od známého programátora Davida Brabena (který je
spoluautorem slavné hry Elite) pro počítač Acorn Archimedes. Výkon čipů ARM byl
(na svou dobu) tak velký (cca 4,5 MIPS pro 32bitové operace), že postačoval na
SW rendering této hry &ndash; Acorn Archimedes totiž neměl žádné multimediální
koprocesory, na rozdíl od Amigy či Atari ST, které ovšem měly slabší CPU (0,5
pro 32bitové operace až maximálně 2 MIPSy pro operace 32bitové).</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Rodina jader ARMv8-A</h2>

<p>V&nbsp;současnosti používané 64bitové čipy ARM patří do rodiny ARMv8-A.
Nalezneme zde například jádra <a
href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">Cortex-A35</a>,
<a
href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">Cortex-A53</a>,
<a
href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">Cortex-A57</a>,
<a
href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">Cortex-A72</a>
a <a
href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">Cortex-A73</a>,
které se od sebe odlišují především výpočetním výkonem a energetickými nároky.
Čipy s&nbsp;těmito jádry lze nalézt ve výkonných tabletech, ale i serverech.
Vzhledem k&nbsp;tomu, že u ARMv8-A je zaručena zpětná kompatibilita
s&nbsp;existující 32bitovou architekturou ARMv7-A, znamená to, že
mikroprocesory je možné přepnout mezi 32bitovým kompatibilním režimem a
plnohodnotným 64bitovým režimem (ve skutečnosti se v&nbsp;32bitovém režimu je
možné provést přepnutí mezi A32 a T32, tj.&nbsp;mezi původními RISCovými
instrukcemi a instrukcemi Thumb/Thumb2).</p>

<p>Zajímavé je, že i přesto, že všechny typy jader ARMv8-A patří do stejné
rodiny a mají například shodnou instrukční sadu, neplatí to o interní realizaci
čipu. Podle toho, jak výkonná jádra mají být se odlišuje i počet řezů pipeline.
V&nbsp;další tabulce uvádím počet řezů pro jádra vyráběná přímo společností ARM
zatímco například u čipů Cyclone od Apple má pipeline dokonce šestnáct řezů a
Mongoose od Samsungu podle čipu 15 až 17 řezů:</p>

<table>
<tr><th>Jádro</th><th>Revize</th><th>Pipeline</th></tr>
<tr><td>Cortex-A35</td><td>ARMv8-A</td><td>8</td></tr>
<tr><td>Cortex-A53</td><td>ARMv8-A</td><td>8</td></tr>
<tr><td>Cortex-A55</td><td>ARMv8.2-A</td><td>8</td></tr>
<tr><td>Cortex-A57</td><td>ARMv8-A</td><td>15</td></tr>
<tr><td>Cortex-A72</td><td>ARMv8-A</td><td>15</td></tr>
<tr><td>Cortex-A73</td><td>ARMv8-A</td><td>11–12</td></tr>
<tr><td>Cortex-A75</td><td>ARMv8.2-A</td><td>11–13</td></tr>
</table>

<p>Jednotlivé čipy s&nbsp;64bitovými ARMovskými jádry se od sebe odlišují i
konfigurací pamětí cache. Základní stavba cache je sice prakticky shodná
&ndash; L1 cache (cache první úrovně) je striktně rozdělena na cache pro data
(D-cache) a cache pro strojové instrukce (I-cache), zatímco L2 cache (cache
druhé úrovně) je společná pro obě skupiny informací &ndash; ovšem liší se
kapacity cache, opět podle toho, jak výkonný má čip být. U novějších modelů
Cortex-A55 a Cortex-A75 je dokonce podporována i cache třetí úrovně (L3 cache),
která je pochopitelně opět společná pro data i pro instrukce:</p>

<table>
<tr><th>Jádro</th><th>L1 I-cache</th><th>L1 D-cache</th><th>L2 cache</th><th>L3 cache</th></tr>
<tr><td>Cortex-A35</td><td>8–64 </td><td>8–64 </td><td>128 kB–1 MB</td><td>&times;</td></tr>
<tr><td>Cortex-A53</td><td>8–64 </td><td>8–64 </td><td>128 kB–2 MB</td><td>&times;</td></tr>
<tr><td>Cortex-A55</td><td>16–64</td><td>16–64</td><td>0 kB–256 kB / jádro</td><td>až 4MB</td></tr>
<tr><td>Cortex-A57</td><td>48</td><td>32</td><td>0.5–2 MB</td><td>&times;</td></tr>
<tr><td>Cortex-A72</td><td>48</td><td>32</td><td>0.5–4 MB</td><td>&times;</td></tr>
<tr><td>Cortex-A73</td><td>64</td><td>32/64</td><td>1–8 MB</td><td>&times;</td></tr>
<tr><td>Cortex-A75</td><td>64</td><td>64</td><td>256 kB nebo 512 kB / jádro</td><td>až 4MB</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Odlišnosti mezi původní 32bitovou architekturou ARM a AArch64</h2>

<p>Z&nbsp;pohledu programátora pracujícího v&nbsp;assembleru je architektura
AArch64 v&nbsp;několika ohledech odlišná od původní 32bitové architektury.
Především se zvýšil počet pracovních registrů z&nbsp;patnácti na 31. Všechny
registry se navíc rozšířily z&nbsp;třiceti dvou bitů na 64 bitů. Ovšem mnohé
operace stále podporují i 32bitové operandy &ndash; v&nbsp;tomto případě se
použije ta samá skupina registrů, z&nbsp;nichž se ovšem využije jen spodních 32
bitů (nedochází zde tedy k&nbsp;rozdvojení každého 64bitového registru na dva
registry 32bitové, jak to známe z&nbsp;jiných typů procesorů). Podporován je i
matematický koprocesor, jehož struktura se v&nbsp;mnoha ohledech blíží VPS.
Nesmíme zapomenout ani na změny v&nbsp;instrukční sadě, které budou popsány
níže. Poslední důležitým vylepšením je &bdquo;zadrátování&ldquo; podpory pro
AES, SHA-1 a SHA-256, což je využitelné jak na tabletech či smartphonech, tak i
na serverech (o podrobnostech se zmíníme v&nbsp;dalších částech tohoto
seriálu).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. AArch64 a další RISCové i CISCové architektury</h2>

<p>Zajímavé a poučné může být porovnání architektury AArch64 s&nbsp;dalšími
populárními RISCovými i CISCovými architekturami, které je patrné při pohledu
na další tabulku, v&nbsp;níž jsou stručně (bez podrobnějších vysvětlení různých
specialit) vypsány počty a bitové šířky pracovních registrů u některých
oblíbených (i neoblíbených) a používaných mikroprocesorů a mikroprocesorových
jader. Z&nbsp;této tabulky je zřejmé, že klasické CISCové procesory měly
k&nbsp;dispozici menší počet registrů; navíc tyto registry nebyly zcela
univerzální, což platí jak pro procesory řady i386, tak i pro Motorolu 68000
(rozdělení na datové a adresové registry). Naproti tomu většina klasických
RISCových procesorů, tj.&nbsp;MIPS a SPARC, se drží oblíbeného schématu
31&times;32bitů, protože jeden z&nbsp;registrů obsahuje konstantní nulu.
Původní 32bitové čipy ARM (A32) stojí klasicky na pomezí mezi těmito dvěma
extrémy, což se změnilo právě s&nbsp;příchodem A64 (AArch 64):</p>

<table>
<tr><th>Řada</th><th>Architektura</th><th>Registry</th></tr>
<tr><td>Motorola 68000</td><td>CISC</td><td>8&times;32bit + 7&times;32bit</td></tr>
<tr><td>IA-32 (i386)</td><td>CISC</td><td>8&times;32bit</td></tr>
<tr><td>x86_64      </td><td>CISC</td><td>16&times;64bit</td></tr>
<tr><td>IA-64       </td><td>EPIC</td><td>128&times;64bit</td></tr>
<tr><td>Atmel AVR   </td><td>RISC</td><td>32&times;8bit</td></tr>
<tr><td>MIPS (32)   </td><td>RISC</td><td>31&times;32bit + zero</td></tr>
<tr><td>SPARC       </td><td>RISC</td><td>31&times;32bit + zero</td></tr>
<tr><td>RISC-V      </td><td>RISC</td><td>31&times;32bit + zero</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ARM (A32)   </td><td>RISC</td><td>15&times;32bit</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ARM (A64)   </td><td>RISC</td><td>31&times;64bit + zero</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Prediktory skoků</h2>

<p>Užitečnou technologií, kterou je vybavena většina jader ARMv8 (kromě
Cortex-A53 a Cortex-A55, u nichž se více dbá na menší plochu čipu a menší
spotřebu) jsou takzvané <i>prediktory skoků</i>. Ty slouží, jak ostatně jejich
název napovídá, k&nbsp;tomu, že dopředu odhadnou, zda se podmíněný skok provede
či nikoli a na základě toho začnou do instrukční pipeline vkládat (a postupně
zpracovávat) buď instrukce, které se nachází ihned za instrukcí podmíněného
skoku či naopak v&nbsp;cíli skoku. U jednotlivých skoků nahrazujících
konstrukci typu <i>if</i> je samozřejmě predikce spíše loterií, ovšem známé
pravidlo 90/10 (nebo 80/20) nám říká, že 90 procent času běhu programu se
stráví v&nbsp;pouhých deseti procentech kódu, tj.&nbsp;musí se typicky jednat o
nějaké programové smyčky, u kterých by bylo dobré skoky predikovat. Existuje
více způsobů implementace prediktorů skoků. My si vysvětlíme prediktory
jednobitové a dvoubitové, protože právě ty nalezneme u jader ARMv8-A.</p>

<p>Jednoduchý jednobitový prediktor skoků pracuje tak, že si procesor u každého
skoku v&nbsp;jednom bitu zapamatuje, zda byl skok proveden či nikoli. Když se
v&nbsp;instrukční pipeline znovu skok objeví (souhlasí jeho adresa), tak se
procesor na základě předešlého běhu programu rozhodne, které další instrukce se
pravděpodobně budou zpracovávat. Při prvním volání skoku má prediktor pouze
padesátiprocentní úspěšnost, ta se potom zvyšuje. Například u smyčky, která by
měla proběhnout 100&times; (to ovšem procesor dopředu nemusí vědět) se sice při
prvním průchodu prediktor splete (za což je penalizován &bdquo;vysypáním&ldquo;
pipeline), ovšem v&nbsp;dalších 98 průchodech už správně odhadne, že se skok
provede. Poslední průchod je znovu odhadnut špatně, což je ovšem pochopitelné.
Výsledkem je poměrně úspěšné a především rychlé provedení všech instrukcí ve
smyčce, přičemž je úspěšnost predikce skvělých 98 procent (to je ovšem ideální
případ).</p>

<p>Dvoubitový prediktor pracuje velmi podobným způsobem, ovšem pamatuje si
nejenom předchozí výsledek skoku (proveden, neproveden), ale i minulý stav
predikce. Pro mnoho typů podmínek je výhodnější, než jednobitový prediktor,
protože i jeden špatný odhad ještě nezmění stav prediktoru.</p>

<p>Použití prediktorů na čipech AArch64:</p>

<table>
<tr><th>Jádro</th><th>Revize</th><th>Prediktor skoků</th></tr>
<tr><td>Cortex-A35</td><td>ARMv8-A</td><td>&#10003;</td></tr>
<tr><td>Cortex-A53</td><td>ARMv8-A</td><td>&times;</td></tr>
<tr><td>Cortex-A55</td><td>ARMv8.2-A</td><td>&times;</td></tr>
<tr><td>Cortex-A57</td><td>ARMv8-A</td><td>&#10003; 2bit</td></tr>
<tr><td>Cortex-A72</td><td>ARMv8-A</td><td>&#10003; 2bit</td></tr>
<tr><td>Cortex-A73</td><td>ARMv8-A</td><td>&#10003; 2bit</td></tr>
<tr><td>Cortex-A75</td><td>ARMv8.2-A</td><td>&#10003; 2bit</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Provádění instrukcí mimo pořadí (out of order)</h2>

<p>Velmi účinnou technikou vedoucí ke snížení cyklů mikroprocesoru, ve kterých
se žádná činnost neprovádí, spočívá v&nbsp;takzvaném provádění instrukcí mimo
pořadí (<i>out of order</i>). U klasických <i>in order</i> mikroprocesorů,
které mají instrukční pipeline, totiž nastává situace, ve které musí
následující instrukce čekat na provedení instrukce předchozí, většinou
z&nbsp;toho důvodu, že předchozí instrukce modifikuje nějaký pracovní registr
či příznak, který následující instrukce potřebuje ke svému zdárnému provedení.
To samozřejmě znamená nežádoucí zdržení, protože se nevyužijí všechny cykly
mikroprocesoru.  V&nbsp;případě architektury <i>out of order</i> však není nic
ztraceno, protože je možné začít provádět nějakou jinou instrukci, u níž je
zaručeno, že používá jiné pracovní registry a příznaky (popř.&nbsp;je možné
použít stínové pracovní registry). Interně se řazení instrukcí provádí na
základě jejich ukládání do instrukční fronty (nazývané také <i>rezervační
stanice</i>), ze které jsou instrukce vybírány ve chvíli, kdy jsou známy
hodnoty jejich operandů.</p>

<p>Použití out of order technologie na čipech AArch64:</p>

<table>
<tr><th>Jádro</th><th>Revize</th><th>Out of order</th></tr>
<tr><td>Cortex-A35</td><td>ARMv8-A  </td><td>&times;</td></tr>
<tr><td>Cortex-A53</td><td>ARMv8-A  </td><td>&times;</td></tr>
<tr><td>Cortex-A55</td><td>ARMv8.2-A</td><td>&times;</td></tr>
<tr><td>Cortex-A57</td><td>ARMv8-A  </td><td>&#10003;</td></tr>
<tr><td>Cortex-A72</td><td>ARMv8-A  </td><td>&#10003;</td></tr>
<tr><td>Cortex-A73</td><td>ARMv8-A  </td><td>&#10003;</td></tr>
<tr><td>Cortex-A75</td><td>ARMv8.2-A</td><td>&#10003;</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Aritmeticko-logická jednotka a matematický koprocesor</h2>

<p>Kromě toho, že aritmeticko-logická jednotka byla rozšířena pro zpracování
64bitových operandů u prakticky všech instrukcí, došlo k&nbsp;jejímu doplnění o
násobičku a děličku. Násobička může provádět i operace typu <i>MAC</i>
(<i>Multiply Accumulate</i>). K&nbsp;dispozici jsou následující kombinace
operandů:</p>

<table>
<tr><th>Operace</th><th>Vstupní operandy</th><th>Výsledek</th></tr>
<tr><td>MUL</td><td>32&times;32 bitů</td><td>32 bitů</td></tr>
<tr><td>MUL</td><td>64&times;64 bitů</td><td>64 bitů</td></tr>
<tr><td>MUL</td><td>32&times;32 bitů</td><td>64 bitů (rozšíření)</td></tr>
<tr><td>MUL</td><td>64&times;64 bitů</td><td>horních 64 bitů (rozšíření)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>MAC</td><td>32&pm;32&times;32 bitů</td><td>32 bitů</td></tr>
<tr><td>MAC</td><td>64&pm;64&times;64 bitů</td><td>64 bitů</td></tr>
<tr><td>MAC</td><td>64&pm;32&times;32 bitů</td><td>64 bitů (rozšíření)</td></tr>
</table>

<p>Pokud je vyžadováno násobení 64&times;64 bitů se 128bitovým výsledkem, je
nutné zkombinovat druhou a čtvrtou instrukci.</p>

<p>Matematický koprocesor je u architektury AArch64 volitelný, ale oproti
32bitovým ARMům došlo ke zjednodušení &ndash; už neexistuje rozdělení ABI na
soft floating point a hard floating point, protože pro předávání hodnot typu
float a double jsou vždy použity FP registry popsané <a
href="#k10">v&nbsp;další kapitole</a>. Z&nbsp;technologického hlediska sice
není soft floating point špatné řešení, ale prakticky způsobovalo (a způsobuje)
množství problémů při distribuci knihoven i aplikací.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Sada pracovních registrů</h2>

<p>Původních patnáct pracovních registrů pojmenovaných <strong>R0</strong> až
<strong>R14</strong>, které známe z&nbsp;32bitových procesorů ARM, bylo
rozšířeno na 31 registrů, z&nbsp;nichž každý má šířku 64 bitů. Z&nbsp;tohoto
důvodu muselo dojít k&nbsp;úpravě pojmenování registrů způsobem, který je
naznačený v&nbsp;následující tabulce:</p>

<table>
<tr><th>Jméno</th><th>Význam</th></tr>
<tr><td>r0..r30</td><td>použito například v&nbsp;dokumentaci, popisu ABI atd.</td></tr>
<tr><td>x0..x30</td><td>celý 64bitový registr použitý jako zdroj či cíl</td></tr>
<tr><td>w0..w30</td><td>spodních 32 bitů registru (horních 32 bitů výsledku je buď vynulováno nebo znaménkově rozšířeno)</td></tr>
</table>

<p>Všechny tyto registry mají v&nbsp;instrukční sadě stejné postavení, na
rozdíl od instrukční sady Thumb, v&nbsp;níž se pro některé instrukce může
použít jen spodních osm registrů (ostatně v&nbsp;&bdquo;pravých&ldquo;
RISCových procesorech je zvykem používat všechny registry shodným
způsobem).</p>

<p>Další sada registrů je používána při operacích s&nbsp;typy
<i>single/float</i> a <i>double</i> (tedy s&nbsp;operandy reprezentovanými
v&nbsp;systému plovoucí řádové čárky), u SIMD operací a taktéž kryptografickým
modulem:</p>

<table>
<tr><th>Jméno</th><th>Význam</th></tr>
<tr><td>v0..v31</td><td>128bitové registry</td></tr>
<tr><td>d0..d31</td><td>spodních 64 bitů registrů v0..v31, použito pro hodnoty typu <i>double</i></td></tr>
<tr><td>s0..s31</td><td>spodních 32 bitů registrů v0..v31, použito pro hodnoty typu <i>single/float</i></td></tr>
</table>

<p>Pro SIMD operace, tj.&nbsp;operace pracující s&nbsp;vektory, se registry
<strong>vn</strong> rozdělují takto:</p>

<table>
<tr><th>Tvar (shape)</th><th>Celkem</th><th>Pojmenování v&nbsp;assembleru</th></tr>
<tr><td>8b&times;8</td><td>64b</td><td>Vn.8B</td></tr>
<tr><td>8b&times;16</td><td>128b</td><td>Vn.16B</td></tr>
<tr><td>16b&times;4</td><td>64b</td><td>Vn.4H</td></tr>
<tr><td>16b&times;8</td><td>128b</td><td>Vn.8H</td></tr>
<tr><td>32b&times;2</td><td>64b</td><td>Vn.2S</td></tr>
<tr><td>32b&times;4</td><td>128b</td><td>Vn.4S</td></tr>
<tr><td>64b&times;1</td><td>64b</td><td>Vn.1D</td></tr>
<tr><td>64b&times;2</td><td>128b</td><td>Vn.2D</td></tr>
</table>

<p>Povšimněte si, že &ndash; na rozdíl od mnoha jiných architektur &ndash;
nedochází k&nbsp;tomu, že by se například dva single registry mapovaly do
jednoho double registru atd.</p>

<p>Mezi speciální registry patří především:</p>

<table>
<tr><th>Jméno</th><th>Význam zkratky</th></tr>
<tr><td>SCTLR_ELn</td><td>System Control Register</td></tr>
<tr><td>ACTLR_ELn</td><td>Auxiliary Control Register</td></tr>
<tr><td>SCR_EL3</td><td>Secure Configuration Register</td></tr>
<tr><td>HCR_EL2</td><td>Hypervisor Configuration Register</td></tr>
<tr><td>MIDR_EL1</td><td>Main ID Register</td></tr>
<tr><td>MPIDR_EL1</td><td>Multiprocessor Affinity Register</td></tr>
</table>
 
<p>Význam těchto registrů bude popsán později.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Speciální význam třicátého druhého registru</h2>

<p>V&nbsp;pořadí třicátý druhý registr, tj.&nbsp;registr se jménem
<strong>x31</strong> či <strong>w31</strong>, není ve skutečnosti běžným
pracovním registrem, protože má dva speciální významy. V&nbsp;případě použití
tohoto registru v&nbsp;aritmetických či logických instrukcích se při použití ve
funkci vstupního operandu tento registr chová jako konstantní nula a při
použití ve funkci operandu výstupního jako /dev/null (výsledek se zahodí a
neovlivní skutečnou hodnotu uloženou do registru). Proto se v&nbsp;assembleru
může pro pojmenování tohoto registru použít jméno <strong>xzr</strong> či
<strong>wzr</strong> (<i>extended zero register</i>, <i>working zero
register</i>). U instrukcí pracujících se zásobníkem se tento registr chová
jako ukazatel na vrchol zásobníku a proto se pro něj v&nbsp;assembleru používá
jméno <strong>rsp</strong> či jen <strong>SP</strong> (na velikosti písmen u
jmen registrů samozřejmě nezáleží).</p>

<p>Poznámky:</p>

<ol>
<li>Registr <strong>x30</strong> se používá ve funkci <strong>LR</strong> (<i>Link Register</i>).</li>
<li>Registr <strong>PC</strong> není přímo dostupný. Toto je jeden z&nbsp;největších viditelných rozdílů mezi ARM 32 a AArch64.</li>
</ol>



<p><a name="k12"></a></p>
<h2 id="k12">12. Operace s&nbsp;32bitovými a 64bitovými operandy</h2>

<p>U většiny aritmetických instrukcí je možné zvolit, zda se mají operace
provádět s&nbsp;32bitovými či naopak se 64bitovými operandy. U 64bitových
operandů je vlastní provedení instrukce jednoduché, ovšem u 32bitových operandů
je nutné zajistit, aby měl výsledek operace smysl i ve chvíli, kdy se převede
na 64 bitů. Z&nbsp;tohoto důvodu je při použití 32bitového <i>zdrojového</i>
operandu horních 32 bitů původně 64bitového registru ignorováno a při použití
32bitového <i>cílového</i> operandu se horních 32 bitů buď vynuluje (většina
instrukcí) či znaménkově rozšíří. U 32bitových operací se navíc základní
příznaky (zero, carry, negative...) nastavují pouze na základě 32bitového
výsledku (což je ostatně logické). Některé výjimky, které se týkají například
bitových posunů a rotací, si popíšeme u konkrétních instrukcí, kterých se to
týká.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Rozšířené možnosti adresování</h2>

<p>Díky použití pracovních registrů se šířkou 64 bitů se samozřejmě dosti
podstatným způsobem rozšířil adresní prostor, který by jinak byl omezen na
&bdquo;pouhých&ldquo; 32 bitů. Teoretický adresový rozsah 64 bitů je u
architektury AArch64 ve skutečnosti snížen na 49 bitů virtuální adresy, což je
však podle všeho dostačující, a to i pro relativně vzdálenou budoucnost. Navíc
se horních osm bitů adresy ignoruje, což znamená, že do této oblasti registru
použitého pro adresování je možné uložit takzvaný &bdquo;tag&ldquo;. Tato
technika se v&nbsp;některých programovacích jazycích používá například pro
rozlišení datového typu či pro rozlišení, zda jde o primitivní typ nebo
ukazatel (příkladem mohou být jazyky odvozené od LISPu).</p>

<p>Některá další omezení jsou způsobena tím, že všechny instrukce mají
konstantní šířku 32 bitů a tudíž v&nbsp;nich není prostor pro uvedení 64bitové
konstanty či adresy:</p>

<ul>
<li>Pro podmíněné skoky může cíl skoku ležet v&nbsp;rozsahu &pm;1 MB (což prakticky ve všech případech postačuje)</li>
<li>Pro relativní skoky může cíl opět ležet v&nbsp;rozsahu &pm;1 MB</li>
<li>U nepodmíněných skoků je rozsah větší, celých &pm;128 MB (což by opět mělo dostačovat pro prakticky všechny účely)</li>
<li>Generování adresy (ukládané do registru) lze implementovat dvojicí instrukcí pro rozsah 4GB</li>
</ul>

<p>U většiny programového kódu, který ve své zdrojové podobě obsahuje relativně
krátké funkce či metody, by se tato omezení neměla vůbec projevit. Ostatně vždy
lze omezení obejít použitím podmíněného skoku s&nbsp;opačnou podmínkou
následovaného nepodmíněným skokem, což je činnost prováděná překladači.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Zjednodušení instrukční sady v&nbsp;porovnání s&nbsp;32bitovými ARMy</h2>

<p>Instrukční sada AArch64 se oproti původní 32bitové RISCové sadě (a ještě
více od sady Thumb a Thumb-2) v&nbsp;několika ohledech liší, především pak
v&nbsp;následujících oblastech:</p>

<ol>
<li>Byly odstraněny instrukce <strong>LDM</strong>, <strong>STM</strong>,
<strong>PUSH</strong> a <strong>POP</strong> ve variantě s&nbsp;bitovým polem
registrů</li>
<li>Naproti tomu lze použít instrukce <strong>LDP</strong> a
<strong>STP</strong> pracující s&nbsp;libovolnými dvěma registry (zajímavá
myšlenka na využití 32bitového slova)</li>
<li>Byly odstraněny prefixy pro podmínku, nyní jsou podmínky použity jen u
skoků a několika dalších vybraných instrukcí</li>
<li>Byl odstraněn prefix <strong>IT</strong> známý z&nbsp;Thumb-2</li>
</ol>

<p>Tyto změny jsou založeny na výsledcích benchmarků, protože současné
prediktory skoků jsou již velmi kvalitní. Navíc odstranění podmínkových bitů
umožnilo použití více bitů v&nbsp;instrukčním slově pro jiné účely.</p>

<p>Poznámka: u instrukcí <strong>LDM</strong> a <strong>STM</strong> je
v&nbsp;operačním kódu instrukce použito jedno bitové pole o šířce 16 bitů,
které je určeno pro označení těch pracovních registrů, které se mají načíst
z&nbsp;operační paměti, popř.&nbsp;které se naopak mají do operační paměti
uložit. Tyto instrukce navíc dovolují manipulovat s&nbsp;tím registrem, který
je použit jako ukazatel do paměti, kam se registry ukládají či odkud se naopak
čtou jejich nové hodnoty. Obsah tohoto adresového registru je možné zvýšit či
naopak snížit, a to buď před provedením operace LOAD/STORE nebo až posléze.
Z&nbsp;tohoto důvodu se instrukce <strong>LDM</strong> a <strong>STM</strong>
na 32bitových architekturách ARM používají při implementaci zásobníkových rámců
i když se striktně řečeno vlastně nejedná o čistě RISCové instrukce.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Instrukční sada AArch64</h2>

<table>
<tr><th>Skupina</th><th>Další dělení</th></tr>
<tr><td>Load-Store</td><td>Load-Store pro jeden registr</td></tr>
<tr><td>&nbsp;</td><td>Load-Store pro dvojici registrů</td></tr>
<tr><td>&nbsp;</td><td>Prefetch</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Skoky</td><td>Nepodmíněné skoky</td></tr>
<tr><td>&nbsp;</td><td>Nepodmíněný skok na adresu v&nbsp;registru</td></tr>
<tr><td>&nbsp;</td><td>Podmíněné skoky</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ALU operace</td><td>Základní aritmetické instrukce</td></tr>
<tr><td>&nbsp;</td><td>Násobení a dělení</td></tr>
<tr><td>&nbsp;</td><td>Logické instrukce</td></tr>
<tr><td>&nbsp;</td><td>Rozšíření operandu</td></tr>
<tr><td>&nbsp;</td><td>Bitové operace</td></tr>
<tr><td>&nbsp;</td><td>Extrakce dat</td></tr>
<tr><td>&nbsp;</td><td>Bitové posuny</td></tr>
<tr><td>&nbsp;</td><td>Aritmetické posuny</td></tr>
<tr><td>&nbsp;</td><td>Podmíněné zpracování dat</td></tr>
<tr><td>&nbsp;</td><td>Podmíněné porovnání</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>FP operace</td><td></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>SIMD operace</td><td></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Systémové instrukce</td><td></td></tr>
</table>

FP operace
SIMD operace
Systémové instrukce



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Comparison of ARMv8-A cores<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores">https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores</a>
</li>

<li>Cortex-A32 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php</a>
</li>

<li>Cortex-A35 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>Apple A7 (SoC založen na CPU Cyclone)<br />
<a href="https://en.wikipedia.org/wiki/Apple_A7">https://en.wikipedia.org/wiki/Apple_A7</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>DSP for Cortex-M<br />
<a href="https://developer.arm.com/technologies/dsp/dsp-for-cortex-m">https://developer.arm.com/technologies/dsp/dsp-for-cortex-m</a>
</li>

<li>Cortex-M processors in DSP applications? Why not?!<br />
<a href="https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not">https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not</a>
</li>

<li>White Paper - DSP capabilities of Cortex-M4 and Cortex-M7<br />
<a href="https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7">https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7</a>
</li>

<li>Q (number format)<br />
<a href="https://en.wikipedia.org/wiki/Q_%28number_format%29">https://en.wikipedia.org/wiki/Q_%28number_format%29</a>
</li>

<li>TriCore Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837">http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837</a>
</li>

<li>TriCoreTM V1.6 Instruction Set: 32-bit Unified Processor Core<br />
<a href="http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352">http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352</a>
</li>

<li>TriCore v2.2 C Compiler, Assembler, Linker Reference Manual<br />
<a href="http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf">http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf</a>
</li>

<li>Infineon TriCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Infineon_TriCore">https://en.wikipedia.org/wiki/Infineon_TriCore</a>
</li>

<li>C166®S V2 Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae">http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální stránky projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky o projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

