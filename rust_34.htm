<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Rust: knihovna ndarray pro práci s n-rozměrnými poli (2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Rust: knihovna ndarray pro práci s n-rozměrnými poli (2)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Programovací jazyk Rust: knihovna ndarray pro práci s n-rozměrnými poli (2)</a></p>
<p><a href="#k02">*** 2. Pohledy na pole</a></p>
<p><a href="#k03">*** 3. Měnitelný pohled na pole</a></p>
<p><a href="#k04">4. Řezy jednorozměrných polí</a></p>
<p><a href="#k05">5. Použití záporných indexů</a></p>
<p><a href="#k06">6. Specifikace kroku při tvorbě řezu polem</a></p>
<p><a href="#k07">7. Záporný krok</a></p>
<p><a href="#k08">8. Řezy dvourozměrných polí</a></p>
<p><a href="#k09">9. Explicitní krok v&nbsp;řezech dvourozměrných polí</a></p>
<p><a href="#k10">10. Operátory aplikované na prvky polí</a></p>
<p><a href="#k11">11. Zpracování prvků zdrojového pole</a></p>
<p><a href="#k12">*** 12. Změna pole vystupujícího v&nbsp;roli zdrojového i cílového operandu</a></p>
<p><a href="#k13">*** 13. Broadcasting</a></p>
<p><a href="#k14">*** 14. Explicitní volání metody <strong>broadcast</strong></a></p>
<p><a href="#k15">15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Rust: knihovna ndarray pro práci s n-rozměrnými poli (2)</h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. Pohledy na pole</h2>

<pre>
let array = Array::from_iter(0..12);
let view = array.view();
&nbsp;
println!("length:     {}", array.len());
println!("dimensions: {}", array.ndim());
println!("dimension:  {:?}", array.dim());
println!("shape:      {:?}", array.shape());
println!("strides:    {:?}\n", array.strides());
&nbsp;
println!("length:     {}", view.len());
println!("dimensions: {}", view.ndim());
println!("dimension:  {:?}", view.dim());
println!("shape:      {:?}", view.shape());
println!("strides:    {:?}\n", view.strides());
</pre>

<pre>
length:     12
dimensions: 1
dimension:  12
shape:      [12]
strides:    [1]
&nbsp;
length:     12
dimensions: 1
dimension:  12
shape:      [12]
strides:    [1]
</pre>

<pre>
let array = Array::from_iter(0..16).into_shape((2,2,2,2)).unwrap();
let view = array.view();
&nbsp;
println!("length:     {}", array.len());
println!("dimensions: {}", array.ndim());
println!("dimension:  {:?}", array.dim());
println!("shape:      {:?}", array.shape());
println!("strides:    {:?}\n", array.strides());
&nbsp;
println!("length:     {}", view.len());
println!("dimensions: {}", view.ndim());
println!("dimension:  {:?}", view.dim());
println!("shape:      {:?}", view.shape());
println!("strides:    {:?}\n", view.strides());
</pre>

<pre>
length:     16
dimensions: 4
dimension:  (2, 2, 2, 2)
shape:      [2, 2, 2, 2]
strides:    [8, 4, 2, 1]
&nbsp;
length:     16
dimensions: 4
dimension:  (2, 2, 2, 2)
shape:      [2, 2, 2, 2]
strides:    [8, 4, 2, 1]
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Měnitelný pohled na pole</h2>

<pre>
let mut array = Array2::<i32>::zeros((3,3));
&nbsp;
println!("original array:\n{}\n", array);
&nbsp;
{
    let mut view = array.view_mut();
    view[[1,1]] = 42;
}
&nbsp;
println!("array modified via view:\n{}\n", array);
&nbsp;
array[[1,1]] = 1000;
&nbsp;
println!("array modified directly:\n{}\n", array);
</pre>

<pre>
original array:
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]
&nbsp;
array modified via view:
[[0, 0, 0],
 [0, 42, 0],
 [0, 0, 0]]
&nbsp;
array modified directly:
[[0, 0, 0],
 [0, 1000, 0],
 [0, 0, 0]]
</pre>

<pre>
let mut array = Array2::<i32>::zeros((3,3));
&nbsp;
println!("original array:\n{}\n", array);
&nbsp;
{
    let mut view = array.view_mut();
    view[[1,1]] = 42;
    array[[1,1]] = 1000;
}
&nbsp;
println!("array modified via view:\n{}\n", array);
</pre>

<pre>
error[E0499]: cannot borrow `array` as mutable more than once at a time
  --&gt; main.rs:62:10
   |
59 |         let mut view = array.view_mut();
   |                        ----- first mutable borrow occurs here
...
62 |          array[[1,1]] = 1000;
   |          ^^^^^ second mutable borrow occurs here
63 |     }
   |     - first borrow ends here
&nbsp;
error: aborting due to previous error
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Řezy jednorozměrných polí</h2>

<p>V&nbsp;mnoha případech je nutné z&nbsp;polí, ať již se jedná o jednorozměrné
vektory, dvourozměrné matice či vícerozměrná pole, získat hodnoty většího
množství prvků tvořících souvislý blok. Může se například jednat o všechny
prvky jednorozměrného pole kromě prvku prvního a posledního (typické pro
některé filtry), prvky z&nbsp;první poloviny pole atd. I v&nbsp;tomto případě
knihovna <i>ndarray</i> nabízí vývojářům velmi elegantní řešení, a to ve formě
takzvaných řezů (<i>slices</i>). Pro tvorbu řezů je určena funkce
<strong>slice()</strong> s&nbsp;makrem <strong>s</strong> zapisovaným
samozřejmě s&nbsp;vykřičníkem na konci. Při použití tohoto makra pro vektory se
namísto jediného indexu zadávají dva indexy oddělené dvěma tečkami, které potom
reprezentují začátek a konec řezu. Jak horní, tak i dolní index je možné
vynechat; v&nbsp;tomto případě se nahradí indexem prvního resp.&nbsp;posledního
prvku zvýšeného o jedničku (to odpovídá chování <a
href="https://doc.rust-lang.org/std/ops/struct.Range.html">Range</a>). Opět se
podívejme na demonstrační příklady, prozatím pro jednorozměrná pole:</p>

<pre>
let array = Array::from_iter(0..12);
println!("original array:\n{}\n", array);
&nbsp;
let slice = array.slice(s![3..8]);
println!("slice 3..8:\n{}\n", slice);
&nbsp;
let slice2 = array.slice(s![..8]);
println!("slice ..8:\n{}\n", slice2);
&nbsp;
let slice3 = array.slice(s![3..]);
println!("slice 3..:\n{}\n", slice3);
&nbsp;
let slice4 = array.slice(s![..]);
println!("slice ..:\n{}\n", slice4);
&nbsp;
let slice5 = array.slice(s![3..4]);
println!("slice 3..4:\n{}\n", slice5);
&nbsp;
let slice6 = array.slice(s![4..4]);
println!("slice 4..4:\n{}\n", slice6);
</pre>

<p>Povšimněte si, že se zadává polootevřený interval, opět stejně jako
v&nbsp;případě Range:</p>

<pre>
original array:
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
&nbsp;
slice 3..8:
[3, 4, 5, 6, 7]
&nbsp;
slice ..8:
[0, 1, 2, 3, 4, 5, 6, 7]
&nbsp;
slice 3..:
[3, 4, 5, 6, 7, 8, 9, 10, 11]
&nbsp;
slice ..:
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
&nbsp;
slice 3..4:
[3]
&nbsp;
slice 4..4:
[]
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Použití záporných indexů</h2>

<p>Použít je možné i záporné indexy popř.&nbsp;první či druhý index zcela
vynechat:</p>

<pre>
let array = Array::from_iter(0..12);
println!("original array:\n{}\n", array);
&nbsp;
let slice = array.slice(s![-10..-1]);
println!("slice -10..-1:\n{}\n", slice);
&nbsp;
let slice2 = array.slice(s![..-1]);
println!("slice2 ..-1:\n{}\n", slice2);
&nbsp;
let slice3 = array.slice(s![..-8]);
println!("slice ..-8:\n{}\n", slice3);
&nbsp;
let slice4 = array.slice(s![-3..]);
println!("slice -3..:\n{}\n", slice4);
&nbsp;
let slice5 = array.slice(s![-1..]);
println!("slice -1..:\n{}\n", slice5);
</pre>

<p>Z&nbsp;výsledků vypsaných po překladu a spuštění je patrné, že
v&nbsp;případě záporných indexů se prvky vybírají od konce pole, přičemž index
-1 ve skutečnosti odpovídá indexu posledního prvku pole. Kvůli tomu, že se u
řezů používá polootevřený interval, bude zápis:</p>

<pre>
s![..-1]
</pre>

<p>odpovídat původnímu vektoru, ovšem bez posledního prvku:</p>

<pre>
original array:
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
&nbsp;
slice -10..-1:
[2, 3, 4, 5, 6, 7, 8, 9, 10]
&nbsp;
slice2 ..-1:
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
&nbsp;
slice ..-8:
[0, 1, 2, 3]
&nbsp;
slice -3..:
[9, 10, 11]
&nbsp;
slice -1..:
[11]
</pre>

<p>Poznámka: díky této vlastnosti se prakticky nikdy nesetkáme s&nbsp;nutností
zjišťovat skutečnou velikost dimenzí pole, tj.&nbsp;v&nbsp;případě vektoru
s&nbsp;nutností spočtení počtu prvků.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Specifikace kroku při tvorbě řezu polem</h2>

<p>Při provádění operace řezu polem jsme doposud používali zápis:</p>

<pre>
pole.slice(s![od..do])
</pre>

<p>popř.&nbsp;se jeden z&nbsp;indexů <strong>od</strong> či <strong>do</strong>
mohl vynechat. Ovšem knihovna <i>ndarray</i> podporuje mj.&nbsp;i mírně
rozšířený zápis:</p>

<pre>
pole.slice(s![od..do;krok])
</pre>

<p>přičemž poslední použitá hodnota udává vzdálenost (<i>stride</i>) mezi
sousedními prvky řezu. Podívejme se na několik jednoduchých příkladů:</p>

<pre>
let array = Array::from_iter(0..12);
println!("original array:\n{}\n", array);
&nbsp;
let slice = array.slice(s![3..8;2]);
println!("slice 3..8;2:\n{}\n", slice);
&nbsp;
let slice2 = array.slice(s![..8;2]);
println!("slice ..8;2:\n{}\n", slice2);
&nbsp;
let slice3 = array.slice(s![3..;2]);
println!("slice 3..;2:\n{}\n", slice3);
&nbsp;
let slice4 = array.slice(s![..;2]);
println!("slice ..;2:\n{}\n", slice4);
</pre>

<p>Ve všech případech byl krok nastavený na hodnotu 2, takže se
z&nbsp;původního pole vybral vždy každý druhý prvek (zda se jednalo o prvek
sudý nebo lichý závisí na hodnotě prvního vybíraného indexu):</p>

<pre>
original array:
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
&nbsp;
slice 3..8;2:
[3, 5, 7]
&nbsp;
slice ..8;2:
[0, 2, 4, 6]
&nbsp;
slice 3..;2:
[3, 5, 7, 9, 11]
&nbsp;
slice ..;2:
[0, 2, 4, 6, 8, 10]
</pre>

<p>Zejména poslední &bdquo;trik&ldquo; se zápisem <strong>s![..;krok]</strong>
může nahradit některé typy programových smyček &ndash; představme si například
výběr jedné barvové složky z&nbsp;vektoru/matice pixelů používajících barvový
model RGB atd.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Záporný krok</h2>

<p>I hodnota kroku, resp.&nbsp;přesněji řečeno <i>stride</i>, může být
v&nbsp;případě potřeby záporná.  V&nbsp;takovém případě se bude polem procházet
v&nbsp;opačném směru:</p>

<pre>
let array = Array::from_iter(0..12);
println!("original array:\n{}\n", array);
&nbsp;
let slice = array.slice(s![3..8;-2]);
println!("slice 3..8;-2:\n{}\n", slice);
&nbsp;
let slice2 = array.slice(s![..8;-2]);
println!("slice ..8;-2:\n{}\n", slice2);
&nbsp;
let slice3 = array.slice(s![3..;-2]);
println!("slice 3..;-2:\n{}\n", slice3);
&nbsp;
let slice4 = array.slice(s![..;-2]);
println!("slice ..;-2:\n{}\n", slice4);
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
original array:
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
&nbsp;
slice 3..8;-2:
[7, 5, 3]
&nbsp;
slice ..8;-2:
[7, 5, 3, 1]
&nbsp;
slice 3..;-2:
[11, 9, 7, 5, 3]
&nbsp;
slice ..;-2:
[11, 9, 7, 5, 3, 1]
</pre>

<p>Tohoto chování je možné využít například pro zrcadlení všech prvků ve
vektoru:</p>

<pre>
let slice5 = array.slice(s![..;-1]);
println!("slice ..;-1:\n{}\n", slice5);
&nbsp;
slice ..;-1:
[11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
</pre>

<p>Poznámka: krok (resp.&nbsp;<i>stride</i>) může být kladný či záporný, nikoli
však nulový. Tato kontrola je provedena až v&nbsp;době běhu programu:</p>

<pre>
thread 'main' panicked at 'Slice stride must not be none(for SliceArg [..;0])',
/home/tester/.cargo/registry/src/github.com-1ecc6299db9ec823/ndarray-0.9.1/src/dimension/dimension_trait.rs:280:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Řezy dvourozměrných polí</h2>

<p>Řezy je možné vytvářet i z&nbsp;dvourozměrných popř.&nbsp;vícerozměrných
polí (zde však již může být obtížné si představit, jak bude výsledek vypadat).
Makro <strong>s</strong> totiž umožňuje specifikovat takový počet klauzulí
s&nbsp;předpisem řezu, jaký odpovídá dimenzi původního pole. Samozřejmě se opět
podíváme na několik příkladů, které budou pro ilustraci používat dvourozměrná
pole, tedy matice. Původní matice bude mít čtyři řádky a pět sloupců, prvky
budou v&nbsp;rozsahu 10 až 29 (to jen kvůli pěknému zarovnání sloupců):</p>

<pre>
let array = Array::from_iter(10..30).into_shape((4,5)).unwrap();
println!("original array:\n{}\n", array);
&nbsp;
let slice = array.slice(s![.., 1..3]);
println!("slice: .., 1..3\n{}\n", slice);
&nbsp;
let slice2 = array.slice(s![1..2, 3..4]);
println!("slice: 1..2, 3..4\n{}\n", slice2);
&nbsp;
let slice3 = array.slice(s![1.., 1..]);
println!("slice: 1.., 1..\n{}\n", slice3);
&nbsp;
let slice4 = array.slice(s![.., ..]);
println!("slice: .., ..\n{}\n", slice4);
&nbsp;
let slice5 = array.slice(s![..-1, ..-1]);
println!("slice: ..-1, ..-1\n{}\n", slice5);
</pre>

<p>Původní matice a její řezy vypadají takto:</p>

<pre>
original array:
[[10, 11, 12, 13, 14],
 [15, 16, 17, 18, 19],
 [20, 21, 22, 23, 24],
 [25, 26, 27, 28, 29]]
&nbsp;
<strong>všechny řádky, ovšem jen dva vybrané sloupce:</strong>
slice: .., 1..3
[[11, 12],
 [16, 17],
 [21, 22],
 [26, 27]]
&nbsp;
<strong>nezapomeňte na polootevřený interval:</strong>
slice: 1..2, 3..4
[[18]]
&nbsp;
<strong>podmatice bez prvního řádku a prvního sloupce:</strong>
slice: 1.., 1..
[[16, 17, 18, 19],
 [21, 22, 23, 24],
 [26, 27, 28, 29]]
&nbsp;
<strong>kopie původní matice:</strong>
slice: .., ..
[[10, 11, 12, 13, 14],
 [15, 16, 17, 18, 19],
 [20, 21, 22, 23, 24],
 [25, 26, 27, 28, 29]]
&nbsp;
<strong>podmatice bez posledního řádku a posledního sloupce:</strong>
slice: ..-1, ..-1
[[10, 11, 12, 13],
 [15, 16, 17, 18],
 [20, 21, 22, 23]]
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Explicitní krok v&nbsp;řezech dvourozměrných polí</h2>

<p>Samozřejmě je možné i u řezů dvourozměrných polí (matic) zvolit krok, který
může být odlišný při výběru řádků i výběru sloupců. Povšimněte si, že se krok
zapisuje vždy ihned za klauzuli se specifikací řezu v&nbsp;dané dimenzi:</p>

<pre>
let array = Array::from_iter(10..30).into_shape((4,5)).unwrap();
println!("original array:\n{}\n", array);
&nbsp;
let slice = array.slice(s![..;2, 1..3]);
println!("slice: ..;2, 1..3\n{}\n", slice);
&nbsp;
let slice2 = array.slice(s![1..2;-1, 3..4;-1]);
println!("slice: 1..2;-1, 3..4;-1\n{}\n", slice2);
&nbsp;
let slice3 = array.slice(s![1..;2, 1..;2]);
println!("slice: 1..;2, 1..;2\n{}\n", slice3);
&nbsp;
let slice4 = array.slice(s![.., ..;-1]);
println!("slice: .., ..;-1\n{}\n", slice4);
&nbsp;
let slice5 = array.slice(s![..;-1, ..;-1]);
println!("slice: ..;-1, ..;-1\n{}\n", slice5);
&nbsp;
let slice6 = array.slice(s![..;-1, ..]);
println!("slice: ..;-1, ..\n{}\n", slice6);
</pre>

<p>Výsledky budou následující:</p>

<pre>
original array:
[[10, 11, 12, 13, 14],
 [15, 16, 17, 18, 19],
 [20, 21, 22, 23, 24],
 [25, 26, 27, 28, 29]]
&nbsp;
<strong>jen sudé řádky a současně druhý a třetí sloupec:</strong>
slice: ..;2, 1..3
[[11, 12],
 [21, 22]]
&nbsp;
slice: 1..2;-1, 3..4;-1
[[18]]
&nbsp;
<strong>liché řádky a sloupce:</strong>
slice: 1..;2, 1..;2
[[16, 18],
 [26, 28]]
&nbsp;
<strong>zrcadlení sloupců:</strong>
slice: .., ..;-1
[[14, 13, 12, 11, 10],
 [19, 18, 17, 16, 15],
 [24, 23, 22, 21, 20],
 [29, 28, 27, 26, 25]]
&nbsp;
<strong>zrcadlení sloupců i řádků:</strong>
slice: ..;-1, ..;-1
[[29, 28, 27, 26, 25],
 [24, 23, 22, 21, 20],
 [19, 18, 17, 16, 15],
 [14, 13, 12, 11, 10]]
&nbsp;
<strong>zrcadlení řádků:</strong>
slice: ..;-1, ..
[[25, 26, 27, 28, 29],
 [20, 21, 22, 23, 24],
 [15, 16, 17, 18, 19],
 [10, 11, 12, 13, 14]]
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Operátory aplikované na prvky polí</h2>

<p>Na prvky polí, například na dvojici vektorů nebo dvojici matic, je možné
aplikovat vybraný operátor. V&nbsp;nejjednodušším případě se používají základní
přetížené operátory aplikované na reference na pole:</p>

<pre>
let array1 = Array::range(0.0, 10.0, 1.0);
let array2 = Array::range(0.0, 5.0, 0.5);
&nbsp;
println!("array1: {}", array1);
println!("array2: {}", array2);
&nbsp;
println!("add:    {}", &amp;array1 + &amp;array2);
println!("sub:    {}", &amp;array1 - &amp;array2);
println!("mul:    {}", &amp;array1 * &amp;array2);
println!("div:    {}", &amp;array1 / &amp;array2);
</pre>

<p>Původní vektory a výsledky všech čtyř operací:</p>

<pre>
array1: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
array2: [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5]
&nbsp;
add:    [0, 1.5, 3, 4.5, 6, 7.5, 9, 10.5, 12, 13.5]
sub:    [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5]
mul:    [0, 0.5, 2, 4.5, 8, 12.5, 18, 24.5, 32, 40.5]
div:    [NaN, 2, 2, 2, 2, 2, 2, 2, 2, 2]
</pre>

<p>Výsledkem je v&nbsp;těchto případech vždy nové pole, zatímco hodnoty ani
vlastnictví původních polí se nezmění. Vytvoření nového pole však nemusí být ve
všech případech žádoucí; ostatně stačí si představit například aplikace
několika filtrů na velký rastrový obrázek.</p>

<p>Poznámka: kupodivu nejsou (alespoň prozatím) implementovány relační
operátory.</p>

<p>Operace nad maticemi:</p>

<pre>
let array1 = Array::from_iter(10..30).into_shape((4,5)).unwrap();
let array2 = Array::from_iter(100..120).into_shape((4,5)).unwrap();
&nbsp;
println!("array1:\n{}\n", array1);
println!("array2:\n{}\n", array2);
&nbsp;
println!("add:\n{}\n", array1 * array2);
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
array1:
[[10, 11, 12, 13, 14],
 [15, 16, 17, 18, 19],
 [20, 21, 22, 23, 24],
 [25, 26, 27, 28, 29]]
&nbsp;
array2:
[[100, 101, 102, 103, 104],
 [105, 106, 107, 108, 109],
 [110, 111, 112, 113, 114],
 [115, 116, 117, 118, 119]]
&nbsp;
add:
[[1000, 1111, 1224, 1339, 1456],
 [1575, 1696, 1819, 1944, 2071],
 [2200, 2331, 2464, 2599, 2736],
 [2875, 3016, 3159, 3304, 3451]]
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Zpracování prvků zdrojového pole</h2>

<p>V&nbsp;případě, že nějaký operátor (například operátor +) aplikujeme na
dvojici polí (nikoli na reference), bude celá operace probíhat odlišně.
Například zápis <strong>array1 + array2</strong> ve skutečnosti znamená, že se
pole <strong>array1</strong> modifikuje (uloží se do něj výsledné prvky) a
současně je toto pole výsledkem (návratovou hodnotou) celé operace.
V&nbsp;praxi to znamená, že se ušetří paměť a současně původní
proměnná/parametr <strong>array1</strong> vstupující do operace <strong>array1
+ array2</strong> ztratí vlastnictví původního pole. To například znamená, že
následující program bude možné přeložit, ale po součtu už nebude možné použít
proměnnou <strong>array1</strong> a ani <strong>array2</strong>:</p>

<pre>
let array1 = Array::range(0.0, 10.0, 1.0);
let array2 = Array::range(0.0, 5.0, 0.5);
&nbsp;
println!("array1: {}", array1);
println!("array2: {}", array2);
&nbsp;
let result = array1 + array2;
&nbsp;
println!("result: {}", result);
</pre>

<p>Výsledek běhu tohoto úryvku kódu:</p>

<pre>
array1: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
array2: [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5]
result: [0, 1.5, 3, 4.5, 6, 7.5, 9, 10.5, 12, 13.5]
</pre>

<p>Nyní se pokusme po součtu přistoupit k&nbsp;původním proměnným
<strong>array1</strong> a <strong>array2</strong>:</p>

<pre>
let array1 = Array::range(0.0, 10.0, 1.0);
let array2 = Array::range(0.0, 5.0, 0.5);
&nbsp;
println!("array1: {}", array1);
println!("array2: {}", array2);
&nbsp;
let result = array1 + array2;
&nbsp;
println!("array1: {}", array1);
println!("array2: {}", array2);
println!("result: {}", result);
</pre>

<p>Překladač nám v&nbsp;tomto případě &bdquo;vynadá&ldquo;, protože již
vlastnictví objektů nepatří k&nbsp;původním proměnným:</p>

<pre>
error[E0382]: use of moved value: `array1`
  --&gt; main.rs:34:28
   |
32 |     let result = array1 + array2;
   |                  ------ value moved here
33 | 
34 |     println!("array1: {}", array1);
   |                            ^^^^^^ value used here after move
   |
   = note: move occurs because `array1` has type `ndarray::ArrayBase&lt;ndarray::OwnedRepr&lt;f64&gt;, ndarray::Dim&lt;[usize; 1]&gt;&gt;`, which does not implement the `Copy` trait
&nbsp;
error[E0382]: use of moved value: `array2`
  --&gt; main.rs:35:28
   |
32 |     let result = array1 + array2;
   |                           ------ value moved here
...
35 |     println!("array2: {}", array2);
   |                            ^^^^^^ value used here after move
   |
   = note: move occurs because `array2` has type `ndarray::ArrayBase&lt;ndarray::OwnedRepr&lt;f64&gt;, ndarray::Dim&lt;[usize; 1]&gt;&gt;`, which does not implement the `Copy` trait
&nbsp;
error: aborting due to 2 previous errors
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Změna pole vystupujícího v&nbsp;roli zdrojového i cílového operandu</h2>

<pre>
let array1 = Array::range(0.0, 10.0, 1.0);
let mut array2 = Array::range(0.0, 5.0, 0.5);
&nbsp;
println!("array1: {}", array1);
println!("array2: {}", array2);
&nbsp;
array2 += &amp;array1;
&nbsp;
println!("result: {}", array2);
</pre>

<pre>
array1: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
array2: [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5]
result: [0, 1.5, 3, 4.5, 6, 7.5, 9, 10.5, 12, 13.5]
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Broadcasting</h2>

<pre>
let array1 = Array::from_iter(0..12).into_shape((3,4)).unwrap();
let array2 = Array::from_iter(0..4);
&nbsp;
println!("array1:\n{}\n", array1);
println!("array2:\n{}\n", array2);
&nbsp;
let result = array1 * array2;
println!("result:\n{}", result);
</pre>

<pre>
array1:
[[0, 1, 2, 3],
 [4, 5, 6, 7],
 [8, 9, 10, 11]]
&nbsp;
array2:
[0, 1, 2, 3]
&nbsp;
result:
[[0, 1, 4, 9],
 [0, 5, 12, 21],
 [0, 9, 20, 33]]
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Explicitní volání metody <strong>broadcast</strong></h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady (Rustovské projekty) byly,
ostatně podobně jako ve všech předchozích částech <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">tohoto seriálu</a>,
uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě
bez nutnosti klonovat celý repositář (ovšem u projektů je lepší mít celý
repositář, abyste nemuseli pracně stahovat všechny potřebné soubory):</p>

<table>
<tr><th>Příklad</th><th>Adresa</th></tr>
<tr><td>První projekt</td><td>ndarray-views</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-views/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-views/Cargo.toml</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-views/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-views/src/main.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Druhý projekt</td><td>ndarray-slices</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-slices/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-slices/Cargo.toml</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-slices/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-slices/src/main.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Třetí projekt</td><td>ndarray-operators</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-operators/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-operators/Cargo.toml</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-operators/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-operators/src/main.rs</a></td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>ndarray - dokumentace k&nbsp;modulu<br />
<a href="https://bluss.github.io/rust-ndarray/master/ndarray/index.html">https://bluss.github.io/rust-ndarray/master/ndarray/index.html</a>
</li>

<li>ndarray - Crate<br />
<a href="https://crates.io/crates/ndarray">https://crates.io/crates/ndarray</a>
</li>

<li>rustup<br />
<a href="https://www.rustup.rs/">https://www.rustup.rs/</a>
</li>

<li>rustup: the Rust toolchain installer (Git repositář + dokumentace)<br />
<a href="https://github.com/rust-lang-nursery/rustup.rs">https://github.com/rust-lang-nursery/rustup.rs</a>
</li>

<li>The Rust FFI Omnibus<br />
<a href="http://jakegoulding.com/rust-ffi-omnibus/">http://jakegoulding.com/rust-ffi-omnibus/</a>
</li>

<li>Build Script Support<br />
<a href="http://doc.crates.io/build-script.html">http://doc.crates.io/build-script.html</a>
</li>

<li>Calling Rust From Python<br />
<a href="https://bheisler.github.io/post/calling-rust-in-python/">https://bheisler.github.io/post/calling-rust-in-python/</a>
</li>

<li>Calling Rust in Python (komentáře k předchozímu článku)<br />
<a href="https://www.reddit.com/r/rust/comments/63iy5a/calling_rust_in_python/">https://www.reddit.com/r/rust/comments/63iy5a/calling_rust_in_python/</a>
</li>

<li>CFFI Documentation<br />
<a href="https://cffi.readthedocs.io/en/latest/">https://cffi.readthedocs.io/en/latest/</a>
</li>

<li>Build Script Support<br />
<a href="http://doc.crates.io/build-script.html">http://doc.crates.io/build-script.html</a>
</li>

<li>Creating a shared and static library with the gnu compiler [gcc]<br />
<a href="http://www.adp-gmbh.ch/cpp/gcc/create_lib.html">http://www.adp-gmbh.ch/cpp/gcc/create_lib.html</a>
</li>

<li>ctypes — A foreign function library for Python<br />
<a href="https://docs.python.org/2/library/ctypes.html">https://docs.python.org/2/library/ctypes.html</a>
</li>

<li>FFI: Foreign Function Interface<br />
<a href="https://doc.rust-lang.org/book/ffi.html">https://doc.rust-lang.org/book/ffi.html</a>
</li>

<li>Primitive Type pointer<br />
<a href="https://doc.rust-lang.org/std/primitive.pointer.html">https://doc.rust-lang.org/std/primitive.pointer.html</a>
</li>

<li>Cargo: správce projektů a balíčků pro programovací jazyk Rust<br />
<a href="https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/">https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/</a>
</li>

<li>Network Communication and Serialization in Rust<br />
<a href="https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/">https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/</a>
</li>

<li>Crate bincode<br />
<a href="http://tyoverby.com/bincode/bincode/index.html">http://tyoverby.com/bincode/bincode/index.html</a>
</li>

<li>Struct std::fs::File<br />
<a href="https://doc.rust-lang.org/std/fs/struct.File.html">https://doc.rust-lang.org/std/fs/struct.File.html</a>
</li>

<li>Trait std::io::Seek<br />
<a href="https://doc.rust-lang.org/std/io/trait.Seek.html">https://doc.rust-lang.org/std/io/trait.Seek.html</a>
</li>

<li>Trait std::io::Read<br />
<a href="https://doc.rust-lang.org/std/io/trait.Read.html">https://doc.rust-lang.org/std/io/trait.Read.html</a>
</li>

<li>Trait std::io::Write<br />
<a href="https://doc.rust-lang.org/std/io/trait.Write.html">https://doc.rust-lang.org/std/io/trait.Write.html</a>
</li>

<li>Trait std::io::BufRead<br />
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html">https://doc.rust-lang.org/std/io/trait.BufRead.html</a>
</li>

<li>Module std::io::prelude<br />
<a href="https://doc.rust-lang.org/std/io/prelude/index.html">https://doc.rust-lang.org/std/io/prelude/index.html</a>
</li>

<li>std::net::IpAddr<br />
<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">https://doc.rust-lang.org/std/net/enum.IpAddr.html</a>
</li>

<li>std::net::Ipv4Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html</a>
</li>

<li>std::net::Ipv6Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html</a>
</li>

<li>TcpListener<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">https://doc.rust-lang.org/std/net/struct.TcpListener.html</a>
</li>

<li>TcpStream<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html">https://doc.rust-lang.org/std/net/struct.TcpStream.html</a>
</li>

<li>Binary heap (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Binary_heap">https://en.wikipedia.org/wiki/Binary_heap</a>
</li>

<li>Binární halda (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda">https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda</a>
</li>

<li>Halda (datová struktura)<br />
<a href="https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29">https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29</a>
</li>

<li>Struct std::collections::HashSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">https://doc.rust-lang.org/std/collections/struct.HashSet.html</a>
</li>

<li>Struct std::collections::BTreeSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">https://doc.rust-lang.org/std/collections/struct.BTreeSet.html</a>
</li>

<li>Struct std::collections::BinaryHeap<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html">https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html</a>
</li>

<li>Set (abstract data type)<br />
<a href="https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support">https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support</a>
</li>

<li>Associative array<br />
<a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a>
</li>

<li>Hash Table<br />
<a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a>
</li>

<li>B-tree<br />
<a href="https://en.wikipedia.org/wiki/B-tree">https://en.wikipedia.org/wiki/B-tree</a>
</li>

<li>Pedro Celis: Robin Hood Hashing (naskenované PDF!)<br />
<a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf</a>
</li>

<li>Robin Hood hashing<br />
<a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">http://codecapsule.com/2013/11/11/robin-hood-hashing/</a>
</li>

<li>Robin Hood hashing: backward shift deletion<br />
<a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/</a>
</li>

<li>Module std::collections<br />
<a href="https://doc.rust-lang.org/std/collections/">https://doc.rust-lang.org/std/collections/</a>
</li>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Struct std::collections::VecDeque<br />
<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">https://doc.rust-lang.org/std/collections/struct.VecDeque.html</a>
</li>

<li>Struct std::collections::LinkedList<br />
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">https://doc.rust-lang.org/std/collections/struct.LinkedList.html</a>
</li>

<li>Module std::fmt<br />
<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>
</li>

<li>Macro std::println<br />
<a href="https://doc.rust-lang.org/std/macro.println.html">https://doc.rust-lang.org/std/macro.println.html</a>
</li>

<li>Enum std::result::Result<br />
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">https://doc.rust-lang.org/std/result/enum.Result.html</a>
</li>

<li>Module std::result<br />
<a href="https://doc.rust-lang.org/std/result/">https://doc.rust-lang.org/std/result/</a>
</li>

<li>Result<br />
<a href="http://rustbyexample.com/std/result.html">http://rustbyexample.com/std/result.html</a>
</li>

<li>Rust stdlib: Option<br />
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">https://doc.rust-lang.org/std/option/enum.Option.html</a>
</li>

<li>Module std::option<br />
<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>
</li>

<li>Rust by example: option<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>Rust by example: if-let<br />
<a href="http://rustbyexample.com/flow_control/if_let.html">http://rustbyexample.com/flow_control/if_let.html</a>
</li>

<li>Rust by example: while let<br />
<a href="http://rustbyexample.com/flow_control/while_let.html">http://rustbyexample.com/flow_control/while_let.html</a>
</li>

<li>Rust by example: Option&lt;i32&gt;<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

