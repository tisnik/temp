<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Architektura procesorů OpenRISC</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Architektura procesorů OpenRISC</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku si podrobněji popíšeme programátorský model mikroprocesorů s architekturou OpenRISC. Jedná se o specifikaci procesorů s modulární a modifikovatelnou instrukční sadou.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Architektura procesorů OpenRISC</a></p>
<p><a href="#k02">*** 2. Programátorský model OpenRISC</a></p>
<p><a href="#k03">*** 3. Funkce registrů při volání funkcí (dohodnutá konvence)</a></p>
<p><a href="#k04">*** 4. Registry se speciálními funkcemi</a></p>
<p><a href="#k05">*** 5. Nejdůležitější registry se speciální funkcí</a></p>
<p><a href="#k06">*** 6. Zjištění verze CPU, jeho architektury a dostupných jednotek</a></p>
<p><a href="#k07">*** 7. Přečtení konkrétních informací o možnostech nabízených mikroprocesorem</a></p>
<p><a href="#k08">*** 8. Příznakové bity</a></p>
<p><a href="#k09">*** 9. Instrukční sady použité v&nbsp;projektu OpenRISC</a></p>
<p><a href="#k10">*** 10. Formát slov v&nbsp;instrukční sadě ORBIS32</a></p>
<p><a href="#k11">*** 11. Instrukce v&nbsp;instrukční sadě ORBIS32</a></p>
<p><a href="#k12">*** 12. Aritmetické a logické instrukce</a></p>
<p><a href="#k13">*** 13. Příznakový bit <strong>F</strong> a instrukce pro práci s&nbsp;ním</a></p>
<p><a href="#k14">*** 14. Instrukce podmíněných i nepodmíněných skoků</a></p>
<p><a href="#k15">*** 15. Jednotka MAC</a></p>
<p><a href="#k16">*** 16. Seznam všech instrukcí v&nbsp;sadě ORBIS32</a></p>
<p><a href="#k17">*** 17. Referenční platforma ORPSoC</a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. </a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Architektura procesorů OpenRISC</h2>

<p>S&nbsp;projektem <i>OpenRISC</i> jsme se již &ndash; ovšem velmi stručně &ndash; na stránkách Rootu seznámili v&nbsp;článku <a href="https://www.root.cz/clanky/otevrene-riscove-architektury-openrisc-a-risc-v/">Otevřené RISCové architektury OpenRISC a RISC-V </a>. Od doby vydání tohoto článku již uplynula poměrně dlouhá doba (alespoň na poměry panující v&nbsp;IT) a navíc byl projekt OpenRISC popsán pouze povrchně, protože jsme se zaměřili spíše na &bdquo;konkurenční&ldquo; RISC V. Od té doby se OpenRISC dále vyvinul a vznikly i jeho zajímavé alternativy, například šestnáctibitový procesor, který je na myšlenkách OpenRISCu založen. Proto se s&nbsp;touto zajímavou a potenciálně užitečnou mikroprocesorovou platformou znovu seznámíme v&nbsp;dnešním článku, který bude zaměřen především na popis architektury procesorů OpenRISC z&nbsp;programátorského hlediska. V&nbsp;závěru článku si navíc popíšeme referenční platformu nazvanou ORPSoC neboli OpenRISC Reference Platform System on Chip.</p>

<p>V&nbsp;rámci tohoto projektu byl především zveřejněn design procesoru, který byl uvolněn pod licencí LGPL. Případný firmware je pak k&nbsp;dispozici pod licencí GPL. To je &ndash; alespoň podle mého názoru &ndash; docela dobrý kompromis mezi zajištěním otevřenosti celé platformy a současně to umožňuje komerční využití, i když ne v&nbsp;takové míře, jako je tomu u <i>RISC-V</i>. Projekt počítá jak s&nbsp;možností implementace &bdquo;pouhých&ldquo; 32bitových čipů, tak i čipů s&nbsp;64bitovými sběrnicemi a aritmeticko-logickou jednotkou. Navíc je možné si při implementaci zvolit, zda bude mikroprocesor obsahovat i matematický koprocesor (pro hodnoty s&nbsp;plovoucí řádovou čárkou typu float/single, double či obojí) popř.&nbsp;je možné na čip s&nbsp;mikroprocesorem přidat i koprocesor určený pro zpracování hodnot uložených v&nbsp;krátkých vektorech (toto rozšíření se nazývá SIMD či DSP, protože v&nbsp;něm jsou obsaženy i některé typické instrukce používané při zpracování signálů).</p>

endianes



<p><a name="k02"></a></p>
<h2 id="k02">2. Programátorský model OpenRISC</h2>

<p>Popišme si nyní programátorský model mikroprocesorů <i>OpenRISC</i>.  Podobně, jako tomu bylo u známé a stále používané architektury <i>MIPS</i>, i zde mají programátoři k&nbsp;dispozici šestnáct či (mnohem častěji) 32 pracovních registrů o šířce 32 bitů popř.&nbsp;64 bitů. Registry jsou pojmenované <strong>r0</strong> až <strong>r15</strong> (<strong>r31</strong>). V&nbsp;následující tabulce jsou vypsány funkce jednotlivých pracovních registrů, ovšem s&nbsp;tou poznámkou, že tyto funkce jsou založeny pouze na konvenci (kromě prvního registru, který je konstantně nulový, opět viz popis architektury <i>MIPS</i>):</p>

<table>
<tr><th>Registr</th><th>Alt.jméno</th><th>Význam</th></tr>
<tr><td>r0</td><td>Zero</td><td>tento registr obsahuje konstantně nulu, díky němu lze zjednodušit instrukční sadu</td></tr>
<tr><td>r1</td><td>SP</td><td>používá se jako ukazatel na vrchol zásobníku</td></tr>
<tr><td>r2</td><td>FP</td><td>používá se jako ukazatel na zásobníkový rámec</td></tr>
<tr><td>r9</td><td>LR</td><td>link registr, používá se pro uchování návratové adresy volající subrutiny</td></tr>
<tr><td>r11</td><td>RV</td><td>return registr, používá se pro předání návratové hodnoty do volající subrutiny</td></tr>
<tr><td>r12</td><td>RVH</td><td>return registr, používá se pro předání návratové hodnoty do volající subrutiny</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: zajímavé je, že registr <strong>r0</strong> sice obsahuje nulu, ovšem toto nastavení (vynulování) musí být provedeno při inicializaci CPU. Obecně se tedy nemusí jednat o konstantu, která je v&nbsp;mikroprocesoru &bdquo;zadrátována&ldquo;.</div></p>

<p>Registry <strong>r11+r12</strong> resp.&nbsp;<strong>RV+RVH</strong> se používají pro předání návratové hodnoty do volané funkce. Dvojice registrů je vyžadována například na 32bitových CPU v&nbsp;případě, že se má vracet typ <i>long</i>. Ovšem pozor &ndash; to, který z&nbsp;těchto registrů bude obsahovat vyšších 32 bitů a který nižších 32 bitů záleží na tom, zda se jedná o CPU s&nbsp;pořadím bajtů little endian nebo big endian.</p>

<p><div class="rs-tip-major">Poznámka: šířka všech zmíněných registrů je buď 32 bitů nebo plných 64 bitů, v&nbsp;závislosti na implementaci konkrétního jádra.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Funkce registrů při volání funkcí (dohodnutá konvence)</h2>

<p>Kromě pěti pracovních registrů, o nichž jsme se explicitně zmínili <a href="#k02">v&nbsp;předchozí kapitole</a>, existuje dohodnutá (resp.&nbsp;přesněji řečeno specifikovaná) konvence pro funkci ostatních dvaceti sedmi pracovních registrů. Tyto registry se dělí do tří skupin:</p>

<ol>
<li>Registry použité pro předání parametrů volané funkci</li>
<li>Registry, u nichž je zaručeno, že se po návratu z&nbsp;volané funkce nezmění jejich obsah</li>
<li>Registry, které naopak po návratu z&nbsp;volané funkce mohou mít odlišnou hodnotu</li>
</ol>

<p><div class="rs-tip-major">Poznámka: na tomto místě je vhodné si uvědomit, že RISCové procesory jsou typicky optimalizovány na operace/instrukce prováděné s&nbsp;pracovními registry, nikoli na operace nad hodnotami uloženými na zásobníkovém rámci. Proto je vhodné některé registry &bdquo;obětovat&ldquo; s&nbsp;tím, že mohou být změněny ve volané funkci/funkcích. Pokud funkce potřebuje použít větší množství registrů, není samozřejmě problém využít i registry se sudým indexem &ndash; pouze je nutné obnovit jejich původní obsah před návratem z&nbsp;funkce.</div></p>

<table>
<tr><th>Registry</th><th>Zachován při volání</th><th>Funkce</th></tr>
<tr><td>r3, r4, r5, r6, r7, r8</td><td>ne</td><td>parametry předávané volané funkci</td></tr>
<tr><td>r10, r14, r16, r18, r20, r22, r24, r26, r28, r30</td><td>ano</td><td>registry, které se po návratu z&nbsp;funkce nezmění</td></tr>
<tr><td>r13, r15, r17, r19, r21, r23, r25, r27, r29, r31</td><td>ano</td><td>pracovní registry, mohou se změnit</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Registry se speciálními funkcemi</h2>

<p>Kromě obecných registrů, o nichž jsme se zmínili v&nbsp;předchozích dvou kapitolách, je ve specifikaci popsáno i několik registrů se speciálními funkcemi. Tyto registry se označují zkratkou <strong>SPR</strong>, která vznikla z&nbsp;jejich označení <i>special-purpose registers</i>. Ne všechny dále popsané registry musí být implementovány všemi procesorovými jádry. Pokud některý registr není implementován (například se jedná o čip bez MMU), musí být zaručeno, že čtení takového registru vrátí nulu a zápis do něj nebude mít žádný viditelný efekt (nejedná se o chybu ani o výjimku). Registry se speciálními funkcemi jsou rozděleny do skupin, přičemž implementována by měla být alespoň nultá skupina. To, které skupiny registrů jsou k&nbsp;dispozici, je určeno bitovým polem uloženým do speciálního registru nazvaného <strong>UPR</strong>:</p>

<table>
<tr><th>Skupina</th><th>Význam</th></tr>
<tr><td>0</td><td>stavové a řídicí registry</td></tr>
<tr><td>1</td><td>řízení MMU pro data</td></tr>
<tr><td>2</td><td>řízení MMU pro instrukce</td></tr>
<tr><td>3</td><td>vyrovnávací paměť pro data</td></tr>
<tr><td>4</td><td>vyrovnávací paměť pro instrukce</td></tr>
<tr><td>5</td><td>jednotka MAC popsaná dále</td></tr>
<tr><td>6</td><td>jednotka použitá pro ladění</td></tr>
<tr><td>7</td><td>čítače použité při měření výkonu, doby trvání instrukcí atd.</td></tr>
<tr><td>8</td><td>power management</td></tr>
<tr><td>9</td><td>řadič přerušení (PIC)</td></tr>
<tr><td>10</td><td>časovače</td></tr>
<tr><td>11</td><td>registry používané matematickým koprocesorem</td></tr>
<tr><td>12-23</td><td>rezervováno, prozatím nepřiřazeno žádné funkci</td></tr>
<tr><td>24-31</td><td>skupiny registrů, které lze využít dalšími moduly na čipu (SoC apod.)</td></tr>
</table>

<p>Pro práci s&nbsp;těmito speciálními registry se používají dvě strojové instrukce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>l.mtspr</td><td>zápis hodnoty z&nbsp;pracovního registru do registru se speciální funkcí</td></tr>
<tr><td>2</td><td>l.mfspr</td><td>čtení hodnoty z&nbsp;registru speciální funkcí a zápis této hodnoty do pracovního registru</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: u obou zmíněných instrukcí je zajímavé, že index registru se speciální funkcí je určen bitovou operací OR mezi konstantou (součást instrukčního slova) a obsahem zvoleného pracovního registru. Můžeme zde využít faktu, že registru <strong>r0</strong> vrací při čtení vždy nulu a tudíž se při jeho použití vlastně využije přímo zapsaná konstanta.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Nejdůležitější registry se speciální funkcí</h2>

<p>Index každého <i>SPR</i> je složen ze dvou částí. V&nbsp;bitech 11 až 15 je uloženo číslo skupiny (0..31) a v&nbsp;bitech 0 až 10 pak číslo registru v&nbsp;rámci skupiny. To mj.&nbsp;znamená, že v&nbsp;každé skupině může být definováno až 2048 registrů. Celkem je teoreticky možné použít 65536 registrů se speciální funkcí (ovšem této hodnoty prakticky nikdy nedosáhneme). V&nbsp;následující tabulce jsou popsány ty registry, s&nbsp;nimiž se setká běžný programátor (používající assembler a OpenRISC &ndash; takže úplně běžný programátor to není). Vynechám asi sto registrů určených pro konfiguraci MMU, ladění, čítačů atd. I tyto registry jsou samozřejmě důležité, ovšem ne při psaní aplikací běžících v&nbsp;uživatelském prostoru:</p>

<table>
<tr><th>Skupina</th><th>Registr</th><th>Stručný popis</th></tr>
<tr><td>0</td><td>0</td><td>VR</td><td>obsahuje verzi (model) procesoru + číslo revize, používat by se měl VR2 a AVR</td></tr>
<tr><td>0</td><td>1</td><td>UPR</td><td>bitové pole popisující existující jednotky čipu</td></tr>
<tr><td>0</td><td>1</td><td>CPUCFGR</td><td>konfigurace CPU</td></tr>
<tr><td>0</td><td>9</td><td>VR2</td><td>novější registr s&nbsp;verzí</td></tr>
<tr><td>0</td><td>10</td><td>AVR</td><td>verze architektury čipu</td></tr>
<tr><td>0</td><td>12</td><td>AECR</td><td>řízení obsluhy výjimek při aritmetických operacích</td></tr>
<tr><td>0</td><td>13</td><td>AESR</td><td>stav výjimek aritmetických operací</td></tr>
<tr><td>0</td><td>16</td><td>NPC</td><td>programový čítač (další hodnota)</td></tr>
<tr><td>0</td><td>17</td><td>SR</td><td>supervisor registr + příznaky ALU</td></tr>
<tr><td>0</td><td>18</td><td>PPC</td><td>programový čítač (předchozí hodnota)</td></tr>
<tr><td>0</td><td>20</td><td>FPCSR</td><td>řízení matematického koprocesoru</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>1</td><td>MACLO</td><td>použito jednotkou pro MAC, viz další text s&nbsp;popisem MACu</td></tr>
<tr><td>5</td><td>2</td><td>MACHI</td><td>použito jednotkou pro MAC, viz další text s&nbsp;popisem MACu</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: povšimněte si především registru pojmenovaného <strong>UPR</strong>, o jehož funkci jsme se zmínili v&nbsp;předchozí kapitole. Jednotlivé bity tohoto registru určují, které <i>skupiny</i> registrů jsou k&nbsp;dispozici.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Zjištění verze CPU, jeho architektury a dostupných jednotek</h2>

<p>Vzhledem k&nbsp;tomu, že <i>OpenRISC</i> je navržen takovým způsobem, aby byl velmi flexibilní a rozšiřitelný, znamená to, že je nutné nějakým způsobem programátorům sdělit všechny důležité instrukce o čipu, na nichž jejich program běží. K&nbsp;tomuto účelu původně sloužil registru nazvaný <strong>VR</strong> (<i>Version Register</i>), ovšem podle novější specifikace by se namísto tohoto registru měla použít dvojice registrů <strong>VR2</strong> společně s&nbsp;registrem <strong>AVR</strong>. Oba zmíněné registry jsou dostupné v&nbsp;režimu &bdquo;supervisor&ldquo;, tj.&nbsp;zejména pro loader jádra a taktéž pro samotné jádro (popř.&nbsp;i pro obdobu BIOSu).</p>

<p>Obsah registru <strong>VR2</strong>:</p>

<table>
<tr><th>Bity</th><th>Označení</th><th>Význam</th></tr>
<tr><td>31-24</td><td>CPUID</td><td>unikátní číslo specifikující konkrétní čip</td></tr>
<tr><td>23-0</td><td>VER</td><td>postupně se zvyšující číslo verze čipu definovaného přes CPUID</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: označením <strong>CPUID</strong> je zde skutečně myšleno osm bitů, které by mělo jednoznačně identifikovat konkrétní čip popř.&nbsp;jeho dodavatele. Na platformě x86 je ovšem stejným názvem <strong>CPUID</strong> označena <a href="http://www.felixcloutier.com/x86/CPUID.html">strojová instrukce</a> (s&nbsp;velmi podobným významem).</div></p>

<p>Obsah registru <strong>AVR</strong>:</p>

<table>
<tr><th>Bity</th><th>Označení</th><th>Význam</th></tr>
<tr><td>31-24</td><td>MAJ</td><td>verze architektury (majoritní číslo před tečkou)</td></tr>
<tr><td>23-16</td><td>MIN</td><td>verze architektury (minoritní číslo za tečkou)</td></tr>
<tr><td>15-8</td><td>REV</td><td>revize (číslo za druhou tečkou)</td></tr>
<tr><td>7-0</td><td>&times;</td><td>rezervováno</td></tr>
</table>

<p>Obsah tohoto registru by měl co nejpřesněji určit, které instrukce jsou implementovány a jaké je jejich přesné chování.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Přečtení konkrétních informací o možnostech nabízených mikroprocesorem</h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. Příznakové bity</h2>

<p>V&nbsp;kontextu programátorského modelu je důležitý především registr nazvaný <strong>SR</strong> (<i>supervision register</i>) obsahující mimo jiné i tyto tři jednobitové příznaky:</p>

<table>
<tr><th>Zkratka</th><th>Příznak</th><th>Význam</th></tr>
<tr><td>CY</td><td>carry</td><td>příznak přenosu při aritmetických operacích</td></tr>
<tr><td>OV</td><td>overflow</td><td>příznak přetečení při aritmetických operacích (typ signed)</td></tr>
<tr><td>F</td><td>flag/branch</td><td>příznak použitý pro implementaci podmíněných skoků</td></tr>
</table>

<p>Zajímavé je, že pro podmíněné skoky lze přímo využít jen příznak <strong>flag</strong> resp.&nbsp;<strong>branch</strong>. Ten je nastavován některou instrukcí pro porovnání dvou registrů, takže podmíněný skok je v&nbsp;praxi implementován vždy dvěma instrukcemi. Záleží hlavně na překladači, jak instrukce přeskládá, aby instrukce podmíneného skoku nemusela čekat na výsledek porovnání (připomeňme si, že dnešní čipy mají většinou pipeline se čtyřmi nebo s&nbsp;pěti řezy).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Instrukční sady použité v&nbsp;projektu OpenRISC</h2>

<p>Vzhledem k&nbsp;tomu, že se předpokládá použití mikroprocesorových jader s&nbsp;architekturou <i>OpenRISC</i> v&nbsp;různých zařízeních, od jednodušších řídicích systémů přes zpracování signálů (DSP) až například po servery, je instrukční sada navržena modulárně. V&nbsp;současnosti existuje pět základních &bdquo;sad&ldquo; instrukcí s&nbsp;předpokladem, že další sady bude možné navrhnout a implementovat v&nbsp;budoucnosti. Jediné, s&nbsp;čím se v&nbsp;architektuře <i>OpenRISC</i> přímo nepočítá (alespoň prozatím), je podpora instrukcí proměnné délky, tj.&nbsp;obdoby sad <i>Thumb</i> známých z&nbsp;konkurenční architektury <i>ARM</i>. V&nbsp;následující tabulce je vypsáno všech pět prozatím oficiálně popsaných sad instrukcí architektury <i>OpenRISC</i>:</p>

<table>
<tr><th>#</th><th>Zkratka</th><th>Celé jméno</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>ORBIS32</td><td>OpenRISC Basic Instruction Set</td><td>zpracování 32bitových operandů, skoky, podmínky, bitové operace</td></tr>
<tr><td>2</td><td>ORBIS64</td><td>OpenRISC Basic Instruction Set</td><td>rozšíření na 64bitové operandy</td></tr>
<tr><td>3</td><td>ORFPX32</td><td>OpenRISC Floating Point eXtension</td><td>operace s&nbsp;numerickými hodnotami typu float/single (jednoduchá přesnost)</td></tr>
<tr><td>4</td><td>ORFPX64</td><td>OpenRISC Floating Point eXtension</td><td>operace s&nbsp;numerickými hodnotami typu double (dvojitá přesnost)</td></tr>
<tr><td>5</td><td>ORVDX64</td><td>OpenRISC Vector/DSP eXtension</td><td>zpracování hodnot uložených v&nbsp;64bitových vektorech</td></tr>
</table>

<p>Pro vytvoření reálně pracujícího mikroprocesoru postačuje implementovat pouze první sadu, tj.&nbsp;<strong>ORBIS32</strong>, samozřejmě s&nbsp;tím omezením, že zpracování 64bitových celých čísel či reálných čísel typu single a double bude prováděno softwarově (za pomoci subrutin). Základními vlastnostmi této instrukční sady se budeme zabývat v&nbsp;navazující kapitole.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Formát slov v&nbsp;instrukční sadě ORBIS32</h2>

<p>Základní instrukční sada <strong>ORBIS32</strong> se v&nbsp;několika ohledech podobá například instrukční sadě mikroprocesorů <i>MIPS</i>. I zde totiž najdeme instrukce s&nbsp;konstantní šířkou třiceti dvou, které jsou v&nbsp;operační paměti vždy zarovnány na adresu dělitelnou čtyřmi. Díky tomu se u skoků nemusí specifikovat nejnižší dva bity adresy či offsetu, neboť tyto bity jsou vždy nulové. Tak, jako je tomu u <i>MIPS</i>, i zde mají instrukční slova tři formáty. První formát se označuje písmenem <strong>R</strong> a používá se pro většinu aritmetických, logických a porovnávacích operací prováděných se dvěma zdrojovými registry a jedním registrem cílovým. Další formát se jmenuje <strong>I</strong> a používá se pro instrukce, v&nbsp;nichž se pracuje se dvěma registry (zdrojový+cílový) a šestnáctibitovou konstantou. Třetí formát se jmenuje <strong>J</strong> a používá se u skoků, neboť součástí instrukčního slova je mj.&nbsp;i 26bitová konstanta (to postačuje, neboť nemusíme specifikovat spodní dva bity).</p>

<p>Formát <strong>R</strong>:</p>

<pre>
  +-----+------+--------+--------+--------+------------------+
  |31 30|29  26| 25  21 | 20  16 | 15  11 | 10             0 |
  +-----+------+--------+--------+--------+------------------+
  |třída|opcode| rD (5) | rA (5) | rB (5) | druhá část opcode|
  +-----+------+--------+--------+--------+------------------+
</pre>

<p><div class="rs-tip-major">Můžeme vidět, že v&nbsp;tento formát obsahuje v&nbsp;nejvyšších dvou bitech tzv.&nbsp;třídu instrukce. Následuje operační kód uložený ve čtyřech bitech, který může být doplněn bity 0 až 10. Důležitá je trojice bitových polí rD, rA a rB, které obsahují indexy pracovních registrů, které jsou instrukcí použity. Vidíme, že se zde využívá takzvaný <i>tříadresový kód</i> se dvěma registry zdrojovými a jedním registrem cílovým.</div></p>

<p>Formát <strong>I</strong>:</p>

<pre>
  +-----+------+--------+--------+---------------------------+
  |31 30|29  26| 25  21 | 20  16 | 15                      0 |
  +-----+------+--------+--------+---------------------------+
  |třída|opcode| rD (5) | rA (5) | offset/konstanta (16)     |
  +-----+------+--------+--------+---------------------------+
</pre>

<p><div class="rs-tip-major">I v&nbsp;tomto formátu můžeme vidět, že v&nbsp;nejvyšších dvou bitech je uložena třída instrukce a následuje čtyřbitový operační kód. Instrukce formátu I pracují s&nbsp;dvojicí registrů specifikovaných v&nbsp;bitových polích rD a rA. Taktéž se specifikuje šestnáctibitový offset nebo šestnáctibitová konstanta. Podle typu instrukce je tato konstanta chápána bez znaménka (unsigned) nebo se znaménkem (signed) a bývá rozšířena na plných 32 či dokonce 64 bitů (opět v&nbsp;závislosti na tom, o jakou instrukci se jedná).</div></p>

<p>Formát <strong>J</strong>:</p>

<pre>
  +-----+------+---------------------------------------------+
  |31 30|29  26| 25                                        0 |
  +-----+------+---------------------------------------------+
  |třída|opcode| adresa (26)                                 |
  +-----+------+---------------------------------------------+
</pre>

<p><div class="rs-tip-major">Tento formát je nejjednodušší. Po již známých bitových polích se specifikací třídy instrukce a operačního kódu následuje adresa, která je zakódována do 26 bitů. Nejnižší dva bity reálné adresy jsou nulové, protože instrukce jsou zarovnány na adresy dělitelné čtyřmi. Samotná adresa je zadána buď absolutně nebo relativně, podle typu instrukce. Relativní adresa se bude vždy vztahovat k&nbsp;aktuální hodnotě registru PC (program counter).</div></p>

<p>Pro porovnání si ukažme formáty instrukčních slov tak, jak jsou implementovány na klasickém 32bitovém MIPSu:</p>

<p>Formát <strong>R</strong>:</p>

<pre>
  +------------+--------+--------+--------+-------+----------+
  | 31  26     | 25  21 | 20  16 | 15  11 | 10  6 | 5      0 |
  +------------+--------+--------+--------+-------+----------+
  | opcode (6) | rs (5) | rt (5) | rd (5) | shift | operace  |
  +------------+--------+--------+--------+-------+----------+
</pre>

<p>Formát <strong>I</strong>:</p>

<pre>
  +------------+-----------------+---------------------------+
  | 31  26     | 25  21 | 20  16 | 15                      0 |
  +------------+-----------------+---------------------------+
  | opcode (6) | rs (5) | rt (5) | offset/konstanta (16)     |
  +------------+-----------------+---------------------------+
</pre>

<p>Formát <strong>J</strong>:</p>

<pre>
  +------------+---------------------------------------------+
  | 31  26     | 25                                        0 |
  +------------+---------------------------------------------+
  | opcode (6) | adresa (26)                                 |
  +------------+---------------------------------------------+
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Instrukce v&nbsp;instrukční sadě ORBIS32</h2>

<p>Vzhledem k&nbsp;tomu, že všechny aritmetické a logické operace pracují s&nbsp;hodnotami uloženými v&nbsp;registrech, je množina instrukcí pro přesuny dat do a z&nbsp;paměti poměrně malá. <i>OpenRISC</i> podporuje instrukce typu <strong>load</strong> a <strong>store</strong>, které mohou zpracovávat bajty, 16bitová slova či 32bitová slova. Při načítání bajtů a 16bitových slov se provádí rozšíření na plných 32 bitů se znaménkem (doplnění podle nejvyššího bitu načítané hodnoty) či bez znaménka (doplnění nul). To je v&nbsp;mnoha ohledech praktické, neboť i ty nejmodernější 64bitové mikroprocesory mnohdy tráví většinu času zpracováním řetězců.</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td></td><td></td></tr>
<tr><td>2</td><td></td><td></td></tr>
<tr><td>3</td><td></td><td></td></tr>
<tr><td>4</td><td></td><td></td></tr>
<tr><td>5</td><td></td><td></td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Aritmetické a logické instrukce</h2>

<p>Mezi aritmetickými instrukcemi najdeme například sčítání s&nbsp;carry či bez carry, násobení a dělení (se znaménkem či bez znaménka), operace typu &bdquo;multiply and accumulate&ldquo; a &bdquo;multiply and subtract&ldquo; a dokonce instrukce <strong>ff1</strong> (find first 1) a <strong>fl1</strong> (find last 1). Už na tomto krátkém výčtu je patrné, že instrukční sada je poměrně rozsáhlá a implementace &bdquo;na křemíku&ldquo; patřičně komplikovaná (měřeno plochou čipu).</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td></td><td></td></tr>
<tr><td>2</td><td></td><td></td></tr>
<tr><td>3</td><td></td><td></td></tr>
<tr><td>4</td><td></td><td></td></tr>
<tr><td>5</td><td></td><td></td></tr>
</table>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td></td><td></td></tr>
<tr><td>2</td><td></td><td></td></tr>
<tr><td>3</td><td></td><td></td></tr>
<tr><td>4</td><td></td><td></td></tr>
<tr><td>5</td><td></td><td></td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Příznakový bit <strong>F</strong> a instrukce pro práci s&nbsp;ním</h2>

<p>Za zmínku stojí taktéž instrukce začínající prefixem <strong>sf</strong>. Tyto instrukce nastavují příznakový bit <strong>branch/F</strong> na základě výsledku porovnání dvou registrů či porovnání registru s&nbsp;šestnáctibitovou konstantou. Hodnota příznakového bitu je následně využita v&nbsp;podmíněném skoku. Příkladem může být instrukce <strong>sfeq</strong> nastavující <strong>F&larr;1</strong> jen tehdy, pokud mají oba registry shodnou hodnotu.  Nezapomeňme navíc na registr <strong>r0</strong> s&nbsp;&bdquo;trvalou nulou&ldquo;, díky jehož existenci automaticky získáváme instrukce <strong>sfzero</strong>. Alternativou k&nbsp;<strong>sfeq</strong> je instrukce <strong>sfeqi</strong> pro porovnání registru s&nbsp;konstantou. Existují i další alternativy, kde se namísto &bdquo;eq&ldquo; používá &bdquo;gt&ldquo; (větší než), &bdquo;ge&ldquo; (větší nebo rovno) atd.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Instrukce podmíněných i nepodmíněných skoků</a></h2>

<p>Mezi skokové instrukce patří zejména:</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>l.j</td><td>skok na adresu PC+konstanta</td></tr>
<tr><td>l.jal</td><td>skok na adresu PC+konstanta, návratová adresa se uloží do registru r9</td></tr>
<tr><td>l.jr</td><td>skok na adresu uloženou ve specifikovaném registru</td></tr>
<tr><td>l.jalr</td><td>kombinace jal+jr (skok na adresu v&nbsp;registru, návratová adresa &rarr; r9)</td></tr>
<tr><td>l.bf</td><td>skok na PC+konstanta pokud je <strong>F</strong> nastaven</td></tr>
<tr><td>l.bnf</td><td>skok na PC+konstanta pokud je <strong>F</strong> vynulován</td></tr>
</table>

<p>Poslední instrukcí, o níž se v&nbsp;této kapitole zmíníme, je instrukce <strong>cmov</strong> používající taktéž tříadresový kód (indexy tří registrů). Tato instrukce může v&nbsp;některých případech nahradit podmíněné skoky:</p>

<ol>
<li>Pokud je F==1, proveď <strong>mov D,A</strong></li>
<li>Pokud je F==0, proveď <strong>mov D,B</strong></li>
</ol>



<p><a name="k15"></a></p>
<h2 id="k15">15. Jednotka MAC</h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. Seznam všech instrukcí v&nbsp;sadě ORBIS32</h2>

<table>
<tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</table>

l.add
l.addc
l.addi
l.addic
l.and
l.andi
l.bf
l.bnf
l.cmov
l.csync
l.div
l.divu
l.extbs
l.extbz
l.exths
l.exthz
l.extws
l.extwz
l.ff1
l.fl1
l.j
l.jal
l.jalr
l.jr
l.lbs
l.lbz
l.ld
l.lhs
l.lhz
l.lwa
l.lws
l.lwz
l.mac
l.maci
l.macrc
l.macu
l.mfspr
l.movhi
l.msb
l.msbu
l.mtspr
l.msync
l.mtspr
l.mul
l.muld
l.muldu
l.muli
l.mulu
l.nop
l.or
l.ori
l.psync
l.rfe
l.ror
l.rori
l.sb
l.sd
l.sfeq
l.sfeqi
l.sfges
l.sfgesi
l.sfgeu
l.sfgeui
l.sfgts
l.sfgtsi
l.sfgtu
l.sfgtui
l.sfles
l.sflesi
l.sfleu
l.sfleui
l.sflts
l.sfltsi
l.sfltu
l.sfltui
l.sfne
l.sfnei
l.sh
l.sll
l.slli
l.sra
l.srai
l.srl
l.srli
l.sub
l.sw
l.swa
l.sys
l.trap
l.xor
l.xori



<p><a name="k17"></a></p>
<h2 id="k17">17. Referenční platforma ORPSoC</h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. </h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>OpenRISC (oficiální stránky)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>OpenRISC System-on-Chip Design Emulation<br />
<a href="https://arxiv.org/pdf/1602.03095.pdf">https://arxiv.org/pdf/1602.03095.pdf</a>
</li>

<li>Open cores<br />
<a href="https://opencores.org/">https://opencores.org/</a>
</li>

<li>Projekt OpenRISC 2000<br />
<a href="https://opencores.org/project/or2k">https://opencores.org/project/or2k</a>
</li>

<li>OpenRISC na GitHubu<br />
<a href="https://github.com/openrisc">https://github.com/openrisc</a>
</li>

<li>OpenRISC 1200<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC_1200">https://en.wikipedia.org/wiki/OpenRISC_1200</a>
</li>

<li>OpenRISC 1200 IP Core Specification (Preliminary Draft)<br />
<a href="https://opencores.org/ocsvn/openrisc/openrisc/trunk/or1200/doc/openrisc1200_spec.pdf">https://opencores.org/ocsvn/openrisc/openrisc/trunk/or1200/doc/openrisc1200_spec.pdf</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>Maska mikroprocesoru RISC 1<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg</a>
</li>

<li>Maska mikroprocesoru RISC 2<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg</a>
</li>

<li>C.E. Sequin and D.A.Patterson: Design and Implementation of RISC I<br />
<a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf">http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>SPARC Processor Family Photo<br />
<a href="http://thenetworkisthecomputer.com/site/?p=243">http://thenetworkisthecomputer.com/site/?p=243</a>
</li>

<li>SPARC: Decades of Continuous Technical Innovation<br />
<a href="http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical">http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical</a>
</li>

<li>The SPARC processors<br />
<a href="http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors">http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors</a>
</li>

<li>Reduced instruction set computing (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Reduced_instruction_set_computer">http://en.wikipedia.org/wiki/Reduced_instruction_set_computer</a>
</li>

<li>MIPS architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MIPS_architecture">http://en.wikipedia.org/wiki/MIPS_architecture</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>Classic RISC pipeline (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Classic_RISC_pipeline">http://en.wikipedia.org/wiki/Classic_RISC_pipeline</a>
</li>

<li>R2000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R2000_(microprocessor)">http://en.wikipedia.org/wiki/R2000_(microprocessor)</a>
</li>

<li>R3000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R3000">http://en.wikipedia.org/wiki/R3000</a>
</li>

<li>R4400 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R4400">http://en.wikipedia.org/wiki/R4400</a>
</li>

<li>R8000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R8000">http://en.wikipedia.org/wiki/R8000</a>
</li>

<li>R10000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R10000">http://en.wikipedia.org/wiki/R10000</a>
</li>

<li>SPARC (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Sparc">http://en.wikipedia.org/wiki/Sparc</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Control unit (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Control_unit">http://en.wikipedia.org/wiki/Control_unit</a>
</li>

<li>CPUID na x86-64<br />
<a href="http://www.felixcloutier.com/x86/CPUID.html">http://www.felixcloutier.com/x86/CPUID.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

