<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Architektura mikroprocesorů OpenRISC</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Architektura mikroprocesorů OpenRISC</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku si podrobněji popíšeme programátorský model mikroprocesorů s architekturou OpenRISC. Jedná se o specifikaci procesorů s modulární a modifikovatelnou instrukční sadou, jejichž design je dostupný pod licencí LGPL.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Architektura mikroprocesorů OpenRISC</a></p>
<p><a href="#k02">2. Programátorský model OpenRISC</a></p>
<p><a href="#k03">3. Funkce registrů při volání funkcí (dohodnutá konvence)</a></p>
<p><a href="#k04">4. Registry se speciálními funkcemi</a></p>
<p><a href="#k05">5. Nejdůležitější registry se speciální funkcí</a></p>
<p><a href="#k06">6. Zjištění verze CPU, jeho architektury a dostupných jednotek</a></p>
<p><a href="#k07">7. Přečtení konkrétních informací o možnostech nabízených mikroprocesorem</a></p>
<p><a href="#k08">8. Příznakové bity</a></p>
<p><a href="#k09">9. Instrukční sady použité v&nbsp;projektu OpenRISC</a></p>
<p><a href="#k10">10. Formát slov v&nbsp;instrukční sadě ORBIS32</a></p>
<p><a href="#k11">11. Instrukce v&nbsp;instrukční sadě ORBIS32</a></p>
<p><a href="#k12">12. Aritmetické a logické instrukce</a></p>
<p><a href="#k13">13. Příznakový bit <strong>F</strong> a instrukce pro práci s&nbsp;ním</a></p>
<p><a href="#k14">14. Instrukce podmíněných i nepodmíněných skoků</a></p>
<p><a href="#k15">15. Jednotka MAC</a></p>
<p><a href="#k16">16. Branch delay sloty</a></p>
<p><a href="#k17">17. Seznam všech instrukcí v&nbsp;sadě ORBIS32</a></p>
<p><a href="#k18">18. Obsah pokračování článku</a></p>
<p><a href="#k19">19. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Architektura mikroprocesorů OpenRISC</h2>

<p>S&nbsp;projektem <i>OpenRISC</i> jsme se již &ndash; ovšem velmi stručně
&ndash; na stránkách Rootu již seznámili v&nbsp;článku <a
href="https://www.root.cz/clanky/otevrene-riscove-architektury-openrisc-a-risc-v/">Otevřené
RISCové architektury OpenRISC a RISC-V </a>. Od doby vydání tohoto článku již
uplynula poměrně dlouhá doba (alespoň na poměry panující v&nbsp;IT) a navíc byl
projekt OpenRISC prozatím popsán pouze povrchně, protože jsme se zaměřili spíše
na &bdquo;konkurenční&ldquo; jádra RISC V. Ovšem i OpenRISC se mezitím dále
vyvinul a vznikly i jeho zajímavé alternativy, například šestnáctibitový
procesor, který je na myšlenkách OpenRISCu založen. Proto se s&nbsp;touto
zajímavou a potenciálně užitečnou mikroprocesorovou platformou znovu seznámíme
v&nbsp;dnešním článku, který bude zaměřen především na popis architektury
procesorů OpenRISC z&nbsp;programátorského hlediska. V&nbsp;navazujícím článku
si navíc popíšeme referenční platformu nazvanou <i>ORPSoC</i> neboli
<i>OpenRISC Reference Platform System on Chip</i>.</p>

<p>Připomeňme si, o jaký projekt se v&nbsp;případě OpenRISCu jedná.
V&nbsp;rámci tohoto projektu byl především zveřejněn design procesoru, který
byl uvolněn pod licencí LGPL. Případný firmware je pak k&nbsp;dispozici pod
licencí GPL. To je &ndash; alespoň podle mého názoru &ndash; docela dobrý
kompromis mezi zajištěním otevřenosti celé platformy a současně to umožňuje
komerční využití, i když ne v&nbsp;takové míře, jako je tomu u <i>RISC-V</i>.
Projekt počítá jak s&nbsp;možností implementace &bdquo;pouhých&ldquo;
32bitových čipů, tak i čipů s&nbsp;64bitovými sběrnicemi a aritmeticko-logickou
jednotkou. Navíc je možné si při implementaci zvolit, zda bude mikroprocesor
obsahovat i matematický koprocesor (pro hodnoty s&nbsp;plovoucí řádovou čárkou
typu float/single, double či obojí) popř.&nbsp;je možné na čip
s&nbsp;mikroprocesorem přidat i koprocesor určený pro zpracování hodnot
uložených v&nbsp;krátkých vektorech (toto rozšíření se nazývá SIMD či DSP,
protože v&nbsp;něm jsou obsaženy i některé typické instrukce používané při
zpracování signálů).</p>

<p><div class="rs-tip-major">Poznámka: specifikace umožňuje, aby konkrétní CPU
byly buď typu little endian či big endian. Tento rozdíl se dotýká především
způsobu použití pracovních registrů při volání funkcí a předávání návratových
hodnot z&nbsp;volaných funkcí. Podrobnosti si řekneme níže, bližší informace o
little a big endian naleznete například <a
href="https://en.wikipedia.org/wiki/Endianness">na Wikipedii</a>.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Programátorský model OpenRISC</h2>

<p>Popišme si nyní programátorský model mikroprocesorů <i>OpenRISC</i>.
Podobně, jako tomu bylo u známé a stále používané architektury <i>MIPS</i>, i
zde mají programátoři k&nbsp;dispozici šestnáct či (mnohem častěji) 32
pracovních registrů, každý o šířce 32 bitů popř.&nbsp;64 bitů. Registry jsou
pojmenované <strong>r0</strong> až <strong>r15</strong> (<strong>r31</strong>),
což jsou opět jména v&nbsp;oblasti RISCů obvyklá. V&nbsp;následující tabulce
jsou vypsány funkce jednotlivých pracovních registrů, ovšem s&nbsp;tou
poznámkou, že tyto funkce jsou založeny pouze na konvenci (kromě prvního
registru, který je při správné inicializaci CPU konstantně nulový, opět viz
popis architektury <i>MIPS</i>):</p>

<table>
<tr><th>Registr</th><th>Alternativní jméno</th><th>Význam</th></tr>
<tr><td>r0</td><td>Zero</td><td>tento registr obsahuje konstantně nulu, díky němu lze do značné míry zjednodušit instrukční sadu</td></tr>
<tr><td>r1</td><td>SP</td><td><i>stack pointer</i>, používá se jako ukazatel na vrchol zásobníku</td></tr>
<tr><td>r2</td><td>FP</td><td><i>frame pointer</i>, používá se jako ukazatel na zásobníkový rámec</td></tr>
<tr><td>r9</td><td>LR</td><td><i>link register</i>, používá se pro uchování návratové adresy volající subrutiny</td></tr>
<tr><td>r11</td><td>RV</td><td><i>return register</i>, používá se pro předání návratové hodnoty do volající subrutiny</td></tr>
<tr><td>r12</td><td>RVH</td><td><i>return register</i>, používá se pro předání návratové hodnoty do volající subrutiny</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: zajímavé je, že registr
<strong>r0</strong> sice skutečně prakticky za všech okolností obsahuje nulu,
ovšem toto nastavení (vynulování) musí být provedeno při inicializaci CPU.
Obecně se tedy nemusí jednat o konstantu, která je v&nbsp;mikroprocesoru
&bdquo;zadrátována&ldquo;.</div></p>

<p>Registry <strong>r11+r12</strong> resp.&nbsp;<strong>RV+RVH</strong> se
používají pro předání návratové hodnoty do volané funkce. Dvojice registrů je
vyžadována například na 32bitových CPU v&nbsp;případě, že se má vracet typ
<i>long</i>. Ovšem pozor &ndash; to, který z&nbsp;těchto registrů bude
obsahovat vyšších 32 bitů a který nižších 32 bitů záleží na tom, zda se jedná o
CPU s&nbsp;pořadím bajtů little endian nebo big endian (alternativní jména
těchto dvou registrů tedy mohou být poněkud matoucí).</p>

<p><div class="rs-tip-major">Poznámka: šířka všech zmíněných registrů je buď 32
bitů nebo plných 64 bitů, v&nbsp;závislosti na implementaci konkrétního jádra.
Prozatím pro jednoduchost předpokládejme, že se používá 32bitová
architektura.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Funkce registrů při volání funkcí (dohodnutá konvence)</h2>

<p>Kromě šesti pracovních registrů, o nichž jsme se explicitně zmínili <a
href="#k02">v&nbsp;předchozí kapitole</a>, existuje dohodnutá
(resp.&nbsp;přesněji řečeno specifikovaná) konvence pro funkci ostatních
dvaceti šesti pracovních registrů. Tyto registry se obecně dělí do tří
skupin:</p>

<ol>

<li>Registry použité pro předání parametrů volané funkci.</li>

<li>Registry, u nichž je zaručeno, že se po návratu z&nbsp;volané funkce
nezmění jejich obsah.</li>

<li>Registry, které naopak po návratu z&nbsp;volané funkce mohou mít odlišnou
hodnotu a volající funkce tedy musí s&nbsp;tímto chováním počítat.</li>

</ol>

<p><div class="rs-tip-major">Poznámka: na tomto místě je vhodné si uvědomit, že
RISCové procesory jsou typicky optimalizovány na operace/instrukce prováděné
s&nbsp;pracovními registry, nikoli na operace nad hodnotami uloženými na
zásobníkovém rámci nebo na haldě (<i>heapu</i>). Proto je vhodné některé
registry &bdquo;obětovat&ldquo; s&nbsp;tím, že mohou být změněny ve volané
funkci/funkcích (ostatně 32 registrů by mohlo být dosti velké množství pro
většinu běžných úloh). Pokud funkce potřebuje použít větší množství registrů,
není samozřejmě problém využít i registry se sudým indexem &ndash; pouze je
nutné obnovit jejich původní obsah před návratem z&nbsp;funkce.</div></p>

<table>
<tr><th>Registry</th><th>Zachován při volání</th><th>Funkce</th></tr>
<tr><td>r3, r4, r5, r6, r7, r8</td><td>ne</td><td>parametry předávané volané funkci</td></tr>
<tr><td>r10, r14, r16, r18, r20, r22, r24, r26, r28, r30</td><td>ano</td><td>registry, které se po návratu z&nbsp;funkce nezmění</td></tr>
<tr><td>r13, r15, r17, r19, r21, r23, r25, r27, r29, r31</td><td>ano</td><td>pracovní registry, mohou se změnit</td></tr>
</table>

<p>Tato konvence by měla být dodržována všemi dostupnými překladači.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Registry se speciálními funkcemi</h2>

<p>Mimo obecných pracovních registrů, o nichž jsme se zmínili
v&nbsp;předchozích dvou kapitolách, je ve specifikaci popsáno i několik desítek
registrů se speciálními funkcemi. Tyto registry se souhrnně označují zkratkou
<strong>SPR</strong>, která vznikla z&nbsp;jejich pojmenování
<i>special-purpose registers</i>. Ne všechny dále popsané registry ovšem musí
být implementovány všemi procesorovými jádry. Pokud některý registr není
implementován (například se jedná o čip bez MMU, což je v&nbsp;případě MCU nebo
DSP legitimní), musí být zaručeno, že čtení takového registru vrátí nulu a
zápis do něj nebude mít žádný viditelný efekt (nejedná se ovšem ani o chybu ani
o výjimku). Registry se speciálními funkcemi jsou rozděleny do skupin
(<i>groups</i>), přičemž implementována by měla být alespoň nultá skupina,
přesněji řečeno vybrané registry z&nbsp;této skupiny. To, které skupiny
registrů jsou skutečně k&nbsp;dispozici, je určeno bitovým polem uloženým do
speciálního registru nazvaného <strong>UPR</strong>:</p>

<table>
<tr><th>Skupina</th><th>Význam</th></tr>
<tr><td>0</td><td>stavové a řídicí registry</td></tr>
<tr><td>1</td><td>řízení MMU (<i>memory management unit</i>) pro data</td></tr>
<tr><td>2</td><td>řízení MMU (<i>memory management unit</i>) pro instrukce</td></tr>
<tr><td>3</td><td>vyrovnávací paměť pro data (stav a řízení)</td></tr>
<tr><td>4</td><td>vyrovnávací paměť pro instrukce (stav a řízení)</td></tr>
<tr><td>5</td><td>jednotka MAC popsaná dále</td></tr>
<tr><td>6</td><td>jednotka použitá pro ladění (debug)</td></tr>
<tr><td>7</td><td>čítače použité při měření výkonu, doby trvání instrukcí atd.</td></tr>
<tr><td>8</td><td>power management</td></tr>
<tr><td>9</td><td>řadič přerušení (PIC &ndash; Programmable Interrupt Controller)</td></tr>
<tr><td>10</td><td>časovače</td></tr>
<tr><td>11</td><td>registry používané matematickým koprocesorem</td></tr>
<tr><td>12-23</td><td>rezervováno, prozatím nepřiřazeno žádné funkci</td></tr>
<tr><td>24-31</td><td>skupiny registrů, které lze využít dalšími moduly na čipu (SoC apod.)</td></tr>
</table>

<p>Pro práci s&nbsp;těmito speciálními registry se používají dvě strojové
instrukce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>l.mtspr</td><td>zápis hodnoty z&nbsp;pracovního registru do registru se speciální funkcí</td></tr>
<tr><td>2</td><td>l.mfspr</td><td>přečtení hodnoty z&nbsp;registru speciální funkcí a zápis této hodnoty do pracovního registru</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: u obou zmíněných instrukcí je zajímavé,
že index registru se speciální funkcí je určen bitovou operací OR mezi
konstantou (součást instrukčního slova) a obsahem zvoleného pracovního
registru. Můžeme zde využít faktu, že pracovní registr <strong>r0</strong>
vrací při čtení vždy nulu a tudíž se při jeho použití vlastně využije přímo
zapsaná šestnáctibitová konstanta.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Nejdůležitější registry se speciální funkcí</h2>

<p>Index každého registru se speciální funkcí (<i>SPR</i>) je složen ze dvou
částí. V&nbsp;bitech 11 až 15 je uloženo číslo skupiny (tj.&nbsp;hodnota 0..31)
a v&nbsp;bitech 0 až 10 pak číslo registru v&nbsp;rámci skupiny. To
mj.&nbsp;znamená, že v&nbsp;každé skupině může být definováno až 2048 registrů.
Celkem je teoreticky možné použít 65536 registrů se speciální funkcí, ovšem
této hodnoty samozřejmě prakticky nikdy nedosáhneme. V&nbsp;následující tabulce
jsou popsány ty SPR registry, s&nbsp;nimiž se setká běžný programátor (pravda:
používající assembler a OpenRISC &ndash; takže úplně běžný programátor to
není). Vynechám asi sto registrů určených pro konfiguraci MMU, ladění, čítačů
atd. I tyto registry jsou samozřejmě důležité a užitečné, ovšem ne při psaní
aplikací běžících v&nbsp;uživatelském prostoru:</p>

<table>
<tr><th>Skupina</th><th>Registr</th><th>Stručný popis</th></tr>
<tr><td>0</td><td>0</td><td>VR</td><td>obsahuje verzi (model) procesoru + číslo revize, používat by se měl VR2 a AVR</td></tr>
<tr><td>0</td><td>1</td><td>UPR</td><td>bitové pole popisující existující jednotky čipu</td></tr>
<tr><td>0</td><td>1</td><td>CPUCFGR</td><td>konfigurace CPU</td></tr>
<tr><td>0</td><td>9</td><td>VR2</td><td>novější registr s&nbsp;verzí, nahrazuje funkci registru VR</td></tr>
<tr><td>0</td><td>10</td><td>AVR</td><td>verze architektury čipu, nahrazuje funkci registru VR</td></tr>
<tr><td>0</td><td>12</td><td>AECR</td><td>řízení obsluhy výjimek při aritmetických operacích</td></tr>
<tr><td>0</td><td>13</td><td>AESR</td><td>stav výjimek aritmetických operací</td></tr>
<tr><td>0</td><td>16</td><td>NPC</td><td>programový čítač (další hodnota PC)</td></tr>
<tr><td>0</td><td>17</td><td>SR</td><td>supervisor registr + příznaky ALU</td></tr>
<tr><td>0</td><td>18</td><td>PPC</td><td>programový čítač (předchozí hodnota PC)</td></tr>
<tr><td>0</td><td>20</td><td>FPCSR</td><td>řízení matematického koprocesoru, stav matematického koprocesoru</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>1</td><td>MACLO</td><td>použito jednotkou pro MAC, viz další text s&nbsp;popisem MACu</td></tr>
<tr><td>5</td><td>2</td><td>MACHI</td><td>použito jednotkou pro MAC, viz další text s&nbsp;popisem MACu</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: povšimněte si především registru
pojmenovaného <strong>UPR</strong> (<i>Unit Present Register</i>), o jehož
funkci jsme se zmínili v&nbsp;předchozí kapitole. Jednotlivé bity tohoto
registru určují, které <i>skupiny</i> registrů jsou k&nbsp;dispozici:</div></p>

<table>
<tr><th>Bit</th><th>Význam</th></tr>
<tr><td>0</td><td>UPR je/není k&nbsp;dispozici</td></tr>
<tr><td>1</td><td>DCP &ndash; datová cache</td></tr>
<tr><td>2</td><td>ICP &ndash; instrukční cache</td></tr>
<tr><td>3</td><td>DPM &ndash; MMU pro data</td></tr>
<tr><td>4</td><td>IPM &ndash; MMU pro instrukce</td></tr>
<tr><td>5</td><td>MP &ndash; jednotka MAC</td></tr>
<tr><td>6</td><td>DUP &ndash; jednotka pro ladění</td></tr>
<tr><td>7</td><td>PCUP &ndash; jednotka s&nbsp;čítači</td></tr>
<tr><td>8</td><td>PICP &ndash; řadič přerušení PIC</td></tr>
<tr><td>9</td><td>PMP &ndash; jednotka pro řízení spotřeby</td></tr>
<tr><td>10</td><td>TTP &ndash; přesné čítače</td></tr>
<tr><td>11-23</td><td>rezervováno</td></tr>
<tr><td>23-31</td><td>CUP &ndash; custom unit/pro dále nespecifikované jednotky</td></tr>
</table>

<p>Hned nultý bit určuje, zda je vůbec UPR k&nbsp;dispozici. Připomeňme si, že
při čtení jakéhokoli neexistujícího registru by se měla vrátit nula, takže i
tento bit by byl nulový, čímž je potvrzeno, že GPR skutečně neexistuje.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Zjištění verze CPU, jeho architektury a dostupných jednotek</h2>

<p>Vzhledem k&nbsp;tomu, že <i>OpenRISC</i> je navržen takovým způsobem, aby
byl velmi flexibilní a rozšiřitelný, znamená to, že je nutné nějakým způsobem
programátorům sdělit všechny důležité instrukce o konkrétním čipu, na nichž
jejich program v&nbsp;daném okamžiku běží (tyto informace bude potřebovat
loader jádra, samotné jádro a popř.&nbsp;obdoba BIOSu). K&nbsp;tomuto účelu
původně sloužil registr nazvaný <strong>VR</strong> (<i>Version Register</i>),
ovšem podle novější specifikace by se namísto tohoto registru měla použít
dvojice registrů <strong>VR2</strong> společně s&nbsp;registrem
<strong>AVR</strong>. Oba zmíněné registry <strong>VR2+AVR</strong> jsou
dostupné v&nbsp;režimu &bdquo;supervisor&ldquo;, tj.&nbsp;zejména pro loader
jádra a taktéž pro samotné jádro (popř.&nbsp;i pro již zmíněnou obdobu BIOSu,
pokud systém BIOS vyžaduje).</p>

<p>Obsah registru <strong>VR2</strong>:</p>

<table>
<tr><th>Bity</th><th>Označení</th><th>Význam</th></tr>
<tr><td>31-24</td><td>CPUID</td><td>unikátní číslo specifikující konkrétní čip</td></tr>
<tr><td>23-0</td><td>VER</td><td>postupně se zvyšující číslo verze čipu definovaného přes CPUID</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: označením <strong>CPUID</strong> je zde
skutečně myšleno osm bitů, které by mělo jednoznačně identifikovat konkrétní
čip popř.&nbsp;jeho dodavatele. Na platformě x86 je ovšem stejným názvem
<strong>CPUID</strong> označena <a
href="http://www.felixcloutier.com/x86/CPUID.html">strojová instrukce</a>
(s&nbsp;velmi podobným významem). Dolních 24 bitů obsahuje verzi/revizi CPU,
což je více než dostačující rozsah.</div></p>

<p>Obsah registru <strong>AVR</strong>:</p>

<table>
<tr><th>Bity</th><th>Označení</th><th>Význam</th></tr>
<tr><td>31-24</td><td>MAJ</td><td>verze architektury (majoritní číslo před tečkou)</td></tr>
<tr><td>23-16</td><td>MIN</td><td>verze architektury (minoritní číslo za tečkou)</td></tr>
<tr><td>15-8</td><td>REV</td><td>revize (číslo za druhou tečkou)</td></tr>
<tr><td>7-0</td><td>&times;</td><td>rezervováno</td></tr>
</table>

<p>Obsah tohoto registru by měl co nejpřesněji určit, které instrukce jsou
implementovány a jaké je jejich přesné chování. Ovšem aby program nemusel
používat složité tabulky, může namísto toho využít registr
<strong>CPUCFGR</strong> popsaný <a href="#k07">v&nbsp;navazující
kapitole</a>.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Přečtení konkrétních informací o možnostech nabízených mikroprocesorem</h2>

<p>Informace o konkrétních možnostech CPU, na kterém právě běží nějaký program,
se zjistí přečtením registru nazvaného jednoduše <strong>CPUCFGR</strong>.
V&nbsp;tomto 32bitovém registru je prozatím definováno celkem 15 bitů
s&nbsp;následujícím významem:</p>

<table>
<tr><th>Bity</th><th>Označení</th><th>Význam</th></tr>
<tr><td>0..3</td><td>NSGF</td><td>počet tzv.&nbsp;stínových registrů GPR</td></tr>
<tr><td>4</td><td>CGF</td><td>velikost skupiny zákaznických GPR (méně nebo více než 32)</td></tr>
<tr><td>5</td><td>OB32S</td><td>podpora instrukční sady ORBIS32 (tu si popíšeme dnes)</td></tr>
<tr><td>6</td><td>OB64S</td><td>podpora instrukční sady ORBIS64</td></tr>
<tr><td>7</td><td>OF32S</td><td>podpora instrukční sady ORFPX32</td></tr>
<tr><td>8</td><td>OF64S</td><td>podpora instrukční sady ORFPX64</td></tr>
<tr><td>9</td><td>OV64S</td><td>podpora instrukční sady ORVDX64</td></tr>
<tr><td>10</td><td>ND</td><td>indikace, zda se při skocích používá branch delay slot či nikoli</td></tr>
<tr><td>11</td><td>AVRP</td><td>existence registru AVR popsaného výše</td></tr>
<tr><td>12</td><td>EVBARP</td><td>existence registru Exception Vector Base Address</td></tr>
<tr><td>13</td><td>ISRP</td><td>existence registrů implementačně závislých na daném CPU</td></tr>
<tr><td>14</td><td>AECSRP</td><td>existence registru Arithmetic Exception Control</td></tr>
<tr><td>15..31</td><td>&times;</td><td>rezervováno</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Příznakové bity</h2>

<p>V&nbsp;kontextu programátorského modelu je důležitý především registr
nazvaný <strong>SR</strong> (<i>supervision register</i>) patřící do nulté
skupiny a mající index 17. Tento registr obsahuje mimo jiné i tyto tři
jednobitové příznaky:</p>

<table>
<tr><th>#</th><th>Zkratka</th><th>Příznak</th><th>Význam</th></tr>
<tr><td>1</td><td>CY</td><td>carry</td><td>příznak přenosu při aritmetických operacích</td></tr>
<tr><td>2</td><td>OV</td><td>overflow</td><td>příznak přetečení při aritmetických operacích (typ signed)</td></tr>
<tr><td>3</td><td>F</td><td>flag/branch</td><td>příznak použitý pro implementaci podmíněných skoků</td></tr>
</table>

<p>Zajímavé je, že pro podmíněné skoky lze přímo využít jen příznak
<strong>flag</strong> resp.&nbsp;<strong>branch</strong>. Ten je nastavován
některou instrukcí pro porovnání dvou registrů, takže podmíněný skok je
v&nbsp;praxi implementován vždy dvěma instrukcemi. Záleží hlavně na překladači,
jak instrukce přeskládá, aby instrukce podmíněného skoku nemusela čekat na
výsledek porovnání (připomeňme si, že dnešní čipy mají většinou pipeline se
čtyřmi nebo s&nbsp;pěti řezy).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Instrukční sady použité v&nbsp;projektu OpenRISC</h2>

<p>Vzhledem k&nbsp;tomu, že se předpokládá použití mikroprocesorových jader
s&nbsp;architekturou <i>OpenRISC</i> v&nbsp;různých zařízeních, od jednodušších
řídicích systémů (mikrořadiče &ndash; MCU) přes zpracování signálů (DSP) až
například po servery, je instrukční sada OpenRISCu navržena modulárně.
V&nbsp;současnosti existuje pět základních &bdquo;sad&ldquo; instrukcí
s&nbsp;předpokladem, že další sady bude možné navrhnout a implementovat
v&nbsp;budoucnosti. Jediné, s&nbsp;čím se v&nbsp;architektuře <i>OpenRISC</i>
přímo nepočítá (alespoň prozatím), je podpora instrukcí proměnné délky,
tj.&nbsp;obdoby sad <i>Thumb</i> známých z&nbsp;konkurenční architektury
<i>ARM</i> či podobné sady, kterou známe z&nbsp;RISC-V. V&nbsp;následující
tabulce je vypsáno všech pět prozatím oficiálně popsaných sad instrukcí
architektury <i>OpenRISC</i>:</p>

<table>
<tr><th>#</th><th>Zkratka</th><th>Celé jméno</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>ORBIS32</td><td>OpenRISC Basic Instruction Set</td><td>zpracování 32bitových operandů, skoky, podmínky, bitové operace</td></tr>
<tr><td>2</td><td>ORBIS64</td><td>OpenRISC Basic Instruction Set</td><td>rozšíření na 64bitové operandy</td></tr>
<tr><td>3</td><td>ORFPX32</td><td>OpenRISC Floating Point eXtension</td><td>operace s&nbsp;numerickými hodnotami typu float/single (jednoduchá přesnost)</td></tr>
<tr><td>4</td><td>ORFPX64</td><td>OpenRISC Floating Point eXtension</td><td>operace s&nbsp;numerickými hodnotami typu double (dvojitá přesnost)</td></tr>
<tr><td>5</td><td>ORVDX64</td><td>OpenRISC Vector/DSP eXtension</td><td>zpracování hodnot uložených v&nbsp;64bitových vektorech</td></tr>
</table>

<p>Pro vytvoření reálně pracujícího mikroprocesoru postačuje implementovat
pouze první sadu, tj.&nbsp;<strong>ORBIS32</strong>, samozřejmě s&nbsp;tím
omezením, že zpracování 64bitových celých čísel či reálných čísel typu single a
double bude prováděno softwarově (za pomoci subrutin). Základními vlastnostmi
této instrukční sady se budeme zabývat v&nbsp;navazující kapitole.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Formát slov v&nbsp;instrukční sadě ORBIS32</h2>

<p>Základní instrukční sada <strong>ORBIS32</strong> se v&nbsp;několika
ohledech podobá například instrukční sadě mikroprocesorů <i>MIPS</i>. I zde
totiž najdeme instrukce s&nbsp;konstantní šířkou třiceti dvou bitů, které jsou
v&nbsp;operační paměti vždy zarovnány na adresu dělitelnou čtyřmi. Díky tomu se
u skoků nemusí specifikovat nejnižší dva bity adresy či offsetu, neboť tyto
bity jsou vždy nulové. Tak, jako je tomu u <i>MIPS</i>, i zde mají instrukční
slova tři formáty. První formát se označuje písmenem <strong>R</strong> a
používá se pro většinu aritmetických, logických a porovnávacích operací
prováděných se dvěma zdrojovými registry a jedním registrem cílovým. Další
formát se jmenuje <strong>I</strong> a používá se pro instrukce, v&nbsp;nichž
se pracuje se dvěma registry (zdrojový+cílový) a šestnáctibitovou konstantou.
Třetí formát se jmenuje <strong>J</strong> a používá se u skoků, neboť součástí
instrukčního slova je mj.&nbsp;i 26bitová konstanta (to postačuje, neboť
nemusíme specifikovat spodní dva bity).</p>

<p>Formát <strong>R</strong>:</p>

<pre>
  +-----+------+--------+--------+--------+------------------+
  |31 30|29  26| 25  21 | 20  16 | 15  11 | 10             0 |
  +-----+------+--------+--------+--------+------------------+
  |třída|opcode| rD (5) | rA (5) | rB (5) | druhá část opcode|
  +-----+------+--------+--------+--------+------------------+
</pre>

<p><div class="rs-tip-major">Můžeme vidět, že tento formát instrukcí obsahuje
v&nbsp;nejvyšších dvou bitech tzv.&nbsp;třídu instrukce. Následuje operační kód
uložený ve čtyřech bitech, který může být doplněn bity 0 až 10
s&nbsp;doplňujícím kódem. Důležitá je trojice bitových polí rD, rA a rB, které
obsahují indexy pracovních registrů, jenž jsou instrukcí použity. Vidíme, že se
zde využívá takzvaný <i>tříadresový kód</i> se dvěma registry zdrojovými a
jedním registrem cílovým.</div></p>

<p>Formát <strong>I</strong>:</p>

<pre>
  +-----+------+--------+--------+---------------------------+
  |31 30|29  26| 25  21 | 20  16 | 15                      0 |
  +-----+------+--------+--------+---------------------------+
  |třída|opcode| rD (5) | rA (5) | offset/konstanta (16)     |
  +-----+------+--------+--------+---------------------------+
</pre>

<p><div class="rs-tip-major">I v&nbsp;tomto formátu můžeme vidět, že
v&nbsp;nejvyšších dvou bitech je uložena třída instrukce a následuje čtyřbitový
operační kód. Instrukce formátu <strong>I</strong> pracují s&nbsp;dvojicí
registrů specifikovaných v&nbsp;bitových polích rD a rA. Taktéž se specifikuje
šestnáctibitový offset nebo šestnáctibitová konstanta. Podle typu instrukce je
tato konstanta chápána bez znaménka (<i>unsigned</i>) nebo se znaménkem
(<i>signed</i>) a bývá rozšířena na plných 32 či dokonce 64 bitů (opět
v&nbsp;závislosti na tom, o jakou instrukci se jedná).</div></p>

<p>Formát <strong>J</strong>:</p>

<pre>
  +-----+------+---------------------------------------------+
  |31 30|29  26| 25                                        0 |
  +-----+------+---------------------------------------------+
  |třída|opcode| adresa (26)                                 |
  +-----+------+---------------------------------------------+
</pre>

<p><div class="rs-tip-major">Tento formát je nejjednodušší, protože obsahuje
pouze tři bitová pole. Po již známých bitových polích se specifikací třídy
instrukce a operačního kódu následuje adresa, která je zakódována do 26 bitů.
Nejnižší dva bity reálné adresy jsou nulové, protože instrukce jsou zarovnány
na adresy dělitelné čtyřmi. Samotná adresa je zadána buď absolutně nebo
relativně, podle typu instrukce. Relativní adresa se bude vždy vztahovat
k&nbsp;aktuální hodnotě registru <strong>PC</strong> (program
counter).</div></p>

<p>Pro porovnání si ukažme formáty instrukčních slov tak, jak jsou
implementovány na klasickém 32bitovém MIPSu:</p>

<p>Formát <strong>R</strong>:</p>

<pre>
  +------------+--------+--------+--------+-------+----------+
  | 31  26     | 25  21 | 20  16 | 15  11 | 10  6 | 5      0 |
  +------------+--------+--------+--------+-------+----------+
  | opcode (6) | rs (5) | rt (5) | rd (5) | shift | operace  |
  +------------+--------+--------+--------+-------+----------+
</pre>

<p>Formát <strong>I</strong>:</p>

<pre>
  +------------+-----------------+---------------------------+
  | 31  26     | 25  21 | 20  16 | 15                      0 |
  +------------+-----------------+---------------------------+
  | opcode (6) | rs (5) | rt (5) | offset/konstanta (16)     |
  +------------+-----------------+---------------------------+
</pre>

<p>Formát <strong>J</strong>:</p>

<pre>
  +------------+---------------------------------------------+
  | 31  26     | 25                                        0 |
  +------------+---------------------------------------------+
  | opcode (6) | adresa (26)                                 |
  +------------+---------------------------------------------+
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Instrukce v&nbsp;instrukční sadě ORBIS32</h2>

<p>Vzhledem k&nbsp;tomu, že všechny aritmetické a logické operace pracují
s&nbsp;hodnotami uloženými v&nbsp;registrech, je množina instrukcí pro přesuny
dat do a z&nbsp;paměti poměrně malá. <i>OpenRISC</i> podporuje instrukce typu
<strong>load</strong> a <strong>store</strong>, které mohou zpracovávat bajty,
16bitová slova či 32bitová slova. Při načítání bajtů a 16bitových slov se
provádí rozšíření na plných 32 bitů se znaménkem (doplnění podle nejvyššího
bitu načítané hodnoty) či bez znaménka (doplnění nul). To je v&nbsp;mnoha
ohledech praktické, neboť i ty nejmodernější 64bitové mikroprocesory mnohdy
tráví většinu času zpracováním řetězců.</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>l.extbs</td><td>znaménkové rozšíření bajtu na 32bitové slovo</td></tr>
<tr><td>2</td><td>l.extbz</td><td>bezznaménkové rozšíření bajtu na 32bitové slovo</td></tr>
<tr><td>3</td><td>l.exths</td><td>znaménkové rozšíření 16bitového slova na 32bitové slovo</td></tr>
<tr><td>4</td><td>l.exthz</td><td>bezznaménkové rozšíření 16bitového slova na 32bitové slovo</td></tr>
<tr><td>5</td><td>l.extws</td><td>pouhý přesun dat (32bit) nebo rozšíření 32bit na 64bit</td></tr>
<tr><td>6</td><td>l.extwz</td><td>pouhý přesun dat (32bit) nebo rozšíření 32bit na 64bit</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>l.lbs</td><td>načtení bajtu z&nbsp;operační paměti se znaménkovým rozšířením</td></tr>
<tr><td>8</td><td>l.lbz</td><td>načtení bajtu z&nbsp;operační paměti s&nbsp;bezznaménkovým rozšířením</td></tr>
<tr><td>9</td><td>l.lhs</td><td>načtení 16bitového slova se znaménkovým rozšířením</td></tr>
<tr><td>10</td><td>l.lhz</td><td>načtení 16bitového slova s&nbsp;bezznaménkovým rozšířením</td></tr>
<tr><td>11</td><td>l.ld</td><td>načtení dvouslova (jen 64bitová CPU)</td></tr>
<tr><td>12</td><td>l.lwa</td><td>atomické načtení slova</td></tr>
<tr><td>13</td><td>l.lws</td><td>načtení slova se znaménkovým rozšířením</td></tr>
<tr><td>14</td><td>l.lwz</td><td>načtení slova s&nbsp;bezznaménkovým rozšířením</td></tr>
<tr><td>15</td><td>l.movhi</td><td>načtení 16bitové konstanty a její uložení do horních 16bitů registru</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>l.sb</td><td>uložení bajtu</td></tr>
<tr><td>17</td><td>l.sh</td><td>uložení 16bitového slova</td></tr>
<tr><td>18</td><td>l.sw</td><td>uložení 32bitového slova</td></tr>
<tr><td>19</td><td>l.swa</td><td>atomické uložení 32bitového slova</td></tr>
<tr><td>20</td><td>l.sd</td><td>uložení dvouslova (jen 64bitová CPU)</td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Aritmetické a logické instrukce</h2>

<p>Mezi aritmetickými instrukcemi najdeme například sčítání s&nbsp;carry či bez
carry, násobení a dělení (se znaménkem či bez znaménka), operace typu
&bdquo;multiply and accumulate&ldquo; a &bdquo;multiply and subtract&ldquo; a
dokonce instrukce <strong>ff1</strong> (find first 1) a <strong>fl1</strong>
(find last 1). Už na tomto krátkém výčtu je patrné, že instrukční sada je
poměrně rozsáhlá a implementace &bdquo;na křemíku&ldquo; patřičně komplikovaná
(měřeno plochou čipu).</p>

<p>Základní aritmetické instrukce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>l.add</td><td>součet registrů</td></tr>
<tr><td>2</td><td>l.addc</td><td>součet (s&nbsp;dalším přičtením přenosu)</td></tr>
<tr><td>3</td><td>l.addi</td><td>přičtení konstanty</td></tr>
<tr><td>4</td><td>l.addic</td><td>přičtení konstanty (s&nbsp;dalším přičtením přenosu)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>l.sub</td><td></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>l.mul</td><td>násobení (se znaménkem)</td></tr>
<tr><td>7</td><td>l.mulu</td><td>násobení (bez znaménka)</td></tr>
<tr><td>8</td><td>l.muli</td><td>násobení konstantou (se znaménkem)</td></tr>
<tr><td>9</td><td>l.muld</td><td>násobení s&nbsp;přesunem výsledku do MAC</td></tr>
<tr><td>10</td><td>l.muldu</td><td>násobení s&nbsp;přesunem výsledku do MAC</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>l.div</td><td>celočíselné dělení (se znaménkem)</td></tr>
<tr><td>12</td><td>l.divu</td><td>celočíselné dělení (bez znaménka)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>l.ff1</td><td>nalezení první jedničky ve slově</td></tr>
<tr><td>14</td><td>l.fl1</td><td>nalezení poslední jedničky ve slově</td></tr>
</table>

<p>Logické instrukce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>l.and</td><td>logický součin bit po bitu</td></tr>
<tr><td>2</td><td>l.andi</td><td>logický součin registru s&nbsp;konstantou</td></tr>
<tr><td>3</td><td>l.or</td><td>logický součet bit po bitu</td></tr>
<tr><td>4</td><td>l.ori</td><td>logický součet registru s&nbsp;konstantou</td></tr>
<tr><td>5</td><td>l.xor</td><td>logická nonekvivalence bit po bitu</td></tr>
<tr><td>6</td><td>l.xori</td><td>logická nonekvivalence registru s&nbsp;konstantou</td></tr>
</table>

<p>Logické posuny a rotace:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>l.ror</td><td>rotace doprava</td></tr>
<tr><td>2</td><td>l.rori</td><td>rotace doprava o konstantu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>l.sll</td><td>logický posun doleva</td></tr>
<tr><td>4</td><td>l.slli</td><td>logický posun doleva o konstantu</td></tr>
<tr><td>5</td><td>l.srl</td><td>logický posun doprava</td></tr>
<tr><td>6</td><td>l.srli</td><td>logický posun doprava o konstantu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>l.sra</td><td>aritmetický posun doprava</td></tr>
<tr><td>8</td><td>l.srai</td><td>aritmetický posun doprava o konstantu</td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Příznakový bit <strong>F</strong> a instrukce pro práci s&nbsp;ním</h2>

<p>Za zmínku stojí taktéž instrukce začínající prefixem <strong>sf</strong>.
Tyto instrukce nastavují příznakový bit <strong>branch/F</strong> na základě
výsledku porovnání dvou registrů či porovnání registru s&nbsp;šestnáctibitovou
konstantou. Hodnota příznakového bitu je následně využita v&nbsp;podmíněném
skoku. Příkladem může být instrukce <strong>sfeq</strong> nastavující
<strong>F&larr;1</strong> jen tehdy, pokud mají oba registry shodnou hodnotu.
Nezapomeňme navíc na registr <strong>r0</strong> s&nbsp;&bdquo;trvalou
nulou&ldquo;, díky jehož existenci automaticky získáváme instrukce
<strong>sfzero</strong>. Alternativou k&nbsp;<strong>sfeq</strong> je instrukce
<strong>sfeqi</strong> pro porovnání registru s&nbsp;konstantou. Existují i
další alternativy, kde se namísto &bdquo;eq&ldquo; používá &bdquo;gt&ldquo;
(větší než), &bdquo;ge&ldquo; (větší nebo rovno) atd.</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td> 1</td><td>l.sfeq</td><td>nastavení F po porovnání dvou registrů na rovnost</td></tr>
<tr><td> 2</td><td>l.sfeqi</td><td>nastavení F po porovnání registru s&nbsp;konstantou na rovnost</td></tr>
<tr><td> 3</td><td>l.sfges</td><td>porovnání na relaci &bdquo;větší nebo rovno&ldquo; (se znaménkem)</td></tr>
<tr><td> 4</td><td>l.sfgesi</td><td>porovnání na relaci &bdquo;větší nebo rovno&ldquo; (se znaménkem)</td></tr>
<tr><td> 5</td><td>l.sfgeu</td><td>porovnání na relaci &bdquo;větší nebo rovno&ldquo; (bez znaménka)</td></tr>
<tr><td> 6</td><td>l.sfgeui</td><td>porovnání na relaci &bdquo;větší nebo rovno&ldquo; (bez znaménka)</td></tr>
<tr><td> 7</td><td>l.sfgts</td><td>porovnání na relaci &bdquo;větší než&ldquo; (se znaménkem)</td></tr>
<tr><td> 8</td><td>l.sfgtsi</td><td>porovnání na relaci &bdquo;větší než&ldquo; (se znaménkem)</td></tr>
<tr><td> 9</td><td>l.sfgtu</td><td>porovnání na relaci &bdquo;větší než&ldquo; (bez znaménka)</td></tr>
<tr><td>10</td><td>l.sfgtui</td><td>porovnání na relaci &bdquo;větší než&ldquo; (bez znaménka)</td></tr>
<tr><td>11</td><td>l.sfles</td><td>porovnání na relaci &bdquo;menší nebo rovno&ldquo; (se znaménkem)</td></tr>
<tr><td>12</td><td>l.sflesi</td><td>porovnání na relaci &bdquo;menší nebo rovno&ldquo; (se znaménkem)</td></tr>
<tr><td>13</td><td>l.sfleu</td><td>porovnání na relaci &bdquo;menší nebo rovno&ldquo; (bez znaménka)</td></tr>
<tr><td>14</td><td>l.sfleui</td><td>porovnání na relaci &bdquo;menší nebo rovno&ldquo; (bez znaménka)</td></tr>
<tr><td>15</td><td>l.sflts</td><td>porovnání na relaci &bdquo;menší než&ldquo; (se znaménkem)</td></tr>
<tr><td>16</td><td>l.sfltsi</td><td>porovnání na relaci &bdquo;menší než&ldquo; (se znaménkem)</td></tr>
<tr><td>17</td><td>l.sfltu </td><td>porovnání na relaci &bdquo;menší než&ldquo; (bez znaménka)</td></tr>
<tr><td>18</td><td>l.sfltui</td><td>porovnání na relaci &bdquo;menší než&ldquo; (bez znaménka)</td></tr>
<tr><td>19</td><td>l.sfne</td><td>nastavení F po porovnání dvou registrů na nerovnost</td></tr>
<tr><td>20</td><td>l.sfnei</td><td>nastavení F po porovnání registru s&nbsp;konstantou na nerovnost</td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Instrukce podmíněných i nepodmíněných skoků</a></h2>

<p>Formát skokových instrukcí jsme si již popsali, takže si jen připomeňme, že
tyto instrukce používají 26bitovou adresu, která je buď absolutní nebo
relativní. Podmíněné skoky využívají příznak <strong>F</strong> zmíněný <a
href="#k13">ve třinácté kapitole</a>. Mezi skokové instrukce patří zejména:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>l.j</td><td>běžný skok na adresu PC+konstanta</td></tr>
<tr><td>2</td><td>l.jal</td><td>skok na adresu PC+konstanta, návratová adresa se uloží do registru r9</td></tr>
<tr><td>3</td><td>l.jr</td><td>skok na adresu uloženou ve specifikovaném registru</td></tr>
<tr><td>4</td><td>l.jalr</td><td>kombinace jal+jr (skok na adresu v&nbsp;registru, návratová adresa &rarr; r9)</td></tr>
<tr><td>5</td><td>l.bf</td><td>skok na PC+konstanta pokud je <strong>F</strong> nastaven</td></tr>
<tr><td>6</td><td>l.bnf</td><td>skok na PC+konstanta pokud je <strong>F</strong> vynulován</td></tr>
<tr><td>7</td><td>l.rfe</td><td>návrat z&nbsp;obsluhy výjimky</td></tr>
</table>

<p>Poslední instrukcí, o níž se v&nbsp;této kapitole zmíníme, je instrukce
<strong>l.cmov</strong> používající taktéž tříadresový kód (indexy tří
registrů).  Tato instrukce může v&nbsp;některých případech nahradit podmíněné
skoky:</p>

<ol>
<li>Pokud je F==1, proveď <strong>mov D,A</strong></li>
<li>Pokud je F==0, proveď <strong>mov D,B</strong></li>
</ol>



<p><a name="k15"></a></p>
<h2 id="k15">15. Jednotka MAC</h2>

<p>Čipy s&nbsp;architekturou OpenRISC mohou obsahovat i jednotku MAC
provádějící operace označované stejně: MAC neboli Multiply-Accumulate. Jedná se
o základní operace používané při zpracování signálů. Pokud je jednotka MAC
skutečně implementována (zjistíme z&nbsp;registru <strong>UPR</strong>), bude
k&nbsp;dispozici těchto šest specializovaných instrukcí:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>l.mac  </td><td>operace MAC (se znaménkem)</td></tr>
<tr><td>2</td><td>l.macu </td><td>operace MAC (bez znaménka)</td></tr>
<tr><td>3</td><td>l.maci </td><td>operace MAC s&nbsp;konstantou</td></tr>
<tr><td>3</td><td>l.macrc</td><td>operace MAC s&nbsp;přenosem výsledku do pracovních registrů a vymazáním MAC registrů</td></tr>
<tr><td>5</td><td>l.msb  </td><td>operace multiply-subtract (se znaménkem)</td></tr>
<tr><td>6</td><td>l.msbu </td><td>operace multiply-subtract (bez znaménka)</td></tr>
</table>

<p>Jednotka MAC používá vlastní dva registry nazvané <strong>MACHI</strong> a
<strong>MACLO</strong>, do nichž se ukládají mezivýsledky. To je důležité,
protože takto může MAC pracovat nezávisle na zbytku CPU a v&nbsp;průběhu
výpočtu je tedy možné například vyhodnocovat adresy dalších operandů atd.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Branch delay sloty</h2>

<p>Pro některé RISCové procesory (jmenujme například asi nejtypičtější MIPS,
PA-RISC či SPARC) je poměrně obvyklé taktéž použití technologie takzvaných
<i>branch delay slotů</i>, kterou můžeme najít i u zde popisovaných čipů
s&nbsp;architekturou OpenRISC. Tyto čipy totiž mohou být navrženy tak, aby
obsahovaly jeden delay slot, což znamená, že instrukce uložená ihned za
instrukcí podmíněného či nepodmíněného skoku bude vykonána vždy, bez ohledu na
výsledek skoku (zda se provede či neprovede). Díky existenci této technologie
se může lépe využít instrukční pipeline, neboť pipeline není nutno celou
vyprazdňovat po každém skoku, což znamená zdržení až čtyři takty
v&nbsp;závislosti na konkrétních možnostech pipeline. Použití branch delay
slotů je sice na první pohled poměrně jednoduché (ostatně většinu práce odvede
překladač), ovšem může způsobit problémy ve chvíli, kdy dojde k&nbsp;výjimce
v&nbsp;instrukci umístěné do delay slotu; navíc ještě záleží na tom, zda
výjimka nastane už při dekódování instrukce nebo později. U OpenRISC lze
existenci branch delay slotů zjistit přečtením bitu <strong>ND</strong>
z&nbsp;registru <strong>CPUCFGR</strong>.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Seznam všech instrukcí v&nbsp;sadě ORBIS32</h2>

<p>V&nbsp;následující tabulce jsou vypsány všechny instrukce, které jsou
v&nbsp;současnosti součástí specifikace instrukční sady ORBIS32:</p>

<table>
<tr><th>Instrukce</th><th>Instrukce</th><th>Instrukce</th><th>Instrukce</th><th>Instrukce</th></tr>
<tr><td>l.add  </td><td>l.j    </td><td>l.mtspr</td><td>l.sfgesi</td><td>l.sra </td></tr>
<tr><td>l.addc </td><td>l.jal  </td><td>l.msync</td><td>l.sfgeu </td><td>l.srai</td></tr>
<tr><td>l.addi </td><td>l.jalr </td><td>l.mtspr</td><td>l.sfgeui</td><td>l.srl </td></tr>
<tr><td>l.addic</td><td>l.jr   </td><td>l.mul  </td><td>l.sfgts </td><td>l.srli</td></tr>
<tr><td>l.and  </td><td>l.lbs  </td><td>l.muld </td><td>l.sfgtsi</td><td>l.sub </td></tr>
<tr><td>l.andi </td><td>l.lbz  </td><td>l.muldu</td><td>l.sfgtu </td><td>l.sw  </td></tr>
<tr><td>l.bf   </td><td>l.ld   </td><td>l.muli </td><td>l.sfgtui</td><td>l.swa </td></tr>
<tr><td>l.bnf  </td><td>l.lhs  </td><td>l.mulu </td><td>l.sfles </td><td>l.sys </td></tr>
<tr><td>l.cmov </td><td>l.lhz  </td><td>l.nop  </td><td>l.sflesi</td><td>l.trap</td></tr>
<tr><td>l.csync</td><td>l.lwa  </td><td>l.or   </td><td>l.sfleu </td><td>l.xor </td></tr>
<tr><td>l.div  </td><td>l.lws  </td><td>l.ori  </td><td>l.sfleui</td><td>l.xori</td></tr>
<tr><td>l.divu </td><td>l.lwz  </td><td>l.psync</td><td>l.sflts </td><td>&nbsp;</td></tr>
<tr><td>l.extbs</td><td>l.mac  </td><td>l.rfe  </td><td>l.sfltsi</td><td>&nbsp;</td></tr>
<tr><td>l.extbz</td><td>l.maci </td><td>l.ror  </td><td>l.sfltu </td><td>&nbsp;</td></tr>
<tr><td>l.exths</td><td>l.macrc</td><td>l.rori </td><td>l.sfltui</td><td>&nbsp;</td></tr>
<tr><td>l.exthz</td><td>l.macu </td><td>l.sb   </td><td>l.sfne  </td><td>&nbsp;</td></tr>
<tr><td>l.extws</td><td>l.mfspr</td><td>l.sd   </td><td>l.sfnei </td><td>&nbsp;</td></tr>
<tr><td>l.extwz</td><td>l.movhi</td><td>l.sfeq </td><td>l.sh    </td><td>&nbsp;</td></tr>
<tr><td>l.ff1  </td><td>l.msb  </td><td>l.sfeqi</td><td>l.sll   </td><td>&nbsp;</td></tr>
<tr><td>l.fl1  </td><td>l.msbu </td><td>l.sfges</td><td>l.slli  </td><td>&nbsp;</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti není nutné, aby byly na
CPU implementovány všechny instrukce vypsané v&nbsp;předchozí tabulce. Pouze
musí být zaručeno, že jsou implementovány instrukce spadající do první skupiny
(group I).</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah pokračování článku</h2>

<p>V&nbsp;navazující části tohoto článku si popíšeme referenční architekturu
nazvanou <i>ORPSoC</i> neboli <i>OpenRISC Reference Platform System on
Chip</i>. Dále se zmíníme o dalších instrukčních sadách, zejména o instrukcích
určených pro matematický koprocesor a pro DSP. Nezapomeneme ani na poměrně
zajímavý projekt &ndash; menší 16bitový procesor založený na podobných
principech jako OpenRISC.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na Internetu</h2>

<ol>

<li>OpenRISC (oficiální stránky)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>OpenRISC System-on-Chip Design Emulation<br />
<a href="https://arxiv.org/pdf/1602.03095.pdf">https://arxiv.org/pdf/1602.03095.pdf</a>
</li>

<li>Open cores<br />
<a href="https://opencores.org/">https://opencores.org/</a>
</li>

<li>Projekt OpenRISC 2000<br />
<a href="https://opencores.org/project/or2k">https://opencores.org/project/or2k</a>
</li>

<li>OpenRISC na GitHubu<br />
<a href="https://github.com/openrisc">https://github.com/openrisc</a>
</li>

<li>OpenRISC 1200<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC_1200">https://en.wikipedia.org/wiki/OpenRISC_1200</a>
</li>

<li>OpenRISC 1200 IP Core Specification (Preliminary Draft)<br />
<a href="https://opencores.org/ocsvn/openrisc/openrisc/trunk/or1200/doc/openrisc1200_spec.pdf">https://opencores.org/ocsvn/openrisc/openrisc/trunk/or1200/doc/openrisc1200_spec.pdf</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>Maska mikroprocesoru RISC 1<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg</a>
</li>

<li>Maska mikroprocesoru RISC 2<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg</a>
</li>

<li>C.E. Sequin and D.A.Patterson: Design and Implementation of RISC I<br />
<a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf">http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>SPARC Processor Family Photo<br />
<a href="http://thenetworkisthecomputer.com/site/?p=243">http://thenetworkisthecomputer.com/site/?p=243</a>
</li>

<li>SPARC: Decades of Continuous Technical Innovation<br />
<a href="http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical">http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical</a>
</li>

<li>The SPARC processors<br />
<a href="http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors">http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors</a>
</li>

<li>Reduced instruction set computing (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Reduced_instruction_set_computer">http://en.wikipedia.org/wiki/Reduced_instruction_set_computer</a>
</li>

<li>MIPS architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MIPS_architecture">http://en.wikipedia.org/wiki/MIPS_architecture</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>Classic RISC pipeline (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Classic_RISC_pipeline">http://en.wikipedia.org/wiki/Classic_RISC_pipeline</a>
</li>

<li>R2000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R2000_(microprocessor)">http://en.wikipedia.org/wiki/R2000_(microprocessor)</a>
</li>

<li>R3000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R3000">http://en.wikipedia.org/wiki/R3000</a>
</li>

<li>R4400 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R4400">http://en.wikipedia.org/wiki/R4400</a>
</li>

<li>R8000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R8000">http://en.wikipedia.org/wiki/R8000</a>
</li>

<li>R10000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R10000">http://en.wikipedia.org/wiki/R10000</a>
</li>

<li>SPARC (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Sparc">http://en.wikipedia.org/wiki/Sparc</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Control unit (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Control_unit">http://en.wikipedia.org/wiki/Control_unit</a>
</li>

<li>CPUID na x86-64<br />
<a href="http://www.felixcloutier.com/x86/CPUID.html">http://www.felixcloutier.com/x86/CPUID.html</a>
</li>

<li>Endianness<br />
<a href="https://en.wikipedia.org/wiki/Endianness">https://en.wikipedia.org/wiki/Endianness</a>
</li>

<li>Otevřené RISCové architektury OpenRISC a RISC-V<br />
<a href="https://www.root.cz/clanky/otevrene-riscove-architektury-openrisc-a-risc-v/">https://www.root.cz/clanky/otevrene-riscove-architektury-openrisc-a-risc-v/</a>
</li>

<li>Instrukční sada procesorových jader s otevřenou architekturou RISC-V<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-procesorovych-jader-s-otevrenou-architekturou-risc-v/">https://www.root.cz/clanky/instrukcni-sada-procesorovych-jader-s-otevrenou-architekturou-risc-v/</a>
</li>

<li>Rozšíření instrukční sady procesorových jader s otevřenou architekturou RISC-V<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v/</a>
</li>

<li>Instrukční sady procesorových jader s otevřenou architekturou RISC-V (dokončení)<br />
<a href="https://www.root.cz/clanky/instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v-dokonceni/">https://www.root.cz/clanky/instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v-dokonceni/</a>
</li>

<li>RISCové mikroprocesory s komprimovanými instrukčními sadami<br />
<a href="https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami/">https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami/</a>
</li>

<li>RISCové mikroprocesory s komprimovanými instrukčními sadami (2)<br />
<a href="https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami-2/">https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami-2/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

