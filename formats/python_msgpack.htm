<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Využití serializačního formátu MessagePack v Pythonu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Využití serializačního formátu MessagePack v Pythonu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Se serializačním formátem nazvaným MessagePack jsme se již na stránkách Roota jednou setkali. Dnes si ukážeme, jak se tento formát používá v jazyku Python, a to včetně serializace N-dimenzionálních polí knihovny NumPy.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Využití serializačního formátu MessagePack v&nbsp;Pythonu</a></p>
<p><a href="#k02">2. Formát <i>MessagePack</i></a></p>
<p><a href="#k03">3. Některá omezení formátu <i>MessagePack</i></a></p>
<p><a href="#k04">4. Instalace balíčku <strong>msgpack</strong> i balíčku pro serializaci N-dimenzionálních polí</a></p>
<p><a href="#k05">5. Prohlížení binárních souborů se serializovanými daty</a></p>
<p><a href="#k06">6. Serializace primitivních datových typů do formátu <i>MessagePack</i></a></p>
<p><a href="#k07">7. Hodnota <strong>nil</strong> resp.&nbsp;<strong>None</strong></a></p>
<p><a href="#k08">8. Serializace pravdivostních hodnot <strong>True</strong> a <strong>False</strong></a></p>
<p><a href="#k09">9. Serializace celočíselných hodnot</a></p>
<p><a href="#k10">10. Celočíselné hodnoty překračující 64bitový rozsah</a></p>
<p><a href="#k11">11. Serializace hodnot s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k12">12. Složené datové typy ve formátu MessagePack</a></p>
<p><a href="#k13">13. Krátké a dlouhé řetězce</a></p>
<p><a href="#k14">14. Malá a rozsáhlá pole</a></p>
<p><a href="#k15">15. Serializace map</a></p>
<p><a href="#k16">16. Serializace N-dimenzionálních polí</a></p>
<p><a href="#k17">*** 17. Serializace 1D polí z&nbsp;balíčku NumPy</a></p>
<p><a href="#k18">18. Příloha: alternativní binární formáty pro serializaci dat</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Využití serializačního formátu MessagePack v&nbsp;Pythonu</h2>

<p>Se serializačním formátem nazvaným <i>MessagePack</i> jsme se již na
stránkách Roota jednou setkali, a to konkrétně v&nbsp;souvislosti <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">s&nbsp;programovacím
jazykem Go</a>. Připomeňme si ve stručnosti, že se v&nbsp;současnosti jedná o
jeden z&nbsp;relativně velkého množství dostupných a používaných datových
formátů určených pro serializaci a deserializaci dat různých typů s&nbsp;jejich
případným přenosem do jiné aplikace či služby (poté se spíše setkáme
s&nbsp;termíny <i>marshalling</i> a <i>unmarshalling</i>). Přenosem se přitom
v&nbsp;tomto kontextu myslí jak lokální komunikace, tak i přenos do služby
běžící na jiném počítači.</p>

<p>Již dříve jsme se ve stručnosti seznámili s&nbsp;využitím známého formátu
<i>JSON</i> (ten se používá a někdy i zneužívá na mnoha místech) a nepřímo
taktéž s&nbsp;formátem <i>TOML</i> používaným typicky pro konfigurační soubory
(a mnohem méně často pro rozsáhlejší data). V&nbsp;případě JSONu se jedná o
poměrně důležitý formát, protože JSON (a samozřejmě též XML) se
v&nbsp;současnosti používá v&nbsp;mnoha webových službách a i když stále
vznikají a jsou postupně adaptovány další formáty, ať již textové (<a
href="https://yaml.org/">YAML</a>, <a
href="https://github.com/edn-format/edn">edn</a>) či binární (<a
href="http://bsonspec.org/">BSON</a>, <a href="http://bjson.org/">B-JSON</a>,
<a href="https://github.com/FasterXML/smile-format-specification">Smile</a>, <a
href="https://developers.google.com/protocol-buffers/">Protocol-Buffers</a>),
<a href="https://github.com/fxamacker/cbor">CBOR</a> atd., je velmi
pravděpodobné, že se JSON bude i nadále poměrně masivně využívat (a navíc pro
něj existují užitečné nástroje typu <a
href="https://www.root.cz/clanky/zpracovani-dat-reprezentovanych-ve-formatu-json-nastrojem-jq/">jq</a>).
Nicméně pochopitelně existují situace, v&nbsp;nichž je vhodné textový a
relativně neúsporný JSON nahradit právě nějakým binárním formátem.</p>

<p>I přesto, že se s&nbsp;výše uvedenými formáty JSON a XML setkáme prakticky
ve všech oblastech moderního IT, nemusí se vždy jednat o to nejlepší možné
řešení problému přenosu strukturovaných dat. Tyto formáty totiž data neukládají
v&nbsp;kompaktní binární podobě a navíc je parsing numerických hodnot relativně
zdlouhavý, což se projevuje zejména tehdy, pokud je nutné zpracovat skutečně
obrovské množství dat (buď se tedy jedná o situaci, kdy je nutné zpracovat
mnoho malých zpráv či událostí, nebo naopak rozsáhlé datové soubory). A právě
v&nbsp;těchto situacích může být výhodnější sáhnout po nějakém vhodně navrženém
binárním formátu, ideálně takovém formátu, který je popsán ve standardu a který
je implementován pro více jazyků či ekosystémů. Takových úsporných formátů již
dnes existuje velké množství, od staršího a dosti těžkopádného ASN.1
(<i>Abstract Syntax Notation One</i>) po formáty, které se snaží napodobit
některé vlastnosti JSONu. Příkladem z&nbsp;této oblasti může být formát
<i>CBOR</i>, jenž je mj.&nbsp;podporován knihovnou <a
href="https://github.com/fxamacker/cbor">https://github.com/fxamacker/cbor</a>,
popř.&nbsp;formát <i>BSON</i>. A konečně, ve se především ve světě Go setkáme i
s&nbsp;formátem nazvaným <i>gob</i> neboli <i>Go Objects</i>.</p>

<p>Jednou ze známých a relativně často nasazovaných &bdquo;binárních
alternativ&ldquo; k&nbsp;formátu JSON je i formát nazvaný <i>MessagePack</i>,
s&nbsp;jehož základními vlastnostmi se seznámíme v&nbsp;navazujících
kapitolách. Zaměříme se přitom na jeho použití v&nbsp;Pythonu, což s&nbsp;sebou
nese určité specifické vlastnosti, které vyplývají z&nbsp;typového systému
Pythonu (konkrétně z&nbsp;toho, že existuje celočíselný typ s&nbsp;neomezeným
rozsahem či jediný numerický formát s&nbsp;plovoucí řádovou čárkou).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Formát <i>MessagePack</i></h2>

<p>Datový formát <i>MessagePack</i> je navržen takovým způsobem, aby byl
&bdquo;binárním protějškem&ldquo; známého a velmi často využívaného formátu
JSON, ovšem s&nbsp;několika vylepšeními. Binární formát <i>MessagePack</i>
umožňuje serializovat (ukládat) následující datové typy a pochopitelně i jejich
kombinace, protože je vhodné si uvědomit, že mnohé datové typy jsou vlastně
kontejnery pro hodnoty dalších typů (v&nbsp;MessagePacku se takto používají
pole a taktéž mapy):</p>

<ol>

<li>Hodnotu <strong>nil</strong> odpovídající v&nbsp;JSONu hodnotě
<strong>null</strong>. Tato hodnota je uložena v&nbsp;jediném bajtu, včetně
typové informace.</li>

<li>Pravdivostní hodnoty <strong>true</strong> a <strong>false</strong>. Opět
je použit úsporný způsob uložení v&nbsp;jediném bajtu.</li>

<li>Celá čísla (<i>integer</i>) s&nbsp;různou binární délkou. Malé hodnoty,
s&nbsp;nimiž se setkáme nejčastěji, jsou uloženy v&nbsp;optimalizované (kratší)
podobě. Jedná se o rozšíření oproti formátu JSON, který celá čísla
nepodporuje.</li>

<li>Čísla s&nbsp;plovoucí řádovou čárkou v&nbsp;jednoduché i dvojité přesnosti,
a to (to je pro mnoho aplikací důležité) včetně všech speciálních hodnot, tedy
kladného a záporného nekonečna i hodnoty &bdquo;Not a Number&ldquo;.</li>

<li>Unicode řetězce, přičemž krátké řetězce jsou opět uloženy optimalizovaně.</li>

<li>Sekvence bajtů, což je typ, který nám umožňuje například serializaci
obrázků atd.</li>

<li>Pole, jejichž prvky jsou prakticky jakéhokoli typu.</li>

<li>Mapy, jejichž klíče i prvky jsou prakticky jakéhokoli typu (v&nbsp;tomto
případě se jedná o rozšíření JSONu).</li>

<li>Časová razítka. To je v&nbsp;praxi poměrně užitečný formát. JSON tuto
možnost postrádá a proto se setkáme s&nbsp;mnoha různými způsoby uložení
časových razítek (mnohé jsou navrženy špatně).</li>

<li>Rozšíření (dvojice s&nbsp;typovou informací a hodnotou). Takto lze
MessagePack rozšířit například o komplexní čísla, vektory atd. Podpora však
musí existovat na obou komunikujících stranách!</li>

</ol>

<p>Důležité přitom je, že způsob uložení dat určuje nejenom jejich hodnotu, ale
i typ, takže přijímající strana získá například informaci &bdquo;toto je
hodnota False typu boolean&ldquo; nebo &bdquo;toto je celé číslo
s&nbsp;hodnotou 42&ldquo;. Naproti tomu však nezískáme jméno příslušného
atributu, takže obě komunikující strany musí mít (shodnou) informaci o tom,
jaké datové struktury se přenáší a/nebo serializují, nebo je nutné použít mapu
(což je nejčastější způsob).</p>

<p>Již z&nbsp;prvního bajtu každé serializované hodnoty lze určit její typ. Jak
je to zařízeno je patrné z&nbsp;následující tabulky. Povšimněte si, že u mnoha
typů je v&nbsp;prvním bajtu typ uložen jen v&nbsp;několika bitech a další bity
tak lze využit i pro (částečné) uložení hodnoty:</p>

<table>
<tr><th>Datový typ</th><td>hodnota prvního bajtu (bin)</td><td>hodnota prvního bajtu (hex)</td></tr>
<tr><td>positive fixint</td><td>0xxxxxxx</td><td>0x00 - 0x7f</td></tr>
<tr><td>fixmap</td><td>1000xxxx</td><td>0x80 - 0x8f</td></tr>
<tr><td>fixarray</td><td>1001xxxx</td><td>0x90 - 0x9f</td></tr>
<tr><td>fixstr</td><td>101xxxxx</td><td>0xa0 - 0xbf</td></tr>
<tr><td>nil (null, None)</td><td>11000000</td><td>0xc0</td></tr>
<tr><td>(není použit)</td><td>11000001</td><td>0xc1</td></tr>
<tr><td>false</td><td>11000010</td><td>0xc2</td></tr>
<tr><td>true</td><td>11000011</td><td>0xc3</td></tr>
<tr><td>bin 8</td><td>11000100</td><td>0xc4</td></tr>
<tr><td>bin 16</td><td>11000101</td><td>0xc5</td></tr>
<tr><td>bin 32</td><td>11000110</td><td>0xc6</td></tr>
<tr><td>ext 8</td><td>11000111</td><td>0xc7</td></tr>
<tr><td>ext 16</td><td>11001000</td><td>0xc8</td></tr>
<tr><td>ext 32</td><td>11001001</td><td>0xc9</td></tr>
<tr><td>float 32</td><td>11001010</td><td>0xca</td></tr>
<tr><td>float 64</td><td>11001011</td><td>0xcb</td></tr>
<tr><td>uint 8</td><td>11001100</td><td>0xcc</td></tr>
<tr><td>uint 16</td><td>11001101</td><td>0xcd</td></tr>
<tr><td>uint 32</td><td>11001110</td><td>0xce</td></tr>
<tr><td>uint 64</td><td>11001111</td><td>0xcf</td></tr>
<tr><td>int 8</td><td>11010000</td><td>0xd0</td></tr>
<tr><td>int 16</td><td>11010001</td><td>0xd1</td></tr>
<tr><td>int 32</td><td>11010010</td><td>0xd2</td></tr>
<tr><td>int 64</td><td>11010011</td><td>0xd3</td></tr>
<tr><td>fixext 1</td><td>11010100</td><td>0xd4</td></tr>
<tr><td>fixext 2</td><td>11010101</td><td>0xd5</td></tr>
<tr><td>fixext 4</td><td>11010110</td><td>0xd6</td></tr>
<tr><td>fixext 8</td><td>11010111</td><td>0xd7</td></tr>
<tr><td>fixext 16</td><td>11011000</td><td>0xd8</td></tr>
<tr><td>str 8</td><td>11011001</td><td>0xd9</td></tr>
<tr><td>str 16</td><td>11011010</td><td>0xda</td></tr>
<tr><td>str 32</td><td>11011011</td><td>0xdb</td></tr>
<tr><td>array 16</td><td>11011100</td><td>0xdc</td></tr>
<tr><td>array 32</td><td>11011101</td><td>0xdd</td></tr>
<tr><td>map 16</td><td>11011110</td><td>0xde</td></tr>
<tr><td>map 32</td><td>11011111</td><td>0xdf</td></tr>
<tr><td>negative fixint</td><td>111xxxxx</td><td>0xe0 - 0xff</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Některá omezení formátu <i>MessagePack</i></h2>

<p>Možnosti binárního formátu <i>MessagePack</i>, kterým se v&nbsp;dnešním
článku zabýváme, skutečně do značné míry odpovídají možnostem JSONu
s&nbsp;několika rozšířeními, o nichž jsme se zmínili výše a s&nbsp;nimiž se
ještě setkáme v&nbsp;demonstračních příkladech v&nbsp;praktické části článku.
Ovšem musíme se zmínit i o některých principiálních omezeních, z&nbsp;nichž
některé jsou společné i dalším často používaným serializačním formátům (nehledě
na to, zda jsou textové či binární):</p>

<ol>

<li>celá čísla mohou nabývat hodnoty z&nbsp;rozsahu -2<sup>63</sup> až
2<sup>64</sup>-1 (to není chyba &ndash; pro kladné hodnoty totiž
v&nbsp;MessagePacku existuje typ bez znaménka, tedy <i>unsigned int</i>).
Rozsah je zde tedy mnohem větší, než v&nbsp;případě JSONu, kde je nutné
pracovat s&nbsp;typem <i>double</i>.</li>

<li>maximální délka řetězců je rovna 4GB (což v&nbsp;praxi pravděpodobně nebude
příliš velké omezení)</li>

<li>maximální délka binárního bloku je taktéž rovna 4GB (což již v&nbsp;praxi
někdy může vadit)</li>

<li>maximální počet prvků v&nbsp;poli je roven 2<sup>32</sup>-1</li>

<li>maximální počet dvojic klíč-hodnota v&nbsp;mapě je taktéž roven
2<sup>32</sup>-1</li>

<li>nelze ukládat ukazatele a tím pádem ani přímo pracovat se stromy, obecnými
grafy atd. Tento nedostatek se částečně dá nahradit mapami obsahujícími další
hodnoty (pole, mapy). Totéž se týká JSONu a mnoha dalších přenositelných
formátů.</li>

<li>co je ze sémantického hlediska poněkud problematické &ndash; není
podporován typ &bdquo;množina&ldquo; (na to jsme si museli zvyknout i u
JSONu).</li>

<li>taktéž není podporován typ <i>decimal</i>, konkrétně numerické hodnoty
s&nbsp;plovoucí <i>desetinnou</i> řádovou čárkou.</li>

</ol>

<p><div class="rs-tip-major">Poznámka: podrobnosti o tom, jak jsou ukládány
jednotlivé typy hodnot, si ukážeme ve druhé (prakticky zaměřené) části dnešního
článku.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instalace balíčku <strong>msgpack</strong>> i balíčku pro serializaci N-dimenzionálních polí</h2>

<p>Pro práci s&nbsp;formátem <i>MessagePack</i> v&nbsp;Pythonu je určen balíček
nazvaný <strong>msgpack</strong>. Ten již bývá nainstalován společně
s&nbsp;Pythonem (protože ho využívají některé nástroje nad Pythonem postavené),
ovšem pokud tomu tak není, je instalace balíčku <strong>msgpack</strong> snadná
a přímočará:</p>

<pre>
$ <strong>pip install --user msgpack</strong>
</pre>

<p>Pro jednoduchý test, zda instalace balíčku proběhla v&nbsp;pořádku,
použijeme tento skript:</p>

<pre>
import msgpack
&nbsp;
help(msgpack)
</pre>

<p>Měla by se zobrazit nápověda:</p>

<pre>
Help on package msgpack:
&nbsp;
NAME
    msgpack
&nbsp;
PACKAGE CONTENTS
    _cmsgpack
    exceptions
    ext
    fallback
&nbsp;
FUNCTIONS
    dump = pack(o, stream, **kwargs)
        Pack object `o` and write it to `stream`
&nbsp;
        See :class:`Packer` for options.
&nbsp;
    dumps = packb(o, **kwargs)
        Pack object `o` and return packed bytes
&nbsp;
        See :class:`Packer` for options.
&nbsp;
    load = unpack(stream, **kwargs)
        Unpack an object from `stream`.
&nbsp;
        Raises `ExtraData` when `stream` contains extra bytes.
        See :class:`Unpacker` for options.
&nbsp;
    pack(o, stream, **kwargs)
        Pack object `o` and write it to `stream`
&nbsp;
        See :class:`Packer` for options.
&nbsp;
    packb(o, **kwargs)
        Pack object `o` and return packed bytes
&nbsp;
        See :class:`Packer` for options.
&nbsp;
    unpack(stream, **kwargs)
        Unpack an object from `stream`.
&nbsp;
        Raises `ExtraData` when `stream` contains extra bytes.
        See :class:`Unpacker` for options.
&nbsp;
DATA
    version = (1, 0, 6)
&nbsp;
VERSION
    1.0.6
&nbsp;
FILE
    /usr/lib64/python3.12/site-packages/msgpack/__init__.py
</pre>

<p>Povšimněte si, že k&nbsp;dispozici jen jen několik funkcí; samotné API je
pojato minimalisticky (což je jen dobře):</p>

<table>
<tr><th>Funkce</th><th>Stručný popis</th></tr>
<tr><td>pack</td><td>serializace hodnoty do otevřeného <i>streamu</i></td></tr>
<tr><td>packb</td><td>serializace hodnoty to sekvence bajtů</td></tr>
<tr><td>unpack</td><td>deserializace hodnoty z&nbsp;otevřeného <i>streamu</i></td></tr>
<tr><td>unpackb</td><td>deserializace hodnoty ze sekvence bajtů</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>dump</td><td>provádí tutéž operaci co pack()</td></tr>
<tr><td>dumps</td><td>provádí tutéž operaci co packb()</td></tr>
<tr><td>load</td><td>provádí tutéž operaci co unpack()</td></tr>
<tr><td>loads</td><td>provádí tutéž operaci co unpackb()</td></tr>
</table>

<p>Dále si nainstalujeme přídavný balíček, který nám umožní serializaci a
deserializaci N-dimenzionálních polí knihovny Numpy. Jedná se o velmi užitečný
doplněk:</p>

<pre>
$ <strong>pip install --user msgpack-numpy</strong>
</pre>

<p>Tento balíček již typicky není v&nbsp;systému dostupný, takže se skutečně
nainstaluje:</p>

<pre>
Collecting msgpack-numpy
  Downloading msgpack_numpy-0.4.8-py2.py3-none-any.whl.metadata (5.0 kB)
Collecting numpy&gt;=1.9.0 (from msgpack-numpy)
  Downloading numpy-2.2.0-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (62 kB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 62.0/62.0 kB 955.9 kB/s eta 0:00:00
Requirement already satisfied: msgpack&gt;=0.5.2 in /usr/lib64/python3.12/site-packages (from msgpack-numpy) (1.0.6)
Downloading msgpack_numpy-0.4.8-py2.py3-none-any.whl (6.9 kB)
Downloading numpy-2.2.0-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (16.1 MB)
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 16.1/16.1 MB 8.0 MB/s eta 0:00:00
Installing collected packages: numpy, msgpack-numpy
Successfully installed msgpack-numpy-0.4.8 numpy-2.2.0
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Prohlížení binárních souborů se serializovanými daty</h2>

<p>Pro prohlížení obsahu vytvořených binárních souborů se serializovanými daty
je možné použít například nějakou formu <i>hexadecimálního prohlížeče</i>.
Hexadecimálních prohlížečů a editorů existuje (pro Linux) relativně velké
množství. První dva nástroje nazvané <strong>od</strong> a
<strong>hexdump</strong> (zkráceně <strong>hd</strong>) pracují jako relativně
jednoduché jednosměrné filtry (navíc bývají nainstalovány společně se základní
sadou nástrojů), ovšem další nástroj pojmenovaný <strong>xxd</strong> již může
být použit pro obousměrný převod (filtraci), tj.&nbsp;jak pro transformaci
původního binárního souboru do čitelného tvaru (většinou s&nbsp;využitím
šestnáctkové soustavy), tak i pro zpětný převod. Díky tomu je možné nástroj
<strong>xxd</strong> použít například ve funkci pluginu do běžných textových
editorů (v&nbsp;textovém editoru se v&nbsp;takovém případě edituje
hexadecimální výpis, při uložení se data konvertují zpět do původní úsporné
binární podoby).</p>

<p>Další nástroj pojmenovaný <strong>hexdiff</strong> dokáže porovnat obsah
dvou binárních souborů a poslední zmíněný nástroj <strong>mcview</strong> je,
na rozdíl od předchozí čtveřice, aplikací s&nbsp;interaktivním ovládáním a
plnohodnotným textovým uživatelským prostředím (patří do sady nástrojů
vytvořených okolo <i>Midnight Commanderu</i> a instaluje se společně
s&nbsp;tímto nástrojem).</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;kontextu dnešního článku si
vystačíme s&nbsp;možnostmi nabízenými nástrojem <strong>od</strong> neboli
<i>octal dump</i>. Jméno tohoto nástroje je ve skutečnosti zavádějící, protože
dokáže zobrazit obsah binárního soubory mnoha různými způsoby, nejenom
v&nbsp;osmičkové soustavě. Již fakt, že jméno této utility má pouhá dvě
písmena, napovídá, že se jedná o nástroj pocházející již z&nbsp;prvních verzí
Unixu. Původní varianty utility <strong>od</strong> vypisovaly obsah zvoleného
souboru (alternativně standardního vstupu či zvoleného zařízení)
s&nbsp;využitím osmičkové soustavy, ovšem GNU verze <strong>od</strong> nabízí
uživatelům mnohem víc možností, a to včetně použití hexadecimální soustavy
(ostatně i proto o této utilitě dnes píšeme), zformátování sousedních čtyř
bajtů do čísla typu <i>single/float</i>, dtto pro osm bajtů a čísla typu
<i>double</i> apod.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Serializace primitivních datových typů do formátu <i>MessagePack</i></h2>

<p>Již v&nbsp;úvodních dvou kapitolách jsme si řekli, že do formátu
<i>MessagePack</i> je možné ukládat jak hodnoty jednoduchých (primitivních)
datových typů, tak i hodnoty složených datových typů (což jsou různé typy
kontejnerů &ndash; pole a mapy). Začneme primitivními datovými typy, protože
binární formát <i>MessagePack</i> je navržen takovým způsobem, aby byl způsob
jejich uložení v&nbsp;co největší míře efektivní &ndash; a to nejenom co se
týká celkového objemu dat, ale i jednoduchosti nebo naopak složitosti
zakódování a dekódování hodnot. Nativně jsou podporovány následující primitivní
datové typy:</p>

<ol>
<li>Typ <strong>none</strong> s&nbsp;jedinou hodnotou <strong>nil</strong> (v&nbsp;Pythonu odpovídá typu <strong>NoneType</strong>)</li>
<li>Typ <strong>boolean</strong> s&nbsp;hodnotami <strong>true</strong> a <strong>false</strong> (v&nbsp;Pythonu odpovídá typu <strong>bool</strong>)</li>
<li>Typ <strong>unsigned integer</strong> s&nbsp;plně 64 bitovým rozsahem (ve standardním Pythonu nemá přímý protějšek)</li>
<li>Typ <strong>signed integer</strong> s&nbsp;plně 64 bitovým rozsahem (částečně odpovídá typu <strong>int</strong>)</li>
<li>Typ <strong>float/single/float32</strong> s&nbsp;plovoucí řádovou čárkou (ve standardním Pythonu nemá přímý protějšek)</li>
<li>Typ <strong>double/float64</strong> s&nbsp;plovoucí řádovou čárkou (v&nbsp;Pythonu odpovídá typu <strong>float</strong> &ndash; pozor na odlišné pojmenování!)</li>
</ol>



<p><a name="k07"></a></p>
<h2 id="k07">7. Hodnota <strong>nil</strong> resp.&nbsp;<strong>None</strong></h2>

<p>Začneme tím zdánlivě nejjednodušším možným příkladem, který je však
v&nbsp;praxi poněkud problematický při předávání serializovaných hodnot mezi
různými programovacími jazyky a proto je nutné se o něm zmínit. Konkrétně se
budeme zabývat způsobem serializace Pythonovské hodnoty <strong>None</strong>.
Ta je použita stejným způsobem jako hodnota <strong>null</strong> v&nbsp;JSONu,
tedy pro indikaci chybějících dat. Přitom <strong>None</strong> má
v&nbsp;Pythonu svůj vlastní datový typ pojmenovaný taktéž
<strong>None</strong>, zatímco například <strong>nil</strong> v&nbsp;jazyce Go
nemusí být nutně přiřazeno k&nbsp;datovému typu (z&nbsp;tohoto pohledu je
v&nbsp;čase překladu beztypové, viz celý článek, který jsme na toto téma
vydali: <a
href="https://www.root.cz/clanky/problematika-nulovych-hodnot-v-go-aneb-proc-nil-nil/">na
rozdíl od samotného jazyka Go</a>).</p>

<p>Zdrojový kód demonstračního příkladu, který serializuje hodnotu
<strong>None</strong>, se skládá z&nbsp;několika operací:</p>

<ol>

<li>Vytvoření a otevření nového (binárního) souboru pro zápis</li>

<li>Konstrukce objektu/struktury použité pro serializaci</li>

<li>Vlastní serializace dat přímo do otevřeného binárního souboru</li>

</ol>

<p>V&nbsp;Pythonu 3.x může takový program vypadat následovně:</p>

<pre>
import msgpack
&nbsp;
value = None
&nbsp;
with open("nil.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>Pro zajímavost se podívejme, jak by podobný program vypadal při realizaci
v&nbsp;programovacím jazyce Go, v&nbsp;němž se explicitně kontrolují případné
chybové stavy atd.:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "os"
&nbsp;
        "github.com/ugorji/go/codec"
)
&nbsp;
const filename = "/tmp/nil.bin"
&nbsp;
func <strong>main</strong>() {
        <i>// vytvořit soubor s binárními daty</i>
        fout, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil {
                log.Fatal(err)
        }
        defer fout.Close()
&nbsp;
        log.Print("Output file created")
&nbsp;
        <i>// handler</i>
        var handler codec.MsgpackHandle
&nbsp;
        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(fout, &amp;handler)
&nbsp;
        log.Print("Encoder created")
&nbsp;
        <i>// zakódování dat</i>
        err = <u>encoder.Encode(nil)</u>
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        log.Print("Done")
}
</pre>

<p>V&nbsp;obou případech, tedy nezávisle na použitém programovacím jazyku, by
však měl mít výsledný soubor <strong>nil.bin</strong> naprosto totožný obsah.
Výsledkem serializace totiž bude binární soubor obsahující jediný bajt
s&nbsp;hodnotou <strong>0xc0</strong>, o čemž se ostatně můžeme velmi snadno
přesvědčit:</p>

<pre>
$ <strong>od -A x -t x1 -v nil.bin</strong>
&nbsp;
000000 c0
000001
</pre>

<p>Obsah tohoto souboru pochopitelně <a
href="https://github.com/msgpack/msgpack/blob/master/spec.md#nil-format">plně
odpovídá specifikaci</a>.</p>

<p><div class="rs-tip-major">Poznámka: je důležité si uvědomit, že tato hodnota
má význam &bdquo;chybějící údaj&ldquo; nebo &bdquo;neexistující údaj&ldquo; a
nejedná se v&nbsp;žádném případě o ukazatel (v&nbsp;Go a vlastně i Pythonu se
tyto dvě rozdílné sémantické významy poněkud překrývají).</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Serializace pravdivostních hodnot <strong>True</strong> a <strong>False</strong></h2>

<p>V&nbsp;serializačním formátu <i>MessagePack</i> jsou plně podporovány i
pravdivostní hodnoty <strong>True</strong> a <strong>False</strong>, což
v&nbsp;praxi znamená, že není nutné (a ani ze sémantického pohledu rozumné)
používat pro reprezentaci pravdivostních hodnot například hodnoty 0 a 1 či 0 a
-1. Navíc jsou pravdivostní hodnoty uloženy relativně rozumným způsobem &ndash;
v&nbsp;jediném bajtu (včetně informace o typu). O tom se budeme moci velmi
snadno přesvědčit na dvojici příkladů, které uloží hodnotu
<strong>True</strong> a ve druhém případě hodnotu <strong>False</strong>:</p>

<pre>
import msgpack
&nbsp;
value = True
&nbsp;
with open("true.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<pre>
import msgpack
&nbsp;
value = False
&nbsp;
with open("false.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>Nyní se podívejme na to, jak jsou tyto dvě hodnoty uloženy do výsledného
souboru:</p>

<pre>
$ <strong>od -A x -t x1 -v true.bin</strong>
&nbsp;
000000 c3
000001
&nbsp;
&nbsp;
&nbsp;
$ <strong>od -A x -t x1 -v false.bin</strong>
&nbsp;
000000 c2
000001
</pre>

<p>Což opět plně odpovídá <a
href="https://github.com/msgpack/msgpack/blob/master/spec.md#bool-format-family">specifikaci</a>.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Serializace celočíselných hodnot</h2>

<p>V&nbsp;této kapitole si ukážeme způsob serializace celočíselných hodnot, což
je již z&nbsp;pohledu programátora mnohem zajímavější problém. V&nbsp;tomto
ohledu totiž museli tvůrci formátu <i>MessagePack</i> splnit dva protichůdné
požadavky:</p>

<ol>

<li>reprezentovat co největší rozsah hodnot, ideálně 64bitové hodnoty</li>

<li>na druhou stranu je použití 64bitů (8 bajtů) ve všech případech až
trestuhodné plýtvání místem (a to mnohdy i oproti textovému JSONu
v&nbsp;případě ukládání hodnot okolo nuly)</li>

</ol>

<p>Výsledkem snahy o splnění obou požadavků je flexibilní způsob uložení celých
čísel v&nbsp;jednom, dvou, třech, pěti či devíti bajtech &ndash; vždy
v&nbsp;závislosti na konkrétní hodnotě a taktéž na tom, zda se jedná o hodnotu
kladnou či zápornou. <a
href="https://github.com/msgpack/msgpack/blob/master/spec.md#int-format-family">Specifikace
uložení celých čísel</a> ve skutečnosti není příliš složitá a můžeme si ji
snadno otestovat na několika demonstračních příkladech.</p>

<p><div class="rs-tip-major">Poznámka: povšimněte si striktního použití pořadí
bajtů <i>big endian</i>!</div></p>

<p>Nejprve si otestujeme uložení velmi malého celého čísla v&nbsp;rozsahu 0 až
127:</p>

<pre>
import msgpack
&nbsp;
value = 42
&nbsp;
with open("int_tiny.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>Výsledkem je v&nbsp;tomto případě pouhý jeden bajt, který obsahuje jak
informace o datovém typu, tak i vlastní hodnotu:</p>

<pre>
$ <strong>od -A x -t x1 -v int_tiny.bin</strong>
&nbsp;
000000 2a
000001
</pre>

<p>Uložení čísla většího než 127, ale menšího než 256:</p>

<pre>
import msgpack
&nbsp;
value = 200
&nbsp;
with open("int_small.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>Výsledný soubor bude mít velikost dva bajty, opět přesně podle specifikace
(první bajt obsahuje typ, druhý hodnotu):</p>

<pre>
$ <strong>od -A x -t x1 -v int_small.bin</strong>
&nbsp;
000000 cc c8
000002
</pre>

<p>Celé číslo větší než 255, ale menší než 2<sup>16</sup> se uloží do tří
bajtů:</p>

<pre>
import msgpack
&nbsp;
value = 1000
&nbsp;
with open("int_large.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>Výsledek:</p>

<pre>
$ <strong>od -A x -t x1 -v int_large.bin</strong>
&nbsp;
000000 cd 03 e8
000003
</pre>

<p>kde 0x3e8 skutečně v&nbsp;desítkové soustavě odpovídá hodnotě 1000.</p>

<p>Serializace čísla většího než 2<sup>16</sup>:</p>

<pre>
import msgpack
&nbsp;
value = 100000
&nbsp;
with open("int_larger.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>Opět je použit jeden bajt se specifikací typu, za kterým následuje čtveřice
bajtů 0x0186a0 = 100000:</p>

<pre>
$ <strong>od -A x -t x1 -v int_larger.bin</strong>
&nbsp;
000000 ce 00 01 86 a0
000005
</pre>

<p>A konečně hodnota 2<sup>60</sup>:</p>

<pre>
import msgpack
&nbsp;
value = 2**60
&nbsp;
with open("int_long.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>Jedná se o 64bitovou hodnotu uloženou v&nbsp;devíti bajtech:</p>

<pre>
$ <strong>od -A x -t x1 -v long_int.bin</strong>
&nbsp;
000000 cf 10 00 00 00 00 00 00 00
000009
</pre>

<p>Podobné příklady lze vytvořit i pro záporná čísla, například:</p>

<pre>
import msgpack
&nbsp;
value = -10
&nbsp;
with open("negative_int.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
$ <strong>od -A x -t x1 -v negative_int.bin</strong>
&nbsp;
000000 f6
000001
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Celočíselné hodnoty překračující 64bitový rozsah</h2>

<p>Celočíselné hodnoty, které přesahují 64bitový rozsah, nejsou v&nbsp;současné
verzi MessagePacku podporovány, tedy za předpokladu, že si nenapíšete rozšíření
pro vlastní datový typ (více o tomto tématu si řekneme dále). Zajímavé bude
zjistit, co se tedy stane v&nbsp;případě, že budeme serializovat větší
celočíselnou hodnotu. Otestování je snadné:</p>

<pre>
import msgpack
&nbsp;
value = 2**64
&nbsp;
with open("too_long_int.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>Výsledek nebude v&nbsp;tomto případě příliš potěšující &ndash; dojde
k&nbsp;vyhození běhové výjimky typu <strong>OverflowError</strong>:</p>

<pre>
Traceback (most recent call last):
  File "msgpack/_packer.pyx", line 177, in msgpack._cmsgpack.Packer._pack
OverflowError: Python int too large to convert to C unsigned long
&nbsp;
During handling of the above exception, another exception occurred:
&nbsp;
Traceback (most recent call last):
  File "/home/ptisnovs/src/most-popular-python-libs/msgpack/serialize_too_long_int.py", line 6, in <module>
    packed = msgpack.packb(value)
             ^^^^^^^^^^^^^^^^^^^^
  File "/usr/lib64/python3.12/site-packages/msgpack/__init__.py", line 36, in packb
    return Packer(**kwargs).pack(o)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "msgpack/_packer.pyx", line 294, in msgpack._cmsgpack.Packer.pack
  File "msgpack/_packer.pyx", line 300, in msgpack._cmsgpack.Packer.pack
  File "msgpack/_packer.pyx", line 297, in msgpack._cmsgpack.Packer.pack
  File "msgpack/_packer.pyx", line 188, in msgpack._cmsgpack.Packer._pack
OverflowError: Integer value out of range
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Serializace hodnot s&nbsp;plovoucí řádovou čárkou</h2>

<p>Ve formátu MessagePack jsou podle očekávání podporovány i hodnoty
s&nbsp;plovoucí řádovou čárkou. Jedná se jak o hodnoty s&nbsp;jednoduchou
přesností (<i>single</i>, <i>float</i>, <i>float32</i>), tak i o hodnoty
s&nbsp;dvojitou přesností (<i>double</i>, <i>float64</i>). V&nbsp;Pythonu
existuje jediný datový typ pro reprezentaci hodnoty s&nbsp;plovoucí řádovou
čárkou, a ten odpovídá typu <i>double/float64</i>, takže se (při serializaci)
většinou s&nbsp;hodnotou typu <i>single</i> nesetkáme:</p>

<pre>
import msgpack
&nbsp;
value = 3.14
&nbsp;
with open("float.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>Prozkoumejme výsledný soubor, který by měl mít délku devíti bajtů:</p>

<pre>
000000 cb 40 09 1e b8 51 eb 85 1f
000009
</pre>

<p><div class="rs-tip-major">Poznámka: výsledek si můžete ověřit <a
href="https://baseconvert.com/ieee-754-floating-point">na této stránce</a> po
zadání hodnoty 3.14 a přečtení 64bitového výsledku v&nbsp;hexadecimálním
tvaru.</div></p>

<p>V&nbsp;mnoha serializačních formátech, zejména těch textově orientovaných
(JSON, XML) se mnohdy poněkud zapomíná na hodnoty NaN a taktéž na kladné i
záporné nekonečno. V&nbsp;případě MessagePacku jsou tyto speciální hodnoty plně
podporovány, což je v&nbsp;poměrně mnoha oblastech důležité (samozřejmě otázkou
je, jak tyto hodnoty vznikly, to však nemá řešit přenosový protokol).</p>

<p>Otestujme si nejdříve serializaci hodnoty NaN, tj.&nbsp;například na
výsledek 0/0, sin(&infin;), &radic;-1 atd.:</p>

<pre>
import math
import msgpack
&nbsp;
value = math.nan
&nbsp;
with open("nan.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>Výsledný soubor obsahuje devět bajtů &ndash; specifikaci formátu
následovanou hodnotou NaN odpovídající IEEE 754, což si opět můžete ověřit na
stránce <a
href="https://baseconvert.com/ieee-754-floating-point">https://baseconvert.com/ieee-754-floating-point</a>
po zadání &bdquo;nan&ldquo; do vstupního políčka:</p>

<pre>
000000 cb 7f f8 00 00 00 00 00 00
000009
</pre>

<p>Podobně si můžeme ověřit, jak je uloženo kladné nebo záporné nekonečno.
Začneme kladným nekonečnem:</p>

<pre>
import math
import msgpack
&nbsp;
value = math.inf
&nbsp;
with open("inf.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>Výsledek:</p>

<pre>
000000 cb 7f f0 00 00 00 00 00 00
000009
</pre>

<p>V&nbsp;případě záporného nekonečně se pouze změní jediný bit, takže druhý
bajt bude namísto hodnoty 7f obsahovat hodnotu ff:</p>

<pre>
import math
import msgpack
&nbsp;
value = -math.inf
&nbsp;
with open("negative_inf.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>Výsledných devět bajtů:</p>

<pre>
000000 cb ff f0 00 00 00 00 00 00
000009
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Složené datové typy ve formátu MessagePack</h2>

<p>Po popisu způsobu uložení jednoduchých datových typů (což vlastně ve
skutečnosti nebylo nic složitého) si v&nbsp;dnešním článku ukážeme, jakým
způsobem je ve formátu <i>MessagePack</i> realizováno uložení složených
datových typů. Do této kategorie se řadí především řetězce, sekvence bajtů,
pole, ale v&nbsp;neposlední řadě i velmi důležité mapy, které lze použít
například pro uložení atributů objektů (ostatně naprosto stejně je tato
problematika řešená v&nbsp;JSONu). Opět uvidíme, že u některých výše zmíněných
datových typů je dbáno na efektivitu výsledného binárního souboru, a to jak
z&nbsp;hlediska celkového objemu dat, tak i složitosti kódování a dekódování
těchto dat.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Krátké a dlouhé řetězce</h2>

<p>Takřka nepostradatelným složeným datovým typem jsou řetězce. Interně se pro
jejich uložení používá UTF-8. Neméně důležitá je však informace o tom, jak
dlouhý řetězec je. Délka řetězce je uložena před vlastní znaky a to konkrétně
tak, že pro krátké řetězce je délka uložena přímo v&nbsp;bajtu se specifikací
typu (tedy neztratíme <i>ani jediný bajt</i>!) a pro delší řetězce je délka
uložena v&nbsp;jednom, dvou či v&nbsp;celých čtyřech bajtech.</p>

<p>Velmi krátký řetězec, menší než 31 bajtů (nikoli znaků!), se serializuje
takto:</p>

<pre>
import msgpack
&nbsp;
value = "Hello"
&nbsp;
with open("short_string.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>V&nbsp;tomto případě je délka řetězce uložena v&nbsp;prvním bajtu, přičemž
první tři bity tohoto bajtu určují datový typ:</p>

<pre>
$ <strong>od -A x -t x1z -v short_string.bin</strong>
&nbsp;
000000 a5 48 65 6c 6c 6f                                &lt;.Hello&gt;
000006
</pre>

<p>Vyzkoušejme si nyní poněkud delší řetězec:</p>

<pre>
import msgpack
&nbsp;
value = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."
&nbsp;
with open("longer_string.bin", "wb") as outfile:
     packed = msgpack.packb(value)
     outfile.write(packed)
</pre>

<p>Takový řetězec po serializaci obsahuje v&nbsp;první bajtu konstantu 0xd9 a
poté délku řetězce v&nbsp;jediném bajtu. Následují kódy jednotlivých znaků:</p>

<pre>
000000 d9 ea 4c 6f 72 65 6d 20 69 70 73 75 6d 20 64 6f  &gt;..Lorem ipsum do&lt;
000010 6c 6f 72 20 73 69 74 20 61 6d 65 74 2c 20 63 6f  &gt;lor sit amet, co&lt;
000020 6e 73 65 63 74 65 74 75 72 20 61 64 69 70 69 73  &gt;nsectetur adipis&lt;
000030 63 69 6e 67 20 65 6c 69 74 2c 20 73 65 64 20 64  &gt;cing elit, sed d&lt;
000040 6f 20 65 69 75 73 6d 6f 64 20 74 65 6d 70 6f 72  &gt;o eiusmod tempor&lt;
000050 20 69 6e 63 69 64 69 64 75 6e 74 20 75 74 20 6c  &gt; incididunt ut l&lt;
000060 61 62 6f 72 65 20 65 74 20 64 6f 6c 6f 72 65 20  &gt;abore et dolore &lt;
000070 6d 61 67 6e 61 20 20 20 20 61 6c 69 71 75 61 2e  &gt;magna    aliqua.&lt;
000080 20 55 74 20 65 6e 69 6d 20 61 64 20 6d 69 6e 69  &gt; Ut enim ad mini&lt;
000090 6d 20 76 65 6e 69 61 6d 2c 20 71 75 69 73 20 6e  &gt;m veniam, quis n&lt;
0000a0 6f 73 74 72 75 64 20 65 78 65 72 63 69 74 61 74  &gt;ostrud exercitat&lt;
0000b0 69 6f 6e 20 75 6c 6c 61 6d 63 6f 20 6c 61 62 6f  &gt;ion ullamco labo&lt;
0000c0 72 69 73 20 6e 69 73 69 20 75 74 20 61 6c 69 71  &gt;ris nisi ut aliq&lt;
0000d0 75 69 70 20 65 78 20 65 61 20 63 6f 6d 6d 6f 64  &gt;uip ex ea commod&lt;
0000e0 6f 20 63 6f 6e 73 65 71 75 61 74 2e              &gt;o consequat.&lt;
0000ec
</pre>

<p>Řetězec delší než 255 znaků, ale kratší než 65536 znaků:</p>

<pre>
import msgpack
&nbsp;
value = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."
&nbsp;
with open("even_longer_string.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>V&nbsp;tomto případě je první bajt roven konstantě 0xda. Za ní následují dva
bajty s&nbsp;délkou řetězce v&nbsp;bajtech, konkrétně celkem 0x1bd=445 bajtů. A
poté již vlastní znaky tvořící řetězec:</p>

<pre>
000000 da 01 bd 4c 6f 72 65 6d 20 69 70 73 75 6d 20 64  &gt;...Lorem ipsum d&lt;
000010 6f 6c 6f 72 20 73 69 74 20 61 6d 65 74 2c 20 63  &gt;olor sit amet, c&lt;
000020 6f 6e 73 65 63 74 65 74 75 72 20 61 64 69 70 69  &gt;onsectetur adipi&lt;
000030 73 63 69 6e 67 20 65 6c 69 74 2c 20 73 65 64 20  &gt;scing elit, sed &lt;
000040 64 6f 20 65 69 75 73 6d 6f 64 20 74 65 6d 70 6f  &gt;do eiusmod tempo&lt;
000050 72 20 69 6e 63 69 64 69 64 75 6e 74 20 75 74 20  &gt;r incididunt ut &lt;
000060 6c 61 62 6f 72 65 20 65 74 20 64 6f 6c 6f 72 65  &gt;labore et dolore&lt;
000070 20 6d 61 67 6e 61 20 61 6c 69 71 75 61 2e 20 55  &gt; magna aliqua. U&lt;
000080 74 20 65 6e 69 6d 20 61 64 20 6d 69 6e 69 6d 20  &gt;t enim ad minim &lt;
000090 76 65 6e 69 61 6d 2c 20 71 75 69 73 20 6e 6f 73  &gt;veniam, quis nos&lt;
0000a0 74 72 75 64 20 65 78 65 72 63 69 74 61 74 69 6f  &gt;trud exercitatio&lt;
0000b0 6e 20 75 6c 6c 61 6d 63 6f 20 6c 61 62 6f 72 69  &gt;n ullamco labori&lt;
0000c0 73 20 6e 69 73 69 20 75 74 20 61 6c 69 71 75 69  &gt;s nisi ut aliqui&lt;
0000d0 70 20 65 78 20 65 61 20 63 6f 6d 6d 6f 64 6f 20  &gt;p ex ea commodo &lt;
0000e0 63 6f 6e 73 65 71 75 61 74 2e 20 44 75 69 73 20  &gt;consequat. Duis &lt;
0000f0 61 75 74 65 20 69 72 75 72 65 20 64 6f 6c 6f 72  &gt;aute irure dolor&lt;
000100 20 69 6e 20 72 65 70 72 65 68 65 6e 64 65 72 69  &gt; in reprehenderi&lt;
000110 74 20 69 6e 20 76 6f 6c 75 70 74 61 74 65 20 76  &gt;t in voluptate v&lt;
000120 65 6c 69 74 20 65 73 73 65 20 63 69 6c 6c 75 6d  &gt;elit esse cillum&lt;
000130 20 64 6f 6c 6f 72 65 20 65 75 20 66 75 67 69 61  &gt; dolore eu fugia&lt;
000140 74 20 6e 75 6c 6c 61 20 70 61 72 69 61 74 75 72  &gt;t nulla pariatur&lt;
000150 2e 20 45 78 63 65 70 74 65 75 72 20 73 69 6e 74  &gt;. Excepteur sint&lt;
000160 20 6f 63 63 61 65 63 61 74 20 63 75 70 69 64 61  &gt; occaecat cupida&lt;
000170 74 61 74 20 6e 6f 6e 20 70 72 6f 69 64 65 6e 74  &gt;tat non proident&lt;
000180 2c 20 73 75 6e 74 20 69 6e 20 63 75 6c 70 61 20  &gt;, sunt in culpa &lt;
000190 71 75 69 20 6f 66 66 69 63 69 61 20 64 65 73 65  &gt;qui officia dese&lt;
0001a0 72 75 6e 74 20 6d 6f 6c 6c 69 74 20 61 6e 69 6d  &gt;runt mollit anim&lt;
0001b0 20 69 64 20 65 73 74 20 6c 61 62 6f 72 75 6d 2e  &gt; id est laborum.&lt;
0001c0
</pre>

<p>A konečně řetězec delší než 65535 bajtů</p>

<pre>
import msgpack
&nbsp;
value = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."
&nbsp;
value *= 300
print(len(value))
&nbsp;
with open("huge_string.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>Na začátku souboru je uložen bajt 0xdb a následuje čtyřbajtová délka
řetězce. Poté již následují jednotlivé znaky řetězce:</p>

<pre>
000000 db 00 01 0e b4 4c 6f 72 65 6d 20 69 70 73 75 6d  &gt;.....Lorem ipsum&lt;
000010 20 64 6f 6c 6f 72 20 73 69 74 20 61 6d 65 74 2c  &gt; dolor sit amet,&lt;
000020 20 63 6f 6e 73 65 63 74 65 74 75 72 20 61 64 69  &gt; consectetur adi&lt;
000030 70 69 73 63 69 6e 67 20 65 6c 69 74 2c 20 73 65  &gt;piscing elit, se&lt;
000040 64 20 64 6f 20 65 69 75 73 6d 6f 64 20 74 65 6d  &gt;d do eiusmod tem&lt;
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Malá a rozsáhlá pole</h2>

<p>Pole, a to pole prvků libovolných typů, se do formátu MessagePack opět
ukládá podle toho, kolik prvků takové pole obsahuje. Pole s&nbsp;prvky, jejichž
počet nepřesáhne patnáct, obsahuje pouze jediný bajt navíc. Obsah tohoto bajtu
určuje, že se jedná o pole a současně i ve spodních čtyřech bitech obsahuje
počet prvků pole.</p>

<pre>
import msgpack
&nbsp;
value = [1, 2, 3, 4]
&nbsp;
with open("array.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>Výše uvedené pole se čtyřmi prvky je uloženo v&nbsp;pouhých pěti bajtech a
to z&nbsp;toho důvodu, že hodnoty prvků samy o sobě mají tak malou hodnotu, že
každý z&nbsp;nich může být uložen v&nbsp;jediném bajtu. První bajt určuje jak
typ (pole), tak i počet jeho prvků:</p>

<pre>
$ <strong>od -A x -t x1 -v short_array.bin</strong>
&nbsp;
000000 94 01 02 03 04
000005
</pre>

<p>Naproti tomu druhé serializované pole již obsahuje prvky s&nbsp;relativně
vyššími hodnotami:</p>

<pre>
import msgpack
&nbsp;
value = [100, 200, 300, 400]
&nbsp;
with open("array2.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>Nyní bude soubor delší, protože již některé prvky nelze uložit do jediného
bajtu:</p>

<pre>
$ <strong>od -A x -t x1 -v short_array2.bin</strong>
&nbsp;
000000 94 64 d1 00 c8 d1 01 2c d1 01 90
00000b
</pre>

<p>V&nbsp;tomto případě první bajt obsahuje typ (pole) s&nbsp;jeho délkou.
Následuje bajt s&nbsp;hodnotou 0x64=100, tedy první prvek (jediný bajt), další
prvek je uložen ve třech bajtech (0xd1 = typ, 0x00c8=200 je hodnota) atd.</p>

<p><div class="rs-tip-major">Poznámka: můžeme vidět, že každý prvek může být
uložen různým způsobem a pole tedy nejsou heterogenní ani s&nbsp;ohledem na
datový typ z&nbsp;pohledu programátora (ve skutečnosti se tedy spíše jedná o
seznamy) ani z&nbsp;pohledu binárního formátu.</div></p>

<p>Pole delší než patnáct prvků se dále rozlišují podle toho, zda je celkový
počet prvků menší než 2<sup>16</sup>-1 nebo větší než tato hodnota. Podle počtu
prvků se volí počet bajtů pro uložení délky pole &ndash; dva či čtyři bajty. My
si dnes ukážeme pouze první typ, tj.&nbsp;pole menší než 2<sup>16</sup>-1
prvků:</p>

<pre>
import msgpack
&nbsp;
value = []
&nbsp;
for i in range(1000):
    value.append(i)
&nbsp;
with open("array3.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>Nejprve je uveden typ (<strong>0xdc</strong>) a počet prvků 0x03e8=1000.
Dále již následují hodnoty jednotlivých prvků. Pro prvních 128 prvků postačuje
pro uložení použít jediný bajt:</p>

<pre>
000000 dc 03 e8 00 01 02 03 04 05 06 07 08 09 0a 0b 0c
000010 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c
000020 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c
000030 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 3b 3c
000040 3d 3e 3f 40 41 42 43 44 45 46 47 48 49 4a 4b 4c
000050 4d 4e 4f 50 51 52 53 54 55 56 57 58 59 5a 5b 5c
000060 5d 5e 5f 60 61 62 63 64 65 66 67 68 69 6a 6b 6c
000070 6d 6e 6f 70 71 72 73 74 75 76 77 78 79 7a 7b 7c
000080 7d 7e 7f
</pre>

<p>Větší hodnoty jsou již uloženy složitějším způsobem, protože první bajt
každé trojice obsahuje typ (<strong>0xd1</strong>):</p>

<pre>
000080          d1 00 80 d1 00 81 d1 00 82 d1 00 83 d1
000090 00 84 d1 00 85 d1 00 86 d1 00 87 d1 00 88 d1 00
0000a0 89 d1 00 8a d1 00 8b d1 00 8c d1 00 8d d1 00 8e
0000b0 d1 00 8f d1 00 90 d1 00 91 d1 00 92 d1 00 93 d1
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Serializace map</h2>

<p>Ve formátu JSON se prakticky vždy setkáme s&nbsp;mapami resp.&nbsp;přesněji
řečeno s&nbsp;asociativními poli. Tuto datovou strukturu lze použít i ve
formátu <i>MessagePack</i> a to dokonce ještě ve vylepšené variantě, protože
klíči mohou být hodnoty jakéhokoli typu, nejenom řetězce. Ukažme si ovšem
základní použití s&nbsp;řetězci jako klíči:</p>

<pre>
import msgpack
&nbsp;
value = {
        "foo": 42,
        "bar": None,
        "baz": 3.14,
        }
&nbsp;
with open("dict.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<p>Tato mapa se dvěma dvojicemi klíč+hodnota bude uložena v&nbsp;pouhých
dvaceti čtyřech bajtech:</p>

<p>Mapa obsahuje tři dvojice, což je malý počet. Z&nbsp;tohoto důvodu je typ
(mapa) i počet dvojic klíč-hodnota uložena v&nbsp;jediném bajtu 0x80+3=0x83.
Následuje stejný obsah, jako v&nbsp;případě polí:</p>

<pre>
000000 83 a3 66 6f 6f 2a a3 62 61 72 c0 a3 62 61 7a cb  &gt;..foo*.bar..baz.&lt;
000010 40 09 1e b8 51 eb 85 1f                          &gt;@...Q...&lt;
000018
</pre>

<table>
<tr><th>Bajty</th><th>Význam</th></tr>
<tr><td>a3 66 6f 6f</td><td>řetězec "foo" o délce tří bajtů</td></tr>
<tr><td>2a</td><td>malé celé číslo 42</td></tr>
<tr><td>a3 62 61 72</td><td>řetězec "bar" o délce tří bajtů</td></tr>
<tr><td>c0</td><td>hodnota nil/None</td></tr>
<tr><td>a3 62 61 7a</td><td>řetězec "baz" o délce tří bajtů</td></tr>
<tr><td>cb 40 09 1e b8 51 eb 85 1f</td><td>hodnota typu <i>double</i> = 3.14 (otestujte <a href="https://gregstoll.com/~gregstoll/floattohex/">zde</a>)</td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Serializace N-dimenzionálních polí</h2>

<p>V&nbsp;mnoha oblastech souvisejících s&nbsp;IT se setkáme s&nbsp;daty, která
jsou uložena v&nbsp;N-rozměrných polích (<i>ND array</i>). Nejčastěji se
s&nbsp;velkou pravděpodobností setkáme s&nbsp;jednorozměrnými poli (neboli
<i>vektory</i>), protože například zvukové záznamy jsou vlastně tvořeny
sekvencí hodnot zvukových vzorků (<i>samplů</i>). A pochopitelně prakticky
každý IT systém pracuje s&nbsp;obrazovými daty (ty si můžeme představit buď
jako matice nebo jako trojrozměrná pole, v&nbsp;případě, že barvové roviny
tvoří třetí dimenzi). Relativně často se setkáme i s&nbsp;vícerozměrnými poli,
například v&nbsp;oblasti statistiky, lineární algebry, datové analýzy,
strojového učení, zpracování medicínských či astronomických dat apod. Současně
se jedná o datové struktury a operace, u nichž má velký smysl využít SIMD
instrukce, které jsou dostupné na všech moderních mikroprocesorových
architekturách. A právě z&nbsp;tohoto důvodu jsme se na stránkách <a
href="https://www.root.cz">Roota</a> již mnohokrát setkali
s&nbsp;programovacími jazyky popř.&nbsp;s&nbsp;knihovnami, které jsou určeny
právě pro zpracování n-rozměrných polí.</p>

<p>Víme již, že práce s&nbsp;N-rozměrnými poli je poměrně dobře podporována jak
ve specializovaných programovacích jazycích (<a
href="https://www.root.cz/clanky/jazyk-apl-kombinatory-vlacky-a-point-free-style/">APL</a>,
<a
href="https://www.root.cz/clanky/programovaci-jazyk-j-ndash-od-hieroglyfu-k-nbsp-ascii-znakum/">J</a>,
<a
href="https://www.root.cz/clanky/programovaci-jazyk-k-dukaz-ze-mezi-nami-ziji-mimozemstane/">K</a>,
...), tak i například v&nbsp;Pythonu, pro nějž byla vytvořena populární <a
href="https://www.root.cz/vyhledavani/?qs=numpy">knihovna Numpy</a>. Taktéž
jsme se setkali s&nbsp;balíčky pro práci s&nbsp;N-rozměrnými poli určenými pro
<a href="https://www.root.cz/serialy/programovaci-jazyk-go/">programovací jazyk
Go</a>. Připomeňme si, že se jednalo především o balíčky <i>Gonum Numerical
Packages</i> a taktéž o balíček <i>narray</i>. Kvůli tomu, že se v&nbsp;oblasti
statistiky, datové analýzy či strojového učení stále více používá programovací
jazyk Python, je mnohdy nutné zajistit předávání dat (reprezentovaných ve formě
N-rozměrných polí) právě mezi Pythonem a nástroji vytvořenými v&nbsp;dalších
jazycích.</p>

<p>Taková data lze předávat v&nbsp;několika standardních formátech k&nbsp;tomu
určených, ovšem využít lze i MessagePack. V&nbsp;tomto případě jsou data
uložena jako &bdquo;rozšiřující typ&ldquo; a pro jejich serializaci a
deserializaci lze použít podpůrný balíček <strong>msgpack_numpy</strong>.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Serializace 1D polí z&nbsp;balíčku NumPy</h2>

<p></p>

<pre>
import msgpack
import msgpack_numpy as m
&nbsp;
import numpy as np
&nbsp;
m.patch()
&nbsp;
value = np.array([1, 2, 3], dtype=np.byte)
&nbsp;
with open("array_1d_byte.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<pre>
000000 85 c4 02 6e 64 c3 c4 04 74 79 70 65 a3 7c 69 31
000010 c4 04 6b 69 6e 64 c4 00 c4 05 73 68 61 70 65 91
000020 03 c4 04 64 61 74 61 c4 03 01 02 03
00002c
</pre>

<pre>
import msgpack
import msgpack_numpy as m

import numpy as np

m.patch()

value = np.zeros([10000], dtype=np.float32)
print(value.shape)

with open("array_1d_large.bin", "wb") as outfile:
    packed = msgpack.packb(value)
    outfile.write(packed)
</pre>

<pre>
</pre>

40044


<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: alternativní binární formáty pro serializaci dat</h2>

<p>Jak jsme se již zmínili <a href="#k01">v&nbsp;úvodní kapitole</a>, existuje
ve skutečnosti mnohem větší množství binárních formátů používaných jak pro
serializaci dat, tak i pro komunikaci mezi různými službami
(resp.&nbsp;přesněji řečeno pro posílání dat/zpráv mezi těmito službami nebo
mikroslužbami). Alespoň krátce se tedy o některých z&nbsp;těchto formátů
zmiňme.</p>

<p>Prvním alternativním binárním formátem, s&nbsp;nímž se v&nbsp;oblasti
mikroslužeb setkáme, je formát nazvaný <i>gob</i> neboli <i>Go Objects</i>.
Jedná se o formát určený primárně pro použití v&nbsp;programovacím jazyku Go,
což znamená, že jeho využití je relativně specifické (ukládání rozsáhlých dat,
komunikace mezi dvojicí služeb naprogramovaných v&nbsp;Go atd.). Tento formát
umožňuje serializaci prakticky jakékoli datové struktury, ovšem je ho možné
použít i pro primitivní datové typy, resp.&nbsp;pro jejich hodnoty. Pro Python
existuje balíček umožňující s&nbsp;<i>gob</i> pracovat, což je
v&nbsp;heterogenních systémech (každá mikroslužba může být naprogramována
v&nbsp;jiném jazyce) užitečné.</p>

<p>Dalším binárním formátem určeným pro přenos prakticky libovolně
strukturovaných dat je formát nazvaný <i>CBOR</i> neboli plným jménem
<i>Concise Binary Object Representation</i>. Tímto formátem, jenž se snaží
nabízet podobné vlastnosti jako JSON (až na možnost jeho přímého čtení
člověkem), se budeme zabývat v&nbsp;navazujícím textu (interně je nepatrně
složitější než MessagePack, navíc s&nbsp;MessagePacku vychází).</p>

<p><p>Dalším sice relativně novým, ale postupně se rozšiřujícím binárním
formátem je formát nazvaný <i>BSON</i> (zde je odkaz na JSON nesporný).
Možnosti tohoto formátu jsou již větší, například je podporován typ
<i>decimal128</i> určený pro použití v&nbsp;bankovnictví. Taktéž podporuje
uložení časových razítek nebo i kódu v&nbsp;JavaScriptu.</p>

<p><div class="rs-tip-major">Poznámka: zajímavé je, že ani jeden
z&nbsp;uvedených binárních formátů nepodporuje typ <a
href="https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/">bfloat16</a>,
i když zrovna v&nbsp;této oblasti se jeho použití přímo nabízí. Toto omezení
v&nbsp;MessagePacku obcházíme vlastními datovými typy.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady využívající knihovnu PyTorch lze nalézt
v&nbsp;repositáři <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Následují odkazy na jednotlivé příklady:</p>

<table>
<tr><th>#<th>Příklad</th><th>Stručný popis</th><th>Adresa příkladu</th></tr></i>
<tr><td> 1</td><td>import_msgpack.py</td><td>import balíčku <strong>msgpack</strong> se zobrazením nápovědy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/import_msgpack.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/import_msgpack.py</a></td></tr>
<tr><td> 2</td><td>serialize_none.py</td><td>serializace hodnoty <strong>None</strong> do souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_none.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_none.py</a></td></tr>
<tr><td> 3</td><td>serialize_true.py</td><td>serializace pravdivostní hodnoty <strong>True</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_true.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_true.py</a></td></tr>
<tr><td> 4</td><td>serialize_false.py</td><td>serializace pravdivostní hodnoty <strong>False</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_false.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_false.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>serialize_int_tiny.py</td><td>serializace malé celočíselné hodnoty do jediného bajtu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_int_tiny.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_int_tiny.py</a></td></tr>
<tr><td> 6</td><td>serialize_int_small.py</td><td>serializace celočíselné hodnoty do dvou bajtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_int_small.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_int_small.py</a></td></tr>
<tr><td> 7</td><td>serialize_int_large.py</td><td>serializace celočíselné hodnoty do tří bajtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_int_large.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_int_large.py</a></td></tr>
<tr><td> 8</td><td>serialize_int_larger.py</td><td>serializace celočíselné hodnoty do pěti bajtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_int_larger.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_int_larger.py</a></td></tr>
<tr><td> 9</td><td>serialize_int_long.py</td><td>serializace celočíselné hodnoty do devíti bajtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_int_long.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_int_long.py</a></td></tr>
<tr><td>10</td><td>serialize_too_long_int.py</td><td>pokus o serializace hodnoty přesahující 2<sup>63</sup></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_too_long_int.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_too_long_int.py</a></td></tr>
<tr><td>11</td><td>serialize_negative_int.py</td><td>serializace záporné celočíselné hodnoty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_negative_int.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_negative_int.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>serialize_float.py</td><td>serializace hodnoty <i>double float</i></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_float.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_float.py</a></td></tr>
<tr><td>13</td><td>serialize_inf.py</td><td>serializace kladného nekonečna</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_inf.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_inf.py</a></td></tr>
<tr><td>14</td><td>negative_inf.py</td><td>serializace záporného nekonečna</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/negative_inf.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/negative_inf.py</a></td></tr>
<tr><td>15</td><td>serialize_nan.py</td><td>serializace hodnoty NaN</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_nan.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_nan.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>serialize_string_short.py</td><td>serializace velmi krátkého řetězce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_string_short.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_string_short.py</a></td></tr>
<tr><td>17</td><td>serialize_string_longer.py</td><td>serializace delšího řetězce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_string_longer.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_string_longer.py</a></td></tr>
<tr><td>18</td><td>serialize_string_even_longer.py</td><td>serializace řetězce delšího než 255 bajtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_string_even_longer.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_string_even_longer.py</a></td></tr>
<tr><td>19</td><td>serialize_string_huge.py</td><td>serializace řetězce delšího než 65535 bajtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_string_huge.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_string_huge.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>serialize_array_small.py</td><td>serializace pole s&nbsp;malým počtem prvků (menších než 255)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_array_small.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_array_small.py</a></td></tr>
<tr><td>21</td><td>serialize_array_normal.py</td><td>serializace pole s&nbsp;malým počtem prvků</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_array_normal.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_array_normal.py</a></td></tr>
<tr><td>22</td><td>serialize_array_large.py</td><td>serializace pole s&nbsp;počtem prvků větším než 256</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_array_large.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_array_large.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>serialize_dict.py</td><td>serializace slovníku</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_dict.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_dict.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>24</td><td>serialize_numpy_array.py</td><td>serializace malého N-dimenzionálního pole</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_numpy_array.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_numpy_array.py</a></td></tr>
<tr><td>25</td><td>serialize_numpy_large_array.py</td><td>serializace N-dimenzionálního pole s&nbsp;prvky typu <i>float</i></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_numpy_large_array.py">https://github.com/tisnik/most-popular-python-libs/blob/master/msgpack/serialize_numpy_large_array.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Základní informace o MessagePacku<br />
<a href="https://msgpack.org/">https://msgpack.org/</a>
</li>

<li>Balíček msgpack na PyPi<br />
<a href="https://pypi.org/project/msgpack/">https://pypi.org/project/msgpack/</a>
</li>

<li>MessagePack na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/MessagePack">https://en.wikipedia.org/wiki/MessagePack</a>
</li>

<li>Comparison of data-serialization formats (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats">https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats</a>
</li>

<li>Repositáře msgpacku<br />
<a href="https://github.com/msgpack">https://github.com/msgpack</a>
</li>

<li>Specifikace ukládání různých typů dat<br />
<a href="https://github.com/msgpack/msgpack/blob/master/spec.md">https://github.com/msgpack/msgpack/blob/master/spec.md</a>
</li>

<li>Podpora MessagePacku v&nbsp;různých programovacích jazycích<br />
<a href="https://msgpack.org/#languages">https://msgpack.org/#languages</a>
</li>

<li>Základní implementace formátu msgpack pro programovací jazyk Go<br />
<a href="https://github.com/msgpack/msgpack-go">https://github.com/msgpack/msgpack-go</a>
</li>

<li>go-codec<br />
<a href="https://github.com/ugorji/go">https://github.com/ugorji/go</a>
</li>

<li>Gobs of data (odlišný serializační formát)<br />
<a href="https://blog.golang.org/gobs-of-data">https://blog.golang.org/gobs-of-data</a>
</li>

<ol>
<li>Formát BSON (odlišný serializační formát)<br />
<a href="http://bsonspec.org/">http://bsonspec.org/</a>
</li>

<li>Problematika nulových hodnot v Go, aneb proč nil != nil<br />
<a href="https://www.root.cz/clanky/problematika-nulovych-hodnot-v-go-aneb-proc-nil-nil/">https://www.root.cz/clanky/problematika-nulovych-hodnot-v-go-aneb-proc-nil-nil/</a>
</li>

<li>IEEE-754 Floating Point Converter<br />
<a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">https://www.h-schmidt.net/FloatConverter/IEEE754.html</a>
</li>

<li>Base Convert: IEEE 754 Floating Point<br />
<a href="https://baseconvert.com/ieee-754-floating-point">https://baseconvert.com/ieee-754-floating-point</a>
</li>

<li>Brain Floating Point &ndash; nový formát uložení čísel pro strojové učení a chytrá čidla<br />
<a href="https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/">https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/</a>
</li>

<li>Marshalling (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
</li>

<li>Protocol Buffers<br />
<a href="https://protobuf.dev/">https://protobuf.dev/</a>
</li>

<li>Protocol Buffers<br />
<a href="https://en.wikipedia.org/wiki/Protocol_Buffers">https://en.wikipedia.org/wiki/Protocol_Buffers</a>
</li>

<li>What is the difference between Serialization and Marshaling?<br />
<a href="https://stackoverflow.com/questions/770474/what-is-the-difference-between-serialization-and-marshaling">https://stackoverflow.com/questions/770474/what-is-the-difference-between-serialization-and-marshaling</a>
</li>

<li>Comparison of data-serialization formats<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats">https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

