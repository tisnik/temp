<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Komunikace realizovaná úsporným binárním formátem MessagePack</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Komunikace realizovaná úsporným binárním formátem MessagePack</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Pro komunikaci mezi službami se v současnosti využívá relativně velké množství (serializačních) formátů. Ty můžeme rozdělit na formáty textové (JSON, XML) a binární. A mezi binární formáty patří mj. i MessagePack, s jehož základními vlastnostmi se seznámíme v dnešním článku.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Komunikace realizovaná úsporným binárním formátem MessagePack</a></p>
<p><a href="#k02">2. Formát MessagePack</a></p>
<p><a href="#k03">3. Některá omezení formátu MessagePack</a></p>
<p><a href="#k04">4. Alternativní binární formáty</a></p>
<p><a href="#k05">5. Praktická část &ndash; uložení hodnot různých typů do formátu MessagePack</a></p>
<p><a href="#k06">6. Jednoduché datové typy</a></p>
<p><a href="#k07">7. Serializace hodnoty <strong>nil</strong></a></p>
<p><a href="#k08">8. Serializace hodnot <strong>true</strong> a <strong>false</strong></a></p>
<p><a href="#k09">9. Serializace celočíselných hodnot</a></p>
<p><a href="#k10">10. Hodnoty s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k11">11. Složené datové typy</a></p>
<p><a href="#k12">12. Krátké řetězce</a></p>
<p><a href="#k13">13. Dlouhé řetězce</a></p>
<p><a href="#k14">14. Krátká pole</a></p>
<p><a href="#k15">15. Delší pole</a></p>
<p><a href="#k16">16. Celočíselné hodnoty se znaménkem vs. hodnoty bez znaménka</a></p>
<p><a href="#k17">17. Serializace map</a></p>
<p><a href="#k18">18. Co dále?</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Komunikace realizovaná úsporným binárním formátem MessagePack</h2>

<p>V&nbsp;dnešním článku se zaměříme na popis serializačního formátu
<i>MessagePack</i>. Jedná se o jeden z&nbsp;formátů určených pro serializaci a
deserializaci dat různých typů s&nbsp;jejich případným přenosem do jiné
aplikace či služby. Přenosem se přitom v&nbsp;tomto kontextu myslí jak lokální
komunikace, tak i přenos do služby běžící na jiném počítači. Již dříve jsme se
ve stručnosti seznámili s&nbsp;využitím formátu JSON a nepřímo taktéž
s&nbsp;formátem TOML používaným typicky pro konfigurační soubory (a mnohem méně
často pro rozsáhlejší data). V&nbsp;případě JSONu se jedná o poměrně důležitý
formát, protože JSON (a samozřejmě též XML) se v&nbsp;současnosti používá
v&nbsp;mnoha webových službách a i když stále vznikají a jsou postupně
adaptovány další formáty, ať již textové (<a href="https://yaml.org/">YAML</a>,
<a href="https://github.com/edn-format/edn">edn</a>) či binární (<a
href="http://bsonspec.org/">BSON</a>, <a href="http://bjson.org/">B-JSON</a>,
<a href="https://github.com/FasterXML/smile-format-specification">Smile</a>, <a
href="https://developers.google.com/protocol-buffers/">Protocol-Buffers</a>),
<a href="https://github.com/fxamacker/cbor">CBOR</a> atd., je velmi
pravděpodobné, že se JSON bude i nadále poměrně masivně využívat. Nicméně
pochopitelně existují situace, v&nbsp;nichž je vhodné textový a relativně
neúsporný JSON nahradit právě nějakým binárním formátem.</p>

<p>I přesto, že se s&nbsp;výše uvedenými formáty JSON a XML setkáme prakticky
ve všech oblastech moderního IT, nemusí se vždy jednat o to nejlepší možné
řešení problému přenosu strukturovaných dat. Tyto formáty totiž data neukládají
v&nbsp;kompaktní binární podobě a navíc je parsing numerických hodnot relativně
zdlouhavý, což se projevuje zejména tehdy, pokud je nutné zpracovat skutečně
obrovské množství dat (buď mnoho malých zpráv či událostí, nebo naopak rozsáhlé
datové soubory). A právě v&nbsp;těchto situacích může být výhodnější sáhnout po
nějakém vhodně navrženém binárním formátu. Těch již dnes existuje velké
množství, od staršího a dosti těžkopádného ASN.1 (<i>Abstract Syntax Notation
One</i>) po formáty, které se snaží napodobit některé vlastnosti JSONu.
Příkladem může být formát <i>CBOR</i>, jenž je mj.&nbsp;podporován knihovnou <a
href="https://github.com/fxamacker/cbor">https://github.com/fxamacker/cbor</a>,
popř.&nbsp;formát <i>BSON</i>. A konečně, ve se především ve světě Go setkáme i
s&nbsp;formátem nazvaným <i>gob</i> neboli <i>Go Objects</i>.</p>

<p>Jednou z&nbsp;&bdquo;binárních alternativ&ldquo; k&nbsp;formátu JSON je u
formát <i>MessagePack</i>, s&nbsp;jehož základními vlastnostmi se seznámíme
v&nbsp;navazujících kapitolách.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Formát MessagePack</h2>

<p>Formát <i>MessagePack</i> je navržen takovým způsobem, aby byl
&bdquo;binárním protějškem&ldquo; známého a velmi často využívaného formátu
JSON, ovšem s&nbsp;několika vylepšeními. Binární formát MessagePack umožňuje
serializovat (ukládat) následující datové typy a pochopitelně i jejich
kombinace (protože mnohé datové typy jsou vlastně kontejnery pro hodnoty
dalších typů):</p>

<ol>

<li>Hodnotu <strong>nil</strong> odpovídající v&nbsp;JSONu hodnotě
<strong>null</strong></li>

<li>Pravdivostní hodnoty <strong>true</strong> a <strong>false</strong></li>

<li>Celá čísla (<i>integer</i>) s&nbsp;různou binární délkou (malé hodnoty jsou
uloženy v&nbsp;optimalizované podobě)</li>

<li>Čísla s&nbsp;plovoucí řádovou čárkou v&nbsp;jednoduché i dvojité přesnosti
(včetně všech speciálních hodnot)</li>

<li>Řetězce, přičemž krátké řetězce jsou uloženy optimalizovaně</li>

<li>Sekvence bajtů</li>

<li>Pole, jejichž prvky jsou prakticky jakéhokoli typu</li>

<li>Mapy, jejichž klíče i prvky jsou prakticky jakéhokoli typu (rozšíření
JSONu)</li>

<li>Časová razítka (to je důležité, JSON tuto možnost postrádá)</li>

<li>Rozšíření (dvojice s&nbsp;typovou informací a hodnotou)</li>

</ol>



<p><a name="k03"></a></p>
<h2 id="k03">3. Některá omezení formátu MessagePack</h2>

<p>Možnosti formátu <i>MessagePack</i> skutečně do značné míry odpovídají
možnostem JSONu s&nbsp;několika rozšířeními zmíněnými výše. Ovšem musíme se
zmínit i o některých principiálních omezeních, z&nbsp;nichž některé jsou
společné i dalším často používaným serializačním formátům (nehledě na to, zda
jsou textové či binární):</p>

<ol>

<li>celá čísla mohou nabývat hodnoty z&nbsp;rozsahu -2<sup>63</sup> až
2<sup>64</sup>-1 (to není chyba &ndash; pro kladné hodnoty existuje formát bez
znaménka)</li>

<li>maximální délka řetězců je rovna 4GB (což v&nbsp;praxi nebude velké
omezení)</li>

<li>maximální délka binárního bloku je taktéž rovna 4GB (což již může
vadit)</li>

<li>maximální počet prvků v&nbsp;poli je roven 2<sup>32</sup>-1</li>

<li>maximální počet dvojic klíč-hodnota v&nbsp;mapě je roven
2<sup>32</sup>-1</li>

<li>nelze ukládat ukazatele a tím pádem ani přímo pracovat se stromy, obecnými
grafy atd. Tento nedostatek se částečně dá nahradit mapami.</li>

<li>co je ze sémantického hlediska poněkud problematické &ndash; není
podporován typ &bdquo;množina&ldquo;</li>

</ol>

<p><div class="rs-tip-major">Poznámka: podrobnosti o tom, jak jsou ukládány
jednotlivé typy hodnot, si ukážeme ve druhé (prakticky zaměření) části
článku.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Alternativní binární formáty</h2>

<p>Jak jsme se již zmínili <a href="#k01">v&nbsp;úvodní kapitole</a>, existuje
ve skutečnosti mnohem větší množství binárních formátů používaných jak pro
serializaci dat, tak i pro komunikaci mezi různými službami
(resp.&nbsp;přesněji řečeno pro posílání dat/zpráv mezi službami). Alespoň
krátce se tedy o některých z&nbsp;těchto formátů zmiňme.</p>

<p>Prvním alternativním binárním formátem, s&nbsp;nímž se setkáme, je formát
nazvaný <i>gob</i> neboli <i>Go Objects</i>. Jedná se o formát určený primárně
pro použití v&nbsp;programovacím jazyku Go, což znamená, že jeho využití je
relativně specifické (ukládání rozsáhlých dat, komunikace mezi dvojicí služeb
naprogramovaných v&nbsp;Go atd.). Tento formát umožňuje serializaci prakticky
jakékoli datové struktury, ovšem je ho možné použít i pro primitivní datové
typy, resp.&nbsp;pro jejich hodnoty.</p>

<p>Dalším binárním formátem určeným pro přenos prakticky libovolně
strukturovaných dat je formát nazvaný <i>CBOR</i> neboli plným jménem
<i>Concise Binary Object Representation</i>. Tímto formátem, jenž se snaží
nabízet podobné vlastnosti jako JSON (až na možnost jeho přímého čtení
člověkem), se budeme zabývat v&nbsp;navazujícím textu (interně je nepatrně
složitější než MessagePack).</p>

<p><p>Dalším sice relativně novým, ale postupně se rozšiřujícím binárním
formátem je formát nazvaný <i>BSON</i> (zde je odkaz na JSON nesporný).
Možnosti tohoto formátu jsou již větší, například je podporován typ
<i>decimal128</i> určený pro použití v&nbsp;bankovnictví. Taktéž podporuje
uložení časových razítek nebo i kódu v&nbsp;JavaScriptu.</p>

<p><div class="rs-tip-major">Poznámka: zajímavé je, že ani jeden
z&nbsp;uvedených binárních formátů nepodporuje typ <a
href="https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/">bfloat16</a>,
i když zrovna v&nbsp;této oblasti se jeho použití přímo nabízí.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Praktická část &ndash; uložení hodnot různých typů do formátu MessagePack</h2>

<p>V&nbsp;praktické části dnešního článku si ukážeme, jakým způsobem jsou
uloženy hodnoty různých typů do dat (souborů, proudů bajtů...) ve formátu
<i>MessagePack</i>. Demonstrační příklady budou naprogramovány <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">v&nbsp;jazyku Go</a>,
ovšem zvolit je možné jakýkoli jazyk a knihovnu zmíněnou na stránce <a
href="https://msgpack.org/#languages">https://msgpack.org/#languages</a>.</p>

<p>Nejprve získáme knihovnu, která serializaci a deserializaci do formátu
MessagePack realizuje:</p>

<pre>
$ <strong>go get github.com/ugorji/go/codec</strong>
&nbsp;
go: downloading github.com/ugorji/go/codec v1.2.6
go: downloading github.com/ugorji/go v1.2.6
</pre>

<p>Alternativně můžeme vytvořit nový projekt (tedy soubor
<strong>go.mod</strong>):</p>

<pre>
module msgpack-test
&nbsp;
go 1.17
&nbsp;
require github.com/ugorji/go/codec v1.2.6 // indirect
</pre>

<p><div class="rs-tip-major">Poznámka: lze použít i další knihovny, například
<a href="https://github.com/shamaton/msgpack">tuto</a>. Výše uvedenou knihovnu
jsem vybral mj.&nbsp;i proto, že podporuje i další formáty a navíc je možné
provádět serializaci a deserializaci dat do/z kanálu a tedy přímo v&nbsp;Go
velmi snadno realizovat proudové zpracování dat (<i>streaming</i>.</div></p>

<p>Pro prohlížení obsahu vytvořených binárních souborů lze použít například
nějakou formu <i>hexadecimálního prohlížeče</i>. Hexadecimálních prohlížečů a
editorů existuje (pro Linux) relativně velké množství. První dva nástroje
nazvané <strong>od</strong> a <strong>hexdump</strong> (zkráceně
<strong>hd</strong>) pracují jako relativně jednoduché jednosměrné filtry
(navíc bývají nainstalovány společně se základním sadou nástrojů), ovšem další
nástroj pojmenovaný <strong>xxd</strong> již může být použit pro obousměrný
převod (filtraci), tj.&nbsp;jak pro transformaci původního binárního souboru do
čitelného tvaru (většinou s&nbsp;využitím šestnáctkové soustavy), tak i pro
zpětný převod. Díky tomu je možné <strong>xxd</strong> použít například ve
funkci pluginu do běžných textových editorů. Další nástroj pojmenovaný
<strong>hexdiff</strong> dokáže porovnat obsah dvou binárních souborů a
poslední zmíněný nástroj <strong>mcview</strong> je, na rozdíl od předchozí
čtveřice, aplikací s&nbsp;interaktivním ovládáním a plnohodnotným textovým
uživatelským prostředím.</p>

<p><div class="rs-tip-major">Poznámka: dnes si vystačíme s&nbsp;možnostmi
nabízenými nástrojem <strong>od</strong> neboli <i>octal dump</i>. Jméno tohoto
nástroje je ve skutečnosti zavádějící, protože dokáže zobrazit obsah binárního
soubory mnoha různými způsoby. Již fakt, že jméno této utility má pouhá dvě
písmena, napovídá, že se jedná o nástroj pocházející již z&nbsp;prvních verzí
Unixu. Původní varianty utility <strong>od</strong> vypisovaly obsah zvoleného
souboru (alternativně standardního vstupu či zvoleného zařízení)
s&nbsp;využitím osmičkové soustavy, ovšem GNU verze <strong>od</strong> nabízí
uživatelům mnohem víc možností, a to včetně včetně použití hexadecimální
soustavy (ostatně i proto o této utilitě dnes píšeme), zformátování sousedních
čtyř bajtů do čísla typu <i>single/float</i>, dtto pro osm bajtů a čísla typu
<i>double</i> apod.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Jednoduché datové typy</h2>

<p>Do binárního formátu <i>MessagePack</i> lze ukládat jak hodnoty jednoduchých
datových typů, tak i hodnoty složených datových typů (což jsou různé typy
kontejnerů). Začneme jednoduchými datovými typy, protože binární formát
<i>MessagePack</i> je navržen takovým způsobem, aby byl způsob jejich uložení
v&nbsp;co největší míře efektivní &ndash; a to nejenom co se týká celkového
objemu dat, ale i jednoduchosti nebo naopak složitosti zakódování a dekódování
hodnot. Podporovány jsou tyto jednoduché datové typy:</p>

<ol>
<li>Typ <strong>none</strong> s&nbsp;jedinou hodnotou <strong>nil</strong></li>
<li>Typ <strong>boolean</strong> s&nbsp;hodnotami <strong>true</strong> a <strong>false</strong></li>
<li>Typ <strong>unsigned integer</strong> s&nbsp;plně 64 bitovým rozsahem</li>
<li>Typ <strong>signed integer</strong> s&nbsp;plně 64 bitovým rozsahem</li>
<li>Typ <strong>float/single/float32</strong> s&nbsp;plovoucí řádovou čárkou</li>
<li>Typ <strong>double/float64</strong> s&nbsp;plovoucí řádovou čárkou</li>
</ol>



<p><a name="k07"></a></p>
<h2 id="k07">7. Serializace hodnoty <strong>nil</strong></h2>

<p>Začneme tím nejjednodušším možným příkladem, a to konkrétně způsobem
serializace hodnoty <strong>nil</strong>. Ta je použita stejným způsobem jako
hodnota <strong>null</strong> v&nbsp;JSONu, tedy pro indikaci chybějících dat.
Přitom <strong>nil</strong> není přiřazeno k&nbsp;datovému typu, <a
href="https://www.root.cz/clanky/problematika-nulovych-hodnot-v-go-aneb-proc-nil-nil/">na
rozdíl od samotného jazyka Go</a>. Celý příklad se skládá z&nbsp;několika
operací:</p>

<ol>

<li>Vytvoření a otevření nového (binárního) souboru pro zápis s&nbsp;kontrolou,
zda byla operace úspěšná</li>

<li>Konstrukce objektu/struktury použité pro serializaci</li>

<li>Vlastní serializace dat, opět s&nbsp;kontrolou, zda byla operace
úspěšná</li>

</ol>

<p>Úplný zdrojový kód tohoto demonstračního příkladu vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "os"
&nbsp;
        "github.com/ugorji/go/codec"
)
&nbsp;
const filename = "/tmp/nil.bin"
&nbsp;
func <strong>main</strong>() {
        <i>// vytvořit soubor s binárními daty</i>
        fout, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil {
                log.Fatal(err)
        }
        defer fout.Close()
&nbsp;
        log.Print("Output file created")
&nbsp;
        <i>// handler</i>
        var handler codec.MsgpackHandle
&nbsp;
        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(fout, &amp;handler)
&nbsp;
        log.Print("Encoder created")
&nbsp;
        <i>// zakódování dat</i>
        err = <u>encoder.Encode(nil)</u>
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        log.Print("Done")
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že metodě
<strong>encoder.Encoder</strong> je možné předat hodnotu libovolného
typu.</div></p>

<p>Výsledkem bude binární soubor obsahující jediný bajt:</p>

<pre>
$ <strong>od -A x -t x1 -v nil.bin</strong>
&nbsp;
000000 c0
000001
</pre>

<p>To <a
href="https://github.com/msgpack/msgpack/blob/master/spec.md#nil-format">plně
odpovídá specifikaci</a>.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Serializace hodnot <strong>true</strong> a <strong>false</strong></h2>

<p>Ve formátu MessagePack jsou plně podporovány i hodnoty <strong>true</strong>
a <strong>false</strong>, což znamená, že není nutné (ani ze sémantického
pohledu rozumné) používat pro reprezentaci pravdivostních hodnot například
hodnoty 0 a 1 či 0 a -1. Navíc jsou pravdivostní hodnoty uloženy relativně
rozumným způsobem &ndash; v&nbsp;jediném bajtu. O tom se budeme moci velmi
snadno přesvědčit:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "os"

        "github.com/ugorji/go/codec"
)
&nbsp;
const filename = "/tmp/true.bin"
&nbsp;
func <strong>main</strong>() {
        <i>// vytvořit soubor s binárními daty</i>
        fout, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil {
                log.Fatal(err)
        }
        defer fout.Close()
&nbsp;
        log.Print("Output file created")
&nbsp;
        <i>// handler</i>
        var handler codec.MsgpackHandle
&nbsp;
        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(fout, &amp;handler)
&nbsp;
        log.Print("Encoder created")
&nbsp;
        <i>// zakódování dat</i>
        err = <u>encoder.Encode(true)</u>
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        log.Print("Done")
}
</pre>

<p>Nyní se podívejme na to, jak jsou tyto dvě hodnoty uloženy do výsledného
souboru:</p>

<pre>
$ <strong>od -A x -t x1 -v true.bin</strong>
&nbsp;
000000 c3
000001
&nbsp;
&nbsp;
$ <strong>od -A x -t x1 -v false.bin</strong>
&nbsp;
000000 c2
000001
</pre>

<p>Což opět plně odpovídá <a
href="https://github.com/msgpack/msgpack/blob/master/spec.md#bool-format-family">specifikaci</a>.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;dalších kapitolách již většinou
nebudeme uvádět úplný zdrojový kód demonstračních příkladů. Namísto toho se
spokojíme pouze s&nbsp;uvedením té nejdůležitější části &ndash; vlastní
serializace dat. To znamená, že předchozí dva příklady bychom zkrátili na
pouhých několik řádků:</div></p>

<pre>
<i>// zakódování dat</i>
err = <u>encoder.Encode(false)</u>
if err != nil {
        log.Fatal(err)
}
</pre>

<p>a:</p>

<pre>
<i>// zakódování dat</i>
err = <u>encoder.Encode(true)</u>
if err != nil {
        log.Fatal(err)
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Serializace celočíselných hodnot</h2>

<p>Prozatím dosti nudné téma poněkud zpestříme, protože si ukážeme způsob
serializace celočíselných hodnot. V&nbsp;tomto ohledu museli tvůrci formátu
<i>MessagePack</i> splnit dva protichůdné požadavky:</p>

<ol>
<li>reprezentovat co největší rozsah hodnot, ideálně 64bitové hodnoty</li>
<li>na druhou stranu je použití 64bitů (8 bajtů) ve všech případech až trestuhodné plýtvání místem (a to i oproti textovému JSONu)</li>
</ol>

<p>Výsledkem snahy o splnění obou požadavků je flexibilní způsob uložení celých
čísel v&nbsp;jednom, dvou, třech, pěti či devíti bajtech &ndash; vždy
v&nbsp;závislosti na konkrétní hodnotě a taktéž na tom, zda se jedná o hodnotu
kladnou či zápornou. <a
href="https://github.com/msgpack/msgpack/blob/master/spec.md#int-format-family">Specifikace
uložení celých čísel</a> ve skutečnosti není příliš složitá a můžeme si ji
snadno otestovat.</p>

<p><div class="rs-tip-major">Poznámka: povšimněte si striktního použití pořadí
bajtů <i>big endian</i>!</div></p>

<p>Uložení malého celého čísla:</p>

<pre>
<i>// zakódování dat</i>
err = encoder.Encode(42)
if err != nil {
        log.Fatal(err)
}
</pre>

<p>Výsledkem je v&nbsp;tomto případě pouhý jeden bajt, který obsahuje jak
informace o datovém typu, tak i vlastní hodnotu:</p>

<pre>
$ <strong>od -A x -t x1 -v small_int.bin</strong>
&nbsp;
000000 2a
000001
</pre>

<p>Uložení čísla většího než 127, ale menšího než 2<sup>16</sup>:</p>

<pre>
<i>// zakódování dat</i>
err = encoder.Encode(1000)
if err != nil {
        log.Fatal(err)
}
</pre>

<p>Nyní je hodnota uložena do třech bajtů. V&nbsp;prvním bajtu je deklarace
typu, druhé dva bajty reprezentují hodnotu 0x3e8 = 1000:</p>

<pre>
$ <strong>od -A x -t x1 -v longer_int.bin</strong>
&nbsp;
000000 d1 03 e8
000003
</pre>

<p>Číslo větší než 2<sup>16</sup>:</p>

<pre>
<i>// zakódování dat</i>
err = encoder.Encode(100000)
if err != nil {
        log.Fatal(err)
}
</pre>

<p>Opět je použit jeden bajt se specifikací typu, za kterým následuje čtveřice
bajtů 0x0186a0 = 100000:</p>

<pre>
$ <strong>od -A x -t x1 -v even_longer_int.bin</strong>
&nbsp;
000000 d2 00 01 86 a0
000005
</pre>

<p>A konečně hodnota 2<sup>60</sup>:</p>

<pre>
<i>// zakódování dat</i>
err = encoder.Encode(2 &lt;&lt; 60)
if err != nil {
        log.Fatal(err)
}
</pre>

<p>Jedná se o 64bitovou hodnotu uloženou v&nbsp;devíti bajtech:</p>

<pre>
$ <strong>od -A x -t x1 -v long_int.bin</strong>
&nbsp;
000000 d3 20 00 00 00 00 00 00 00
000009
</pre>

<p><div class="rs-tip-major">Poznámka: podobné příklady lze vytvořit i pro
záporná čísla.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Hodnoty s&nbsp;plovoucí řádovou čárkou</h2>

<p>Ve formátu MessagePack jsou podle očekávání podporovány i hodnoty
s&nbsp;plovoucí řádovou čárkou. Jedná se jak o hodnoty s&nbsp;jednoduchou
přesností (<i>single</i>, <i>float</i>, <i>float32</i>), tak i o hodnoty
s&nbsp;dvojitou přesností (<i>double</i>, <i>float64</i>). Nejprve si ukažme
způsob uložení hodnot s&nbsp;jednoduchou přesností, což v&nbsp;jazyce Go
odpovídá datovému typu <strong>float32</strong>:</p>

<pre>
<i>// zakódování dat</i>
err = encoder.Encode(float32(3.14))
if err != nil {
        log.Fatal(err)
}
</pre>

<p>Výsledkem je soubor s&nbsp;pěti bajty. První bajt opět obsahuje typ dat,
další čtyři bajty pak vlastní hodnotu:</p>

<pre>
$ <strong>od -A x -t x1 -v single.bin</strong>
&nbsp;
000000 ca 40 48 f5 c3
000005
</pre>

<p><div class="rs-tip-major">Poznámka: čtveřici bajtů se zakódovanou hodnotou
si můžete ověřit například <a
href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">na této
stránce</a> nebo ještě lépe <a
href="https://baseconvert.com/ieee-754-floating-point">zde</a> po zadání vstupu
3.14.</div></p>

<p>Uložení hodnoty s&nbsp;dvojitou přesností:</p>

<pre>
<i>// zakódování dat</i>
err = encoder.Encode(3.14)
if err != nil {
        log.Fatal(err)
}
</pre>

<p>Výsledkem je soubor s&nbsp;devíti bajty, jehož struktura je (až na odlišný
typ) totožná s&nbsp;předchozím souborem:</p>

<pre>
$ <strong>od -A x -t x1 -v double.bin</strong>
&nbsp;
000000 cb 40 09 1e b8 51 eb 85 1f
000009
</pre>

<p><div class="rs-tip-major">Poznámka: výsledek si můžete ověřit <a
href="https://baseconvert.com/ieee-754-floating-point">na této
stránce</a>.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Složené datové typy</h2>

<p>Po popisu způsobu uložení jednoduchých datových typů (což nebylo nic
složitého) si ukážeme, jakým způsobem je v&nbsp;MessagePacku realizováno
uložení složených datových typů. Do této kategorie se řadí především řetězce,
sekvence bajtů, pole, ale v&nbsp;neposlední řadě i velmi důležité mapy, které
lze použít například pro uložení atributů objektů. Opět uvidíme, že u některých
výše zmíněných datových typů je dbáno na efektivitu výsledného binárního
souboru, a to jak z&nbsp;hlediska celkového objemu dat, tak i složitosti
kódování a dekódování těchto dat.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Krátké řetězce</h2>

<p>Takřka nepostradatelným složeným datovým typem jsou řetězce. Interně se pro
jejich uložení používá UTF-8. Neméně důležitá je však informace o tom, jak
dlouhý řetězec je. Délka řetězce je uložena před vlastní znaky a to konkrétně
tak, že pro krátké řetězce je délka uložena přímo v&nbsp;bajtu se specifikací
typu (tedy neztratíme <i>ani jediný bajt</i>!) a pro delší řetězce je délka
uložena v&nbsp;jednom, dvou či čtyřech bajtech.</p>

<p>Velmi krátký řetězec, menší než 31 bajtů (nikoli znaků!):</p>

<pre>
const message = "Hello"
&nbsp;
<i>// zakódování dat</i>
err = encoder.Encode(message)
if err != nil {
        log.Fatal(err)
}
</pre>

<p>V&nbsp;tomto případě je délka řetězce uložena v&nbsp;prvním bajtu, přičemž
první tři bity tohoto bajtu určují datový typ:</p>

<pre>
$ <strong>od -A x -t x1z -v short_string.bin</strong>
&nbsp;
000000 a5 48 65 6c 6c 6f                                &lt;.Hello&gt;
000006
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Dlouhé řetězce</h2>

<p>Vyzkoušejme si nyní poněkud delší řetězec:</p>

<pre>
const message = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."
&nbsp;
<i>// zakódování dat</i>
err = encoder.Encode(message)
if err != nil {
        log.Fatal(err)
}
</pre>

<p>V&nbsp;tomto případě je první bajt roven konstantě 0xda. Za ní následují dva
bajty s&nbsp;délkou řetězce v&nbsp;bajtech, konkrétně celkem 0xe7=231 bajtů. A
poté již vlastní znaky tvořící řetězec:</p>

<pre>
$ <strong>od -A x -t x1z -v longer_string.bin</strong>
&nbsp;
000000 da 00 e7 4c 6f 72 65 6d 20 69 70 73 75 6d 20 64  &gt;...Lorem ipsum d&lt;
000010 6f 6c 6f 72 20 73 69 74 20 61 6d 65 74 2c 20 63  &gt;olor sit amet, c&lt;
000020 6f 6e 73 65 63 74 65 74 75 72 20 61 64 69 70 69  &gt;onsectetur adipi&lt;
000030 73 63 69 6e 67 20 65 6c 69 74 2c 20 73 65 64 20  &gt;scing elit, sed &lt;
000040 64 6f 20 65 69 75 73 6d 6f 64 20 74 65 6d 70 6f  &gt;do eiusmod tempo&lt;
000050 72 20 69 6e 63 69 64 69 64 75 6e 74 20 75 74 20  &gt;r incididunt ut &lt;
000060 6c 61 62 6f 72 65 20 65 74 20 64 6f 6c 6f 72 65  &gt;labore et dolore&lt;
000070 20 6d 61 67 6e 61 20 61 6c 69 71 75 61 2e 20 55  &gt; magna aliqua. U&lt;
000080 74 20 65 6e 69 6d 20 61 64 20 6d 69 6e 69 6d 20  &gt;t enim ad minim &lt;
000090 76 65 6e 69 61 6d 2c 20 71 75 69 73 20 6e 6f 73  &gt;veniam, quis nos&lt;
0000a0 74 72 75 64 20 65 78 65 72 63 69 74 61 74 69 6f  &gt;trud exercitatio&lt;
0000b0 6e 20 75 6c 6c 61 6d 63 6f 20 6c 61 62 6f 72 69  &gt;n ullamco labori&lt;
0000c0 73 20 6e 69 73 69 20 75 74 20 61 6c 69 71 75 69  &gt;s nisi ut aliqui&lt;
0000d0 70 20 65 78 20 65 61 20 63 6f 6d 6d 6f 64 6f 20  &gt;p ex ea commodo &lt;
0000e0 63 6f 6e 73 65 71 75 61 74 2e                    &gt;consequat.&lt;
0000ea
</pre>

<p><div class="rs-tip-major">Poznámka: zde by ve skutečnosti knihovna měla
resp.&nbsp;mohla zvolit řetězec s&nbsp;délkou menší než 256 bajtů a tedy typ
<strong>0xd9</strong> namísto typu <strong>0x9a</strong> &ndash; viz též <a
href="https://github.com/msgpack/msgpack/blob/master/spec.md#str-format-family">https://github.com/msgpack/msgpack/blob/master/spec.md#str-format-family</a>.</div></p>

<p>Zakódování řetězce, který je skutečně delší než 256 bajtů, ale kratší než
2<sup>16</sup> bajtů:</p>

<pre>
const message = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."
&nbsp;
<i>// zakódování dat</i>
err = encoder.Encode(message)
if err != nil {
        log.Fatal(err)
}
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
$ <strong>od -A x -t x1z -v even_longer_string.bin</strong>
&nbsp;
000000 da 01 bd 4c 6f 72 65 6d 20 69 70 73 75 6d 20 64  &gt;...Lorem ipsum d&lt;
000010 6f 6c 6f 72 20 73 69 74 20 61 6d 65 74 2c 20 63  &gt;olor sit amet, c&lt;
000020 6f 6e 73 65 63 74 65 74 75 72 20 61 64 69 70 69  &gt;onsectetur adipi&lt;
000030 73 63 69 6e 67 20 65 6c 69 74 2c 20 73 65 64 20  &gt;scing elit, sed &lt;
000040 64 6f 20 65 69 75 73 6d 6f 64 20 74 65 6d 70 6f  &gt;do eiusmod tempo&lt;
000050 72 20 69 6e 63 69 64 69 64 75 6e 74 20 75 74 20  &gt;r incididunt ut &lt;
000060 6c 61 62 6f 72 65 20 65 74 20 64 6f 6c 6f 72 65  &gt;labore et dolore&lt;
000070 20 6d 61 67 6e 61 20 61 6c 69 71 75 61 2e 20 55  &gt; magna aliqua. U&lt;
000080 74 20 65 6e 69 6d 20 61 64 20 6d 69 6e 69 6d 20  &gt;t enim ad minim &lt;
000090 76 65 6e 69 61 6d 2c 20 71 75 69 73 20 6e 6f 73  &gt;veniam, quis nos&lt;
0000a0 74 72 75 64 20 65 78 65 72 63 69 74 61 74 69 6f  &gt;trud exercitatio&lt;
0000b0 6e 20 75 6c 6c 61 6d 63 6f 20 6c 61 62 6f 72 69  &gt;n ullamco labori&lt;
0000c0 73 20 6e 69 73 69 20 75 74 20 61 6c 69 71 75 69  &gt;s nisi ut aliqui&lt;
0000d0 70 20 65 78 20 65 61 20 63 6f 6d 6d 6f 64 6f 20  &gt;p ex ea commodo &lt;
0000e0 63 6f 6e 73 65 71 75 61 74 2e 20 44 75 69 73 20  &gt;consequat. Duis &lt;
0000f0 61 75 74 65 20 69 72 75 72 65 20 64 6f 6c 6f 72  &gt;aute irure dolor&lt;
000100 20 69 6e 20 72 65 70 72 65 68 65 6e 64 65 72 69  &gt; in reprehenderi&lt;
000110 74 20 69 6e 20 76 6f 6c 75 70 74 61 74 65 20 76  &gt;t in voluptate v&lt;
000120 65 6c 69 74 20 65 73 73 65 20 63 69 6c 6c 75 6d  &gt;elit esse cillum&lt;
000130 20 64 6f 6c 6f 72 65 20 65 75 20 66 75 67 69 61  &gt; dolore eu fugia&lt;
000140 74 20 6e 75 6c 6c 61 20 70 61 72 69 61 74 75 72  &gt;t nulla pariatur&lt;
000150 2e 20 45 78 63 65 70 74 65 75 72 20 73 69 6e 74  &gt;. Excepteur sint&lt;
000160 20 6f 63 63 61 65 63 61 74 20 63 75 70 69 64 61  &gt; occaecat cupida&lt;
000170 74 61 74 20 6e 6f 6e 20 70 72 6f 69 64 65 6e 74  &gt;tat non proident&lt;
000180 2c 20 73 75 6e 74 20 69 6e 20 63 75 6c 70 61 20  &gt;, sunt in culpa &lt;
000190 71 75 69 20 6f 66 66 69 63 69 61 20 64 65 73 65  &gt;qui officia dese&lt;
0001a0 72 75 6e 74 20 6d 6f 6c 6c 69 74 20 61 6e 69 6d  &gt;runt mollit anim&lt;
0001b0 20 69 64 20 65 73 74 20 6c 61 62 6f 72 75 6d 2e  &gt; id est laborum.&lt;
0001c0
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Krátká pole</h2>

<p>Pole, a to pole prvků libovolných typů, se do formátu MessagePack opět
ukládá podle toho, kolik prvků takové pole obsahuje. Pole s&nbsp;prvky, jejichž
počet nepřesáhne patnáct, obsahuje pouze jediný bajt navíc. Obsah tohoto bajtu
určuje, že se jedná o pole a současně i ve spodních čtyřech bitech obsahuje
počet prvků pole.</p>

<pre>
var values []int = <strong>[]int{1, 2, 3, 4}</strong>
&nbsp;
<i>// zakódování dat</i>
err = encoder.Encode(values)
if err != nil {
        log.Fatal(err)
}
</pre>

<p>Výše uvedené pole se čtyřmi prvky je uloženo v&nbsp;pouhých pěti bajtech a
to z&nbsp;toho důvodu, že hodnoty prvků samy o sobě mají tak malou hodnotu, že
každý z&nbsp;nich může být uložen v&nbsp;jediném bajtu:</p>

<pre>
$ <strong>od -A x -t x1 -v short_array.bin</strong>
&nbsp;
000000 94 01 02 03 04
000005
</pre>

<p>Naproti tomu druhé serializované pole již obsahuje prvky s&nbsp;relativně
vyššími hodnotami:</p>

<pre>
var values []int = <strong>[]int{100, 200, 300, 400}</strong>
&nbsp;
<i>// zakódování dat</i>
err = encoder.Encode(values)
if err != nil {
        log.Fatal(err)
}
</pre>

<p>Nyní bude soubor delší, protože již některé prvky nelze uložit do jediného
bajtu:</p>

<pre>
$ <strong>od -A x -t x1 -v short_array2.bin</strong>
&nbsp;
000000 94 64 d1 00 c8 d1 01 2c d1 01 90
00000b
</pre>

<p>V&nbsp;tomto případě první bajt obsahuje typ (pole) s&nbsp;jeho délkou.
Následuje bajt s&nbsp;hodnotou 0x64=100, tedy první prvek (jediný bajt), další
prvek je uložen ve třech bajtech (0xd1 = typ, 0x00c8=200 je hodnota) atd.</p>

<p><div class="rs-tip-major">Poznámka: můžeme vidět, že každý prvek může být
uložen různým způsobem a pole tedy nejsou heterogenní ani s&nbsp;ohledem na
datový typ z&nbsp;pohledu programátora (ve skutečnosti se tedy spíše jedná o
seznamy) ani z&nbsp;pohledu binárního formátu.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Delší pole</h2>

<p>Pole delší než patnáct prvků se dále rozlišují podle toho, zda je celkový
počet prvků menší než 2<sup>16</sup>-1 nebo větší než tato hodnota. Podle počtu
prvků se volí počet bajtů pro uložení délky pole &ndash; dva či čtyři bajty. My
si dnes ukážeme pouze první typ, tj.&nbsp;pole menší než 2<sup>16</sup>-1
prvků:</p>

<pre>
const N = 1000
var values [N]int
&nbsp;
for i := 0; i &lt; N; i++ {
        values[i] = i
}
&nbsp;
<i>// zakódování dat</i>
err = encoder.Encode(values)
if err != nil {
        log.Fatal(err)
}
</pre>

<p>Obsah výsledného binárního souboru si zobrazíme:</p>

<pre>
$ <strong>od -A x -t x1 -v array16.bin</strong>
</pre>

<p>Nejprve je uveden typ (<strong>0xdc</strong>) a počet prvků 0x03e8=1000.
Dále již následují hodnoty jednotlivých prvků. Pro prvních 128 prvků postačuje
pro uložení použít jediný bajt:</p>

<pre>
000000 dc 03 e8 00 01 02 03 04 05 06 07 08 09 0a 0b 0c
000010 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c
000020 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c
000030 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 3b 3c
000040 3d 3e 3f 40 41 42 43 44 45 46 47 48 49 4a 4b 4c
000050 4d 4e 4f 50 51 52 53 54 55 56 57 58 59 5a 5b 5c
000060 5d 5e 5f 60 61 62 63 64 65 66 67 68 69 6a 6b 6c
000070 6d 6e 6f 70 71 72 73 74 75 76 77 78 79 7a 7b 7c
000080 7d 7e 7f
</pre>

<p>Větší hodnoty jsou již uloženy složitějším způsobem, protože první bajt
každé trojice obsahuje typ (<strong>0xd1</strong>):</p>

<pre>
000080          d1 00 80 d1 00 81 d1 00 82 d1 00 83 d1
000090 00 84 d1 00 85 d1 00 86 d1 00 87 d1 00 88 d1 00
0000a0 89 d1 00 8a d1 00 8b d1 00 8c d1 00 8d d1 00 8e
0000b0 d1 00 8f d1 00 90 d1 00 91 d1 00 92 d1 00 93 d1
</pre>

<p>Často se setkáme s&nbsp;polem bajtů, a to mj.&nbsp;i proto, že takové pole
může vzniknout například jako výsledek zašifrování dat:</p>

<pre>
const N = 1000
var values [N]byte
&nbsp;
for i := 0; i &lt; N; i++ {
        values[i] = byte(i)
}
</pre>

<p>Takové pole bude zapsáno ve formátu:</p>

<pre>
$ <strong>od -A x -t x1 -v bytes.bin</strong>
&nbsp;
000000 da 03 e8 00 01 02 03 04 05 06 07 08 09 0a 0b 0c
000010 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c
000020 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c
</pre>

<p>Celý soubor bude mít délku 1003 bajtů, tedy tři bajty pro určení typu (pole)
a jeho délky následovanou 1000 bajty představujícími data.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Celočíselné hodnoty se znaménkem vs. hodnoty bez znaménka</h2>

<p>Vraťme se ještě k&nbsp;poli 1000 prvků typu <strong>int</strong>, které jsme
vytvořili a uložili tímto způsobem:</p>

<pre>
const N = 1000
var values [N]int
&nbsp;
for i := 0; i &lt; N; i++ {
        values[i] = i
}
</pre>

<p>Výsledkem byl soubor o délce 2747 bajtů, přičemž všechny hodnoty větší než
127 byly uloženy ve třech bajtech.</p>

<p>Pokud ovšem namísto typu <strong>int</strong> použijeme typ
<strong>uint</strong>:</p>

<pre>
const N = 1000
var values [N]uint
&nbsp;
for i := 0; i &lt; N; i++ {
        values[i] = uint(i)
}
</pre>

<p>Budou ty samé hodnoty 0 až 999 uloženy v&nbsp;souboru o délce 2619 bajtů a
způsob uložení se bude lišit:</p>

<ol>
<li>Hodnoty menší než 128 budou uloženy v&nbsp;jediné bajtu</li>
<li>Hodnoty mezi 128 až 255 budou uloženy jako dvojice 0xcc + hodnota</li>
<li>Hodnoty větší než 255 budou uloženy jako trojice 0xcd + hodnota</li>
</ol>

<p>Můžeme se o tom snadno přesvědčit:</p>

<pre>
$ <strong>od -A x -t x1 -v array16B.bin</strong>
<pre>

<p>Typ + délka pole + prvních 128 prvků:</p>

</pre>
000000 dc 03 e8 00 01 02 03 04 05 06 07 08 09 0a 0b 0c
000010 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c
000020 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c
000030 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 3b 3c
000040 3d 3e 3f 40 41 42 43 44 45 46 47 48 49 4a 4b 4c
000050 4d 4e 4f 50 51 52 53 54 55 56 57 58 59 5a 5b 5c
000060 5d 5e 5f 60 61 62 63 64 65 66 67 68 69 6a 6b 6c
000070 6d 6e 6f 70 71 72 73 74 75 76 77 78 79 7a 7b 7c
000080 7d 7e 7f
</pre>

<p>Následují prvky s&nbsp;hodnotou 128 až 255:</p>

<pre>
000080          cc 80 cc 81 cc 82 cc 83 cc 84 cc 85 cc
000090 86 cc 87 cc 88 cc 89 cc 8a cc 8b cc 8c cc 8d cc
0000a0 8e cc 8f cc 90 cc 91 cc 92 cc 93 cc 94 cc 95 cc
</pre>

<p>A poté zbylé prvky:</p>

<pre>
000180 fe cc ff cd 01 00 cd 01 01 cd 01 02 cd 01 03 cd
000190 01 04 cd 01 05 cd 01 06 cd 01 07 cd 01 08 cd 01
0001a0 09 cd 01 0a cd 01 0b cd 01 0c cd 01 0d cd 01 0e
0001b0 cd 01 0f cd 01 10 cd 01 11 cd 01 12 cd 01 13 cd
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Serializace map</h2>

<p>Ve formátu JSON se prakticky vždy setkáme s&nbsp;mapami
resp.&nbsp;s&nbsp;asociativními poli. Tuto datovou strukturu lze použít i
v&nbsp;MessagePacku a to dokonce ještě ve vylepšené variantě, protože klíči
mohou být hodnoty jakéhokoli typu, nejenom řetězce. Ukažme si ovšem základní
použití s&nbsp;řetězci jako klíči:</p>

<pre>
var m map[string]int = make(map[string]int)
m["foo"] = 1
m["bar"] = 2
&nbsp;
<i>// zakódování dat</i>
err = encoder.Encode(m)
if err != nil {
	log.Fatal(err)
}
</pre>

<p>Tato mapa se dvěma dvojicemi klíč+hodnota bude uložena v&nbsp;pouhých
jedenácti bajtech (v&nbsp;JSONu se nedostaneme pod 17 bajtů &ndash; ostatně
sami si to vyzkoušejte na <a
href="https://msgpack.org/">https://msgpack.org/</a> po výběru
&bdquo;Try&ldquo;):</p>

<pre>
$ <strong>od -A x -t x1 -v map.bin</strong>
&nbsp;
000000 82 a3 66 6f 6f 01 a3 62 61 72 02
00000b
</pre>

<p>Mapa obsahuje dvě dvojice, což je malý počet. Z&nbsp;tohoto důvodu je typ
(mapa) i počet dvojic klíč-hodnota uložena v&nbsp;jediném bajtu 0x80+0x02=0x82.
Následuje stejný obsah, jako v&nbsp;případě polí:</p>

<table>
<tr><th>Bajty</th><th>Význam</th></tr>
<tr><td>a3 66 6f 6f</td><td>řetězec "foo" o délce tří bajtů</td></tr>
<tr><td>01</td><td>malé celé číslo 1</td></tr>
<tr><td>a3 62 61 72</td><td>řetězec "bar" o délce tří bajtů</td></tr>
<tr><td>02</td><td>malé celé číslo 2</td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Co dále?</h2>

<p>Pro praktické použití formátu MessagePack musíme vyřešit ještě další
problémy, s&nbsp;nimiž se dennodenně můžeme setkat v&nbsp;praxi. Týká se to
zejména serializace struktur a v&nbsp;neposlední řadě taktéž rekurzivních
struktur typu binární strom. S&nbsp;touto problematikou se blíže seznámíme
příště, kde MessagePack kromě jiného využijeme i z&nbsp;dalších programovacích
jazyků. Taktéž si vysvětlíme způsob uložení časových značek s&nbsp;různou
přesností.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
nového Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně stovku kilobajtů), můžete namísto toho použít odkazy na jednotlivé
demonstrační příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad/soubor</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>msgpack_nil.go</td><td>serializace hodnoty <strong>nil</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_nil.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_nil.go</a></td></tr>
<tr><td> 2</td><td>msgpack_true.go</td><td>serializace hodnot <strong>true</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_true.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_true.go</a></td></tr>
<tr><td> 3</td><td>msgpack_false.go</td><td>serializace hodnot <strong>false</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_false.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_false.go</a></td></tr>
<tr><td> 4</td><td>msgpack_small_int.go</td><td>serializace celočíselné hodnoty menší než 127</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_small_int.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_small_int.go</a></td></tr>
<tr><td> 5</td><td>msgpack_longer_int.go</td><td>serializace celočíselné hodnoty menší než 2<sup>16</sup></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_longer_int.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_longer_int.go</a></td></tr>
<tr><td> 6</td><td>msgpack_even_longer_int.go</td><td>serializace celočíselné hodnoty větší než 2<sup>16</sup></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_even_longer_int.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_even_longer_int.go</a></td></tr>
<tr><td> 7</td><td>msgpack_long_int.go</td><td>serializace celočíselné hodnoty větší než 2<sup>32</sup></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_long_int.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_long_int.go</a></td></tr>
<tr><td> 8</td><td>msgpack_single.go</td><td>serializace hodnoty s&nbsp;plovoucí řádovou čárkou (<i>single</i>)</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_single.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_single.go</a></td></tr>
<tr><td> 9</td><td>msgpack_double.go</td><td>serializace hodnoty s&nbsp;plovoucí řádovou čárkou (<i>double</i>)</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_double.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_double.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>msgpack_short_string.go</td><td>serializace krátkého řetězce (méně než 31 znaků)</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_short_string.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_short_string.go</a></td></tr>
<tr><td>11</td><td>msgpack_longer_string.go</td><td>serializace delšího řetězce (méně než 256 znaků)</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_longer_string.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_longer_string.go</a></td></tr>
<tr><td>12</td><td>msgpack_even_longer_string.go</td><td>serializace dlouhého řetězce</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_even_longer_string.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_even_longer_string.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>msgpack_short_array1.go</td><td>krátké pole čtyř hodnot 1-4</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_short_array1.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_short_array1.go</a></td></tr>
<tr><td>14</td><td>msgpack_short_array2.go</td><td>krátké pole čtyř hodnot 100, 200, 300 a 400</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_short_array2.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_short_array2.go</a></td></tr>
<tr><td>15</td><td>msgpack_bytes.go</td><td>pole 1000 bajtů</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_bytes.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_bytes.go</a></td></tr>
<tr><td>16</td><td>msgpack_array_16A.go</td><td>pole 1000 prvků typu <strong>int</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16A.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16A.go</a></td></tr>
<tr><td>17</td><td>msgpack_array_16B.go</td><td>pole 1000 prvků typu <strong>uint</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16B.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16B.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>msgpack_map.go</td><td>serializace mapy</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_map.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_map.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Základní informace o MessagePacku<br />
<a href="https://msgpack.org/">https://msgpack.org/</a>
</li>

<li>MessagePack na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/MessagePack">https://en.wikipedia.org/wiki/MessagePack</a>
</li>

<li>Comparison of data-serialization formats (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats">https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats</a>
</li>

<li>Repositáře msgpacku<br />
<a href="https://github.com/msgpack">https://github.com/msgpack</a>
</li>

<li>Specifikace ukládání různých typů dat<br />
<a href="https://github.com/msgpack/msgpack/blob/master/spec.md">https://github.com/msgpack/msgpack/blob/master/spec.md</a>
</li>

<li>Podpora MessagePacku v&nbsp;různých jazycích<br />
<a href="https://msgpack.org/#languages">https://msgpack.org/#languages</a>
</li>

<li>Základní implementace formátu msgpack pro Go<br />
<a href="https://github.com/msgpack/msgpack-go">https://github.com/msgpack/msgpack-go</a>
</li>

<li>go-codec<br />
<a href="https://github.com/ugorji/go">https://github.com/ugorji/go</a>
</li>

<li>Gobs of data<br />
<a href="https://blog.golang.org/gobs-of-data">https://blog.golang.org/gobs-of-data</a>
</li>

<li>Formát BSON<br />
<a href="http://bsonspec.org/">http://bsonspec.org/</a>
</li>

<li>Problematika nulových hodnot v Go, aneb proč nil != nil<br />
<a href="https://www.root.cz/clanky/problematika-nulovych-hodnot-v-go-aneb-proc-nil-nil/">https://www.root.cz/clanky/problematika-nulovych-hodnot-v-go-aneb-proc-nil-nil/</a>
</li>

<li>IEEE-754 Floating Point Converter<br />
<a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">https://www.h-schmidt.net/FloatConverter/IEEE754.html</a>
</li>

<li>Base Convert: IEEE 754 Floating Point<br />
<a href="https://baseconvert.com/ieee-754-floating-point">https://baseconvert.com/ieee-754-floating-point</a>
</li>

<li>Brain Floating Point – nový formát uložení čísel pro strojové učení a chytrá čidla<br />
<a href="https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/">https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

