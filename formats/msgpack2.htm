<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Komunikace realizovaná binárním formátem MessagePack (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Komunikace realizovaná binárním formátem MessagePack (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na úvodní část dvoudílného článku o formátu MessagePack dnes navážeme. Ukážeme si, že datové struktury pole a mapa jsou v Message Packu heterogenní (což odpovídá původnímu textovému JSONu). Taktéž provedeme porovnání mezi formáty JSON, XML, BSON, gob a právě Message Packem.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Komunikace realizovaná binárním formátem MessagePack (dokončení)</a></p>
<p><a href="#k02">2. Serializace polí a řezů</a></p>
<p><a href="#k03">3. Serializace řezů</a></p>
<p><a href="#k04">4. Mapy jako heterogenní datový typ</a></p>
<p><a href="#k05">5. Uložení heterogenní mapy v&nbsp;binárním formátu</a></p>
<p><a href="#k06">6. Uložení heterogenního pole do binárního formátu</a></p>
<p><a href="#k07">*** 7. Uložení časového razítka</a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Komunikace realizovaná binárním formátem MessagePack (dokončení)</h2>

<p></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Serializace polí a řezů</h2>

<p>Formát <i>Message Pack</i> podporuje ukládání polí, která jsou (jak uvidíme
dále) heterogenní. To znamená, že typ každého prvku pole může být prakticky
libovolný a nezávislý na typu ostatních prvků. To ostatně velmi dobře odpovídá
pojetí polí v&nbsp;JavaScriptu a tím pádem i ve formátu JSON, jehož myšlenky
jsou použity v&nbsp;binárním formátu <i>Message Pack</i>. Pokud ovšem budeme
Message Pack používat například v&nbsp;programovacím jazyku Go, bude pro nás
důležitější vědět, jakým způsobem se serializují <i>řezy</i> (<i>slice</i>) a
nikoli pole, protože s&nbsp;řezy se v&nbsp;praxi setkáme mnohem častěji než
s&nbsp;klasickými poli. Bude tedy dobré si vyzkoušet, jak se od sebe bude lišit
serializace pole a řezu.</p>

<p>Následující demonstrační příklad jsme si již ukázali minule, takže si jen ve
stručnosti řekněme, že se v&nbsp;příkladu vytváří klasické pole s&nbsp;tisíci
prvky typu <strong>uint</strong>. Prvky tohoto pole jsou inicializovány na
hodnoty 0, 1, 2 až 999. Následně je celé pole serializováno do binárního
formátu Message Pack:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "os"
&nbsp;
        "github.com/ugorji/go/codec"
)
&nbsp;
const filename = "/tmp/array16B.bin"
&nbsp;
func <strong>main</strong>() {
        <i>// vytvořit soubor s binárními daty</i>
        fout, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil {
                log.Fatal(err)
        }
        defer fout.Close()
&nbsp;
        log.Print("Output file created")
&nbsp;
        <i>// handler</i>
        var handler codec.MsgpackHandle
&nbsp;
        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(fout, &amp;handler)
&nbsp;
        log.Print("Encoder created")
&nbsp;
        const N = 1000
        var values [N]uint
&nbsp;
        for i := 0; i &lt; N; i++ {
                values[i] = uint(i)
        }
&nbsp;
        <i>// zakódování dat</i>
        err = encoder.Encode(values)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        log.Print("Done")
}
</pre>

<p>Výsledkem bude po spuštění předchozího programu binární soubor nazvaný
&bdquo;array16B.bin&ldquo;, jehož velikost by měla být rovna 2619 bajtům.
Samozřejmě můžeme prozkoumat obsah tohoto souboru. Celočíselné prvky
s&nbsp;hodnotami 0 až 999 budou uloženy následujícím způsobem:</p>

<ol>
<li>Hodnoty menší než 128 budou uloženy v&nbsp;jediném bajtu, což je současně nejúspornější možná varianta</li>
<li>Hodnoty mezi 128 až 255 budou uloženy jako dvojice <strong>0xcc</strong> + osmibitová hodnota</li>
<li>Hodnoty větší než 255 budou uloženy jako trojice <strong>0xcd</strong> + 16bitová hodnota</li>
</ol>

<p>Můžeme se o tom snadno přesvědčit analýzou vytvořeného binárního
souboru:</p>

<pre>
$ <strong>od -A x -t x1 -v array16B.bin</strong>
<pre>

<p>Typ + délka pole + prvních 128 prvků:</p>

</pre>
000000 dc 03 e8 00 01 02 03 04 05 06 07 08 09 0a 0b 0c
000010 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c
000020 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c
000030 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 3b 3c
000040 3d 3e 3f 40 41 42 43 44 45 46 47 48 49 4a 4b 4c
000050 4d 4e 4f 50 51 52 53 54 55 56 57 58 59 5a 5b 5c
000060 5d 5e 5f 60 61 62 63 64 65 66 67 68 69 6a 6b 6c
000070 6d 6e 6f 70 71 72 73 74 75 76 77 78 79 7a 7b 7c
000080 7d 7e 7f
</pre>

<p>Následují prvky s&nbsp;hodnotou 128 až 255:</p>

<pre>
000080          cc 80 cc 81 cc 82 cc 83 cc 84 cc 85 cc
000090 86 cc 87 cc 88 cc 89 cc 8a cc 8b cc 8c cc 8d cc
0000a0 8e cc 8f cc 90 cc 91 cc 92 cc 93 cc 94 cc 95 cc
</pre>

<p>A poté zbylé prvky:</p>

<pre>
000180 fe cc ff cd 01 00 cd 01 01 cd 01 02 cd 01 03 cd
000190 01 04 cd 01 05 cd 01 06 cd 01 07 cd 01 08 cd 01
0001a0 09 cd 01 0a cd 01 0b cd 01 0c cd 01 0d cd 01 0e
0001b0 cd 01 0f cd 01 10 cd 01 11 cd 01 12 cd 01 13 cd
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Serializace řezů</h2>

<p>Nyní předchozí demonstrační příklad nepatrně upravíme, a to takovým
způsobem, aby se namísto polí použil řez:</p>

<pre>
const N = 1000
var values []uint
&nbsp;
for i := 0; i &lt; N; i++ {
        values = append(values, uint(i))
}
</pre>

<p>Interně se v&nbsp;případě řezu jedná o referenci na automaticky vytvořené
pole nebo na pole, které je explicitně alokovanáno programátorem. Každý řez je
v&nbsp;operační paměti uložen ve formě trojice hodnot (jde tedy o záznam
&ndash; struct či record):</p>

<ol>
<li>Ukazatele (reference) na zvolený prvek pole s&nbsp;daty, ke kterým přes řez přistupujeme.</li>
<li>Délky řezu, tj.&nbsp;počtu prvků.</li>
<li>Kapacity řezu (do jaké míry může řez narůstat v&nbsp;důsledku přidávání dalších prvků).</li>
</ol>

<p>Tato interní struktura řezů s&nbsp;sebou přináší několik zajímavých
důsledků. Je totiž možné, aby existovalo větší množství řezů ukazujících na
obecně různé prvky jediného pole. Pokud nyní změníme prvek v&nbsp;jednom řezu,
znamená to, že se vlastně modifikuje obsah původního pole a i ostatní řezy nový
prvek uvidí. Co je však užitečnější &ndash; s&nbsp;řezy jako s&nbsp;datovým
typem se velmi snadno pracuje; řezy mohou být předávány do funkcí, vráceny
z&nbsp;funkcí atd. Proto se s&nbsp;řezy setkáme mnohem častěji než
s&nbsp;klasickými poli.</p>

<p>Po úpravě demonstračního příkladu tak, aby se namísto pole použil řez,
získáme soubor nazvaný &bdquo;array16C.bin&ldquo;. Velikost i obsah tohoto
souboru bude stejný se souborem získaným příkladem uvedeným <a
href="#k02">v&nbsp;předchozí kapitole</a>, o čemž se můžeme velmi snadno
přesvědčit:</p>

<pre>
$ <strong>cmp -l -b array16B.bin array16C.bin</strong>
&nbsp;
<i>(nic se nevypíše)</i>
</pre>

<p><div class="rs-tip-major">Poznámka: to ovšem znamená, že se z&nbsp;řezu
uloží &bdquo;pouze&ldquo; vlastní pole s&nbsp;daty. Ve skutečnosti je ještě
uložena skutečná délka pole/řezu, ovšem nikoli již kapacita. To ovšem dává
smysl, protože formát Message Pack je určen pro mnoho jazyků a současně
nepodporuje všechny datové typy všech podporovaných jazyků (ostatně stejně jako
JSON).</div></p>

<p>Upravený kód demonstračního příkladu bude vypadat následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "os"
&nbsp;
        "github.com/ugorji/go/codec"
)
&nbsp;
const filename = "/tmp/array16C.bin"
&nbsp;
func <strong>main</strong>() {
        <i>// vytvořit soubor s binárními daty</i>
        fout, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil {
                log.Fatal(err)
        }
        defer fout.Close()
&nbsp;
        log.Print("Output file created")
&nbsp;
        <i>// handler</i>
        var handler codec.MsgpackHandle
&nbsp;
        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(fout, &amp;handler)
&nbsp;
        log.Print("Encoder created")
&nbsp;
        const N = 1000
        var values []uint
&nbsp;
        for i := 0; i &lt; N; i++ {
                values = append(values, uint(i))
        }
&nbsp;
        <i>// zakódování dat</i>
        err = encoder.Encode(values)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        log.Print("Done")
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Mapy jako heterogenní datový typ</h2>

<p>Mapy (neboli asociativní pole) jsou ve formátu Message Pack heterogenním
datovým typem, což znamená, že jak klíče, tak i hodnoty jednotlivých dvojic
mohou být prakticky libovolného typu, nezávisle na typech klíčů a hodnot jiných
dvojic uložených ve stejné mapě. Na jednu stranu se tedy jedná o napodobení map
ve formátu JSON, ovšem ve skutečnosti není prakticky vůbec omezen typ klíčů
&ndash; což může způsobovat potíže v&nbsp;těch programovacích jazycích, kde
nějaká omezení existují.</p>

<p>Typicky se ovšem u map používají jako klíče řetězce. Serializaci takové mapy
si ukážeme v&nbsp;následujícím demonstračním příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "os"
&nbsp;
        "github.com/ugorji/go/codec"
)
&nbsp;
const filename = "/tmp/map.bin"
&nbsp;
func <strong>main</strong>() {
        <i>// vytvořit soubor s binárními daty</i>
        fout, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil {
                log.Fatal(err)
        }
        defer fout.Close()
&nbsp;
        log.Print("Output file created")
&nbsp;
        <i>// handler</i>
        var handler codec.MsgpackHandle
&nbsp;
        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(fout, &amp;handler)
&nbsp;
        log.Print("Encoder created")
&nbsp;
        var m map[string]int = make(map[string]int)
        m["foo"] = 1
        m["bar"] = 2
&nbsp;
        <i>// zakódování dat</i>
        err = encoder.Encode(m)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        log.Print("Done")
}
</pre>

<p>Výsledkem bude soubor &bdquo;map.bin&ldquo;, jehož obsah je následující:</p>

<pre>
$ <strong>od -A x -t x1z -v map.bin</strong>
000000 82 a3 66 6f 6f 01 a3 62 61 72 02                 &gt;..foo..bar.&lt;
00000b
</pre>

<p>Mapa obsahuje dvě dvojice, což je malý počet. Z&nbsp;tohoto důvodu je typ
(mapa) i počet dvojic klíč-hodnota uložena v&nbsp;jediném bajtu 0x80+0x02=0x82.
Následuje obsah dvojic klíč-hodnota. Tyto dvojice jsou uloženy za sebou, takže
mapa je interně (v&nbsp;binárním formátu) vlastně běžným polem, ovšem
s&nbsp;odlišnou hlavičkou:</p>

<table>
<tr><th>Bajty</th><th>Význam</th></tr>
<tr><td>a3 66 6f 6f</td><td>řetězec "foo" o délce tří bajtů</td></tr>
<tr><td>01</td><td>malé celé číslo 1</td></tr>
<tr><td>a3 62 61 72</td><td>řetězec "bar" o délce tří bajtů</td></tr>
<tr><td>02</td><td>malé celé číslo 2</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Uložení heterogenní mapy v&nbsp;binárním formátu</h2>

<p>Nic nám ovšem nebrání v&nbsp;použití mapy s&nbsp;prvky, jejichž typy se od
sebe budou navzájem lišit. Takovou mapu lze vytvořit i v&nbsp;jazyce Go, a to
konkrétně s&nbsp;využitím typu <strong>map[klíče]interface{}</strong>, tedy
tak, jak je to ukázáno v&nbsp;dalším příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "os"

        "github.com/ugorji/go/codec"
)
&nbsp;
const filename = "/tmp/map2.bin"
&nbsp;
func <strong>main</strong>() {
        <i>// vytvořit soubor s binárními daty</i>
        fout, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil {
                log.Fatal(err)
        }
        defer fout.Close()
&nbsp;
        log.Print("Output file created")
&nbsp;
        <i>// handler</i>
        var handler codec.MsgpackHandle
&nbsp;
        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(fout, &amp;handler)
&nbsp;
        log.Print("Encoder created")
&nbsp;
        var m map[string]interface{} = make(map[string]interface{})
        m["foo"] = 1
        m["bar"] = 2
        m["baz"] = 1000000
        m["wee"] = "test"
        m["array"] = []int{1, 2, 3}
        m["map"] = map[string]string{
                "one": "jedna",
                "two": "dve",
        }
&nbsp;
        <i>// zakódování dat</i>
        err = encoder.Encode(m)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        log.Print("Done")
}
</pre>

<p>Výsledný binární soubor s&nbsp;mapou bude mít délku 62 bajtů a následující
obsah:</p>

<pre>
$ <strong>od -A x -t x1z -v map2.bin</strong>
&nbsp;
000000 86 a3 62 61 72 02 a3 62 61 7a d2 00 0f 42 40 a3  &gt;..bar..baz...B@.&lt;
000010 77 65 65 a4 74 65 73 74 a5 61 72 72 61 79 93 01  &gt;wee.test.array..&lt;
000020 02 03 a3 6d 61 70 82 a3 6f 6e 65 a5 6a 65 64 6e  &gt;...map..one.jedn&lt;
000030 61 a3 74 77 6f a3 64 76 65 a3 66 6f 6f 01        &gt;a.two.dve.foo.&lt;
00003e
</pre>

<p>První bajt v&nbsp;souboru obsahuje hodnotu <strong>0x86</strong>, takže
víme, že se jedná o mapu s&nbsp;maximálně patnácti prvky
(<strong>0x8?</strong>) a celkový počet prvků (tedy dvojic klíč+hodnota) je
roven šesti (<strong>0x?6</strong>).</p>

<p>Následuje bajt <strong>0xa3</strong> značící řetězec (první tři bity) kratší
než 32 bajtů, za nímž následují znaky řetězce zakódované do bajtů <strong>0x62
0x61 0x72</strong>. To je hodnota prvního klíče. Pod tímto klíčem je zapsaná
celočíselná hodnota 2 reprezentovaná jediným bajtem <strong>0x02</strong>.
Naprosto stejným způsobem jsou zapsány i další dvojice klíč-hodnota.</p>

<p>Povšimněte si, že jednou hodnotou uloženou do mapy je další (vnořená) mapa,
která začíná bajtem <strong>0x82</strong> &ndash; jedná se tedy o mapu se dvěma
dvojicemi klíč+hodnota.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Uložení heterogenního pole do binárního formátu</h2>

<p>Nepatrnou úpravou předchozího příkladu vytvoříme heterogenní pole,
tj.&nbsp;pole, v&nbsp;němž mohou mít jeho prvky jakoukoli hodnotu nezávislou na
typech ostatních prvků pole. Nejprve se podívejme na zdrojový kód tohoto
demonstračního příkladu (v&nbsp;něm sice pracujeme s&nbsp;řezem a nikoli
s&nbsp;polem, ovšem víme již, že se řezy serializují naprosto stejným způsobem
jako běžná pole):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "os"
&nbsp;
        "github.com/ugorji/go/codec"
)
&nbsp;
const filename = "/tmp/array16D.bin"
&nbsp;
func <strong>main</strong>() {
        <i>// vytvořit soubor s binárními daty</i>
        fout, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil {
                log.Fatal(err)
        }
        defer fout.Close()
&nbsp;
        log.Print("Output file created")
&nbsp;
        <i>// handler</i>
        var handler codec.MsgpackHandle
&nbsp;
        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(fout, &amp;handler)
&nbsp;
        log.Print("Encoder created")
&nbsp;
        var values []interface{}
&nbsp;
        values = append(values, 1)
        values = append(values, 100000)
        values = append(values, "test")
        values = append(values, []int{1, 2, 3})
        values = append(values, map[string]string{
                "one": "jedna",
                "two": "dve",
        })
&nbsp;
        <i>// zakódování dat</i>
        err = encoder.Encode(values)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        log.Print("Done")
}
</pre>

<p>Výsledkem bude binární soubor nazvaný &bdquo;array16D.bin&ldquo;, jehož
délka bude 35 bajtů. Oproti mapě z&nbsp;předchozích kapitol je to méně, což je
ovšem logické, protože nyní nemusíme ukládat klíče, ale pouze hodnoty (tedy
prvky) pole:</p>

<pre>
$ <strong>od -A x -t x1z -v array16D.bin</strong>
&nbsp;
000000 95 01 d2 00 01 86 a0 a4 74 65 73 74 93 01 02 03  &gt;........test....&lt;
000010 82 a3 6f 6e 65 a5 6a 65 64 6e 61 a3 74 77 6f a3  &gt;..one.jedna.two.&lt;
000020 64 76 65                                         &gt;dve&lt;
000023
</pre>

<p>První bajt s&nbsp;hodnotou <strong>0x95</strong> značí krátké pole (prefix
<strong>0x9?</strong>) s&nbsp;pěti prvky (<strong>0x?5</strong>). Ihned poté
následují hodnoty prvků pole, z&nbsp;nichž každý s&nbsp;sebou nese i informace
o datovém typu:</p>

<table>
<tr><th>Bajty</th><th>Význam</th></tr>
<tr><td>0x01</td><td>celočíselná hodnota 1</td></tr>
<tr><td>0xd2 0x00 0x01 0x86 0xa0</td><td>celočíselná hodnota 0x186a0 == 100000</td></tr>
<tr><td>0x74 0x65 0x73 0x74 0x93</td><td>řetězec &bdquo;test&ldquo; o délce čtyři bajty</td></tr>
<tr><td>0x93 0x01 0x02 0x03</td><td>tříprvkové pole celočíselných hodnot 1, 2 a 3</td></tr>
<tr><td>0x82 ...</td><td>mapa se dvěma dvojicemi klíč+hodnota</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Uložení časového razítka</h2>

<p>V&nbsp;praxi je velmi důležité zajistit ukládání popř.&nbsp;přenos časových
razítek. Ve formátu JSON na tento důležitý datový typ není pamatováno, takže se
setkáme s&nbsp;různými způsoby uložení informací o datu a času &ndash;
například se lze setkat například s&nbsp;nicneříkajím zápisem
&bdquo;01/02/03&ldquo; atd.</p>

<p>Naproti tomu formát Message Pack dokáže s&nbsp;časovými razítky pracovat a
dokonce podporuje tři různé způsoby uložení. O jakou hodnotu se jedná lze
zjistit z&nbsp;prefixového bajtu:</p>

<table>
<tr><th>Prefix</th><th>Délka</th><th>Význam</th><th>Přesnost</th></tr>
<tr><td>0xd6</td><td>4 bajty</td><td>32bitová hodnota sekund od 1970-01-01 00:00:00 UTC</td><td>sekundy</td></tr>
<tr><td>0xd7</td><td>8 bajtů</td><td>34bitová hodnota sekund od 1970-01-01 00:00:00 UTC + počet nanosekund</td><td>nanosekundy</td></tr>
<tr><td>0xc7</td><td>12 bajtů</td><td>64bitová hodnota sekund od 1970-01-01 00:00:00 UTC + počet nanosekund</td><td>nanosekundy</td></tr>
</table>

<p>Podívejme se nyní na způsob uložení časového razítka, konkrétně aktuální
hodnoty data+času ve chvíli, kdy program zavolá funkci
<strong>time.Now</strong>():</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "os"
        "time"
&nbsp;
        "github.com/ugorji/go/codec"
)
&nbsp;
const filename = "/tmp/timestamp.bin"
&nbsp;
func <strong>main</strong>() {
        <i>// vytvořit soubor s binárními daty</i>
        fout, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil {
                log.Fatal(err)
        }
        defer fout.Close()
&nbsp;
        log.Print("Output file created")
&nbsp;
        <i>// handler</i>
        var handler codec.MsgpackHandle
&nbsp;
        <i>// důležité - serializace časového razítka ve správném datovém formátu</i>
        handler.WriteExt = true
&nbsp;
        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(fout, &amp;handler)
&nbsp;
        log.Print("Encoder created")
&nbsp;
        <strong>t := time.Now()</strong>
        log.Print(t)
&nbsp;
        <i>// zakódování dat</i>
        err = encoder.Encode(t)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        log.Print("Done")
}
</pre>

<p><div class="rs-tip-major">Poznámka: nesmíme zapomenout na tento
řádek:</div></p>

<pre>
<i>// důležité - serializace časového razítka ve správném datovém formátu</i>
<strong>handler.WriteExt = true</strong>
</pre>

<p>Po spuštění příkladu by se měl vytvořit binární soubor nazvaný
&bdquo;timestamp.bin&ldquo; s&nbsp;délkou devíti bajtů. Obsah tohoto souboru si
opět vypíšeme:</p>

<pre>
$ <strong>od -A x -t x1 -v timestamp.bin</strong>
&nbsp;
000000 d7 ff 72 1f e3 88 61 ed 8a 66
00000a
</pre>

<p>První bajt <strong>0xd7</strong></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>

<table>
<tr><th></th><th></th></tr>
<tr><td>vector1.bin </td><td> 9003</td></tr>
<tr><td>vector1.bson</td><td>12895</td></tr>
<tr><td>vector1.gob </td><td> 8960</td></tr>
<tr><td>vector1.json</td><td>21017</td></tr>
<tr><td>vector2.json</td><td>26018</td></tr>
<tr><td>vector1.xml </td><td>39016</td></tr>
<tr><td>vector2.xml </td><td>40015</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: </div></p>

<table>
<tr><th></th><th></th></tr>
<tr><td>vector1.bin.gz </td><td>5431</td></tr>
<tr><td>vector1.bson.gz</td><td>6537</td></tr>
<tr><td>vector1.gob.gz </td><td>5234</td></tr>
<tr><td>vector1.json.gz</td><td>7559</td></tr>
<tr><td>vector2.json.gz</td><td>7652</td></tr>
<tr><td>vector1.xml.gz </td><td>8182</td></tr>
<tr><td>vector2.xml.gz </td><td>8230</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

<pre>
package <strong>main</strong>

import (
        "bytes"
        "encoding/gob"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "gopkg.in/mgo.v2/bson"
        "io/ioutil"

        "github.com/ugorji/go/codec"
)

type Item int

type Node struct {
        Value Item
        Left  *Node
        Right *Node
}

type BinaryTree struct {
        Root *Node
}

func (bt *BinaryTree) Insert(value Item) {
        node := &Node{value, nil, nil}
        if bt.Root == nil {
                bt.Root = node
        } else {
                insertNode(bt.Root, node)
        }
}

func <strong>insertNode</strong>(node, newNode *Node) {
        if newNode.Value < node.Value {
                if node.Left == nil {
                        node.Left = newNode
                } else {
                        insertNode(node.Left, newNode)
                }
        } else {
                if node.Right == nil {
                        node.Right = newNode
                } else {
                        insertNode(node.Right, newNode)
                }
        }
}

func <strong>printTree</strong>(node *Node, level int) {
        if node != nil {
                format := ""
                for i := 0; i < level; i++ {
                        format += "       "
                }
                format += "---[ "
                level++
                printTree(node.Left, level)
                fmt.Printf(format+"%d\n", node.Value)
                printTree(node.Right, level)
        }
}

func <strong>encodeBinaryTreeIntoBSON</strong>(bt BinaryTree) ([]byte, error) {
        bsonOutput, err := bson.Marshal(bt)

        if err != nil {
                return bsonOutput, err
        }
        return bsonOutput, nil
}

func <strong>encodeBinaryTreeIntoJSON</strong>(bt BinaryTree) ([]byte, error) {
        jsonOutput, err := json.Marshal(bt)

        if err != nil {
                return jsonOutput, err
        }
        return jsonOutput, nil
}

func <strong>encodeBinaryTreeIntoIndentedJSON</strong>(bt BinaryTree) ([]byte, error) {
        jsonOutput, err := json.MarshalIndent(bt, "", "    ")

        if err != nil {
                return jsonOutput, err
        }
        return jsonOutput, nil
}

func <strong>encodeBinaryTreeIntoXML</strong>(bt BinaryTree) ([]byte, error) {
        xmlOutput, err := xml.Marshal(bt)

        if err != nil {
                return xmlOutput, err
        }
        return xmlOutput, nil
}

func <strong>encodeBinaryTreeIntoIndentedXML</strong>(bt BinaryTree) ([]byte, error) {
        xmlOutput, err := xml.MarshalIndent(bt, "", "    ")

        if err != nil {
                return xmlOutput, err
        }
        return xmlOutput, nil
}

func <strong>encodeBinaryTreeIntoGob</strong>(bt BinaryTree) ([]byte, error) {
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&buffer)

        err := encoder.Encode(bt)
        if err != nil {
                return buffer.Bytes(), err
        }
        return buffer.Bytes(), nil
}

func <strong>encodeBinaryTreeIntoMsgPack</strong>(bt BinaryTree) ([]byte, error) {
        var buffer bytes.Buffer

        <i>// handler</i>
        var handler codec.MsgpackHandle

        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(&buffer, &handler)

        <i>// zakódování dat</i>
        err := encoder.Encode(bt)
        if err != nil {
                return buffer.Bytes(), err
        }
        return buffer.Bytes(), nil
}

func <strong>saveBinaryTree</strong>(encodedTree []byte, filename string) {
        err := ioutil.WriteFile(filename, encodedTree, 0644)
        if err != nil {
                fmt.Println(err)
        } else {
                fmt.Println("Stored into file", filename)
        }
}

func <strong>constructTree</strong>(bt *BinaryTree, min, max int) {
        middle := (min + max) / 2
        if min < middle && middle < max {
                fmt.Println(middle)
                bt.Insert(Item(middle))
                constructTree(bt, min, middle)
                constructTree(bt, middle, max)
        }
}

func <strong>printBufferInfo</strong>(buffer []byte) {
        fmt.Println("\nBuffer with encoded tree: ", len(buffer))
}

func <strong>main</strong>() {
        var bt BinaryTree
        constructTree(&bt, 0, 256)

        printTree(bt.Root, 0)

        encodedTree, err := encodeBinaryTreeIntoXML(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "/tmp/tree1.xml")

        encodedTree, err = encodeBinaryTreeIntoIndentedXML(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "/tmp/tree2.xml")

        encodedTree, err = encodeBinaryTreeIntoJSON(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "/tmp/tree1.json")

        encodedTree, err = encodeBinaryTreeIntoIndentedJSON(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "/tmp/tree2.json")

        encodedTree, err = encodeBinaryTreeIntoBSON(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "/tmp/tree1.bson")

        encodedTree, err = encodeBinaryTreeIntoGob(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "/tmp/tree1.gob")

        encodedTree, err = encodeBinaryTreeIntoMsgPack(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "/tmp/tree1.bin")

}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>

<pre>
Buffer with encoded tree:  8076
Stored into file /tmp/tree1.xml

Buffer with encoded tree:  31378
Stored into file /tmp/tree2.xml

Buffer with encoded tree:  8575
Stored into file /tmp/tree1.json

Buffer with encoded tree:  42115
Stored into file /tmp/tree2.json

Buffer with encoded tree:  7406
Stored into file /tmp/tree1.bson

Buffer with encoded tree:  1431
Stored into file /tmp/tree1.gob

Buffer with encoded tree:  5363
Stored into file /tmp/tree1.bin
</pre>

<table>
<tr><th></th><th></th></tr>
<tr><td>tree1.bin </td><td> 5363</td></tr>
<tr><td>tree1.bson</td><td> 7406</td></tr>
<tr><td>tree1.gob </td><td> 1431</td></tr>
<tr><td>tree1.json</td><td> 8575</td></tr>
<tr><td>tree2.json</td><td>42115</td></tr>
<tr><td>tree1.xml </td><td> 8076</td></tr>
<tr><td>tree2.xml </td><td>31378</td></tr>
</table>

<table>
<tr><th></th><th></th></tr>
<tr><td>tree1.bin.gz </td><td> 745</td></tr>
<tr><td>tree1.bson.gz</td><td> 924</td></tr>
<tr><td>tree1.gob.gz </td><td> 714</td></tr>
<tr><td>tree1.json.gz</td><td> 840</td></tr>
<tr><td>tree2.json.gz</td><td>1474</td></tr>
<tr><td>tree1.xml.gz </td><td> 869</td></tr>
<tr><td>tree2.xml.gz </td><td>1306</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>

<pre>
package <strong>main</strong>

import (
        "bytes"
        "encoding/gob"
        "encoding/json"
        "fmt"
        "gopkg.in/mgo.v2/bson"
        "io/ioutil"

        "github.com/ugorji/go/codec"
)

type Map map[string]string

func <strong>encodeMapIntoBSON</strong>(m Map) ([]byte, error) {
        bsonOutput, err := bson.Marshal(m)

        if err != nil {
                return bsonOutput, err
        }
        return bsonOutput, nil
}

func <strong>encodeMapIntoJSON</strong>(m Map) ([]byte, error) {
        jsonOutput, err := json.Marshal(m)

        if err != nil {
                return jsonOutput, err
        }
        return jsonOutput, nil
}

func <strong>encodeMapIntoIndentedJSON</strong>(m Map) ([]byte, error) {
        jsonOutput, err := json.MarshalIndent(m, "", "    ")

        if err != nil {
                return jsonOutput, err
        }
        return jsonOutput, nil
}

func <strong>encodeMapIntoGob</strong>(m Map) ([]byte, error) {
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&buffer)

        err := encoder.Encode(m)
        if err != nil {
                return buffer.Bytes(), err
        }
        return buffer.Bytes(), nil
}

func <strong>encodeMapIntoMsgPack</strong>(m Map) ([]byte, error) {
        var buffer bytes.Buffer

        <i>// handler</i>
        var handler codec.MsgpackHandle

        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(&buffer, &handler)

        <i>// zakódování dat</i>
        err := encoder.Encode(m)
        if err != nil {
                return buffer.Bytes(), err
        }
        return buffer.Bytes(), nil
}

func <strong>saveMap</strong>(encodedMap []byte, filename string) {
        err := ioutil.WriteFile(filename, encodedMap, 0644)
        if err != nil {
                fmt.Println(err)
        } else {
                fmt.Println("Stored into file", filename)
        }
}

func <strong>printBufferInfo</strong>(buffer []byte) {
        fmt.Println("\nBuffer with encoded map: ", len(buffer))
}

func <strong>main</strong>() {
        var m Map = make(map[string]string)
        m["foo"] = "text"
        m["bar"] = "test"
        m["baz"] = "Příliš žluťoučký kůň"
        m["longer key"] = "Příliš žluťoučký kůň"

        for i := 0; i &lt; 256; i++ {
                key := fmt.Sprintf("key: %02x", i)
                value := fmt.Sprintf("value: %d", i)
                m[key] = value
        }

        encodedMap, err := encodeMapIntoJSON(m)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedMap)
        saveMap(encodedMap, "/tmp/map1.json")

        encodedMap, err = encodeMapIntoIndentedJSON(m)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedMap)
        saveMap(encodedMap, "/tmp/map2.json")

        encodedMap, err = encodeMapIntoBSON(m)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedMap)
        saveMap(encodedMap, "/tmp/map1.bson")

        encodedMap, err = encodeMapIntoGob(m)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedMap)
        saveMap(encodedMap, "/tmp/map1.gob")

        encodedMap, err = encodeMapIntoMsgPack(m)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedMap)
        saveMap(encodedMap, "/tmp/map1.bin")
}
</pre>

4850 map1.bin
6152 map1.bson
4876 map1.gob
5888 map1.json
7449 map2.json



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

type Map map[string]string

func <strong>encodeMapIntoBSON</strong>(m Map) ([]byte, error) {
        bsonOutput, err := bson.Marshal(m)

        if err != nil {
                return bsonOutput, err
        }
        return bsonOutput, nil
}

func <strong>encodeMapIntoJSON</strong>(m Map) ([]byte, error) {
        jsonOutput, err := json.Marshal(m)

        if err != nil {
                return jsonOutput, err
        }
        return jsonOutput, nil
}

func <strong>encodeMapIntoIndentedJSON</strong>(m Map) ([]byte, error) {
        jsonOutput, err := json.MarshalIndent(m, "", "    ")

        if err != nil {
                return jsonOutput, err
        }
        return jsonOutput, nil
}

func <strong>encodeMapIntoGob</strong>(m Map) ([]byte, error) {
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&buffer)

        err := encoder.Encode(m)
        if err != nil {
                return buffer.Bytes(), err
        }
        return buffer.Bytes(), nil
}

func <strong>encodeMapIntoMsgPack</strong>(m Map) ([]byte, error) {
        var buffer bytes.Buffer

        <i>// handler</i>
        var handler codec.MsgpackHandle

        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(&buffer, &handler)

        <i>// zakódování dat</i>
        err := encoder.Encode(m)
        if err != nil {
                return buffer.Bytes(), err
        }
        return buffer.Bytes(), nil
}


<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<pre>
package <strong>main</strong>

import (
        "fmt"

        "testing"
)

func <strong>createMap</strong>(n int) Map {
        var m Map = make(map[string]string)
        m["foo"] = "text"
        m["bar"] = "test"
        m["baz"] = "Příliš žluťoučký kůň"
        m["longer key"] = "Příliš žluťoučký kůň"

        for i := 0; i &lt; n; i++ {
                key := fmt.Sprintf("key: %02x", i)
                value := fmt.Sprintf("value: %d", i)
                m[key] = value
        }
        return m
}

func <strong>benchmark</strong>(b *testing.B, n int, f func(m Map) ([]byte, error)) {
        m := createMap(n)
        for i := 0; i &lt; b.N; i++ {
                f(m)
        }
}

func <strong>BenchmarkBSON1</strong>(b *testing.B) {
        benchmark(b, 1, encodeMapIntoBSON)
}

func <strong>BenchmarkBSON100</strong>(b *testing.B) {
        benchmark(b, 100, encodeMapIntoBSON)
}

func <strong>BenchmarkBSON1000</strong>(b *testing.B) {
        benchmark(b, 1000, encodeMapIntoBSON)
}

func <strong>BenchmarkJSON1</strong>(b *testing.B) {
        benchmark(b, 1, encodeMapIntoJSON)
}

func <strong>BenchmarkJSON100</strong>(b *testing.B) {
        benchmark(b, 100, encodeMapIntoJSON)
}

func <strong>BenchmarkJSON1000</strong>(b *testing.B) {
        benchmark(b, 1000, encodeMapIntoJSON)
}

func <strong>BenchmarkIndentedJSON1</strong>(b *testing.B) {
        benchmark(b, 1, encodeMapIntoIndentedJSON)
}

func <strong>BenchmarkIndentedJSON100</strong>(b *testing.B) {
        benchmark(b, 100, encodeMapIntoIndentedJSON)
}

func <strong>BenchmarkIndentedJSON1000</strong>(b *testing.B) {
        benchmark(b, 1000, encodeMapIntoIndentedJSON)
}

func <strong>BenchmarkGob1</strong>(b *testing.B) {
        benchmark(b, 1, encodeMapIntoGob)
}

func <strong>BenchmarkGob100</strong>(b *testing.B) {
        benchmark(b, 100, encodeMapIntoGob)
}

func <strong>BenchmarkGob1000</strong>(b *testing.B) {
        benchmark(b, 1000, encodeMapIntoGob)
}

func <strong>BenchmarkMsgPack1</strong>(b *testing.B) {
        benchmark(b, 1, encodeMapIntoMsgPack)
}

func <strong>BenchmarkMsgPack100</strong>(b *testing.B) {
        benchmark(b, 100, encodeMapIntoMsgPack)
}

func <strong>BenchmarkMsgPack1000</strong>(b *testing.B) {
        benchmark(b, 1000, encodeMapIntoMsgPack)
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<pre>
$ go test -bench=.
</pre>

<pre>
goos: linux
goarch: amd64
pkg: msgpack-test
cpu: Intel(R) Core(TM) i7-8665U CPU @ 1.90GHz
BenchmarkBSON1-8                  933855              1121 ns/op
BenchmarkBSON100-8                 62947             21862 ns/op
BenchmarkBSON1000-8                 5594            191998 ns/op
BenchmarkJSON1-8                  848180              1400 ns/op
BenchmarkJSON100-8                 44877             27312 ns/op
BenchmarkJSON1000-8                 3687            343840 ns/op
BenchmarkIndentedJSON1-8          454699              2566 ns/op
BenchmarkIndentedJSON100-8         27103             45834 ns/op
BenchmarkIndentedJSON1000-8         2395            504380 ns/op
BenchmarkGob1-8                   568262              2425 ns/op
BenchmarkGob100-8                  68746             23603 ns/op
BenchmarkGob1000-8                  7363            159924 ns/op
BenchmarkMsgPack1-8               847807              1351 ns/op
BenchmarkMsgPack100-8             231123              5438 ns/op
BenchmarkMsgPack1000-8             26774             46252 ns/op
PASS
ok      msgpack-test    21.273s
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech <a
href="https://www.root.cz/clanky/komunikace-realizovana-uspornym-binarnim-formatem-messagepack/">minule</a>
i dnes použitých demonstračních příkladů byly uloženy do nového Git repositáře,
který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně stovku kilobajtů), můžete namísto toho použít odkazy na jednotlivé
demonstrační příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad/soubor</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>msgpack_nil.go</td><td>serializace hodnoty <strong>nil</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_nil.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_nil.go</a></td></tr>
<tr><td> 2</td><td>msgpack_true.go</td><td>serializace hodnot <strong>true</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_true.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_true.go</a></td></tr>
<tr><td> 3</td><td>msgpack_false.go</td><td>serializace hodnot <strong>false</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_false.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_false.go</a></td></tr>
<tr><td> 4</td><td>msgpack_small_int.go</td><td>serializace celočíselné hodnoty menší než 127</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_small_int.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_small_int.go</a></td></tr>
<tr><td> 5</td><td>msgpack_longer_int.go</td><td>serializace celočíselné hodnoty menší než 2<sup>16</sup></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_longer_int.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_longer_int.go</a></td></tr>
<tr><td> 6</td><td>msgpack_even_longer_int.go</td><td>serializace celočíselné hodnoty větší než 2<sup>16</sup></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_even_longer_int.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_even_longer_int.go</a></td></tr>
<tr><td> 7</td><td>msgpack_long_int.go</td><td>serializace celočíselné hodnoty větší než 2<sup>32</sup></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_long_int.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_long_int.go</a></td></tr>
<tr><td> 8</td><td>msgpack_single.go</td><td>serializace hodnoty s&nbsp;plovoucí řádovou čárkou (<i>single</i>)</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_single.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_single.go</a></td></tr>
<tr><td> 9</td><td>msgpack_double.go</td><td>serializace hodnoty s&nbsp;plovoucí řádovou čárkou (<i>double</i>)</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_double.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_double.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>msgpack_short_string.go</td><td>serializace krátkého řetězce (méně než 31 znaků)</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_short_string.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_short_string.go</a></td></tr>
<tr><td>11</td><td>msgpack_longer_string.go</td><td>serializace delšího řetězce (méně než 256 znaků)</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_longer_string.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_longer_string.go</a></td></tr>
<tr><td>12</td><td>msgpack_even_longer_string.go</td><td>serializace dlouhého řetězce</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_even_longer_string.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_even_longer_string.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>msgpack_short_array1.go</td><td>krátké pole čtyř hodnot 1-4</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_short_array1.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_short_array1.go</a></td></tr>
<tr><td>14</td><td>msgpack_short_array2.go</td><td>krátké pole čtyř hodnot 100, 200, 300 a 400</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_short_array2.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_short_array2.go</a></td></tr>
<tr><td>15</td><td>msgpack_bytes.go</td><td>pole 1000 bajtů</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_bytes.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_bytes.go</a></td></tr>
<tr><td>16</td><td>msgpack_array_16A.go</td><td>pole 1000 prvků typu <strong>int</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16A.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16A.go</a></td></tr>
<tr><td>17</td><td>msgpack_array_16B.go</td><td>pole 1000 prvků typu <strong>uint</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16B.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16B.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>msgpack_map.go</td><td>serializace mapy</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_map.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_map.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>msgpack_array_16C.go</td><td>pole vzniklé serializací řezu (<i>slice</i>)</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16C.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16C.go</a></td></tr>
<tr><td>20</td><td>msgpack_array_16D.go</td><td>serializace heterogenního pole</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16D.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16D.go</a></td></tr>
<tr><td>21</td><td>msgpack_map2.go</td><td>serializace heterogenní mapy</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_map2.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_map2.go</a></td></tr>
<tr><td>22</td><td>msgpack_timestamp.go</td><td>serializace časového razítka</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_timestamp.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_timestamp.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>size_comparison_A.go</td><td>porovnání velikosti vektorů typu float64 po jejich serializaci do různých formátů</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/size_comparison_A.go">https://github.com/tisnik/go-root/blob/master/msgpack/size_comparison_A.go</a></td></tr>
<tr><td>23</td><td>size_comparison_B.go</td><td>porovnání velikosti binárních stromů po jejich serializaci do různých formátů</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/size_comparison_B.go">https://github.com/tisnik/go-root/blob/master/msgpack/size_comparison_B.go</a></td></tr>
<tr><td>24</td><td>size_comparison_C.go</td><td>porovnání velikosti map po jejich serializaci do různých formátů</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/size_comparison_C.go">https://github.com/tisnik/go-root/blob/master/msgpack/size_comparison_C.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>benchmark/</td><td>měření rychlosti serializace map do různých formátů</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/benchmark">https://github.com/tisnik/go-root/blob/master/msgpack/benchmark</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Základní informace o MessagePacku<br />
<a href="https://msgpack.org/">https://msgpack.org/</a>
</li>

<li>MessagePack na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/MessagePack">https://en.wikipedia.org/wiki/MessagePack</a>
</li>

<li>Comparison of data-serialization formats (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats">https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats</a>
</li>

<li>Repositáře msgpacku<br />
<a href="https://github.com/msgpack">https://github.com/msgpack</a>
</li>

<li>Specifikace ukládání různých typů dat<br />
<a href="https://github.com/msgpack/msgpack/blob/master/spec.md">https://github.com/msgpack/msgpack/blob/master/spec.md</a>
</li>

<li>Podpora MessagePacku v&nbsp;různých jazycích<br />
<a href="https://msgpack.org/#languages">https://msgpack.org/#languages</a>
</li>

<li>Základní implementace formátu msgpack pro Go<br />
<a href="https://github.com/msgpack/msgpack-go">https://github.com/msgpack/msgpack-go</a>
</li>

<li>go-codec<br />
<a href="https://github.com/ugorji/go">https://github.com/ugorji/go</a>
</li>

<li>Gobs of data<br />
<a href="https://blog.golang.org/gobs-of-data">https://blog.golang.org/gobs-of-data</a>
</li>

<li>Formát BSON<br />
<a href="http://bsonspec.org/">http://bsonspec.org/</a>
</li>

<li>Problematika nulových hodnot v Go, aneb proč nil != nil<br />
<a href="https://www.root.cz/clanky/problematika-nulovych-hodnot-v-go-aneb-proc-nil-nil/">https://www.root.cz/clanky/problematika-nulovych-hodnot-v-go-aneb-proc-nil-nil/</a>
</li>

<li>IEEE-754 Floating Point Converter<br />
<a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">https://www.h-schmidt.net/FloatConverter/IEEE754.html</a>
</li>

<li>Base Convert: IEEE 754 Floating Point<br />
<a href="https://baseconvert.com/ieee-754-floating-point">https://baseconvert.com/ieee-754-floating-point</a>
</li>

<li>Brain Floating Point – nový formát uložení čísel pro strojové učení a chytrá čidla<br />
<a href="https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/">https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

