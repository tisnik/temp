<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Komunikace realizovaná binárním formátem MessagePack (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Komunikace realizovaná binárním formátem MessagePack (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na úvodní část dvoudílného článku o formátu MessagePack dnes navážeme. Ukážeme si, že datové struktury pole a mapa jsou v Message Packu heterogenní (což odpovídá původnímu textovému JSONu). Taktéž provedeme porovnání mezi formáty JSON, XML, BSON, gob a právě Message Packem.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Komunikace realizovaná binárním formátem MessagePack (dokončení)</a></p>
<p><a href="#k02">2. Serializace polí a řezů</a></p>
<p><a href="#k03">3. Serializace řezů</a></p>
<p><a href="#k04">4. Mapy jako heterogenní datový typ</a></p>
<p><a href="#k05">5. Uložení heterogenní mapy v&nbsp;binárním formátu</a></p>
<p><a href="#k06">6. Uložení heterogenního pole do binárního formátu</a></p>
<p><a href="#k07">7. Uložení časového razítka</a></p>
<p><a href="#k08">8. Message Pack &ndash; it's like JSON. But fast and small</a></p>
<p><a href="#k09">9. Serializace vektoru hodnot typu <strong>float64</strong></a></p>
<p><a href="#k10">10. Velikosti souborů se serializovaným vektorem</a></p>
<p><a href="#k11">11. Serializace binárního stromu</a></p>
<p><a href="#k12">12. Velikosti souborů se serializovaným binárním stromem</a></p>
<p><a href="#k13">13. Serializace mapy, jejímiž klíči i hodnotami jsou řetězce</a></p>
<p><a href="#k14">14. Velikosti souborů se serializovanou mapou</a></p>
<p><a href="#k15">15. Rychlost serializace</a></p>
<p><a href="#k16">16. Benchmark měřící rychlost serializace</a></p>
<p><a href="#k17">17. Výsledky benchmarku</a></p>
<p><a href="#k18">18. Kam dál?</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Komunikace realizovaná binárním formátem MessagePack (dokončení)</h2>

<p>Na <a
href="https://www.root.cz/clanky/komunikace-realizovana-uspornym-binarnim-formatem-messagepack/">úvodní
článek o binárním serializačním formátu Message Pack</a> dnes navážeme. Nejprve
si na praktických příkladech ukážeme, že datové struktury pole a mapa jsou
v&nbsp;Message Packu heterogenní, což odpovídá původnímu textovému JSONu,
kterému se binární formát JSON snaží svými možnostmi přiblížit. Dále si
ukážeme, jakým způsobem se serializují časová razítka. To je důležitý datový
typ, jehož absence ve specifikaci JSONu (a nepřímo i absence příslušného
literálu v&nbsp;JavaScriptu) způsobuje, že se časová razítka v&nbsp;JSONu
ukládají různými, mnohdy dosti obskurními způsoby. A na závěr provedeme
porovnání mezi formáty JSON, XML, BSON, gob a právě Message Packem. Zaměříme se
jak na velikosti dat po jejich serializaci, tak i na rychlost serializace, což
v&nbsp;některých aplikacích může být limitujícím faktorem.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Serializace polí a řezů</h2>

<p>Formát <i>Message Pack</i> podporuje ukládání polí, která jsou (jak uvidíme
dále) heterogenní. To znamená, že typ každého prvku pole může být prakticky
libovolný a nezávislý na typu ostatních prvků. To ostatně velmi dobře odpovídá
pojetí polí v&nbsp;JavaScriptu a tím pádem i ve formátu JSON, jehož myšlenky
jsou použity v&nbsp;binárním formátu <i>Message Pack</i>. Pokud ovšem budeme
Message Pack používat například v&nbsp;programovacím jazyku Go, bude pro nás
důležitější vědět, jakým způsobem se serializují <i>řezy</i> (<i>slice</i>) a
nikoli pole, protože s&nbsp;řezy se v&nbsp;praxi setkáme mnohem častěji než
s&nbsp;klasickými poli. Bude tedy dobré si vyzkoušet, jak se od sebe bude lišit
serializace pole a řezu.</p>

<p>Následující demonstrační příklad jsme si již ukázali minule, takže si jen ve
stručnosti řekněme, že se v&nbsp;příkladu vytváří klasické pole s&nbsp;tisíci
prvky typu <strong>uint</strong>. Prvky tohoto pole jsou inicializovány na
hodnoty 0, 1, 2 až 999. Následně je celé pole serializováno do binárního
formátu Message Pack:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "os"
&nbsp;
        "github.com/ugorji/go/codec"
)
&nbsp;
const filename = "/tmp/array16B.bin"
&nbsp;
func <strong>main</strong>() {
        <i>// vytvořit soubor s binárními daty</i>
        fout, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil {
                log.Fatal(err)
        }
        defer fout.Close()
&nbsp;
        log.Print("Output file created")
&nbsp;
        <i>// handler</i>
        var handler codec.MsgpackHandle
&nbsp;
        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(fout, &amp;handler)
&nbsp;
        log.Print("Encoder created")
&nbsp;
        const N = 1000
        var values [N]uint
&nbsp;
        for i := 0; i &lt; N; i++ {
                values[i] = uint(i)
        }
&nbsp;
        <i>// zakódování dat</i>
        err = encoder.Encode(values)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        log.Print("Done")
}
</pre>

<p>Výsledkem bude po spuštění předchozího programu binární soubor nazvaný
&bdquo;array16B.bin&ldquo;, jehož velikost by měla být rovna 2619 bajtům.
Samozřejmě můžeme prozkoumat obsah tohoto souboru. Celočíselné prvky
s&nbsp;hodnotami 0 až 999 budou uloženy následujícím způsobem:</p>

<ol>
<li>Hodnoty menší než 128 budou uloženy v&nbsp;jediném bajtu, což je současně nejúspornější možná varianta</li>
<li>Hodnoty mezi 128 až 255 budou uloženy jako dvojice <strong>0xcc</strong> + osmibitová hodnota</li>
<li>Hodnoty větší než 255 budou uloženy jako trojice <strong>0xcd</strong> + 16bitová hodnota</li>
</ol>

<p>Můžeme se o tom snadno přesvědčit analýzou vytvořeného binárního
souboru:</p>

<pre>
$ <strong>od -A x -t x1 -v array16B.bin</strong>
</pre>

<p>Typ + délka pole + prvních 128 prvků:</p>

<pre>
000000 dc 03 e8 00 01 02 03 04 05 06 07 08 09 0a 0b 0c
000010 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c
000020 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c
000030 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 3b 3c
000040 3d 3e 3f 40 41 42 43 44 45 46 47 48 49 4a 4b 4c
000050 4d 4e 4f 50 51 52 53 54 55 56 57 58 59 5a 5b 5c
000060 5d 5e 5f 60 61 62 63 64 65 66 67 68 69 6a 6b 6c
000070 6d 6e 6f 70 71 72 73 74 75 76 77 78 79 7a 7b 7c
000080 7d 7e 7f
</pre>

<p>Následují prvky s&nbsp;hodnotou 128 až 255:</p>

<pre>
000080          cc 80 cc 81 cc 82 cc 83 cc 84 cc 85 cc
000090 86 cc 87 cc 88 cc 89 cc 8a cc 8b cc 8c cc 8d cc
0000a0 8e cc 8f cc 90 cc 91 cc 92 cc 93 cc 94 cc 95 cc
</pre>

<p>A poté zbylé prvky:</p>

<pre>
000180 fe cc ff cd 01 00 cd 01 01 cd 01 02 cd 01 03 cd
000190 01 04 cd 01 05 cd 01 06 cd 01 07 cd 01 08 cd 01
0001a0 09 cd 01 0a cd 01 0b cd 01 0c cd 01 0d cd 01 0e
0001b0 cd 01 0f cd 01 10 cd 01 11 cd 01 12 cd 01 13 cd
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Serializace řezů</h2>

<p>Nyní předchozí demonstrační příklad nepatrně upravíme, a to takovým
způsobem, aby se namísto polí použil řez:</p>

<pre>
const N = 1000
var values []uint
&nbsp;
for i := 0; i &lt; N; i++ {
        values = append(values, uint(i))
}
</pre>

<p>Interně se v&nbsp;případě řezu jedná o referenci na automaticky vytvořené
pole nebo na pole, které je explicitně alokovanáno programátorem. Každý řez je
v&nbsp;operační paměti uložen ve formě trojice hodnot (jde tedy o záznam
&ndash; struct či record):</p>

<ol>
<li>Ukazatele (reference) na zvolený prvek pole s&nbsp;daty, ke kterým přes řez přistupujeme.</li>
<li>Délky řezu, tj.&nbsp;počtu prvků.</li>
<li>Kapacity řezu (do jaké míry může řez narůstat v&nbsp;důsledku přidávání dalších prvků).</li>
</ol>

<p>Tato interní struktura řezů s&nbsp;sebou přináší několik zajímavých
důsledků. Je totiž možné, aby existovalo větší množství řezů ukazujících na
obecně různé prvky jediného pole. Pokud nyní změníme prvek v&nbsp;jednom řezu,
znamená to, že se vlastně modifikuje obsah původního pole a i ostatní řezy nový
prvek uvidí. Co je však užitečnější &ndash; s&nbsp;řezy jako s&nbsp;datovým
typem se velmi snadno pracuje; řezy mohou být předávány do funkcí, vráceny
z&nbsp;funkcí atd. Proto se s&nbsp;řezy setkáme mnohem častěji než
s&nbsp;klasickými poli.</p>

<p>Po úpravě demonstračního příkladu tak, aby se namísto pole použil řez,
získáme soubor nazvaný &bdquo;array16C.bin&ldquo;. Velikost i obsah tohoto
souboru bude stejný se souborem získaným příkladem uvedeným <a
href="#k02">v&nbsp;předchozí kapitole</a>, o čemž se můžeme velmi snadno
přesvědčit:</p>

<pre>
$ <strong>cmp -l -b array16B.bin array16C.bin</strong>
&nbsp;
<i>(nic se nevypíše)</i>
</pre>

<p><div class="rs-tip-major">Poznámka: to ovšem znamená, že se z&nbsp;řezu
uloží &bdquo;pouze&ldquo; vlastní pole s&nbsp;daty. Ve skutečnosti je ještě
uložena skutečná délka pole/řezu, ovšem nikoli již kapacita. To ovšem dává
smysl, protože formát Message Pack je určen pro mnoho jazyků a současně
nepodporuje všechny datové typy všech podporovaných jazyků (ostatně stejně jako
JSON).</div></p>

<p>Upravený kód demonstračního příkladu bude vypadat následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "os"
&nbsp;
        "github.com/ugorji/go/codec"
)
&nbsp;
const filename = "/tmp/array16C.bin"
&nbsp;
func <strong>main</strong>() {
        <i>// vytvořit soubor s binárními daty</i>
        fout, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil {
                log.Fatal(err)
        }
        defer fout.Close()
&nbsp;
        log.Print("Output file created")
&nbsp;
        <i>// handler</i>
        var handler codec.MsgpackHandle
&nbsp;
        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(fout, &amp;handler)
&nbsp;
        log.Print("Encoder created")
&nbsp;
        const N = 1000
        var values []uint
&nbsp;
        for i := 0; i &lt; N; i++ {
                values = append(values, uint(i))
        }
&nbsp;
        <i>// zakódování dat</i>
        err = encoder.Encode(values)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        log.Print("Done")
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Mapy jako heterogenní datový typ</h2>

<p>Mapy (neboli asociativní pole) jsou ve formátu Message Pack heterogenním
datovým typem, což znamená, že jak klíče, tak i hodnoty jednotlivých dvojic
mohou být prakticky libovolného typu, nezávisle na typech klíčů a hodnot jiných
dvojic uložených ve stejné mapě. Na jednu stranu se tedy jedná o napodobení map
ve formátu JSON, ovšem ve skutečnosti není prakticky vůbec omezen typ klíčů
&ndash; což může způsobovat potíže v&nbsp;těch programovacích jazycích, kde
nějaká omezení existují.</p>

<p>Typicky se ovšem u map používají jako klíče řetězce. Serializaci takové mapy
si ukážeme v&nbsp;následujícím demonstračním příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "os"
&nbsp;
        "github.com/ugorji/go/codec"
)
&nbsp;
const filename = "/tmp/map.bin"
&nbsp;
func <strong>main</strong>() {
        <i>// vytvořit soubor s binárními daty</i>
        fout, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil {
                log.Fatal(err)
        }
        defer fout.Close()
&nbsp;
        log.Print("Output file created")
&nbsp;
        <i>// handler</i>
        var handler codec.MsgpackHandle
&nbsp;
        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(fout, &amp;handler)
&nbsp;
        log.Print("Encoder created")
&nbsp;
        var m map[string]int = make(map[string]int)
        m["foo"] = 1
        m["bar"] = 2
&nbsp;
        <i>// zakódování dat</i>
        err = encoder.Encode(m)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        log.Print("Done")
}
</pre>

<p>Výsledkem bude soubor &bdquo;map.bin&ldquo;, jehož obsah je následující:</p>

<pre>
$ <strong>od -A x -t x1z -v map.bin</strong>
000000 82 a3 66 6f 6f 01 a3 62 61 72 02                 &gt;..foo..bar.&lt;
00000b
</pre>

<p>Mapa obsahuje dvě dvojice, což je malý počet. Z&nbsp;tohoto důvodu je typ
(mapa) i počet dvojic klíč-hodnota uložena v&nbsp;jediném bajtu 0x80+0x02=0x82.
Následuje obsah dvojic klíč-hodnota. Tyto dvojice jsou uloženy za sebou, takže
mapa je interně (v&nbsp;binárním formátu) vlastně běžným polem, ovšem
s&nbsp;odlišnou hlavičkou:</p>

<table>
<tr><th>Bajty</th><th>Význam</th></tr>
<tr><td>a3 66 6f 6f</td><td>řetězec "foo" o délce tří bajtů</td></tr>
<tr><td>01</td><td>malé celé číslo 1</td></tr>
<tr><td>a3 62 61 72</td><td>řetězec "bar" o délce tří bajtů</td></tr>
<tr><td>02</td><td>malé celé číslo 2</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Uložení heterogenní mapy v&nbsp;binárním formátu</h2>

<p>Nic nám ovšem nebrání v&nbsp;použití mapy s&nbsp;prvky, jejichž typy se od
sebe budou navzájem lišit. Takovou mapu lze vytvořit i v&nbsp;jazyce Go, a to
konkrétně s&nbsp;využitím typu <strong>map[klíče]interface{}</strong>, tedy
tak, jak je to ukázáno v&nbsp;dalším příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "os"

        "github.com/ugorji/go/codec"
)
&nbsp;
const filename = "/tmp/map2.bin"
&nbsp;
func <strong>main</strong>() {
        <i>// vytvořit soubor s binárními daty</i>
        fout, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil {
                log.Fatal(err)
        }
        defer fout.Close()
&nbsp;
        log.Print("Output file created")
&nbsp;
        <i>// handler</i>
        var handler codec.MsgpackHandle
&nbsp;
        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(fout, &amp;handler)
&nbsp;
        log.Print("Encoder created")
&nbsp;
        var m map[string]interface{} = make(map[string]interface{})
        m["foo"] = 1
        m["bar"] = 2
        m["baz"] = 1000000
        m["wee"] = "test"
        m["array"] = []int{1, 2, 3}
        m["map"] = map[string]string{
                "one": "jedna",
                "two": "dve",
        }
&nbsp;
        <i>// zakódování dat</i>
        err = encoder.Encode(m)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        log.Print("Done")
}
</pre>

<p>Výsledný binární soubor s&nbsp;mapou bude mít délku 62 bajtů a následující
obsah:</p>

<pre>
$ <strong>od -A x -t x1z -v map2.bin</strong>
&nbsp;
000000 86 a3 62 61 72 02 a3 62 61 7a d2 00 0f 42 40 a3  &gt;..bar..baz...B@.&lt;
000010 77 65 65 a4 74 65 73 74 a5 61 72 72 61 79 93 01  &gt;wee.test.array..&lt;
000020 02 03 a3 6d 61 70 82 a3 6f 6e 65 a5 6a 65 64 6e  &gt;...map..one.jedn&lt;
000030 61 a3 74 77 6f a3 64 76 65 a3 66 6f 6f 01        &gt;a.two.dve.foo.&lt;
00003e
</pre>

<p>První bajt v&nbsp;souboru obsahuje hodnotu <strong>0x86</strong>, takže
víme, že se jedná o mapu s&nbsp;maximálně patnácti prvky
(<strong>0x8?</strong>) a celkový počet prvků (tedy dvojic klíč+hodnota) je
roven šesti (<strong>0x?6</strong>).</p>

<p>Následuje bajt <strong>0xa3</strong> značící řetězec (první tři bity) kratší
než 32 bajtů, za nímž následují znaky řetězce zakódované do bajtů <strong>0x62
0x61 0x72</strong>. To je hodnota prvního klíče. Pod tímto klíčem je zapsaná
celočíselná hodnota 2 reprezentovaná jediným bajtem <strong>0x02</strong>.
Naprosto stejným způsobem jsou zapsány i další dvojice klíč-hodnota.</p>

<p>Povšimněte si, že jednou hodnotou uloženou do mapy je další (vnořená) mapa,
která začíná bajtem <strong>0x82</strong> &ndash; jedná se tedy o mapu se dvěma
dvojicemi klíč+hodnota.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Uložení heterogenního pole do binárního formátu</h2>

<p>Nepatrnou úpravou předchozího příkladu vytvoříme heterogenní pole,
tj.&nbsp;pole, v&nbsp;němž mohou mít jeho prvky jakoukoli hodnotu nezávislou na
typech ostatních prvků pole. Nejprve se podívejme na zdrojový kód tohoto
demonstračního příkladu (v&nbsp;něm sice pracujeme s&nbsp;řezem a nikoli
s&nbsp;polem, ovšem víme již, že se řezy serializují naprosto stejným způsobem
jako běžná pole):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "os"
&nbsp;
        "github.com/ugorji/go/codec"
)
&nbsp;
const filename = "/tmp/array16D.bin"
&nbsp;
func <strong>main</strong>() {
        <i>// vytvořit soubor s binárními daty</i>
        fout, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil {
                log.Fatal(err)
        }
        defer fout.Close()
&nbsp;
        log.Print("Output file created")
&nbsp;
        <i>// handler</i>
        var handler codec.MsgpackHandle
&nbsp;
        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(fout, &amp;handler)
&nbsp;
        log.Print("Encoder created")
&nbsp;
        var values []interface{}
&nbsp;
        values = append(values, 1)
        values = append(values, 100000)
        values = append(values, "test")
        values = append(values, []int{1, 2, 3})
        values = append(values, map[string]string{
                "one": "jedna",
                "two": "dve",
        })
&nbsp;
        <i>// zakódování dat</i>
        err = encoder.Encode(values)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        log.Print("Done")
}
</pre>

<p>Výsledkem bude binární soubor nazvaný &bdquo;array16D.bin&ldquo;, jehož
délka bude 35 bajtů. Oproti mapě z&nbsp;předchozích kapitol je to méně, což je
ovšem logické, protože nyní nemusíme ukládat klíče, ale pouze hodnoty (tedy
prvky) pole:</p>

<pre>
$ <strong>od -A x -t x1z -v array16D.bin</strong>
&nbsp;
000000 95 01 d2 00 01 86 a0 a4 74 65 73 74 93 01 02 03  &gt;........test....&lt;
000010 82 a3 6f 6e 65 a5 6a 65 64 6e 61 a3 74 77 6f a3  &gt;..one.jedna.two.&lt;
000020 64 76 65                                         &gt;dve&lt;
000023
</pre>

<p>První bajt s&nbsp;hodnotou <strong>0x95</strong> značí krátké pole (prefix
<strong>0x9?</strong>) s&nbsp;pěti prvky (<strong>0x?5</strong>). Ihned poté
následují hodnoty prvků pole, z&nbsp;nichž každý s&nbsp;sebou nese i informace
o datovém typu:</p>

<table>
<tr><th>Bajty</th><th>Význam</th></tr>
<tr><td>0x01</td><td>celočíselná hodnota 1</td></tr>
<tr><td>0xd2 0x00 0x01 0x86 0xa0</td><td>celočíselná hodnota 0x186a0 == 100000</td></tr>
<tr><td>0x74 0x65 0x73 0x74 0x93</td><td>řetězec &bdquo;test&ldquo; o délce čtyři bajty</td></tr>
<tr><td>0x93 0x01 0x02 0x03</td><td>tříprvkové pole celočíselných hodnot 1, 2 a 3</td></tr>
<tr><td>0x82 ...</td><td>mapa se dvěma dvojicemi klíč+hodnota</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Uložení časového razítka</h2>

<p>V&nbsp;praxi je velmi důležité zajistit ukládání popř.&nbsp;přenos časových
razítek. Ve formátu JSON na tento důležitý datový typ není pamatováno, takže se
setkáme s&nbsp;různými způsoby uložení informací o datu a času &ndash;
například se lze setkat například s&nbsp;nicneříkajím zápisem
&bdquo;01/02/03&ldquo; atd.</p>

<p>Naproti tomu formát Message Pack dokáže s&nbsp;časovými razítky pracovat a
dokonce podporuje tři různé způsoby uložení. O jakou hodnotu se jedná lze
zjistit z&nbsp;prefixového bajtu:</p>

<table>
<tr><th>Prefix</th><th>Délka</th><th>Význam</th><th>Přesnost</th></tr>
<tr><td>0xd6</td><td>4 bajty</td><td>32bitová hodnota sekund od 1970-01-01 00:00:00 UTC</td><td>sekundy</td></tr>
<tr><td>0xd7</td><td>8 bajtů</td><td>34bitová hodnota sekund od 1970-01-01 00:00:00 UTC + počet nanosekund</td><td>nanosekundy</td></tr>
<tr><td>0xc7</td><td>12 bajtů</td><td>64bitová hodnota sekund od 1970-01-01 00:00:00 UTC + počet nanosekund</td><td>nanosekundy</td></tr>
</table>

<p>Podívejme se nyní na způsob uložení časového razítka, konkrétně aktuální
hodnoty data+času získané ve chvíli, kdy program zavolá funkci
<strong>time.Now</strong>():</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "log"
        "os"
        "time"
&nbsp;
        "github.com/ugorji/go/codec"
)
&nbsp;
const filename = "/tmp/timestamp.bin"
&nbsp;
func <strong>main</strong>() {
        <i>// vytvořit soubor s binárními daty</i>
        fout, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil {
                log.Fatal(err)
        }
        defer fout.Close()
&nbsp;
        log.Print("Output file created")
&nbsp;
        <i>// handler</i>
        var handler codec.MsgpackHandle
&nbsp;
        <i>// důležité - serializace časového razítka ve správném datovém formátu</i>
        handler.WriteExt = true
&nbsp;
        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(fout, &amp;handler)
&nbsp;
        log.Print("Encoder created")
&nbsp;
        <strong>t := time.Now()</strong>
        log.Print(t)
&nbsp;
        <i>// zakódování dat</i>
        err = encoder.Encode(t)
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        log.Print("Done")
}
</pre>

<p><div class="rs-tip-major">Poznámka: nesmíme zapomenout na tento řádek. Pokud
by nebyl uveden, bylo by časové razítko uloženo jako prostá sekvence osmi bajtů
(tedy jako pole):</div></p>

<pre>
<i>// důležité - serializace časového razítka ve správném datovém formátu</i>
<strong>handler.WriteExt = true</strong>
</pre>

<p>Po spuštění příkladu by se měl vytvořit binární soubor nazvaný
&bdquo;timestamp.bin&ldquo; s&nbsp;délkou desíti bajtů. Obsah tohoto souboru si
opět vypíšeme:</p>

<pre>
$ <strong>od -A x -t x1 -v timestamp.bin</strong>
&nbsp;
000000 d7 ff 72 1f e3 88 61 ed 8a 66
00000a
</pre>

<p>První bajt <strong>0xd7</strong> značí, že se bude jednat o časové razítko
uložené v&nbsp;osmi bajtech. Celý záznam by měl vypadat takto:</p>

<pre>
+--------+--------+--------+--------+--------+------|-+--------+--------+--------+--------+
|  0xd7  |   -1   | nanosec. in 30-bit unsigned int |   seconds in 34-bit unsigned int    |
+--------+--------+--------+--------+--------+------^-+--------+--------+--------+--------+
</pre>

<p>Druhý bajt je skutečně roven -1 neboli <strong>0xff</strong>. Dalších sedm
bajtů (64 bitů) je rozděleno na 30 bitů a 34 bitů. V&nbsp;prvních 30 bitech je
desetinná část času v&nbsp;nanosekundách (až do hodnoty 999999999 nanosekund,
tedy těsně pod sekundu). A posledních 34 bitů určuje počet sekund od 1.1.1970.
Počet nanosekund je asi nezajímavý, ale podívejme se na posledních 34 bitů
(resp.&nbsp;postačuje posledních 32 bitů, protože nejvyšší dva bity jsou
nulové):</p>

<pre>
0x61ed8a66 = 1642957414
</pre>

<p>Což lze převést na příkazové řádce do čitelného formátu:</p>

<pre>
$ <strong>date -d @1642957414</strong>
&nbsp;
Sun 23 Jan 2022 06:03:34 PM CET
</pre>

<p><div class="rs-tip-major">Poznámka: 34bitový počet sekund umožňuje vytvářet
časová razítka až do 2514-05-30.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Message Pack &ndash; it's like JSON. But fast and small</h2>

<p>Přímo <a href="https://msgpack.org/">na úvodní stránce</a> o formátu Message
Pack se píše, že tento formát dokáže ukládat stejná data jako JSON (což jsme si
již ukázali), ale současně by měla být celá operace rychlejší a výsledné
soubory (po serializaci) menší. Obě tato tvrzení si samozřejmě musíme ověřit, a
to nejenom porovnáním Message Packu s&nbsp;formátem JSON. Do porovnání zahrneme
i některé další textové i binární formáty, zejména BSON, XML a Gob. Přitom BSON
(nikoli B-JSON) je <a href="http://bsonspec.org/">binární obdobou JSONu</a>,
tj.&nbsp;míří do stejné niky jako Message Pack. Naproti tomu XML je většinou
určen pro poněkud jiné účely, stejně jako formát Gob neboli <i>Go Objects</i>.
V&nbsp;případě Gob se jedná o formát určený primárně pro použití
v&nbsp;programovacím jazyku Go, což znamená, že jeho využití je relativně
specifické (ukládání rozsáhlých dat, komunikace mezi dvojicí služeb
naprogramovaných v&nbsp;Go atd.). Tento formát umožňuje serializaci prakticky
jakékoli datové struktury, ovšem je ho možné použít i pro primitivní datové
typy, resp.&nbsp;pro jejich hodnoty.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Serializace vektoru hodnot typu <strong>float64</strong></h2>

<p>Nejdříve si vyzkoušíme, jak velké soubory vzniknou po serializaci vektoru
s&nbsp;jedním tisícem hodnot typu <strong>float64</strong>. Tento vektor bude
reprezentován jednorozměrným polem, jehož obsah postupně uložíme do:</p>

<ol>
<li>Binárního formátu Message Back</li>
<li>Binárního formátu BSON</li>
<li>Binárního formátu Gob</li>
<li>Textového formátu JSON v&nbsp;minifikované podobě</li>
<li>Textového formátu JSON v&nbsp;čitelné podobě (s&nbsp;odsazením atd.)</li>
<li>Textového formátu XML v&nbsp;minifikované podobě</li>
<li>Textového formátu XML v&nbsp;čitelné podobě (s&nbsp;odsazením atd.)</li>
</ol>

<p>Program, který tuto serializaci provede, vypadá následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "encoding/gob"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "gopkg.in/mgo.v2/bson"
        "io/ioutil"
&nbsp;
        "github.com/ugorji/go/codec"
)
&nbsp;
<i>// Vector represents type of data to be serialized into various formats</i>
type <strong>Vector</strong> []float64
&nbsp;
func <strong>encodeVectorIntoBSON</strong>(vector Vector) ([]byte, error) {
        bsonOutput, err := bson.Marshal(vector)
&nbsp;
        if err != nil {
                return bsonOutput, err
        }
        return bsonOutput, nil
}
&nbsp;
func <strong>encodeVectorIntoJSON</strong>(vector Vector) ([]byte, error) {
        jsonOutput, err := json.Marshal(vector)
&nbsp;
        if err != nil {
                return jsonOutput, err
        }
        return jsonOutput, nil
}
&nbsp;
func <strong>encodeVectorIntoIndentedJSON</strong>(vector Vector) ([]byte, error) {
        jsonOutput, err := json.MarshalIndent(vector, "", "    ")
&nbsp;
        if err != nil {
                return jsonOutput, err
        }
        return jsonOutput, nil
}
&nbsp;
func <strong>encodeVectorIntoXML</strong>(vector Vector) ([]byte, error) {
        xmlOutput, err := xml.Marshal(vector)
&nbsp;
        if err != nil {
                return xmlOutput, err
        }
        return xmlOutput, nil
}
&nbsp;
func <strong>encodeVectorIntoIndentedXML</strong>(vector Vector) ([]byte, error) {
        xmlOutput, err := xml.MarshalIndent(vector, "", "    ")
&nbsp;
        if err != nil {
                return xmlOutput, err
        }
        return xmlOutput, nil
}
&nbsp;
func <strong>encodeVectorIntoGob</strong>(vector Vector) ([]byte, error) {
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
&nbsp;
        err := encoder.Encode(vector)
        if err != nil {
                return buffer.Bytes(), err
        }
        return buffer.Bytes(), nil
}
&nbsp;
func <strong>encodeVectorIntoMsgPack</strong>(vector Vector) ([]byte, error) {
        var buffer bytes.Buffer
&nbsp;
        <i>// handler</i>
        var handler codec.MsgpackHandle
&nbsp;
        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(&amp;buffer, &amp;bhandler)
&nbsp;
        <i>// zakódování dat</i>
        err := encoder.Encode(vector)
        if err != nil {
                return buffer.Bytes(), err
        }
        return buffer.Bytes(), nil
}
&nbsp;
func <strong>saveVector</strong>(encodedVector []byte, filename string) {
        err := ioutil.WriteFile(filename, encodedVector, 0644)
        if err != nil {
                fmt.Println(err)
        } else {
                fmt.Println("Stored into file", filename)
        }
}
&nbsp;
func <strong>printBufferInfo</strong>(buffer []byte) {
        fmt.Println("\nBuffer with encoded vector: ", len(buffer))
}
&nbsp;
func <strong>main</strong>() {
        var array [1000]float64
&nbsp;
        for i := 0; i &lt; len(array); i++ {
                if i == 0 {
                        array[i] = 1.0
                } else {
                        array[i] = 1.0 / float64(i)
                }
        }
&nbsp;
        var vector Vector = array[:]
&nbsp;
        encodedVector, err := encodeVectorIntoXML(vector)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedVector)
        saveVector(encodedVector, "/tmp/vector1.xml")
&nbsp;
        encodedVector, err = encodeVectorIntoIndentedXML(vector)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedVector)
        saveVector(encodedVector, "/tmp/vector2.xml")
&nbsp;
        encodedVector, err = encodeVectorIntoJSON(vector)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedVector)
        saveVector(encodedVector, "/tmp/vector1.json")
&nbsp;
        encodedVector, err = encodeVectorIntoIndentedJSON(vector)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedVector)
        saveVector(encodedVector, "/tmp/vector2.json")
&nbsp;
        encodedVector, err = encodeVectorIntoBSON(vector)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedVector)
        saveVector(encodedVector, "/tmp/vector1.bson")
&nbsp;
        encodedVector, err = encodeVectorIntoGob(vector)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedVector)
        saveVector(encodedVector, "/tmp/vector1.gob")
&nbsp;
        encodedVector, err = encodeVectorIntoMsgPack(vector)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedVector)
        saveVector(encodedVector, "/tmp/vector1.bin")

}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Velikosti souborů se serializovaným vektorem</h2>

<p>Velmi snadno můžeme porovnat velikosti jednotlivých souborů a určit si i
pořadí podle velikosti (resp.&nbsp;spíše malosti) výsledků serializace:</p>

<table>
<tr><th>Soubor</th><th>Velikost</th><th>Pořadí</th><th>Poznámka</th></tr>
<tr><td>vector1.bin </td><td> 9003</td><td>2</td><td>hlavička pole + 1000&times;(1+8 bajtů)</td></tr>
<tr><td>vector1.bson</td><td>12895</td><td>3</td><td>&nbsp;</td></tr>
<tr><td>vector1.gob </td><td> 8960</td><td>1</td><td>&nbsp;</td></tr>
<tr><td>vector1.json</td><td>21017</td><td>4</td><td>minifikovaný</td></tr>
<tr><td>vector2.json</td><td>26018</td><td>5</td><td>čitelný s&nbsp;odsazením</td></tr>
<tr><td>vector1.xml </td><td>39016</td><td>6</td><td>minifikovaný</td></tr>
<tr><td>vector2.xml </td><td>40015</td><td>7</td><td>čitelný s&nbsp;odsazením</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: výhra formátu Gob je mj.&nbsp;způsobena
tím, že se pole ukládají jako homogenní datová struktura, tj.&nbsp;u
jednotlivých prvků není nutné specifikovat jejich typ. Tím lze oproti formátu
Message Pack ušetřit 1000 bajtů &ndash; ovšem z&nbsp;výsledků vidíme, že rozdíl
ve velikosti je jen 57 bajtů, což znamená, že Gob svou výhodu plně
nevyužil.</div></p>

<p>Při přenosech dat po síti se může (i transparentně) provádět komprimace dat,
takže si ještě pro zajímavost ukažme, jak se budou jednotlivé soubory lišit po
komprimaci GZIPem:</p>

<table>
<tr><th>Soubor</th><th>Velikost</th><th>Pořadí</th></tr>
<tr><td>vector1.bin.gz </td><td>5431</td><td>2</td></tr>
<tr><td>vector1.bson.gz</td><td>6537</td><td>3</td></tr>
<tr><td>vector1.gob.gz </td><td>5234</td><td>1</td></tr>
<tr><td>vector1.json.gz</td><td>7559</td><td>4</td></tr>
<tr><td>vector2.json.gz</td><td>7652</td><td>5</td></tr>
<tr><td>vector1.xml.gz </td><td>8182</td><td>6</td></tr>
<tr><td>vector2.xml.gz </td><td>8230</td><td>7</td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Serializace binárního stromu</h2>

<p>Druhý benchmark je založen na serializaci binárního stromu s&nbsp;255 uzly.
Samotnou konstrukci tohoto stromu (tak, aby byl vyvážený) zajišťuje tato
rekurzivní funkce:</p>

<pre>
func <strong>constructTree</strong>(bt *BinaryTree, min int, max int) {
        middle := (min + max) / 2
        if min &lt; middle &amp;&amp; middle &lt; max {
                fmt.Println(middle)
                bt.Insert(Item(middle))
                constructTree(bt, min, middle)
                constructTree(bt, middle, max)
        }
}
</pre>

<p>Opět si pochopitelně ukážeme celý zdrojový kód příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "encoding/gob"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "gopkg.in/mgo.v2/bson"
        "io/ioutil"
&nbsp;
        "github.com/ugorji/go/codec"
)
&nbsp;
type <strong>Item</strong> int
&nbsp;
type <strong>Node</strong> struct {
        Value Item
        Left  *Node
        Right *Node
}
&nbsp;
type <strong>BinaryTree</strong> struct {
        Root *Node
}
&nbsp;
func (bt *BinaryTree) <strong>Insert</strong>(value Item) {
        node := &amp;Node{value, nil, nil}
        if bt.Root == nil {
                bt.Root = node
        } else {
                insertNode(bt.Root, node)
        }
}
&nbsp;
func <strong>insertNode</strong>(node, newNode *Node) {
        if newNode.Value &lt; node.Value {
                if node.Left == nil {
                        node.Left = newNode
                } else {
                        insertNode(node.Left, newNode)
                }
        } else {
                if node.Right == nil {
                        node.Right = newNode
                } else {
                        insertNode(node.Right, newNode)
                }
        }
}
&nbsp;
func <strong>printTree</strong>(node *Node, level int) {
        if node != nil {
                format := ""
                for i := 0; i &lt; level; i++ {
                        format += "       "
                }
                format += "---[ "
                level++
                printTree(node.Left, level)
                fmt.Printf(format+"%d\n", node.Value)
                printTree(node.Right, level)
        }
}
&nbsp;
func <strong>encodeBinaryTreeIntoBSON</strong>(bt BinaryTree) ([]byte, error) {
        bsonOutput, err := bson.Marshal(bt)
&nbsp;
        if err != nil {
                return bsonOutput, err
        }
        return bsonOutput, nil
}
&nbsp;
func <strong>encodeBinaryTreeIntoJSON</strong>(bt BinaryTree) ([]byte, error) {
        jsonOutput, err := json.Marshal(bt)
&nbsp;
        if err != nil {
                return jsonOutput, err
        }
        return jsonOutput, nil
}
&nbsp;
func <strong>encodeBinaryTreeIntoIndentedJSON</strong>(bt BinaryTree) ([]byte, error) {
        jsonOutput, err := json.MarshalIndent(bt, "", "    ")
&nbsp;
        if err != nil {
                return jsonOutput, err
        }
        return jsonOutput, nil
}
&nbsp;
func <strong>encodeBinaryTreeIntoXML</strong>(bt BinaryTree) ([]byte, error) {
        xmlOutput, err := xml.Marshal(bt)
&nbsp;
        if err != nil {
                return xmlOutput, err
        }
        return xmlOutput, nil
}
&nbsp;
func <strong>encodeBinaryTreeIntoIndentedXML</strong>(bt BinaryTree) ([]byte, error) {
        xmlOutput, err := xml.MarshalIndent(bt, "", "    ")
&nbsp;
        if err != nil {
                return xmlOutput, err
        }
        return xmlOutput, nil
}
&nbsp;
func <strong>encodeBinaryTreeIntoGob</strong>(bt BinaryTree) ([]byte, error) {
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
&nbsp;
        err := encoder.Encode(bt)
        if err != nil {
                return buffer.Bytes(), err
        }
        return buffer.Bytes(), nil
}
&nbsp;
func <strong>encodeBinaryTreeIntoMsgPack</strong>(bt BinaryTree) ([]byte, error) {
        var buffer bytes.Buffer
&nbsp;
        <i>// handler</i>
        var handler codec.MsgpackHandle
&nbsp;
        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(&amp;buffer, &amp;handler)
&nbsp;
        <i>// zakódování dat</i>
        err := encoder.Encode(bt)
        if err != nil {
                return buffer.Bytes(), err
        }
        return buffer.Bytes(), nil
}
&nbsp;
func <strong>saveBinaryTree</strong>(encodedTree []byte, filename string) {
        err := ioutil.WriteFile(filename, encodedTree, 0644)
        if err != nil {
                fmt.Println(err)
        } else {
                fmt.Println("Stored into file", filename)
        }
}
&nbsp;
func <strong>constructTree</strong>(bt *BinaryTree, min, max int) {
        middle := (min + max) / 2
        if min &lt; middle && middle &lt; max {
                fmt.Println(middle)
                bt.Insert(Item(middle))
                constructTree(bt, min, middle)
                constructTree(bt, middle, max)
        }
}
&nbsp;
func <strong>printBufferInfo</strong>(buffer []byte) {
        fmt.Println("\nBuffer with encoded tree: ", len(buffer))
}
&nbsp;
func <strong>main</strong>() {
        var bt BinaryTree
        constructTree(&amp;bt, 0, 256)
&nbsp;
        printTree(bt.Root, 0)
&nbsp;
        encodedTree, err := encodeBinaryTreeIntoXML(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "/tmp/tree1.xml")
&nbsp;
        encodedTree, err = encodeBinaryTreeIntoIndentedXML(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "/tmp/tree2.xml")
&nbsp;
        encodedTree, err = encodeBinaryTreeIntoJSON(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "/tmp/tree1.json")
&nbsp;
        encodedTree, err = encodeBinaryTreeIntoIndentedJSON(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "/tmp/tree2.json")
&nbsp;
        encodedTree, err = encodeBinaryTreeIntoBSON(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "/tmp/tree1.bson")
&nbsp;
        encodedTree, err = encodeBinaryTreeIntoGob(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "/tmp/tree1.gob")
&nbsp;
        encodedTree, err = encodeBinaryTreeIntoMsgPack(bt)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedTree)
        saveBinaryTree(encodedTree, "/tmp/tree1.bin")

}
</pre>

<p>Průběh činnosti tohoto prográmku:</p>

<pre>
Buffer with encoded tree:  8076
Stored into file /tmp/tree1.xml
&nbsp;
Buffer with encoded tree:  31378
Stored into file /tmp/tree2.xml
&nbsp;
Buffer with encoded tree:  8575
Stored into file /tmp/tree1.json
&nbsp;
Buffer with encoded tree:  42115
Stored into file /tmp/tree2.json
&nbsp;
Buffer with encoded tree:  7406
Stored into file /tmp/tree1.bson
&nbsp;
Buffer with encoded tree:  1431
Stored into file /tmp/tree1.gob
&nbsp;
Buffer with encoded tree:  5363
Stored into file /tmp/tree1.bin
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Velikosti souborů se serializovaným binárním stromem</h2>

<p>Opět si jednotlivé soubory porovnejme podle velikosti:</p>

<table>
<tr><th>Soubor</th><th>Velikost</th><th>Pořadí</th><th>Poznámka</th></tr>
<tr><td>tree1.bin </td><td> 5363</td><td>2</td><td>rekurzivní struktura namísto stromu</td></tr>
<tr><td>tree1.bson</td><td> 7406</td><td>3</td><td>rekurzivní struktura namísto stromu</td></tr>
<tr><td>tree1.gob </td><td> 1431</td><td>1</td><td>skutečný strom s&nbsp;ukazateli na další uzly</td></tr>
<tr><td>tree1.json</td><td> 8575</td><td>4</td><td>minifikovaný</td></tr>
<tr><td>tree2.json</td><td>42115</td><td>6</td><td>čitelný s&nbsp;odsazením</td></tr>
<tr><td>tree1.xml </td><td> 8076</td><td>5</td><td>minifikovaný</td></tr>
<tr><td>tree2.xml </td><td>31378</td><td>7</td><td>čitelný s&nbsp;odsazením</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: na tomto místě je vhodné poznamenat, že
jedině formát Gob podporuje ukazatele, resp.&nbsp;přesněji řečeno reference
mezi uzly a jedná se tedy o jediný formát, který strom uloží v&nbsp;původní
podobě. Tomu také odpovídá naprosto nejmenší velikost výsledného binárního
souboru.</div></p>

<p>Použitím GZIPu se rozdíly do značné míry smažou, což jen vypovídá o tom,
kolik duplicitních dat se v&nbsp;původních souborech nacházelo:</p>

<table>
<tr><th>Soubor</th><th>Velikost</th><th>Pořadí</th></tr>
<tr><td>tree1.bin.gz </td><td> 745</td><td>2</td></tr>
<tr><td>tree1.bson.gz</td><td> 924</td><td>5</td></tr>
<tr><td>tree1.gob.gz </td><td> 714</td><td>1</td></tr>
<tr><td>tree1.json.gz</td><td> 840</td><td>3</td></tr>
<tr><td>tree2.json.gz</td><td>1474</td><td>7</td></tr>
<tr><td>tree1.xml.gz </td><td> 869</td><td>4</td></tr>
<tr><td>tree2.xml.gz </td><td>1306</td><td>6</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: paradoxně v&nbsp;tomto srovnání prohrává
BSON, i když se jedná o binární formát. Nezdá se však, že by byl vhodný pro
ukládání grafových struktur.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Serializace mapy, jejímiž klíči i hodnotami jsou řetězce</h2>

<p>Poslední porovnání velikosti souborů po serializaci dat provedeme
s&nbsp;mapou, jejímiž klíči i hodnotami jsou řetězce. S&nbsp;takovou mapou se
lze v&nbsp;praxi setkat velmi často &ndash; příkladem mohou být některé
konfigurační soubory atd. Mapa, kterou budeme ukládat, bude mít 260 dvojic
klíč-hodnota.</p>

<p><div class="rs-tip-major">Poznámka: důležité upozornění &ndash; mapy není
možné přímo ukládat do formátu XML, takže tento formát z&nbsp;dalšího porovnání
odstraníme. Důvodem je to, že mapa netvoří rekurzivní datovou strukturu,
přesněji u ní chybí kořenový uzel.</div></p>

<p>Program určený pro serializaci mapy do různých formátů bude vypadat
následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "bytes"
        "encoding/gob"
        "encoding/json"
        "fmt"
        "gopkg.in/mgo.v2/bson"
        "io/ioutil"
&nbsp;
        "github.com/ugorji/go/codec"
)
&nbsp;
type <strong>Map</strong> map[string]string
&nbsp;
func <strong>encodeMapIntoBSON</strong>(m Map) ([]byte, error) {
        bsonOutput, err := bson.Marshal(m)
&nbsp;
        if err != nil {
                return bsonOutput, err
        }
        return bsonOutput, nil
}
&nbsp;
func <strong>encodeMapIntoJSON</strong>(m Map) ([]byte, error) {
        jsonOutput, err := json.Marshal(m)
&nbsp;
        if err != nil {
                return jsonOutput, err
        }
        return jsonOutput, nil
}
&nbsp;
func <strong>encodeMapIntoIndentedJSON</strong>(m Map) ([]byte, error) {
        jsonOutput, err := json.MarshalIndent(m, "", "    ")
&nbsp;
        if err != nil {
                return jsonOutput, err
        }
        return jsonOutput, nil
}
&nbsp;
func <strong>encodeMapIntoGob</strong>(m Map) ([]byte, error) {
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
&nbsp;
        err := encoder.Encode(m)
        if err != nil {
                return buffer.Bytes(), err
        }
        return buffer.Bytes(), nil
}
&nbsp;
func <strong>encodeMapIntoMsgPack</strong>(m Map) ([]byte, error) {
        var buffer bytes.Buffer
&nbsp;
        <i>// handler</i>
        var handler codec.MsgpackHandle
&nbsp;
        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(&amp;buffer, &amp;handler)
&nbsp;
        <i>// zakódování dat</i>
        err := encoder.Encode(m)
        if err != nil {
                return buffer.Bytes(), err
        }
        return buffer.Bytes(), nil
}
&nbsp;
func <strong>saveMap</strong>(encodedMap []byte, filename string) {
        err := ioutil.WriteFile(filename, encodedMap, 0644)
        if err != nil {
                fmt.Println(err)
        } else {
                fmt.Println("Stored into file", filename)
        }
}
&nbsp;
func <strong>printBufferInfo</strong>(buffer []byte) {
        fmt.Println("\nBuffer with encoded map: ", len(buffer))
}
&nbsp;
func <strong>main</strong>() {
        var m Map = make(map[string]string)
        m["foo"] = "text"
        m["bar"] = "test"
        m["baz"] = "Příliš žluťoučký kůň"
        m["longer key"] = "Příliš žluťoučký kůň"
&nbsp;
        for i := 0; i &lt; 256; i++ {
                key := fmt.Sprintf("key: %02x", i)
                value := fmt.Sprintf("value: %d", i)
                m[key] = value
        }
&nbsp;
        encodedMap, err := encodeMapIntoJSON(m)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedMap)
        saveMap(encodedMap, "/tmp/map1.json")
&nbsp;
        encodedMap, err = encodeMapIntoIndentedJSON(m)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedMap)
        saveMap(encodedMap, "/tmp/map2.json")
&nbsp;
        encodedMap, err = encodeMapIntoBSON(m)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedMap)
        saveMap(encodedMap, "/tmp/map1.bson")
&nbsp;
        encodedMap, err = encodeMapIntoGob(m)
        if err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedMap)
        saveMap(encodedMap, "/tmp/map1.gob")
&nbsp;
        encodedMap, err = encodeMapIntoMsgPack(m)
        zif err != nil {
                fmt.Println(err)
                return
        }
        printBufferInfo(encodedMap)
        saveMap(encodedMap, "/tmp/map1.bin")
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Velikosti souborů se serializovanou mapou</h2>

<p>Opět si porovnejme velikosti výsledných souborů:</p>

<table>
<tr><th>Soubor</th><th>Velikost</th><th>Pořadí</th><th>Poznámka</th></tr>
<tr><td>map1.bin </td><td>4850</td><td>1</td><td>&nbsp;</td></tr>
<tr><td>map1.bson</td><td>6152</td><td>4</td><td>&nbsp;</td></tr>
<tr><td>map1.gob </td><td>4876</td><td>2</td><td>&nbsp;</td></tr>
<tr><td>map1.json</td><td>5888</td><td>3</td><td>minifikovaný</td></tr>
<tr><td>map2.json</td><td>7449</td><td>5</td><td>čitelný s&nbsp;odsazením</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: poprvé zde můžeme vidět významné změny
v&nbsp;pořadí. Zejména konečně vyhrál formát Message Pack (i když jen o 26
bajtů), ale navíc se ukazuje, že textový JSON může být úspornější než binární
formát BSON. Pokud je totiž JSON minifikovaný, bude každý řetězec uložen tak,
že se kromě binární podoby řetězce (UTF-8) navíc uloží pouze další dva bajty se
znakem uvozovek. Samotné &bdquo;zakódování&ldquo; mapy do JSONu si vyžádá další
čtyři bajty pro znaky &bdquo;{&ldquo;, &bdquo;:&ldquo;, &bdquo;}&ldquo; a
&bdquo;,&ldquo;, což opět není mnoho.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Rychlost serializace</h2>

<p>Nyní již máme představu o možnostech formátu Message Pack z&nbsp;hlediska
velikosti výsledných souborů (nebo posílaných datových bloků). Formát Message
Pack v&nbsp;tomto ohledu obstál; pouze formát Gob byl v&nbsp;některých ohledech
lepší. Zbývá nám však zjistit rychlost serializace, což je opět velmi důležitý
údaj, zejména v&nbsp;oblasti mikroslužeb, IoT atd. Nyní se však již pohybujeme
čistě na půdě programovacího jazyka Go a serializačních knihoven určených pro
tento jazyk &ndash; v&nbsp;případě použití jiného jazyka a/nebo knihovny totiž
můžeme dostat odlišné rychlosti (ovšem velikosti souborů zůstanou stále
stejné).</p>

<p>Rychlost serializace si ověříme na kódu odvozeného od předchozího
demonstračního příkladu. Bude se jednat o sadu funkcí pro serializaci mapy do
různých formátů, ovšem s&nbsp;tím, že serializace bude provedena pouze do
paměti &ndash; nebudeme tedy zahrnovat rychlost I/O operací:</p>

<pre>
type <strong>Map</strong> map[string]string
&nbsp;
func <strong>encodeMapIntoBSON</strong>(m Map) ([]byte, error) {
        bsonOutput, err := bson.Marshal(m)
&nbsp;
        if err != nil {
                return bsonOutput, err
        }
        return bsonOutput, nil
}
&nbsp;
func <strong>encodeMapIntoJSON</strong>(m Map) ([]byte, error) {
        jsonOutput, err := json.Marshal(m)
&nbsp;
        if err != nil {
                return jsonOutput, err
        }
        return jsonOutput, nil
}
&nbsp;
func <strong>encodeMapIntoIndentedJSON</strong>(m Map) ([]byte, error) {
        jsonOutput, err := json.MarshalIndent(m, "", "    ")
&nbsp;
        if err != nil {
                return jsonOutput, err
        }
        return jsonOutput, nil
}
&nbsp;
func <strong>encodeMapIntoGob</strong>(m Map) ([]byte, error) {
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
&nbsp;
        err := encoder.Encode(m)
        if err != nil {
                return buffer.Bytes(), err
        }
        return buffer.Bytes(), nil
}
&nbsp;
func <strong>encodeMapIntoMsgPack</strong>(m Map) ([]byte, error) {
        var buffer bytes.Buffer
&nbsp;
        <i>// handler</i>
        var handler codec.MsgpackHandle
&nbsp;
        <i>// objekt realizující zakódování dat</i>
        encoder := codec.NewEncoder(&amp;buffer, &amp;handler)
&nbsp;
        <i>// zakódování dat</i>
        err := encoder.Encode(m)
        if err != nil {
                return buffer.Bytes(), err
        }
        return buffer.Bytes(), nil
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Benchmark měřící rychlost serializace</h2>

<p>Samotný benchmark využívá základní sadu nástrojů programovacího jazyka Go.
Modul určený pro spouštění jednotkových testů totiž dokáže spouštět i
benchmarky a následně vyhodnocovat rychlost jednotlivých funkcí pro různé
velikosti vstupní veličiny. Tato veličina je automaticky měněna takovým
způsobem, aby benchmarky byly dokončeny po určité době, a to na každém hardware
(tedy na rychlém počítači bude provedeno větší množství iterací a naopak).
Následně jsou výsledky benchmarků v&nbsp;čitelné podobě vypsány.</p>

<p>Nejprve si ukažme pomocnou funkci pro konstrukci mapy zadané velikosti,
která je následně serializována:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
&nbsp;
        "testing"
)
&nbsp;
func <strong>createMap</strong>(n int) Map {
        var m Map = make(map[string]string)
        m["foo"] = "text"
        m["bar"] = "test"
        m["baz"] = "Příliš žluťoučký kůň"
        m["longer key"] = "Příliš žluťoučký kůň"
&nbsp;
        for i := 0; i &lt; n; i++ {
                key := fmt.Sprintf("key: %02x", i)
                value := fmt.Sprintf("value: %d", i)
                m[key] = value
        }
        return m
}
</pre>

<p>Následuje vlastní realizace benchmarku, který opakovaně volá funkci
<strong>f</strong>, která má provádět serializaci vstupní mapy. Za
<strong>f</strong> se dosadí libovolná funkce <a href="#k15">z&nbsp;předchozí
kapitoly</a>:</p>

<pre>
func <strong>benchmark</strong>(b *testing.B, n int, f func(m Map) ([]byte, error)) {
        m := createMap(n)
        for i := 0; i &lt; b.N; i++ {
                f(m)
        }
}
</pre>

<p>Testovat postupně budeme serializaci mapy s&nbsp;4+1 prvkem, 4+100 prvky a
4+1000 prvky. A měřit pochopitelně budeme serializaci do formátů BSON,
minifikovaný JSON, čitelný JSON a Message Pack:</p>

<pre>
func <strong>BenchmarkBSON1</strong>(b *testing.B) {
        benchmark(b, 1, encodeMapIntoBSON)
}
&nbsp;
func <strong>BenchmarkBSON100</strong>(b *testing.B) {
        benchmark(b, 100, encodeMapIntoBSON)
}
&nbsp;
func <strong>BenchmarkBSON1000</strong>(b *testing.B) {
        benchmark(b, 1000, encodeMapIntoBSON)
}
&nbsp;
func <strong>BenchmarkJSON1</strong>(b *testing.B) {
        benchmark(b, 1, encodeMapIntoJSON)
}
&nbsp;
func <strong>BenchmarkJSON100</strong>(b *testing.B) {
        benchmark(b, 100, encodeMapIntoJSON)
}
&nbsp;
func <strong>BenchmarkJSON1000</strong>(b *testing.B) {
        benchmark(b, 1000, encodeMapIntoJSON)
}
&nbsp;
func <strong>BenchmarkIndentedJSON1</strong>(b *testing.B) {
        benchmark(b, 1, encodeMapIntoIndentedJSON)
}
&nbsp;
func <strong>BenchmarkIndentedJSON100</strong>(b *testing.B) {
        benchmark(b, 100, encodeMapIntoIndentedJSON)
}
&nbsp;
func <strong>BenchmarkIndentedJSON1000</strong>(b *testing.B) {
        benchmark(b, 1000, encodeMapIntoIndentedJSON)
}
&nbsp;
func <strong>BenchmarkGob1</strong>(b *testing.B) {
        benchmark(b, 1, encodeMapIntoGob)
}
&nbsp;
func <strong>BenchmarkGob100</strong>(b *testing.B) {
        benchmark(b, 100, encodeMapIntoGob)
}
&nbsp;
func <strong>BenchmarkGob1000</strong>(b *testing.B) {
        benchmark(b, 1000, encodeMapIntoGob)
}
&nbsp;
func <strong>BenchmarkMsgPack1</strong>(b *testing.B) {
        benchmark(b, 1, encodeMapIntoMsgPack)
}
&nbsp;
func <strong>BenchmarkMsgPack100</strong>(b *testing.B) {
        benchmark(b, 100, encodeMapIntoMsgPack)
}
&nbsp;
func <strong>BenchmarkMsgPack1000</strong>(b *testing.B) {
        benchmark(b, 1000, encodeMapIntoMsgPack)
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Výsledky benchmarku</h2>

<p>Samotný benchmark se spustí tímto příkazem:</p>

<pre>
$ <strong>go test -bench=.</strong>
</pre>

<p>Získané výsledky mohou vypadat následovně:</p>

<pre>
goos: linux
goarch: amd64
pkg: msgpack-test
cpu: Intel(R) Core(TM) i7-8665U CPU @ 1.90GHz
BenchmarkBSON1-8                  933855              1121 ns/op
BenchmarkBSON100-8                 62947             21862 ns/op
BenchmarkBSON1000-8                 5594            191998 ns/op
BenchmarkJSON1-8                  848180              1400 ns/op
BenchmarkJSON100-8                 44877             27312 ns/op
BenchmarkJSON1000-8                 3687            343840 ns/op
BenchmarkIndentedJSON1-8          454699              2566 ns/op
BenchmarkIndentedJSON100-8         27103             45834 ns/op
BenchmarkIndentedJSON1000-8         2395            504380 ns/op
BenchmarkGob1-8                   568262              2425 ns/op
BenchmarkGob100-8                  68746             23603 ns/op
BenchmarkGob1000-8                  7363            159924 ns/op
BenchmarkMsgPack1-8               847807              1351 ns/op
BenchmarkMsgPack100-8             231123              5438 ns/op
BenchmarkMsgPack1000-8             26774             46252 ns/op
PASS
ok      msgpack-test    21.273s
</pre>

<p>Lepší bude výsledky roztřídit podle velikosti mapy:</p>

<pre>
BenchmarkBSON1-8                  933855              1121 ns/op
BenchmarkJSON1-8                  848180              1400 ns/op
BenchmarkIndentedJSON1-8          454699              2566 ns/op
BenchmarkGob1-8                   568262              2425 ns/op
BenchmarkMsgPack1-8               847807              1351 ns/op
&nbsp;
BenchmarkBSON100-8                 62947             21862 ns/op
BenchmarkJSON100-8                 44877             27312 ns/op
BenchmarkIndentedJSON100-8         27103             45834 ns/op
BenchmarkGob100-8                  68746             23603 ns/op
BenchmarkMsgPack100-8             231123              5438 ns/op
&nbsp;
BenchmarkBSON1000-8                 5594            191998 ns/op
BenchmarkJSON1000-8                 3687            343840 ns/op
BenchmarkIndentedJSON1000-8         2395            504380 ns/op
BenchmarkGob1000-8                  7363            159924 ns/op
BenchmarkMsgPack1000-8             26774             46252 ns/op
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že formát Message Pack,
resp.&nbsp;přesněji řečeno použitá serializační knihovna Message Packu, je
absolutně nejrychlejší už pro relativně malé mapy se 104 prvky (a ještě
významněji pro větší mapy). To je poněkud překvapující zjištění, protože osobně
bych čekal, že zvítězí formát Gob.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Kam dál?</h2>

<p>Formát Message Pack je vhodný použít v&nbsp;situacích, kdy je nutné rychle
přenášet velké množství dat, která navíc musí být &bdquo;samopopisná&ldquo;,
což znamená, že u každé datové položky je určen (uložen) i její datový typ.
V&nbsp;případě, že &bdquo;samopopisnost&ldquo; není vyžadována, tj.&nbsp;ve
chvíli, kdy obě komunikující strany očekávají shodný formát dat, nebo si formát
předají jiným kanálem, může být výhodnější použít <i>Protocol Buffers</i>
neboli <i>Protobuf</i>. To je však již téma na samostatný článek.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech <a
href="https://www.root.cz/clanky/komunikace-realizovana-uspornym-binarnim-formatem-messagepack/">minule</a>
i dnes použitých demonstračních příkladů byly uloženy do nového Git repositáře,
který je dostupný na adrese <a
href="https://github.com/tisnik/go-root">https://github.com/tisnik/go-root</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
přibližně stovku kilobajtů), můžete namísto toho použít odkazy na jednotlivé
demonstrační příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad/soubor</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>msgpack_nil.go</td><td>serializace hodnoty <strong>nil</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_nil.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_nil.go</a></td></tr>
<tr><td> 2</td><td>msgpack_true.go</td><td>serializace hodnot <strong>true</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_true.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_true.go</a></td></tr>
<tr><td> 3</td><td>msgpack_false.go</td><td>serializace hodnot <strong>false</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_false.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_false.go</a></td></tr>
<tr><td> 4</td><td>msgpack_small_int.go</td><td>serializace celočíselné hodnoty menší než 127</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_small_int.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_small_int.go</a></td></tr>
<tr><td> 5</td><td>msgpack_longer_int.go</td><td>serializace celočíselné hodnoty menší než 2<sup>16</sup></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_longer_int.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_longer_int.go</a></td></tr>
<tr><td> 6</td><td>msgpack_even_longer_int.go</td><td>serializace celočíselné hodnoty větší než 2<sup>16</sup></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_even_longer_int.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_even_longer_int.go</a></td></tr>
<tr><td> 7</td><td>msgpack_long_int.go</td><td>serializace celočíselné hodnoty větší než 2<sup>32</sup></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_long_int.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_long_int.go</a></td></tr>
<tr><td> 8</td><td>msgpack_single.go</td><td>serializace hodnoty s&nbsp;plovoucí řádovou čárkou (<i>single</i>)</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_single.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_single.go</a></td></tr>
<tr><td> 9</td><td>msgpack_double.go</td><td>serializace hodnoty s&nbsp;plovoucí řádovou čárkou (<i>double</i>)</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_double.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_double.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>msgpack_short_string.go</td><td>serializace krátkého řetězce (méně než 31 znaků)</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_short_string.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_short_string.go</a></td></tr>
<tr><td>11</td><td>msgpack_longer_string.go</td><td>serializace delšího řetězce (méně než 256 znaků)</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_longer_string.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_longer_string.go</a></td></tr>
<tr><td>12</td><td>msgpack_even_longer_string.go</td><td>serializace dlouhého řetězce</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_even_longer_string.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_even_longer_string.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>msgpack_short_array1.go</td><td>krátké pole čtyř hodnot 1-4</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_short_array1.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_short_array1.go</a></td></tr>
<tr><td>14</td><td>msgpack_short_array2.go</td><td>krátké pole čtyř hodnot 100, 200, 300 a 400</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_short_array2.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_short_array2.go</a></td></tr>
<tr><td>15</td><td>msgpack_bytes.go</td><td>pole 1000 bajtů</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_bytes.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_bytes.go</a></td></tr>
<tr><td>16</td><td>msgpack_array_16A.go</td><td>pole 1000 prvků typu <strong>int</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16A.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16A.go</a></td></tr>
<tr><td>17</td><td>msgpack_array_16B.go</td><td>pole 1000 prvků typu <strong>uint</strong></td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16B.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16B.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>msgpack_map.go</td><td>serializace mapy</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_map.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_map.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>msgpack_array_16C.go</td><td>pole vzniklé serializací řezu (<i>slice</i>)</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16C.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16C.go</a></td></tr>
<tr><td>20</td><td>msgpack_array_16D.go</td><td>serializace heterogenního pole</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16D.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_array_16D.go</a></td></tr>
<tr><td>21</td><td>msgpack_map2.go</td><td>serializace heterogenní mapy</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_map2.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_map2.go</a></td></tr>
<tr><td>22</td><td>msgpack_timestamp.go</td><td>serializace časového razítka</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_timestamp.go">https://github.com/tisnik/go-root/blob/master/msgpack/msgpack_timestamp.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>size_comparison_A.go</td><td>porovnání velikosti vektorů typu float64 po jejich serializaci do různých formátů</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/size_comparison_A.go">https://github.com/tisnik/go-root/blob/master/msgpack/size_comparison_A.go</a></td></tr>
<tr><td>23</td><td>size_comparison_B.go</td><td>porovnání velikosti binárních stromů po jejich serializaci do různých formátů</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/size_comparison_B.go">https://github.com/tisnik/go-root/blob/master/msgpack/size_comparison_B.go</a></td></tr>
<tr><td>24</td><td>size_comparison_C.go</td><td>porovnání velikosti map po jejich serializaci do různých formátů</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/size_comparison_C.go">https://github.com/tisnik/go-root/blob/master/msgpack/size_comparison_C.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>benchmark/</td><td>měření rychlosti serializace map do různých formátů</td><td><a href="https://github.com/tisnik/go-root/blob/master/msgpack/benchmark">https://github.com/tisnik/go-root/blob/master/msgpack/benchmark</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Základní informace o MessagePacku<br />
<a href="https://msgpack.org/">https://msgpack.org/</a>
</li>

<li>MessagePack na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/MessagePack">https://en.wikipedia.org/wiki/MessagePack</a>
</li>

<li>Comparison of data-serialization formats (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats">https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats</a>
</li>

<li>Repositáře msgpacku<br />
<a href="https://github.com/msgpack">https://github.com/msgpack</a>
</li>

<li>Specifikace ukládání různých typů dat<br />
<a href="https://github.com/msgpack/msgpack/blob/master/spec.md">https://github.com/msgpack/msgpack/blob/master/spec.md</a>
</li>

<li>Podpora MessagePacku v&nbsp;různých jazycích<br />
<a href="https://msgpack.org/#languages">https://msgpack.org/#languages</a>
</li>

<li>Základní implementace formátu msgpack pro Go<br />
<a href="https://github.com/msgpack/msgpack-go">https://github.com/msgpack/msgpack-go</a>
</li>

<li>go-codec<br />
<a href="https://github.com/ugorji/go">https://github.com/ugorji/go</a>
</li>

<li>Gobs of data<br />
<a href="https://blog.golang.org/gobs-of-data">https://blog.golang.org/gobs-of-data</a>
</li>

<li>Formát BSON<br />
<a href="http://bsonspec.org/">http://bsonspec.org/</a>
</li>

<li>Problematika nulových hodnot v Go, aneb proč nil != nil<br />
<a href="https://www.root.cz/clanky/problematika-nulovych-hodnot-v-go-aneb-proc-nil-nil/">https://www.root.cz/clanky/problematika-nulovych-hodnot-v-go-aneb-proc-nil-nil/</a>
</li>

<li>IEEE-754 Floating Point Converter<br />
<a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">https://www.h-schmidt.net/FloatConverter/IEEE754.html</a>
</li>

<li>Base Convert: IEEE 754 Floating Point<br />
<a href="https://baseconvert.com/ieee-754-floating-point">https://baseconvert.com/ieee-754-floating-point</a>
</li>

<li>Brain Floating Point – nový formát uložení čísel pro strojové učení a chytrá čidla<br />
<a href="https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/">https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

